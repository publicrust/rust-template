using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Sprites;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UILineRendererList")]
[RequireComponent(typeof(RectTransform))]
public class UILineRendererList : UIPrimitiveBase
{
	private enum SegmentType
	{
		Start,
		Middle,
		End,
		Full
	}

	public enum JoinType
	{
		Bevel,
		Miter
	}

	public enum BezierType
	{
		None,
		Quick,
		Basic,
		Improved,
		Catenary
	}

	private const float MIN_MITER_JOIN = MathF.PI / 12f;

	private const float MIN_BEVEL_NICE_JOIN = MathF.PI / 6f;

	private static Vector2 UV_TOP_LEFT;

	private static Vector2 UV_BOTTOM_LEFT;

	private static Vector2 UV_TOP_CENTER_LEFT;

	private static Vector2 UV_TOP_CENTER_RIGHT;

	private static Vector2 UV_BOTTOM_CENTER_LEFT;

	private static Vector2 UV_BOTTOM_CENTER_RIGHT;

	private static Vector2 UV_TOP_RIGHT;

	private static Vector2 UV_BOTTOM_RIGHT;

	private static Vector2[] startUvs;

	private static Vector2[] middleUvs;

	private static Vector2[] endUvs;

	private static Vector2[] fullUvs;

	[Tooltip("Points to draw lines between\n Can be improved using the Resolution Option")]
	[SerializeField]
	internal List<Vector2> m_points;

	[SerializeField]
	[Tooltip("Thickness of the line")]
	internal float lineThickness = 2f;

	[SerializeField]
	[Tooltip("Use the relative bounds of the Rect Transform (0,0 -> 0,1) or screen space coordinates")]
	internal bool relativeSize;

	[SerializeField]
	[Tooltip("Do the points identify a single line or split pairs of lines")]
	internal bool lineList;

	[Tooltip("Add end caps to each line\nMultiple caps when used with Line List")]
	[SerializeField]
	internal bool lineCaps;

	[Tooltip("Resolution of the Bezier curve, different to line Resolution")]
	[SerializeField]
	internal int bezierSegmentsPerCurve = 10;

	[Tooltip("The type of Join used between lines, Square/Mitre or Curved/Bevel")]
	public JoinType LineJoins;

	[Tooltip("Bezier method to apply to line, see docs for options\nCan't be used in conjunction with Resolution as Bezier already changes the resolution")]
	public BezierType BezierMode;

	[HideInInspector]
	public bool drivenExternally;

	public float LineThickness
	{
		get
		{
			return lineThickness;
		}
		set
		{
			lineThickness = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool RelativeSize
	{
		get
		{
			return relativeSize;
		}
		set
		{
			relativeSize = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineList
	{
		get
		{
			return lineList;
		}
		set
		{
			lineList = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool LineCaps
	{
		get
		{
			return lineCaps;
		}
		set
		{
			lineCaps = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public int BezierSegmentsPerCurve
	{
		get
		{
			return bezierSegmentsPerCurve;
		}
		set
		{
			bezierSegmentsPerCurve = value;
		}
	}

	public List<Vector2> Points
	{
		get
		{
			return m_points;
		}
		set
		{
			if (m_points != value)
			{
				m_points = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	public void AddPoint(Vector2 pointToAdd)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		m_points.Add(pointToAdd);
		((Graphic)this).SetAllDirty();
	}

	public void RemovePoint(Vector2 pointToRemove)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		m_points.Remove(pointToRemove);
		((Graphic)this).SetAllDirty();
	}

	public void ClearPoints()
	{
		m_points.Clear();
		((Graphic)this).SetAllDirty();
	}

	private void PopulateMesh(VertexHelper vh, List<Vector2> pointsToDraw)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0346: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0544: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0577: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_058f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_045a: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0472: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_048a: Unknown result type (might be due to invalid IL or missing references)
		//IL_048c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0515: Unknown result type (might be due to invalid IL or missing references)
		//IL_052b: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
		if (BezierMode != 0 && BezierMode != BezierType.Catenary && pointsToDraw.Count > 3)
		{
			BezierPath bezierPath = new BezierPath();
			bezierPath.SetControlPoints(pointsToDraw);
			bezierPath.SegmentsPerCurve = bezierSegmentsPerCurve;
			pointsToDraw = BezierMode switch
			{
				BezierType.Basic => bezierPath.GetDrawingPoints0(), 
				BezierType.Improved => bezierPath.GetDrawingPoints1(), 
				_ => bezierPath.GetDrawingPoints2(), 
			};
		}
		if (BezierMode == BezierType.Catenary && pointsToDraw.Count == 2)
		{
			CableCurve cableCurve = new CableCurve(pointsToDraw);
			cableCurve.slack = base.Resoloution;
			cableCurve.steps = BezierSegmentsPerCurve;
			pointsToDraw.Clear();
			pointsToDraw.AddRange(cableCurve.Points());
		}
		if (base.ImproveResolution != 0)
		{
			pointsToDraw = IncreaseResolution(pointsToDraw);
		}
		Rect rect;
		float num;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num = ((Rect)(ref rect)).width;
		}
		else
		{
			num = 1f;
		}
		float num2 = num;
		float num3;
		if (relativeSize)
		{
			rect = ((Graphic)this).rectTransform.rect;
			num3 = ((Rect)(ref rect)).height;
		}
		else
		{
			num3 = 1f;
		}
		float num4 = num3;
		float num5 = (0f - ((Graphic)this).rectTransform.pivot.x) * num2;
		float num6 = (0f - ((Graphic)this).rectTransform.pivot.y) * num4;
		List<UIVertex[]> list = new List<UIVertex[]>();
		if (lineList)
		{
			for (int i = 1; i < pointsToDraw.Count; i += 2)
			{
				Vector2 val = pointsToDraw[i - 1];
				Vector2 val2 = pointsToDraw[i];
				((Vector2)(ref val))..ctor(val.x * num2 + num5, val.y * num4 + num6);
				((Vector2)(ref val2))..ctor(val2.x * num2 + num5, val2.y * num4 + num6);
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val, val2, SegmentType.Middle));
				if (lineCaps)
				{
					list.Add(CreateLineCap(val, val2, SegmentType.End));
				}
			}
		}
		else
		{
			for (int j = 1; j < pointsToDraw.Count; j++)
			{
				Vector2 val3 = pointsToDraw[j - 1];
				Vector2 val4 = pointsToDraw[j];
				((Vector2)(ref val3))..ctor(val3.x * num2 + num5, val3.y * num4 + num6);
				((Vector2)(ref val4))..ctor(val4.x * num2 + num5, val4.y * num4 + num6);
				if (lineCaps && j == 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.Start));
				}
				list.Add(CreateLineSegment(val3, val4, SegmentType.Middle));
				if (lineCaps && j == pointsToDraw.Count - 1)
				{
					list.Add(CreateLineCap(val3, val4, SegmentType.End));
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			if (!lineList && k < list.Count - 1)
			{
				Vector3 val5 = list[k][1].position - list[k][2].position;
				Vector3 val6 = list[k + 1][2].position - list[k + 1][1].position;
				float num7 = Vector2.Angle(Vector2.op_Implicit(val5), Vector2.op_Implicit(val6)) * (MathF.PI / 180f);
				float num8 = Mathf.Sign(Vector3.Cross(((Vector3)(ref val5)).normalized, ((Vector3)(ref val6)).normalized).z);
				float num9 = lineThickness / (2f * Mathf.Tan(num7 / 2f));
				Vector3 position = list[k][2].position - ((Vector3)(ref val5)).normalized * num9 * num8;
				Vector3 position2 = list[k][3].position + ((Vector3)(ref val5)).normalized * num9 * num8;
				JoinType joinType = LineJoins;
				if (joinType == JoinType.Miter)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 12f)
					{
						list[k][2].position = position;
						list[k][3].position = position2;
						list[k + 1][0].position = position2;
						list[k + 1][1].position = position;
					}
					else
					{
						joinType = JoinType.Bevel;
					}
				}
				if (joinType == JoinType.Bevel)
				{
					if (num9 < ((Vector3)(ref val5)).magnitude / 2f && num9 < ((Vector3)(ref val6)).magnitude / 2f && num7 > MathF.PI / 6f)
					{
						if (num8 < 0f)
						{
							list[k][2].position = position;
							list[k + 1][1].position = position;
						}
						else
						{
							list[k][3].position = position2;
							list[k + 1][0].position = position2;
						}
					}
					UIVertex[] array = (UIVertex[])(object)new UIVertex[4]
					{
						list[k][2],
						list[k][3],
						list[k + 1][0],
						list[k + 1][1]
					};
					vh.AddUIVertexQuad(array);
				}
			}
			vh.AddUIVertexQuad(list[k]);
		}
		if (vh.currentVertCount > 64000)
		{
			Debug.LogError((object)("Max Verticies size is 64000, current mesh vertcies count is [" + vh.currentVertCount + "] - Cannot Draw"));
			vh.Clear();
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		if (m_points != null && m_points.Count > 0)
		{
			GeneratedUVs();
			vh.Clear();
			PopulateMesh(vh, m_points);
		}
	}

	private UIVertex[] CreateLineCap(Vector2 start, Vector2 end, SegmentType type)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val;
		switch (type)
		{
		case SegmentType.Start:
		{
			val = end - start;
			Vector2 start2 = start - ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(start2, start, SegmentType.Start);
		}
		case SegmentType.End:
		{
			val = end - start;
			Vector2 end2 = end + ((Vector2)(ref val)).normalized * lineThickness / 2f;
			return CreateLineSegment(end, end2, SegmentType.End);
		}
		default:
			Debug.LogError((object)"Bad SegmentType passed in to CreateLineCap. Must be SegmentType.Start or SegmentType.End");
			return null;
		}
	}

	private UIVertex[] CreateLineSegment(Vector2 start, Vector2 end, SegmentType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = new Vector2(start.y - end.y, end.x - start.x);
		Vector2 val2 = ((Vector2)(ref val)).normalized * lineThickness / 2f;
		Vector2 val3 = start - val2;
		Vector2 val4 = start + val2;
		Vector2 val5 = end + val2;
		Vector2 val6 = end - val2;
		return type switch
		{
			SegmentType.Start => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, startUvs), 
			SegmentType.End => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, endUvs), 
			SegmentType.Full => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, fullUvs), 
			_ => SetVbo((Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }, middleUvs), 
		};
	}

	protected override void GeneratedUVs()
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)base.activeSprite != (Object)null)
		{
			Vector4 outerUV = DataUtility.GetOuterUV(base.activeSprite);
			Vector4 innerUV = DataUtility.GetInnerUV(base.activeSprite);
			UV_TOP_LEFT = new Vector2(outerUV.x, outerUV.y);
			UV_BOTTOM_LEFT = new Vector2(outerUV.x, outerUV.w);
			UV_TOP_CENTER_LEFT = new Vector2(innerUV.x, innerUV.y);
			UV_TOP_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.y);
			UV_BOTTOM_CENTER_LEFT = new Vector2(innerUV.x, innerUV.w);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(innerUV.z, innerUV.w);
			UV_TOP_RIGHT = new Vector2(outerUV.z, outerUV.y);
			UV_BOTTOM_RIGHT = new Vector2(outerUV.z, outerUV.w);
		}
		else
		{
			UV_TOP_LEFT = Vector2.zero;
			UV_BOTTOM_LEFT = new Vector2(0f, 1f);
			UV_TOP_CENTER_LEFT = new Vector2(0.5f, 0f);
			UV_TOP_CENTER_RIGHT = new Vector2(0.5f, 0f);
			UV_BOTTOM_CENTER_LEFT = new Vector2(0.5f, 1f);
			UV_BOTTOM_CENTER_RIGHT = new Vector2(0.5f, 1f);
			UV_TOP_RIGHT = new Vector2(1f, 0f);
			UV_BOTTOM_RIGHT = Vector2.one;
		}
		startUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_CENTER_LEFT, UV_TOP_CENTER_LEFT };
		middleUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_LEFT, UV_BOTTOM_CENTER_LEFT, UV_BOTTOM_CENTER_RIGHT, UV_TOP_CENTER_RIGHT };
		endUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_CENTER_RIGHT, UV_BOTTOM_CENTER_RIGHT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
		fullUvs = (Vector2[])(object)new Vector2[4] { UV_TOP_LEFT, UV_BOTTOM_LEFT, UV_BOTTOM_RIGHT, UV_TOP_RIGHT };
	}

	protected override void ResolutionToNativeSize(float distance)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (base.UseNativeSize)
		{
			Rect rect = base.activeSprite.rect;
			m_Resolution = distance / (((Rect)(ref rect)).width / base.pixelsPerUnit);
			rect = base.activeSprite.rect;
			lineThickness = ((Rect)(ref rect)).height / base.pixelsPerUnit;
		}
	}
}


private enum SegmentType
{
	Start,
	Middle,
	End,
	Full
}


public enum JoinType
{
	Bevel,
	Miter
}


public enum BezierType
{
	None,
	Quick,
	Basic,
	Improved,
	Catenary
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UILineTextureRenderer")]
public class UILineTextureRenderer : UIPrimitiveBase
{
	[SerializeField]
	private Rect m_UVRect = new Rect(0f, 0f, 1f, 1f);

	[SerializeField]
	private Vector2[] m_points;

	public float LineThickness = 2f;

	public bool UseMargins;

	public Vector2 Margin;

	public bool relativeSize;

	public Rect uvRect
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_UVRect;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			if (!(m_UVRect == value))
			{
				m_UVRect = value;
				((Graphic)this).SetVerticesDirty();
			}
		}
	}

	public Vector2[] Points
	{
		get
		{
			return m_points;
		}
		set
		{
			if (m_points != value)
			{
				m_points = value;
				((Graphic)this).SetAllDirty();
			}
		}
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_038b: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_0475: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0489: Unknown result type (might be due to invalid IL or missing references)
		//IL_0490: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_054b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0552: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_055b: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0564: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_0577: Unknown result type (might be due to invalid IL or missing references)
		//IL_0579: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_057d: Unknown result type (might be due to invalid IL or missing references)
		//IL_051b: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_052f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		if (m_points == null || m_points.Length < 2)
		{
			m_points = (Vector2[])(object)new Vector2[2]
			{
				new Vector2(0f, 0f),
				new Vector2(1f, 1f)
			};
		}
		int num = 24;
		Rect rect = ((Graphic)this).rectTransform.rect;
		float num2 = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float num3 = ((Rect)(ref rect)).height;
		float num4 = 0f - ((Graphic)this).rectTransform.pivot.x;
		rect = ((Graphic)this).rectTransform.rect;
		float num5 = num4 * ((Rect)(ref rect)).width;
		float num6 = 0f - ((Graphic)this).rectTransform.pivot.y;
		rect = ((Graphic)this).rectTransform.rect;
		float num7 = num6 * ((Rect)(ref rect)).height;
		if (!relativeSize)
		{
			num2 = 1f;
			num3 = 1f;
		}
		List<Vector2> list = new List<Vector2>();
		list.Add(m_points[0]);
		Vector2 val = m_points[0];
		Vector2 val2 = m_points[1] - m_points[0];
		Vector2 item = val + ((Vector2)(ref val2)).normalized * (float)num;
		list.Add(item);
		for (int i = 1; i < m_points.Length - 1; i++)
		{
			list.Add(m_points[i]);
		}
		Vector2 val3 = m_points[m_points.Length - 1];
		val2 = m_points[m_points.Length - 1] - m_points[m_points.Length - 2];
		item = val3 - ((Vector2)(ref val2)).normalized * (float)num;
		list.Add(item);
		list.Add(m_points[m_points.Length - 1]);
		Vector2[] array = list.ToArray();
		if (UseMargins)
		{
			num2 -= Margin.x;
			num3 -= Margin.y;
			num5 += Margin.x / 2f;
			num7 += Margin.y / 2f;
		}
		vh.Clear();
		Vector2 val4 = Vector2.zero;
		Vector2 val5 = Vector2.zero;
		Vector2 val12 = default(Vector2);
		Vector2 val13 = default(Vector2);
		Vector2 val14 = default(Vector2);
		Vector2 val15 = default(Vector2);
		Vector2 val16 = default(Vector2);
		for (int j = 1; j < array.Length; j++)
		{
			Vector2 val6 = array[j - 1];
			Vector2 val7 = array[j];
			((Vector2)(ref val6))..ctor(val6.x * num2 + num5, val6.y * num3 + num7);
			((Vector2)(ref val7))..ctor(val7.x * num2 + num5, val7.y * num3 + num7);
			float num8 = Mathf.Atan2(val7.y - val6.y, val7.x - val6.x) * 180f / MathF.PI;
			Vector2 val8 = val6 + new Vector2(0f, (0f - LineThickness) / 2f);
			Vector2 val9 = val6 + new Vector2(0f, LineThickness / 2f);
			Vector2 val10 = val7 + new Vector2(0f, LineThickness / 2f);
			Vector2 val11 = val7 + new Vector2(0f, (0f - LineThickness) / 2f);
			val8 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val8), Vector2.op_Implicit(val6), new Vector3(0f, 0f, num8)));
			val9 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val9), Vector2.op_Implicit(val6), new Vector3(0f, 0f, num8)));
			val10 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val10), Vector2.op_Implicit(val7), new Vector3(0f, 0f, num8)));
			val11 = Vector2.op_Implicit(RotatePointAroundPivot(Vector2.op_Implicit(val11), Vector2.op_Implicit(val7), new Vector3(0f, 0f, num8)));
			Vector2 zero = Vector2.zero;
			((Vector2)(ref val12))..ctor(0f, 1f);
			((Vector2)(ref val13))..ctor(0.5f, 0f);
			((Vector2)(ref val14))..ctor(0.5f, 1f);
			((Vector2)(ref val15))..ctor(1f, 0f);
			((Vector2)(ref val16))..ctor(1f, 1f);
			Vector2[] uvs = (Vector2[])(object)new Vector2[4] { val13, val14, val14, val13 };
			if (j > 1)
			{
				vh.AddUIVertexQuad(SetVbo((Vector2[])(object)new Vector2[4] { val4, val5, val8, val9 }, uvs));
			}
			if (j == 1)
			{
				uvs = (Vector2[])(object)new Vector2[4] { zero, val12, val14, val13 };
			}
			else if (j == array.Length - 1)
			{
				uvs = (Vector2[])(object)new Vector2[4] { val13, val14, val16, val15 };
			}
			vh.AddUIVertexQuad(SetVbo((Vector2[])(object)new Vector2[4] { val8, val9, val10, val11 }, uvs));
			val4 = val10;
			val5 = val11;
		}
	}

	public Vector3 RotatePointAroundPivot(Vector3 point, Vector3 pivot, Vector3 angles)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point - pivot;
		val = Quaternion.Euler(angles) * val;
		point = val + pivot;
		return point;
	}
}


using System;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Polygon")]
public class UIPolygon : UIPrimitiveBase
{
	public bool fill = true;

	public float thickness = 5f;

	[Range(3f, 360f)]
	public int sides = 3;

	[Range(0f, 360f)]
	public float rotation;

	[Range(0f, 1f)]
	public float[] VerticesDistances = new float[3];

	private float size;

	public void DrawPolygon(int _sides)
	{
		sides = _sides;
		VerticesDistances = new float[_sides + 1];
		for (int i = 0; i < _sides; i++)
		{
			VerticesDistances[i] = 1f;
		}
		rotation = 0f;
		((Graphic)this).SetAllDirty();
	}

	public void DrawPolygon(int _sides, float[] _VerticesDistances)
	{
		sides = _sides;
		VerticesDistances = _VerticesDistances;
		rotation = 0f;
		((Graphic)this).SetAllDirty();
	}

	public void DrawPolygon(int _sides, float[] _VerticesDistances, float _rotation)
	{
		sides = _sides;
		VerticesDistances = _VerticesDistances;
		rotation = _rotation;
		((Graphic)this).SetAllDirty();
	}

	private void Update()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((Graphic)this).rectTransform.rect;
		size = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		float width = ((Rect)(ref rect)).width;
		rect = ((Graphic)this).rectTransform.rect;
		if (width > ((Rect)(ref rect)).height)
		{
			rect = ((Graphic)this).rectTransform.rect;
			size = ((Rect)(ref rect)).height;
		}
		else
		{
			rect = ((Graphic)this).rectTransform.rect;
			size = ((Rect)(ref rect)).width;
		}
		thickness = Mathf.Clamp(thickness, 0f, size / 2f);
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		vh.Clear();
		Vector2 val = Vector2.zero;
		Vector2 val2 = Vector2.zero;
		Vector2 val3 = default(Vector2);
		((Vector2)(ref val3))..ctor(0f, 0f);
		Vector2 val4 = default(Vector2);
		((Vector2)(ref val4))..ctor(0f, 1f);
		Vector2 val5 = default(Vector2);
		((Vector2)(ref val5))..ctor(1f, 1f);
		Vector2 val6 = default(Vector2);
		((Vector2)(ref val6))..ctor(1f, 0f);
		float num = 360f / (float)sides;
		int num2 = sides + 1;
		if (VerticesDistances.Length != num2)
		{
			VerticesDistances = new float[num2];
			for (int i = 0; i < num2 - 1; i++)
			{
				VerticesDistances[i] = 1f;
			}
		}
		VerticesDistances[num2 - 1] = VerticesDistances[0];
		Vector2 val8 = default(Vector2);
		Vector2 zero = default(Vector2);
		for (int j = 0; j < num2; j++)
		{
			float num3 = (0f - ((Graphic)this).rectTransform.pivot.x) * size * VerticesDistances[j];
			float num4 = (0f - ((Graphic)this).rectTransform.pivot.x) * size * VerticesDistances[j] + thickness;
			float num5 = MathF.PI / 180f * ((float)j * num + rotation);
			float num6 = Mathf.Cos(num5);
			float num7 = Mathf.Sin(num5);
			((Vector2)(ref val3))..ctor(0f, 1f);
			((Vector2)(ref val4))..ctor(1f, 1f);
			((Vector2)(ref val5))..ctor(1f, 0f);
			((Vector2)(ref val6))..ctor(0f, 0f);
			Vector2 val7 = val;
			((Vector2)(ref val8))..ctor(num3 * num6, num3 * num7);
			Vector2 val9;
			if (fill)
			{
				zero = Vector2.zero;
				val9 = Vector2.zero;
			}
			else
			{
				((Vector2)(ref zero))..ctor(num4 * num6, num4 * num7);
				val9 = val2;
			}
			val = val8;
			val2 = zero;
			vh.AddUIVertexQuad(SetVbo((Vector2[])(object)new Vector2[4] { val7, val8, zero, val9 }, (Vector2[])(object)new Vector2[4] { val3, val4, val5, val6 }));
		}
	}
}


public enum ResolutionMode
{
	None,
	PerSegment,
	PerLine
}


using System;
using UnityEngine;

internal static class SetPropertyUtility
{
	public static bool SetColor(ref Color currentValue, Color newValue)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (currentValue.r == newValue.r && currentValue.g == newValue.g && currentValue.b == newValue.b && currentValue.a == newValue.a)
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}

	public static bool SetEquatableStruct<T>(ref T currentValue, T newValue) where T : IEquatable<T>
	{
		if (currentValue.Equals(newValue))
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}

	public static bool SetStruct<T>(ref T currentValue, T newValue) where T : struct
	{
		if (currentValue.Equals(newValue))
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}

	public static bool SetClass<T>(ref T currentValue, T newValue) where T : class
	{
		if ((currentValue == null && newValue == null) || (currentValue != null && currentValue.Equals(newValue)))
		{
			return false;
		}
		currentValue = newValue;
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

public class UIPrimitiveBase : MaskableGraphic, ILayoutElement, ICanvasRaycastFilter
{
	protected static Material s_ETC1DefaultUI;

	private List<Vector2> outputList = new List<Vector2>();

	[SerializeField]
	private Sprite m_Sprite;

	[NonSerialized]
	private Sprite m_OverrideSprite;

	internal float m_EventAlphaThreshold = 1f;

	[SerializeField]
	private ResolutionMode m_improveResolution;

	[SerializeField]
	protected float m_Resolution;

	[SerializeField]
	private bool m_useNativeSize;

	public Sprite sprite
	{
		get
		{
			return m_Sprite;
		}
		set
		{
			if (SetPropertyUtility.SetClass(ref m_Sprite, value))
			{
				GeneratedUVs();
			}
			((Graphic)this).SetAllDirty();
		}
	}

	public Sprite overrideSprite
	{
		get
		{
			return activeSprite;
		}
		set
		{
			if (SetPropertyUtility.SetClass(ref m_OverrideSprite, value))
			{
				GeneratedUVs();
			}
			((Graphic)this).SetAllDirty();
		}
	}

	protected Sprite activeSprite
	{
		get
		{
			if (!((Object)(object)m_OverrideSprite != (Object)null))
			{
				return sprite;
			}
			return m_OverrideSprite;
		}
	}

	public float eventAlphaThreshold
	{
		get
		{
			return m_EventAlphaThreshold;
		}
		set
		{
			m_EventAlphaThreshold = value;
		}
	}

	public ResolutionMode ImproveResolution
	{
		get
		{
			return m_improveResolution;
		}
		set
		{
			m_improveResolution = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public float Resoloution
	{
		get
		{
			return m_Resolution;
		}
		set
		{
			m_Resolution = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public bool UseNativeSize
	{
		get
		{
			return m_useNativeSize;
		}
		set
		{
			m_useNativeSize = value;
			((Graphic)this).SetAllDirty();
		}
	}

	public static Material defaultETC1GraphicMaterial
	{
		get
		{
			if ((Object)(object)s_ETC1DefaultUI == (Object)null)
			{
				s_ETC1DefaultUI = Canvas.GetETC1SupportedCanvasMaterial();
			}
			return s_ETC1DefaultUI;
		}
	}

	public override Texture mainTexture
	{
		get
		{
			if ((Object)(object)activeSprite == (Object)null)
			{
				if ((Object)(object)((Graphic)this).material != (Object)null && (Object)(object)((Graphic)this).material.mainTexture != (Object)null)
				{
					return ((Graphic)this).material.mainTexture;
				}
				return (Texture)(object)Graphic.s_WhiteTexture;
			}
			return (Texture)(object)activeSprite.texture;
		}
	}

	public bool hasBorder
	{
		get
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)activeSprite != (Object)null)
			{
				Vector4 border = activeSprite.border;
				return ((Vector4)(ref border)).sqrMagnitude > 0f;
			}
			return false;
		}
	}

	public float pixelsPerUnit
	{
		get
		{
			float num = 100f;
			if (Object.op_Implicit((Object)(object)activeSprite))
			{
				num = activeSprite.pixelsPerUnit;
			}
			float num2 = 100f;
			if (Object.op_Implicit((Object)(object)((Graphic)this).canvas))
			{
				num2 = ((Graphic)this).canvas.referencePixelsPerUnit;
			}
			return num / num2;
		}
	}

	public override Material material
	{
		get
		{
			if ((Object)(object)((Graphic)this).m_Material != (Object)null)
			{
				return ((Graphic)this).m_Material;
			}
			if (Object.op_Implicit((Object)(object)activeSprite) && (Object)(object)activeSprite.associatedAlphaSplitTexture != (Object)null)
			{
				return defaultETC1GraphicMaterial;
			}
			return ((Graphic)this).defaultMaterial;
		}
		set
		{
			((Graphic)this).material = value;
		}
	}

	public virtual float minWidth => 0f;

	public virtual float preferredWidth
	{
		get
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)overrideSprite == (Object)null)
			{
				return 0f;
			}
			Rect rect = overrideSprite.rect;
			return ((Rect)(ref rect)).size.x / pixelsPerUnit;
		}
	}

	public virtual float flexibleWidth => -1f;

	public virtual float minHeight => 0f;

	public virtual float preferredHeight
	{
		get
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)overrideSprite == (Object)null)
			{
				return 0f;
			}
			Rect rect = overrideSprite.rect;
			return ((Rect)(ref rect)).size.y / pixelsPerUnit;
		}
	}

	public virtual float flexibleHeight => -1f;

	public virtual int layoutPriority => 0;

	protected UIPrimitiveBase()
	{
		((Graphic)this).useLegacyMeshGeneration = false;
	}

	protected UIVertex[] SetVbo(Vector2[] vertices, Vector2[] uvs)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		UIVertex[] array = (UIVertex[])(object)new UIVertex[4];
		for (int i = 0; i < vertices.Length; i++)
		{
			UIVertex simpleVert = UIVertex.simpleVert;
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.position = Vector2.op_Implicit(vertices[i]);
			simpleVert.uv0 = Vector4.op_Implicit(uvs[i]);
			array[i] = simpleVert;
		}
		return array;
	}

	protected Vector2[] IncreaseResolution(Vector2[] input)
	{
		return IncreaseResolution(new List<Vector2>(input)).ToArray();
	}

	protected List<Vector2> IncreaseResolution(List<Vector2> input)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		outputList.Clear();
		switch (ImproveResolution)
		{
		case ResolutionMode.PerLine:
		{
			float num3 = 0f;
			float num = 0f;
			for (int j = 0; j < input.Count - 1; j++)
			{
				num3 += Vector2.Distance(input[j], input[j + 1]);
			}
			ResolutionToNativeSize(num3);
			num = num3 / m_Resolution;
			int num4 = 0;
			for (int k = 0; k < input.Count - 1; k++)
			{
				Vector2 val3 = input[k];
				outputList.Add(val3);
				Vector2 val4 = input[k + 1];
				float num5 = Vector2.Distance(val3, val4) / num;
				float num6 = 1f / num5;
				for (int l = 0; (float)l < num5; l++)
				{
					outputList.Add(Vector2.Lerp(val3, val4, (float)l * num6));
					num4++;
				}
				outputList.Add(val4);
			}
			break;
		}
		case ResolutionMode.PerSegment:
		{
			for (int i = 0; i < input.Count - 1; i++)
			{
				Vector2 val = input[i];
				outputList.Add(val);
				Vector2 val2 = input[i + 1];
				ResolutionToNativeSize(Vector2.Distance(val, val2));
				float num = 1f / m_Resolution;
				for (float num2 = 1f; num2 < m_Resolution; num2 += 1f)
				{
					outputList.Add(Vector2.Lerp(val, val2, num * num2));
				}
				outputList.Add(val2);
			}
			break;
		}
		}
		return outputList;
	}

	protected virtual void GeneratedUVs()
	{
	}

	protected virtual void ResolutionToNativeSize(float distance)
	{
	}

	public virtual void CalculateLayoutInputHorizontal()
	{
	}

	public virtual void CalculateLayoutInputVertical()
	{
	}

	public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		//IL_0128: Expected O, but got Unknown
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		if (m_EventAlphaThreshold >= 1f)
		{
			return true;
		}
		Sprite val = overrideSprite;
		if ((Object)(object)val == (Object)null)
		{
			return true;
		}
		Vector2 local = default(Vector2);
		RectTransformUtility.ScreenPointToLocalPointInRectangle(((Graphic)this).rectTransform, screenPoint, eventCamera, ref local);
		Rect pixelAdjustedRect = ((Graphic)this).GetPixelAdjustedRect();
		local.x += ((Graphic)this).rectTransform.pivot.x * ((Rect)(ref pixelAdjustedRect)).width;
		local.y += ((Graphic)this).rectTransform.pivot.y * ((Rect)(ref pixelAdjustedRect)).height;
		local = MapCoordinate(local, pixelAdjustedRect);
		Rect textureRect = val.textureRect;
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(local.x / ((Rect)(ref textureRect)).width, local.y / ((Rect)(ref textureRect)).height);
		float num = Mathf.Lerp(((Rect)(ref textureRect)).x, ((Rect)(ref textureRect)).xMax, val2.x) / (float)((Texture)val.texture).width;
		float num2 = Mathf.Lerp(((Rect)(ref textureRect)).y, ((Rect)(ref textureRect)).yMax, val2.y) / (float)((Texture)val.texture).height;
		try
		{
			return val.texture.GetPixelBilinear(num, num2).a >= m_EventAlphaThreshold;
		}
		catch (UnityException val3)
		{
			UnityException val4 = val3;
			Debug.LogError((object)("Using clickAlphaThreshold lower than 1 on Image whose sprite texture cannot be read. " + ((Exception)(object)val4).Message + " Also make sure to disable sprite packing for this sprite."), (Object)(object)this);
			return true;
		}
	}

	private Vector2 MapCoordinate(Vector2 local, Rect rect)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		_ = sprite.rect;
		return new Vector2(local.x * ((Rect)(ref rect)).width, local.y * ((Rect)(ref rect)).height);
	}

	private Vector4 GetAdjustedBorders(Vector4 border, Rect rect)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i <= 1; i++)
		{
			float num = ((Vector4)(ref border))[i] + ((Vector4)(ref border))[i + 2];
			Vector2 size = ((Rect)(ref rect)).size;
			if (((Vector2)(ref size))[i] < num && num != 0f)
			{
				size = ((Rect)(ref rect)).size;
				float num2 = ((Vector2)(ref size))[i] / num;
				ref Vector4 reference = ref border;
				int num3 = i;
				((Vector4)(ref reference))[num3] = ((Vector4)(ref reference))[num3] * num2;
				reference = ref border;
				num3 = i + 2;
				((Vector4)(ref reference))[num3] = ((Vector4)(ref reference))[num3] * num2;
			}
		}
		return border;
	}

	protected override void OnEnable()
	{
		((MaskableGraphic)this).OnEnable();
		((Graphic)this).SetAllDirty();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.UI.Extensions;

[AddComponentMenu("UI/Extensions/Primitives/UI Ring")]
public class UIRing : UIPrimitiveBase
{
	public float innerRadius = 16f;

	public float outerRadius = 32f;

	[Tooltip("The Arc Steps property defines the number of segments that the Arc will be divided into.")]
	[Range(0f, 1000f)]
	public int ArcSteps = 100;

	private List<int> indices = new List<int>();

	private List<UIVertex> vertices = new List<UIVertex>();

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		float num = innerRadius * 2f;
		float num2 = outerRadius * 2f;
		vh.Clear();
		indices.Clear();
		vertices.Clear();
		int item = 0;
		int num3 = 1;
		float num4 = 360f / (float)ArcSteps;
		float num5 = Mathf.Cos(0f);
		float num6 = Mathf.Sin(0f);
		UIVertex simpleVert = UIVertex.simpleVert;
		simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
		simpleVert.position = Vector2.op_Implicit(new Vector2(num2 * num5, num2 * num6));
		vertices.Add(simpleVert);
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(num * num5, num * num6);
		simpleVert.position = Vector2.op_Implicit(val);
		vertices.Add(simpleVert);
		for (int i = 1; i <= ArcSteps; i++)
		{
			float num7 = MathF.PI / 180f * ((float)i * num4);
			num5 = Mathf.Cos(num7);
			num6 = Mathf.Sin(num7);
			simpleVert.color = Color32.op_Implicit(((Graphic)this).color);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num2 * num5, num2 * num6));
			vertices.Add(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num * num5, num * num6));
			vertices.Add(simpleVert);
			int item2 = num3;
			indices.Add(item);
			indices.Add(num3 + 1);
			indices.Add(num3);
			num3++;
			item = num3;
			num3++;
			indices.Add(item);
			indices.Add(num3);
			indices.Add(item2);
		}
		vh.AddUIVertexStream(vertices, indices);
	}

	public void SetArcSteps(int steps)
	{
		ArcSteps = steps;
		((Graphic)this).SetVerticesDirty();
	}

	public void SetBaseColor(Color color)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}

	public void UpdateBaseAlpha(float value)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Color color = ((Graphic)this).color;
		color.a = value;
		((Graphic)this).color = color;
		((Graphic)this).SetVerticesDirty();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class BezierPath
{
	public int SegmentsPerCurve = 10;

	public float MINIMUM_SQR_DISTANCE = 0.01f;

	public float DIVISION_THRESHOLD = -0.99f;

	private List<Vector2> controlPoints;

	private int curveCount;

	public BezierPath()
	{
		controlPoints = new List<Vector2>();
	}

	public void SetControlPoints(List<Vector2> newControlPoints)
	{
		controlPoints.Clear();
		controlPoints.AddRange(newControlPoints);
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public void SetControlPoints(Vector2[] newControlPoints)
	{
		controlPoints.Clear();
		controlPoints.AddRange(newControlPoints);
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public List<Vector2> GetControlPoints()
	{
		return controlPoints;
	}

	public void Interpolate(List<Vector2> segmentPoints, float scale)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		controlPoints.Clear();
		if (segmentPoints.Count < 2)
		{
			return;
		}
		for (int i = 0; i < segmentPoints.Count; i++)
		{
			if (i == 0)
			{
				Vector2 val = segmentPoints[i];
				Vector2 val2 = segmentPoints[i + 1] - val;
				Vector2 item = val + scale * val2;
				controlPoints.Add(val);
				controlPoints.Add(item);
				continue;
			}
			if (i == segmentPoints.Count - 1)
			{
				Vector2 val3 = segmentPoints[i - 1];
				Vector2 val4 = segmentPoints[i];
				Vector2 val5 = val4 - val3;
				Vector2 item2 = val4 - scale * val5;
				controlPoints.Add(item2);
				controlPoints.Add(val4);
				continue;
			}
			Vector2 val6 = segmentPoints[i - 1];
			Vector2 val7 = segmentPoints[i];
			Vector2 val8 = segmentPoints[i + 1];
			Vector2 val9 = val8 - val6;
			Vector2 normalized = ((Vector2)(ref val9)).normalized;
			Vector2 val10 = scale * normalized;
			val9 = val7 - val6;
			Vector2 item3 = val7 - val10 * ((Vector2)(ref val9)).magnitude;
			Vector2 val11 = scale * normalized;
			val9 = val8 - val7;
			Vector2 item4 = val7 + val11 * ((Vector2)(ref val9)).magnitude;
			controlPoints.Add(item3);
			controlPoints.Add(val7);
			controlPoints.Add(item4);
		}
		curveCount = (controlPoints.Count - 1) / 3;
	}

	public void SamplePoints(List<Vector2> sourcePoints, float minSqrDistance, float maxSqrDistance, float scale)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (sourcePoints.Count < 2)
		{
			return;
		}
		Stack<Vector2> stack = new Stack<Vector2>();
		stack.Push(sourcePoints[0]);
		Vector2 val = sourcePoints[1];
		int num = 2;
		Vector2 val2;
		for (num = 2; num < sourcePoints.Count; num++)
		{
			val2 = val - sourcePoints[num];
			if (((Vector2)(ref val2)).sqrMagnitude > minSqrDistance)
			{
				val2 = stack.Peek() - sourcePoints[num];
				if (((Vector2)(ref val2)).sqrMagnitude > maxSqrDistance)
				{
					stack.Push(val);
				}
			}
			val = sourcePoints[num];
		}
		Vector2 val3 = stack.Pop();
		Vector2 val4 = stack.Peek();
		val2 = val4 - val;
		Vector2 normalized = ((Vector2)(ref val2)).normalized;
		val2 = val - val3;
		float magnitude = ((Vector2)(ref val2)).magnitude;
		val2 = val3 - val4;
		float magnitude2 = ((Vector2)(ref val2)).magnitude;
		val3 += normalized * ((magnitude2 - magnitude) / 2f);
		stack.Push(val3);
		stack.Push(val);
		Interpolate(new List<Vector2>(stack), scale);
	}

	public Vector2 CalculateBezierPoint(int curveIndex, float t)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		int num = curveIndex * 3;
		Vector2 p = controlPoints[num];
		Vector2 p2 = controlPoints[num + 1];
		Vector2 p3 = controlPoints[num + 2];
		Vector2 p4 = controlPoints[num + 3];
		return CalculateBezierPoint(t, p, p2, p3, p4);
	}

	public List<Vector2> GetDrawingPoints0()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < curveCount; i++)
		{
			if (i == 0)
			{
				list.Add(CalculateBezierPoint(i, 0f));
			}
			for (int j = 1; j <= SegmentsPerCurve; j++)
			{
				float t = (float)j / (float)SegmentsPerCurve;
				list.Add(CalculateBezierPoint(i, t));
			}
		}
		return list;
	}

	public List<Vector2> GetDrawingPoints1()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < controlPoints.Count - 3; i += 3)
		{
			Vector2 p = controlPoints[i];
			Vector2 p2 = controlPoints[i + 1];
			Vector2 p3 = controlPoints[i + 2];
			Vector2 p4 = controlPoints[i + 3];
			if (i == 0)
			{
				list.Add(CalculateBezierPoint(0f, p, p2, p3, p4));
			}
			for (int j = 1; j <= SegmentsPerCurve; j++)
			{
				float t = (float)j / (float)SegmentsPerCurve;
				list.Add(CalculateBezierPoint(t, p, p2, p3, p4));
			}
		}
		return list;
	}

	public List<Vector2> GetDrawingPoints2()
	{
		List<Vector2> list = new List<Vector2>();
		for (int i = 0; i < curveCount; i++)
		{
			List<Vector2> list2 = FindDrawingPoints(i);
			if (i != 0)
			{
				list2.RemoveAt(0);
			}
			list.AddRange(list2);
		}
		return list;
	}

	private List<Vector2> FindDrawingPoints(int curveIndex)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		List<Vector2> list = new List<Vector2>();
		Vector2 item = CalculateBezierPoint(curveIndex, 0f);
		Vector2 item2 = CalculateBezierPoint(curveIndex, 1f);
		list.Add(item);
		list.Add(item2);
		FindDrawingPoints(curveIndex, 0f, 1f, list, 1);
		return list;
	}

	private int FindDrawingPoints(int curveIndex, float t0, float t1, List<Vector2> pointList, int insertionIndex)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = CalculateBezierPoint(curveIndex, t0);
		Vector2 val2 = CalculateBezierPoint(curveIndex, t1);
		Vector2 val3 = val - val2;
		if (((Vector2)(ref val3)).sqrMagnitude < MINIMUM_SQR_DISTANCE)
		{
			return 0;
		}
		float num = (t0 + t1) / 2f;
		Vector2 val4 = CalculateBezierPoint(curveIndex, num);
		val3 = val - val4;
		Vector2 normalized = ((Vector2)(ref val3)).normalized;
		val3 = val2 - val4;
		Vector2 normalized2 = ((Vector2)(ref val3)).normalized;
		if (Vector2.Dot(normalized, normalized2) > DIVISION_THRESHOLD || Mathf.Abs(num - 0.5f) < 0.0001f)
		{
			int num2 = 0;
			num2 += FindDrawingPoints(curveIndex, t0, num, pointList, insertionIndex);
			pointList.Insert(insertionIndex + num2, val4);
			num2++;
			return num2 + FindDrawingPoints(curveIndex, num, t1, pointList, insertionIndex + num2);
		}
		return 0;
	}

	private Vector2 CalculateBezierPoint(float t, Vector2 p0, Vector2 p1, Vector2 p2, Vector2 p3)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f - t;
		float num2 = t * t;
		float num3 = num * num;
		float num4 = num3 * num;
		float num5 = num2 * t;
		return num4 * p0 + 3f * num3 * t * p1 + 3f * num * num2 * p2 + num5 * p3;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI.Extensions;

[Serializable]
public class CableCurve
{
	[SerializeField]
	private Vector2 m_start;

	[SerializeField]
	private Vector2 m_end;

	[SerializeField]
	private float m_slack;

	[SerializeField]
	private int m_steps;

	[SerializeField]
	private bool m_regen;

	private static Vector2[] emptyCurve = (Vector2[])(object)new Vector2[2]
	{
		new Vector2(0f, 0f),
		new Vector2(0f, 0f)
	};

	[SerializeField]
	private Vector2[] points;

	public bool regenPoints
	{
		get
		{
			return m_regen;
		}
		set
		{
			m_regen = value;
		}
	}

	public Vector2 start
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_start;
		}
		set
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			if (value != m_start)
			{
				m_regen = true;
			}
			m_start = value;
		}
	}

	public Vector2 end
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return m_end;
		}
		set
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			if (value != m_end)
			{
				m_regen = true;
			}
			m_end = value;
		}
	}

	public float slack
	{
		get
		{
			return m_slack;
		}
		set
		{
			if (value != m_slack)
			{
				m_regen = true;
			}
			m_slack = Mathf.Max(0f, value);
		}
	}

	public int steps
	{
		get
		{
			return m_steps;
		}
		set
		{
			if (value != m_steps)
			{
				m_regen = true;
			}
			m_steps = Mathf.Max(2, value);
		}
	}

	public Vector2 midPoint
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			Vector2 result = Vector2.zero;
			if (m_steps == 2)
			{
				return (points[0] + points[1]) * 0.5f;
			}
			if (m_steps > 2)
			{
				int num = m_steps / 2;
				result = ((m_steps % 2 != 0) ? points[num] : ((points[num] + points[num + 1]) * 0.5f));
			}
			return result;
		}
	}

	public CableCurve()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		points = emptyCurve;
		m_start = Vector2.up;
		m_end = Vector2.up + Vector2.right;
		m_slack = 0.5f;
		m_steps = 20;
		m_regen = true;
	}

	public CableCurve(Vector2[] inputPoints)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		points = inputPoints;
		m_start = inputPoints[0];
		m_end = inputPoints[1];
		m_slack = 0.5f;
		m_steps = 20;
		m_regen = true;
	}

	public CableCurve(List<Vector2> inputPoints)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		points = inputPoints.ToArray();
		m_start = inputPoints[0];
		m_end = inputPoints[1];
		m_slack = 0.5f;
		m_steps = 20;
		m_regen = true;
	}

	public CableCurve(CableCurve v)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		points = v.Points();
		m_start = v.start;
		m_end = v.end;
		m_slack = v.slack;
		m_steps = v.steps;
		m_regen = v.regenPoints;
	}

	public Vector2[] Points()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		if (!m_regen)
		{
			return points;
		}
		if (m_steps < 2)
		{
			return emptyCurve;
		}
		float num = Vector2.Distance(m_end, m_start);
		float num2 = Vector2.Distance(new Vector2(m_end.x, m_start.y), m_start);
		float num3 = num + Mathf.Max(0.0001f, m_slack);
		float num4 = 0f;
		float y = m_start.y;
		float num5 = num2;
		float y2 = end.y;
		if (num5 - num4 == 0f)
		{
			return emptyCurve;
		}
		float num6 = Mathf.Sqrt(Mathf.Pow(num3, 2f) - Mathf.Pow(y2 - y, 2f)) / (num5 - num4);
		int num7 = 30;
		int num8 = 0;
		int num9 = num7 * 10;
		bool flag = false;
		float num10 = 0f;
		float num11 = 0f;
		float num12 = 100f;
		float num13 = 0f;
		for (int i = 0; i < num7; i++)
		{
			for (int j = 0; j < 10; j++)
			{
				num8++;
				num11 = num10 + num12;
				num13 = (float)Math.Sinh(num11) / num11;
				if (!float.IsInfinity(num13))
				{
					if (num13 == num6)
					{
						flag = true;
						num10 = num11;
						break;
					}
					if (num13 > num6)
					{
						break;
					}
					num10 = num11;
					if (num8 > num9)
					{
						flag = true;
						break;
					}
				}
			}
			if (flag)
			{
				break;
			}
			num12 *= 0.1f;
		}
		float num14 = (num5 - num4) / 2f / num10;
		float num15 = (num4 + num5 - num14 * Mathf.Log((num3 + y2 - y) / (num3 - y2 + y))) / 2f;
		float num16 = (y2 + y - num3 * (float)Math.Cosh(num10) / (float)Math.Sinh(num10)) / 2f;
		points = (Vector2[])(object)new Vector2[m_steps];
		float num17 = m_steps - 1;
		for (int k = 0; k < m_steps; k++)
		{
			float num18 = (float)k / num17;
			Vector2 zero = Vector2.zero;
			zero.x = Mathf.Lerp(start.x, end.x, num18);
			zero.y = num14 * (float)Math.Cosh((num18 * num2 - num15) / num14) + num16;
			points[k] = zero;
		}
		m_regen = false;
		return points;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[ImageEffectAllowedInSceneView]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Rendering/Post-process Layer", 1000)]
[DisallowMultipleComponent]
[ExecuteAlways]
public class PostProcessLayer : MonoBehaviour
{
	private enum ScalingMode
	{
		NATIVE,
		BILINEAR,
		DLSS
	}

	public enum Antialiasing
	{
		None,
		FastApproximateAntialiasing,
		SubpixelMorphologicalAntialiasing,
		TemporalAntialiasing
	}

	[Serializable]
	public sealed class SerializedBundleRef
	{
		public string assemblyQualifiedName;

		public PostProcessBundle bundle;
	}

	public Transform volumeTrigger;

	public LayerMask volumeLayer;

	public bool stopNaNPropagation = true;

	public bool finalBlitToCameraTarget;

	public Antialiasing antialiasingMode;

	public TemporalAntialiasing temporalAntialiasing;

	public SubpixelMorphologicalAntialiasing subpixelMorphologicalAntialiasing;

	public FastApproximateAntialiasing fastApproximateAntialiasing;

	public Fog fog;

	private Dithering dithering;

	public PostProcessDebugLayer debugLayer;

	public RenderTextureFormat intermediateFormat = (RenderTextureFormat)9;

	private RenderTextureFormat prevIntermediateFormat = (RenderTextureFormat)9;

	private bool supportsIntermediateFormat = true;

	[SerializeField]
	private PostProcessResources m_Resources;

	[Preserve]
	[SerializeField]
	private bool m_ShowToolkit;

	[SerializeField]
	[Preserve]
	private bool m_ShowCustomSorter;

	public bool breakBeforeColorGrading;

	[SerializeField]
	private List<SerializedBundleRef> m_BeforeTransparentBundles;

	[SerializeField]
	private List<SerializedBundleRef> m_BeforeStackBundles;

	[SerializeField]
	private List<SerializedBundleRef> m_AfterStackBundles;

	private Dictionary<Type, PostProcessBundle> m_Bundles;

	private PropertySheetFactory m_PropertySheetFactory;

	private CommandBuffer m_LegacyCmdBufferBeforeReflections;

	private CommandBuffer m_LegacyCmdBufferBeforeLighting;

	private CommandBuffer m_LegacyCmdBufferOpaque;

	private CommandBuffer m_LegacyCmdBuffer;

	private Camera m_Camera;

	private PostProcessRenderContext m_CurrentContext;

	private LogHistogram m_LogHistogram;

	private bool m_SettingsUpdateNeeded = true;

	private bool m_IsRenderingInSceneView;

	private TargetPool m_TargetPool;

	private bool m_NaNKilled;

	private readonly List<PostProcessEffectRenderer> m_ActiveEffects = new List<PostProcessEffectRenderer>();

	private readonly List<RenderTargetIdentifier> m_Targets = new List<RenderTargetIdentifier>();

	public Dictionary<PostProcessEvent, List<SerializedBundleRef>> sortedBundles { get; private set; }

	public bool haveBundlesBeenInited { get; private set; }

	private void OnEnable()
	{
		Init(null);
		if (!haveBundlesBeenInited)
		{
			InitBundles();
		}
		m_LogHistogram = new LogHistogram();
		m_PropertySheetFactory = new PropertySheetFactory();
		m_TargetPool = new TargetPool();
		debugLayer.OnEnable();
		if (!RuntimeUtilities.scriptableRenderPipelineActive)
		{
			InitLegacy();
		}
	}

	private void InitLegacy()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected O, but got Unknown
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Expected O, but got Unknown
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Expected O, but got Unknown
		m_LegacyCmdBufferBeforeReflections = new CommandBuffer
		{
			name = "Deferred Ambient Occlusion"
		};
		m_LegacyCmdBufferBeforeLighting = new CommandBuffer
		{
			name = "Deferred Ambient Occlusion"
		};
		m_LegacyCmdBufferOpaque = new CommandBuffer
		{
			name = "Opaque Only Post-processing"
		};
		m_LegacyCmdBuffer = new CommandBuffer
		{
			name = "Post-processing"
		};
		m_Camera = ((Component)this).GetComponent<Camera>();
		m_Camera.AddCommandBuffer((CameraEvent)21, m_LegacyCmdBufferBeforeReflections);
		m_Camera.AddCommandBuffer((CameraEvent)6, m_LegacyCmdBufferBeforeLighting);
		m_Camera.AddCommandBuffer((CameraEvent)12, m_LegacyCmdBufferOpaque);
		m_Camera.AddCommandBuffer((CameraEvent)18, m_LegacyCmdBuffer);
		m_CurrentContext = new PostProcessRenderContext();
	}

	[ImageEffectUsesCommandBuffer]
	private void OnRenderImage(RenderTexture src, RenderTexture dst)
	{
		if (finalBlitToCameraTarget)
		{
			RenderTexture.active = dst;
		}
		else
		{
			Graphics.Blit((Texture)(object)src, dst);
		}
	}

	public void Init(PostProcessResources resources)
	{
		if ((Object)(object)resources != (Object)null)
		{
			m_Resources = resources;
		}
		RuntimeUtilities.CreateIfNull(ref temporalAntialiasing);
		RuntimeUtilities.CreateIfNull(ref subpixelMorphologicalAntialiasing);
		RuntimeUtilities.CreateIfNull(ref fastApproximateAntialiasing);
		RuntimeUtilities.CreateIfNull(ref dithering);
		RuntimeUtilities.CreateIfNull(ref fog);
		RuntimeUtilities.CreateIfNull(ref debugLayer);
	}

	public void InitBundles()
	{
		if (haveBundlesBeenInited)
		{
			return;
		}
		RuntimeUtilities.CreateIfNull(ref m_BeforeTransparentBundles);
		RuntimeUtilities.CreateIfNull(ref m_BeforeStackBundles);
		RuntimeUtilities.CreateIfNull(ref m_AfterStackBundles);
		m_Bundles = new Dictionary<Type, PostProcessBundle>();
		foreach (Type key in PostProcessManager.instance.settingsTypes.Keys)
		{
			PostProcessBundle value = new PostProcessBundle((PostProcessEffectSettings)(object)ScriptableObject.CreateInstance(key));
			m_Bundles.Add(key, value);
		}
		UpdateBundleSortList(m_BeforeTransparentBundles, PostProcessEvent.BeforeTransparent);
		UpdateBundleSortList(m_BeforeStackBundles, PostProcessEvent.BeforeStack);
		UpdateBundleSortList(m_AfterStackBundles, PostProcessEvent.AfterStack);
		sortedBundles = new Dictionary<PostProcessEvent, List<SerializedBundleRef>>(default(PostProcessEventComparer))
		{
			{
				PostProcessEvent.BeforeTransparent,
				m_BeforeTransparentBundles
			},
			{
				PostProcessEvent.BeforeStack,
				m_BeforeStackBundles
			},
			{
				PostProcessEvent.AfterStack,
				m_AfterStackBundles
			}
		};
		haveBundlesBeenInited = true;
	}

	private void UpdateBundleSortList(List<SerializedBundleRef> sortedList, PostProcessEvent evt)
	{
		List<PostProcessBundle> effects = (from kvp in m_Bundles
			where kvp.Value.attribute.eventType == evt && !kvp.Value.attribute.builtinEffect
			select kvp.Value).ToList();
		sortedList.RemoveAll(delegate(SerializedBundleRef x)
		{
			string searchStr = x.assemblyQualifiedName;
			return !effects.Exists((PostProcessBundle b) => ((object)b.settings).GetType().AssemblyQualifiedName == searchStr);
		});
		foreach (PostProcessBundle item2 in effects)
		{
			string typeName = ((object)item2.settings).GetType().AssemblyQualifiedName;
			if (!sortedList.Exists((SerializedBundleRef b) => b.assemblyQualifiedName == typeName))
			{
				SerializedBundleRef item = new SerializedBundleRef
				{
					assemblyQualifiedName = typeName
				};
				sortedList.Add(item);
			}
		}
		foreach (SerializedBundleRef sorted in sortedList)
		{
			string typeName2 = sorted.assemblyQualifiedName;
			PostProcessBundle bundle = effects.Find((PostProcessBundle b) => ((object)b.settings).GetType().AssemblyQualifiedName == typeName2);
			sorted.bundle = bundle;
		}
	}

	private void OnDisable()
	{
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_Camera != (Object)null)
		{
			if (m_LegacyCmdBufferBeforeReflections != null)
			{
				m_Camera.RemoveCommandBuffer((CameraEvent)21, m_LegacyCmdBufferBeforeReflections);
			}
			if (m_LegacyCmdBufferBeforeLighting != null)
			{
				m_Camera.RemoveCommandBuffer((CameraEvent)6, m_LegacyCmdBufferBeforeLighting);
			}
			if (m_LegacyCmdBufferOpaque != null)
			{
				m_Camera.RemoveCommandBuffer((CameraEvent)12, m_LegacyCmdBufferOpaque);
			}
			if (m_LegacyCmdBuffer != null)
			{
				m_Camera.RemoveCommandBuffer((CameraEvent)18, m_LegacyCmdBuffer);
			}
		}
		temporalAntialiasing.Release();
		m_LogHistogram.Release();
		foreach (PostProcessBundle value in m_Bundles.Values)
		{
			value.Release();
		}
		m_Bundles.Clear();
		m_PropertySheetFactory.Release();
		if (debugLayer != null)
		{
			debugLayer.OnDisable();
		}
		TextureLerper.instance.Clear();
		if ((Object)(object)m_Camera != (Object)null)
		{
			m_Camera.ResetProjectionMatrix();
			m_Camera.nonJitteredProjectionMatrix = m_Camera.projectionMatrix;
		}
		Shader.SetGlobalVector("_FrustumJitter", Vector4.op_Implicit(Vector2.zero));
		haveBundlesBeenInited = false;
	}

	private void Reset()
	{
		volumeTrigger = ((Component)this).transform;
	}

	private void OnPreCull()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (!RuntimeUtilities.scriptableRenderPipelineActive)
		{
			if ((Object)(object)m_Camera == (Object)null || m_CurrentContext == null)
			{
				InitLegacy();
			}
			if (!m_Camera.usePhysicalProperties)
			{
				m_Camera.ResetProjectionMatrix();
			}
			m_Camera.nonJitteredProjectionMatrix = m_Camera.projectionMatrix;
			if (m_Camera.stereoEnabled)
			{
				m_Camera.ResetStereoProjectionMatrices();
			}
			else
			{
				Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, 1f);
			}
			BuildCommandBuffers();
			Shader.SetGlobalVector("_FrustumJitter", Vector4.op_Implicit(temporalAntialiasing.jitter));
		}
	}

	private void OnPreRender()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Invalid comparison between Unknown and I4
		if (!RuntimeUtilities.scriptableRenderPipelineActive && (int)m_Camera.stereoActiveEye == 1)
		{
			BuildCommandBuffers();
		}
	}

	private RenderTextureFormat GetIntermediateFormat()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (intermediateFormat != prevIntermediateFormat)
		{
			supportsIntermediateFormat = SystemInfo.SupportsRenderTextureFormat(intermediateFormat);
			prevIntermediateFormat = intermediateFormat;
		}
		if (!supportsIntermediateFormat)
		{
			return (RenderTextureFormat)9;
		}
		return intermediateFormat;
	}

	private static bool RequiresInitialBlit(Camera camera, PostProcessRenderContext context)
	{
		if (camera.allowMSAA)
		{
			return true;
		}
		if (RuntimeUtilities.scriptableRenderPipelineActive)
		{
			return true;
		}
		return false;
	}

	private void UpdateSrcDstForOpaqueOnly(ref int src, ref int dst, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget, int opaqueOnlyEffectsRemaining)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (src > -1)
		{
			context.command.ReleaseTemporaryRT(src);
		}
		context.source = context.destination;
		src = dst;
		if (opaqueOnlyEffectsRemaining == 1)
		{
			context.destination = cameraTarget;
			return;
		}
		dst = m_TargetPool.Get();
		context.destination = RenderTargetIdentifier.op_Implicit(dst);
		context.GetScreenSpaceTemporaryRT(context.command, dst, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
	}

	private void BuildCommandBuffers()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		PostProcessRenderContext currentContext = m_CurrentContext;
		RenderTextureFormat val = GetIntermediateFormat();
		RenderTextureFormat val2 = (RenderTextureFormat)((!m_Camera.allowHDR) ? 7 : ((int)val));
		if (!RuntimeUtilities.isFloatingPointFormat(val2))
		{
			m_NaNKilled = true;
		}
		currentContext.Reset();
		currentContext.camera = m_Camera;
		currentContext.sourceFormat = val2;
		m_LegacyCmdBufferBeforeReflections.Clear();
		m_LegacyCmdBufferBeforeLighting.Clear();
		m_LegacyCmdBufferOpaque.Clear();
		m_LegacyCmdBuffer.Clear();
		SetupContext(currentContext);
		currentContext.command = m_LegacyCmdBufferOpaque;
		TextureLerper.instance.BeginFrame(currentContext);
		UpdateVolumeSystem(currentContext.camera, currentContext.command);
		PostProcessBundle bundle = GetBundle<AmbientOcclusion>();
		AmbientOcclusion ambientOcclusion = bundle.CastSettings<AmbientOcclusion>();
		AmbientOcclusionRenderer ambientOcclusionRenderer = bundle.CastRenderer<AmbientOcclusionRenderer>();
		bool flag = ambientOcclusion.IsEnabledAndSupported(currentContext);
		bool flag2 = ambientOcclusionRenderer.IsAmbientOnly(currentContext);
		bool flag3 = flag && flag2;
		bool flag4 = flag && !flag2;
		PostProcessBundle bundle2 = GetBundle<ScreenSpaceReflections>();
		PostProcessEffectSettings settings = bundle2.settings;
		PostProcessEffectRenderer renderer = bundle2.renderer;
		bool flag5 = settings.IsEnabledAndSupported(currentContext);
		if (flag3)
		{
			IAmbientOcclusionMethod ambientOcclusionMethod = ambientOcclusionRenderer.Get();
			currentContext.command = m_LegacyCmdBufferBeforeReflections;
			ambientOcclusionMethod.RenderAmbientOnly(currentContext);
			currentContext.command = m_LegacyCmdBufferBeforeLighting;
			ambientOcclusionMethod.CompositeAmbientOnly(currentContext);
		}
		else if (flag4)
		{
			currentContext.command = m_LegacyCmdBufferOpaque;
			ambientOcclusionRenderer.Get().RenderAfterOpaque(currentContext);
		}
		bool flag6 = fog.IsEnabledAndSupported(currentContext);
		bool flag7 = HasOpaqueOnlyEffects(currentContext);
		int num = 0;
		num += (flag5 ? 1 : 0);
		num += (flag6 ? 1 : 0);
		num += (flag7 ? 1 : 0);
		RenderTargetIdentifier val3 = default(RenderTargetIdentifier);
		((RenderTargetIdentifier)(ref val3))..ctor((BuiltinRenderTextureType)2);
		if (num > 0)
		{
			CommandBuffer val4 = (currentContext.command = m_LegacyCmdBufferOpaque);
			currentContext.source = val3;
			currentContext.destination = val3;
			int src = -1;
			int dst = -1;
			UpdateSrcDstForOpaqueOnly(ref src, ref dst, currentContext, val3, num + 1);
			if (RequiresInitialBlit(m_Camera, currentContext) || num == 1)
			{
				val4.BuiltinBlit(currentContext.source, currentContext.destination, RuntimeUtilities.copyStdMaterial, stopNaNPropagation ? 1 : 0);
				UpdateSrcDstForOpaqueOnly(ref src, ref dst, currentContext, val3, num);
			}
			if (flag5)
			{
				renderer.Render(currentContext);
				num--;
				UpdateSrcDstForOpaqueOnly(ref src, ref dst, currentContext, val3, num);
			}
			if (flag6)
			{
				fog.Render(currentContext);
				num--;
				UpdateSrcDstForOpaqueOnly(ref src, ref dst, currentContext, val3, num);
			}
			if (flag7)
			{
				RenderOpaqueOnly(currentContext);
			}
			val4.ReleaseTemporaryRT(src);
		}
		BuildPostEffectsOld(val2, currentContext, val3);
	}

	private void BuildPostEffectsOld(RenderTextureFormat sourceFormat, PostProcessRenderContext context, RenderTargetIdentifier cameraTarget)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		bool flag = !m_NaNKilled && stopNaNPropagation && RuntimeUtilities.isFloatingPointFormat(sourceFormat);
		if (RequiresInitialBlit(m_Camera, context) || flag)
		{
			num = m_TargetPool.Get();
			context.GetScreenSpaceTemporaryRT(m_LegacyCmdBuffer, num, 0, sourceFormat, (RenderTextureReadWrite)2, (FilterMode)1);
			m_LegacyCmdBuffer.BuiltinBlit(cameraTarget, RenderTargetIdentifier.op_Implicit(num), RuntimeUtilities.copyStdMaterial, stopNaNPropagation ? 1 : 0);
			if (!m_NaNKilled)
			{
				m_NaNKilled = stopNaNPropagation;
			}
			context.source = RenderTargetIdentifier.op_Implicit(num);
		}
		else
		{
			context.source = cameraTarget;
		}
		context.destination = cameraTarget;
		if (finalBlitToCameraTarget && !RuntimeUtilities.scriptableRenderPipelineActive)
		{
			if (Object.op_Implicit((Object)(object)m_Camera.targetTexture))
			{
				context.destination = RenderTargetIdentifier.op_Implicit(m_Camera.targetTexture.colorBuffer);
			}
			else
			{
				context.flip = true;
				context.destination = RenderTargetIdentifier.op_Implicit(Display.main.colorBuffer);
			}
		}
		context.command = m_LegacyCmdBuffer;
		Render(context);
		if (num > -1)
		{
			m_LegacyCmdBuffer.ReleaseTemporaryRT(num);
		}
	}

	private void OnPostRender()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Invalid comparison between Unknown and I4
		if (!RuntimeUtilities.scriptableRenderPipelineActive && m_CurrentContext.IsTemporalAntialiasingActive())
		{
			if (m_CurrentContext.physicalCamera)
			{
				m_Camera.usePhysicalProperties = true;
			}
			else
			{
				m_Camera.ResetProjectionMatrix();
			}
			if (m_CurrentContext.stereoActive && (RuntimeUtilities.isSinglePassStereoEnabled || (int)m_Camera.stereoActiveEye == 1))
			{
				m_Camera.ResetStereoProjectionMatrices();
			}
		}
	}

	public PostProcessBundle GetBundle<T>() where T : PostProcessEffectSettings
	{
		return GetBundle(typeof(T));
	}

	public PostProcessBundle GetBundle(Type settingsType)
	{
		Assert.IsTrue(m_Bundles.ContainsKey(settingsType), "Invalid type");
		return m_Bundles[settingsType];
	}

	public T GetSettings<T>() where T : PostProcessEffectSettings
	{
		return GetBundle<T>().CastSettings<T>();
	}

	public void BakeMSVOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert, bool isMSAA = false)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		MultiScaleVO multiScaleVO = GetBundle<AmbientOcclusion>().CastRenderer<AmbientOcclusionRenderer>().GetMultiScaleVO();
		multiScaleVO.SetResources(m_Resources);
		multiScaleVO.GenerateAOMap(cmd, camera, destination, depthMap, invert, isMSAA);
	}

	internal void OverrideSettings(List<PostProcessEffectSettings> baseSettings, float interpFactor)
	{
		foreach (PostProcessEffectSettings baseSetting in baseSettings)
		{
			if (!baseSetting.active)
			{
				continue;
			}
			PostProcessEffectSettings settings = GetBundle(((object)baseSetting).GetType()).settings;
			int count = baseSetting.parameters.Count;
			for (int i = 0; i < count; i++)
			{
				ParameterOverride parameterOverride = baseSetting.parameters[i];
				if (parameterOverride.overrideState)
				{
					ParameterOverride parameterOverride2 = settings.parameters[i];
					parameterOverride2.Interp(parameterOverride2, parameterOverride, interpFactor);
				}
			}
		}
	}

	private void SetLegacyCameraFlags(PostProcessRenderContext context)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		DepthTextureMode val = context.camera.depthTextureMode;
		foreach (KeyValuePair<Type, PostProcessBundle> bundle in m_Bundles)
		{
			if (bundle.Value.settings.IsEnabledAndSupported(context))
			{
				val |= bundle.Value.renderer.GetCameraFlags();
			}
		}
		if (context.IsTemporalAntialiasingActive())
		{
			val |= temporalAntialiasing.GetCameraFlags();
		}
		if (fog.IsEnabledAndSupported(context))
		{
			val |= fog.GetCameraFlags();
		}
		if (debugLayer.debugOverlay != 0)
		{
			val |= debugLayer.GetCameraFlags();
		}
		context.camera.depthTextureMode = val;
	}

	public void ResetHistory()
	{
		foreach (KeyValuePair<Type, PostProcessBundle> bundle in m_Bundles)
		{
			bundle.Value.ResetHistory();
		}
		temporalAntialiasing.ResetHistory();
	}

	public bool HasOpaqueOnlyEffects(PostProcessRenderContext context)
	{
		return HasActiveEffects(PostProcessEvent.BeforeTransparent, context);
	}

	public bool HasActiveEffects(PostProcessEvent evt, PostProcessRenderContext context)
	{
		foreach (SerializedBundleRef item in sortedBundles[evt])
		{
			bool flag = item.bundle.settings.IsEnabledAndSupported(context);
			if (context.isSceneView)
			{
				if (item.bundle.attribute.allowInSceneView && flag)
				{
					return true;
				}
			}
			else if (flag)
			{
				return true;
			}
		}
		return false;
	}

	private void SetupContext(PostProcessRenderContext context)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Invalid comparison between Unknown and I4
		RuntimeUtilities.s_Resources = m_Resources;
		m_IsRenderingInSceneView = (int)context.camera.cameraType == 2;
		context.isSceneView = m_IsRenderingInSceneView;
		context.resources = m_Resources;
		context.propertySheets = m_PropertySheetFactory;
		context.debugLayer = debugLayer;
		context.antialiasing = antialiasingMode;
		context.temporalAntialiasing = temporalAntialiasing;
		context.logHistogram = m_LogHistogram;
		context.physicalCamera = context.camera.usePhysicalProperties;
		SetLegacyCameraFlags(context);
		debugLayer.SetFrameSize(context.width, context.height);
		m_CurrentContext = context;
	}

	public void UpdateVolumeSystem(Camera cam, CommandBuffer cmd)
	{
		if (m_SettingsUpdateNeeded)
		{
			cmd.BeginSample("VolumeBlending");
			PostProcessManager.instance.UpdateSettings(this, cam);
			cmd.EndSample("VolumeBlending");
			m_TargetPool.Reset();
			if (RuntimeUtilities.scriptableRenderPipelineActive)
			{
				Shader.SetGlobalFloat(ShaderIDs.RenderViewportScaleFactor, 1f);
			}
		}
		m_SettingsUpdateNeeded = false;
	}

	public void RenderOpaqueOnly(PostProcessRenderContext context)
	{
		if (RuntimeUtilities.scriptableRenderPipelineActive)
		{
			SetupContext(context);
		}
		TextureLerper.instance.BeginFrame(context);
		UpdateVolumeSystem(context.camera, context.command);
		RenderList(sortedBundles[PostProcessEvent.BeforeTransparent], context, "OpaqueOnly");
	}

	public void Render(PostProcessRenderContext context)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		if (RuntimeUtilities.scriptableRenderPipelineActive)
		{
			SetupContext(context);
		}
		TextureLerper.instance.BeginFrame(context);
		CommandBuffer command = context.command;
		UpdateVolumeSystem(context.camera, context.command);
		int num = -1;
		RenderTargetIdentifier source = context.source;
		if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
		{
			command.SetSinglePassStereo((SinglePassStereoMode)0);
			command.DisableShaderKeyword("UNITY_SINGLE_PASS_STEREO");
		}
		for (int i = 0; i < context.numberOfEyes; i++)
		{
			bool flag = false;
			if (stopNaNPropagation && !m_NaNKilled)
			{
				num = m_TargetPool.Get();
				context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
				if (context.stereoActive && context.numberOfEyes > 1)
				{
					if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
					{
						command.BlitFullscreenTriangleFromTexArray(context.source, RenderTargetIdentifier.op_Implicit(num), RuntimeUtilities.copyFromTexArraySheet, 1, clear: false, i);
						flag = true;
					}
					else if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
					{
						command.BlitFullscreenTriangleFromDoubleWide(context.source, RenderTargetIdentifier.op_Implicit(num), RuntimeUtilities.copyStdFromDoubleWideMaterial, 1, i);
						flag = true;
					}
				}
				else
				{
					command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num), RuntimeUtilities.copySheet, 1, clear: false, null);
				}
				context.source = RenderTargetIdentifier.op_Implicit(num);
				m_NaNKilled = true;
			}
			if (!flag && context.numberOfEyes > 1)
			{
				num = m_TargetPool.Get();
				context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
				if (context.stereoActive)
				{
					if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
					{
						command.BlitFullscreenTriangleFromTexArray(context.source, RenderTargetIdentifier.op_Implicit(num), RuntimeUtilities.copyFromTexArraySheet, 1, clear: false, i);
						flag = true;
					}
					else if (context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
					{
						command.BlitFullscreenTriangleFromDoubleWide(context.source, RenderTargetIdentifier.op_Implicit(num), RuntimeUtilities.copyStdFromDoubleWideMaterial, stopNaNPropagation ? 1 : 0, i);
						flag = true;
					}
				}
				context.source = RenderTargetIdentifier.op_Implicit(num);
			}
			bool num2 = HasActiveEffects(PostProcessEvent.BeforeStack, context);
			bool flag2 = HasActiveEffects(PostProcessEvent.AfterStack, context) && !breakBeforeColorGrading;
			bool flag3 = (flag2 || antialiasingMode == Antialiasing.FastApproximateAntialiasing || (antialiasingMode == Antialiasing.SubpixelMorphologicalAntialiasing && subpixelMorphologicalAntialiasing.IsSupported())) && !breakBeforeColorGrading;
			if (num2)
			{
				num = RenderInjectionPoint(PostProcessEvent.BeforeStack, context, "BeforeStack", num);
			}
			num = RenderBuiltins(context, !flag3, num, i);
			if (flag2)
			{
				num = RenderInjectionPoint(PostProcessEvent.AfterStack, context, "AfterStack", num);
			}
			if (flag3)
			{
				RenderFinalPass(context, num, i);
			}
			if (context.stereoActive)
			{
				context.source = source;
			}
		}
		if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
		{
			command.SetSinglePassStereo((SinglePassStereoMode)1);
			command.EnableShaderKeyword("UNITY_SINGLE_PASS_STEREO");
		}
		debugLayer.RenderSpecialOverlays(context);
		debugLayer.RenderMonitors(context);
		TextureLerper.instance.EndFrame();
		debugLayer.EndFrame();
		m_SettingsUpdateNeeded = true;
		m_NaNKilled = false;
	}

	private int RenderInjectionPoint(PostProcessEvent evt, PostProcessRenderContext context, string marker, int releaseTargetAfterUse = -1)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		int num = m_TargetPool.Get();
		RenderTargetIdentifier destination = context.destination;
		CommandBuffer command = context.command;
		context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
		context.destination = RenderTargetIdentifier.op_Implicit(num);
		RenderList(sortedBundles[evt], context, marker);
		context.source = RenderTargetIdentifier.op_Implicit(num);
		context.destination = destination;
		if (releaseTargetAfterUse > -1)
		{
			command.ReleaseTemporaryRT(releaseTargetAfterUse);
		}
		return num;
	}

	private void RenderList(List<SerializedBundleRef> list, PostProcessRenderContext context, string marker)
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample(marker);
		m_ActiveEffects.Clear();
		for (int i = 0; i < list.Count; i++)
		{
			PostProcessBundle bundle = list[i].bundle;
			if (bundle.settings.IsEnabledAndSupported(context) && (!context.isSceneView || (context.isSceneView && bundle.attribute.allowInSceneView)))
			{
				m_ActiveEffects.Add(bundle.renderer);
			}
		}
		int count = m_ActiveEffects.Count;
		if (count == 1)
		{
			m_ActiveEffects[0].Render(context);
		}
		else
		{
			m_Targets.Clear();
			m_Targets.Add(context.source);
			int num = m_TargetPool.Get();
			int num2 = m_TargetPool.Get();
			for (int j = 0; j < count - 1; j++)
			{
				m_Targets.Add(RenderTargetIdentifier.op_Implicit((j % 2 == 0) ? num : num2));
			}
			m_Targets.Add(context.destination);
			context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
			if (count > 2)
			{
				context.GetScreenSpaceTemporaryRT(command, num2, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
			}
			for (int k = 0; k < count; k++)
			{
				context.source = m_Targets[k];
				context.destination = m_Targets[k + 1];
				m_ActiveEffects[k].Render(context);
			}
			command.ReleaseTemporaryRT(num);
			if (count > 2)
			{
				command.ReleaseTemporaryRT(num2);
			}
		}
		command.EndSample(marker);
	}

	private void ApplyFlip(PostProcessRenderContext context, MaterialPropertyBlock properties)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (context.flip && !context.isSceneView)
		{
			properties.SetVector(ShaderIDs.UVTransform, new Vector4(1f, 1f, 0f, 0f));
		}
		else
		{
			ApplyDefaultFlip(properties);
		}
	}

	private void ApplyDefaultFlip(MaterialPropertyBlock properties)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		properties.SetVector(ShaderIDs.UVTransform, SystemInfo.graphicsUVStartsAtTop ? new Vector4(1f, -1f, 0f, 1f) : new Vector4(1f, 1f, 0f, 0f));
	}

	private int RenderBuiltins(PostProcessRenderContext context, bool isFinalPass, int releaseTargetAfterUse = -1, int eye = -1)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.uber);
		propertySheet.ClearKeywords();
		propertySheet.properties.Clear();
		context.uberSheet = propertySheet;
		context.bloomBufferNameID = -1;
		context.autoExposureTexture = (Texture)(object)RuntimeUtilities.whiteTexture;
		if (isFinalPass && context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
		{
			propertySheet.EnableKeyword("STEREO_INSTANCING_ENABLED");
		}
		CommandBuffer command = context.command;
		command.BeginSample("BuiltinStack");
		int num = -1;
		RenderTargetIdentifier destination = context.destination;
		if (!isFinalPass)
		{
			num = m_TargetPool.Get();
			context.GetScreenSpaceTemporaryRT(command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
			context.destination = RenderTargetIdentifier.op_Implicit(num);
			if (antialiasingMode == Antialiasing.FastApproximateAntialiasing && !fastApproximateAntialiasing.keepAlpha)
			{
				propertySheet.properties.SetFloat(ShaderIDs.LumaInAlpha, 1f);
			}
		}
		int num2 = RenderEffect<DepthOfFieldEffect>(context, useTempTarget: true);
		int num3 = RenderEffect<MotionBlur>(context, useTempTarget: true);
		if (ShouldGenerateLogHistogram(context))
		{
			m_LogHistogram.Generate(context);
		}
		RenderEffect<AutoExposure>(context);
		propertySheet.properties.SetTexture(ShaderIDs.AutoExposureTex, context.autoExposureTexture);
		RenderEffect<LensDistortion>(context);
		RenderEffect<ChromaticAberration>(context);
		RenderEffect<Bloom>(context);
		RenderEffect<Vignette>(context);
		RenderEffect<Grain>(context);
		if (!breakBeforeColorGrading)
		{
			RenderEffect<ColorGrading>(context);
		}
		if (isFinalPass)
		{
			propertySheet.EnableKeyword("FINALPASS");
			dithering.Render(context);
			ApplyFlip(context, propertySheet.properties);
		}
		else
		{
			ApplyDefaultFlip(propertySheet.properties);
		}
		if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
		{
			propertySheet.properties.SetFloat(ShaderIDs.DepthSlice, (float)eye);
			command.BlitFullscreenTriangleToTexArray(context.source, context.destination, propertySheet, 0, clear: false, eye);
		}
		else if (isFinalPass && context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
		{
			command.BlitFullscreenTriangleToDoubleWide(context.source, context.destination, propertySheet, 0, eye);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		context.source = context.destination;
		context.destination = destination;
		if (releaseTargetAfterUse > -1)
		{
			command.ReleaseTemporaryRT(releaseTargetAfterUse);
		}
		if (num3 > -1)
		{
			command.ReleaseTemporaryRT(num3);
		}
		if (num2 > -1)
		{
			command.ReleaseTemporaryRT(num2);
		}
		if (context.bloomBufferNameID > -1)
		{
			command.ReleaseTemporaryRT(context.bloomBufferNameID);
		}
		command.EndSample("BuiltinStack");
		return num;
	}

	private void RenderFinalPass(PostProcessRenderContext context, int releaseTargetAfterUse = -1, int eye = -1)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("FinalPass");
		if (breakBeforeColorGrading)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.discardAlpha);
			if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
			{
				propertySheet.EnableKeyword("STEREO_INSTANCING_ENABLED");
			}
			if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
			{
				propertySheet.properties.SetFloat(ShaderIDs.DepthSlice, (float)eye);
				command.BlitFullscreenTriangleToTexArray(context.source, context.destination, propertySheet, 0, clear: false, eye);
			}
			else if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
			{
				command.BlitFullscreenTriangleToDoubleWide(context.source, context.destination, propertySheet, 0, eye);
			}
			else
			{
				command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
			}
		}
		else
		{
			PropertySheet propertySheet2 = context.propertySheets.Get(context.resources.shaders.finalPass);
			propertySheet2.ClearKeywords();
			propertySheet2.properties.Clear();
			context.uberSheet = propertySheet2;
			int num = -1;
			if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
			{
				propertySheet2.EnableKeyword("STEREO_INSTANCING_ENABLED");
			}
			if (antialiasingMode == Antialiasing.FastApproximateAntialiasing)
			{
				propertySheet2.EnableKeyword(fastApproximateAntialiasing.fastMode ? "FXAA_LOW" : "FXAA");
				if (fastApproximateAntialiasing.keepAlpha)
				{
					propertySheet2.EnableKeyword("FXAA_KEEP_ALPHA");
				}
			}
			else if (antialiasingMode == Antialiasing.SubpixelMorphologicalAntialiasing && subpixelMorphologicalAntialiasing.IsSupported())
			{
				num = m_TargetPool.Get();
				RenderTargetIdentifier destination = context.destination;
				context.GetScreenSpaceTemporaryRT(context.command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
				context.destination = RenderTargetIdentifier.op_Implicit(num);
				subpixelMorphologicalAntialiasing.Render(context);
				context.source = RenderTargetIdentifier.op_Implicit(num);
				context.destination = destination;
			}
			dithering.Render(context);
			ApplyFlip(context, propertySheet2.properties);
			if (context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePassInstanced)
			{
				propertySheet2.properties.SetFloat(ShaderIDs.DepthSlice, (float)eye);
				command.BlitFullscreenTriangleToTexArray(context.source, context.destination, propertySheet2, 0, clear: false, eye);
			}
			else if (context.stereoActive && context.numberOfEyes > 1 && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass)
			{
				command.BlitFullscreenTriangleToDoubleWide(context.source, context.destination, propertySheet2, 0, eye);
			}
			else
			{
				command.BlitFullscreenTriangle(context.source, context.destination, propertySheet2, 0, clear: false, null);
			}
			if (num > -1)
			{
				command.ReleaseTemporaryRT(num);
			}
		}
		if (releaseTargetAfterUse > -1)
		{
			command.ReleaseTemporaryRT(releaseTargetAfterUse);
		}
		command.EndSample("FinalPass");
	}

	private int RenderEffect<T>(PostProcessRenderContext context, bool useTempTarget = false) where T : PostProcessEffectSettings
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		PostProcessBundle bundle = GetBundle<T>();
		if (!bundle.settings.IsEnabledAndSupported(context))
		{
			return -1;
		}
		if (m_IsRenderingInSceneView && !bundle.attribute.allowInSceneView)
		{
			return -1;
		}
		if (!useTempTarget)
		{
			bundle.renderer.Render(context);
			return -1;
		}
		RenderTargetIdentifier destination = context.destination;
		int num = m_TargetPool.Get();
		context.GetScreenSpaceTemporaryRT(context.command, num, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1);
		context.destination = RenderTargetIdentifier.op_Implicit(num);
		bundle.renderer.Render(context);
		context.source = RenderTargetIdentifier.op_Implicit(num);
		context.destination = destination;
		return num;
	}

	private bool ShouldGenerateLogHistogram(PostProcessRenderContext context)
	{
		bool num = GetBundle<AutoExposure>().settings.IsEnabledAndSupported(context);
		bool flag = debugLayer.lightMeter.IsRequestedAndSupported(context);
		return num || flag;
	}
}


private enum ScalingMode
{
	NATIVE,
	BILINEAR,
	DLSS
}


public enum Antialiasing
{
	None,
	FastApproximateAntialiasing,
	SubpixelMorphologicalAntialiasing,
	TemporalAntialiasing
}


using System;

[Serializable]
public sealed class SerializedBundleRef
{
	public string assemblyQualifiedName;

	public PostProcessBundle bundle;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class PostProcessRenderContext
{
	public enum StereoRenderingMode
	{
		MultiPass,
		SinglePass,
		SinglePassInstanced,
		SinglePassMultiview
	}

	public bool dlssEnabled;

	private Camera m_Camera;

	internal PropertySheet uberSheet;

	internal Texture autoExposureTexture;

	internal LogHistogram logHistogram;

	internal Texture logLut;

	internal AutoExposure autoExposure;

	internal int bloomBufferNameID;

	internal bool physicalCamera;

	private RenderTextureDescriptor m_sourceDescriptor;

	public Camera camera
	{
		get
		{
			return m_Camera;
		}
		set
		{
			m_Camera = value;
			if (!m_Camera.stereoEnabled)
			{
				width = m_Camera.pixelWidth;
				height = m_Camera.pixelHeight;
				((RenderTextureDescriptor)(ref m_sourceDescriptor)).width = width;
				((RenderTextureDescriptor)(ref m_sourceDescriptor)).height = height;
				screenWidth = width;
				screenHeight = height;
				stereoActive = false;
				numberOfEyes = 1;
			}
		}
	}

	public CommandBuffer command { get; set; }

	public RenderTargetIdentifier source { get; set; }

	public RenderTargetIdentifier destination { get; set; }

	public RenderTextureFormat sourceFormat { get; set; }

	public bool flip { get; set; }

	public PostProcessResources resources { get; internal set; }

	public PropertySheetFactory propertySheets { get; internal set; }

	public Dictionary<string, object> userData { get; private set; }

	public PostProcessDebugLayer debugLayer { get; internal set; }

	public int width { get; set; }

	public int height { get; set; }

	public bool stereoActive { get; private set; }

	public int xrActiveEye { get; private set; }

	public int numberOfEyes { get; private set; }

	public StereoRenderingMode stereoRenderingMode { get; private set; }

	public int screenWidth { get; set; }

	public int screenHeight { get; set; }

	public bool isSceneView { get; internal set; }

	public PostProcessLayer.Antialiasing antialiasing { get; internal set; }

	public TemporalAntialiasing temporalAntialiasing { get; internal set; }

	public void Resize(int width, int height, bool dlssEnabled)
	{
		int num2 = (screenWidth = width);
		this.width = num2;
		num2 = (screenHeight = height);
		this.height = num2;
		this.dlssEnabled = dlssEnabled;
		((RenderTextureDescriptor)(ref m_sourceDescriptor)).width = width;
		((RenderTextureDescriptor)(ref m_sourceDescriptor)).height = height;
	}

	public void Reset()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		m_Camera = null;
		width = 0;
		height = 0;
		dlssEnabled = false;
		m_sourceDescriptor = new RenderTextureDescriptor(0, 0);
		physicalCamera = false;
		stereoActive = false;
		xrActiveEye = 0;
		screenWidth = 0;
		screenHeight = 0;
		command = null;
		source = RenderTargetIdentifier.op_Implicit(0);
		destination = RenderTargetIdentifier.op_Implicit(0);
		sourceFormat = (RenderTextureFormat)0;
		flip = false;
		resources = null;
		propertySheets = null;
		debugLayer = null;
		isSceneView = false;
		antialiasing = PostProcessLayer.Antialiasing.None;
		temporalAntialiasing = null;
		uberSheet = null;
		autoExposureTexture = null;
		logLut = null;
		autoExposure = null;
		bloomBufferNameID = -1;
		if (userData == null)
		{
			userData = new Dictionary<string, object>();
		}
		userData.Clear();
	}

	public bool IsTemporalAntialiasingActive()
	{
		return false;
	}

	public bool IsDebugOverlayEnabled(DebugOverlay overlay)
	{
		return debugLayer.debugOverlay == overlay;
	}

	public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		debugLayer.PushDebugOverlay(cmd, source, sheet, pass);
	}

	private RenderTextureDescriptor GetDescriptor(int depthBufferBits = 0, RenderTextureFormat colorFormat = 7, RenderTextureReadWrite readWrite = 0)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Invalid comparison between Unknown and I4
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Invalid comparison between Unknown and I4
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Invalid comparison between Unknown and I4
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Invalid comparison between Unknown and I4
		RenderTextureDescriptor result = default(RenderTextureDescriptor);
		((RenderTextureDescriptor)(ref result))..ctor(((RenderTextureDescriptor)(ref m_sourceDescriptor)).width, ((RenderTextureDescriptor)(ref m_sourceDescriptor)).height, ((RenderTextureDescriptor)(ref m_sourceDescriptor)).colorFormat, depthBufferBits);
		((RenderTextureDescriptor)(ref result)).dimension = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).dimension;
		((RenderTextureDescriptor)(ref result)).volumeDepth = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).volumeDepth;
		((RenderTextureDescriptor)(ref result)).vrUsage = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).vrUsage;
		((RenderTextureDescriptor)(ref result)).msaaSamples = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).msaaSamples;
		((RenderTextureDescriptor)(ref result)).memoryless = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).memoryless;
		((RenderTextureDescriptor)(ref result)).useMipMap = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).useMipMap;
		((RenderTextureDescriptor)(ref result)).autoGenerateMips = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).autoGenerateMips;
		((RenderTextureDescriptor)(ref result)).enableRandomWrite = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).enableRandomWrite;
		((RenderTextureDescriptor)(ref result)).shadowSamplingMode = ((RenderTextureDescriptor)(ref m_sourceDescriptor)).shadowSamplingMode;
		if ((int)colorFormat != 7)
		{
			((RenderTextureDescriptor)(ref result)).colorFormat = colorFormat;
		}
		if ((int)readWrite == 2)
		{
			((RenderTextureDescriptor)(ref result)).sRGB = true;
		}
		else if ((int)readWrite == 1)
		{
			((RenderTextureDescriptor)(ref result)).sRGB = false;
		}
		else if ((int)readWrite == 0)
		{
			((RenderTextureDescriptor)(ref result)).sRGB = (int)QualitySettings.activeColorSpace > 0;
		}
		return result;
	}

	public void GetScreenSpaceTemporaryRT(CommandBuffer cmd, int nameID, int depthBufferBits = 0, RenderTextureFormat colorFormat = 7, RenderTextureReadWrite readWrite = 0, FilterMode filter = 1, int widthOverride = 0, int heightOverride = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Invalid comparison between Unknown and I4
		RenderTextureDescriptor descriptor = GetDescriptor(depthBufferBits, colorFormat, readWrite);
		if (widthOverride > 0)
		{
			((RenderTextureDescriptor)(ref descriptor)).width = widthOverride;
		}
		if (heightOverride > 0)
		{
			((RenderTextureDescriptor)(ref descriptor)).height = heightOverride;
		}
		if (stereoActive && (int)((RenderTextureDescriptor)(ref descriptor)).dimension == 5)
		{
			((RenderTextureDescriptor)(ref descriptor)).dimension = (TextureDimension)2;
		}
		cmd.GetTemporaryRT(nameID, descriptor, filter);
	}

	public RenderTexture GetScreenSpaceTemporaryRT(int depthBufferBits = 0, RenderTextureFormat colorFormat = 7, RenderTextureReadWrite readWrite = 0, int widthOverride = 0, int heightOverride = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureDescriptor descriptor = GetDescriptor(depthBufferBits, colorFormat, readWrite);
		if (widthOverride > 0)
		{
			((RenderTextureDescriptor)(ref descriptor)).width = widthOverride;
		}
		if (heightOverride > 0)
		{
			((RenderTextureDescriptor)(ref descriptor)).height = heightOverride;
		}
		return RenderTexture.GetTemporary(descriptor);
	}
}


public enum StereoRenderingMode
{
	MultiPass,
	SinglePass,
	SinglePassInstanced,
	SinglePassMultiview
}


using System;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
public sealed class DisplayNameAttribute : Attribute
{
	public readonly string displayName;

	public DisplayNameAttribute(string displayName)
	{
		this.displayName = displayName;
	}
}


using System;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
public sealed class MaxAttribute : Attribute
{
	public readonly float max;

	public MaxAttribute(float max)
	{
		this.max = max;
	}
}


using System;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
public sealed class MinAttribute : Attribute
{
	public readonly float min;

	public MinAttribute(float min)
	{
		this.min = min;
	}
}


using System;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
public sealed class MinMaxAttribute : Attribute
{
	public readonly float min;

	public readonly float max;

	public MinMaxAttribute(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
public sealed class PostProcessAttribute : Attribute
{
	public readonly Type renderer;

	public readonly PostProcessEvent eventType;

	public readonly string menuItem;

	public readonly bool allowInSceneView;

	internal readonly bool builtinEffect;

	public PostProcessAttribute(Type renderer, PostProcessEvent eventType, string menuItem, bool allowInSceneView = true)
	{
		this.renderer = renderer;
		this.eventType = eventType;
		this.menuItem = menuItem;
		this.allowInSceneView = allowInSceneView;
		builtinEffect = false;
	}

	internal PostProcessAttribute(Type renderer, string menuItem, bool allowInSceneView = true)
	{
		this.renderer = renderer;
		this.menuItem = menuItem;
		this.allowInSceneView = allowInSceneView;
		builtinEffect = true;
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[AttributeUsage(AttributeTargets.Field, AllowMultiple = false)]
public sealed class TrackballAttribute : Attribute
{
	public enum Mode
	{
		None,
		Lift,
		Gamma,
		Gain
	}

	public readonly Mode mode;

	public TrackballAttribute(Mode mode)
	{
		this.mode = mode;
	}
}


public enum Mode
{
	None,
	Lift,
	Gamma,
	Gain
}


public enum AmbientOcclusionMode
{
	ScalableAmbientObscurance,
	MultiScaleVolumetricObscurance
}


public enum AmbientOcclusionQuality
{
	Lowest,
	Low,
	Medium,
	High,
	Ultra
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class AmbientOcclusionModeParameter : ParameterOverride<AmbientOcclusionMode>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class AmbientOcclusionQualityParameter : ParameterOverride<AmbientOcclusionQuality>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(AmbientOcclusionRenderer), "Unity/Ambient Occlusion", true)]
public sealed class AmbientOcclusion : PostProcessEffectSettings
{
	[Tooltip("The ambient occlusion method to use. \"Multi Scale Volumetric Obscurance\" is higher quality and faster on desktop & console platforms but requires compute shader support.")]
	public AmbientOcclusionModeParameter mode = new AmbientOcclusionModeParameter
	{
		value = AmbientOcclusionMode.MultiScaleVolumetricObscurance
	};

	[Tooltip("The degree of darkness added by ambient occlusion. Higher values produce darker areas.")]
	[Range(0f, 4f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("The custom color to use for the ambient occlusion. The default is black.")]
	[ColorUsage(false)]
	public ColorParameter color = new ColorParameter
	{
		value = Color.black
	};

	[Tooltip("Check this box to mark this Volume as to only affect ambient lighting. This mode is only available with the Deferred rendering path and HDR rendering. Objects rendered with the Forward rendering path won't get any ambient occlusion.")]
	public BoolParameter ambientOnly = new BoolParameter
	{
		value = true
	};

	[Range(-8f, 0f)]
	public FloatParameter noiseFilterTolerance = new FloatParameter
	{
		value = 0f
	};

	[Range(-8f, -1f)]
	public FloatParameter blurTolerance = new FloatParameter
	{
		value = -4.6f
	};

	[Range(-12f, -1f)]
	public FloatParameter upsampleTolerance = new FloatParameter
	{
		value = -12f
	};

	[Range(1f, 10f)]
	[Tooltip("This modifies the thickness of occluders. It increases the size of dark areas and also introduces a dark halo around objects.")]
	public FloatParameter thicknessModifier = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	[Tooltip("Modifies the influence of direct lighting on ambient occlusion.")]
	public FloatParameter directLightingStrength = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("The radius of sample points. This affects the size of darkened areas.")]
	public FloatParameter radius = new FloatParameter
	{
		value = 0.25f
	};

	[Tooltip("The number of sample points. This affects both quality and performance. For \"Lowest\", \"Low\", and \"Medium\", passes are downsampled. For \"High\" and \"Ultra\", they are not and therefore you should only \"High\" and \"Ultra\" on high-end hardware.")]
	public AmbientOcclusionQualityParameter quality = new AmbientOcclusionQualityParameter
	{
		value = AmbientOcclusionQuality.Medium
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		bool flag = enabled.value && intensity.value > 0f;
		if (mode.value == AmbientOcclusionMode.ScalableAmbientObscurance)
		{
			flag &= !RuntimeUtilities.scriptableRenderPipelineActive;
			if (context != null)
			{
				flag &= Object.op_Implicit((Object)(object)context.resources.shaders.scalableAO) && context.resources.shaders.scalableAO.isSupported;
			}
		}
		else if (mode.value == AmbientOcclusionMode.MultiScaleVolumetricObscurance)
		{
			if (context != null)
			{
				flag &= Object.op_Implicit((Object)(object)context.resources.shaders.multiScaleAO) && context.resources.shaders.multiScaleAO.isSupported && Object.op_Implicit((Object)(object)context.resources.computeShaders.multiScaleAODownsample1) && Object.op_Implicit((Object)(object)context.resources.computeShaders.multiScaleAODownsample2) && Object.op_Implicit((Object)(object)context.resources.computeShaders.multiScaleAORender) && Object.op_Implicit((Object)(object)context.resources.computeShaders.multiScaleAOUpsample);
			}
			flag &= SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL && ((RenderTextureFormat)14).IsSupported() && ((RenderTextureFormat)15).IsSupported() && ((RenderTextureFormat)16).IsSupported();
		}
		return flag;
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

internal interface IAmbientOcclusionMethod
{
	DepthTextureMode GetCameraFlags();

	void RenderAfterOpaque(PostProcessRenderContext context);

	void RenderAmbientOnly(PostProcessRenderContext context);

	void CompositeAmbientOnly(PostProcessRenderContext context);

	void Release();
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class AmbientOcclusionRenderer : PostProcessEffectRenderer<AmbientOcclusion>
{
	private IAmbientOcclusionMethod[] m_Methods;

	public override void Init()
	{
		if (m_Methods == null)
		{
			m_Methods = new IAmbientOcclusionMethod[2]
			{
				new ScalableAO(base.settings),
				new MultiScaleVO(base.settings)
			};
		}
	}

	public bool IsAmbientOnly(PostProcessRenderContext context)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Invalid comparison between Unknown and I4
		Camera camera = context.camera;
		if (base.settings.ambientOnly.value && (int)camera.actualRenderingPath == 3)
		{
			return camera.allowHDR;
		}
		return false;
	}

	public IAmbientOcclusionMethod Get()
	{
		return m_Methods[(int)base.settings.mode.value];
	}

	public override DepthTextureMode GetCameraFlags()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Get().GetCameraFlags();
	}

	public override void Release()
	{
		IAmbientOcclusionMethod[] methods = m_Methods;
		for (int i = 0; i < methods.Length; i++)
		{
			methods[i].Release();
		}
	}

	public ScalableAO GetScalableAO()
	{
		return (ScalableAO)m_Methods[0];
	}

	public MultiScaleVO GetMultiScaleVO()
	{
		return (MultiScaleVO)m_Methods[1];
	}

	public override void Render(PostProcessRenderContext context)
	{
	}
}


public enum EyeAdaptation
{
	Progressive,
	Fixed
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class EyeAdaptationParameter : ParameterOverride<EyeAdaptation>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(AutoExposureRenderer), "Unity/Auto Exposure", true)]
public sealed class AutoExposure : PostProcessEffectSettings
{
	[UnityEngine.Rendering.PostProcessing.MinMax(1f, 99f)]
	[DisplayName("Filtering (%)")]
	[Tooltip("Filters the bright and dark parts of the histogram when computing the average luminance. This is to avoid very dark pixels and very bright pixels from contributing to the auto exposure. Unit is in percent.")]
	public Vector2Parameter filtering = new Vector2Parameter
	{
		value = new Vector2(50f, 95f)
	};

	[Tooltip("Minimum average luminance to consider for auto exposure. Unit is EV.")]
	[Range(-9f, 9f)]
	[DisplayName("Minimum (EV)")]
	public FloatParameter minLuminance = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Maximum average luminance to consider for auto exposure. Unit is EV.")]
	[DisplayName("Maximum (EV)")]
	[Range(-9f, 9f)]
	public FloatParameter maxLuminance = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Use this to scale the global exposure of the scene.")]
	[DisplayName("Exposure Compensation")]
	[Min(0f)]
	public FloatParameter keyValue = new FloatParameter
	{
		value = 1f
	};

	[DisplayName("Type")]
	[Tooltip("Use \"Progressive\" if you want auto exposure to be animated. Use \"Fixed\" otherwise.")]
	public EyeAdaptationParameter eyeAdaptation = new EyeAdaptationParameter
	{
		value = EyeAdaptation.Progressive
	};

	[Min(0f)]
	[Tooltip("Adaptation speed from a dark to a light environment.")]
	public FloatParameter speedUp = new FloatParameter
	{
		value = 2f
	};

	[Min(0f)]
	[Tooltip("Adaptation speed from a light to a dark environment.")]
	public FloatParameter speedDown = new FloatParameter
	{
		value = 1f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value && SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL && ((RenderTextureFormat)14).IsSupported() && Object.op_Implicit((Object)(object)context.resources.computeShaders.autoExposure))
		{
			return Object.op_Implicit((Object)(object)context.resources.computeShaders.exposureHistogram);
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class AutoExposureRenderer : PostProcessEffectRenderer<AutoExposure>
{
	private const int k_NumEyes = 2;

	private const int k_NumAutoExposureTextures = 2;

	private readonly RenderTexture[][] m_AutoExposurePool = new RenderTexture[2][];

	private int[] m_AutoExposurePingPong = new int[2];

	private RenderTexture m_CurrentAutoExposure;

	public AutoExposureRenderer()
	{
		for (int i = 0; i < 2; i++)
		{
			m_AutoExposurePool[i] = (RenderTexture[])(object)new RenderTexture[2];
			m_AutoExposurePingPong[i] = 0;
		}
	}

	private void CheckTexture(int eye, int id)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		if ((Object)(object)m_AutoExposurePool[eye][id] == (Object)null || !m_AutoExposurePool[eye][id].IsCreated())
		{
			m_AutoExposurePool[eye][id] = new RenderTexture(1, 1, 0, (RenderTextureFormat)14)
			{
				enableRandomWrite = true
			};
			m_AutoExposurePool[eye][id].Create();
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("AutoExposureLookup");
		CheckTexture(context.xrActiveEye, 0);
		CheckTexture(context.xrActiveEye, 1);
		float x = base.settings.filtering.value.x;
		float y = base.settings.filtering.value.y;
		y = Mathf.Clamp(y, 1.01f, 99f);
		x = Mathf.Clamp(x, 1f, y - 0.01f);
		float value = base.settings.minLuminance.value;
		float value2 = base.settings.maxLuminance.value;
		base.settings.minLuminance.value = Mathf.Min(value, value2);
		base.settings.maxLuminance.value = Mathf.Max(value, value2);
		bool num = m_ResetHistory || !Application.isPlaying;
		string text = null;
		text = ((!num && base.settings.eyeAdaptation.value != EyeAdaptation.Fixed) ? "KAutoExposureAvgLuminance_progressive" : "KAutoExposureAvgLuminance_fixed");
		ComputeShader autoExposure = context.resources.computeShaders.autoExposure;
		int num2 = autoExposure.FindKernel(text);
		command.SetComputeBufferParam(autoExposure, num2, "_HistogramBuffer", context.logHistogram.data);
		command.SetComputeVectorParam(autoExposure, "_Params1", new Vector4(x * 0.01f, y * 0.01f, RuntimeUtilities.Exp2(base.settings.minLuminance.value), RuntimeUtilities.Exp2(base.settings.maxLuminance.value)));
		command.SetComputeVectorParam(autoExposure, "_Params2", new Vector4(base.settings.speedDown.value, base.settings.speedUp.value, base.settings.keyValue.value, Time.deltaTime));
		command.SetComputeVectorParam(autoExposure, "_ScaleOffsetRes", context.logHistogram.GetHistogramScaleOffsetRes(context));
		if (num)
		{
			m_CurrentAutoExposure = m_AutoExposurePool[context.xrActiveEye][0];
			command.SetComputeTextureParam(autoExposure, num2, "_Destination", RenderTargetIdentifier.op_Implicit((Texture)(object)m_CurrentAutoExposure));
			command.DispatchCompute(autoExposure, num2, 1, 1, 1);
			RuntimeUtilities.CopyTexture(command, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AutoExposurePool[context.xrActiveEye][0]), RenderTargetIdentifier.op_Implicit((Texture)(object)m_AutoExposurePool[context.xrActiveEye][1]));
			m_ResetHistory = false;
		}
		else
		{
			int num3 = m_AutoExposurePingPong[context.xrActiveEye];
			RenderTexture val = m_AutoExposurePool[context.xrActiveEye][++num3 % 2];
			RenderTexture val2 = m_AutoExposurePool[context.xrActiveEye][++num3 % 2];
			command.SetComputeTextureParam(autoExposure, num2, "_Source", RenderTargetIdentifier.op_Implicit((Texture)(object)val));
			command.SetComputeTextureParam(autoExposure, num2, "_Destination", RenderTargetIdentifier.op_Implicit((Texture)(object)val2));
			command.DispatchCompute(autoExposure, num2, 1, 1, 1);
			m_AutoExposurePingPong[context.xrActiveEye] = ++num3 % 2;
			m_CurrentAutoExposure = val2;
		}
		command.EndSample("AutoExposureLookup");
		context.autoExposureTexture = (Texture)(object)m_CurrentAutoExposure;
		context.autoExposure = base.settings;
	}

	public override void Release()
	{
		RenderTexture[][] autoExposurePool = m_AutoExposurePool;
		foreach (RenderTexture[] array in autoExposurePool)
		{
			for (int j = 0; j < array.Length; j++)
			{
				RuntimeUtilities.Destroy((Object)(object)array[j]);
			}
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Serialization;

[Serializable]
[PostProcess(typeof(BloomRenderer), "Unity/Bloom", true)]
public sealed class Bloom : PostProcessEffectSettings
{
	[Tooltip("Strength of the bloom filter. Values higher than 1 will make bloom contribute more energy to the final render.")]
	[Min(0f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Min(0f)]
	[Tooltip("Filters out pixels under this level of brightness. Value is in gamma-space.")]
	public FloatParameter threshold = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Makes transitions between under/over-threshold gradual. 0 for a hard threshold, 1 for a soft threshold).")]
	[Range(0f, 1f)]
	public FloatParameter softKnee = new FloatParameter
	{
		value = 0.5f
	};

	[Tooltip("Clamps pixels to control the bloom amount. Value is in gamma-space.")]
	public FloatParameter clamp = new FloatParameter
	{
		value = 65472f
	};

	[Tooltip("Changes the extent of veiling effects. For maximum quality, use integer values. Because this value changes the internal iteration count, You should not animating it as it may introduce issues with the perceived radius.")]
	[Range(1f, 10f)]
	public FloatParameter diffusion = new FloatParameter
	{
		value = 7f
	};

	[Tooltip("Distorts the bloom to give an anamorphic look. Negative values distort vertically, positive values distort horizontally.")]
	[Range(-1f, 1f)]
	public FloatParameter anamorphicRatio = new FloatParameter
	{
		value = 0f
	};

	[ColorUsage(false, true)]
	[Tooltip("Global tint of the bloom filter.")]
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};

	[FormerlySerializedAs("mobileOptimized")]
	[Tooltip("Boost performance by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
	public BoolParameter fastMode = new BoolParameter
	{
		value = false
	};

	[DisplayName("Texture")]
	[Tooltip("The lens dirt texture used to add smudges or dust to the bloom effect.")]
	public TextureParameter dirtTexture = new TextureParameter
	{
		value = null
	};

	[DisplayName("Intensity")]
	[Tooltip("The intensity of the lens dirtiness.")]
	[Min(0f)]
	public FloatParameter dirtIntensity = new FloatParameter
	{
		value = 0f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value)
		{
			return intensity.value > 0f;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class BloomRenderer : PostProcessEffectRenderer<Bloom>
{
	private enum Pass
	{
		Prefilter13,
		Prefilter4,
		Downsample13,
		Downsample4,
		UpsampleTent,
		UpsampleBox,
		DebugOverlayThreshold,
		DebugOverlayTent,
		DebugOverlayBox
	}

	private struct Level
	{
		internal int down;

		internal int up;
	}

	private Level[] m_Pyramid;

	private const int k_MaxPyramidSize = 16;

	public override void Init()
	{
		m_Pyramid = new Level[16];
		for (int i = 0; i < 16; i++)
		{
			m_Pyramid[i] = new Level
			{
				down = Shader.PropertyToID("_BloomMipDown" + i),
				up = Shader.PropertyToID("_BloomMipUp" + i)
			};
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Invalid comparison between Unknown and I4
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0382: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0567: Unknown result type (might be due to invalid IL or missing references)
		//IL_0589: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("BloomPyramid");
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.bloom);
		propertySheet.properties.SetTexture(ShaderIDs.AutoExposureTex, context.autoExposureTexture);
		float num = Mathf.Clamp((float)base.settings.anamorphicRatio, -1f, 1f);
		float num2 = ((num < 0f) ? (0f - num) : 0f);
		float num3 = ((num > 0f) ? num : 0f);
		int num4 = Mathf.FloorToInt((float)context.screenWidth / (2f - num2));
		int num5 = Mathf.FloorToInt((float)context.screenHeight / (2f - num3));
		bool flag = context.stereoActive && context.stereoRenderingMode == PostProcessRenderContext.StereoRenderingMode.SinglePass && (int)context.camera.stereoTargetEye == 3;
		int num6 = (flag ? (num4 * 2) : num4);
		float num7 = Mathf.Log((float)Mathf.Max(num4, num5), 2f) + Mathf.Min(base.settings.diffusion.value, 10f) - 10f;
		int num8 = Mathf.FloorToInt(num7);
		int num9 = Mathf.Clamp(num8, 1, 16);
		float num10 = 0.5f + num7 - (float)num8;
		propertySheet.properties.SetFloat(ShaderIDs.SampleScale, num10);
		float num11 = Mathf.GammaToLinearSpace(base.settings.threshold.value);
		float num12 = num11 * base.settings.softKnee.value + 1E-05f;
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(num11, num11 - num12, num12 * 2f, 0.25f / num12);
		propertySheet.properties.SetVector(ShaderIDs.Threshold, val);
		float num13 = Mathf.GammaToLinearSpace(base.settings.clamp.value);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(num13, 0f, 0f, 0f));
		int num14 = (base.settings.fastMode ? 1 : 0);
		RenderTargetIdentifier source = context.source;
		for (int i = 0; i < num9; i++)
		{
			int down = m_Pyramid[i].down;
			int up = m_Pyramid[i].up;
			int pass = ((i == 0) ? num14 : (2 + num14));
			context.GetScreenSpaceTemporaryRT(command, down, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1, num6, num5);
			context.GetScreenSpaceTemporaryRT(command, up, 0, context.sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1, num6, num5);
			command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(down), propertySheet, pass, clear: false, null);
			source = RenderTargetIdentifier.op_Implicit(down);
			num6 = ((flag && num6 / 2 % 2 > 0) ? (1 + num6 / 2) : (num6 / 2));
			num6 = Mathf.Max(num6, 1);
			num5 = Mathf.Max(num5 / 2, 1);
		}
		int num15 = m_Pyramid[num9 - 1].down;
		for (int num16 = num9 - 2; num16 >= 0; num16--)
		{
			int down2 = m_Pyramid[num16].down;
			int up2 = m_Pyramid[num16].up;
			command.SetGlobalTexture(ShaderIDs.BloomTex, RenderTargetIdentifier.op_Implicit(down2));
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num15), RenderTargetIdentifier.op_Implicit(up2), propertySheet, 4 + num14, clear: false, null);
			num15 = up2;
		}
		Color linear = ((Color)(ref base.settings.color.value)).linear;
		float num17 = RuntimeUtilities.Exp2(base.settings.intensity.value / 10f) - 1f;
		Vector4 val2 = default(Vector4);
		((Vector4)(ref val2))..ctor(num10, num17, base.settings.dirtIntensity.value, (float)num9);
		if (context.IsDebugOverlayEnabled(DebugOverlay.BloomThreshold))
		{
			context.PushDebugOverlay(command, context.source, propertySheet, 6);
		}
		else if (context.IsDebugOverlayEnabled(DebugOverlay.BloomBuffer))
		{
			propertySheet.properties.SetVector(ShaderIDs.ColorIntensity, new Vector4(linear.r, linear.g, linear.b, num17));
			context.PushDebugOverlay(command, RenderTargetIdentifier.op_Implicit(m_Pyramid[0].up), propertySheet, 7 + num14);
		}
		Texture val3 = (Texture)(((Object)(object)base.settings.dirtTexture.value == (Object)null) ? ((object)RuntimeUtilities.blackTexture) : ((object)base.settings.dirtTexture.value));
		float num18 = (float)val3.width / (float)val3.height;
		float num19 = (float)context.screenWidth / (float)context.screenHeight;
		Vector4 val4 = default(Vector4);
		((Vector4)(ref val4))..ctor(1f, 1f, 0f, 0f);
		if (num18 > num19)
		{
			val4.x = num19 / num18;
			val4.z = (1f - val4.x) * 0.5f;
		}
		else if (num19 > num18)
		{
			val4.y = num18 / num19;
			val4.w = (1f - val4.y) * 0.5f;
		}
		PropertySheet uberSheet = context.uberSheet;
		if ((bool)base.settings.fastMode)
		{
			uberSheet.EnableKeyword("BLOOM_LOW");
		}
		else
		{
			uberSheet.EnableKeyword("BLOOM");
		}
		uberSheet.properties.SetVector(ShaderIDs.Bloom_DirtTileOffset, val4);
		uberSheet.properties.SetVector(ShaderIDs.Bloom_Settings, val2);
		uberSheet.properties.SetColor(ShaderIDs.Bloom_Color, linear);
		uberSheet.properties.SetTexture(ShaderIDs.Bloom_DirtTex, val3);
		command.SetGlobalTexture(ShaderIDs.BloomTex, RenderTargetIdentifier.op_Implicit(num15));
		for (int j = 0; j < num9; j++)
		{
			if (m_Pyramid[j].down != num15)
			{
				command.ReleaseTemporaryRT(m_Pyramid[j].down);
			}
			if (m_Pyramid[j].up != num15)
			{
				command.ReleaseTemporaryRT(m_Pyramid[j].up);
			}
		}
		command.EndSample("BloomPyramid");
		context.bloomBufferNameID = num15;
	}
}


private enum Pass
{
	Prefilter13,
	Prefilter4,
	Downsample13,
	Downsample4,
	UpsampleTent,
	UpsampleBox,
	DebugOverlayThreshold,
	DebugOverlayTent,
	DebugOverlayBox
}


private struct Level
{
	internal int down;

	internal int up;
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Serialization;

[Serializable]
[PostProcess(typeof(ChromaticAberrationRenderer), "Unity/Chromatic Aberration", true)]
public sealed class ChromaticAberration : PostProcessEffectSettings
{
	[Tooltip("Shifts the hue of chromatic aberrations.")]
	public TextureParameter spectralLut = new TextureParameter
	{
		value = null
	};

	[Range(0f, 1f)]
	[Tooltip("Amount of tangential distortion.")]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[FormerlySerializedAs("mobileOptimized")]
	[Tooltip("Boost performances by lowering the effect quality. This settings is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
	public BoolParameter fastMode = new BoolParameter
	{
		value = false
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value)
		{
			return intensity.value > 0f;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class ChromaticAberrationRenderer : PostProcessEffectRenderer<ChromaticAberration>
{
	private Texture2D m_InternalSpectralLut;

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Invalid comparison between Unknown and I4
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Expected O, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		Texture val = base.settings.spectralLut.value;
		if ((Object)(object)val == (Object)null)
		{
			if ((Object)(object)m_InternalSpectralLut == (Object)null)
			{
				m_InternalSpectralLut = new Texture2D(3, 1, (TextureFormat)3, false)
				{
					name = "Chromatic Aberration Spectrum Lookup",
					filterMode = (FilterMode)1,
					wrapMode = (TextureWrapMode)1,
					anisoLevel = 0,
					hideFlags = (HideFlags)52
				};
				m_InternalSpectralLut.SetPixels((Color[])(object)new Color[3]
				{
					new Color(1f, 0f, 0f),
					new Color(0f, 1f, 0f),
					new Color(0f, 0f, 1f)
				});
				m_InternalSpectralLut.Apply();
			}
			val = (Texture)(object)m_InternalSpectralLut;
		}
		PropertySheet uberSheet = context.uberSheet;
		bool flag = (bool)base.settings.fastMode || (int)SystemInfo.graphicsDeviceType == 8;
		uberSheet.EnableKeyword(flag ? "CHROMATIC_ABERRATION_LOW" : "CHROMATIC_ABERRATION");
		uberSheet.properties.SetFloat(ShaderIDs.ChromaticAberration_Amount, (float)base.settings.intensity * 0.05f);
		uberSheet.properties.SetTexture(ShaderIDs.ChromaticAberration_SpectralLut, val);
	}

	public override void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_InternalSpectralLut);
		m_InternalSpectralLut = null;
	}
}


public enum GradingMode
{
	LowDefinitionRange,
	HighDefinitionRange,
	External
}


public enum Tonemapper
{
	None,
	Neutral,
	ACES,
	Custom
}


public enum MaskingMode
{
	None,
	SourceAlpha,
	SourceOneMinusAlpha
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class GradingModeParameter : ParameterOverride<GradingMode>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class TonemapperParameter : ParameterOverride<Tonemapper>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class MaskingModeParameter : ParameterOverride<MaskingMode>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ColorGradingRenderer), "Unity/Color Grading", true)]
public sealed class ColorGrading : PostProcessEffectSettings
{
	[DisplayName("Mode")]
	[Tooltip("Select a color grading mode that fits your dynamic range and workflow. Use HDR if your camera is set to render in HDR and your target platform supports it. Use LDR for low-end mobiles or devices that don't support HDR. Use External if you prefer authoring a Log LUT in an external software.")]
	public GradingModeParameter gradingMode = new GradingModeParameter
	{
		value = GradingMode.HighDefinitionRange
	};

	[Tooltip("A custom 3D log-encoded texture.")]
	[DisplayName("Lookup Texture")]
	public TextureParameter externalLut = new TextureParameter
	{
		value = null
	};

	[Tooltip("Select a tonemapping algorithm to use at the end of the color grading process.")]
	[DisplayName("Mode")]
	public TonemapperParameter tonemapper = new TonemapperParameter
	{
		value = Tonemapper.None
	};

	[Range(0f, 1f)]
	[Tooltip("Affects the transition between the toe and the mid section of the curve. A value of 0 means no toe, a value of 1 means a very hard transition.")]
	[DisplayName("Toe Strength")]
	public FloatParameter toneCurveToeStrength = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	[DisplayName("Toe Length")]
	[Tooltip("Affects how much of the dynamic range is in the toe. With a small value, the toe will be very short and quickly transition into the linear section, with a larger value, the toe will be longer.")]
	public FloatParameter toneCurveToeLength = new FloatParameter
	{
		value = 0.5f
	};

	[DisplayName("Shoulder Strength")]
	[Range(0f, 1f)]
	[Tooltip("Affects the transition between the mid section and the shoulder of the curve. A value of 0 means no shoulder, a value of 1 means a very hard transition.")]
	public FloatParameter toneCurveShoulderStrength = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Shoulder Length")]
	[Min(0f)]
	[Tooltip("Affects how many F-stops (EV) to add to the dynamic range of the curve.")]
	public FloatParameter toneCurveShoulderLength = new FloatParameter
	{
		value = 0.5f
	};

	[DisplayName("Shoulder Angle")]
	[Range(0f, 1f)]
	[Tooltip("Affects how much overshoot to add to the shoulder.")]
	public FloatParameter toneCurveShoulderAngle = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Gamma")]
	[Min(0.001f)]
	[Tooltip("Applies a gamma function to the curve.")]
	public FloatParameter toneCurveGamma = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Custom lookup texture (strip format, for example 256x16) to apply before the rest of the color grading operators. If none is provided, a neutral one will be generated internally.")]
	[DisplayName("Lookup Texture")]
	public TextureParameter ldrLut = new TextureParameter
	{
		value = null,
		defaultState = TextureParameterDefault.Lut2D
	};

	[DisplayName("Contribution")]
	[Range(0f, 1f)]
	[Tooltip("How much of the lookup texture will contribute to the color grading effect.")]
	public FloatParameter ldrLutContribution = new FloatParameter
	{
		value = 1f
	};

	[DisplayName("Temperature")]
	[Range(-100f, 100f)]
	[Tooltip("Sets the white balance to a custom color temperature.")]
	public FloatParameter temperature = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Sets the white balance to compensate for a green or magenta tint.")]
	[Range(-100f, 100f)]
	[DisplayName("Tint")]
	public FloatParameter tint = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Tint the render by multiplying a color.")]
	[ColorUsage(false, true)]
	[DisplayName("Color Filter")]
	public ColorParameter colorFilter = new ColorParameter
	{
		value = Color.white
	};

	[DisplayName("Hue Shift")]
	[Range(-180f, 180f)]
	[Tooltip("Shift the hue of all colors.")]
	public FloatParameter hueShift = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Pushes the intensity of all colors.")]
	[Range(-100f, 100f)]
	[DisplayName("Saturation")]
	public FloatParameter saturation = new FloatParameter
	{
		value = 0f
	};

	[Range(-100f, 100f)]
	[DisplayName("Brightness")]
	[Tooltip("Makes the image brighter or darker.")]
	public FloatParameter brightness = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Adjusts the overall exposure of the scene in EV units. This is applied after the HDR effect and right before tonemapping so it won't affect previous effects in the chain.")]
	[DisplayName("Post-exposure (EV)")]
	public FloatParameter postExposure = new FloatParameter
	{
		value = 0f
	};

	[Range(-100f, 100f)]
	[DisplayName("Contrast")]
	[Tooltip("Expands or shrinks the overall range of tonal values.")]
	public FloatParameter contrast = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Mode")]
	[Tooltip("Select masking type to avoid applying grading to certain areas.")]
	public MaskingModeParameter maskMode = new MaskingModeParameter
	{
		value = MaskingMode.None
	};

	[DisplayName("Intensity")]
	[Range(0f, 10f)]
	[Tooltip("Mask intensity.")]
	public FloatParameter maskIntensity = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Modify influence of the red channel in the overall mix.")]
	[DisplayName("Red")]
	[Range(-200f, 200f)]
	public FloatParameter mixerRedOutRedIn = new FloatParameter
	{
		value = 100f
	};

	[DisplayName("Green")]
	[Tooltip("Modify influence of the green channel in the overall mix.")]
	[Range(-200f, 200f)]
	public FloatParameter mixerRedOutGreenIn = new FloatParameter
	{
		value = 0f
	};

	[Range(-200f, 200f)]
	[Tooltip("Modify influence of the blue channel in the overall mix.")]
	[DisplayName("Blue")]
	public FloatParameter mixerRedOutBlueIn = new FloatParameter
	{
		value = 0f
	};

	[Range(-200f, 200f)]
	[Tooltip("Modify influence of the red channel in the overall mix.")]
	[DisplayName("Red")]
	public FloatParameter mixerGreenOutRedIn = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Green")]
	[Range(-200f, 200f)]
	[Tooltip("Modify influence of the green channel in the overall mix.")]
	public FloatParameter mixerGreenOutGreenIn = new FloatParameter
	{
		value = 100f
	};

	[DisplayName("Blue")]
	[Range(-200f, 200f)]
	[Tooltip("Modify influence of the blue channel in the overall mix.")]
	public FloatParameter mixerGreenOutBlueIn = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Red")]
	[Range(-200f, 200f)]
	[Tooltip("Modify influence of the red channel in the overall mix.")]
	public FloatParameter mixerBlueOutRedIn = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Green")]
	[Range(-200f, 200f)]
	[Tooltip("Modify influence of the green channel in the overall mix.")]
	public FloatParameter mixerBlueOutGreenIn = new FloatParameter
	{
		value = 0f
	};

	[DisplayName("Blue")]
	[Tooltip("Modify influence of the blue channel in the overall mix.")]
	[Range(-200f, 200f)]
	public FloatParameter mixerBlueOutBlueIn = new FloatParameter
	{
		value = 100f
	};

	[Tooltip("Controls the darkest portions of the render.")]
	[DisplayName("Lift")]
	[Trackball(TrackballAttribute.Mode.Lift)]
	public Vector4Parameter lift = new Vector4Parameter
	{
		value = new Vector4(1f, 1f, 1f, 0f)
	};

	[Trackball(TrackballAttribute.Mode.Gamma)]
	[Tooltip("Power function that controls mid-range tones.")]
	[DisplayName("Gamma")]
	public Vector4Parameter gamma = new Vector4Parameter
	{
		value = new Vector4(1f, 1f, 1f, 0f)
	};

	[Trackball(TrackballAttribute.Mode.Gain)]
	[Tooltip("Controls the lightest portions of the render.")]
	[DisplayName("Gain")]
	public Vector4Parameter gain = new Vector4Parameter
	{
		value = new Vector4(1f, 1f, 1f, 0f)
	};

	public SplineParameter masterCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f, 1f, 1f),
			new Keyframe(1f, 1f, 1f, 1f)
		}), 0f, loop: false, new Vector2(0f, 1f))
	};

	public SplineParameter redCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f, 1f, 1f),
			new Keyframe(1f, 1f, 1f, 1f)
		}), 0f, loop: false, new Vector2(0f, 1f))
	};

	public SplineParameter greenCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f, 1f, 1f),
			new Keyframe(1f, 1f, 1f, 1f)
		}), 0f, loop: false, new Vector2(0f, 1f))
	};

	public SplineParameter blueCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f, 1f, 1f),
			new Keyframe(1f, 1f, 1f, 1f)
		}), 0f, loop: false, new Vector2(0f, 1f))
	};

	public SplineParameter hueVsHueCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f))
	};

	public SplineParameter hueVsSatCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve(), 0.5f, loop: true, new Vector2(0f, 1f))
	};

	public SplineParameter satVsSatCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f))
	};

	public SplineParameter lumVsSatCurve = new SplineParameter
	{
		value = new Spline(new AnimationCurve(), 0.5f, loop: false, new Vector2(0f, 1f))
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (gradingMode.value == GradingMode.External && (!SystemInfo.supports3DRenderTextures || !SystemInfo.supportsComputeShaders))
		{
			return false;
		}
		return enabled.value;
	}
}


using UnityEngine;
using UnityEngine.Experimental.Rendering;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class ColorGradingRenderer : PostProcessEffectRenderer<ColorGrading>
{
	private enum Pass
	{
		LutGenLDRFromScratch,
		LutGenLDR,
		LutGenHDR2D
	}

	private Texture2D m_GradingCurves;

	private readonly Color[] m_Pixels = (Color[])(object)new Color[256];

	private RenderTexture m_InternalLdrLut;

	private RenderTexture m_InternalLogLut;

	private const int k_Lut2DSize = 32;

	private const int k_Lut3DSize = 33;

	private readonly HableCurve m_HableCurve = new HableCurve();

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Invalid comparison between Unknown and I4
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Invalid comparison between Unknown and I4
		GradingMode value = base.settings.gradingMode.value;
		bool flag = SystemInfo.supports3DRenderTextures && SystemInfo.supportsComputeShaders && (Object)(object)context.resources.computeShaders.lut3DBaker != (Object)null && (int)SystemInfo.graphicsDeviceType != 17 && (int)SystemInfo.graphicsDeviceType != 11;
		if (value == GradingMode.External)
		{
			RenderExternalPipeline3D(context);
		}
		else if (value == GradingMode.HighDefinitionRange && flag)
		{
			RenderHDRPipeline3D(context);
		}
		else if (value == GradingMode.HighDefinitionRange)
		{
			RenderHDRPipeline2D(context);
		}
		else
		{
			RenderLDRPipeline2D(context);
		}
	}

	private void RenderExternalPipeline3D(PostProcessRenderContext context)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		Texture value = base.settings.externalLut.value;
		if (!((Object)(object)value == (Object)null))
		{
			PropertySheet uberSheet = context.uberSheet;
			uberSheet.EnableKeyword("COLOR_GRADING_HDR_3D");
			uberSheet.properties.SetTexture(ShaderIDs.Lut3D, value);
			uberSheet.properties.SetVector(ShaderIDs.Lut3D_Params, Vector4.op_Implicit(new Vector2(1f / (float)value.width, (float)value.width - 1f)));
			uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(base.settings.postExposure.value));
			uberSheet.properties.SetInt(ShaderIDs.MaskMode, (int)base.settings.maskMode.value);
			uberSheet.properties.SetFloat(ShaderIDs.MaskIntensity, base.settings.maskIntensity.value);
			context.logLut = value;
		}
	}

	private void RenderHDRPipeline3D(PostProcessRenderContext context)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0328: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_0345: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		CheckInternalLogLut();
		ComputeShader lut3DBaker = context.resources.computeShaders.lut3DBaker;
		int num = 0;
		switch (base.settings.tonemapper.value)
		{
		case Tonemapper.None:
			num = lut3DBaker.FindKernel("KGenLut3D_NoTonemap");
			break;
		case Tonemapper.Neutral:
			num = lut3DBaker.FindKernel("KGenLut3D_NeutralTonemap");
			break;
		case Tonemapper.ACES:
			num = lut3DBaker.FindKernel("KGenLut3D_AcesTonemap");
			break;
		case Tonemapper.Custom:
			num = lut3DBaker.FindKernel("KGenLut3D_CustomTonemap");
			break;
		}
		CommandBuffer command = context.command;
		command.SetComputeTextureParam(lut3DBaker, num, "_Output", RenderTargetIdentifier.op_Implicit((Texture)(object)m_InternalLogLut));
		command.SetComputeVectorParam(lut3DBaker, "_Size", new Vector4(33f, 1f / 32f, 0f, 0f));
		Vector3 val = ColorUtilities.ComputeColorBalance(base.settings.temperature.value, base.settings.tint.value);
		command.SetComputeVectorParam(lut3DBaker, "_ColorBalance", Vector4.op_Implicit(val));
		command.SetComputeVectorParam(lut3DBaker, "_ColorFilter", Color.op_Implicit(base.settings.colorFilter.value));
		float num2 = base.settings.hueShift.value / 360f;
		float num3 = base.settings.saturation.value / 100f + 1f;
		float num4 = base.settings.contrast.value / 100f + 1f;
		command.SetComputeVectorParam(lut3DBaker, "_HueSatCon", new Vector4(num2, num3, num4, 0f));
		Vector4 val2 = default(Vector4);
		((Vector4)(ref val2))..ctor((float)base.settings.mixerRedOutRedIn, (float)base.settings.mixerRedOutGreenIn, (float)base.settings.mixerRedOutBlueIn, 0f);
		Vector4 val3 = default(Vector4);
		((Vector4)(ref val3))..ctor((float)base.settings.mixerGreenOutRedIn, (float)base.settings.mixerGreenOutGreenIn, (float)base.settings.mixerGreenOutBlueIn, 0f);
		Vector4 val4 = default(Vector4);
		((Vector4)(ref val4))..ctor((float)base.settings.mixerBlueOutRedIn, (float)base.settings.mixerBlueOutGreenIn, (float)base.settings.mixerBlueOutBlueIn, 0f);
		command.SetComputeVectorParam(lut3DBaker, "_ChannelMixerRed", val2 / 100f);
		command.SetComputeVectorParam(lut3DBaker, "_ChannelMixerGreen", val3 / 100f);
		command.SetComputeVectorParam(lut3DBaker, "_ChannelMixerBlue", val4 / 100f);
		Vector3 val5 = ColorUtilities.ColorToLift(base.settings.lift.value * 0.2f);
		Vector3 val6 = ColorUtilities.ColorToGain(base.settings.gain.value * 0.8f);
		Vector3 val7 = ColorUtilities.ColorToInverseGamma(base.settings.gamma.value * 0.8f);
		command.SetComputeVectorParam(lut3DBaker, "_Lift", new Vector4(val5.x, val5.y, val5.z, 0f));
		command.SetComputeVectorParam(lut3DBaker, "_InvGamma", new Vector4(val7.x, val7.y, val7.z, 0f));
		command.SetComputeVectorParam(lut3DBaker, "_Gain", new Vector4(val6.x, val6.y, val6.z, 0f));
		command.SetComputeTextureParam(lut3DBaker, num, "_Curves", RenderTargetIdentifier.op_Implicit((Texture)(object)GetCurveTexture(hdr: true)));
		if (base.settings.tonemapper.value == Tonemapper.Custom)
		{
			m_HableCurve.Init(base.settings.toneCurveToeStrength.value, base.settings.toneCurveToeLength.value, base.settings.toneCurveShoulderStrength.value, base.settings.toneCurveShoulderLength.value, base.settings.toneCurveShoulderAngle.value, base.settings.toneCurveGamma.value);
			command.SetComputeVectorParam(lut3DBaker, "_CustomToneCurve", m_HableCurve.uniforms.curve);
			command.SetComputeVectorParam(lut3DBaker, "_ToeSegmentA", m_HableCurve.uniforms.toeSegmentA);
			command.SetComputeVectorParam(lut3DBaker, "_ToeSegmentB", m_HableCurve.uniforms.toeSegmentB);
			command.SetComputeVectorParam(lut3DBaker, "_MidSegmentA", m_HableCurve.uniforms.midSegmentA);
			command.SetComputeVectorParam(lut3DBaker, "_MidSegmentB", m_HableCurve.uniforms.midSegmentB);
			command.SetComputeVectorParam(lut3DBaker, "_ShoSegmentA", m_HableCurve.uniforms.shoSegmentA);
			command.SetComputeVectorParam(lut3DBaker, "_ShoSegmentB", m_HableCurve.uniforms.shoSegmentB);
		}
		context.command.BeginSample("HdrColorGradingLut3D");
		int num5 = Mathf.CeilToInt(8.25f);
		command.DispatchCompute(lut3DBaker, num, num5, num5, num5);
		context.command.EndSample("HdrColorGradingLut3D");
		RenderTexture internalLogLut = m_InternalLogLut;
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.EnableKeyword("COLOR_GRADING_HDR_3D");
		uberSheet.properties.SetTexture(ShaderIDs.Lut3D, (Texture)(object)internalLogLut);
		uberSheet.properties.SetVector(ShaderIDs.Lut3D_Params, Vector4.op_Implicit(new Vector2(1f / (float)((Texture)internalLogLut).width, (float)((Texture)internalLogLut).width - 1f)));
		uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(base.settings.postExposure.value));
		uberSheet.properties.SetInt(ShaderIDs.MaskMode, (int)base.settings.maskMode.value);
		uberSheet.properties.SetFloat(ShaderIDs.MaskIntensity, base.settings.maskIntensity.value);
		context.logLut = (Texture)(object)internalLogLut;
	}

	private void RenderHDRPipeline2D(PostProcessRenderContext context)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0391: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0411: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0512: Unknown result type (might be due to invalid IL or missing references)
		//IL_0517: Unknown result type (might be due to invalid IL or missing references)
		CheckInternalStripLut();
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lut2DBaker);
		propertySheet.ClearKeywords();
		propertySheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
		Vector3 val = ColorUtilities.ComputeColorBalance(base.settings.temperature.value, base.settings.tint.value);
		propertySheet.properties.SetVector(ShaderIDs.ColorBalance, Vector4.op_Implicit(val));
		propertySheet.properties.SetVector(ShaderIDs.ColorFilter, Color.op_Implicit(base.settings.colorFilter.value));
		float num = base.settings.hueShift.value / 360f;
		float num2 = base.settings.saturation.value / 100f + 1f;
		float num3 = base.settings.contrast.value / 100f + 1f;
		propertySheet.properties.SetVector(ShaderIDs.HueSatCon, Vector4.op_Implicit(new Vector3(num, num2, num3)));
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor((float)base.settings.mixerRedOutRedIn, (float)base.settings.mixerRedOutGreenIn, (float)base.settings.mixerRedOutBlueIn);
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor((float)base.settings.mixerGreenOutRedIn, (float)base.settings.mixerGreenOutGreenIn, (float)base.settings.mixerGreenOutBlueIn);
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor((float)base.settings.mixerBlueOutRedIn, (float)base.settings.mixerBlueOutGreenIn, (float)base.settings.mixerBlueOutBlueIn);
		propertySheet.properties.SetVector(ShaderIDs.ChannelMixerRed, Vector4.op_Implicit(val2 / 100f));
		propertySheet.properties.SetVector(ShaderIDs.ChannelMixerGreen, Vector4.op_Implicit(val3 / 100f));
		propertySheet.properties.SetVector(ShaderIDs.ChannelMixerBlue, Vector4.op_Implicit(val4 / 100f));
		Vector3 val5 = ColorUtilities.ColorToLift(base.settings.lift.value * 0.2f);
		Vector3 val6 = ColorUtilities.ColorToGain(base.settings.gain.value * 0.8f);
		Vector3 val7 = ColorUtilities.ColorToInverseGamma(base.settings.gamma.value * 0.8f);
		propertySheet.properties.SetVector(ShaderIDs.Lift, Vector4.op_Implicit(val5));
		propertySheet.properties.SetVector(ShaderIDs.InvGamma, Vector4.op_Implicit(val7));
		propertySheet.properties.SetVector(ShaderIDs.Gain, Vector4.op_Implicit(val6));
		propertySheet.properties.SetTexture(ShaderIDs.Curves, (Texture)(object)GetCurveTexture(hdr: true));
		switch (base.settings.tonemapper.value)
		{
		case Tonemapper.Custom:
			propertySheet.EnableKeyword("TONEMAPPING_CUSTOM");
			m_HableCurve.Init(base.settings.toneCurveToeStrength.value, base.settings.toneCurveToeLength.value, base.settings.toneCurveShoulderStrength.value, base.settings.toneCurveShoulderLength.value, base.settings.toneCurveShoulderAngle.value, base.settings.toneCurveGamma.value);
			propertySheet.properties.SetVector(ShaderIDs.CustomToneCurve, m_HableCurve.uniforms.curve);
			propertySheet.properties.SetVector(ShaderIDs.ToeSegmentA, m_HableCurve.uniforms.toeSegmentA);
			propertySheet.properties.SetVector(ShaderIDs.ToeSegmentB, m_HableCurve.uniforms.toeSegmentB);
			propertySheet.properties.SetVector(ShaderIDs.MidSegmentA, m_HableCurve.uniforms.midSegmentA);
			propertySheet.properties.SetVector(ShaderIDs.MidSegmentB, m_HableCurve.uniforms.midSegmentB);
			propertySheet.properties.SetVector(ShaderIDs.ShoSegmentA, m_HableCurve.uniforms.shoSegmentA);
			propertySheet.properties.SetVector(ShaderIDs.ShoSegmentB, m_HableCurve.uniforms.shoSegmentB);
			break;
		case Tonemapper.ACES:
			propertySheet.EnableKeyword("TONEMAPPING_ACES");
			break;
		case Tonemapper.Neutral:
			propertySheet.EnableKeyword("TONEMAPPING_NEUTRAL");
			break;
		}
		context.command.BeginSample("HdrColorGradingLut2D");
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)m_InternalLdrLut), propertySheet, 2, clear: false, null);
		context.command.EndSample("HdrColorGradingLut2D");
		RenderTexture internalLdrLut = m_InternalLdrLut;
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.EnableKeyword("COLOR_GRADING_HDR_2D");
		uberSheet.properties.SetVector(ShaderIDs.Lut2D_Params, Vector4.op_Implicit(new Vector3(1f / (float)((Texture)internalLdrLut).width, 1f / (float)((Texture)internalLdrLut).height, (float)((Texture)internalLdrLut).height - 1f)));
		uberSheet.properties.SetTexture(ShaderIDs.Lut2D, (Texture)(object)internalLdrLut);
		uberSheet.properties.SetFloat(ShaderIDs.PostExposure, RuntimeUtilities.Exp2(base.settings.postExposure.value));
		uberSheet.properties.SetInt(ShaderIDs.MaskMode, (int)base.settings.maskMode.value);
		uberSheet.properties.SetFloat(ShaderIDs.MaskIntensity, base.settings.maskIntensity.value);
	}

	private void RenderLDRPipeline2D(PostProcessRenderContext context)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_034f: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		CheckInternalStripLut();
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lut2DBaker);
		propertySheet.ClearKeywords();
		propertySheet.properties.SetVector(ShaderIDs.Lut2D_Params, new Vector4(32f, 0.00048828125f, 1f / 64f, 1.032258f));
		Vector3 val = ColorUtilities.ComputeColorBalance(base.settings.temperature.value, base.settings.tint.value);
		propertySheet.properties.SetVector(ShaderIDs.ColorBalance, Vector4.op_Implicit(val));
		propertySheet.properties.SetVector(ShaderIDs.ColorFilter, Color.op_Implicit(base.settings.colorFilter.value));
		float num = base.settings.hueShift.value / 360f;
		float num2 = base.settings.saturation.value / 100f + 1f;
		float num3 = base.settings.contrast.value / 100f + 1f;
		propertySheet.properties.SetVector(ShaderIDs.HueSatCon, Vector4.op_Implicit(new Vector3(num, num2, num3)));
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor((float)base.settings.mixerRedOutRedIn, (float)base.settings.mixerRedOutGreenIn, (float)base.settings.mixerRedOutBlueIn);
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor((float)base.settings.mixerGreenOutRedIn, (float)base.settings.mixerGreenOutGreenIn, (float)base.settings.mixerGreenOutBlueIn);
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor((float)base.settings.mixerBlueOutRedIn, (float)base.settings.mixerBlueOutGreenIn, (float)base.settings.mixerBlueOutBlueIn);
		propertySheet.properties.SetVector(ShaderIDs.ChannelMixerRed, Vector4.op_Implicit(val2 / 100f));
		propertySheet.properties.SetVector(ShaderIDs.ChannelMixerGreen, Vector4.op_Implicit(val3 / 100f));
		propertySheet.properties.SetVector(ShaderIDs.ChannelMixerBlue, Vector4.op_Implicit(val4 / 100f));
		Vector3 val5 = ColorUtilities.ColorToLift(base.settings.lift.value);
		Vector3 val6 = ColorUtilities.ColorToGain(base.settings.gain.value);
		Vector3 val7 = ColorUtilities.ColorToInverseGamma(base.settings.gamma.value);
		propertySheet.properties.SetVector(ShaderIDs.Lift, Vector4.op_Implicit(val5));
		propertySheet.properties.SetVector(ShaderIDs.InvGamma, Vector4.op_Implicit(val7));
		propertySheet.properties.SetVector(ShaderIDs.Gain, Vector4.op_Implicit(val6));
		propertySheet.properties.SetFloat(ShaderIDs.Brightness, (base.settings.brightness.value + 100f) / 100f);
		propertySheet.properties.SetTexture(ShaderIDs.Curves, (Texture)(object)GetCurveTexture(hdr: false));
		context.command.BeginSample("LdrColorGradingLut2D");
		Texture value = base.settings.ldrLut.value;
		if ((Object)(object)value == (Object)null || value.width != value.height * value.height)
		{
			context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)m_InternalLdrLut), propertySheet, 0, clear: false, null);
		}
		else
		{
			propertySheet.properties.SetVector(ShaderIDs.UserLut2D_Params, new Vector4(1f / (float)value.width, 1f / (float)value.height, (float)value.height - 1f, (float)base.settings.ldrLutContribution));
			context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(value), RenderTargetIdentifier.op_Implicit((Texture)(object)m_InternalLdrLut), propertySheet, 1, clear: false, null);
		}
		context.command.EndSample("LdrColorGradingLut2D");
		RenderTexture internalLdrLut = m_InternalLdrLut;
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.EnableKeyword("COLOR_GRADING_LDR_2D");
		uberSheet.properties.SetVector(ShaderIDs.Lut2D_Params, Vector4.op_Implicit(new Vector3(1f / (float)((Texture)internalLdrLut).width, 1f / (float)((Texture)internalLdrLut).height, (float)((Texture)internalLdrLut).height - 1f)));
		uberSheet.properties.SetTexture(ShaderIDs.Lut2D, (Texture)(object)internalLdrLut);
		uberSheet.properties.SetInt(ShaderIDs.MaskMode, (int)base.settings.maskMode.value);
		uberSheet.properties.SetFloat(ShaderIDs.MaskIntensity, base.settings.maskIntensity.value);
	}

	private void CheckInternalLogLut()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Expected O, but got Unknown
		if ((Object)(object)m_InternalLogLut == (Object)null || !m_InternalLogLut.IsCreated())
		{
			RuntimeUtilities.Destroy((Object)(object)m_InternalLogLut);
			RenderTextureFormat lutFormat = GetLutFormat();
			m_InternalLogLut = new RenderTexture(33, 33, 0, lutFormat, (RenderTextureReadWrite)1)
			{
				name = "Color Grading Log Lut",
				dimension = (TextureDimension)3,
				hideFlags = (HideFlags)52,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				anisoLevel = 0,
				enableRandomWrite = true,
				volumeDepth = 33,
				autoGenerateMips = false,
				useMipMap = false
			};
			m_InternalLogLut.Create();
		}
	}

	private void CheckInternalStripLut()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Expected O, but got Unknown
		if ((Object)(object)m_InternalLdrLut == (Object)null || !m_InternalLdrLut.IsCreated())
		{
			RuntimeUtilities.Destroy((Object)(object)m_InternalLdrLut);
			RenderTextureFormat lutFormat = GetLutFormat();
			m_InternalLdrLut = new RenderTexture(1024, 32, 0, lutFormat, (RenderTextureReadWrite)1)
			{
				name = "Color Grading Strip Lut",
				hideFlags = (HideFlags)52,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				anisoLevel = 0,
				autoGenerateMips = false,
				useMipMap = false
			};
			m_InternalLdrLut.Create();
		}
	}

	private Texture2D GetCurveTexture(bool hdr)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Expected O, but got Unknown
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_GradingCurves == (Object)null)
		{
			TextureFormat curveFormat = GetCurveFormat();
			m_GradingCurves = new Texture2D(128, 2, curveFormat, false, true)
			{
				name = "Internal Curves Texture",
				hideFlags = (HideFlags)52,
				anisoLevel = 0,
				wrapMode = (TextureWrapMode)1,
				filterMode = (FilterMode)1
			};
		}
		Spline value = base.settings.hueVsHueCurve.value;
		Spline value2 = base.settings.hueVsSatCurve.value;
		Spline value3 = base.settings.satVsSatCurve.value;
		Spline value4 = base.settings.lumVsSatCurve.value;
		Spline value5 = base.settings.masterCurve.value;
		Spline value6 = base.settings.redCurve.value;
		Spline value7 = base.settings.greenCurve.value;
		Spline value8 = base.settings.blueCurve.value;
		Color[] pixels = m_Pixels;
		for (int i = 0; i < 128; i++)
		{
			float num = value.cachedData[i];
			float num2 = value2.cachedData[i];
			float num3 = value3.cachedData[i];
			float num4 = value4.cachedData[i];
			pixels[i] = new Color(num, num2, num3, num4);
			if (!hdr)
			{
				float num5 = value5.cachedData[i];
				float num6 = value6.cachedData[i];
				float num7 = value7.cachedData[i];
				float num8 = value8.cachedData[i];
				pixels[i + 128] = new Color(num6, num7, num8, num5);
			}
		}
		m_GradingCurves.SetPixels(pixels);
		m_GradingCurves.Apply(false, false);
		return m_GradingCurves;
	}

	private static bool IsRenderTextureFormatSupportedForLinearFiltering(RenderTextureFormat format)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return SystemInfo.IsFormatSupported(GraphicsFormatUtility.GetGraphicsFormat(format, (RenderTextureReadWrite)1), (FormatUsage)1);
	}

	private static RenderTextureFormat GetLutFormat()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureFormat val = (RenderTextureFormat)2;
		if (!IsRenderTextureFormatSupportedForLinearFiltering(val))
		{
			val = (RenderTextureFormat)8;
			if (!IsRenderTextureFormatSupportedForLinearFiltering(val))
			{
				val = (RenderTextureFormat)0;
			}
		}
		return val;
	}

	private static TextureFormat GetCurveFormat()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		TextureFormat val = (TextureFormat)17;
		if (!SystemInfo.SupportsTextureFormat(val))
		{
			val = (TextureFormat)5;
		}
		return val;
	}

	public override void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_InternalLdrLut);
		m_InternalLdrLut = null;
		RuntimeUtilities.Destroy((Object)(object)m_InternalLogLut);
		m_InternalLogLut = null;
		RuntimeUtilities.Destroy((Object)(object)m_GradingCurves);
		m_GradingCurves = null;
	}
}


private enum Pass
{
	LutGenLDRFromScratch,
	LutGenLDR,
	LutGenHDR2D
}


public enum KernelSize
{
	Small,
	Medium,
	Large,
	VeryLarge
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class KernelSizeParameter : ParameterOverride<KernelSize>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DepthOfFieldRenderer), "Unity/Depth of Field", false)]
public sealed class DepthOfField : PostProcessEffectSettings
{
	[Min(0.1f)]
	[Tooltip("Distance to the point of focus.")]
	public FloatParameter focusDistance = new FloatParameter
	{
		value = 10f
	};

	[Tooltip("Ratio of aperture (known as f-stop or f-number). The smaller the value is, the shallower the depth of field is.")]
	[Range(0.05f, 32f)]
	public FloatParameter aperture = new FloatParameter
	{
		value = 5.6f
	};

	[Tooltip("Distance between the lens and the film. The larger the value is, the shallower the depth of field is.")]
	[Range(1f, 300f)]
	public FloatParameter focalLength = new FloatParameter
	{
		value = 50f
	};

	[Tooltip("Convolution kernel size of the bokeh filter, which determines the maximum radius of bokeh. It also affects performances (the larger the kernel is, the longer the GPU time is required).")]
	[DisplayName("Max Blur Size")]
	public KernelSizeParameter kernelSize = new KernelSizeParameter
	{
		value = KernelSize.Medium
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value)
		{
			return SystemInfo.graphicsShaderLevel >= 35;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class DepthOfFieldRenderer : PostProcessEffectRenderer<DepthOfField>
{
	private enum Pass
	{
		CoCCalculation,
		CoCTemporalFilter,
		DownsampleAndPrefilter,
		BokehSmallKernel,
		BokehMediumKernel,
		BokehLargeKernel,
		BokehVeryLargeKernel,
		PostFilter,
		Combine,
		DebugOverlay
	}

	private const int k_NumEyes = 2;

	private const int k_NumCoCHistoryTextures = 2;

	private readonly RenderTexture[][] m_CoCHistoryTextures = new RenderTexture[2][];

	private int[] m_HistoryPingPong = new int[2];

	private const float k_FilmHeight = 0.024f;

	public DepthOfFieldRenderer()
	{
		for (int i = 0; i < 2; i++)
		{
			m_CoCHistoryTextures[i] = (RenderTexture[])(object)new RenderTexture[2];
			m_HistoryPingPong[i] = 0;
		}
	}

	public override DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)1;
	}

	private RenderTextureFormat SelectFormat(RenderTextureFormat primary, RenderTextureFormat secondary)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (primary.IsSupported())
		{
			return primary;
		}
		if (secondary.IsSupported())
		{
			return secondary;
		}
		return (RenderTextureFormat)7;
	}

	private float CalculateMaxCoCRadius(int screenHeight)
	{
		float num = (float)base.settings.kernelSize.value * 4f + 6f;
		return Mathf.Min(0.05f, num / (float)screenHeight);
	}

	private RenderTexture CheckHistory(int eye, int id, PostProcessRenderContext context, RenderTextureFormat format)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture val = m_CoCHistoryTextures[eye][id];
		if (m_ResetHistory || (Object)(object)val == (Object)null || !val.IsCreated() || ((Texture)val).width != context.width || ((Texture)val).height != context.height)
		{
			RenderTexture.ReleaseTemporary(val);
			val = context.GetScreenSpaceTemporaryRT(0, format, (RenderTextureReadWrite)1);
			((Object)val).name = "CoC History, Eye: " + eye + ", ID: " + id;
			((Texture)val).filterMode = (FilterMode)1;
			val.Create();
			m_CoCHistoryTextures[eye][id] = val;
		}
		return val;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureFormat sourceFormat = context.sourceFormat;
		RenderTextureFormat val = SelectFormat((RenderTextureFormat)16, (RenderTextureFormat)15);
		float num = 0.024f * ((float)context.height / 1080f);
		float num2 = base.settings.focalLength.value / 1000f;
		float num3 = Mathf.Max(base.settings.focusDistance.value, num2);
		float num4 = (float)context.screenWidth / (float)context.screenHeight;
		float num5 = num2 * num2 / (base.settings.aperture.value * (num3 - num2) * num * 2f);
		float num6 = CalculateMaxCoCRadius(context.screenHeight);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.depthOfField);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(ShaderIDs.Distance, num3);
		propertySheet.properties.SetFloat(ShaderIDs.LensCoeff, num5);
		propertySheet.properties.SetFloat(ShaderIDs.MaxCoC, num6);
		propertySheet.properties.SetFloat(ShaderIDs.RcpMaxCoC, 1f / num6);
		propertySheet.properties.SetFloat(ShaderIDs.RcpAspect, 1f / num4);
		CommandBuffer command = context.command;
		command.BeginSample("DepthOfField");
		context.GetScreenSpaceTemporaryRT(command, ShaderIDs.CoCTex, 0, val, (RenderTextureReadWrite)1, (FilterMode)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit(ShaderIDs.CoCTex), propertySheet, 0, clear: false, null);
		if (context.IsTemporalAntialiasingActive() || context.dlssEnabled)
		{
			float motionBlending = context.temporalAntialiasing.motionBlending;
			float num7 = (m_ResetHistory ? 0f : motionBlending);
			Vector2 texelOffset = RustTemporalAntialiasingRenderer.Instance.JitterSettings.TexelOffset;
			propertySheet.properties.SetVector(ShaderIDs.TaaParams, Vector4.op_Implicit(new Vector3(texelOffset.x, texelOffset.y, num7)));
			int num8 = m_HistoryPingPong[context.xrActiveEye];
			RenderTexture val2 = CheckHistory(context.xrActiveEye, ++num8 % 2, context, val);
			RenderTexture val3 = CheckHistory(context.xrActiveEye, ++num8 % 2, context, val);
			m_HistoryPingPong[context.xrActiveEye] = ++num8 % 2;
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((Texture)(object)val2), RenderTargetIdentifier.op_Implicit((Texture)(object)val3), propertySheet, 1, clear: false, null);
			command.ReleaseTemporaryRT(ShaderIDs.CoCTex);
			command.SetGlobalTexture(ShaderIDs.CoCTex, RenderTargetIdentifier.op_Implicit((Texture)(object)val3));
		}
		context.GetScreenSpaceTemporaryRT(command, ShaderIDs.DepthOfFieldTex, 0, sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1, context.width / 2, context.height / 2);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.DepthOfFieldTex), propertySheet, 2, clear: false, null);
		context.GetScreenSpaceTemporaryRT(command, ShaderIDs.DepthOfFieldTemp, 0, sourceFormat, (RenderTextureReadWrite)0, (FilterMode)1, context.width / 2, context.height / 2);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.DepthOfFieldTex), RenderTargetIdentifier.op_Implicit(ShaderIDs.DepthOfFieldTemp), propertySheet, (int)(3 + base.settings.kernelSize.value), clear: false, null);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.DepthOfFieldTemp), RenderTargetIdentifier.op_Implicit(ShaderIDs.DepthOfFieldTex), propertySheet, 7, clear: false, null);
		command.ReleaseTemporaryRT(ShaderIDs.DepthOfFieldTemp);
		if (context.IsDebugOverlayEnabled(DebugOverlay.DepthOfField))
		{
			context.PushDebugOverlay(command, context.source, propertySheet, 9);
		}
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 8, clear: false, null);
		command.ReleaseTemporaryRT(ShaderIDs.DepthOfFieldTex);
		if (!context.IsTemporalAntialiasingActive() || context.dlssEnabled)
		{
			command.ReleaseTemporaryRT(ShaderIDs.CoCTex);
		}
		command.EndSample("DepthOfField");
		m_ResetHistory = false;
	}

	public override void Release()
	{
		for (int i = 0; i < 2; i++)
		{
			for (int j = 0; j < m_CoCHistoryTextures[i].Length; j++)
			{
				RenderTexture.ReleaseTemporary(m_CoCHistoryTextures[i][j]);
				m_CoCHistoryTextures[i][j] = null;
			}
			m_HistoryPingPong[i] = 0;
		}
		ResetHistory();
	}
}


private enum Pass
{
	CoCCalculation,
	CoCTemporalFilter,
	DownsampleAndPrefilter,
	BokehSmallKernel,
	BokehMediumKernel,
	BokehLargeKernel,
	BokehVeryLargeKernel,
	PostFilter,
	Combine,
	DebugOverlay
}


using System;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
internal sealed class Dithering
{
	private int m_NoiseTextureIndex;

	internal void Render(PostProcessRenderContext context)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		Texture2D[] blueNoise = context.resources.blueNoise64;
		Assert.IsTrue(blueNoise != null && blueNoise.Length != 0);
		if (++m_NoiseTextureIndex >= blueNoise.Length)
		{
			m_NoiseTextureIndex = 0;
		}
		float value = Random.value;
		float value2 = Random.value;
		Texture2D val = blueNoise[m_NoiseTextureIndex];
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.properties.SetTexture(ShaderIDs.DitheringTex, (Texture)(object)val);
		uberSheet.properties.SetVector(ShaderIDs.Dithering_Coords, new Vector4((float)context.screenWidth / (float)((Texture)val).width, (float)context.screenHeight / (float)((Texture)val).height, value, value2));
	}
}


using System;
using UnityEngine;
using UnityEngine.Scripting;
using UnityEngine.Serialization;

[Serializable]
[Preserve]
public sealed class FastApproximateAntialiasing
{
	[Tooltip("Boost performances by lowering the effect quality. This setting is meant to be used on mobile and other low-end platforms but can also provide a nice performance boost on desktops and consoles.")]
	[FormerlySerializedAs("mobileOptimized")]
	public bool fastMode;

	[Tooltip("Keep alpha channel. This will slightly lower the effect quality but allows rendering against a transparent background.")]
	public bool keepAlpha;
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
public sealed class Fog
{
	[Tooltip("Enables the internal deferred fog pass. Actual fog settings should be set in the Lighting panel.")]
	public bool enabled = true;

	[Tooltip("Mark true for the fog to ignore the skybox")]
	public bool excludeSkybox = true;

	internal DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)1;
	}

	internal bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Invalid comparison between Unknown and I4
		if (enabled && RenderSettings.fog && !RuntimeUtilities.scriptableRenderPipelineActive && Object.op_Implicit((Object)(object)context.resources.shaders.deferredFog) && context.resources.shaders.deferredFog.isSupported)
		{
			return (int)context.camera.actualRenderingPath == 3;
		}
		return false;
	}

	internal void Render(PostProcessRenderContext context)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.deferredFog);
		propertySheet.ClearKeywords();
		Color val;
		if (!RuntimeUtilities.isLinearColorSpace)
		{
			val = RenderSettings.fogColor;
		}
		else
		{
			Color fogColor = RenderSettings.fogColor;
			val = ((Color)(ref fogColor)).linear;
		}
		Color val2 = val;
		propertySheet.properties.SetVector(ShaderIDs.FogColor, Color.op_Implicit(val2));
		propertySheet.properties.SetVector(ShaderIDs.FogParams, Vector4.op_Implicit(new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance)));
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, excludeSkybox ? 1 : 0, clear: false, null);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GrainRenderer), "Unity/Grain", true)]
public sealed class Grain : PostProcessEffectSettings
{
	[Tooltip("Enable the use of colored grain.")]
	public BoolParameter colored = new BoolParameter
	{
		value = true
	};

	[Tooltip("Grain strength. Higher values mean more visible grain.")]
	[Range(0f, 1f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Grain particle size.")]
	[Range(0.3f, 3f)]
	public FloatParameter size = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Controls the noise response curve based on scene luminance. Lower values mean less noise in dark areas.")]
	[DisplayName("Luminance Contribution")]
	[Range(0f, 1f)]
	public FloatParameter lumContrib = new FloatParameter
	{
		value = 0.8f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value)
		{
			return intensity.value > 0f;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class GrainRenderer : PostProcessEffectRenderer<Grain>
{
	private RenderTexture m_GrainLookupRT;

	private const int k_SampleCount = 1024;

	private int m_SampleIndex;

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Expected O, but got Unknown
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		float num = HaltonSeq.Get(m_SampleIndex & 0x3FF, 2);
		float num2 = HaltonSeq.Get(m_SampleIndex & 0x3FF, 3);
		if (++m_SampleIndex >= 1024)
		{
			m_SampleIndex = 0;
		}
		if ((Object)(object)m_GrainLookupRT == (Object)null || !m_GrainLookupRT.IsCreated())
		{
			RuntimeUtilities.Destroy((Object)(object)m_GrainLookupRT);
			m_GrainLookupRT = new RenderTexture(128, 128, 0, GetLookupFormat())
			{
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)0,
				anisoLevel = 0,
				name = "Grain Lookup Texture"
			};
			m_GrainLookupRT.Create();
		}
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.grainBaker);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(ShaderIDs.Phase, realtimeSinceStartup % 10f);
		propertySheet.properties.SetVector(ShaderIDs.GrainNoiseParameters, Vector4.op_Implicit(new Vector3(12.9898f, 78.233f, 43758.547f)));
		context.command.BeginSample("GrainLookup");
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)m_GrainLookupRT), propertySheet, base.settings.colored.value ? 1 : 0, clear: false, null);
		context.command.EndSample("GrainLookup");
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.EnableKeyword("GRAIN");
		uberSheet.properties.SetTexture(ShaderIDs.GrainTex, (Texture)(object)m_GrainLookupRT);
		uberSheet.properties.SetVector(ShaderIDs.Grain_Params1, Vector4.op_Implicit(new Vector2(base.settings.lumContrib.value, base.settings.intensity.value * 20f)));
		uberSheet.properties.SetVector(ShaderIDs.Grain_Params2, new Vector4((float)context.width / (float)((Texture)m_GrainLookupRT).width / base.settings.size.value, (float)context.height / (float)((Texture)m_GrainLookupRT).height / base.settings.size.value, num, num2));
	}

	private RenderTextureFormat GetLookupFormat()
	{
		if (!((RenderTextureFormat)2).IsSupported())
		{
			return (RenderTextureFormat)0;
		}
		return (RenderTextureFormat)2;
	}

	public override void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_GrainLookupRT);
		m_GrainLookupRT = null;
		m_SampleIndex = 0;
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(LensDistortionRenderer), "Unity/Lens Distortion", true)]
public sealed class LensDistortion : PostProcessEffectSettings
{
	[Range(-100f, 100f)]
	[Tooltip("Total distortion amount.")]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	[DisplayName("X Multiplier")]
	[Tooltip("Intensity multiplier on the x-axis. Set it to 0 to disable distortion on this axis.")]
	public FloatParameter intensityX = new FloatParameter
	{
		value = 1f
	};

	[DisplayName("Y Multiplier")]
	[Tooltip("Intensity multiplier on the y-axis. Set it to 0 to disable distortion on this axis.")]
	[Range(0f, 1f)]
	public FloatParameter intensityY = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Distortion center point (x-axis).")]
	[Range(-1f, 1f)]
	[Space]
	public FloatParameter centerX = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Distortion center point (y-axis).")]
	[Range(-1f, 1f)]
	public FloatParameter centerY = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Global screen scaling.")]
	[Space]
	[Range(0.01f, 5f)]
	public FloatParameter scale = new FloatParameter
	{
		value = 1f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value && !Mathf.Approximately((float)intensity, 0f) && ((float)intensityX > 0f || (float)intensityY > 0f))
		{
			return !RuntimeUtilities.isVREnabled;
		}
		return false;
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class LensDistortionRenderer : PostProcessEffectRenderer<LensDistortion>
{
	public override void Render(PostProcessRenderContext context)
	{
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet uberSheet = context.uberSheet;
		float val = 1.6f * Math.Max(Mathf.Abs(base.settings.intensity.value), 1f);
		float num = MathF.PI / 180f * Math.Min(160f, val);
		float num2 = 2f * Mathf.Tan(num * 0.5f);
		Vector4 val2 = default(Vector4);
		((Vector4)(ref val2))..ctor(base.settings.centerX.value, base.settings.centerY.value, Mathf.Max(base.settings.intensityX.value, 0.0001f), Mathf.Max(base.settings.intensityY.value, 0.0001f));
		Vector4 val3 = default(Vector4);
		((Vector4)(ref val3))..ctor((base.settings.intensity.value >= 0f) ? num : (1f / num), num2, 1f / base.settings.scale.value, base.settings.intensity.value);
		uberSheet.EnableKeyword("DISTORT");
		uberSheet.properties.SetVector(ShaderIDs.Distortion_CenterScale, val2);
		uberSheet.properties.SetVector(ShaderIDs.Distortion_Amount, val3);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(MotionBlurRenderer), "Unity/Motion Blur", false)]
public sealed class MotionBlur : PostProcessEffectSettings
{
	[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
	[Range(0f, 360f)]
	public FloatParameter shutterAngle = new FloatParameter
	{
		value = 270f
	};

	[Range(4f, 32f)]
	[Tooltip("The amount of sample points. This affects quality and performance.")]
	public IntParameter sampleCount = new IntParameter
	{
		value = 10
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value && shutterAngle.value > 0f && SystemInfo.supportsMotionVectors && ((RenderTextureFormat)13).IsSupported())
		{
			return !RuntimeUtilities.isVREnabled;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class MotionBlurRenderer : PostProcessEffectRenderer<MotionBlur>
{
	private enum Pass
	{
		VelocitySetup,
		TileMax1,
		TileMax2,
		TileMaxV,
		NeighborMax,
		Reconstruction
	}

	public override DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)5;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		if (m_ResetHistory)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			m_ResetHistory = false;
			return;
		}
		RenderTextureFormat val = (RenderTextureFormat)13;
		RenderTextureFormat val2 = (RenderTextureFormat)(((RenderTextureFormat)8).IsSupported() ? 8 : 0);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.motionBlur);
		command.BeginSample("MotionBlur");
		int num = (int)(5f * (float)context.height / 100f);
		int num2 = ((num - 1) / 8 + 1) * 8;
		float num3 = (float)base.settings.shutterAngle / 360f;
		propertySheet.properties.SetFloat(ShaderIDs.VelocityScale, num3);
		propertySheet.properties.SetFloat(ShaderIDs.MaxBlurRadius, (float)num);
		propertySheet.properties.SetFloat(ShaderIDs.RcpMaxBlurRadius, 1f / (float)num);
		int velocityTex = ShaderIDs.VelocityTex;
		command.GetTemporaryRT(velocityTex, context.width, context.height, 0, (FilterMode)0, val2, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit(velocityTex), propertySheet, 0, clear: false, null);
		int tile2RT = ShaderIDs.Tile2RT;
		command.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(velocityTex), RenderTargetIdentifier.op_Implicit(tile2RT), propertySheet, 1, clear: false, null);
		int tile4RT = ShaderIDs.Tile4RT;
		command.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tile2RT), RenderTargetIdentifier.op_Implicit(tile4RT), propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(tile2RT);
		int tile8RT = ShaderIDs.Tile8RT;
		command.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tile4RT), RenderTargetIdentifier.op_Implicit(tile8RT), propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(tile4RT);
		Vector2 val3 = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
		propertySheet.properties.SetVector(ShaderIDs.TileMaxOffs, Vector4.op_Implicit(val3));
		propertySheet.properties.SetFloat(ShaderIDs.TileMaxLoop, (float)(int)((float)num2 / 8f));
		int tileVRT = ShaderIDs.TileVRT;
		command.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tile8RT), RenderTargetIdentifier.op_Implicit(tileVRT), propertySheet, 3, clear: false, null);
		command.ReleaseTemporaryRT(tile8RT);
		int neighborMaxTex = ShaderIDs.NeighborMaxTex;
		int num4 = context.width / num2;
		int num5 = context.height / num2;
		command.GetTemporaryRT(neighborMaxTex, num4, num5, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tileVRT), RenderTargetIdentifier.op_Implicit(neighborMaxTex), propertySheet, 4, clear: false, null);
		command.ReleaseTemporaryRT(tileVRT);
		propertySheet.properties.SetFloat(ShaderIDs.LoopCount, (float)Mathf.Clamp((int)base.settings.sampleCount / 2, 1, 64));
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, clear: false, null);
		command.ReleaseTemporaryRT(velocityTex);
		command.ReleaseTemporaryRT(neighborMaxTex);
		command.EndSample("MotionBlur");
	}
}


private enum Pass
{
	VelocitySetup,
	TileMax1,
	TileMax2,
	TileMaxV,
	NeighborMax,
	Reconstruction
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
internal sealed class MultiScaleVO : IAmbientOcclusionMethod
{
	internal enum MipLevel
	{
		Original,
		L1,
		L2,
		L3,
		L4,
		L5,
		L6
	}

	private enum Pass
	{
		DepthCopy,
		CompositionDeferred,
		CompositionForward,
		DebugOverlay
	}

	private readonly float[] m_SampleThickness = new float[12]
	{
		Mathf.Sqrt(0.96f),
		Mathf.Sqrt(0.84f),
		Mathf.Sqrt(0.64f),
		Mathf.Sqrt(0.35999995f),
		Mathf.Sqrt(0.91999996f),
		Mathf.Sqrt(0.79999995f),
		Mathf.Sqrt(0.59999996f),
		Mathf.Sqrt(0.31999993f),
		Mathf.Sqrt(0.67999995f),
		Mathf.Sqrt(0.47999996f),
		Mathf.Sqrt(0.19999993f),
		Mathf.Sqrt(0.27999997f)
	};

	private readonly float[] m_InvThicknessTable = new float[12];

	private readonly float[] m_SampleWeightTable = new float[12];

	private readonly int[] m_Widths = new int[7];

	private readonly int[] m_Heights = new int[7];

	private AmbientOcclusion m_Settings;

	private PropertySheet m_PropertySheet;

	private PostProcessResources m_Resources;

	private RenderTexture m_AmbientOnlyAO;

	private readonly RenderTargetIdentifier[] m_MRT = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2]
	{
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)10),
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2)
	};

	public MultiScaleVO(AmbientOcclusion settings)
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		m_Settings = settings;
	}

	public DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)1;
	}

	public void SetResources(PostProcessResources resources)
	{
		m_Resources = resources;
	}

	private void Alloc(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureDescriptor val = default(RenderTextureDescriptor);
		((RenderTextureDescriptor)(ref val)).width = m_Widths[(int)size];
		((RenderTextureDescriptor)(ref val)).height = m_Heights[(int)size];
		((RenderTextureDescriptor)(ref val)).colorFormat = format;
		((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
		((RenderTextureDescriptor)(ref val)).volumeDepth = 1;
		((RenderTextureDescriptor)(ref val)).autoGenerateMips = false;
		((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
		((RenderTextureDescriptor)(ref val)).enableRandomWrite = uav;
		((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)2;
		((RenderTextureDescriptor)(ref val)).sRGB = false;
		cmd.GetTemporaryRT(id, val, (FilterMode)0);
	}

	private void AllocArray(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureDescriptor val = default(RenderTextureDescriptor);
		((RenderTextureDescriptor)(ref val)).width = m_Widths[(int)size];
		((RenderTextureDescriptor)(ref val)).height = m_Heights[(int)size];
		((RenderTextureDescriptor)(ref val)).colorFormat = format;
		((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
		((RenderTextureDescriptor)(ref val)).volumeDepth = 16;
		((RenderTextureDescriptor)(ref val)).autoGenerateMips = false;
		((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
		((RenderTextureDescriptor)(ref val)).enableRandomWrite = uav;
		((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)5;
		((RenderTextureDescriptor)(ref val)).sRGB = false;
		cmd.GetTemporaryRT(id, val, (FilterMode)0);
	}

	private void Release(CommandBuffer cmd, int id)
	{
		cmd.ReleaseTemporaryRT(id);
	}

	private Vector4 CalculateZBufferParams(Camera camera)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float num = camera.farClipPlane / camera.nearClipPlane;
		if (SystemInfo.usesReversedZBuffer)
		{
			return new Vector4(num - 1f, 1f, 0f, 0f);
		}
		return new Vector4(1f - num, num, 0f, 0f);
	}

	private float CalculateTanHalfFovHeight(Camera camera)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 projectionMatrix = camera.projectionMatrix;
		return 1f / ((Matrix4x4)(ref projectionMatrix))[0, 0];
	}

	private Vector2 GetSize(MipLevel mip)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)m_Widths[(int)mip], (float)m_Heights[(int)mip]);
	}

	private Vector3 GetSizeArray(MipLevel mip)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)m_Widths[(int)mip], (float)m_Heights[(int)mip], 16f);
	}

	public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert, bool isMSAA)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		m_Widths[0] = camera.pixelWidth * ((!RuntimeUtilities.isSinglePassStereoEnabled) ? 1 : 2);
		m_Heights[0] = camera.pixelHeight;
		for (int i = 1; i < 7; i++)
		{
			int num = 1 << i;
			m_Widths[i] = (m_Widths[0] + (num - 1)) / num;
			m_Heights[i] = (m_Heights[0] + (num - 1)) / num;
		}
		PushAllocCommands(cmd, isMSAA);
		PushDownsampleCommands(cmd, camera, depthMap, isMSAA);
		float tanHalfFovH = CalculateTanHalfFovHeight(camera);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth1, ShaderIDs.Occlusion1, GetSizeArray(MipLevel.L3), tanHalfFovH, isMSAA);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth2, ShaderIDs.Occlusion2, GetSizeArray(MipLevel.L4), tanHalfFovH, isMSAA);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth3, ShaderIDs.Occlusion3, GetSizeArray(MipLevel.L5), tanHalfFovH, isMSAA);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth4, ShaderIDs.Occlusion4, GetSizeArray(MipLevel.L6), tanHalfFovH, isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth4, ShaderIDs.Occlusion4, ShaderIDs.LowDepth3, ShaderIDs.Occlusion3, RenderTargetIdentifier.op_Implicit(ShaderIDs.Combined3), Vector2.op_Implicit(GetSize(MipLevel.L4)), GetSize(MipLevel.L3), isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth3, ShaderIDs.Combined3, ShaderIDs.LowDepth2, ShaderIDs.Occlusion2, RenderTargetIdentifier.op_Implicit(ShaderIDs.Combined2), Vector2.op_Implicit(GetSize(MipLevel.L3)), GetSize(MipLevel.L2), isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth2, ShaderIDs.Combined2, ShaderIDs.LowDepth1, ShaderIDs.Occlusion1, RenderTargetIdentifier.op_Implicit(ShaderIDs.Combined1), Vector2.op_Implicit(GetSize(MipLevel.L2)), GetSize(MipLevel.L1), isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth1, ShaderIDs.Combined1, ShaderIDs.LinearDepth, null, destination, Vector2.op_Implicit(GetSize(MipLevel.L1)), GetSize(MipLevel.Original), isMSAA, invert);
		PushReleaseCommands(cmd);
	}

	private void PushAllocCommands(CommandBuffer cmd, bool isMSAA)
	{
		if (isMSAA)
		{
			Alloc(cmd, ShaderIDs.LinearDepth, MipLevel.Original, (RenderTextureFormat)13, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth1, MipLevel.L1, (RenderTextureFormat)12, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth2, MipLevel.L2, (RenderTextureFormat)12, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth3, MipLevel.L3, (RenderTextureFormat)12, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth4, MipLevel.L4, (RenderTextureFormat)12, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth1, MipLevel.L3, (RenderTextureFormat)13, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth2, MipLevel.L4, (RenderTextureFormat)13, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth3, MipLevel.L5, (RenderTextureFormat)13, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth4, MipLevel.L6, (RenderTextureFormat)13, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion1, MipLevel.L1, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion2, MipLevel.L2, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion3, MipLevel.L3, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion4, MipLevel.L4, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Combined1, MipLevel.L1, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Combined2, MipLevel.L2, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Combined3, MipLevel.L3, (RenderTextureFormat)25, uav: true);
		}
		else
		{
			Alloc(cmd, ShaderIDs.LinearDepth, MipLevel.Original, (RenderTextureFormat)15, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth1, MipLevel.L1, (RenderTextureFormat)14, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth2, MipLevel.L2, (RenderTextureFormat)14, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth3, MipLevel.L3, (RenderTextureFormat)14, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth4, MipLevel.L4, (RenderTextureFormat)14, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth1, MipLevel.L3, (RenderTextureFormat)15, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth2, MipLevel.L4, (RenderTextureFormat)15, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth3, MipLevel.L5, (RenderTextureFormat)15, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth4, MipLevel.L6, (RenderTextureFormat)15, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion1, MipLevel.L1, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion2, MipLevel.L2, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion3, MipLevel.L3, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion4, MipLevel.L4, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Combined1, MipLevel.L1, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Combined2, MipLevel.L2, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Combined3, MipLevel.L3, (RenderTextureFormat)16, uav: true);
		}
	}

	private void PushDownsampleCommands(CommandBuffer cmd, Camera camera, RenderTargetIdentifier? depthMap, bool isMSAA)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		RenderTargetIdentifier val = default(RenderTargetIdentifier);
		if (depthMap.HasValue)
		{
			val = depthMap.Value;
		}
		else if (!RuntimeUtilities.IsResolvedDepthAvailable(camera))
		{
			Alloc(cmd, ShaderIDs.DepthCopy, MipLevel.Original, (RenderTextureFormat)14, uav: false);
			((RenderTargetIdentifier)(ref val))..ctor(ShaderIDs.DepthCopy);
			cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), val, m_PropertySheet, 0, clear: false, null);
			flag = true;
		}
		else
		{
			val = RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)5);
		}
		ComputeShader multiScaleAODownsample = m_Resources.computeShaders.multiScaleAODownsample1;
		int num = multiScaleAODownsample.FindKernel(isMSAA ? "MultiScaleVODownsample1_MSAA" : "MultiScaleVODownsample1");
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "LinearZ", RenderTargetIdentifier.op_Implicit(ShaderIDs.LinearDepth));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS2x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth1));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS4x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth2));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS2xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth1));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS4xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth2));
		cmd.SetComputeVectorParam(multiScaleAODownsample, "ZBufferParams", CalculateZBufferParams(camera));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "Depth", val);
		cmd.DispatchCompute(multiScaleAODownsample, num, m_Widths[4], m_Heights[4], 1);
		if (flag)
		{
			Release(cmd, ShaderIDs.DepthCopy);
		}
		multiScaleAODownsample = m_Resources.computeShaders.multiScaleAODownsample2;
		num = (isMSAA ? multiScaleAODownsample.FindKernel("MultiScaleVODownsample2_MSAA") : multiScaleAODownsample.FindKernel("MultiScaleVODownsample2"));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS4x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth2));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS8x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth3));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS16x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth4));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS8xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth3));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS16xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth4));
		cmd.DispatchCompute(multiScaleAODownsample, num, m_Widths[6], m_Heights[6], 1);
	}

	private void PushRenderCommands(CommandBuffer cmd, int source, int destination, Vector3 sourceSize, float tanHalfFovH, bool isMSAA)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		float num = 2f * tanHalfFovH * 10f / sourceSize.x;
		if (RuntimeUtilities.isSinglePassStereoEnabled)
		{
			num *= 2f;
		}
		float num2 = 1f / num;
		for (int i = 0; i < 12; i++)
		{
			m_InvThicknessTable[i] = num2 / m_SampleThickness[i];
		}
		m_SampleWeightTable[0] = 4f * m_SampleThickness[0];
		m_SampleWeightTable[1] = 4f * m_SampleThickness[1];
		m_SampleWeightTable[2] = 4f * m_SampleThickness[2];
		m_SampleWeightTable[3] = 4f * m_SampleThickness[3];
		m_SampleWeightTable[4] = 4f * m_SampleThickness[4];
		m_SampleWeightTable[5] = 8f * m_SampleThickness[5];
		m_SampleWeightTable[6] = 8f * m_SampleThickness[6];
		m_SampleWeightTable[7] = 8f * m_SampleThickness[7];
		m_SampleWeightTable[8] = 4f * m_SampleThickness[8];
		m_SampleWeightTable[9] = 8f * m_SampleThickness[9];
		m_SampleWeightTable[10] = 8f * m_SampleThickness[10];
		m_SampleWeightTable[11] = 4f * m_SampleThickness[11];
		m_SampleWeightTable[0] = 0f;
		m_SampleWeightTable[2] = 0f;
		m_SampleWeightTable[5] = 0f;
		m_SampleWeightTable[7] = 0f;
		m_SampleWeightTable[9] = 0f;
		float num3 = 0f;
		float[] sampleWeightTable = m_SampleWeightTable;
		foreach (float num4 in sampleWeightTable)
		{
			num3 += num4;
		}
		for (int k = 0; k < m_SampleWeightTable.Length; k++)
		{
			m_SampleWeightTable[k] /= num3;
		}
		ComputeShader multiScaleAORender = m_Resources.computeShaders.multiScaleAORender;
		int num5 = (isMSAA ? multiScaleAORender.FindKernel("MultiScaleVORender_MSAA_interleaved") : multiScaleAORender.FindKernel("MultiScaleVORender_interleaved"));
		cmd.SetComputeFloatParams(multiScaleAORender, "gInvThicknessTable", m_InvThicknessTable);
		cmd.SetComputeFloatParams(multiScaleAORender, "gSampleWeightTable", m_SampleWeightTable);
		cmd.SetComputeVectorParam(multiScaleAORender, "gInvSliceDimension", Vector4.op_Implicit(new Vector2(1f / sourceSize.x, 1f / sourceSize.y)));
		cmd.SetComputeVectorParam(multiScaleAORender, "AdditionalParams", Vector4.op_Implicit(new Vector2(-1f / m_Settings.thicknessModifier.value, m_Settings.intensity.value)));
		cmd.SetComputeTextureParam(multiScaleAORender, num5, "DepthTex", RenderTargetIdentifier.op_Implicit(source));
		cmd.SetComputeTextureParam(multiScaleAORender, num5, "Occlusion", RenderTargetIdentifier.op_Implicit(destination));
		uint num6 = default(uint);
		uint num7 = default(uint);
		uint num8 = default(uint);
		multiScaleAORender.GetKernelThreadGroupSizes(num5, ref num6, ref num7, ref num8);
		cmd.DispatchCompute(multiScaleAORender, num5, ((int)sourceSize.x + (int)num6 - 1) / (int)num6, ((int)sourceSize.y + (int)num7 - 1) / (int)num7, ((int)sourceSize.z + (int)num8 - 1) / (int)num8);
	}

	private void PushUpsampleCommands(CommandBuffer cmd, int lowResDepth, int interleavedAO, int highResDepth, int? highResAO, RenderTargetIdentifier dest, Vector3 lowResDepthSize, Vector2 highResDepthSize, bool isMSAA, bool invert = false)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		ComputeShader multiScaleAOUpsample = m_Resources.computeShaders.multiScaleAOUpsample;
		int num = 0;
		num = (isMSAA ? multiScaleAOUpsample.FindKernel(highResAO.HasValue ? "MultiScaleVOUpSample_MSAA_blendout" : (invert ? "MultiScaleVOUpSample_MSAA_invert" : "MultiScaleVOUpSample_MSAA")) : multiScaleAOUpsample.FindKernel(highResAO.HasValue ? "MultiScaleVOUpSample_blendout" : (invert ? "MultiScaleVOUpSample_invert" : "MultiScaleVOUpSample")));
		float num2 = 1920f / lowResDepthSize.x;
		float num3 = 1f - Mathf.Pow(10f, m_Settings.blurTolerance.value) * num2;
		num3 *= num3;
		float num4 = Mathf.Pow(10f, m_Settings.upsampleTolerance.value);
		float num5 = 1f / (Mathf.Pow(10f, m_Settings.noiseFilterTolerance.value) + num4);
		cmd.SetComputeVectorParam(multiScaleAOUpsample, "InvLowResolution", Vector4.op_Implicit(new Vector2(1f / lowResDepthSize.x, 1f / lowResDepthSize.y)));
		cmd.SetComputeVectorParam(multiScaleAOUpsample, "InvHighResolution", Vector4.op_Implicit(new Vector2(1f / highResDepthSize.x, 1f / highResDepthSize.y)));
		cmd.SetComputeVectorParam(multiScaleAOUpsample, "AdditionalParams", new Vector4(num5, num2, num3, num4));
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "LoResDB", RenderTargetIdentifier.op_Implicit(lowResDepth));
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "HiResDB", RenderTargetIdentifier.op_Implicit(highResDepth));
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "LoResAO1", RenderTargetIdentifier.op_Implicit(interleavedAO));
		if (highResAO.HasValue)
		{
			cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "HiResAO", RenderTargetIdentifier.op_Implicit(highResAO.Value));
		}
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "AoResult", dest);
		int num6 = ((int)highResDepthSize.x + 17) / 16;
		int num7 = ((int)highResDepthSize.y + 17) / 16;
		cmd.DispatchCompute(multiScaleAOUpsample, num, num6, num7, 1);
	}

	private void PushReleaseCommands(CommandBuffer cmd)
	{
		Release(cmd, ShaderIDs.LinearDepth);
		Release(cmd, ShaderIDs.LowDepth1);
		Release(cmd, ShaderIDs.LowDepth2);
		Release(cmd, ShaderIDs.LowDepth3);
		Release(cmd, ShaderIDs.LowDepth4);
		Release(cmd, ShaderIDs.TiledDepth1);
		Release(cmd, ShaderIDs.TiledDepth2);
		Release(cmd, ShaderIDs.TiledDepth3);
		Release(cmd, ShaderIDs.TiledDepth4);
		Release(cmd, ShaderIDs.Occlusion1);
		Release(cmd, ShaderIDs.Occlusion2);
		Release(cmd, ShaderIDs.Occlusion3);
		Release(cmd, ShaderIDs.Occlusion4);
		Release(cmd, ShaderIDs.Combined1);
		Release(cmd, ShaderIDs.Combined2);
		Release(cmd, ShaderIDs.Combined3);
	}

	private void PreparePropertySheet(PostProcessRenderContext context)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(m_Resources.shaders.multiScaleAO);
		propertySheet.ClearKeywords();
		propertySheet.properties.SetVector(ShaderIDs.AOColor, Color.op_Implicit(Color.white - m_Settings.color.value));
		m_PropertySheet = propertySheet;
	}

	private void CheckAOTexture(PostProcessRenderContext context)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Expected O, but got Unknown
		if ((Object)(object)m_AmbientOnlyAO == (Object)null || !m_AmbientOnlyAO.IsCreated() || ((Texture)m_AmbientOnlyAO).width != context.width || ((Texture)m_AmbientOnlyAO).height != context.height)
		{
			RuntimeUtilities.Destroy((Object)(object)m_AmbientOnlyAO);
			m_AmbientOnlyAO = new RenderTexture(context.width, context.height, 0, (RenderTextureFormat)16, (RenderTextureReadWrite)1)
			{
				hideFlags = (HideFlags)52,
				filterMode = (FilterMode)0,
				enableRandomWrite = true
			};
			m_AmbientOnlyAO.Create();
		}
	}

	private void PushDebug(PostProcessRenderContext context)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion))
		{
			context.PushDebugOverlay(context.command, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO), m_PropertySheet, 3);
		}
	}

	public void RenderAfterOpaque(PostProcessRenderContext context)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Invalid comparison between Unknown and I4
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion");
		SetResources(context.resources);
		PreparePropertySheet(context);
		CheckAOTexture(context);
		if ((int)context.camera.actualRenderingPath == 1 && RenderSettings.fog)
		{
			m_PropertySheet.EnableKeyword("APPLY_FORWARD_FOG");
			m_PropertySheet.properties.SetVector(ShaderIDs.FogParams, Vector4.op_Implicit(new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance)));
		}
		GenerateAOMap(command, context.camera, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO), null, invert: false, isMSAA: false);
		PushDebug(context);
		command.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 2, (RenderBufferLoadAction)0, null);
		command.EndSample("Ambient Occlusion");
	}

	public void RenderAmbientOnly(PostProcessRenderContext context)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Render");
		SetResources(context.resources);
		PreparePropertySheet(context);
		CheckAOTexture(context);
		GenerateAOMap(command, context.camera, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO), null, invert: false, isMSAA: false);
		PushDebug(context);
		command.EndSample("Ambient Occlusion Render");
	}

	public void CompositeAmbientOnly(PostProcessRenderContext context)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Composite");
		command.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), m_MRT, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 1, clear: false, null);
		command.EndSample("Ambient Occlusion Composite");
	}

	public void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_AmbientOnlyAO);
		m_AmbientOnlyAO = null;
	}
}


internal enum MipLevel
{
	Original,
	L1,
	L2,
	L3,
	L4,
	L5,
	L6
}


private enum Pass
{
	DepthCopy,
	CompositionDeferred,
	CompositionForward,
	DebugOverlay
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
internal sealed class ScalableAO : IAmbientOcclusionMethod
{
	private enum Pass
	{
		OcclusionEstimationForward,
		OcclusionEstimationDeferred,
		HorizontalBlurForward,
		HorizontalBlurDeferred,
		VerticalBlur,
		CompositionForward,
		CompositionDeferred,
		DebugOverlay
	}

	private RenderTexture m_Result;

	private PropertySheet m_PropertySheet;

	private AmbientOcclusion m_Settings;

	private readonly RenderTargetIdentifier[] m_MRT = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2]
	{
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)10),
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2)
	};

	private readonly int[] m_SampleCount = new int[5] { 4, 6, 10, 8, 12 };

	public ScalableAO(AmbientOcclusion settings)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		m_Settings = settings;
	}

	public DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)3;
	}

	private void DoLazyInitialization(PostProcessRenderContext context)
	{
		m_PropertySheet = context.propertySheets.Get(context.resources.shaders.scalableAO);
		bool flag = false;
		if ((Object)(object)m_Result == (Object)null || !m_Result.IsCreated())
		{
			m_Result = context.GetScreenSpaceTemporaryRT(0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
			((Object)m_Result).hideFlags = (HideFlags)52;
			((Texture)m_Result).filterMode = (FilterMode)1;
			flag = true;
		}
		else if (((Texture)m_Result).width != context.width || ((Texture)m_Result).height != context.height)
		{
			m_Result.Release();
			((Texture)m_Result).width = context.width;
			((Texture)m_Result).height = context.height;
			flag = true;
		}
		if (flag)
		{
			m_Result.Create();
		}
	}

	private void Render(PostProcessRenderContext context, CommandBuffer cmd, int occlusionSource)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Invalid comparison between Unknown and I4
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		DoLazyInitialization(context);
		m_Settings.radius.value = Mathf.Max(m_Settings.radius.value, 0.0001f);
		bool num = m_Settings.quality.value < AmbientOcclusionQuality.High;
		float value = m_Settings.intensity.value;
		float value2 = m_Settings.radius.value;
		float num2 = (num ? 0.5f : 1f);
		float num3 = m_SampleCount[(int)m_Settings.quality.value];
		PropertySheet propertySheet = m_PropertySheet;
		propertySheet.ClearKeywords();
		propertySheet.properties.SetVector(ShaderIDs.AOParams, new Vector4(value, value2, num2, num3));
		propertySheet.properties.SetVector(ShaderIDs.AOColor, Color.op_Implicit(Color.white - m_Settings.color.value));
		if ((int)context.camera.actualRenderingPath == 1 && RenderSettings.fog)
		{
			propertySheet.EnableKeyword("APPLY_FORWARD_FOG");
			propertySheet.properties.SetVector(ShaderIDs.FogParams, Vector4.op_Implicit(new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance)));
		}
		int num4 = ((!num) ? 1 : 2);
		int occlusionTexture = ShaderIDs.OcclusionTexture1;
		int widthOverride = context.width / num4;
		int heightOverride = context.height / num4;
		context.GetScreenSpaceTemporaryRT(cmd, occlusionTexture, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1, (FilterMode)1, widthOverride, heightOverride);
		cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit(occlusionTexture), propertySheet, occlusionSource, clear: false, null);
		int occlusionTexture2 = ShaderIDs.OcclusionTexture2;
		context.GetScreenSpaceTemporaryRT(cmd, occlusionTexture2, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1, (FilterMode)1);
		cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(occlusionTexture), RenderTargetIdentifier.op_Implicit(occlusionTexture2), propertySheet, 2 + occlusionSource, clear: false, null);
		cmd.ReleaseTemporaryRT(occlusionTexture);
		cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(occlusionTexture2), RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result), propertySheet, 4, clear: false, null);
		cmd.ReleaseTemporaryRT(occlusionTexture2);
		if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion))
		{
			context.PushDebugOverlay(cmd, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result), propertySheet, 7);
		}
	}

	public void RenderAfterOpaque(PostProcessRenderContext context)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion");
		Render(context, command, 0);
		command.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 5, (RenderBufferLoadAction)0, null);
		command.EndSample("Ambient Occlusion");
	}

	public void RenderAmbientOnly(PostProcessRenderContext context)
	{
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Render");
		Render(context, command, 1);
		command.EndSample("Ambient Occlusion Render");
	}

	public void CompositeAmbientOnly(PostProcessRenderContext context)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Composite");
		command.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), m_MRT, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 6, clear: false, null);
		command.EndSample("Ambient Occlusion Composite");
	}

	public void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_Result);
		m_Result = null;
	}
}


private enum Pass
{
	OcclusionEstimationForward,
	OcclusionEstimationDeferred,
	HorizontalBlurForward,
	HorizontalBlurDeferred,
	VerticalBlur,
	CompositionForward,
	CompositionDeferred,
	DebugOverlay
}


public enum ScreenSpaceReflectionPreset
{
	Lower,
	Low,
	Medium,
	High,
	Higher,
	Ultra,
	Overkill,
	Custom
}


public enum ScreenSpaceReflectionResolution
{
	Downsampled,
	FullSize,
	Supersampled
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ScreenSpaceReflectionPresetParameter : ParameterOverride<ScreenSpaceReflectionPreset>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ScreenSpaceReflectionResolutionParameter : ParameterOverride<ScreenSpaceReflectionResolution>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ScreenSpaceReflectionsRenderer), "Unity/Screen-space reflections", true)]
public sealed class ScreenSpaceReflections : PostProcessEffectSettings
{
	[Tooltip("Choose a quality preset, or use \"Custom\" to create your own custom preset. Don't use a preset higher than \"Medium\" if you desire good performance on consoles.")]
	public ScreenSpaceReflectionPresetParameter preset = new ScreenSpaceReflectionPresetParameter
	{
		value = ScreenSpaceReflectionPreset.Medium
	};

	[Range(0f, 256f)]
	[Tooltip("Maximum number of steps in the raymarching pass. Higher values mean more reflections.")]
	public IntParameter maximumIterationCount = new IntParameter
	{
		value = 16
	};

	[Tooltip("Changes the size of the SSR buffer. Downsample it to maximize performances or supersample it for higher quality results with reduced performance.")]
	public ScreenSpaceReflectionResolutionParameter resolution = new ScreenSpaceReflectionResolutionParameter
	{
		value = ScreenSpaceReflectionResolution.Downsampled
	};

	[Range(1f, 64f)]
	[Tooltip("Ray thickness. Lower values are more expensive but allow the effect to detect smaller details.")]
	public FloatParameter thickness = new FloatParameter
	{
		value = 8f
	};

	[Tooltip("Maximum distance to traverse after which it will stop drawing reflections.")]
	public FloatParameter maximumMarchDistance = new FloatParameter
	{
		value = 100f
	};

	[Range(0f, 1f)]
	[Tooltip("Fades reflections close to the near planes.")]
	public FloatParameter distanceFade = new FloatParameter
	{
		value = 0.5f
	};

	[Range(0f, 1f)]
	[Tooltip("Fades reflections close to the screen edges.")]
	public FloatParameter vignette = new FloatParameter
	{
		value = 0.5f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Invalid comparison between Unknown and I4
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Invalid comparison between Unknown and I4
		if ((bool)enabled && (int)context.camera.actualRenderingPath == 3 && SystemInfo.supportsMotionVectors && SystemInfo.supportsComputeShaders && (int)SystemInfo.copyTextureSupport > 0 && Object.op_Implicit((Object)(object)context.resources.shaders.screenSpaceReflections) && context.resources.shaders.screenSpaceReflections.isSupported)
		{
			return Object.op_Implicit((Object)(object)context.resources.computeShaders.gaussianDownsample);
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class ScreenSpaceReflectionsRenderer : PostProcessEffectRenderer<ScreenSpaceReflections>
{
	private class QualityPreset
	{
		public int maximumIterationCount;

		public float thickness;

		public ScreenSpaceReflectionResolution downsampling;
	}

	private enum Pass
	{
		Test,
		Resolve,
		Reproject,
		Composite
	}

	private RenderTexture m_Resolve;

	private RenderTexture m_History;

	private int[] m_MipIDs;

	private readonly QualityPreset[] m_Presets = new QualityPreset[7]
	{
		new QualityPreset
		{
			maximumIterationCount = 10,
			thickness = 32f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 16,
			thickness = 32f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 32,
			thickness = 16f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 48,
			thickness = 8f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 16,
			thickness = 32f,
			downsampling = ScreenSpaceReflectionResolution.FullSize
		},
		new QualityPreset
		{
			maximumIterationCount = 48,
			thickness = 16f,
			downsampling = ScreenSpaceReflectionResolution.FullSize
		},
		new QualityPreset
		{
			maximumIterationCount = 128,
			thickness = 12f,
			downsampling = ScreenSpaceReflectionResolution.Supersampled
		}
	};

	public override DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)5;
	}

	internal void CheckRT(ref RenderTexture rt, int width, int height, FilterMode filterMode, bool useMipMap)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Expected O, but got Unknown
		if ((Object)(object)rt == (Object)null || !rt.IsCreated() || ((Texture)rt).width != width || ((Texture)rt).height != height)
		{
			if ((Object)(object)rt != (Object)null)
			{
				rt.Release();
				RuntimeUtilities.Destroy((Object)(object)rt);
			}
			rt = new RenderTexture(width, height, 0, RuntimeUtilities.defaultHDRRenderTextureFormat)
			{
				filterMode = filterMode,
				useMipMap = useMipMap,
				autoGenerateMips = false,
				hideFlags = (HideFlags)61
			};
			rt.Create();
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0529: Unknown result type (might be due to invalid IL or missing references)
		//IL_0540: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0580: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0617: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Screen-space Reflections");
		if (base.settings.preset.value != ScreenSpaceReflectionPreset.Custom)
		{
			int value = (int)base.settings.preset.value;
			base.settings.maximumIterationCount.value = m_Presets[value].maximumIterationCount;
			base.settings.thickness.value = m_Presets[value].thickness;
			base.settings.resolution.value = m_Presets[value].downsampling;
		}
		base.settings.maximumMarchDistance.value = Mathf.Max(0f, base.settings.maximumMarchDistance.value);
		int num = Mathf.ClosestPowerOfTwo(Mathf.Min(context.width, context.height));
		if (base.settings.resolution.value == ScreenSpaceReflectionResolution.Downsampled)
		{
			num >>= 1;
		}
		else if (base.settings.resolution.value == ScreenSpaceReflectionResolution.Supersampled)
		{
			num <<= 1;
		}
		int num2 = Mathf.FloorToInt(Mathf.Log((float)num, 2f) - 3f);
		num2 = Mathf.Min(num2, 12);
		CheckRT(ref m_Resolve, num, num, (FilterMode)2, useMipMap: true);
		Texture2D val = context.resources.blueNoise256[0];
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.screenSpaceReflections);
		propertySheet.properties.SetTexture(ShaderIDs.Noise, (Texture)(object)val);
		Matrix4x4 val2 = default(Matrix4x4);
		((Matrix4x4)(ref val2)).SetRow(0, new Vector4((float)num * 0.5f, 0f, 0f, (float)num * 0.5f));
		((Matrix4x4)(ref val2)).SetRow(1, new Vector4(0f, (float)num * 0.5f, 0f, (float)num * 0.5f));
		((Matrix4x4)(ref val2)).SetRow(2, new Vector4(0f, 0f, 1f, 0f));
		((Matrix4x4)(ref val2)).SetRow(3, new Vector4(0f, 0f, 0f, 1f));
		Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(context.camera.projectionMatrix, false);
		val2 *= gPUProjectionMatrix;
		propertySheet.properties.SetMatrix(ShaderIDs.ViewMatrix, context.camera.worldToCameraMatrix);
		MaterialPropertyBlock properties = propertySheet.properties;
		int inverseViewMatrix = ShaderIDs.InverseViewMatrix;
		Matrix4x4 worldToCameraMatrix = context.camera.worldToCameraMatrix;
		properties.SetMatrix(inverseViewMatrix, ((Matrix4x4)(ref worldToCameraMatrix)).inverse);
		propertySheet.properties.SetMatrix(ShaderIDs.InverseProjectionMatrix, ((Matrix4x4)(ref gPUProjectionMatrix)).inverse);
		propertySheet.properties.SetMatrix(ShaderIDs.ScreenSpaceProjectionMatrix, val2);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(base.settings.vignette.value, base.settings.distanceFade.value, base.settings.maximumMarchDistance.value, (float)num2));
		propertySheet.properties.SetVector(ShaderIDs.Params2, new Vector4((float)context.width / (float)context.height, (float)num / (float)((Texture)val).width, base.settings.thickness.value, (float)base.settings.maximumIterationCount.value));
		command.GetTemporaryRT(ShaderIDs.Test, num, num, 0, (FilterMode)0, context.sourceFormat);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.Test), propertySheet, 0, clear: false, null);
		if (context.isSceneView)
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), propertySheet, 1, clear: false, null);
		}
		else
		{
			CheckRT(ref m_History, num, num, (FilterMode)1, useMipMap: false);
			if (m_ResetHistory)
			{
				context.command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)m_History), clear: false, null);
				m_ResetHistory = false;
			}
			command.GetTemporaryRT(ShaderIDs.SSRResolveTemp, num, num, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.SSRResolveTemp), propertySheet, 1, clear: false, null);
			propertySheet.properties.SetTexture(ShaderIDs.History, (Texture)(object)m_History);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.SSRResolveTemp), RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), propertySheet, 2, clear: false, null);
			command.CopyTexture(RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), 0, 0, RenderTargetIdentifier.op_Implicit((Texture)(object)m_History), 0, 0);
			command.ReleaseTemporaryRT(ShaderIDs.SSRResolveTemp);
		}
		command.ReleaseTemporaryRT(ShaderIDs.Test);
		if (m_MipIDs == null || m_MipIDs.Length == 0)
		{
			m_MipIDs = new int[12];
			for (int i = 0; i < 12; i++)
			{
				m_MipIDs[i] = Shader.PropertyToID("_SSRGaussianMip" + i);
			}
		}
		ComputeShader gaussianDownsample = context.resources.computeShaders.gaussianDownsample;
		int num3 = gaussianDownsample.FindKernel("KMain");
		RenderTargetIdentifier val3 = default(RenderTargetIdentifier);
		((RenderTargetIdentifier)(ref val3))..ctor((Texture)(object)m_Resolve);
		for (int j = 0; j < num2; j++)
		{
			num >>= 1;
			Assert.IsTrue(num > 0);
			command.GetTemporaryRT(m_MipIDs[j], num, num, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0, 1, true);
			command.SetComputeTextureParam(gaussianDownsample, num3, "_Source", val3);
			command.SetComputeTextureParam(gaussianDownsample, num3, "_Result", RenderTargetIdentifier.op_Implicit(m_MipIDs[j]));
			command.SetComputeVectorParam(gaussianDownsample, "_Size", new Vector4((float)num, (float)num, 1f / (float)num, 1f / (float)num));
			command.DispatchCompute(gaussianDownsample, num3, num / 8, num / 8, 1);
			command.CopyTexture(RenderTargetIdentifier.op_Implicit(m_MipIDs[j]), 0, 0, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), 0, j + 1);
			val3 = RenderTargetIdentifier.op_Implicit(m_MipIDs[j]);
		}
		for (int k = 0; k < num2; k++)
		{
			command.ReleaseTemporaryRT(m_MipIDs[k]);
		}
		propertySheet.properties.SetTexture(ShaderIDs.Resolve, (Texture)(object)m_Resolve);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 3, clear: false, null);
		command.EndSample("Screen-space Reflections");
	}

	public override void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_Resolve);
		RuntimeUtilities.Destroy((Object)(object)m_History);
		m_Resolve = null;
		m_History = null;
	}
}


private class QualityPreset
{
	public int maximumIterationCount;

	public float thickness;

	public ScreenSpaceReflectionResolution downsampling;
}


private enum Pass
{
	Test,
	Resolve,
	Reproject,
	Composite
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
public sealed class SubpixelMorphologicalAntialiasing
{
	private enum Pass
	{
		EdgeDetection = 0,
		BlendWeights = 3,
		NeighborhoodBlending = 6
	}

	public enum Quality
	{
		Low,
		Medium,
		High
	}

	[Tooltip("Lower quality is faster at the expense of visual quality (Low = ~60%, Medium = ~80%).")]
	public Quality quality = Quality.High;

	public bool IsSupported()
	{
		return !RuntimeUtilities.isSinglePassStereoEnabled;
	}

	internal void Render(PostProcessRenderContext context)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.subpixelMorphologicalAntialiasing);
		propertySheet.properties.SetTexture("_AreaTex", (Texture)(object)context.resources.smaaLuts.area);
		propertySheet.properties.SetTexture("_SearchTex", (Texture)(object)context.resources.smaaLuts.search);
		CommandBuffer command = context.command;
		command.BeginSample("SubpixelMorphologicalAntialiasing");
		command.GetTemporaryRT(ShaderIDs.SMAA_Flip, context.width, context.height, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)1);
		command.GetTemporaryRT(ShaderIDs.SMAA_Flop, context.width, context.height, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flip), propertySheet, (int)quality, clear: true, null);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flip), RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flop), propertySheet, (int)(3 + quality), clear: false, null);
		command.SetGlobalTexture("_BlendTex", RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flop));
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 6, clear: false, null);
		command.ReleaseTemporaryRT(ShaderIDs.SMAA_Flip);
		command.ReleaseTemporaryRT(ShaderIDs.SMAA_Flop);
		command.EndSample("SubpixelMorphologicalAntialiasing");
	}
}


private enum Pass
{
	EdgeDetection = 0,
	BlendWeights = 3,
	NeighborhoodBlending = 6
}


public enum Quality
{
	Low,
	Medium,
	High
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
public sealed class TemporalAntialiasing
{
	private enum Pass
	{
		SolverDilate,
		SolverNoDilate
	}

	[Range(0.1f, 1f)]
	[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable, but blurrier, output.")]
	public float jitterSpread = 0.75f;

	[Tooltip("Controls the amount of sharpening applied to the color buffer. High values may introduce dark-border artifacts.")]
	[Range(0f, 3f)]
	public float sharpness = 0.25f;

	[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
	[Range(0f, 0.99f)]
	public float stationaryBlending = 0.95f;

	[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
	[Range(0f, 0.99f)]
	public float motionBlending = 0.85f;

	public Func<Camera, Vector2, Matrix4x4> jitteredMatrixFunc;

	private readonly RenderTargetIdentifier[] m_Mrt = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2];

	private bool m_ResetHistory = true;

	private const int k_NumEyes = 2;

	private const int k_NumHistoryTextures = 2;

	private readonly RenderTexture[][] m_HistoryTextures = new RenderTexture[2][];

	private readonly int[] m_HistoryPingPong = new int[2];

	public Vector2 jitter { get; private set; }

	public Vector2 jitterRaw { get; private set; }

	public int sampleIndex { get; private set; }

	public int sampleCount { get; set; }

	public bool IsSupported()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Invalid comparison between Unknown and I4
		if (SystemInfo.supportedRenderTargetCount >= 2 && SystemInfo.supportsMotionVectors)
		{
			return (int)SystemInfo.graphicsDeviceType != 8;
		}
		return false;
	}

	internal DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)5;
	}

	internal void ResetHistory()
	{
		m_ResetHistory = true;
	}

	private Vector2 GenerateRandomOffset()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = new Vector2(HaltonSeq.Get((sampleIndex & 0x3FF) + 1, 2) - 0.5f, HaltonSeq.Get((sampleIndex & 0x3FF) + 1, 3) - 0.5f);
		if (++sampleIndex >= sampleCount)
		{
			sampleIndex = 0;
		}
		return result;
	}

	public Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		jitter = GenerateRandomOffset();
		Matrix4x4 result = ((jitteredMatrixFunc == null) ? (camera.orthographic ? RuntimeUtilities.GetJitteredOrthographicProjectionMatrix(camera, jitter) : RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, jitter)) : jitteredMatrixFunc(camera, jitter));
		jitterRaw = jitter;
		jitter = new Vector2(jitter.x / (float)camera.pixelWidth, jitter.y / (float)camera.pixelHeight);
		return result;
	}

	public void ConfigureJitteredProjectionMatrix(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
		camera.projectionMatrix = GetJitteredProjectionMatrix(camera);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}

	public void ConfigureStereoJitteredProjectionMatrices(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Invalid comparison between Unknown and I4
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		jitter = GenerateRandomOffset();
		for (StereoscopicEye val = (StereoscopicEye)0; (int)val <= 1; val = (StereoscopicEye)(val + 1))
		{
			context.camera.CopyStereoDeviceProjectionMatrixToNonJittered(val);
			Matrix4x4 stereoNonJitteredProjectionMatrix = context.camera.GetStereoNonJitteredProjectionMatrix(val);
			Matrix4x4 val2 = RuntimeUtilities.GenerateJitteredProjectionMatrixFromOriginal(context, stereoNonJitteredProjectionMatrix, jitter);
			context.camera.SetStereoProjectionMatrix(val, val2);
		}
		jitter = new Vector2(jitter.x / (float)context.screenWidth, jitter.y / (float)context.screenHeight);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}

	private void GenerateHistoryName(RenderTexture rt, int id, PostProcessRenderContext context)
	{
		((Object)rt).name = "Temporal Anti-aliasing History id #" + id;
		if (context.stereoActive)
		{
			((Object)rt).name = ((Object)rt).name + " for eye " + context.xrActiveEye;
		}
	}

	private RenderTexture CheckHistory(int id, PostProcessRenderContext context)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		int xrActiveEye = context.xrActiveEye;
		if (m_HistoryTextures[xrActiveEye] == null)
		{
			m_HistoryTextures[xrActiveEye] = (RenderTexture[])(object)new RenderTexture[2];
		}
		RenderTexture val = m_HistoryTextures[xrActiveEye][id];
		if (m_ResetHistory || (Object)(object)val == (Object)null || !val.IsCreated())
		{
			RenderTexture.ReleaseTemporary(val);
			val = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat, (RenderTextureReadWrite)0);
			GenerateHistoryName(val, id, context);
			((Texture)val).filterMode = (FilterMode)1;
			m_HistoryTextures[xrActiveEye][id] = val;
			context.command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)val), clear: false, null);
		}
		else if (((Texture)val).width != context.width || ((Texture)val).height != context.height)
		{
			RenderTexture screenSpaceTemporaryRT = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat, (RenderTextureReadWrite)0);
			GenerateHistoryName(screenSpaceTemporaryRT, id, context);
			((Texture)screenSpaceTemporaryRT).filterMode = (FilterMode)1;
			m_HistoryTextures[xrActiveEye][id] = screenSpaceTemporaryRT;
			context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((Texture)(object)val), RenderTargetIdentifier.op_Implicit((Texture)(object)screenSpaceTemporaryRT), clear: false, null);
			RenderTexture.ReleaseTemporary(val);
		}
		return m_HistoryTextures[xrActiveEye][id];
	}

	internal void Render(PostProcessRenderContext context)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.temporalAntialiasing);
		CommandBuffer command = context.command;
		command.BeginSample("TemporalAntialiasing");
		int num = m_HistoryPingPong[context.xrActiveEye];
		RenderTexture val = CheckHistory(++num % 2, context);
		RenderTexture val2 = CheckHistory(++num % 2, context);
		m_HistoryPingPong[context.xrActiveEye] = ++num % 2;
		propertySheet.properties.SetVector(ShaderIDs.Jitter, Vector4.op_Implicit(jitter));
		propertySheet.properties.SetFloat(ShaderIDs.Sharpness, sharpness);
		propertySheet.properties.SetVector(ShaderIDs.FinalBlendParameters, new Vector4(stationaryBlending, motionBlending, 6000f, 0f));
		propertySheet.properties.SetTexture(ShaderIDs.HistoryTex, (Texture)(object)val);
		int pass = (context.camera.orthographic ? 1 : 0);
		m_Mrt[0] = context.destination;
		m_Mrt[1] = RenderTargetIdentifier.op_Implicit((Texture)(object)val2);
		command.BlitFullscreenTriangle(context.source, m_Mrt, context.source, propertySheet, pass, clear: false, null);
		command.EndSample("TemporalAntialiasing");
		m_ResetHistory = false;
	}

	internal void Release()
	{
		if (m_HistoryTextures != null)
		{
			for (int i = 0; i < m_HistoryTextures.Length; i++)
			{
				if (m_HistoryTextures[i] != null)
				{
					for (int j = 0; j < m_HistoryTextures[i].Length; j++)
					{
						RenderTexture.ReleaseTemporary(m_HistoryTextures[i][j]);
						m_HistoryTextures[i][j] = null;
					}
					m_HistoryTextures[i] = null;
				}
			}
		}
		sampleIndex = 0;
		m_HistoryPingPong[0] = 0;
		m_HistoryPingPong[1] = 0;
		ResetHistory();
	}
}


private enum Pass
{
	SolverDilate,
	SolverNoDilate
}


public enum VignetteMode
{
	Classic,
	Masked
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class VignetteModeParameter : ParameterOverride<VignetteMode>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(VignetteRenderer), "Unity/Vignette", true)]
public sealed class Vignette : PostProcessEffectSettings
{
	[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
	public VignetteModeParameter mode = new VignetteModeParameter
	{
		value = VignetteMode.Classic
	};

	[Tooltip("Vignette color.")]
	public ColorParameter color = new ColorParameter
	{
		value = new Color(0f, 0f, 0f, 1f)
	};

	[Tooltip("Sets the vignette center point (screen center is [0.5, 0.5]).")]
	public Vector2Parameter center = new Vector2Parameter
	{
		value = new Vector2(0.5f, 0.5f)
	};

	[Tooltip("Amount of vignetting on screen.")]
	[Range(0f, 1f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Tooltip("Smoothness of the vignette borders.")]
	[Range(0.01f, 1f)]
	public FloatParameter smoothness = new FloatParameter
	{
		value = 0.2f
	};

	[Range(0f, 1f)]
	[Tooltip("Lower values will make a square-ish vignette.")]
	public FloatParameter roundness = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Set to true to mark the vignette to be perfectly round. False will make its shape dependent on the current aspect ratio.")]
	public BoolParameter rounded = new BoolParameter
	{
		value = false
	};

	[Tooltip("A black and white mask to use as a vignette.")]
	public TextureParameter mask = new TextureParameter
	{
		value = null
	};

	[Range(0f, 1f)]
	[Tooltip("Mask opacity.")]
	public FloatParameter opacity = new FloatParameter
	{
		value = 1f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value)
		{
			if (mode.value != 0 || !(intensity.value > 0f))
			{
				if (mode.value == VignetteMode.Masked && opacity.value > 0f)
				{
					return (Object)(object)mask.value != (Object)null;
				}
				return false;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class VignetteRenderer : PostProcessEffectRenderer<Vignette>
{
	public override void Render(PostProcessRenderContext context)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.EnableKeyword("VIGNETTE");
		uberSheet.properties.SetColor(ShaderIDs.Vignette_Color, base.settings.color.value);
		if ((VignetteMode)base.settings.mode == VignetteMode.Classic)
		{
			uberSheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 0f);
			uberSheet.properties.SetVector(ShaderIDs.Vignette_Center, Vector4.op_Implicit(base.settings.center.value));
			float num = (1f - base.settings.roundness.value) * 6f + base.settings.roundness.value;
			uberSheet.properties.SetVector(ShaderIDs.Vignette_Settings, new Vector4(base.settings.intensity.value * 3f, base.settings.smoothness.value * 5f, num, base.settings.rounded.value ? 1f : 0f));
		}
		else
		{
			uberSheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 1f);
			uberSheet.properties.SetTexture(ShaderIDs.Vignette_Mask, base.settings.mask.value);
			uberSheet.properties.SetFloat(ShaderIDs.Vignette_Opacity, Mathf.Clamp01(base.settings.opacity.value));
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class HistogramMonitor : Monitor
{
	public enum Channel
	{
		Red,
		Green,
		Blue,
		Master
	}

	public int width = 512;

	public int height = 256;

	public Channel channel = Channel.Master;

	private ComputeBuffer m_Data;

	private const int k_NumBins = 256;

	private const int k_ThreadGroupSizeX = 16;

	private const int k_ThreadGroupSizeY = 16;

	internal override void OnDisable()
	{
		base.OnDisable();
		if (m_Data != null)
		{
			m_Data.Release();
		}
		m_Data = null;
	}

	internal override bool NeedsHalfRes()
	{
		return true;
	}

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		return Object.op_Implicit((Object)(object)context.resources.computeShaders.gammaHistogram);
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected O, but got Unknown
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		CheckOutput(width, height);
		if (m_Data == null)
		{
			m_Data = new ComputeBuffer(256, 4);
		}
		ComputeShader gammaHistogram = context.resources.computeShaders.gammaHistogram;
		CommandBuffer command = context.command;
		command.BeginSample("GammaHistogram");
		int num = gammaHistogram.FindKernel("KHistogramClear");
		command.SetComputeBufferParam(gammaHistogram, num, "_HistogramBuffer", m_Data);
		command.DispatchCompute(gammaHistogram, num, Mathf.CeilToInt(16f), 1, 1);
		num = gammaHistogram.FindKernel("KHistogramGather");
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor((float)(context.width / 2), (float)(context.height / 2), (float)(RuntimeUtilities.isLinearColorSpace ? 1 : 0), (float)channel);
		command.SetComputeVectorParam(gammaHistogram, "_Params", val);
		command.SetComputeTextureParam(gammaHistogram, num, "_Source", RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy));
		command.SetComputeBufferParam(gammaHistogram, num, "_HistogramBuffer", m_Data);
		command.DispatchCompute(gammaHistogram, num, Mathf.CeilToInt(val.x / 16f), Mathf.CeilToInt(val.y / 16f), 1);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.gammaHistogram);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)width, (float)height, 0f, 0f));
		propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, m_Data);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("GammaHistogram");
	}
}


public enum Channel
{
	Red,
	Green,
	Blue,
	Master
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class LightMeterMonitor : Monitor
{
	public int width = 512;

	public int height = 256;

	public bool showCurves = true;

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		if (Object.op_Implicit((Object)(object)context.resources.shaders.lightMeter))
		{
			return context.resources.shaders.lightMeter.isSupported;
		}
		return false;
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		CheckOutput(width, height);
		LogHistogram logHistogram = context.logHistogram;
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lightMeter);
		propertySheet.ClearKeywords();
		propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, logHistogram.data);
		Vector4 histogramScaleOffsetRes = logHistogram.GetHistogramScaleOffsetRes(context);
		histogramScaleOffsetRes.z = 1f / (float)width;
		histogramScaleOffsetRes.w = 1f / (float)height;
		propertySheet.properties.SetVector(ShaderIDs.ScaleOffsetRes, histogramScaleOffsetRes);
		if ((Object)(object)context.logLut != (Object)null && showCurves)
		{
			propertySheet.EnableKeyword("COLOR_GRADING_HDR");
			propertySheet.properties.SetTexture(ShaderIDs.Lut3D, context.logLut);
		}
		AutoExposure autoExposure = context.autoExposure;
		if ((Object)(object)autoExposure != (Object)null)
		{
			float x = autoExposure.filtering.value.x;
			float y = autoExposure.filtering.value.y;
			y = Mathf.Clamp(y, 1.01f, 99f);
			x = Mathf.Clamp(x, 1f, y - 0.01f);
			Vector4 val = default(Vector4);
			((Vector4)(ref val))..ctor(x * 0.01f, y * 0.01f, RuntimeUtilities.Exp2(autoExposure.minLuminance.value), RuntimeUtilities.Exp2(autoExposure.maxLuminance.value));
			propertySheet.EnableKeyword("AUTO_EXPOSURE");
			propertySheet.properties.SetVector(ShaderIDs.Params, val);
		}
		CommandBuffer command = context.command;
		command.BeginSample("LightMeter");
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("LightMeter");
	}
}


public enum MonitorType
{
	LightMeter,
	Histogram,
	Waveform,
	Vectorscope
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class Monitor
{
	internal bool requested;

	public RenderTexture output { get; protected set; }

	public bool IsRequestedAndSupported(PostProcessRenderContext context)
	{
		if (requested && SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL)
		{
			return ShaderResourcesAvailable(context);
		}
		return false;
	}

	internal abstract bool ShaderResourcesAvailable(PostProcessRenderContext context);

	internal virtual bool NeedsHalfRes()
	{
		return false;
	}

	protected void CheckOutput(int width, int height)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Expected O, but got Unknown
		if ((Object)(object)output == (Object)null || !output.IsCreated() || ((Texture)output).width != width || ((Texture)output).height != height)
		{
			RuntimeUtilities.Destroy((Object)(object)output);
			output = new RenderTexture(width, height, 0, (RenderTextureFormat)0)
			{
				anisoLevel = 0,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				useMipMap = false
			};
		}
	}

	internal virtual void OnEnable()
	{
	}

	internal virtual void OnDisable()
	{
		RuntimeUtilities.Destroy((Object)(object)output);
	}

	internal abstract void Render(PostProcessRenderContext context);
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class VectorscopeMonitor : Monitor
{
	public int size = 256;

	public float exposure = 0.12f;

	private ComputeBuffer m_Data;

	private const int k_ThreadGroupSizeX = 16;

	private const int k_ThreadGroupSizeY = 16;

	internal override void OnDisable()
	{
		base.OnDisable();
		if (m_Data != null)
		{
			m_Data.Release();
		}
		m_Data = null;
	}

	internal override bool NeedsHalfRes()
	{
		return true;
	}

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		return Object.op_Implicit((Object)(object)context.resources.computeShaders.vectorscope);
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Expected O, but got Unknown
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		CheckOutput(size, size);
		exposure = Mathf.Max(0f, exposure);
		int num = size * size;
		if (m_Data == null)
		{
			m_Data = new ComputeBuffer(num, 4);
		}
		else if (m_Data.count != num)
		{
			m_Data.Release();
			m_Data = new ComputeBuffer(num, 4);
		}
		ComputeShader vectorscope = context.resources.computeShaders.vectorscope;
		CommandBuffer command = context.command;
		command.BeginSample("Vectorscope");
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor((float)(context.width / 2), (float)(context.height / 2), (float)size, (float)(RuntimeUtilities.isLinearColorSpace ? 1 : 0));
		int num2 = vectorscope.FindKernel("KVectorscopeClear");
		command.SetComputeBufferParam(vectorscope, num2, "_VectorscopeBuffer", m_Data);
		command.SetComputeVectorParam(vectorscope, "_Params", val);
		command.DispatchCompute(vectorscope, num2, Mathf.CeilToInt((float)size / 16f), Mathf.CeilToInt((float)size / 16f), 1);
		num2 = vectorscope.FindKernel("KVectorscopeGather");
		command.SetComputeBufferParam(vectorscope, num2, "_VectorscopeBuffer", m_Data);
		command.SetComputeTextureParam(vectorscope, num2, "_Source", RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy));
		command.DispatchCompute(vectorscope, num2, Mathf.CeilToInt(val.x / 16f), Mathf.CeilToInt(val.y / 16f), 1);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.vectorscope);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)size, (float)size, exposure, 0f));
		propertySheet.properties.SetBuffer(ShaderIDs.VectorscopeBuffer, m_Data);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("Vectorscope");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class WaveformMonitor : Monitor
{
	public float exposure = 0.12f;

	public int height = 256;

	private ComputeBuffer m_Data;

	private const int k_ThreadGroupSize = 256;

	private const int k_ThreadGroupSizeX = 16;

	private const int k_ThreadGroupSizeY = 16;

	internal override void OnDisable()
	{
		base.OnDisable();
		if (m_Data != null)
		{
			m_Data.Release();
		}
		m_Data = null;
	}

	internal override bool NeedsHalfRes()
	{
		return true;
	}

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		return Object.op_Implicit((Object)(object)context.resources.computeShaders.waveform);
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Expected O, but got Unknown
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Expected O, but got Unknown
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)context.width / 2f / ((float)context.height / 2f);
		int num2 = Mathf.FloorToInt((float)height * num);
		CheckOutput(num2, height);
		exposure = Mathf.Max(0f, exposure);
		int num3 = num2 * height;
		if (m_Data == null)
		{
			m_Data = new ComputeBuffer(num3, 16);
		}
		else if (m_Data.count < num3)
		{
			m_Data.Release();
			m_Data = new ComputeBuffer(num3, 16);
		}
		ComputeShader waveform = context.resources.computeShaders.waveform;
		CommandBuffer command = context.command;
		command.BeginSample("Waveform");
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor((float)num2, (float)height, (float)(RuntimeUtilities.isLinearColorSpace ? 1 : 0), 0f);
		int num4 = waveform.FindKernel("KWaveformClear");
		command.SetComputeBufferParam(waveform, num4, "_WaveformBuffer", m_Data);
		command.SetComputeVectorParam(waveform, "_Params", val);
		command.DispatchCompute(waveform, num4, Mathf.CeilToInt((float)num2 / 16f), Mathf.CeilToInt((float)height / 16f), 1);
		command.GetTemporaryRT(ShaderIDs.WaveformSource, num2, height, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy), RenderTargetIdentifier.op_Implicit(ShaderIDs.WaveformSource), clear: false, null);
		num4 = waveform.FindKernel("KWaveformGather");
		command.SetComputeBufferParam(waveform, num4, "_WaveformBuffer", m_Data);
		command.SetComputeTextureParam(waveform, num4, "_Source", RenderTargetIdentifier.op_Implicit(ShaderIDs.WaveformSource));
		command.SetComputeVectorParam(waveform, "_Params", val);
		command.DispatchCompute(waveform, num4, num2, Mathf.CeilToInt((float)height / 256f), 1);
		command.ReleaseTemporaryRT(ShaderIDs.WaveformSource);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.waveform);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)num2, (float)height, exposure, 0f));
		propertySheet.properties.SetBuffer(ShaderIDs.WaveformBuffer, m_Data);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("Waveform");
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public abstract class ParameterOverride
{
	public bool overrideState;

	internal abstract void Interp(ParameterOverride from, ParameterOverride to, float t);

	public abstract int GetHash();

	public T GetValue<T>()
	{
		return ((ParameterOverride<T>)this).value;
	}

	protected internal virtual void OnEnable()
	{
	}

	protected internal virtual void OnDisable()
	{
	}

	internal abstract void SetValue(ParameterOverride parameter);
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class ParameterOverride<T> : ParameterOverride
{
	public T value;

	public ParameterOverride()
		: this(default(T), overrideState: false)
	{
	}

	public ParameterOverride(T value)
		: this(value, overrideState: false)
	{
	}

	public ParameterOverride(T value, bool overrideState)
	{
		this.value = value;
		base.overrideState = overrideState;
	}

	internal override void Interp(ParameterOverride from, ParameterOverride to, float t)
	{
		Interp(from.GetValue<T>(), to.GetValue<T>(), t);
	}

	public virtual void Interp(T from, T to, float t)
	{
		value = ((t > 0f) ? to : from);
	}

	public void Override(T x)
	{
		overrideState = true;
		value = x;
	}

	internal override void SetValue(ParameterOverride parameter)
	{
		value = parameter.GetValue<T>();
	}

	public override int GetHash()
	{
		return (17 * 23 + overrideState.GetHashCode()) * 23 + value.GetHashCode();
	}

	public static implicit operator T(ParameterOverride<T> prop)
	{
		return prop.value;
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class FloatParameter : ParameterOverride<float>
{
	public override void Interp(float from, float to, float t)
	{
		value = from + (to - from) * t;
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class IntParameter : ParameterOverride<int>
{
	public override void Interp(int from, int to, float t)
	{
		value = (int)((float)from + (float)(to - from) * t);
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BoolParameter : ParameterOverride<bool>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ColorParameter : ParameterOverride<Color>
{
	public override void Interp(Color from, Color to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		value.r = from.r + (to.r - from.r) * t;
		value.g = from.g + (to.g - from.g) * t;
		value.b = from.b + (to.b - from.b) * t;
		value.a = from.a + (to.a - from.a) * t;
	}

	public static implicit operator Vector4(ColorParameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Color.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class Vector2Parameter : ParameterOverride<Vector2>
{
	public override void Interp(Vector2 from, Vector2 to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		value.x = from.x + (to.x - from.x) * t;
		value.y = from.y + (to.y - from.y) * t;
	}

	public static implicit operator Vector3(Vector2Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(prop.value);
	}

	public static implicit operator Vector4(Vector2Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class Vector3Parameter : ParameterOverride<Vector3>
{
	public override void Interp(Vector3 from, Vector3 to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		value.x = from.x + (to.x - from.x) * t;
		value.y = from.y + (to.y - from.y) * t;
		value.z = from.z + (to.z - from.z) * t;
	}

	public static implicit operator Vector2(Vector3Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(prop.value);
	}

	public static implicit operator Vector4(Vector3Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class Vector4Parameter : ParameterOverride<Vector4>
{
	public override void Interp(Vector4 from, Vector4 to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		value.x = from.x + (to.x - from.x) * t;
		value.y = from.y + (to.y - from.y) * t;
		value.z = from.z + (to.z - from.z) * t;
		value.w = from.w + (to.w - from.w) * t;
	}

	public static implicit operator Vector2(Vector4Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}

	public static implicit operator Vector3(Vector4Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class SplineParameter : ParameterOverride<Spline>
{
	protected internal override void OnEnable()
	{
		if (value != null)
		{
			value.Cache(int.MinValue);
		}
	}

	internal override void SetValue(ParameterOverride parameter)
	{
		base.SetValue(parameter);
		if (value != null)
		{
			value.Cache(Time.renderedFrameCount);
		}
	}

	public override void Interp(Spline from, Spline to, float t)
	{
		if (from == null || to == null)
		{
			base.Interp(from, to, t);
			return;
		}
		int renderedFrameCount = Time.renderedFrameCount;
		from.Cache(renderedFrameCount);
		to.Cache(renderedFrameCount);
		for (int i = 0; i < 128; i++)
		{
			float num = from.cachedData[i];
			float num2 = to.cachedData[i];
			value.cachedData[i] = num + (num2 - num) * t;
		}
	}
}


public enum TextureParameterDefault
{
	None,
	Black,
	White,
	Transparent,
	Lut2D
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class TextureParameter : ParameterOverride<Texture>
{
	public TextureParameterDefault defaultState = TextureParameterDefault.Black;

	public override void Interp(Texture from, Texture to, float t)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)from == (Object)null && (Object)(object)to == (Object)null)
		{
			value = null;
			return;
		}
		if ((Object)(object)from != (Object)null && (Object)(object)to != (Object)null)
		{
			value = TextureLerper.instance.Lerp(from, to, t);
			return;
		}
		if (defaultState == TextureParameterDefault.Lut2D)
		{
			Texture lutStrip = (Texture)(object)RuntimeUtilities.GetLutStrip(((Object)(object)from != (Object)null) ? from.height : to.height);
			if ((Object)(object)from == (Object)null)
			{
				from = lutStrip;
			}
			if ((Object)(object)to == (Object)null)
			{
				to = lutStrip;
			}
		}
		Color to2;
		switch (defaultState)
		{
		case TextureParameterDefault.Black:
			to2 = Color.black;
			break;
		case TextureParameterDefault.White:
			to2 = Color.white;
			break;
		case TextureParameterDefault.Transparent:
			to2 = Color.clear;
			break;
		case TextureParameterDefault.Lut2D:
		{
			Texture lutStrip2 = (Texture)(object)RuntimeUtilities.GetLutStrip(((Object)(object)from != (Object)null) ? from.height : to.height);
			if ((Object)(object)from == (Object)null)
			{
				from = lutStrip2;
			}
			if ((Object)(object)to == (Object)null)
			{
				to = lutStrip2;
			}
			if (from.width != to.width || from.height != to.height)
			{
				value = null;
			}
			else
			{
				value = TextureLerper.instance.Lerp(from, to, t);
			}
			return;
		}
		default:
			base.Interp(from, to, t);
			return;
		}
		if ((Object)(object)from == (Object)null)
		{
			value = TextureLerper.instance.Lerp(to, to2, 1f - t);
		}
		else
		{
			value = TextureLerper.instance.Lerp(from, to2, t);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessBundle
{
	private PostProcessEffectRenderer m_Renderer;

	public PostProcessAttribute attribute { get; private set; }

	public PostProcessEffectSettings settings { get; private set; }

	internal PostProcessEffectRenderer renderer
	{
		get
		{
			if (m_Renderer == null)
			{
				Assert.IsNotNull<Type>(attribute.renderer);
				Type type = attribute.renderer;
				m_Renderer = (PostProcessEffectRenderer)Activator.CreateInstance(type);
				m_Renderer.SetSettings(settings);
				m_Renderer.Init();
			}
			return m_Renderer;
		}
	}

	internal PostProcessBundle(PostProcessEffectSettings settings)
	{
		Assert.IsNotNull<PostProcessEffectSettings>(settings);
		this.settings = settings;
		attribute = ((object)settings).GetType().GetAttribute<PostProcessAttribute>();
	}

	internal void Release()
	{
		if (m_Renderer != null)
		{
			m_Renderer.Release();
		}
		RuntimeUtilities.Destroy((Object)(object)settings);
	}

	internal void ResetHistory()
	{
		if (m_Renderer != null)
		{
			m_Renderer.ResetHistory();
		}
	}

	internal T CastSettings<T>() where T : PostProcessEffectSettings
	{
		return (T)settings;
	}

	internal T CastRenderer<T>() where T : PostProcessEffectRenderer
	{
		return (T)renderer;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[AddComponentMenu("Rendering/Post-process Debug", 1002)]
[ExecuteAlways]
public sealed class PostProcessDebug : MonoBehaviour
{
	public PostProcessLayer postProcessLayer;

	private PostProcessLayer m_PreviousPostProcessLayer;

	public bool lightMeter;

	public bool histogram;

	public bool waveform;

	public bool vectorscope;

	public DebugOverlay debugOverlay;

	private Camera m_CurrentCamera;

	private CommandBuffer m_CmdAfterEverything;

	private void OnEnable()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		m_CmdAfterEverything = new CommandBuffer
		{
			name = "Post-processing Debug Overlay"
		};
	}

	private void OnDisable()
	{
		if ((Object)(object)m_CurrentCamera != (Object)null)
		{
			m_CurrentCamera.RemoveCommandBuffer((CameraEvent)19, m_CmdAfterEverything);
		}
		m_CurrentCamera = null;
		m_PreviousPostProcessLayer = null;
	}

	private void Update()
	{
		UpdateStates();
	}

	private void Reset()
	{
		postProcessLayer = ((Component)this).GetComponent<PostProcessLayer>();
	}

	private void UpdateStates()
	{
		if ((Object)(object)m_PreviousPostProcessLayer != (Object)(object)postProcessLayer)
		{
			if ((Object)(object)m_CurrentCamera != (Object)null)
			{
				m_CurrentCamera.RemoveCommandBuffer((CameraEvent)19, m_CmdAfterEverything);
				m_CurrentCamera = null;
			}
			m_PreviousPostProcessLayer = postProcessLayer;
			if ((Object)(object)postProcessLayer != (Object)null)
			{
				m_CurrentCamera = ((Component)postProcessLayer).GetComponent<Camera>();
				m_CurrentCamera.AddCommandBuffer((CameraEvent)19, m_CmdAfterEverything);
			}
		}
		if (!((Object)(object)postProcessLayer == (Object)null) && ((Behaviour)postProcessLayer).enabled)
		{
			if (lightMeter)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.LightMeter);
			}
			if (histogram)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Histogram);
			}
			if (waveform)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Waveform);
			}
			if (vectorscope)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Vectorscope);
			}
			postProcessLayer.debugLayer.RequestDebugOverlay(debugOverlay);
		}
	}

	private void OnPostRender()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		m_CmdAfterEverything.Clear();
		if (!((Object)(object)postProcessLayer == (Object)null) && ((Behaviour)postProcessLayer).enabled && postProcessLayer.debugLayer.debugOverlayActive)
		{
			m_CmdAfterEverything.Blit((Texture)(object)postProcessLayer.debugLayer.debugOverlayTarget, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2));
		}
	}

	private void OnGUI()
	{
		if (!((Object)(object)postProcessLayer == (Object)null) && ((Behaviour)postProcessLayer).enabled)
		{
			RenderTexture.active = null;
			Rect rect = default(Rect);
			((Rect)(ref rect))..ctor(5f, 5f, 0f, 0f);
			PostProcessDebugLayer debugLayer = postProcessLayer.debugLayer;
			DrawMonitor(ref rect, debugLayer.lightMeter, lightMeter);
			DrawMonitor(ref rect, debugLayer.histogram, histogram);
			DrawMonitor(ref rect, debugLayer.waveform, waveform);
			DrawMonitor(ref rect, debugLayer.vectorscope, vectorscope);
		}
	}

	private void DrawMonitor(ref Rect rect, Monitor monitor, bool enabled)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (enabled && !((Object)(object)monitor.output == (Object)null))
		{
			((Rect)(ref rect)).width = ((Texture)monitor.output).width;
			((Rect)(ref rect)).height = ((Texture)monitor.output).height;
			GUI.DrawTexture(rect, (Texture)(object)monitor.output);
			((Rect)(ref rect)).x = ((Rect)(ref rect)).x + ((float)((Texture)monitor.output).width + 5f);
		}
	}
}


public enum DebugOverlay
{
	None,
	Depth,
	Normals,
	MotionVectors,
	NANTracker,
	ColorBlindnessSimulation,
	_,
	AmbientOcclusion,
	BloomBuffer,
	BloomThreshold,
	DepthOfField
}


public enum ColorBlindnessType
{
	Deuteranopia,
	Protanopia,
	Tritanopia
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class PostProcessDebugLayer
{
	[Serializable]
	public class OverlaySettings
	{
		public bool linearDepth;

		[Range(0f, 16f)]
		public float motionColorIntensity = 4f;

		[Range(4f, 128f)]
		public int motionGridSize = 64;

		public ColorBlindnessType colorBlindnessType;

		[Range(0f, 1f)]
		public float colorBlindnessStrength = 1f;
	}

	public LightMeterMonitor lightMeter;

	public HistogramMonitor histogram;

	public WaveformMonitor waveform;

	public VectorscopeMonitor vectorscope;

	private Dictionary<MonitorType, Monitor> m_Monitors;

	private int frameWidth;

	private int frameHeight;

	public OverlaySettings overlaySettings;

	public RenderTexture debugOverlayTarget { get; private set; }

	public bool debugOverlayActive { get; private set; }

	public DebugOverlay debugOverlay { get; private set; }

	internal void OnEnable()
	{
		RuntimeUtilities.CreateIfNull(ref lightMeter);
		RuntimeUtilities.CreateIfNull(ref histogram);
		RuntimeUtilities.CreateIfNull(ref waveform);
		RuntimeUtilities.CreateIfNull(ref vectorscope);
		RuntimeUtilities.CreateIfNull(ref overlaySettings);
		m_Monitors = new Dictionary<MonitorType, Monitor>
		{
			{
				MonitorType.LightMeter,
				lightMeter
			},
			{
				MonitorType.Histogram,
				histogram
			},
			{
				MonitorType.Waveform,
				waveform
			},
			{
				MonitorType.Vectorscope,
				vectorscope
			}
		};
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			monitor.Value.OnEnable();
		}
	}

	internal void OnDisable()
	{
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			monitor.Value.OnDisable();
		}
		DestroyDebugOverlayTarget();
	}

	private void DestroyDebugOverlayTarget()
	{
		RuntimeUtilities.Destroy((Object)(object)debugOverlayTarget);
		debugOverlayTarget = null;
	}

	public void RequestMonitorPass(MonitorType monitor)
	{
		m_Monitors[monitor].requested = true;
	}

	public void RequestDebugOverlay(DebugOverlay mode)
	{
		debugOverlay = mode;
	}

	internal void SetFrameSize(int width, int height)
	{
		frameWidth = width;
		frameHeight = height;
		debugOverlayActive = false;
	}

	public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Expected O, but got Unknown
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)debugOverlayTarget == (Object)null || !debugOverlayTarget.IsCreated() || ((Texture)debugOverlayTarget).width != frameWidth || ((Texture)debugOverlayTarget).height != frameHeight)
		{
			RuntimeUtilities.Destroy((Object)(object)debugOverlayTarget);
			debugOverlayTarget = new RenderTexture(frameWidth, frameHeight, 0, (RenderTextureFormat)0)
			{
				name = "Debug Overlay Target",
				anisoLevel = 1,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				hideFlags = (HideFlags)61
			};
			debugOverlayTarget.Create();
		}
		cmd.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit((Texture)(object)debugOverlayTarget), sheet, pass, clear: false, null);
		debugOverlayActive = true;
	}

	internal DepthTextureMode GetCameraFlags()
	{
		if (debugOverlay != DebugOverlay.Depth)
		{
			if (debugOverlay != DebugOverlay.Normals)
			{
				if (debugOverlay != DebugOverlay.MotionVectors)
				{
					return (DepthTextureMode)0;
				}
				return (DepthTextureMode)5;
			}
			return (DepthTextureMode)2;
		}
		return (DepthTextureMode)1;
	}

	internal void RenderMonitors(PostProcessRenderContext context)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		bool flag2 = false;
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			bool flag3 = monitor.Value.IsRequestedAndSupported(context);
			flag = flag || flag3;
			flag2 |= flag3 && monitor.Value.NeedsHalfRes();
		}
		if (!flag)
		{
			return;
		}
		CommandBuffer command = context.command;
		command.BeginSample("Monitors");
		if (flag2)
		{
			command.GetTemporaryRT(ShaderIDs.HalfResFinalCopy, context.width / 2, context.height / 2, 0, (FilterMode)1, context.sourceFormat);
			command.Blit(context.destination, RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy));
		}
		foreach (KeyValuePair<MonitorType, Monitor> monitor2 in m_Monitors)
		{
			Monitor value = monitor2.Value;
			if (value.requested)
			{
				value.Render(context);
			}
		}
		if (flag2)
		{
			command.ReleaseTemporaryRT(ShaderIDs.HalfResFinalCopy);
		}
		command.EndSample("Monitors");
	}

	internal void RenderSpecialOverlays(PostProcessRenderContext context)
	{
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Invalid comparison between Unknown and I4
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		if (debugOverlay == DebugOverlay.Depth)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.linearDepth ? 1f : 0f, 0f, 0f, 0f));
			PushDebugOverlay(context.command, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet, 0);
		}
		else if (debugOverlay == DebugOverlay.Normals)
		{
			PropertySheet propertySheet2 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet2.ClearKeywords();
			if ((int)context.camera.actualRenderingPath == 2)
			{
				propertySheet2.EnableKeyword("SOURCE_GBUFFER");
			}
			PushDebugOverlay(context.command, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet2, 1);
		}
		else if (debugOverlay == DebugOverlay.MotionVectors)
		{
			PropertySheet propertySheet3 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet3.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.motionColorIntensity, (float)overlaySettings.motionGridSize, 0f, 0f));
			PushDebugOverlay(context.command, context.source, propertySheet3, 2);
		}
		else if (debugOverlay == DebugOverlay.NANTracker)
		{
			PropertySheet sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			PushDebugOverlay(context.command, context.source, sheet, 3);
		}
		else if (debugOverlay == DebugOverlay.ColorBlindnessSimulation)
		{
			PropertySheet propertySheet4 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet4.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.colorBlindnessStrength, 0f, 0f, 0f));
			PushDebugOverlay(context.command, context.source, propertySheet4, (int)(4 + overlaySettings.colorBlindnessType));
		}
	}

	internal void EndFrame()
	{
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			monitor.Value.requested = false;
		}
		if (!debugOverlayActive)
		{
			DestroyDebugOverlayTarget();
		}
		debugOverlay = DebugOverlay.None;
	}
}


using System;

[Serializable]
public class OverlaySettings
{
	public bool linearDepth;

	[Range(0f, 16f)]
	public float motionColorIntensity = 4f;

	[Range(4f, 128f)]
	public int motionGridSize = 64;

	public ColorBlindnessType colorBlindnessType;

	[Range(0f, 1f)]
	public float colorBlindnessStrength = 1f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class PostProcessEffectRenderer
{
	protected bool m_ResetHistory = true;

	public virtual void Init()
	{
	}

	public virtual DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)0;
	}

	public virtual void ResetHistory()
	{
		m_ResetHistory = true;
	}

	public virtual void Release()
	{
		ResetHistory();
	}

	public abstract void Render(PostProcessRenderContext context);

	internal abstract void SetSettings(PostProcessEffectSettings settings);
}


using UnityEngine.Rendering.PostProcessing;

public abstract class PostProcessEffectRenderer<T> : PostProcessEffectRenderer where T : PostProcessEffectSettings
{
	public T settings { get; internal set; }

	internal override void SetSettings(PostProcessEffectSettings settings)
	{
		this.settings = (T)settings;
	}
}


using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class PostProcessEffectSettings : ScriptableObject
{
	public bool active = true;

	public BoolParameter enabled = new BoolParameter
	{
		overrideState = true,
		value = false
	};

	internal ReadOnlyCollection<ParameterOverride> parameters;

	private void OnEnable()
	{
		parameters = (from t in ((object)this).GetType().GetFields(BindingFlags.Instance | BindingFlags.Public)
			where t.FieldType.IsSubclassOf(typeof(ParameterOverride))
			orderby t.MetadataToken
			select (ParameterOverride)t.GetValue(this)).ToList().AsReadOnly();
		foreach (ParameterOverride parameter in parameters)
		{
			parameter.OnEnable();
		}
	}

	private void OnDisable()
	{
		if (parameters == null)
		{
			return;
		}
		foreach (ParameterOverride parameter in parameters)
		{
			parameter.OnDisable();
		}
	}

	public void SetAllOverridesTo(bool state, bool excludeEnabled = true)
	{
		foreach (ParameterOverride parameter in parameters)
		{
			if (!excludeEnabled || parameter != enabled)
			{
				parameter.overrideState = state;
			}
		}
	}

	public virtual bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		return enabled.value;
	}

	public int GetHash()
	{
		int num = 17;
		foreach (ParameterOverride parameter in parameters)
		{
			num = num * 23 + parameter.GetHash();
		}
		return num;
	}
}


public enum PostProcessEvent
{
	BeforeTransparent,
	BeforeStack,
	AfterStack
}


using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.Rendering.PostProcessing;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct PostProcessEventComparer : IEqualityComparer<PostProcessEvent>
{
	public bool Equals(PostProcessEvent x, PostProcessEvent y)
	{
		return x == y;
	}

	public int GetHashCode(PostProcessEvent obj)
	{
		return (int)obj;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessManager
{
	private static PostProcessManager s_Instance;

	private const int k_MaxLayerCount = 32;

	private readonly Dictionary<int, List<PostProcessVolume>> m_SortedVolumes;

	private readonly List<PostProcessVolume> m_Volumes;

	private readonly Dictionary<int, bool> m_SortNeeded;

	private readonly List<PostProcessEffectSettings> m_BaseSettings;

	public readonly Dictionary<Type, PostProcessAttribute> settingsTypes;

	public static PostProcessManager instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = new PostProcessManager();
			}
			return s_Instance;
		}
	}

	private PostProcessManager()
	{
		m_SortedVolumes = new Dictionary<int, List<PostProcessVolume>>();
		m_Volumes = new List<PostProcessVolume>();
		m_SortNeeded = new Dictionary<int, bool>();
		m_BaseSettings = new List<PostProcessEffectSettings>();
		settingsTypes = new Dictionary<Type, PostProcessAttribute>();
		ReloadBaseTypes();
	}

	private void CleanBaseTypes()
	{
		settingsTypes.Clear();
		foreach (PostProcessEffectSettings baseSetting in m_BaseSettings)
		{
			RuntimeUtilities.Destroy((Object)(object)baseSetting);
		}
		m_BaseSettings.Clear();
	}

	private void ReloadBaseTypes()
	{
		CleanBaseTypes();
		foreach (Type item in from t in RuntimeUtilities.GetAllAssemblyTypes()
			where t.IsSubclassOf(typeof(PostProcessEffectSettings)) && t.IsDefined(typeof(PostProcessAttribute), inherit: false) && !t.IsAbstract
			select t)
		{
			settingsTypes.Add(item, item.GetAttribute<PostProcessAttribute>());
			PostProcessEffectSettings postProcessEffectSettings = (PostProcessEffectSettings)(object)ScriptableObject.CreateInstance(item);
			postProcessEffectSettings.SetAllOverridesTo(state: true, excludeEnabled: false);
			m_BaseSettings.Add(postProcessEffectSettings);
		}
	}

	public void GetActiveVolumes(PostProcessLayer layer, List<PostProcessVolume> results, bool skipDisabled = true, bool skipZeroWeight = true)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		int value = ((LayerMask)(ref layer.volumeLayer)).value;
		Transform volumeTrigger = layer.volumeTrigger;
		bool flag = (Object)(object)volumeTrigger == (Object)null;
		Vector3 val = (flag ? Vector3.zero : volumeTrigger.position);
		OBB val2 = default(OBB);
		foreach (PostProcessVolume item in GrabVolumes(LayerMask.op_Implicit(value)))
		{
			if ((skipDisabled && !((Behaviour)item).enabled) || (Object)(object)item.profileRef == (Object)null || (skipZeroWeight && item.weight <= 0f))
			{
				continue;
			}
			if (item.isGlobal)
			{
				results.Add(item);
			}
			else if (!flag)
			{
				((OBB)(ref val2))..ctor(((Component)item).transform, item.bounds);
				Vector3 val3 = (((OBB)(ref val2)).ClosestPoint(val) - val) / 2f;
				float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
				float num = item.blendDistance * item.blendDistance;
				if (sqrMagnitude <= num)
				{
					results.Add(item);
				}
			}
		}
	}

	public PostProcessVolume GetHighestPriorityVolume(PostProcessLayer layer)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)layer == (Object)null)
		{
			throw new ArgumentNullException("layer");
		}
		return GetHighestPriorityVolume(layer.volumeLayer);
	}

	public PostProcessVolume GetHighestPriorityVolume(LayerMask mask)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		float num = float.NegativeInfinity;
		PostProcessVolume result = null;
		if (m_SortedVolumes.TryGetValue(LayerMask.op_Implicit(mask), out var value))
		{
			foreach (PostProcessVolume item in value)
			{
				if (item.priority > num)
				{
					num = item.priority;
					result = item;
				}
			}
		}
		return result;
	}

	public PostProcessVolume QuickVolume(int layer, float priority, params PostProcessEffectSettings[] settings)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		PostProcessVolume postProcessVolume = new GameObject
		{
			name = "Quick Volume",
			layer = layer,
			hideFlags = (HideFlags)61
		}.AddComponent<PostProcessVolume>();
		postProcessVolume.priority = priority;
		postProcessVolume.isGlobal = true;
		PostProcessProfile profile = postProcessVolume.profile;
		foreach (PostProcessEffectSettings postProcessEffectSettings in settings)
		{
			Assert.IsNotNull<PostProcessEffectSettings>(postProcessEffectSettings, "Trying to create a volume with null effects");
			profile.AddSettings(postProcessEffectSettings);
		}
		return postProcessVolume;
	}

	internal void SetLayerDirty(int layer)
	{
		Assert.IsTrue(layer >= 0 && layer <= 32, "Invalid layer bit");
		foreach (KeyValuePair<int, List<PostProcessVolume>> sortedVolume in m_SortedVolumes)
		{
			int key = sortedVolume.Key;
			if ((key & (1 << layer)) != 0)
			{
				m_SortNeeded[key] = true;
			}
		}
	}

	internal void UpdateVolumeLayer(PostProcessVolume volume, int prevLayer, int newLayer)
	{
		Assert.IsTrue(prevLayer >= 0 && prevLayer <= 32, "Invalid layer bit");
		Unregister(volume, prevLayer);
		Register(volume, newLayer);
	}

	private void Register(PostProcessVolume volume, int layer)
	{
		m_Volumes.Add(volume);
		foreach (KeyValuePair<int, List<PostProcessVolume>> sortedVolume in m_SortedVolumes)
		{
			if ((sortedVolume.Key & (1 << layer)) != 0)
			{
				sortedVolume.Value.Add(volume);
			}
		}
		SetLayerDirty(layer);
	}

	internal void Register(PostProcessVolume volume)
	{
		int layer = ((Component)volume).gameObject.layer;
		Register(volume, layer);
	}

	private void Unregister(PostProcessVolume volume, int layer)
	{
		m_Volumes.Remove(volume);
		foreach (KeyValuePair<int, List<PostProcessVolume>> sortedVolume in m_SortedVolumes)
		{
			if ((sortedVolume.Key & (1 << layer)) != 0)
			{
				sortedVolume.Value.Remove(volume);
			}
		}
	}

	internal void Unregister(PostProcessVolume volume)
	{
		int layer = ((Component)volume).gameObject.layer;
		Unregister(volume, layer);
	}

	private void ReplaceData(PostProcessLayer postProcessLayer)
	{
		foreach (PostProcessEffectSettings baseSetting in m_BaseSettings)
		{
			PostProcessEffectSettings settings = postProcessLayer.GetBundle(((object)baseSetting).GetType()).settings;
			int count = baseSetting.parameters.Count;
			for (int i = 0; i < count; i++)
			{
				settings.parameters[i].SetValue(baseSetting.parameters[i]);
			}
		}
	}

	internal void UpdateSettings(PostProcessLayer postProcessLayer, Camera camera)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		ReplaceData(postProcessLayer);
		int value = ((LayerMask)(ref postProcessLayer.volumeLayer)).value;
		Transform volumeTrigger = postProcessLayer.volumeTrigger;
		bool flag = (Object)(object)volumeTrigger == (Object)null;
		Vector3 val = (flag ? Vector3.zero : volumeTrigger.position);
		OBB val2 = default(OBB);
		foreach (PostProcessVolume item in GrabVolumes(LayerMask.op_Implicit(value)))
		{
			if (!((Behaviour)item).enabled || (Object)(object)item.profileRef == (Object)null || item.weight <= 0f)
			{
				continue;
			}
			List<PostProcessEffectSettings> settings = item.profileRef.settings;
			if (item.isGlobal)
			{
				postProcessLayer.OverrideSettings(settings, Mathf.Clamp01(item.weight));
			}
			else
			{
				if (flag)
				{
					continue;
				}
				((OBB)(ref val2))..ctor(((Component)item).transform, item.bounds);
				Vector3 val3 = (((OBB)(ref val2)).ClosestPoint(val) - val) / 2f;
				float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
				float num = item.blendDistance * item.blendDistance;
				if (!(sqrMagnitude > num))
				{
					float num2 = 1f;
					if (num > 0f)
					{
						num2 = 1f - sqrMagnitude / num;
					}
					postProcessLayer.OverrideSettings(settings, num2 * Mathf.Clamp01(item.weight));
				}
			}
		}
	}

	private List<PostProcessVolume> GrabVolumes(LayerMask mask)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if (!m_SortedVolumes.TryGetValue(LayerMask.op_Implicit(mask), out var value))
		{
			value = new List<PostProcessVolume>();
			foreach (PostProcessVolume volume in m_Volumes)
			{
				if ((LayerMask.op_Implicit(mask) & (1 << ((Component)volume).gameObject.layer)) != 0)
				{
					value.Add(volume);
					m_SortNeeded[LayerMask.op_Implicit(mask)] = true;
				}
			}
			m_SortedVolumes.Add(LayerMask.op_Implicit(mask), value);
		}
		if (m_SortNeeded.TryGetValue(LayerMask.op_Implicit(mask), out var value2) && value2)
		{
			m_SortNeeded[LayerMask.op_Implicit(mask)] = false;
			SortByPriority(value);
		}
		return value;
	}

	private static void SortByPriority(List<PostProcessVolume> volumes)
	{
		Assert.IsNotNull<List<PostProcessVolume>>(volumes, "Trying to sort volumes of non-initialized layer");
		for (int i = 1; i < volumes.Count; i++)
		{
			PostProcessVolume postProcessVolume = volumes[i];
			int num = i - 1;
			while (num >= 0 && volumes[num].priority > postProcessVolume.priority)
			{
				volumes[num + 1] = volumes[num];
				num--;
			}
			volumes[num + 1] = postProcessVolume;
		}
	}

	private static bool IsVolumeRenderedByCamera(PostProcessVolume volume, Camera camera)
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessProfile : ScriptableObject
{
	[Tooltip("A list of all settings currently stored in this profile.")]
	public List<PostProcessEffectSettings> settings = new List<PostProcessEffectSettings>();

	[NonSerialized]
	public bool isDirty = true;

	private void OnEnable()
	{
		settings.RemoveAll((PostProcessEffectSettings x) => (Object)(object)x == (Object)null);
	}

	public T AddSettings<T>() where T : PostProcessEffectSettings
	{
		return (T)AddSettings(typeof(T));
	}

	public PostProcessEffectSettings AddSettings(Type type)
	{
		if (HasSettings(type))
		{
			throw new InvalidOperationException("Effect already exists in the stack");
		}
		PostProcessEffectSettings postProcessEffectSettings = (PostProcessEffectSettings)(object)ScriptableObject.CreateInstance(type);
		((Object)postProcessEffectSettings).hideFlags = (HideFlags)3;
		((Object)postProcessEffectSettings).name = type.Name;
		postProcessEffectSettings.enabled.value = true;
		settings.Add(postProcessEffectSettings);
		isDirty = true;
		return postProcessEffectSettings;
	}

	public PostProcessEffectSettings AddSettings(PostProcessEffectSettings effect)
	{
		if (HasSettings(settings.GetType()))
		{
			throw new InvalidOperationException("Effect already exists in the stack");
		}
		settings.Add(effect);
		isDirty = true;
		return effect;
	}

	public void RemoveSettings<T>() where T : PostProcessEffectSettings
	{
		RemoveSettings(typeof(T));
	}

	public void RemoveSettings(Type type)
	{
		int num = -1;
		for (int i = 0; i < settings.Count; i++)
		{
			if (((object)settings[i]).GetType() == type)
			{
				num = i;
				break;
			}
		}
		if (num < 0)
		{
			throw new InvalidOperationException("Effect doesn't exist in the profile");
		}
		settings.RemoveAt(num);
		isDirty = true;
	}

	public bool HasSettings<T>() where T : PostProcessEffectSettings
	{
		return HasSettings(typeof(T));
	}

	public bool HasSettings(Type type)
	{
		foreach (PostProcessEffectSettings setting in settings)
		{
			if (((object)setting).GetType() == type)
			{
				return true;
			}
		}
		return false;
	}

	public T GetSetting<T>() where T : PostProcessEffectSettings
	{
		foreach (PostProcessEffectSettings setting in settings)
		{
			if (setting is T)
			{
				return setting as T;
			}
		}
		return null;
	}

	public bool TryGetSettings<T>(out T outSetting) where T : PostProcessEffectSettings
	{
		Type typeFromHandle = typeof(T);
		outSetting = null;
		foreach (PostProcessEffectSettings setting in settings)
		{
			if (((object)setting).GetType() == typeFromHandle)
			{
				outSetting = (T)setting;
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessResources : ScriptableObject
{
	[Serializable]
	public sealed class Shaders
	{
		public Shader bloom;

		public Shader copy;

		public Shader copyStd;

		public Shader copyStdFromTexArray;

		public Shader copyStdFromDoubleWide;

		public Shader discardAlpha;

		public Shader depthOfField;

		public Shader finalPass;

		public Shader grainBaker;

		public Shader motionBlur;

		public Shader temporalAntialiasing;

		public Shader subpixelMorphologicalAntialiasing;

		public Shader texture2dLerp;

		public Shader uber;

		public Shader lut2DBaker;

		public Shader lightMeter;

		public Shader gammaHistogram;

		public Shader waveform;

		public Shader vectorscope;

		public Shader debugOverlays;

		public Shader deferredFog;

		public Shader scalableAO;

		public Shader multiScaleAO;

		public Shader screenSpaceReflections;

		public Shaders Clone()
		{
			return (Shaders)MemberwiseClone();
		}
	}

	[Serializable]
	public sealed class ComputeShaders
	{
		public ComputeShader autoExposure;

		public ComputeShader exposureHistogram;

		public ComputeShader lut3DBaker;

		public ComputeShader texture3dLerp;

		public ComputeShader gammaHistogram;

		public ComputeShader waveform;

		public ComputeShader vectorscope;

		public ComputeShader multiScaleAODownsample1;

		public ComputeShader multiScaleAODownsample2;

		public ComputeShader multiScaleAORender;

		public ComputeShader multiScaleAOUpsample;

		public ComputeShader gaussianDownsample;

		public ComputeShaders Clone()
		{
			return (ComputeShaders)MemberwiseClone();
		}
	}

	[Serializable]
	public sealed class SMAALuts
	{
		public Texture2D area;

		public Texture2D search;
	}

	public Texture2D[] blueNoise64;

	public Texture2D[] blueNoise256;

	public SMAALuts smaaLuts;

	public Shaders shaders;

	public ComputeShaders computeShaders;
}


using System;

[Serializable]
public sealed class Shaders
{
	public Shader bloom;

	public Shader copy;

	public Shader copyStd;

	public Shader copyStdFromTexArray;

	public Shader copyStdFromDoubleWide;

	public Shader discardAlpha;

	public Shader depthOfField;

	public Shader finalPass;

	public Shader grainBaker;

	public Shader motionBlur;

	public Shader temporalAntialiasing;

	public Shader subpixelMorphologicalAntialiasing;

	public Shader texture2dLerp;

	public Shader uber;

	public Shader lut2DBaker;

	public Shader lightMeter;

	public Shader gammaHistogram;

	public Shader waveform;

	public Shader vectorscope;

	public Shader debugOverlays;

	public Shader deferredFog;

	public Shader scalableAO;

	public Shader multiScaleAO;

	public Shader screenSpaceReflections;

	public Shaders Clone()
	{
		return (Shaders)MemberwiseClone();
	}
}


using System;

[Serializable]
public sealed class ComputeShaders
{
	public ComputeShader autoExposure;

	public ComputeShader exposureHistogram;

	public ComputeShader lut3DBaker;

	public ComputeShader texture3dLerp;

	public ComputeShader gammaHistogram;

	public ComputeShader waveform;

	public ComputeShader vectorscope;

	public ComputeShader multiScaleAODownsample1;

	public ComputeShader multiScaleAODownsample2;

	public ComputeShader multiScaleAORender;

	public ComputeShader multiScaleAOUpsample;

	public ComputeShader gaussianDownsample;

	public ComputeShaders Clone()
	{
		return (ComputeShaders)MemberwiseClone();
	}
}


using System;

[Serializable]
public sealed class SMAALuts
{
	public Texture2D area;

	public Texture2D search;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[ExecuteAlways]
[AddComponentMenu("Rendering/Post-process Volume", 1001)]
public sealed class PostProcessVolume : MonoBehaviour
{
	public PostProcessProfile sharedProfile;

	[Tooltip("Check this box to mark this volume as global. This volume's Profile will be applied to the whole Scene.")]
	public bool isGlobal;

	public Bounds bounds;

	[Tooltip("The distance (from the attached Collider) to start blending from. A value of 0 means there will be no blending and the Volume overrides will be applied immediatly upon entry to the attached Collider.")]
	[Min(0f)]
	public float blendDistance;

	[Tooltip("The total weight of this Volume in the Scene. A value of 0 signifies that it will have no effect, 1 signifies full effect.")]
	[Range(0f, 1f)]
	public float weight = 1f;

	[Tooltip("The volume priority in the stack. A higher value means higher priority. Negative values are supported.")]
	public float priority;

	private int m_PreviousLayer;

	private float m_PreviousPriority;

	private PostProcessProfile m_InternalProfile;

	public PostProcessProfile profile
	{
		get
		{
			if ((Object)(object)m_InternalProfile == (Object)null)
			{
				m_InternalProfile = ScriptableObject.CreateInstance<PostProcessProfile>();
				if ((Object)(object)sharedProfile != (Object)null)
				{
					foreach (PostProcessEffectSettings setting in sharedProfile.settings)
					{
						PostProcessEffectSettings item = Object.Instantiate<PostProcessEffectSettings>(setting);
						m_InternalProfile.settings.Add(item);
					}
				}
			}
			return m_InternalProfile;
		}
		set
		{
			m_InternalProfile = value;
		}
	}

	internal PostProcessProfile profileRef
	{
		get
		{
			if (!((Object)(object)m_InternalProfile == (Object)null))
			{
				return m_InternalProfile;
			}
			return sharedProfile;
		}
	}

	public bool HasInstantiatedProfile()
	{
		return (Object)(object)m_InternalProfile != (Object)null;
	}

	private void OnEnable()
	{
		PostProcessManager.instance.Register(this);
		m_PreviousLayer = ((Component)this).gameObject.layer;
	}

	private void OnDisable()
	{
		PostProcessManager.instance.Unregister(this);
	}

	private void Update()
	{
		int layer = ((Component)this).gameObject.layer;
		if (layer != m_PreviousLayer)
		{
			PostProcessManager.instance.UpdateVolumeLayer(this, m_PreviousLayer, layer);
			m_PreviousLayer = layer;
		}
		if (priority != m_PreviousPriority)
		{
			PostProcessManager.instance.SetLayerDirty(layer);
			m_PreviousPriority = priority;
		}
	}

	private void OnDrawGizmos()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (!isGlobal)
		{
			Vector3 lossyScale = ((Component)this).transform.lossyScale;
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z);
			Gizmos.matrix = Matrix4x4.TRS(((Component)this).transform.position, ((Component)this).transform.rotation, lossyScale);
			Gizmos.DrawCube(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size);
			Gizmos.DrawWireCube(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size + val * blendDistance * 4f);
			Gizmos.matrix = Matrix4x4.identity;
		}
	}
}


using UnityEngine;

public static class ColorUtilities
{
	private const float logC_cut = 0.011361f;

	private const float logC_a = 5.555556f;

	private const float logC_b = 0.047996f;

	private const float logC_c = 0.244161f;

	private const float logC_d = 0.386036f;

	private const float logC_e = 5.301883f;

	private const float logC_f = 0.092819f;

	public static float StandardIlluminantY(float x)
	{
		return 2.87f * x - 3f * x * x - 0.27509508f;
	}

	public static Vector3 CIExyToLMS(float x, float y)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		float num2 = num * x / y;
		float num3 = num * (1f - x - y) / y;
		float num4 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
		float num5 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
		float num6 = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
		return new Vector3(num4, num5, num6);
	}

	public static Vector3 ComputeColorBalance(float temperature, float tint)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		float num = temperature / 60f;
		float num2 = tint / 60f;
		float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
		float y = StandardIlluminantY(x) + num2 * 0.05f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0.949237f, 1.03542f, 1.08728f);
		Vector3 val2 = CIExyToLMS(x, y);
		return new Vector3(val.x / val2.x, val.y / val2.y, val.z / val2.z);
	}

	public static Vector3 ColorToLift(Vector4 color)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(color.x, color.y, color.z);
		float num = val.x * 0.2126f + val.y * 0.7152f + val.z * 0.0722f;
		((Vector3)(ref val))..ctor(val.x - num, val.y - num, val.z - num);
		float w = color.w;
		return new Vector3(val.x + w, val.y + w, val.z + w);
	}

	public static Vector3 ColorToInverseGamma(Vector4 color)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(color.x, color.y, color.z);
		float num = val.x * 0.2126f + val.y * 0.7152f + val.z * 0.0722f;
		((Vector3)(ref val))..ctor(val.x - num, val.y - num, val.z - num);
		float num2 = color.w + 1f;
		return new Vector3(1f / Mathf.Max(val.x + num2, 0.001f), 1f / Mathf.Max(val.y + num2, 0.001f), 1f / Mathf.Max(val.z + num2, 0.001f));
	}

	public static Vector3 ColorToGain(Vector4 color)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(color.x, color.y, color.z);
		float num = val.x * 0.2126f + val.y * 0.7152f + val.z * 0.0722f;
		((Vector3)(ref val))..ctor(val.x - num, val.y - num, val.z - num);
		float num2 = color.w + 1f;
		return new Vector3(val.x + num2, val.y + num2, val.z + num2);
	}

	public static float LogCToLinear(float x)
	{
		if (!(x > 0.1530537f))
		{
			return (x - 0.092819f) / 5.301883f;
		}
		return (Mathf.Pow(10f, (x - 0.386036f) / 0.244161f) - 0.047996f) / 5.555556f;
	}

	public static float LinearToLogC(float x)
	{
		if (!(x > 0.011361f))
		{
			return 5.301883f * x + 0.092819f;
		}
		return 0.244161f * Mathf.Log10(5.555556f * x + 0.047996f) + 0.386036f;
	}

	public static uint ToHex(Color c)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		return ((uint)(c.a * 255f) << 24) | ((uint)(c.r * 255f) << 16) | ((uint)(c.g * 255f) << 8) | (uint)(c.b * 255f);
	}

	public static Color ToRGBA(uint hex)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		return new Color((float)((hex >> 16) & 0xFF) / 255f, (float)((hex >> 8) & 0xFF) / 255f, (float)(hex & 0xFF) / 255f, (float)((hex >> 24) & 0xFF) / 255f);
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HableCurve
{
	private class Segment
	{
		public float offsetX;

		public float offsetY;

		public float scaleX;

		public float scaleY;

		public float lnA;

		public float B;

		public float Eval(float x)
		{
			float num = (x - offsetX) * scaleX;
			float num2 = 0f;
			if (num > 0f)
			{
				num2 = Mathf.Exp(lnA + B * Mathf.Log(num));
			}
			return num2 * scaleY + offsetY;
		}
	}

	private struct DirectParams
	{
		internal float x0;

		internal float y0;

		internal float x1;

		internal float y1;

		internal float W;

		internal float overshootX;

		internal float overshootY;

		internal float gamma;
	}

	public class Uniforms
	{
		private HableCurve parent;

		public Vector4 curve => new Vector4(parent.inverseWhitePoint, parent.x0, parent.x1, 0f);

		public Vector4 toeSegmentA
		{
			get
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[0];
				return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
			}
		}

		public Vector4 toeSegmentB
		{
			get
			{
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[0];
				return new Vector4(segment.lnA, segment.B, 0f, 0f);
			}
		}

		public Vector4 midSegmentA
		{
			get
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[1];
				return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
			}
		}

		public Vector4 midSegmentB
		{
			get
			{
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[1];
				return new Vector4(segment.lnA, segment.B, 0f, 0f);
			}
		}

		public Vector4 shoSegmentA
		{
			get
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[2];
				return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
			}
		}

		public Vector4 shoSegmentB
		{
			get
			{
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[2];
				return new Vector4(segment.lnA, segment.B, 0f, 0f);
			}
		}

		internal Uniforms(HableCurve parent)
		{
			this.parent = parent;
		}
	}

	private readonly Segment[] m_Segments = new Segment[3];

	public readonly Uniforms uniforms;

	public float whitePoint { get; private set; }

	public float inverseWhitePoint { get; private set; }

	internal float x0 { get; private set; }

	internal float x1 { get; private set; }

	public HableCurve()
	{
		for (int i = 0; i < 3; i++)
		{
			m_Segments[i] = new Segment();
		}
		uniforms = new Uniforms(this);
	}

	public float Eval(float x)
	{
		float num = x * inverseWhitePoint;
		int num2 = ((!(num < x0)) ? ((num < x1) ? 1 : 2) : 0);
		return m_Segments[num2].Eval(num);
	}

	public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma)
	{
		DirectParams srcParams = default(DirectParams);
		toeLength = Mathf.Pow(Mathf.Clamp01(toeLength), 2.2f);
		toeStrength = Mathf.Clamp01(toeStrength);
		shoulderAngle = Mathf.Clamp01(shoulderAngle);
		shoulderStrength = Mathf.Clamp(shoulderStrength, 1E-05f, 0.99999f);
		shoulderLength = Mathf.Max(0f, shoulderLength);
		gamma = Mathf.Max(1E-05f, gamma);
		float num = toeLength * 0.5f;
		float num2 = (1f - toeStrength) * num;
		float num3 = 1f - num2;
		float num4 = num + num3;
		float num5 = (1f - shoulderStrength) * num3;
		float num6 = num + num5;
		float y = num2 + num5;
		float num7 = RuntimeUtilities.Exp2(shoulderLength) - 1f;
		float w = num4 + num7;
		srcParams.x0 = num;
		srcParams.y0 = num2;
		srcParams.x1 = num6;
		srcParams.y1 = y;
		srcParams.W = w;
		srcParams.gamma = gamma;
		srcParams.overshootX = srcParams.W * 2f * shoulderAngle * shoulderLength;
		srcParams.overshootY = 0.5f * shoulderAngle * shoulderLength;
		InitSegments(srcParams);
	}

	private void InitSegments(DirectParams srcParams)
	{
		DirectParams directParams = srcParams;
		whitePoint = srcParams.W;
		inverseWhitePoint = 1f / srcParams.W;
		directParams.W = 1f;
		directParams.x0 /= srcParams.W;
		directParams.x1 /= srcParams.W;
		directParams.overshootX = srcParams.overshootX / srcParams.W;
		float num = 0f;
		float num2 = 0f;
		AsSlopeIntercept(out var m, out var b, directParams.x0, directParams.x1, directParams.y0, directParams.y1);
		float gamma = srcParams.gamma;
		Segment obj = m_Segments[1];
		obj.offsetX = 0f - b / m;
		obj.offsetY = 0f;
		obj.scaleX = 1f;
		obj.scaleY = 1f;
		obj.lnA = gamma * Mathf.Log(m);
		obj.B = gamma;
		num = EvalDerivativeLinearGamma(m, b, gamma, directParams.x0);
		num2 = EvalDerivativeLinearGamma(m, b, gamma, directParams.x1);
		directParams.y0 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y0, directParams.gamma));
		directParams.y1 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y1, directParams.gamma));
		directParams.overshootY = Mathf.Pow(1f + directParams.overshootY, directParams.gamma) - 1f;
		x0 = directParams.x0;
		x1 = directParams.x1;
		Segment obj2 = m_Segments[0];
		obj2.offsetX = 0f;
		obj2.offsetY = 0f;
		obj2.scaleX = 1f;
		obj2.scaleY = 1f;
		SolveAB(out var lnA, out var B, directParams.x0, directParams.y0, num);
		obj2.lnA = lnA;
		obj2.B = B;
		Segment obj3 = m_Segments[2];
		float num3 = 1f + directParams.overshootX - directParams.x1;
		float y = 1f + directParams.overshootY - directParams.y1;
		SolveAB(out var lnA2, out var B2, num3, y, num2);
		obj3.offsetX = 1f + directParams.overshootX;
		obj3.offsetY = 1f + directParams.overshootY;
		obj3.scaleX = -1f;
		obj3.scaleY = -1f;
		obj3.lnA = lnA2;
		obj3.B = B2;
		float num4 = m_Segments[2].Eval(1f);
		float num5 = 1f / num4;
		m_Segments[0].offsetY *= num5;
		m_Segments[0].scaleY *= num5;
		m_Segments[1].offsetY *= num5;
		m_Segments[1].scaleY *= num5;
		m_Segments[2].offsetY *= num5;
		m_Segments[2].scaleY *= num5;
	}

	private void SolveAB(out float lnA, out float B, float x0, float y0, float m)
	{
		B = m * x0 / y0;
		lnA = Mathf.Log(y0) - B * Mathf.Log(x0);
	}

	private void AsSlopeIntercept(out float m, out float b, float x0, float x1, float y0, float y1)
	{
		float num = y1 - y0;
		float num2 = x1 - x0;
		if (num2 == 0f)
		{
			m = 1f;
		}
		else
		{
			m = num / num2;
		}
		b = y0 - x0 * m;
	}

	private float EvalDerivativeLinearGamma(float m, float b, float g, float x)
	{
		return g * m * Mathf.Pow(m * x + b, g - 1f);
	}
}


private class Segment
{
	public float offsetX;

	public float offsetY;

	public float scaleX;

	public float scaleY;

	public float lnA;

	public float B;

	public float Eval(float x)
	{
		float num = (x - offsetX) * scaleX;
		float num2 = 0f;
		if (num > 0f)
		{
			num2 = Mathf.Exp(lnA + B * Mathf.Log(num));
		}
		return num2 * scaleY + offsetY;
	}
}


private struct DirectParams
{
	internal float x0;

	internal float y0;

	internal float x1;

	internal float y1;

	internal float W;

	internal float overshootX;

	internal float overshootY;

	internal float gamma;
}


public class Uniforms
{
	private HableCurve parent;

	public Vector4 curve => new Vector4(parent.inverseWhitePoint, parent.x0, parent.x1, 0f);

	public Vector4 toeSegmentA
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[0];
			return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
		}
	}

	public Vector4 toeSegmentB
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[0];
			return new Vector4(segment.lnA, segment.B, 0f, 0f);
		}
	}

	public Vector4 midSegmentA
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[1];
			return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
		}
	}

	public Vector4 midSegmentB
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[1];
			return new Vector4(segment.lnA, segment.B, 0f, 0f);
		}
	}

	public Vector4 shoSegmentA
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[2];
			return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
		}
	}

	public Vector4 shoSegmentB
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[2];
			return new Vector4(segment.lnA, segment.B, 0f, 0f);
		}
	}

	internal Uniforms(HableCurve parent)
	{
		this.parent = parent;
	}
}


public static class HaltonSeq
{
	public static float Get(int index, int radix)
	{
		float num = 0f;
		float num2 = 1f / (float)radix;
		while (index > 0)
		{
			num += (float)(index % radix) * num2;
			index /= radix;
			num2 /= (float)radix;
		}
		return num;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

internal sealed class LogHistogram
{
	public const int rangeMin = -9;

	public const int rangeMax = 9;

	private const int k_Bins = 128;

	public ComputeBuffer data { get; private set; }

	public void Generate(PostProcessRenderContext context)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (data == null)
		{
			data = new ComputeBuffer(128, 4);
		}
		Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes(context);
		ComputeShader exposureHistogram = context.resources.computeShaders.exposureHistogram;
		CommandBuffer command = context.command;
		command.BeginSample("LogHistogram");
		int num = exposureHistogram.FindKernel("KEyeHistogramClear");
		command.SetComputeBufferParam(exposureHistogram, num, "_HistogramBuffer", data);
		uint num2 = default(uint);
		uint num3 = default(uint);
		uint num4 = default(uint);
		exposureHistogram.GetKernelThreadGroupSizes(num, ref num2, ref num3, ref num4);
		command.DispatchCompute(exposureHistogram, num, Mathf.CeilToInt(128f / (float)num2), 1, 1);
		num = exposureHistogram.FindKernel("KEyeHistogram");
		command.SetComputeBufferParam(exposureHistogram, num, "_HistogramBuffer", data);
		command.SetComputeTextureParam(exposureHistogram, num, "_Source", context.source);
		command.SetComputeVectorParam(exposureHistogram, "_ScaleOffsetRes", histogramScaleOffsetRes);
		exposureHistogram.GetKernelThreadGroupSizes(num, ref num2, ref num3, ref num4);
		command.DispatchCompute(exposureHistogram, num, Mathf.CeilToInt(histogramScaleOffsetRes.z / 2f / (float)num2), Mathf.CeilToInt(histogramScaleOffsetRes.w / 2f / (float)num3), 1);
		command.EndSample("LogHistogram");
	}

	public Vector4 GetHistogramScaleOffsetRes(PostProcessRenderContext context)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = 18f;
		float num2 = 1f / num;
		float num3 = 9f * num2;
		return new Vector4(num2, num3, (float)context.width, (float)context.height);
	}

	public void Release()
	{
		if (data != null)
		{
			data.Release();
		}
		data = null;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;

internal static class MeshUtilities
{
	private static Dictionary<PrimitiveType, Mesh> s_Primitives;

	private static Dictionary<Type, PrimitiveType> s_ColliderPrimitives;

	static MeshUtilities()
	{
		s_Primitives = new Dictionary<PrimitiveType, Mesh>();
		s_ColliderPrimitives = new Dictionary<Type, PrimitiveType>
		{
			{
				typeof(BoxCollider),
				(PrimitiveType)3
			},
			{
				typeof(SphereCollider),
				(PrimitiveType)0
			},
			{
				typeof(CapsuleCollider),
				(PrimitiveType)1
			}
		};
	}

	internal static Mesh GetColliderMesh(Collider collider)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Type type = ((object)collider).GetType();
		if (type == typeof(MeshCollider))
		{
			return ((MeshCollider)collider).sharedMesh;
		}
		Assert.IsTrue(s_ColliderPrimitives.ContainsKey(type), "Unknown collider");
		return GetPrimitive(s_ColliderPrimitives[type]);
	}

	internal static Mesh GetPrimitive(PrimitiveType primitiveType)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (!s_Primitives.TryGetValue(primitiveType, out var value))
		{
			value = GetBuiltinMesh(primitiveType);
			s_Primitives.Add(primitiveType, value);
		}
		return value;
	}

	private static Mesh GetBuiltinMesh(PrimitiveType primitiveType)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = GameObject.CreatePrimitive(primitiveType);
		Mesh sharedMesh = obj.GetComponent<MeshFilter>().sharedMesh;
		RuntimeUtilities.Destroy((Object)(object)obj);
		return sharedMesh;
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PropertySheet
{
	public MaterialPropertyBlock properties { get; private set; }

	internal Material material { get; private set; }

	internal PropertySheet(Material material)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Expected O, but got Unknown
		this.material = material;
		properties = new MaterialPropertyBlock();
	}

	public void ClearKeywords()
	{
		material.shaderKeywords = null;
	}

	public void EnableKeyword(string keyword)
	{
		material.EnableKeyword(keyword);
	}

	public void DisableKeyword(string keyword)
	{
		material.DisableKeyword(keyword);
	}

	internal void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)material);
		material = null;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PropertySheetFactory
{
	private readonly Dictionary<Shader, PropertySheet> m_Sheets;

	public PropertySheetFactory()
	{
		m_Sheets = new Dictionary<Shader, PropertySheet>();
	}

	[Obsolete("Use PropertySheet.Get(Shader) with a direct reference to the Shader instead.")]
	public PropertySheet Get(string shaderName)
	{
		Shader val = Shader.Find(shaderName);
		if ((Object)(object)val == (Object)null)
		{
			throw new ArgumentException($"Invalid shader ({shaderName})");
		}
		return Get(val);
	}

	public PropertySheet Get(Shader shader)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Expected O, but got Unknown
		if ((Object)(object)shader == (Object)null)
		{
			throw new ArgumentException($"Invalid shader ({shader})");
		}
		if (m_Sheets.TryGetValue(shader, out var value))
		{
			return value;
		}
		string name = ((Object)shader).name;
		value = new PropertySheet(new Material(shader)
		{
			name = $"PostProcess - {name.Substring(name.LastIndexOf('/') + 1)}",
			hideFlags = (HideFlags)52
		});
		m_Sheets.Add(shader, value);
		return value;
	}

	public void Release()
	{
		foreach (PropertySheet value in m_Sheets.Values)
		{
			value.Release();
		}
		m_Sheets.Clear();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;

public static class RuntimeUtilities
{
	private static Texture2D m_WhiteTexture;

	private static Texture3D m_WhiteTexture3D;

	private static Texture2D m_BlackTexture;

	private static Texture3D m_BlackTexture3D;

	private static Texture2D m_TransparentTexture;

	private static Texture3D m_TransparentTexture3D;

	private static Dictionary<int, Texture2D> m_LutStrips = new Dictionary<int, Texture2D>();

	internal static PostProcessResources s_Resources;

	private static Mesh s_FullscreenTriangle;

	private static Material s_CopyStdMaterial;

	private static Material s_CopyStdFromDoubleWideMaterial;

	private static Material s_CopyMaterial;

	private static Material s_CopyFromTexArrayMaterial;

	private static PropertySheet s_CopySheet;

	private static PropertySheet s_CopyFromTexArraySheet;

	private static IEnumerable<Type> m_AssemblyTypes;

	public static Texture2D whiteTexture
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_WhiteTexture == (Object)null)
			{
				m_WhiteTexture = new Texture2D(1, 1, (TextureFormat)5, false)
				{
					name = "White Texture"
				};
				m_WhiteTexture.SetPixel(0, 0, Color.white);
				m_WhiteTexture.Apply();
			}
			return m_WhiteTexture;
		}
	}

	public static Texture3D whiteTexture3D
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_WhiteTexture3D == (Object)null)
			{
				m_WhiteTexture3D = new Texture3D(1, 1, 1, (TextureFormat)5, false)
				{
					name = "White Texture 3D"
				};
				m_WhiteTexture3D.SetPixels((Color[])(object)new Color[1] { Color.white });
				m_WhiteTexture3D.Apply();
			}
			return m_WhiteTexture3D;
		}
	}

	public static Texture2D blackTexture
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_BlackTexture == (Object)null)
			{
				m_BlackTexture = new Texture2D(1, 1, (TextureFormat)5, false)
				{
					name = "Black Texture"
				};
				m_BlackTexture.SetPixel(0, 0, Color.black);
				m_BlackTexture.Apply();
			}
			return m_BlackTexture;
		}
	}

	public static Texture3D blackTexture3D
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_BlackTexture3D == (Object)null)
			{
				m_BlackTexture3D = new Texture3D(1, 1, 1, (TextureFormat)5, false)
				{
					name = "Black Texture 3D"
				};
				m_BlackTexture3D.SetPixels((Color[])(object)new Color[1] { Color.black });
				m_BlackTexture3D.Apply();
			}
			return m_BlackTexture3D;
		}
	}

	public static Texture2D transparentTexture
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_TransparentTexture == (Object)null)
			{
				m_TransparentTexture = new Texture2D(1, 1, (TextureFormat)5, false)
				{
					name = "Transparent Texture"
				};
				m_TransparentTexture.SetPixel(0, 0, Color.clear);
				m_TransparentTexture.Apply();
			}
			return m_TransparentTexture;
		}
	}

	public static Texture3D transparentTexture3D
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_TransparentTexture3D == (Object)null)
			{
				m_TransparentTexture3D = new Texture3D(1, 1, 1, (TextureFormat)5, false)
				{
					name = "Transparent Texture 3D"
				};
				m_TransparentTexture3D.SetPixels((Color[])(object)new Color[1] { Color.clear });
				m_TransparentTexture3D.Apply();
			}
			return m_TransparentTexture3D;
		}
	}

	public static Mesh fullscreenTriangle
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Expected O, but got Unknown
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)s_FullscreenTriangle != (Object)null)
			{
				return s_FullscreenTriangle;
			}
			s_FullscreenTriangle = new Mesh
			{
				name = "Fullscreen Triangle"
			};
			s_FullscreenTriangle.SetVertices(new List<Vector3>
			{
				new Vector3(-1f, -1f, 0f),
				new Vector3(-1f, 3f, 0f),
				new Vector3(3f, -1f, 0f)
			});
			s_FullscreenTriangle.SetIndices(new int[3] { 0, 1, 2 }, (MeshTopology)0, 0, false);
			s_FullscreenTriangle.UploadMeshData(false);
			return s_FullscreenTriangle;
		}
	}

	public static Material copyStdMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyStdMaterial != (Object)null)
			{
				return s_CopyStdMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyStdMaterial = new Material(s_Resources.shaders.copyStd)
			{
				name = "PostProcess - CopyStd",
				hideFlags = (HideFlags)61
			};
			return s_CopyStdMaterial;
		}
	}

	public static Material copyStdFromDoubleWideMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyStdFromDoubleWideMaterial != (Object)null)
			{
				return s_CopyStdFromDoubleWideMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyStdFromDoubleWideMaterial = new Material(s_Resources.shaders.copyStdFromDoubleWide)
			{
				name = "PostProcess - CopyStdFromDoubleWide",
				hideFlags = (HideFlags)61
			};
			return s_CopyStdFromDoubleWideMaterial;
		}
	}

	public static Material copyMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyMaterial != (Object)null)
			{
				return s_CopyMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyMaterial = new Material(s_Resources.shaders.copy)
			{
				name = "PostProcess - Copy",
				hideFlags = (HideFlags)61
			};
			return s_CopyMaterial;
		}
	}

	public static Material copyFromTexArrayMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyFromTexArrayMaterial != (Object)null)
			{
				return s_CopyFromTexArrayMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyFromTexArrayMaterial = new Material(s_Resources.shaders.copyStdFromTexArray)
			{
				name = "PostProcess - CopyFromTexArray",
				hideFlags = (HideFlags)61
			};
			return s_CopyFromTexArrayMaterial;
		}
	}

	public static PropertySheet copySheet
	{
		get
		{
			if (s_CopySheet == null)
			{
				s_CopySheet = new PropertySheet(copyMaterial);
			}
			return s_CopySheet;
		}
	}

	public static PropertySheet copyFromTexArraySheet
	{
		get
		{
			if (s_CopyFromTexArraySheet == null)
			{
				s_CopyFromTexArraySheet = new PropertySheet(copyFromTexArrayMaterial);
			}
			return s_CopyFromTexArraySheet;
		}
	}

	public static bool scriptableRenderPipelineActive => (Object)(object)GraphicsSettings.renderPipelineAsset != (Object)null;

	public static bool supportsDeferredShading
	{
		get
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Invalid comparison between Unknown and I4
			if (!scriptableRenderPipelineActive)
			{
				return (int)GraphicsSettings.GetShaderMode((BuiltinShaderType)0) > 0;
			}
			return true;
		}
	}

	public static bool supportsDepthNormals
	{
		get
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Invalid comparison between Unknown and I4
			if (!scriptableRenderPipelineActive)
			{
				return (int)GraphicsSettings.GetShaderMode((BuiltinShaderType)4) > 0;
			}
			return true;
		}
	}

	public static bool isSinglePassStereoEnabled => false;

	public static bool isVREnabled => false;

	public static bool isAndroidOpenGL
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Invalid comparison between Unknown and I4
			if ((int)Application.platform == 11)
			{
				return (int)SystemInfo.graphicsDeviceType != 21;
			}
			return false;
		}
	}

	public static RenderTextureFormat defaultHDRRenderTextureFormat => (RenderTextureFormat)9;

	public static bool isLinearColorSpace => (int)QualitySettings.activeColorSpace == 1;

	public static Texture2D GetLutStrip(int size)
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Expected O, but got Unknown
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!m_LutStrips.TryGetValue(size, out var value))
		{
			int num = size * size;
			int num2 = size;
			Color[] array = (Color[])(object)new Color[num * num2];
			float num3 = 1f / ((float)size - 1f);
			for (int i = 0; i < size; i++)
			{
				int num4 = i * size;
				float num5 = (float)i * num3;
				for (int j = 0; j < size; j++)
				{
					float num6 = (float)j * num3;
					for (int k = 0; k < size; k++)
					{
						float num7 = (float)k * num3;
						array[j * num + num4 + k] = new Color(num7, num6, num5);
					}
				}
			}
			TextureFormat val = (TextureFormat)17;
			if (!val.IsSupported())
			{
				val = (TextureFormat)5;
			}
			value = new Texture2D(size * size, size, val, false, true)
			{
				name = "Strip Lut" + size,
				hideFlags = (HideFlags)52,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				anisoLevel = 0
			};
			value.SetPixels(array);
			value.Apply();
			m_LutStrips.Add(size, value);
		}
		return value;
	}

	public static void SetRenderTargetWithLoadStoreAction(this CommandBuffer cmd, RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(rt, loadAction, storeAction);
	}

	public static void SetRenderTargetWithLoadStoreAction(this CommandBuffer cmd, RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(color, colorLoadAction, colorStoreAction, depth, depthLoadAction, depthStoreAction);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, bool clear = false, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetRenderTargetWithLoadStoreAction(destination, (RenderBufferLoadAction)((!viewport.HasValue) ? 2 : 0), (RenderBufferStoreAction)0);
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, copyMaterial, 0, 0);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, RenderBufferLoadAction loadAction, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		bool num = (int)loadAction == 1;
		if (num)
		{
			loadAction = (RenderBufferLoadAction)2;
		}
		cmd.SetRenderTargetWithLoadStoreAction(destination, (RenderBufferLoadAction)((!viewport.HasValue) ? ((int)loadAction) : 0), (RenderBufferStoreAction)0);
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		if (num)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		cmd.BlitFullscreenTriangle(source, destination, propertySheet, pass, (RenderBufferLoadAction)(clear ? 1 : 2), viewport);
	}

	public static void BlitFullscreenTriangleFromDoubleWide(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material, int pass, int eye)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(0.5f, 1f, 0f, 0f);
		if (eye == 1)
		{
			val.z = 0.5f;
		}
		cmd.SetGlobalVector(ShaderIDs.UVScaleOffset, val);
		cmd.BuiltinBlit(source, destination, material, pass);
	}

	public static void BlitFullscreenTriangleToDoubleWide(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, int eye)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(0.5f, 1f, -0.5f, 0f);
		if (eye == 1)
		{
			val.z = 0.5f;
		}
		propertySheet.EnableKeyword("STEREO_DOUBLEWIDE_TARGET");
		propertySheet.properties.SetVector(ShaderIDs.PosScaleOffset, val);
		cmd.BlitFullscreenTriangle(source, destination, propertySheet, 0, clear: false, null);
	}

	public static void BlitFullscreenTriangleFromTexArray(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, int depthSlice = -1)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetGlobalFloat(ShaderIDs.DepthSlice, (float)depthSlice);
		cmd.SetRenderTargetWithLoadStoreAction(destination, (RenderBufferLoadAction)2, (RenderBufferStoreAction)0);
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangleToTexArray(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, int depthSlice = -1)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetGlobalFloat(ShaderIDs.DepthSlice, (float)depthSlice);
		cmd.SetRenderTarget(destination, 0, (CubemapFace)(-1), -1);
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		RenderBufferLoadAction val = (RenderBufferLoadAction)((!viewport.HasValue) ? 2 : 0);
		if (clear)
		{
			cmd.SetRenderTargetWithLoadStoreAction(destination, val, (RenderBufferStoreAction)0, depth, val, (RenderBufferStoreAction)0);
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		else
		{
			cmd.SetRenderTargetWithLoadStoreAction(destination, val, (RenderBufferStoreAction)0, depth, (RenderBufferLoadAction)0, (RenderBufferStoreAction)0);
		}
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier[] destinations, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetRenderTarget(destinations, depth);
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BuiltinBlit(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(destination, (RenderBufferLoadAction)2, (RenderBufferStoreAction)0);
		destination = RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)1);
		cmd.Blit(source, destination);
	}

	public static void BuiltinBlit(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material mat, int pass = 0)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(destination, (RenderBufferLoadAction)2, (RenderBufferStoreAction)0);
		destination = RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)1);
		cmd.Blit(source, destination, mat, pass);
	}

	public static void CopyTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if ((int)SystemInfo.copyTextureSupport > 0)
		{
			cmd.CopyTexture(source, destination);
		}
		else
		{
			cmd.BlitFullscreenTriangle(source, destination, clear: false, null);
		}
	}

	public static bool isFloatingPointFormat(RenderTextureFormat format)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Invalid comparison between Unknown and I4
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Invalid comparison between Unknown and I4
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Invalid comparison between Unknown and I4
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Invalid comparison between Unknown and I4
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Invalid comparison between Unknown and I4
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Invalid comparison between Unknown and I4
		if ((int)format != 9 && (int)format != 2 && (int)format != 11 && (int)format != 12 && (int)format != 13 && (int)format != 14 && (int)format != 15)
		{
			return (int)format == 22;
		}
		return true;
	}

	public static void Destroy(Object obj)
	{
		if (obj != (Object)null)
		{
			Object.Destroy(obj);
		}
	}

	public static bool IsResolvedDepthAvailable(Camera camera)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Invalid comparison between Unknown and I4
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Invalid comparison between Unknown and I4
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Invalid comparison between Unknown and I4
		GraphicsDeviceType graphicsDeviceType = SystemInfo.graphicsDeviceType;
		if ((int)camera.actualRenderingPath == 3)
		{
			if ((int)graphicsDeviceType != 2 && (int)graphicsDeviceType != 18)
			{
				return (int)graphicsDeviceType == 14;
			}
			return true;
		}
		return false;
	}

	public static void DestroyProfile(PostProcessProfile profile, bool destroyEffects)
	{
		if (destroyEffects)
		{
			foreach (PostProcessEffectSettings setting in profile.settings)
			{
				Destroy((Object)(object)setting);
			}
		}
		Destroy((Object)(object)profile);
	}

	public static void DestroyVolume(PostProcessVolume volume, bool destroyProfile, bool destroyGameObject = false)
	{
		if (destroyProfile)
		{
			DestroyProfile(volume.profileRef, destroyEffects: true);
		}
		GameObject gameObject = ((Component)volume).gameObject;
		Destroy((Object)(object)volume);
		if (destroyGameObject)
		{
			Destroy((Object)(object)gameObject);
		}
	}

	public static bool IsPostProcessingActive(PostProcessLayer layer)
	{
		if ((Object)(object)layer != (Object)null)
		{
			return ((Behaviour)layer).enabled;
		}
		return false;
	}

	public static bool IsTemporalAntialiasingActive(PostProcessLayer layer)
	{
		if (IsPostProcessingActive(layer) && layer.antialiasingMode == PostProcessLayer.Antialiasing.TemporalAntialiasing)
		{
			return layer.temporalAntialiasing.IsSupported();
		}
		return false;
	}

	public static IEnumerable<T> GetAllSceneObjects<T>() where T : Component
	{
		Queue<Transform> queue = new Queue<Transform>();
		Scene activeScene = SceneManager.GetActiveScene();
		GameObject[] rootGameObjects = ((Scene)(ref activeScene)).GetRootGameObjects();
		GameObject[] array = rootGameObjects;
		foreach (GameObject val in array)
		{
			queue.Enqueue(val.transform);
			T component = val.GetComponent<T>();
			if ((Object)(object)component != (Object)null)
			{
				yield return component;
			}
		}
		while (queue.Count > 0)
		{
			foreach (Transform item in queue.Dequeue())
			{
				Transform val2 = item;
				queue.Enqueue(val2);
				T component2 = ((Component)val2).GetComponent<T>();
				if ((Object)(object)component2 != (Object)null)
				{
					yield return component2;
				}
			}
		}
	}

	public static void CreateIfNull<T>(ref T obj) where T : class, new()
	{
		if (obj == null)
		{
			obj = new T();
		}
	}

	public static float Exp2(float x)
	{
		return Mathf.Exp(x * 0.6931472f);
	}

	public static Matrix4x4 GetJitteredPerspectiveProjectionMatrix(Camera camera, Vector2 offset)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		float nearClipPlane = camera.nearClipPlane;
		_ = camera.farClipPlane;
		float num = Mathf.Tan(MathF.PI / 360f * camera.fieldOfView) * nearClipPlane;
		float num2 = num * camera.aspect;
		offset.x *= num2 / (0.5f * (float)camera.pixelWidth);
		offset.y *= num / (0.5f * (float)camera.pixelHeight);
		Matrix4x4 projectionMatrix = camera.projectionMatrix;
		ref Matrix4x4 reference = ref projectionMatrix;
		((Matrix4x4)(ref reference))[0, 2] = ((Matrix4x4)(ref reference))[0, 2] + offset.x / num2;
		reference = ref projectionMatrix;
		((Matrix4x4)(ref reference))[1, 2] = ((Matrix4x4)(ref reference))[1, 2] + offset.y / num;
		return projectionMatrix;
	}

	public static Matrix4x4 GetJitteredOrthographicProjectionMatrix(Camera camera, Vector2 offset)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		float orthographicSize = camera.orthographicSize;
		float num = orthographicSize * camera.aspect;
		offset.x *= num / (0.5f * (float)camera.pixelWidth);
		offset.y *= orthographicSize / (0.5f * (float)camera.pixelHeight);
		float num2 = offset.x - num;
		float num3 = offset.x + num;
		float num4 = offset.y + orthographicSize;
		float num5 = offset.y - orthographicSize;
		return Matrix4x4.Ortho(num2, num3, num5, num4, camera.nearClipPlane, camera.farClipPlane);
	}

	public static Matrix4x4 GenerateJitteredProjectionMatrixFromOriginal(PostProcessRenderContext context, Matrix4x4 origProj, Vector2 jitter)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		FrustumPlanes decomposeProjection = ((Matrix4x4)(ref origProj)).decomposeProjection;
		float num = Math.Abs(decomposeProjection.top) + Math.Abs(decomposeProjection.bottom);
		float num2 = Math.Abs(decomposeProjection.left) + Math.Abs(decomposeProjection.right);
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(jitter.x * num2 / (float)context.screenWidth, jitter.y * num / (float)context.screenHeight);
		decomposeProjection.left += val.x;
		decomposeProjection.right += val.x;
		decomposeProjection.top += val.y;
		decomposeProjection.bottom += val.y;
		return Matrix4x4.Frustum(decomposeProjection);
	}

	public static IEnumerable<Type> GetAllAssemblyTypes()
	{
		if (m_AssemblyTypes == null)
		{
			m_AssemblyTypes = AppDomain.CurrentDomain.GetAssemblies().SelectMany(delegate(Assembly t)
			{
				Type[] result = new Type[0];
				try
				{
					result = t.GetTypes();
				}
				catch
				{
				}
				return result;
			});
		}
		return m_AssemblyTypes;
	}

	public static T GetAttribute<T>(this Type type) where T : Attribute
	{
		Assert.IsTrue(type.IsDefined(typeof(T), inherit: false), "Attribute not found");
		return (T)type.GetCustomAttributes(typeof(T), inherit: false)[0];
	}

	public static Attribute[] GetMemberAttributes<TType, TValue>(Expression<Func<TType, TValue>> expr)
	{
		Expression expression = expr;
		if (expression is LambdaExpression)
		{
			expression = ((LambdaExpression)expression).Body;
		}
		if (expression.NodeType == ExpressionType.MemberAccess)
		{
			return ((FieldInfo)((MemberExpression)expression).Member).GetCustomAttributes(inherit: false).Cast<Attribute>().ToArray();
		}
		throw new InvalidOperationException();
	}

	public static string GetFieldPath<TType, TValue>(Expression<Func<TType, TValue>> expr)
	{
		if (expr.Body.NodeType == ExpressionType.MemberAccess)
		{
			MemberExpression memberExpression = expr.Body as MemberExpression;
			List<string> list = new List<string>();
			while (memberExpression != null)
			{
				list.Add(memberExpression.Member.Name);
				memberExpression = memberExpression.Expression as MemberExpression;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				stringBuilder.Append(list[num]);
				if (num > 0)
				{
					stringBuilder.Append('.');
				}
			}
			return stringBuilder.ToString();
		}
		throw new InvalidOperationException();
	}
}


using UnityEngine;

internal static class ShaderIDs
{
	internal static readonly int MainTex = Shader.PropertyToID("_MainTex");

	internal static readonly int Jitter = Shader.PropertyToID("_Jitter");

	internal static readonly int Sharpness = Shader.PropertyToID("_Sharpness");

	internal static readonly int FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

	internal static readonly int HistoryTex = Shader.PropertyToID("_HistoryTex");

	internal static readonly int SMAA_Flip = Shader.PropertyToID("_SMAA_Flip");

	internal static readonly int SMAA_Flop = Shader.PropertyToID("_SMAA_Flop");

	internal static readonly int AOParams = Shader.PropertyToID("_AOParams");

	internal static readonly int AOColor = Shader.PropertyToID("_AOColor");

	internal static readonly int OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

	internal static readonly int OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

	internal static readonly int SAOcclusionTexture = Shader.PropertyToID("_SAOcclusionTexture");

	internal static readonly int MSVOcclusionTexture = Shader.PropertyToID("_MSVOcclusionTexture");

	internal static readonly int DepthCopy = Shader.PropertyToID("DepthCopy");

	internal static readonly int LinearDepth = Shader.PropertyToID("LinearDepth");

	internal static readonly int LowDepth1 = Shader.PropertyToID("LowDepth1");

	internal static readonly int LowDepth2 = Shader.PropertyToID("LowDepth2");

	internal static readonly int LowDepth3 = Shader.PropertyToID("LowDepth3");

	internal static readonly int LowDepth4 = Shader.PropertyToID("LowDepth4");

	internal static readonly int TiledDepth1 = Shader.PropertyToID("TiledDepth1");

	internal static readonly int TiledDepth2 = Shader.PropertyToID("TiledDepth2");

	internal static readonly int TiledDepth3 = Shader.PropertyToID("TiledDepth3");

	internal static readonly int TiledDepth4 = Shader.PropertyToID("TiledDepth4");

	internal static readonly int Occlusion1 = Shader.PropertyToID("Occlusion1");

	internal static readonly int Occlusion2 = Shader.PropertyToID("Occlusion2");

	internal static readonly int Occlusion3 = Shader.PropertyToID("Occlusion3");

	internal static readonly int Occlusion4 = Shader.PropertyToID("Occlusion4");

	internal static readonly int Combined1 = Shader.PropertyToID("Combined1");

	internal static readonly int Combined2 = Shader.PropertyToID("Combined2");

	internal static readonly int Combined3 = Shader.PropertyToID("Combined3");

	internal static readonly int SSRResolveTemp = Shader.PropertyToID("_SSRResolveTemp");

	internal static readonly int Noise = Shader.PropertyToID("_Noise");

	internal static readonly int Test = Shader.PropertyToID("_Test");

	internal static readonly int Resolve = Shader.PropertyToID("_Resolve");

	internal static readonly int History = Shader.PropertyToID("_History");

	internal static readonly int ViewMatrix = Shader.PropertyToID("_ViewMatrix");

	internal static readonly int InverseViewMatrix = Shader.PropertyToID("_InverseViewMatrix");

	internal static readonly int InverseProjectionMatrix = Shader.PropertyToID("_InverseProjectionMatrix");

	internal static readonly int ScreenSpaceProjectionMatrix = Shader.PropertyToID("_ScreenSpaceProjectionMatrix");

	internal static readonly int Params2 = Shader.PropertyToID("_Params2");

	internal static readonly int FogColor = Shader.PropertyToID("_FogColor");

	internal static readonly int FogParams = Shader.PropertyToID("_FogParams");

	internal static readonly int VelocityScale = Shader.PropertyToID("_VelocityScale");

	internal static readonly int MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

	internal static readonly int RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

	internal static readonly int VelocityTex = Shader.PropertyToID("_VelocityTex");

	internal static readonly int Tile2RT = Shader.PropertyToID("_Tile2RT");

	internal static readonly int Tile4RT = Shader.PropertyToID("_Tile4RT");

	internal static readonly int Tile8RT = Shader.PropertyToID("_Tile8RT");

	internal static readonly int TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

	internal static readonly int TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

	internal static readonly int TileVRT = Shader.PropertyToID("_TileVRT");

	internal static readonly int NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

	internal static readonly int LoopCount = Shader.PropertyToID("_LoopCount");

	internal static readonly int DepthOfFieldTemp = Shader.PropertyToID("_DepthOfFieldTemp");

	internal static readonly int DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

	internal static readonly int Distance = Shader.PropertyToID("_Distance");

	internal static readonly int LensCoeff = Shader.PropertyToID("_LensCoeff");

	internal static readonly int MaxCoC = Shader.PropertyToID("_MaxCoC");

	internal static readonly int RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

	internal static readonly int RcpAspect = Shader.PropertyToID("_RcpAspect");

	internal static readonly int CoCTex = Shader.PropertyToID("_CoCTex");

	internal static readonly int TaaParams = Shader.PropertyToID("_TaaParams");

	internal static readonly int AutoExposureTex = Shader.PropertyToID("_AutoExposureTex");

	internal static readonly int HistogramBuffer = Shader.PropertyToID("_HistogramBuffer");

	internal static readonly int Params = Shader.PropertyToID("_Params");

	internal static readonly int ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");

	internal static readonly int BloomTex = Shader.PropertyToID("_BloomTex");

	internal static readonly int SampleScale = Shader.PropertyToID("_SampleScale");

	internal static readonly int Threshold = Shader.PropertyToID("_Threshold");

	internal static readonly int ColorIntensity = Shader.PropertyToID("_ColorIntensity");

	internal static readonly int Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

	internal static readonly int Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

	internal static readonly int Bloom_Color = Shader.PropertyToID("_Bloom_Color");

	internal static readonly int Bloom_DirtTileOffset = Shader.PropertyToID("_Bloom_DirtTileOffset");

	internal static readonly int ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

	internal static readonly int ChromaticAberration_SpectralLut = Shader.PropertyToID("_ChromaticAberration_SpectralLut");

	internal static readonly int Distortion_CenterScale = Shader.PropertyToID("_Distortion_CenterScale");

	internal static readonly int Distortion_Amount = Shader.PropertyToID("_Distortion_Amount");

	internal static readonly int Lut2D = Shader.PropertyToID("_Lut2D");

	internal static readonly int Lut3D = Shader.PropertyToID("_Lut3D");

	internal static readonly int Lut3D_Params = Shader.PropertyToID("_Lut3D_Params");

	internal static readonly int Lut2D_Params = Shader.PropertyToID("_Lut2D_Params");

	internal static readonly int UserLut2D_Params = Shader.PropertyToID("_UserLut2D_Params");

	internal static readonly int PostExposure = Shader.PropertyToID("_PostExposure");

	internal static readonly int ColorBalance = Shader.PropertyToID("_ColorBalance");

	internal static readonly int ColorFilter = Shader.PropertyToID("_ColorFilter");

	internal static readonly int HueSatCon = Shader.PropertyToID("_HueSatCon");

	internal static readonly int Brightness = Shader.PropertyToID("_Brightness");

	internal static readonly int ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

	internal static readonly int ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

	internal static readonly int ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

	internal static readonly int Lift = Shader.PropertyToID("_Lift");

	internal static readonly int InvGamma = Shader.PropertyToID("_InvGamma");

	internal static readonly int Gain = Shader.PropertyToID("_Gain");

	internal static readonly int Curves = Shader.PropertyToID("_Curves");

	internal static readonly int CustomToneCurve = Shader.PropertyToID("_CustomToneCurve");

	internal static readonly int ToeSegmentA = Shader.PropertyToID("_ToeSegmentA");

	internal static readonly int ToeSegmentB = Shader.PropertyToID("_ToeSegmentB");

	internal static readonly int MidSegmentA = Shader.PropertyToID("_MidSegmentA");

	internal static readonly int MidSegmentB = Shader.PropertyToID("_MidSegmentB");

	internal static readonly int ShoSegmentA = Shader.PropertyToID("_ShoSegmentA");

	internal static readonly int ShoSegmentB = Shader.PropertyToID("_ShoSegmentB");

	internal static readonly int MaskMode = Shader.PropertyToID("_MaskMode");

	internal static readonly int MaskIntensity = Shader.PropertyToID("_MaskIntensity");

	internal static readonly int Vignette_Color = Shader.PropertyToID("_Vignette_Color");

	internal static readonly int Vignette_Center = Shader.PropertyToID("_Vignette_Center");

	internal static readonly int Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

	internal static readonly int Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

	internal static readonly int Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");

	internal static readonly int Vignette_Mode = Shader.PropertyToID("_Vignette_Mode");

	internal static readonly int Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

	internal static readonly int Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

	internal static readonly int GrainTex = Shader.PropertyToID("_GrainTex");

	internal static readonly int Phase = Shader.PropertyToID("_Phase");

	internal static readonly int GrainNoiseParameters = Shader.PropertyToID("_NoiseParameters");

	internal static readonly int LumaInAlpha = Shader.PropertyToID("_LumaInAlpha");

	internal static readonly int DitheringTex = Shader.PropertyToID("_DitheringTex");

	internal static readonly int Dithering_Coords = Shader.PropertyToID("_Dithering_Coords");

	internal static readonly int From = Shader.PropertyToID("_From");

	internal static readonly int To = Shader.PropertyToID("_To");

	internal static readonly int Interp = Shader.PropertyToID("_Interp");

	internal static readonly int TargetColor = Shader.PropertyToID("_TargetColor");

	internal static readonly int HalfResFinalCopy = Shader.PropertyToID("_HalfResFinalCopy");

	internal static readonly int WaveformSource = Shader.PropertyToID("_WaveformSource");

	internal static readonly int WaveformBuffer = Shader.PropertyToID("_WaveformBuffer");

	internal static readonly int VectorscopeBuffer = Shader.PropertyToID("_VectorscopeBuffer");

	internal static readonly int RenderViewportScaleFactor = Shader.PropertyToID("_RenderViewportScaleFactor");

	internal static readonly int UVTransform = Shader.PropertyToID("_UVTransform");

	internal static readonly int DepthSlice = Shader.PropertyToID("_DepthSlice");

	internal static readonly int UVScaleOffset = Shader.PropertyToID("_UVScaleOffset");

	internal static readonly int PosScaleOffset = Shader.PropertyToID("_PosScaleOffset");
}


using System;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public sealed class Spline
{
	public const int k_Precision = 128;

	public const float k_Step = 1f / 128f;

	public AnimationCurve curve;

	[SerializeField]
	private bool m_Loop;

	[SerializeField]
	private float m_ZeroValue;

	[SerializeField]
	private float m_Range;

	private AnimationCurve m_InternalLoopingCurve;

	private int frameCount = -1;

	public float[] cachedData;

	public Spline(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
	{
		Assert.IsNotNull<AnimationCurve>(curve);
		this.curve = curve;
		m_ZeroValue = zeroValue;
		m_Loop = loop;
		m_Range = ((Vector2)(ref bounds)).magnitude;
		cachedData = new float[128];
	}

	public void Cache(int frame)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected O, but got Unknown
		if (frame == frameCount)
		{
			return;
		}
		int length = curve.length;
		if (m_Loop && length > 1)
		{
			if (m_InternalLoopingCurve == null)
			{
				m_InternalLoopingCurve = new AnimationCurve();
			}
			Keyframe val = curve[length - 1];
			((Keyframe)(ref val)).time = ((Keyframe)(ref val)).time - m_Range;
			Keyframe val2 = curve[0];
			((Keyframe)(ref val2)).time = ((Keyframe)(ref val2)).time + m_Range;
			m_InternalLoopingCurve.keys = curve.keys;
			m_InternalLoopingCurve.AddKey(val);
			m_InternalLoopingCurve.AddKey(val2);
		}
		for (int i = 0; i < 128; i++)
		{
			cachedData[i] = Evaluate((float)i * (1f / 128f), length);
		}
		frameCount = Time.renderedFrameCount;
	}

	public float Evaluate(float t, int length)
	{
		if (length == 0)
		{
			return m_ZeroValue;
		}
		if (!m_Loop || length == 1)
		{
			return curve.Evaluate(t);
		}
		return m_InternalLoopingCurve.Evaluate(t);
	}

	public float Evaluate(float t)
	{
		return Evaluate(t, curve.length);
	}

	public override int GetHashCode()
	{
		return 17 * 23 + ((object)curve).GetHashCode();
	}
}


using System.Collections.Generic;
using UnityEngine;

internal class TargetPool
{
	private readonly List<int> m_Pool;

	private int m_Current;

	internal TargetPool()
	{
		m_Pool = new List<int>();
		Get();
	}

	internal int Get()
	{
		int result = Get(m_Current);
		m_Current++;
		return result;
	}

	private int Get(int i)
	{
		if (m_Pool.Count > i)
		{
			return m_Pool[i];
		}
		while (m_Pool.Count <= i)
		{
			m_Pool.Add(Shader.PropertyToID("_TargetPool" + i));
		}
		return m_Pool[i];
	}

	internal void Reset()
	{
		m_Current = 0;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;

public static class TextureFormatUtilities
{
	private static Dictionary<int, RenderTextureFormat> s_FormatAliasMap;

	private static Dictionary<int, bool> s_SupportedRenderTextureFormats;

	private static Dictionary<int, bool> s_SupportedTextureFormats;

	static TextureFormatUtilities()
	{
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		s_FormatAliasMap = new Dictionary<int, RenderTextureFormat>
		{
			{
				1,
				(RenderTextureFormat)0
			},
			{
				2,
				(RenderTextureFormat)5
			},
			{
				3,
				(RenderTextureFormat)0
			},
			{
				4,
				(RenderTextureFormat)0
			},
			{
				5,
				(RenderTextureFormat)0
			},
			{
				7,
				(RenderTextureFormat)4
			},
			{
				9,
				(RenderTextureFormat)15
			},
			{
				10,
				(RenderTextureFormat)0
			},
			{
				12,
				(RenderTextureFormat)0
			},
			{
				13,
				(RenderTextureFormat)5
			},
			{
				14,
				(RenderTextureFormat)0
			},
			{
				15,
				(RenderTextureFormat)15
			},
			{
				16,
				(RenderTextureFormat)13
			},
			{
				17,
				(RenderTextureFormat)2
			},
			{
				18,
				(RenderTextureFormat)14
			},
			{
				19,
				(RenderTextureFormat)12
			},
			{
				20,
				(RenderTextureFormat)11
			},
			{
				22,
				(RenderTextureFormat)2
			},
			{
				26,
				(RenderTextureFormat)16
			},
			{
				27,
				(RenderTextureFormat)13
			},
			{
				24,
				(RenderTextureFormat)2
			},
			{
				25,
				(RenderTextureFormat)0
			},
			{
				28,
				(RenderTextureFormat)0
			},
			{
				29,
				(RenderTextureFormat)0
			},
			{
				30,
				(RenderTextureFormat)0
			},
			{
				31,
				(RenderTextureFormat)0
			},
			{
				32,
				(RenderTextureFormat)0
			},
			{
				33,
				(RenderTextureFormat)0
			},
			{
				34,
				(RenderTextureFormat)0
			},
			{
				45,
				(RenderTextureFormat)0
			},
			{
				46,
				(RenderTextureFormat)0
			},
			{
				47,
				(RenderTextureFormat)0
			},
			{
				48,
				(RenderTextureFormat)0
			},
			{
				49,
				(RenderTextureFormat)0
			},
			{
				50,
				(RenderTextureFormat)0
			},
			{
				51,
				(RenderTextureFormat)0
			},
			{
				52,
				(RenderTextureFormat)0
			},
			{
				53,
				(RenderTextureFormat)0
			}
		};
		s_SupportedRenderTextureFormats = new Dictionary<int, bool>();
		foreach (object value3 in Enum.GetValues(typeof(RenderTextureFormat)))
		{
			if ((int)value3 >= 0 && !IsObsolete(value3))
			{
				bool value = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)value3);
				s_SupportedRenderTextureFormats[(int)value3] = value;
			}
		}
		s_SupportedTextureFormats = new Dictionary<int, bool>();
		foreach (object value4 in Enum.GetValues(typeof(TextureFormat)))
		{
			if ((int)value4 >= 0 && !IsObsolete(value4))
			{
				bool value2 = SystemInfo.SupportsTextureFormat((TextureFormat)value4);
				s_SupportedTextureFormats[(int)value4] = value2;
			}
		}
	}

	private static bool IsObsolete(object value)
	{
		ObsoleteAttribute[] array = (ObsoleteAttribute[])value.GetType().GetField(value.ToString()).GetCustomAttributes(typeof(ObsoleteAttribute), inherit: false);
		if (array != null)
		{
			return array.Length != 0;
		}
		return false;
	}

	public static RenderTextureFormat GetUncompressedRenderTextureFormat(Texture texture)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected I4, but got Unknown
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<Texture>(texture);
		if (texture is RenderTexture)
		{
			return ((RenderTexture)((texture is RenderTexture) ? texture : null)).format;
		}
		if (texture is Texture2D)
		{
			TextureFormat format = ((Texture2D)texture).format;
			if (!s_FormatAliasMap.TryGetValue((int)format, out var value))
			{
				throw new NotSupportedException("Texture format not supported");
			}
			return value;
		}
		return (RenderTextureFormat)7;
	}

	internal static bool IsSupported(this RenderTextureFormat format)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected I4, but got Unknown
		s_SupportedRenderTextureFormats.TryGetValue((int)format, out var value);
		return value;
	}

	internal static bool IsSupported(this TextureFormat format)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected I4, but got Unknown
		s_SupportedTextureFormats.TryGetValue((int)format, out var value);
		return value;
	}
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

internal class TextureLerper
{
	private static TextureLerper m_Instance;

	private CommandBuffer m_Command;

	private PropertySheetFactory m_PropertySheets;

	private PostProcessResources m_Resources;

	private List<RenderTexture> m_Recycled;

	private List<RenderTexture> m_Actives;

	internal static TextureLerper instance
	{
		get
		{
			if (m_Instance == null)
			{
				m_Instance = new TextureLerper();
			}
			return m_Instance;
		}
	}

	private TextureLerper()
	{
		m_Recycled = new List<RenderTexture>();
		m_Actives = new List<RenderTexture>();
	}

	internal void BeginFrame(PostProcessRenderContext context)
	{
		m_Command = context.command;
		m_PropertySheets = context.propertySheets;
		m_Resources = context.resources;
	}

	internal void EndFrame()
	{
		if (m_Recycled.Count > 0)
		{
			foreach (RenderTexture item in m_Recycled)
			{
				RuntimeUtilities.Destroy((Object)(object)item);
			}
			m_Recycled.Clear();
		}
		if (m_Actives.Count <= 0)
		{
			return;
		}
		foreach (RenderTexture active in m_Actives)
		{
			m_Recycled.Add(active);
		}
		m_Actives.Clear();
	}

	private RenderTexture Get(RenderTextureFormat format, int w, int h, int d = 1, bool enableRandomWrite = false, bool force3D = false)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Invalid comparison between Unknown and I4
		RenderTexture val = null;
		int count = m_Recycled.Count;
		int i;
		for (i = 0; i < count; i++)
		{
			RenderTexture val2 = m_Recycled[i];
			if (((Texture)val2).width == w && ((Texture)val2).height == h && val2.volumeDepth == d && val2.format == format && val2.enableRandomWrite == enableRandomWrite && (!force3D || (int)((Texture)val2).dimension == 3))
			{
				val = val2;
				break;
			}
		}
		if ((Object)(object)val == (Object)null)
		{
			TextureDimension dimension = (TextureDimension)((d > 1 || force3D) ? 3 : 2);
			val = new RenderTexture(w, h, 0, format)
			{
				dimension = dimension,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				anisoLevel = 0,
				volumeDepth = d,
				enableRandomWrite = enableRandomWrite
			};
			val.Create();
		}
		else
		{
			m_Recycled.RemoveAt(i);
		}
		m_Actives.Add(val);
		return val;
	}

	internal Texture Lerp(Texture from, Texture to, float t)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<Texture>(from);
		Assert.IsNotNull<Texture>(to);
		Assert.AreEqual(from.width, to.width);
		Assert.AreEqual(from.height, to.height);
		if ((Object)(object)from == (Object)(object)to)
		{
			return from;
		}
		if (t <= 0f)
		{
			return from;
		}
		if (t >= 1f)
		{
			return to;
		}
		RenderTexture val;
		if (from is Texture3D || (from is RenderTexture && ((RenderTexture)from).volumeDepth > 1))
		{
			int num = ((from is Texture3D) ? ((Texture3D)from).depth : ((RenderTexture)from).volumeDepth);
			int num2 = Mathf.Max(Mathf.Max(from.width, from.height), num);
			val = Get((RenderTextureFormat)2, from.width, from.height, num, enableRandomWrite: true, force3D: true);
			ComputeShader texture3dLerp = m_Resources.computeShaders.texture3dLerp;
			int num3 = texture3dLerp.FindKernel("KTexture3DLerp");
			m_Command.SetComputeVectorParam(texture3dLerp, "_DimensionsAndLerp", new Vector4((float)from.width, (float)from.height, (float)num, t));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_Output", RenderTargetIdentifier.op_Implicit((Texture)(object)val));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_From", RenderTargetIdentifier.op_Implicit(from));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_To", RenderTargetIdentifier.op_Implicit(to));
			uint num4 = default(uint);
			uint num5 = default(uint);
			uint num6 = default(uint);
			texture3dLerp.GetKernelThreadGroupSizes(num3, ref num4, ref num5, ref num6);
			Assert.AreEqual(num4, num5);
			int num7 = Mathf.CeilToInt((float)num2 / (float)num4);
			int num8 = Mathf.CeilToInt((float)num2 / (float)num6);
			m_Command.DispatchCompute(texture3dLerp, num3, num7, num7, num8);
			return (Texture)(object)val;
		}
		RenderTextureFormat uncompressedRenderTextureFormat = TextureFormatUtilities.GetUncompressedRenderTextureFormat(to);
		val = Get(uncompressedRenderTextureFormat, to.width, to.height);
		PropertySheet propertySheet = m_PropertySheets.Get(m_Resources.shaders.texture2dLerp);
		propertySheet.properties.SetTexture(ShaderIDs.To, to);
		propertySheet.properties.SetFloat(ShaderIDs.Interp, t);
		m_Command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(from), RenderTargetIdentifier.op_Implicit((Texture)(object)val), propertySheet, 0, clear: false, null);
		return (Texture)(object)val;
	}

	internal Texture Lerp(Texture from, Color to, float t)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<Texture>(from);
		if ((double)t < 1E-05)
		{
			return from;
		}
		RenderTexture val;
		if (from is Texture3D || (from is RenderTexture && ((RenderTexture)from).volumeDepth > 1))
		{
			int num = ((from is Texture3D) ? ((Texture3D)from).depth : ((RenderTexture)from).volumeDepth);
			int num2 = Mathf.Max(Mathf.Max(from.width, from.height), num);
			val = Get((RenderTextureFormat)2, from.width, from.height, num, enableRandomWrite: true, force3D: true);
			ComputeShader texture3dLerp = m_Resources.computeShaders.texture3dLerp;
			int num3 = texture3dLerp.FindKernel("KTexture3DLerpToColor");
			m_Command.SetComputeVectorParam(texture3dLerp, "_DimensionsAndLerp", new Vector4((float)from.width, (float)from.height, (float)num, t));
			m_Command.SetComputeVectorParam(texture3dLerp, "_TargetColor", new Vector4(to.r, to.g, to.b, to.a));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_Output", RenderTargetIdentifier.op_Implicit((Texture)(object)val));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_From", RenderTargetIdentifier.op_Implicit(from));
			int num4 = Mathf.CeilToInt((float)num2 / 4f);
			m_Command.DispatchCompute(texture3dLerp, num3, num4, num4, num4);
			return (Texture)(object)val;
		}
		RenderTextureFormat uncompressedRenderTextureFormat = TextureFormatUtilities.GetUncompressedRenderTextureFormat(from);
		val = Get(uncompressedRenderTextureFormat, from.width, from.height);
		PropertySheet propertySheet = m_PropertySheets.Get(m_Resources.shaders.texture2dLerp);
		propertySheet.properties.SetVector(ShaderIDs.TargetColor, new Vector4(to.r, to.g, to.b, to.a));
		propertySheet.properties.SetFloat(ShaderIDs.Interp, t);
		m_Command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(from), RenderTargetIdentifier.op_Implicit((Texture)(object)val), propertySheet, 1, clear: false, null);
		return (Texture)(object)val;
	}

	internal void Clear()
	{
		foreach (RenderTexture active in m_Actives)
		{
			RuntimeUtilities.Destroy((Object)(object)active);
		}
		foreach (RenderTexture item in m_Recycled)
		{
			RuntimeUtilities.Destroy((Object)(object)item);
		}
		m_Actives.Clear();
		m_Recycled.Clear();
	}
}


using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct TraceAllJob : IJobFor
{
	public ReadOnly<HitboxSystem.HitboxShape.JobStruct> Shapes;

	[WriteOnly]
	public NativeArray<bool> DidHits;

	[WriteOnly]
	public NativeArray<RaycastHit> Hits;

	public Ray ray;

	public float maxDist;

	public float forgiveness;

	public void Execute(int index)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hit;
		bool flag = Trace(Shapes[index], ray, out hit, forgiveness, maxDist);
		DidHits[index] = flag;
		Hits[index] = hit;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static bool Trace(in HitboxSystem.HitboxShape.JobStruct shape, Ray ray, out RaycastHit hit, float forgivness = 0f, float maxDistance = float.PositiveInfinity)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 val = shape.inverseTransform;
		((Ray)(ref ray)).origin = ((Matrix4x4)(ref val)).MultiplyPoint3x4(((Ray)(ref ray)).origin);
		val = shape.inverseTransform;
		((Ray)(ref ray)).direction = ((Matrix4x4)(ref val)).MultiplyVector(((Ray)(ref ray)).direction);
		if (shape.type == HitboxDefinition.Type.BOX)
		{
			AABB val2 = default(AABB);
			((AABB)(ref val2))..ctor(Vector3.zero, shape.size);
			if (!((AABB)(ref val2)).Trace(ray, ref hit, forgivness, maxDistance))
			{
				return false;
			}
		}
		else
		{
			Capsule val3 = default(Capsule);
			((Capsule)(ref val3))..ctor(Vector3.zero, shape.size.x, shape.size.y * 0.5f);
			if (!((Capsule)(ref val3)).Trace(ray, ref hit, forgivness, maxDistance))
			{
				return false;
			}
		}
		val = shape.transform;
		((RaycastHit)(ref hit)).point = ((Matrix4x4)(ref val)).MultiplyPoint3x4(((RaycastHit)(ref hit)).point);
		val = shape.transform;
		((RaycastHit)(ref hit)).normal = ((Matrix4x4)(ref val)).MultiplyVector(((RaycastHit)(ref hit)).normal);
		return true;
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct CalcMidpoingJob : IJob
{
	[WriteOnly]
	public NativeArray<Vector3> Results;

	[ReadOnly]
	public ReadOnly<Vector3> From;

	[ReadOnly]
	public ReadOnly<Vector3> To;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < From.Length; i++)
		{
			Vector3 val = From[i];
			Vector3 val2 = To[i];
			Results[i] = (val + val2) * 0.5f;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CheckHitsJob : IJob
{
	[WriteOnly]
	public NativeArray<bool> Results;

	[ReadOnly]
	public ReadOnly<ColliderHit> Hits;

	public void Execute()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Hits.Length; i++)
		{
			ref NativeArray<bool> results = ref Results;
			int num = i;
			ColliderHit val = Hits[i];
			results[num] = ((ColliderHit)(ref val)).instanceID != 0;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct GenerateOverlapCapsuleCommandsJob : IJob
{
	[WriteOnly]
	public NativeArray<OverlapCapsuleCommand> CapsuleCommands;

	[ReadOnly]
	public ReadOnly<Vector3> From;

	[ReadOnly]
	public ReadOnly<Vector3> To;

	[ReadOnly]
	public ReadOnly<int> LayerMasks;

	[ReadOnly]
	public ReadOnly<float> Radiii;

	[ReadOnly]
	public QueryTriggerInteraction TriggerInteraction;

	[ReadOnly]
	public bool HitMultipleFaces;

	[ReadOnly]
	public bool HitBackfaces;

	public void Execute()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		QueryParameters val = default(QueryParameters);
		for (int i = 0; i < From.Length; i++)
		{
			((QueryParameters)(ref val))..ctor(LayerMasks[i], HitMultipleFaces, TriggerInteraction, HitBackfaces);
			CapsuleCommands[i] = new OverlapCapsuleCommand(From[i], To[i], Radiii[i], val);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct ValidateOverlapCapsuleCommandsJob : IJob
{
	[WriteOnly]
	public NativeList<int> InvalidIndices;

	[ReadOnly]
	public ReadOnly<OverlapCapsuleCommand> Commands;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Commands.Length; i++)
		{
			OverlapCapsuleCommand val = Commands[i];
			if (!(((OverlapCapsuleCommand)(ref val)).radius <= 0f))
			{
				Vector3 val2 = ((OverlapCapsuleCommand)(ref val)).point1 - ((OverlapCapsuleCommand)(ref val)).point0;
				if (!(((Vector3)(ref val2)).magnitude / 2f <= 0f))
				{
					continue;
				}
			}
			InvalidIndices.AddNoResize(i);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct FindSphereCmdsInCapsuleCmdsJob : IJob
{
	[WriteOnly]
	public NativeList<int> SphereIndices;

	[ReadOnly]
	public ReadOnly<OverlapCapsuleCommand> Commands;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Commands.Length; i++)
		{
			OverlapCapsuleCommand val = Commands[i];
			Vector3 val2 = ((OverlapCapsuleCommand)(ref val)).point1 - ((OverlapCapsuleCommand)(ref val)).point0;
			if (((Vector3)(ref val2)).magnitude / 2f <= 0f)
			{
				SphereIndices.AddNoResize(i);
			}
		}
	}
}


using System;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
public struct GenerateSphereCmdsFromCapsuleCmdsJob : IJob
{
	[WriteOnly]
	public NativeList<OverlapSphereCommand> SphereCommands;

	[ReadOnly]
	public ReadOnly<OverlapCapsuleCommand> Commands;

	[ReadOnly]
	public ReadOnly<int> Indices;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<int> enumerator = Indices.GetEnumerator();
		try
		{
			OverlapSphereCommand val2 = default(OverlapSphereCommand);
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				OverlapCapsuleCommand val = Commands[current];
				((OverlapSphereCommand)(ref val2))..ctor(((OverlapCapsuleCommand)(ref val)).point0, ((OverlapCapsuleCommand)(ref val)).radius, val.queryParameters);
				SphereCommands.AddNoResize(val2);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct GenerateOverlapSphereCommandsJob : IJob
{
	[WriteOnly]
	public NativeArray<OverlapSphereCommand> SphereCommands;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<int> LayerMasks;

	[ReadOnly]
	public ReadOnly<float> Radiii;

	[ReadOnly]
	public QueryTriggerInteraction TriggerInteraction;

	[ReadOnly]
	public bool HitMultipleFaces;

	[ReadOnly]
	public bool HitBackfaces;

	public void Execute()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		QueryParameters val = default(QueryParameters);
		for (int i = 0; i < Pos.Length; i++)
		{
			((QueryParameters)(ref val))..ctor(LayerMasks[i], HitMultipleFaces, TriggerInteraction, HitBackfaces);
			SphereCommands[i] = new OverlapSphereCommand(Pos[i], Radiii[i], val);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct ValidateOverlapSphereCommandsJob : IJob
{
	[WriteOnly]
	public NativeList<int> InvalidIndices;

	[ReadOnly]
	public ReadOnly<OverlapSphereCommand> Commands;

	public void Execute()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Commands.Length; i++)
		{
			OverlapSphereCommand val = Commands[i];
			if (((OverlapSphereCommand)(ref val)).radius < 0f)
			{
				InvalidIndices.AddNoResize(i);
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct RemoveLayerMaskJob : IJob
{
	public NativeArray<int> LayerMasks;

	[ReadOnly]
	public ReadOnly<bool> ShouldIgnore;

	[ReadOnly]
	public int MaskToRemove;

	public void Execute()
	{
		for (int i = 0; i < ShouldIgnore.Length; i++)
		{
			if (ShouldIgnore[i])
			{
				ref NativeArray<int> layerMasks = ref LayerMasks;
				int num = i;
				layerMasks[num] &= ~MaskToRemove;
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct CountRaycastHitsJobs : IJob
{
	public NativeArray<int> Counts;

	[ReadOnly]
	public ReadOnly<RaycastHit> Hits;

	[ReadOnly]
	public int MaxHitsPerRay;

	public void Execute()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Counts.Length; i++)
		{
			int num = 0;
			for (int j = 0; j < MaxHitsPerRay; j++)
			{
				int num2 = i * MaxHitsPerRay + j;
				RaycastHit val = Hits[num2];
				if (((RaycastHit)(ref val)).normal == Vector3.zero)
				{
					break;
				}
				num++;
			}
			Counts[i] = num;
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
public struct ScatterColliderHitsJob : IJob
{
	[WriteOnly]
	public NativeArray<ColliderHit> To;

	[ReadOnly]
	public ReadOnly<ColliderHit> From;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public int MaxHitsPerRay;

	public void Execute()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = i * MaxHitsPerRay;
			int num2 = Indices[i] * MaxHitsPerRay;
			NativeArray<ColliderHit>.Copy(From, num, To, num2, MaxHitsPerRay);
		}
	}
}


using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;
using UnityEngine.Scripting;

[StructLayout(LayoutKind.Sequential, Size = 1)]
[Preserve]
public struct RaycastHitComparer : IComparer<RaycastHit>
{
	public int Compare(RaycastHit x, RaycastHit y)
	{
		return ((RaycastHit)(ref x)).distance.CompareTo(((RaycastHit)(ref y)).distance);
	}
}


using Unity.Collections;
using UnityEngine;

internal static class Util
{
	public static int FindFreeSlot(int rayInd, in NativeArray<RaycastHit> hits, int maxHitsPerRay, out int endInd)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		int i = rayInd * maxHitsPerRay;
		for (endInd = i + maxHitsPerRay; i < endInd; i++)
		{
			RaycastHit val = hits[i];
			if (((RaycastHit)(ref val)).colliderInstanceID == 0)
			{
				break;
			}
		}
		return i;
	}
}


using GamePhysicsJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PreProcessWaterSpheresJob : IJob
{
	public NativeArray<RaycastHit> hits;

	public NativeArray<SpherecastCommand> rays;

	public int maxHitsPerTrace;

	public NativeList<Vector2i> WaterIndices;

	public NativeList<Ray> WaterRays;

	public NativeArray<float> WaterMaxDists;

	public void Execute()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Ray val2 = default(Ray);
		for (int i = 0; i < rays.Length; i++)
		{
			SpherecastCommand val = rays[i];
			if ((val.queryParameters.layerMask & 0x10) != 0)
			{
				int endInd;
				int num2 = Util.FindFreeSlot(i, in hits, maxHitsPerTrace, out endInd);
				if (num2 != endInd)
				{
					int num3 = num++;
					((Ray)(ref val2))..ctor(((SpherecastCommand)(ref val)).origin, ((SpherecastCommand)(ref val)).direction);
					WaterRays.Add(ref val2);
					WaterMaxDists[num3] = ((SpherecastCommand)(ref val)).distance;
					ref NativeList<Vector2i> waterIndices = ref WaterIndices;
					Vector2i val3 = new Vector2i(num2, endInd);
					waterIndices.Add(ref val3);
				}
			}
		}
	}
}


using GamePhysicsJobs;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PreProcessWaterRaysJob : IJob
{
	public NativeArray<RaycastHit> hits;

	public NativeArray<RaycastCommand> rays;

	public int maxHitsPerTrace;

	public NativeList<Vector2i> WaterIndices;

	public NativeList<Ray> WaterRays;

	public NativeArray<float> WaterMaxDists;

	public void Execute()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Ray val2 = default(Ray);
		for (int i = 0; i < rays.Length; i++)
		{
			RaycastCommand val = rays[i];
			if ((val.queryParameters.layerMask & 0x10) != 0)
			{
				int endInd;
				int num2 = Util.FindFreeSlot(i, in hits, maxHitsPerTrace, out endInd);
				if (num2 != endInd)
				{
					int num3 = num++;
					((Ray)(ref val2))..ctor(((RaycastCommand)(ref val)).from, ((RaycastCommand)(ref val)).direction);
					WaterRays.Add(ref val2);
					WaterMaxDists[num3] = ((RaycastCommand)(ref val)).distance;
					ref NativeList<Vector2i> waterIndices = ref WaterIndices;
					Vector2i val3 = new Vector2i(num2, endInd);
					waterIndices.Add(ref val3);
				}
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PostProcessWaterRaysJob : IJob
{
	public NativeArray<RaycastHit> hits;

	public NativeArray<Ray> rays;

	public NativeList<Vector2i> WaterIndices;

	public NativeArray<bool> hitsSub;

	public NativeArray<Vector3> positionsSub;

	public NativeArray<Vector3> normalsSub;

	public void Execute()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < WaterIndices.Length; i++)
		{
			Vector2i val = WaterIndices[i];
			int x = val.x;
			int y = val.y;
			int num2 = num++;
			if (hitsSub[num2])
			{
				Vector3 val2 = positionsSub[num2];
				Ray val3 = rays[num2];
				RaycastHit val4 = default(RaycastHit);
				((RaycastHit)(ref val4)).point = val2;
				((RaycastHit)(ref val4)).normal = normalsSub[num2];
				Vector3 val5 = val2 - ((Ray)(ref val3)).origin;
				((RaycastHit)(ref val4)).distance = ((Vector3)(ref val5)).magnitude;
				RaycastHit val6 = val4;
				hits[x++] = val6;
				if (x < y)
				{
					val4 = (hits[x] = default(RaycastHit));
				}
			}
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct ReadPositionDataTransformJob : IJobParallelForTransform
{
	public NativeArray<Vector3> Positions;

	public void Execute(int index, TransformAccess transform)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transform)).isValid)
		{
			Positions[index] = ((TransformAccess)(ref transform)).position;
		}
	}
}


using System;
using ProjectileJobs;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct BatchUpdateVelocityEndJob : IJobParallelForTransform
{
	public struct BatchData
	{
		public int DebugStableIndex;

		public Vector3 CurrentPosition;

		public Vector3 CurrentVelocity;

		public float TumbleSpeed;

		public Vector3 TumbleAxis;
	}

	public ReadOnly<int> BatchedIndices;

	public ReadOnly<BatchData> BatchedData;

	public float DeltaTime;

	public void Execute(int index, TransformAccess transform)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transform)).isValid && BatchedIndices.Contains(index))
		{
			BatchData batchData = BatchedData[index];
			if (index != batchData.DebugStableIndex)
			{
				throw new Exception($"{batchData.DebugStableIndex} {index}");
			}
			Quaternion val = ((!(batchData.TumbleSpeed > 0f)) ? Quaternion.LookRotation(batchData.CurrentVelocity) : (((TransformAccess)(ref transform)).rotation * Quaternion.AngleAxis(batchData.TumbleSpeed * DeltaTime, batchData.TumbleAxis)));
			((TransformAccess)(ref transform)).SetPositionAndRotation(batchData.CurrentPosition, val);
		}
	}
}


using UnityEngine;

public struct BatchData
{
	public int DebugStableIndex;

	public Vector3 CurrentPosition;

	public Vector3 CurrentVelocity;

	public float TumbleSpeed;

	public Vector3 TumbleAxis;
}


using UnityEngine;

public struct RayGenBatchData
{
	public Vector3 CurrentVelocity;

	public Vector3 SwimSpeed;

	public Vector3 SwimScale;

	public float SwimRandom;
}


using UnityEngine;

public struct RayGenOutput
{
	public Ray Ray;

	public float MaxDistance;
}


using ProjectileJobs;
using UnityEngine;
using UnityEngine.Jobs;

public static class RayGenUtil
{
	public static RayGenOutput GenerateRayGenOutput(TransformAccess transform, in RayGenBatchData data, Vector3 position, float time, float deltaTime, bool isClientDemo)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = data.CurrentVelocity;
		if (data.SwimScale != Vector3.zero)
		{
			Vector3 swimSpeed = data.SwimSpeed;
			Vector3 swimScale = data.SwimScale;
			float num = time + data.SwimRandom;
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(Mathf.Sin(num * swimSpeed.x) * swimScale.x, Mathf.Cos(num * swimSpeed.y) * swimScale.y, Mathf.Sin(num * swimSpeed.z) * swimScale.z);
			val2 = Quaternion.Inverse(((TransformAccess)(ref transform)).rotation) * val2;
			val += val2;
		}
		Vector3 val3 = val * deltaTime;
		float magnitude = ((Vector3)(ref val3)).magnitude;
		float num2 = 1f / magnitude;
		Vector3 val4 = val3 * num2;
		if (isClientDemo && Vector3Ex.IsNaNOrInfinity(val4))
		{
			val4 = Vector3.zero;
		}
		RayGenOutput result = default(RayGenOutput);
		result.Ray = new Ray(position, val4);
		result.MaxDistance = magnitude;
		return result;
	}
}


using ProjectileJobs;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GenerateRaysJob : IJobParallelForTransform
{
	public ReadOnly<int> Indices;

	public ReadOnly<RayGenBatchData> Data;

	public NativeArray<Vector3> PositionData;

	public NativeArray<RayGenOutput> Out;

	public float Time;

	public float DeltaTime;

	public bool IsClientDemo;

	public void Execute(int index, TransformAccess transform)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transform)).isValid && Indices.Contains(index))
		{
			RayGenBatchData data = Data[index];
			Vector3 val = (PositionData[index] = ((TransformAccess)(ref transform)).position);
			Vector3 position2 = val;
			Out[index] = RayGenUtil.GenerateRayGenOutput(transform, in data, position2, Time, DeltaTime, IsClientDemo);
		}
	}
}


using ProjectileJobs;
using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct GenerateRaysMidstepJob : IJobParallelForTransform
{
	public ReadOnly<Vector3> PositionData;

	public ReadOnly<int> Indices;

	public ReadOnly<RayGenBatchData> Data;

	public NativeArray<RayGenOutput> Out;

	public float Time;

	public float DeltaTime;

	public bool IsClientDemo;

	public void Execute(int index, TransformAccess transform)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transform)).isValid && Indices.Contains(index))
		{
			RayGenBatchData data = Data[index];
			Vector3 position = PositionData[index];
			Out[index] = RayGenUtil.GenerateRayGenOutput(transform, in data, position, Time, DeltaTime, IsClientDemo);
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Jobs;

[BurstCompile(/*Could not decode attribute arguments.*/)]
internal struct PosRotReadJob : IJobParallelForTransform
{
	public NativeArray<Vector3> Positions;

	public NativeArray<Quaternion> Rotations;

	public void Execute(int index, TransformAccess transform)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (((TransformAccess)(ref transform)).isValid)
		{
			Vector3 val = default(Vector3);
			Quaternion val2 = default(Quaternion);
			((TransformAccess)(ref transform)).GetPositionAndRotation(ref val, ref val2);
			Positions[index] = val;
			Rotations[index] = val2;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Math;
using UnityEngine;

public static class Output
{
	public struct Entry
	{
		public string Message;

		public string Stacktrace;

		public string Type;

		public int Time;
	}

	public static bool installed = false;

	public static Queue<Entry> HistoryOutput = new Queue<Entry>();

	private static readonly Memoized<string, LogType> LogTypeToString = new Memoized<string, LogType>((Func<LogType, string>)((LogType type) => ((object)(LogType)(ref type)/*cast due to .constrained prefix*/).ToString()));

	public static event Action<string, string, LogType> OnMessage;

	public static event Action<string, string, LogType> OnPostMessage;

	public static void Install()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (!installed)
		{
			Application.logMessageReceived += new LogCallback(LogHandler);
			installed = true;
		}
	}

	public static void LogHandler(string log, string stacktrace, LogType type)
	{
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		if ((Output.OnMessage == null && Output.OnPostMessage == null) || log.StartsWith("Kinematic body only supports Speculative Continuous collision detection") || log.StartsWith("Non-convex MeshCollider with non-kinematic Rigidbody is no longer supported") || log.StartsWith("Too many layers used to exclude objects from lighting") || log.StartsWith("Skipped frame because GfxDevice") || log.StartsWith("Your current multi-scene setup has inconsistent Lighting") || log.Contains("HandleD3DDeviceLost") || log.Contains("ResetD3DDevice") || log.Contains("dev->Reset") || log.Contains("D3Dwindow device not lost anymore") || log.Contains("D3D device reset") || log.Contains("group < 0xfff") || log.Contains("Mesh can not have more than 65000 vert") || log.Contains("Trying to add (Layout Rebuilder for)") || log.Contains("Coroutine continue failure") || log.Contains("No texture data available to upload") || log.Contains("Trying to reload asset from disk that is not") || log.Contains("Unable to find shaders used for the terrain engine.") || log.Contains("Canvas element contains more than 65535 vertices") || log.Contains("RectTransform.set_anchorMin") || log.Contains("FMOD failed to initialize the output device") || log.Contains("Cannot create FMOD::Sound") || log.Contains("invalid utf-16 sequence") || log.Contains("missing surrogate tail") || log.Contains("Failed to create agent because it is not close enough to the Nav") || log.Contains("user-provided triangle mesh descriptor is invalid") || log.Contains("Releasing render texture that is set as"))
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Facepunch.Output.LogHandler", 0);
		try
		{
			try
			{
				Output.OnMessage?.Invoke(log, stacktrace, type);
			}
			catch (Exception)
			{
			}
			try
			{
				Output.OnPostMessage?.Invoke(log, stacktrace, type);
			}
			catch (Exception)
			{
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Entry entry = default(Entry);
		entry.Message = log;
		entry.Stacktrace = stacktrace;
		entry.Type = LogTypeToString.Get(type);
		entry.Time = Epoch.Current;
		Entry item = entry;
		HistoryOutput.Enqueue(item);
		while (HistoryOutput.Count > 1024)
		{
			HistoryOutput.Dequeue();
		}
	}
}


public struct Entry
{
	public string Message;

	public string Stacktrace;

	public string Type;

	public int Time;
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rcon;
using Facepunch.Rust.Profiling;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using UnityEngine;

public class RCon
{
	public struct Command
	{
		public IPAddress Ip;

		public int ConnectionId;

		public string Name;

		public string Message;

		public int Identifier;
	}

	public enum LogType
	{
		Generic,
		Error,
		Warning,
		Chat,
		Report,
		ClientPerf,
		Subscription
	}

	public struct Response
	{
		public string Message;

		public int Identifier;

		[JsonConverter(typeof(StringEnumConverter))]
		public LogType Type;

		public string Stacktrace;
	}

	internal struct BannedAddresses
	{
		public IPAddress addr;

		public float banTime;
	}

	public static class ReservedIdentifiers
	{
		public const int PlayerPostionsUpdate = -64001;

		public const int FoundationsUpdate = -64002;
	}

	internal class RConClient
	{
		private Socket socket;

		private bool isAuthorised;

		private string connectionName;

		private int lastMessageID = -1;

		private bool runningConsoleCommand;

		private bool utf8Mode;

		internal RConClient(Socket cl)
		{
			socket = cl;
			socket.NoDelay = true;
			connectionName = socket.RemoteEndPoint.ToString();
		}

		internal bool IsValid()
		{
			return socket != null;
		}

		internal void Update()
		{
			if (socket == null)
			{
				return;
			}
			if (!socket.Connected)
			{
				Close("Disconnected");
				return;
			}
			int available = socket.Available;
			if (available < 14)
			{
				return;
			}
			if (available > 4096)
			{
				Close("overflow");
				return;
			}
			byte[] buffer = new byte[available];
			socket.Receive(buffer);
			using BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer, writable: false), utf8Mode ? Encoding.UTF8 : Encoding.ASCII);
			int num = binaryReader.ReadInt32();
			if (available < num)
			{
				Close("invalid packet");
				return;
			}
			lastMessageID = binaryReader.ReadInt32();
			int type = binaryReader.ReadInt32();
			string msg = ReadNullTerminatedString(binaryReader);
			ReadNullTerminatedString(binaryReader);
			if (!HandleMessage(type, msg))
			{
				Close("invalid packet");
			}
			else
			{
				lastMessageID = -1;
			}
		}

		internal bool HandleMessage(int type, string msg)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (!isAuthorised)
			{
				return HandleMessage_UnAuthed(type, msg);
			}
			if (type == SERVERDATA_SWITCH_UTF8)
			{
				utf8Mode = true;
				return true;
			}
			if (type == SERVERDATA_EXECCOMMAND)
			{
				Debug.Log((object)("[RCON][" + connectionName + "] " + msg));
				runningConsoleCommand = true;
				ConsoleSystem.Run(Option.Server, msg, Array.Empty<object>());
				runningConsoleCommand = false;
				Reply(-1, SERVERDATA_RESPONSE_VALUE, "");
				return true;
			}
			if (type == SERVERDATA_RESPONSE_VALUE)
			{
				Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
				return true;
			}
			Debug.Log((object)("[RCON][" + connectionName + "] Unhandled: " + lastMessageID + " -> " + type + " -> " + msg));
			return false;
		}

		internal bool HandleMessage_UnAuthed(int type, string msg)
		{
			if (type != SERVERDATA_AUTH)
			{
				BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
				Close("Invalid Command - Not Authed");
				return false;
			}
			Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
			isAuthorised = Password == msg;
			if (!isAuthorised)
			{
				Reply(-1, SERVERDATA_AUTH_RESPONSE, "");
				BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
				Close("Invalid Password");
				return true;
			}
			Reply(lastMessageID, SERVERDATA_AUTH_RESPONSE, "");
			Debug.Log((object)("[RCON] Auth: " + connectionName));
			Output.OnMessage += Output_OnMessage;
			return true;
		}

		private void Output_OnMessage(string message, string stacktrace, LogType type)
		{
			if (isAuthorised && IsValid())
			{
				if (lastMessageID != -1 && runningConsoleCommand)
				{
					Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, message);
				}
				Reply(0, SERVERDATA_CONSOLE_LOG, message);
			}
		}

		internal void Reply(int id, int type, string msg)
		{
			MemoryStream memoryStream = new MemoryStream(1024);
			using BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
			if (utf8Mode)
			{
				byte[] bytes = Encoding.UTF8.GetBytes(msg);
				int value = 10 + bytes.Length;
				binaryWriter.Write(value);
				binaryWriter.Write(id);
				binaryWriter.Write(type);
				binaryWriter.Write(bytes);
			}
			else
			{
				int value2 = 10 + msg.Length;
				binaryWriter.Write(value2);
				binaryWriter.Write(id);
				binaryWriter.Write(type);
				foreach (char c in msg)
				{
					binaryWriter.Write((sbyte)c);
				}
			}
			binaryWriter.Write((sbyte)0);
			binaryWriter.Write((sbyte)0);
			binaryWriter.Flush();
			try
			{
				socket.Send(memoryStream.GetBuffer(), (int)memoryStream.Position, SocketFlags.None);
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)("Error sending rcon reply: " + ex));
				Close("Exception");
			}
		}

		internal void Close(string strReasn)
		{
			Output.OnMessage -= Output_OnMessage;
			if (socket != null)
			{
				Debug.Log((object)("[RCON][" + connectionName + "] Disconnected: " + strReasn));
				socket.Close();
				socket = null;
			}
		}

		internal string ReadNullTerminatedString(BinaryReader read)
		{
			string text = "";
			do
			{
				if (read.BaseStream.Position == read.BaseStream.Length)
				{
					return "";
				}
				char c = read.ReadChar();
				if (c == '\0')
				{
					return text;
				}
				text += c;
			}
			while (text.Length <= 8192);
			return string.Empty;
		}
	}

	internal class RConListener
	{
		private TcpListener server;

		private List<RConClient> clients = new List<RConClient>();

		internal RConListener()
		{
			IPAddress address = IPAddress.Any;
			if (!IPAddress.TryParse(Ip, out address))
			{
				address = IPAddress.Any;
			}
			server = new TcpListener(address, Port);
			try
			{
				server.Start();
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)("Couldn't start RCON Listener: " + ex.Message));
				server = null;
			}
		}

		internal void Shutdown()
		{
			if (server != null)
			{
				server.Stop();
				server = null;
			}
		}

		internal void Cycle()
		{
			if (server != null)
			{
				ProcessConnections();
				RemoveDeadClients();
				UpdateClients();
			}
		}

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", (object)iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log((object)("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString()));
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

		private void UpdateClients()
		{
			foreach (RConClient client in clients)
			{
				client.Update();
			}
		}

		private void RemoveDeadClients()
		{
			clients.RemoveAll((RConClient x) => !x.IsValid());
		}
	}

	public static string Password = "";

	[ServerVar(Help = "Port to listen for RCON connections")]
	public static int Port = 0;

	[ServerVar(Help = "IP Address to listen for RCON connections")]
	public static string Ip = "";

	[ServerVar(Help = "If set to true, use websocket RCON. If set to false use legacy, source engine RCON. Source engine RCON is DEPRECATED")]
	public static bool Web = true;

	[ServerVar(Help = "If true, RCON commands will be printed in the console")]
	public static bool Print = false;

	private static bool _enableSubscriptions;

	internal static RConListener listener = null;

	public static Listener listenerNew = null;

	private static ConcurrentQueue<Command> Commands = new ConcurrentQueue<Command>();

	private static float lastRunTime = 0f;

	internal static List<BannedAddresses> bannedAddresses = new List<BannedAddresses>();

	private static int responseIdentifier;

	private static int responseConnection = -1;

	private static bool isInput;

	private static Stopwatch timer = new Stopwatch();

	internal static int SERVERDATA_AUTH = 3;

	internal static int SERVERDATA_EXECCOMMAND = 2;

	internal static int SERVERDATA_AUTH_RESPONSE = 2;

	internal static int SERVERDATA_RESPONSE_VALUE = 0;

	internal static int SERVERDATA_CONSOLE_LOG = 4;

	internal static int SERVERDATA_SWITCH_UTF8 = 5;

	public static bool HasSubscribers
	{
		get
		{
			if (EnableSubscriptions)
			{
				return listenerNew.HasSubscribers;
			}
			return false;
		}
	}

	[ServerVar(Help = "If true, allow RCON connections to subscribe to server events. This could be a performance hit and should only be used if you need it.", Saved = true, ShowInAdminUI = true)]
	public static bool EnableSubscriptions
	{
		get
		{
			return _enableSubscriptions;
		}
		set
		{
			if (_enableSubscriptions != value)
			{
				_enableSubscriptions = value;
				if (value)
				{
					ServerSubscriptions.StartSubscribeFeed();
				}
				else
				{
					ServerSubscriptions.StopSubscribeFeed();
				}
			}
		}
	}

	[ServerVar(Help = "Ban an IP address from RCON, preventing it from connecting and kick any clients from this IP, this is permanent and persistent")]
	public static void ban_ip(Arg arg)
	{
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
		}
		else if (arg.Args.Length < 1)
		{
			arg.ReplyWith("Usage: rcon.ban_ip <ip or cidr network>");
		}
		else
		{
			arg.ReplyWith(listenerNew.BanIP(arg.Args[0]) ? ("Banned " + arg.Args[0]) : (arg.Args[0] + " is not a valid IP address or CIDR formatted network."));
		}
	}

	[ServerVar(Help = "Unban an IP address from connecting to RCON, will also remove all attempt history")]
	public static void unban_ip(Arg arg)
	{
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		if (arg.Args.Length < 1)
		{
			arg.ReplyWith("Usage: rcon.unban_ip <ip>");
			return;
		}
		try
		{
			bool flag = listenerNew.UnbanIP(arg.Args[0]);
			arg.ReplyWith(flag ? ("Unbanned IP " + arg.Args[0]) : ("IP " + arg.Args[0] + " was not banned"));
		}
		catch
		{
			arg.ReplyWith("Invalid IP address");
		}
	}

	[ServerVar(Help = "Clear all failed login attempts")]
	public static void clear_rcon_failed_logins(Arg arg)
	{
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		listenerNew.ClearFailedIPData();
		arg.ReplyWith("Cleared failed login attempts");
	}

	[ServerVar(Help = "Print a table of permanently banned IPs and networks. Use '--json' to return a JSON object")]
	public static void print_rcon_bans(Arg arg)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		bool flag = arg.HasArg("--json", true);
		IList<IPNetwork> bannedNetworks = listenerNew.GetBannedNetworks();
		TextTable val = new TextTable();
		val.AddColumns(new string[4] { "address", "prefix", "netmask", "cidr" });
		foreach (IPNetwork item in bannedNetworks)
		{
			IPNetwork current = item;
			string[] obj = new string[4]
			{
				((IPNetwork)(ref current)).NetworkAddress().ToString(),
				null,
				null,
				null
			};
			byte prefixLength = current.PrefixLength;
			obj[1] = prefixLength.ToString();
			obj[2] = ((IPNetwork)(ref current)).Netmask().ToString();
			obj[3] = ((object)(IPNetwork)(ref current)/*cast due to .constrained prefix*/).ToString();
			val.AddRow(obj);
		}
		arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Print a table of clients with failed passwords.  Use '--json' to return a JSON object")]
	public static void print_rcon_failed_logins(Arg arg)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		bool flag = arg.HasArg("--json", true);
		Dictionary<IPAddress, FailedIPData> failedIPs = listenerNew.GetFailedIPs();
		TextTable val = new TextTable();
		val.AddColumns(new string[4] { "ip", "attempts", "banned", "ban_time" });
		foreach (KeyValuePair<IPAddress, FailedIPData> item in failedIPs)
		{
			val.AddRow(new string[4]
			{
				item.Key.ToString(),
				item.Value.Attempts.ToString(),
				item.Value.IsBanned.ToString(),
				((int)item.Value.BanTime).ToString()
			});
		}
		arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Print a table of connected RCON clients. Use '--json' to return a JSON object")]
	public static void print_rcon_clients(Arg arg)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		bool flag = arg.HasArg("--json", true);
		IList<RconClientStats> clientStats = listenerNew.GetClientStats();
		TextTable val = new TextTable();
		val.AddColumns(new string[9] { "index", "connection_id", "ip", "port", "connected_time", "inbound_messages", "outbound_messages", "broadcast_messages", "subscribed" });
		for (int i = 0; i < clientStats.Count; i++)
		{
			RconClientStats val2 = clientStats[i];
			TimeSpan timeSpan = DateTime.UtcNow.Subtract(val2.ConnectedAt);
			val.AddRow(new string[9]
			{
				i.ToString(),
				val2.ConnectionId.ToString(),
				val2.IP.ToString(),
				val2.Port.ToString(),
				Math.Floor(timeSpan.TotalSeconds).ToString(),
				val2.RecievedMessages.ToString(),
				val2.SentMessages.ToString(),
				val2.BroadcastedMessages.ToString(),
				val2.IsSubscribed.ToString()
			});
		}
		arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Clears all subscribers from the server.")]
	public static void clear_subscribers(Arg arg)
	{
		listenerNew.ClearSubscribers();
		arg.ReplyWith("Cleared subscribers");
	}

	[ServerVar(Help = "Un/Subscribes the current RCON connection to changes in server state. This could be a performance hit and should only be used if you need it.")]
	public static void subscribe(Arg arg)
	{
		if (!EnableSubscriptions)
		{
			arg.ReplyWith("Subscriptions are disabled. Enable them with enablesubscriptions");
			return;
		}
		if (!arg.IsRcon || ((Option)(ref arg.Option)).RconConnectionId == 0)
		{
			arg.ReplyWith("Must be an RCON connection to subscribe to server state");
			return;
		}
		bool flag = SetEventSubscriber(((Option)(ref arg.Option)).RconConnectionId);
		arg.ReplyWith(flag ? "Subscribed" : "Unsubscribed");
	}

	public static void Initialize()
	{
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Expected O, but got Unknown
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password.Length < 8)
		{
			Debug.Log((object)"\r\n*******************************************************\r\n**                                                   **\r\n** RCON password length is very insecure.            **\r\n** Support for passwords less than 8 characters may  **\r\n** be removed in the future.                         **\r\n**                                                   **\r\n*******************************************************\r\n");
		}
		switch (Password.ToLower())
		{
		case "changeme":
		case "abc123":
		case "qwerty":
		case "qwerty123":
		case "123456":
		case "000000":
		case "password123":
		case "password":
		case "":
			Debug.Log((object)"\r\n*******************************************************\r\n**                                                   **\r\n** RCON password is very insecure, RCON is disabled. **\r\n**                                                   **\r\n*******************************************************\r\n");
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			string serverFolder = Server.GetServerFolder("cfg");
			listenerNew.BansFile = serverFolder + "/rcon-bans.cfg";
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", CommandLine.GetSwitch("+rcon.ssl", (string)null));
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", CommandLine.GetSwitch("+rcon.sslpwd", (string)null));
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				Command item = JsonConvert.DeserializeObject<Command>(msg);
				item.Ip = ip;
				item.ConnectionId = id;
				Commands.Enqueue(item);
			};
			listenerNew.Start();
			Debug.Log((object)$"WebSocket RCON Started on {Ip}:{Port}");
		}
		else
		{
			listener = new RConListener();
			Debug.Log((object)("RCON Started on " + Port));
			Debug.Log((object)"\r\n*********************************************************************\r\n**                                                                 **\r\n** Source engine style TCP RCON is deprecated and will be removed. **\r\n** Please switch to Websocket RCON by setting rcon.web to true     **\r\n**                                                                 **\r\n*********************************************************************");
		}
	}

	public static void Shutdown()
	{
		if (listenerNew != null)
		{
			listenerNew.Shutdown();
			listenerNew = null;
		}
		if (listener != null)
		{
			listener.Shutdown();
			listener = null;
		}
	}

	public static void SendMessageToSubscribers(string message, int identifier = -1)
	{
		if (listenerNew != null)
		{
			Response response = default(Response);
			response.Identifier = identifier;
			response.Message = message;
			response.Type = LogType.Subscription;
			string text = JsonConvert.SerializeObject((object)response, (Formatting)1);
			listenerNew.SendMessageToSubscribers(text);
		}
	}

	public static void Broadcast(LogType type, object obj)
	{
		if (listenerNew != null)
		{
			string message = JsonConvert.SerializeObject(obj, (Formatting)1);
			Broadcast(type, message);
		}
	}

	public static void Broadcast(LogType type, string message)
	{
		if (listenerNew != null && !string.IsNullOrWhiteSpace(message))
		{
			Response response = default(Response);
			response.Identifier = -1;
			response.Message = message;
			response.Type = type;
			if (responseConnection < 0)
			{
				listenerNew.BroadcastMessage(JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
			else
			{
				listenerNew.SendMessage(responseConnection, JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
		}
	}

	public static void Update()
	{
		Command result;
		while (Commands.TryDequeue(out result))
		{
			OnCommand(result);
		}
		if (listener == null || lastRunTime + 0.02f >= Time.realtimeSinceStartup)
		{
			return;
		}
		lastRunTime = Time.realtimeSinceStartup;
		try
		{
			bannedAddresses.RemoveAll((BannedAddresses x) => x.banTime < Time.realtimeSinceStartup);
			listener.Cycle();
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)"Rcon Exception");
			Debug.LogException(ex);
		}
	}

	public static void BanIP(IPAddress addr, float seconds)
	{
		RCon.bannedAddresses.RemoveAll((BannedAddresses x) => x.addr == addr);
		BannedAddresses bannedAddresses = default(BannedAddresses);
		bannedAddresses.addr = addr;
		bannedAddresses.banTime = Time.realtimeSinceStartup + seconds;
	}

	public static bool IsBanned(IPAddress addr)
	{
		return bannedAddresses.Count((BannedAddresses x) => x.addr == addr && x.banTime > Time.realtimeSinceStartup) > 0;
	}

	private static void OnCommand(Command cmd)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			responseIdentifier = cmd.Identifier;
			responseConnection = cmd.ConnectionId;
			isInput = true;
			if (Print)
			{
				Debug.Log((object)("[rcon] " + cmd.Ip?.ToString() + ": " + cmd.Message));
			}
			isInput = false;
			timer.Restart();
			Option val = Option.Server;
			val = ((Option)(ref val)).Quiet();
			string text = ConsoleSystem.Run(((Option)(ref val)).WithRconId(cmd.ConnectionId), cmd.Message, Array.Empty<object>());
			timer.Stop();
			TimeSpan elapsed = timer.Elapsed;
			if (RconProfiler.mode > 0)
			{
				RconProfiler.ExecutionTime += elapsed;
			}
			if (elapsed > RuntimeProfiler.RconCommandWarningThreshold)
			{
				LagSpikeProfiler.RconCommand(timer.Elapsed, cmd.Message);
			}
			if (text != null)
			{
				OnMessage(text, string.Empty, (LogType)3);
			}
		}
		finally
		{
			responseIdentifier = 0;
			responseConnection = -1;
		}
	}

	private static void OnMessage(string message, string stacktrace, LogType type)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Invalid comparison between Unknown and I4
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Invalid comparison between Unknown and I4
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Invalid comparison between Unknown and I4
		if (!isInput && listenerNew != null)
		{
			Response response = default(Response);
			response.Identifier = responseIdentifier;
			response.Message = message;
			response.Stacktrace = stacktrace;
			response.Type = LogType.Generic;
			if ((int)type == 0 || (int)type == 4)
			{
				response.Type = LogType.Error;
			}
			if ((int)type == 1 || (int)type == 2)
			{
				response.Type = LogType.Warning;
			}
			if (responseConnection < 0)
			{
				listenerNew.BroadcastMessage(JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
			else
			{
				listenerNew.SendMessage(responseConnection, JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
		}
	}

	public static bool SetEventSubscriber(int optionRconConnectionId)
	{
		return listenerNew.AddOrRemoveEventListener(optionRconConnectionId);
	}
}


using System.Net;

public struct Command
{
	public IPAddress Ip;

	public int ConnectionId;

	public string Name;

	public string Message;

	public int Identifier;
}


public enum LogType
{
	Generic,
	Error,
	Warning,
	Chat,
	Report,
	ClientPerf,
	Subscription
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

public struct Response
{
	public string Message;

	public int Identifier;

	[JsonConverter(typeof(StringEnumConverter))]
	public LogType Type;

	public string Stacktrace;
}


using System.Net;

internal struct BannedAddresses
{
	public IPAddress addr;

	public float banTime;
}


public static class ReservedIdentifiers
{
	public const int PlayerPostionsUpdate = -64001;

	public const int FoundationsUpdate = -64002;
}


using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using UnityEngine;

internal class RConClient
{
	private Socket socket;

	private bool isAuthorised;

	private string connectionName;

	private int lastMessageID = -1;

	private bool runningConsoleCommand;

	private bool utf8Mode;

	internal RConClient(Socket cl)
	{
		socket = cl;
		socket.NoDelay = true;
		connectionName = socket.RemoteEndPoint.ToString();
	}

	internal bool IsValid()
	{
		return socket != null;
	}

	internal void Update()
	{
		if (socket == null)
		{
			return;
		}
		if (!socket.Connected)
		{
			Close("Disconnected");
			return;
		}
		int available = socket.Available;
		if (available < 14)
		{
			return;
		}
		if (available > 4096)
		{
			Close("overflow");
			return;
		}
		byte[] buffer = new byte[available];
		socket.Receive(buffer);
		using BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer, writable: false), utf8Mode ? Encoding.UTF8 : Encoding.ASCII);
		int num = binaryReader.ReadInt32();
		if (available < num)
		{
			Close("invalid packet");
			return;
		}
		lastMessageID = binaryReader.ReadInt32();
		int type = binaryReader.ReadInt32();
		string msg = ReadNullTerminatedString(binaryReader);
		ReadNullTerminatedString(binaryReader);
		if (!HandleMessage(type, msg))
		{
			Close("invalid packet");
		}
		else
		{
			lastMessageID = -1;
		}
	}

	internal bool HandleMessage(int type, string msg)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!isAuthorised)
		{
			return HandleMessage_UnAuthed(type, msg);
		}
		if (type == SERVERDATA_SWITCH_UTF8)
		{
			utf8Mode = true;
			return true;
		}
		if (type == SERVERDATA_EXECCOMMAND)
		{
			Debug.Log((object)("[RCON][" + connectionName + "] " + msg));
			runningConsoleCommand = true;
			ConsoleSystem.Run(Option.Server, msg, Array.Empty<object>());
			runningConsoleCommand = false;
			Reply(-1, SERVERDATA_RESPONSE_VALUE, "");
			return true;
		}
		if (type == SERVERDATA_RESPONSE_VALUE)
		{
			Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
			return true;
		}
		Debug.Log((object)("[RCON][" + connectionName + "] Unhandled: " + lastMessageID + " -> " + type + " -> " + msg));
		return false;
	}

	internal bool HandleMessage_UnAuthed(int type, string msg)
	{
		if (type != SERVERDATA_AUTH)
		{
			BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
			Close("Invalid Command - Not Authed");
			return false;
		}
		Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
		isAuthorised = Password == msg;
		if (!isAuthorised)
		{
			Reply(-1, SERVERDATA_AUTH_RESPONSE, "");
			BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
			Close("Invalid Password");
			return true;
		}
		Reply(lastMessageID, SERVERDATA_AUTH_RESPONSE, "");
		Debug.Log((object)("[RCON] Auth: " + connectionName));
		Output.OnMessage += Output_OnMessage;
		return true;
	}

	private void Output_OnMessage(string message, string stacktrace, LogType type)
	{
		if (isAuthorised && IsValid())
		{
			if (lastMessageID != -1 && runningConsoleCommand)
			{
				Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, message);
			}
			Reply(0, SERVERDATA_CONSOLE_LOG, message);
		}
	}

	internal void Reply(int id, int type, string msg)
	{
		MemoryStream memoryStream = new MemoryStream(1024);
		using BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (utf8Mode)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(msg);
			int value = 10 + bytes.Length;
			binaryWriter.Write(value);
			binaryWriter.Write(id);
			binaryWriter.Write(type);
			binaryWriter.Write(bytes);
		}
		else
		{
			int value2 = 10 + msg.Length;
			binaryWriter.Write(value2);
			binaryWriter.Write(id);
			binaryWriter.Write(type);
			foreach (char c in msg)
			{
				binaryWriter.Write((sbyte)c);
			}
		}
		binaryWriter.Write((sbyte)0);
		binaryWriter.Write((sbyte)0);
		binaryWriter.Flush();
		try
		{
			socket.Send(memoryStream.GetBuffer(), (int)memoryStream.Position, SocketFlags.None);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("Error sending rcon reply: " + ex));
			Close("Exception");
		}
	}

	internal void Close(string strReasn)
	{
		Output.OnMessage -= Output_OnMessage;
		if (socket != null)
		{
			Debug.Log((object)("[RCON][" + connectionName + "] Disconnected: " + strReasn));
			socket.Close();
			socket = null;
		}
	}

	internal string ReadNullTerminatedString(BinaryReader read)
	{
		string text = "";
		do
		{
			if (read.BaseStream.Position == read.BaseStream.Length)
			{
				return "";
			}
			char c = read.ReadChar();
			if (c == '\0')
			{
				return text;
			}
			text += c;
		}
		while (text.Length <= 8192);
		return string.Empty;
	}
}


using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using Oxide.Core;
using UnityEngine;

internal class RConListener
{
	private TcpListener server;

	private List<RConClient> clients = new List<RConClient>();

	internal RConListener()
	{
		IPAddress address = IPAddress.Any;
		if (!IPAddress.TryParse(Ip, out address))
		{
			address = IPAddress.Any;
		}
		server = new TcpListener(address, Port);
		try
		{
			server.Start();
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("Couldn't start RCON Listener: " + ex.Message));
			server = null;
		}
	}

	internal void Shutdown()
	{
		if (server != null)
		{
			server.Stop();
			server = null;
		}
	}

	internal void Cycle()
	{
		if (server != null)
		{
			ProcessConnections();
			RemoveDeadClients();
			UpdateClients();
		}
	}

	private void ProcessConnections()
	{
		if (!server.Pending())
		{
			return;
		}
		Socket socket = server.AcceptSocket();
		if (socket != null)
		{
			IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
			if (Interface.CallHook("OnRconConnection", (object)iPEndPoint.Address) != null)
			{
				socket.Close();
			}
			else if (IsBanned(iPEndPoint.Address))
			{
				Debug.Log((object)("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString()));
				socket.Close();
			}
			else
			{
				clients.Add(new RConClient(socket));
			}
		}
	}

	private void UpdateClients()
	{
		foreach (RConClient client in clients)
		{
			client.Update();
		}
	}

	private void RemoveDeadClients()
	{
		clients.RemoveAll((RConClient x) => !x.IsValid());
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class VirtualScroll : MonoBehaviour
{
	public interface IDataSource
	{
		int GetItemCount();

		void SetItemData(int i, GameObject obj);
	}

	public interface IVisualUpdate
	{
		void OnVisualUpdate(int i, GameObject obj);
	}

	public int ItemHeight = 40;

	public int ItemSpacing = 10;

	public RectOffset Padding;

	[Tooltip("Optional, we'll try to GetComponent IDataSource from this object on awake")]
	public GameObject DataSourceObject;

	public GameObject SourceObject;

	public ScrollRect ScrollRect;

	public RectTransform OverrideContentRoot;

	private IDataSource dataSource;

	private Dictionary<int, GameObject> ActivePool = new Dictionary<int, GameObject>();

	private Stack<GameObject> InactivePool = new Stack<GameObject>();

	private int BlockHeight => ItemHeight + ItemSpacing;

	public void Awake()
	{
		((UnityEvent<Vector2>)(object)ScrollRect.onValueChanged).AddListener((UnityAction<Vector2>)OnScrollChanged);
		if ((Object)(object)DataSourceObject != (Object)null)
		{
			SetDataSource(DataSourceObject.GetComponent<IDataSource>());
		}
	}

	public void OnDestroy()
	{
		((UnityEvent<Vector2>)(object)ScrollRect.onValueChanged).RemoveListener((UnityAction<Vector2>)OnScrollChanged);
	}

	private void OnScrollChanged(Vector2 pos)
	{
		Rebuild();
	}

	public void SetDataSource(IDataSource source, bool forceRebuild = false)
	{
		if (dataSource != source || forceRebuild)
		{
			dataSource = source;
			FullRebuild();
		}
	}

	public void FullRebuild()
	{
		int[] array = ActivePool.Keys.ToArray();
		foreach (int key in array)
		{
			Recycle(key);
		}
		Rebuild();
	}

	public void DataChanged()
	{
		foreach (KeyValuePair<int, GameObject> item in ActivePool)
		{
			dataSource.SetItemData(item.Key, item.Value);
		}
		Rebuild();
	}

	protected virtual float GetContentHeight(int itemCount)
	{
		return BlockHeight * itemCount - ItemSpacing + Padding.top + Padding.bottom;
	}

	protected virtual float SetCanvasSize(int items)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		object obj = (((Object)(object)OverrideContentRoot != (Object)null) ? ((object)OverrideContentRoot) : ((object)/*isinst with value type is only supported in some contexts*/));
		((RectTransform)obj).SetSizeWithCurrentAnchors((Axis)1, GetContentHeight(items));
		return ((RectTransform)obj).anchoredPosition.y;
	}

	public void Rebuild()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (dataSource == null)
		{
			return;
		}
		int itemCount = dataSource.GetItemCount();
		float num = SetCanvasSize(itemCount);
		Rect rect = ScrollRect.viewport.rect;
		int num2 = Mathf.Max(2, Mathf.CeilToInt(((Rect)(ref rect)).height / (float)BlockHeight));
		int num3 = Mathf.FloorToInt((num - (float)Padding.top) / (float)BlockHeight);
		int num4 = num3 + num2;
		RecycleOutOfRange(num3, num4);
		for (int i = num3; i <= num4; i++)
		{
			if (i >= 0 && i < itemCount)
			{
				BuildItem(i);
			}
		}
	}

	public void Update()
	{
		if (!(dataSource is IVisualUpdate visualUpdate))
		{
			return;
		}
		foreach (KeyValuePair<int, GameObject> item in ActivePool)
		{
			visualUpdate.OnVisualUpdate(item.Key, item.Value);
		}
	}

	private void RecycleOutOfRange(int startVisible, float endVisible)
	{
		int[] array = (from x in ActivePool.Keys
			where x < startVisible || (float)x > endVisible
			select (x)).ToArray();
		foreach (int key in array)
		{
			Recycle(key);
		}
	}

	private void Recycle(int key)
	{
		GameObject val = ActivePool[key];
		val.SetActive(false);
		ActivePool.Remove(key);
		InactivePool.Push(val);
	}

	private void BuildItem(int i)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		if (i >= 0 && !ActivePool.ContainsKey(i))
		{
			GameObject item = GetItem();
			item.SetActive(true);
			dataSource.SetItemData(i, item);
			Transform transform = item.transform;
			Transform obj = ((transform is RectTransform) ? transform : null);
			((RectTransform)obj).anchorMin = new Vector2(0f, 1f);
			((RectTransform)obj).anchorMax = new Vector2(1f, 1f);
			((RectTransform)obj).pivot = new Vector2(0.5f, 1f);
			((RectTransform)obj).offsetMin = new Vector2(0f, 0f);
			((RectTransform)obj).offsetMax = new Vector2(0f, (float)ItemHeight);
			((RectTransform)obj).sizeDelta = new Vector2((float)((Padding.left + Padding.right) * -1), (float)ItemHeight);
			((RectTransform)obj).anchoredPosition = new Vector2((float)(Padding.left - Padding.right) * 0.5f, (float)(-1 * (i * BlockHeight + Padding.top)));
			ActivePool[i] = item;
		}
	}

	private GameObject GetItem()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (InactivePool.Count == 0)
		{
			GameObject val = Object.Instantiate<GameObject>(SourceObject);
			val.transform.SetParent((Transform)(((Object)(object)OverrideContentRoot != (Object)null) ? ((object)OverrideContentRoot) : ((object)((Transform)ScrollRect.viewport).GetChild(0))), false);
			val.transform.localScale = Vector3.one;
			val.SetActive(false);
			InactivePool.Push(val);
		}
		return InactivePool.Pop();
	}
}


using UnityEngine;

public interface IDataSource
{
	int GetItemCount();

	void SetItemData(int i, GameObject obj);
}


using UnityEngine;

public interface IVisualUpdate
{
	void OnVisualUpdate(int i, GameObject obj);
}


using Facepunch;
using Unity.Collections;
using UnityEngine;

public class FPNativeList<T> : IPooled where T : struct
{
	private NativeArray<T> _array;

	private int _length;

	private int _capacity;

	public NativeArray<T> Array => _array;

	public int Count => _length;

	public int Capacity => _capacity;

	public T this[int index]
	{
		get
		{
			return _array[index];
		}
		set
		{
			_array[index] = value;
		}
	}

	public void Add(T item)
	{
		EnsureCapacity(_length + 1);
		_array[_length++] = item;
	}

	public void RemoveLast()
	{
		_length--;
		_array[_length] = default(T);
	}

	public void SetLength(int newLength)
	{
		if (newLength > _length)
		{
			EnsureCapacity(newLength);
		}
		else
		{
			_length = newLength;
		}
	}

	public void Clear()
	{
		for (int i = 0; i < _array.Length; i++)
		{
			_array[i] = default(T);
		}
		_length = 0;
	}

	public void Resize(int count)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (_array.IsCreated)
		{
			_array.Dispose();
		}
		_array = new NativeArray<T>(count, (Allocator)4, (NativeArrayOptions)1);
		_length = count;
	}

	public void EnsureCapacity(int requiredCapacity)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (!_array.IsCreated || _array.Length < requiredCapacity)
		{
			_capacity = Mathf.Max(_array.Length * 2, requiredCapacity);
			NativeArray<T> array = default(NativeArray<T>);
			array..ctor(_capacity, (Allocator)4, (NativeArrayOptions)1);
			if (_array.IsCreated)
			{
				_array.CopyTo(array.GetSubArray(0, _array.Length));
				_array.Dispose();
			}
			_array = array;
		}
	}

	public void EnterPool()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (_array.IsCreated)
		{
			_array.Dispose();
		}
		_array = default(NativeArray<T>);
		_length = 0;
		_capacity = 0;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Flexbox;
using UnityEngine;
using UnityEngine.Serialization;

[DisallowMultipleComponent]
[RequireComponent(typeof(RectTransform))]
[ExecuteAlways]
public class FlexGridsElement : FlexElementBase
{
	private struct GridSlot
	{
		public IFlexNode Child;

		public int X;

		public int Y;

		public int SpanX;

		public int SpanY;
	}

	[Tooltip("Spacing to add from this elements borders to where children are laid out.")]
	public FlexPadding Padding;

	[Min(0f)]
	[Tooltip("Spacing to add between each child flex item.")]
	public float Gap;

	[Min(1f)]
	[Tooltip("The number of columns to use when using a fixed number of columns.")]
	public int ColumnCount = 1;

	[FormerlySerializedAs("ColumnWidth")]
	[Tooltip("The minimum width of each column when not using a fixed number of columns.")]
	[Min(1f)]
	public int ColumnMinWidth = 100;

	public bool FixedRowCount;

	[Min(1f)]
	public int RowCount = 1;

	[Min(1f)]
	public int RowMinHeight = 100;

	public bool BestFitOrdering;

	public bool[,] _gridMapBuffer = new bool[32, 32];

	public int _gridMapColumns = 32;

	public int _gridMapRows = 32;

	public void EnsureGridMapSize(int columns, int rows)
	{
		if (_gridMapBuffer == null || _gridMapColumns < columns || _gridMapRows < rows)
		{
			_gridMapBuffer = new bool[columns, rows];
			_gridMapColumns = columns;
			_gridMapRows = rows;
		}
		else
		{
			Array.Clear(_gridMapBuffer, 0, _gridMapBuffer.Length);
		}
	}

	protected override void MeasureHorizontalImpl()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = Mathf.Min(ColumnCount, Mathf.Max(1, base.Children.Count));
		num = (float)(num2 * ColumnMinWidth) + (float)Mathf.Max(num2 - 1, 0) * Gap;
		foreach (IFlexNode child in base.Children)
		{
			if (child.IsDirty)
			{
				child.MeasureHorizontal();
			}
		}
		float num3 = ((base.Basis.HasValue && (int)base.Basis.Unit == 0) ? base.Basis.Value : 0f);
		float num4 = ((base.MinWidth.HasValue && (int)base.MinWidth.Unit == 0) ? base.MinWidth.Value : 0f);
		float num5 = ((base.MaxWidth.HasValue && (int)base.MaxWidth.Unit == 0) ? base.MaxWidth.Value : float.PositiveInfinity);
		float num6 = Padding.left + Padding.right;
		base.PrefWidth = Mathf.Clamp(num + num6, Mathf.Max(num4, num3), num5);
	}

	protected override void LayoutHorizontalImpl(float maxWidth, float maxHeight)
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b6: Unknown result type (might be due to invalid IL or missing references)
		float num = maxWidth - Padding.left - Padding.right;
		float num2 = maxHeight - Padding.top - Padding.bottom;
		float num3 = (num - Gap * (float)(ColumnCount - 1)) / (float)ColumnCount;
		float num4 = RowMinHeight;
		if (BestFitOrdering)
		{
			ReOrderChildren(num, num3);
		}
		int num5 = (FixedRowCount ? RowCount : 50);
		EnsureGridMapSize(ColumnCount, num5);
		Array.Clear(_gridMapBuffer, 0, _gridMapBuffer.Length);
		List<GridSlot> list = Pool.Get<List<GridSlot>>();
		foreach (IFlexNode child in base.Children)
		{
			FlexLength minWidth = child.MinWidth;
			int num6 = Mathf.Clamp(Mathf.CeilToInt(FlexElementBase.CalculateLengthValue(ref minWidth, num, 0f) / (num3 + Gap)), 1, ColumnCount);
			minWidth = child.MinHeight;
			int num7 = Mathf.Clamp(Mathf.CeilToInt(FlexElementBase.CalculateLengthValue(ref minWidth, num2, 0f) / (num4 + Gap)), 1, num5);
			bool flag = false;
			for (int i = 0; i < num5; i++)
			{
				for (int j = 0; j <= ColumnCount - num6; j++)
				{
					if (CanPlaceAt(j, i, num6, num7, _gridMapBuffer))
					{
						MarkUsed(j, i, num6, num7, _gridMapBuffer);
						list.Add(new GridSlot
						{
							Child = child,
							X = j,
							Y = i,
							SpanX = num6,
							SpanY = num7
						});
						flag = true;
						break;
					}
				}
				if (flag)
				{
					break;
				}
			}
		}
		foreach (GridSlot item in list)
		{
			RectTransform transform = item.Child.Transform;
			float num8 = Padding.left + (float)item.X * (num3 + Gap);
			float num9 = Padding.top + (float)item.Y * (num4 + Gap);
			float num10 = (float)item.SpanX * num3 + (float)(item.SpanX - 1) * Gap;
			float num11 = (float)item.SpanY * num4 + (float)(item.SpanY - 1) * Gap;
			item.Child.LayoutHorizontal(num10, float.PositiveInfinity);
			item.Child.LayoutVertical(float.PositiveInfinity, num11);
			transform.anchoredPosition = new Vector2(num8, 0f - num9);
			transform.sizeDelta = new Vector2(num10, num11);
		}
		Pool.FreeUnmanaged<GridSlot>(ref list);
	}

	public static bool CanPlaceAt(int xPos, int yPos, int sizeX, int sizeY, bool[,] grid)
	{
		for (int i = 0; i < sizeY; i++)
		{
			for (int j = 0; j < sizeX; j++)
			{
				if (grid[xPos + j, yPos + i])
				{
					return false;
				}
			}
		}
		return true;
	}

	public static void MarkUsed(int xPos, int yPos, int sizeX, int sizeY, bool[,] grid)
	{
		for (int i = 0; i < sizeY; i++)
		{
			for (int j = 0; j < sizeX; j++)
			{
				grid[xPos + j, yPos + i] = true;
			}
		}
	}

	private void ReOrderChildren(float innerWidth, float columnWidth)
	{
		List<GridSlot> list = base.Children.Select(delegate(IFlexNode child)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			FlexLength minWidth = child.MinWidth;
			float num = FlexElementBase.CalculateLengthValue(ref minWidth, innerWidth, 0f);
			minWidth = child.MaxWidth;
			float num2 = FlexElementBase.CalculateLengthValue(ref minWidth, innerWidth, float.PositiveInfinity);
			float num3 = Mathf.Clamp(columnWidth, num, num2);
			minWidth = child.MinHeight;
			float num4 = FlexElementBase.CalculateLengthValue(ref minWidth, float.PositiveInfinity, 0f);
			float num5 = Mathf.Clamp((float)RowMinHeight, num4, float.PositiveInfinity);
			int spanX = Mathf.Clamp(Mathf.CeilToInt((num3 + Gap) / (columnWidth + Gap)), 1, ColumnCount);
			int spanY = Mathf.Clamp(Mathf.CeilToInt((num5 + Gap) / ((float)RowMinHeight + Gap)), 1, 64);
			GridSlot result = default(GridSlot);
			result.Child = child;
			result.SpanX = spanX;
			result.SpanY = spanY;
			return result;
		}).ToList();
		list.Sort(delegate(GridSlot a, GridSlot b)
		{
			int value = a.SpanX * a.SpanY;
			return (b.SpanX * b.SpanY).CompareTo(value);
		});
		List<IFlexNode> list2 = Pool.Get<List<IFlexNode>>();
		while (list.Count > 0)
		{
			int num6 = ColumnCount;
			int num7 = 0;
			while (num7 < list.Count)
			{
				if (list[num7].SpanX <= num6)
				{
					list2.Add(list[num7].Child);
					num6 -= list[num7].SpanX;
					list.RemoveAt(num7);
				}
				else
				{
					num7++;
				}
			}
		}
		for (int i = 0; i < list2.Count; i++)
		{
			((Transform)list2[i].Transform).SetSiblingIndex(i);
		}
		Pool.FreeUnmanaged<IFlexNode>(ref list2);
	}

	protected override void MeasureVerticalImpl()
	{
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		float num;
		if (FixedRowCount)
		{
			num = (float)(RowCount * RowMinHeight) + (float)Mathf.Max(RowCount - 1, 0) * Gap;
		}
		else
		{
			int[] array = new int[ColumnCount];
			int num2 = 0;
			foreach (IFlexNode child in base.Children)
			{
				if (child.IsDirty)
				{
					child.MeasureVertical();
				}
				FlexLength minWidth = child.MinWidth;
				float num3 = FlexElementBase.CalculateLengthValue(ref minWidth, 0f, 0f);
				minWidth = child.MinHeight;
				float num4 = FlexElementBase.CalculateLengthValue(ref minWidth, 0f, 0f);
				int num5 = Mathf.Clamp(Mathf.CeilToInt((num3 + Gap) / ((float)ColumnMinWidth + Gap)), 1, ColumnCount);
				int num6 = Mathf.Clamp(Mathf.CeilToInt((num4 + Gap) / ((float)RowMinHeight + Gap)), 1, 64);
				int num7 = -1;
				int num8 = int.MaxValue;
				for (int i = 0; i <= ColumnCount - num5; i++)
				{
					int num9 = 0;
					for (int j = 0; j < num5; j++)
					{
						num9 = Mathf.Max(num9, array[i + j]);
					}
					if (num9 < num8)
					{
						num8 = num9;
						num7 = i;
					}
				}
				if (num7 >= 0)
				{
					for (int k = 0; k < num5; k++)
					{
						array[num7 + k] = num8 + num6;
					}
					num2 = Mathf.Max(num2, num8 + num6);
				}
			}
			num = (float)(num2 * RowMinHeight) + (float)Mathf.Max(num2 - 1, 0) * Gap;
		}
		float num10 = ((base.Basis.HasValue && (int)base.Basis.Unit == 0) ? base.Basis.Value : 0f);
		float num11 = ((base.MinHeight.HasValue && (int)base.MinHeight.Unit == 0) ? base.MinHeight.Value : 0f);
		float num12 = ((base.MaxHeight.HasValue && (int)base.MaxHeight.Unit == 0) ? base.MaxHeight.Value : float.PositiveInfinity);
		float num13 = Padding.top + Padding.bottom;
		base.PrefHeight = Mathf.Clamp(num + num13, Mathf.Max(num11, num10), num12);
	}

	protected override void LayoutVerticalImpl(float maxWidth, float maxHeight)
	{
	}
}


private struct GridSlot
{
	public IFlexNode Child;

	public int X;

	public int Y;

	public int SpanX;

	public int SpanY;
}


using Facepunch.UI;
using UnityEngine;

public class ESPCanvas : SingletonComponent<ESPCanvas>
{
	[Tooltip("Amount of times per second we should update the visible panels")]
	public float RefreshRate = 5f;

	[Tooltip("This object will be duplicated in place")]
	public ESPPlayerInfo Source;

	[Header("Nameplate Properties")]
	public Gradient gradientNormal;

	public Gradient gradientTeam;

	public AccessibilityColourCollection TeamLookup;

	public AccessibilityColourCollection ClanLookup;

	public AccessibilityColourCollection AllyLookup;

	public AccessibilityColourCollection EnemyLookup;

	private static int NameplateCount = 32;

	[ClientVar(ClientAdmin = true)]
	public static float OverrideMaxDisplayDistance = 0f;

	[ClientVar(ClientAdmin = true)]
	public static bool DisableOcclusionChecks = false;

	[ClientVar(ClientAdmin = true)]
	public static bool ShowHealth = false;

	[ClientVar(ClientAdmin = true)]
	public static bool ColourCodeTeams = false;

	[ClientVar(ClientAdmin = true)]
	public static bool UseRandomTeamColours = false;

	[ClientVar(ClientAdmin = true, Help = "Max amount of nameplates to show at once")]
	public static int MaxNameplates
	{
		get
		{
			return NameplateCount;
		}
		set
		{
			NameplateCount = Mathf.Clamp(value, 16, 150);
		}
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class ESPPlayerInfo : MonoBehaviour
{
	public Vector3 WorldOffset;

	public RustText Text;

	public TextMeshProUGUI[] TextElements;

	public RustIcon Loading;

	public GameObject ClanElement;

	public RustText ClanText;

	public CanvasGroup group;

	public QueryVis visCheck;

	public BasePlayer Entity { get; set; }
}


using Facepunch.NativeMeshSimplification;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CopyBackJob : IJob
{
	[WriteOnly]
	public NativeList<float3> DstVertices;

	[WriteOnly]
	public NativeList<int> DstIndices;

	[ReadOnly]
	public NativeList<NativeMeshSimplifier.Triangle> SrcTriangles;

	[ReadOnly]
	public NativeList<NativeMeshSimplifier.Vertex> SrcVertices;

	public void Execute()
	{
		DstVertices.Clear();
		DstVertices.SetCapacity(SrcVertices.Length);
		for (int i = 0; i < SrcVertices.Length; i++)
		{
			ref NativeList<float3> dstVertices = ref DstVertices;
			NativeMeshSimplifier.Vertex vertex = SrcVertices[i];
			dstVertices.Add(ref vertex.p);
		}
		DstIndices.Clear();
		DstIndices.SetCapacity(SrcTriangles.Length * 3);
		for (int j = 0; j < SrcTriangles.Length; j++)
		{
			ref NativeList<int> dstIndices = ref DstIndices;
			NativeMeshSimplifier.Triangle triangle = SrcTriangles[j];
			int num = ((int3)(ref triangle.vIndex))[0];
			dstIndices.Add(ref num);
			ref NativeList<int> dstIndices2 = ref DstIndices;
			triangle = SrcTriangles[j];
			num = ((int3)(ref triangle.vIndex))[1];
			dstIndices2.Add(ref num);
			ref NativeList<int> dstIndices3 = ref DstIndices;
			triangle = SrcTriangles[j];
			num = ((int3)(ref triangle.vIndex))[2];
			dstIndices3.Add(ref num);
		}
	}
}


using System;
using System.Diagnostics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

public static class NativeListAccessExtensions
{
	[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
	private static void ArrayBoundsCheck<T>(in NativeList<T> list, int i) where T : unmanaged
	{
		if (i < 0 || i >= list.Length)
		{
			throw new IndexOutOfRangeException();
		}
	}

	public unsafe static ref T Get<T>(this in NativeList<T> list, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return ref NativeListUnsafeUtility.GetUnsafePtr<T>(list)[index];
	}

	public unsafe static ref readonly T GetReadonly<T>(this in NativeList<T> list, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return ref NativeListUnsafeUtility.GetUnsafeReadOnlyPtr<T>(list)[index];
	}
}


using Facepunch.NativeMeshSimplification;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct PopulateArraysJob : IJob
{
	[ReadOnly]
	public NativeList<float3> VerticesIn;

	[ReadOnly]
	public NativeList<int> IndicesIn;

	public NativeList<NativeMeshSimplifier.Triangle> TrianglesOut;

	public NativeList<NativeMeshSimplifier.Vertex> VerticesOut;

	public void Execute()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		if (VerticesOut.Capacity < VerticesIn.Length)
		{
			VerticesOut.SetCapacity(VerticesIn.Length);
		}
		VerticesOut.Clear();
		for (int i = 0; i < VerticesIn.Length; i++)
		{
			ref NativeList<NativeMeshSimplifier.Vertex> verticesOut = ref VerticesOut;
			NativeMeshSimplifier.Vertex vertex = new NativeMeshSimplifier.Vertex
			{
				p = VerticesIn[i]
			};
			verticesOut.Add(ref vertex);
		}
		if (TrianglesOut.Capacity < IndicesIn.Length / 3)
		{
			TrianglesOut.SetCapacity(IndicesIn.Length / 3);
		}
		TrianglesOut.Clear();
		for (int j = 0; j < IndicesIn.Length; j += 3)
		{
			ref NativeList<NativeMeshSimplifier.Triangle> trianglesOut = ref TrianglesOut;
			NativeMeshSimplifier.Triangle triangle = new NativeMeshSimplifier.Triangle
			{
				vIndex = new int3(IndicesIn[j], IndicesIn[j + 1], IndicesIn[j + 2])
			};
			trianglesOut.Add(ref triangle);
		}
	}
}


using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Facepunch.NativeMeshSimplification;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct SimplifyMeshJob : IJob
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	private struct ProfilerMarkerStub
	{
		[BurstDiscard]
		public void Begin()
		{
		}

		[BurstDiscard]
		public void End()
		{
		}
	}

	public int MaxIterations;

	public float ReductionTarget;

	public int Aggressiveness;

	public NativeList<NativeMeshSimplifier.Triangle> Triangles;

	public NativeList<NativeMeshSimplifier.Vertex> Vertices;

	public NativeList<NativeMeshSimplifier.Ref> Refs;

	private static readonly ProfilerMarkerStub k_Iteration;

	private static readonly ProfilerMarkerStub k_UpdateMesh;

	private static readonly ProfilerMarkerStub k_FirstUpdate;

	private static readonly ProfilerMarkerStub k_CompactMesh;

	private static readonly ProfilerMarkerStub k_Flipped;

	private static readonly ProfilerMarkerStub k_UpdateTriangles;

	private static readonly ProfilerMarkerStub k_MemCpy;

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		Refs.Clear();
		NativeList<int> deleted = default(NativeList<int>);
		deleted..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		NativeList<int> deleted2 = default(NativeList<int>);
		deleted2..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		int deletedTriangles = 0;
		int length = Triangles.Length;
		int num = (int)((float)length * ReductionTarget);
		NativeSlice<NativeMeshSimplifier.Ref> val2 = default(NativeSlice<NativeMeshSimplifier.Ref>);
		NativeSlice<NativeMeshSimplifier.Ref> val3 = default(NativeSlice<NativeMeshSimplifier.Ref>);
		for (int i = 0; i < MaxIterations; i++)
		{
			k_Iteration.Begin();
			if (length - deletedTriangles <= num)
			{
				k_Iteration.End();
				break;
			}
			if (i % 5 == 0)
			{
				k_UpdateMesh.Begin();
				UpdateMesh(i);
				k_UpdateMesh.End();
			}
			for (int j = 0; j < Triangles.Length; j++)
			{
				NativeListAccessExtensions.Get(in Triangles, j).dirty = false;
			}
			float num2 = 1E-09f * math.pow((float)i + 3f, (float)Aggressiveness);
			for (int k = 0; k < Triangles.Length; k++)
			{
				ref readonly NativeMeshSimplifier.Triangle @readonly = ref NativeListAccessExtensions.GetReadonly(in Triangles, k);
				float4 err = @readonly.err;
				if (math.any(new bool3(((float4)(ref err))[3] > num2, @readonly.deleted, @readonly.dirty)))
				{
					continue;
				}
				for (int l = 0; l < 3; l++)
				{
					err = @readonly.err;
					if (((float4)(ref err))[l] > num2)
					{
						continue;
					}
					int3 vIndex = @readonly.vIndex;
					int num3 = ((int3)(ref vIndex))[l];
					vIndex = @readonly.vIndex;
					int num4 = ((int3)(ref vIndex))[(l + 1) % 3];
					ref NativeMeshSimplifier.Vertex reference = ref NativeListAccessExtensions.Get(in Vertices, num3);
					ref readonly NativeMeshSimplifier.Vertex readonly2 = ref NativeListAccessExtensions.GetReadonly(in Vertices, num4);
					if (reference.border != readonly2.border)
					{
						continue;
					}
					CalculateError(in reference, in readonly2, out var pResult);
					deleted.Length = reference.tCount;
					deleted2.Length = readonly2.tCount;
					if (Flipped(pResult, num4, in reference, ref deleted) || Flipped(pResult, num3, in readonly2, ref deleted2))
					{
						continue;
					}
					reference.p = pResult;
					reference.q = readonly2.q + reference.q;
					int length2 = Refs.Length;
					k_UpdateTriangles.Begin();
					UpdateTriangles(num3, in reference, in deleted, ref deletedTriangles);
					UpdateTriangles(num3, in readonly2, in deleted2, ref deletedTriangles);
					k_UpdateTriangles.End();
					int num5 = Refs.Length - length2;
					if (num5 <= reference.tCount)
					{
						if (num5 > 0)
						{
							k_MemCpy.Begin();
							NativeArray<NativeMeshSimplifier.Ref> val = Refs.AsArray();
							val2..ctor(val, reference.tStart, num5);
							val3..ctor(val, length2, num5);
							val2.CopyFrom(val3);
							k_MemCpy.End();
						}
					}
					else
					{
						reference.tStart = length2;
					}
					reference.tCount = num5;
					break;
				}
				if (length - deletedTriangles <= num)
				{
					break;
				}
			}
			k_Iteration.End();
		}
		k_CompactMesh.Begin();
		CompactMesh();
		k_CompactMesh.End();
		deleted.Dispose();
		deleted2.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float VertexError(in NativeMeshSimplifier.SymmetricMatrix q, in float3 v)
	{
		float x = v.x;
		float y = v.y;
		float z = v.z;
		return q[0] * x * x + 2f * q[1] * x * y + 2f * q[2] * x * z + 2f * q[3] * x + q[4] * y * y + 2f * q[5] * y * z + 2f * q[6] * y + q[7] * z * z + 2f * q[8] * z + q[9];
	}

	private float CalculateError(int idV1, int idV2)
	{
		float3 pResult;
		return CalculateError(in NativeListAccessExtensions.Get(in Vertices, idV1), in NativeListAccessExtensions.Get(in Vertices, idV2), out pResult);
	}

	private float CalculateError(in NativeMeshSimplifier.Vertex v1, in NativeMeshSimplifier.Vertex v2, out float3 pResult)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		pResult = default(float3);
		NativeMeshSimplifier.SymmetricMatrix q = v1.q + v2.q;
		bool flag = v1.border & v2.border;
		float num = 0f;
		float num2 = q.Det(0, 1, 2, 1, 4, 5, 2, 5, 7);
		if (num2 != 0f && !flag)
		{
			float num3 = math.rcp(num2);
			pResult.x = (0f - num3) * q.Det(1, 2, 3, 4, 5, 6, 5, 7, 8);
			pResult.y = num3 * q.Det(0, 2, 3, 1, 5, 6, 2, 7, 8);
			pResult.z = (0f - num3) * q.Det(0, 1, 3, 1, 4, 6, 2, 5, 8);
			num = VertexError(in q, in pResult);
		}
		else
		{
			float3 v3 = v1.p;
			float3 v4 = v2.p;
			float3 v5 = (v3 + v4) * 0.5f;
			float num4 = VertexError(in q, in v3);
			float num5 = VertexError(in q, in v4);
			float num6 = VertexError(in q, in v5);
			num = math.min(num4, math.min(num5, num6));
			if (num4 == num)
			{
				pResult = v3;
			}
			if (num5 == num)
			{
				pResult = v4;
			}
			if (num6 == num)
			{
				pResult = v5;
			}
		}
		return num;
	}

	private bool Flipped(float3 p, int i1, in NativeMeshSimplifier.Vertex v0, ref NativeList<int> deleted)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		k_Flipped.Begin();
		for (int j = 0; j < v0.tCount; j++)
		{
			ref readonly NativeMeshSimplifier.Ref @readonly = ref NativeListAccessExtensions.GetReadonly(in Refs, v0.tStart + j);
			ref readonly NativeMeshSimplifier.Triangle readonly2 = ref NativeListAccessExtensions.GetReadonly(in Triangles, @readonly.tId);
			if (readonly2.deleted)
			{
				continue;
			}
			int tVertex = @readonly.tVertex;
			int3 vIndex = readonly2.vIndex;
			int num = ((int3)(ref vIndex))[(tVertex + 1) % 3];
			vIndex = readonly2.vIndex;
			int num2 = ((int3)(ref vIndex))[(tVertex + 2) % 3];
			if (num == i1 || num2 == i1)
			{
				deleted[j] = 1;
				continue;
			}
			float3 val = Vertices[num].p - p;
			float3 val2 = Vertices[num2].p - p;
			float3 val3 = math.cross(val, val2);
			if (math.lengthsq(val3) == 0f)
			{
				k_Flipped.End();
				return true;
			}
			float3 val4 = math.normalize(val3);
			deleted[j] = 0;
			if (math.dot(val4, readonly2.n) < 0.2f)
			{
				k_Flipped.End();
				return true;
			}
		}
		k_Flipped.End();
		return false;
	}

	private void UpdateTriangles(int i0, in NativeMeshSimplifier.Vertex v, in NativeList<int> deleted, ref int deletedTriangles)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		for (int j = 0; j < v.tCount; j++)
		{
			ref readonly NativeMeshSimplifier.Ref @readonly = ref NativeListAccessExtensions.GetReadonly(in Refs, v.tStart + j);
			ref NativeMeshSimplifier.Triangle reference = ref NativeListAccessExtensions.Get(in Triangles, @readonly.tId);
			if (!reference.deleted)
			{
				if (deleted[j] > 0)
				{
					reference.deleted = true;
					deletedTriangles++;
					continue;
				}
				ref readonly NativeMeshSimplifier.Vertex readonly2 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference.vIndex))[0]);
				ref readonly NativeMeshSimplifier.Vertex readonly3 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference.vIndex))[1]);
				ref readonly NativeMeshSimplifier.Vertex readonly4 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference.vIndex))[2]);
				((int3)(ref reference.vIndex))[@readonly.tVertex] = i0;
				reference.dirty = true;
				((float4)(ref reference.err))[0] = CalculateError(in readonly2, in readonly3, out var pResult);
				((float4)(ref reference.err))[1] = CalculateError(in readonly3, in readonly4, out pResult);
				((float4)(ref reference.err))[2] = CalculateError(in readonly4, in readonly2, out pResult);
				((float4)(ref reference.err))[3] = math.cmin(((float4)(ref reference.err)).xyz);
				Refs.Add(ref @readonly);
			}
		}
	}

	private void UpdateMesh(int iteration)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0434: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = iteration == 0;
		if (!flag)
		{
			int length = 0;
			for (int i = 0; i < Triangles.Length; i++)
			{
				ref readonly NativeMeshSimplifier.Triangle @readonly = ref NativeListAccessExtensions.GetReadonly(in Triangles, i);
				if (!@readonly.deleted)
				{
					Triangles[length++] = @readonly;
				}
			}
			Triangles.Length = length;
		}
		for (int j = 0; j < Vertices.Length; j++)
		{
			ref NativeMeshSimplifier.Vertex reference = ref NativeListAccessExtensions.Get(in Vertices, j);
			reference.tStart = 0;
			reference.tCount = 0;
		}
		int3 vIndex;
		for (int k = 0; k < Triangles.Length; k++)
		{
			ref readonly NativeMeshSimplifier.Triangle readonly2 = ref NativeListAccessExtensions.GetReadonly(in Triangles, k);
			for (int l = 0; l < 3; l++)
			{
				ref NativeList<NativeMeshSimplifier.Vertex> vertices = ref Vertices;
				vIndex = readonly2.vIndex;
				NativeListAccessExtensions.Get(in vertices, ((int3)(ref vIndex))[l]).tCount++;
			}
		}
		int num = 0;
		for (int m = 0; m < Vertices.Length; m++)
		{
			ref NativeMeshSimplifier.Vertex reference2 = ref NativeListAccessExtensions.Get(in Vertices, m);
			reference2.tStart = num;
			num += reference2.tCount;
			reference2.tCount = 0;
		}
		Refs.Length = Triangles.Length * 3;
		for (int n = 0; n < Triangles.Length; n++)
		{
			ref readonly NativeMeshSimplifier.Triangle readonly3 = ref NativeListAccessExtensions.GetReadonly(in Triangles, n);
			for (int num2 = 0; num2 < 3; num2++)
			{
				ref NativeList<NativeMeshSimplifier.Vertex> vertices2 = ref Vertices;
				vIndex = readonly3.vIndex;
				ref NativeMeshSimplifier.Vertex reference3 = ref NativeListAccessExtensions.Get(in vertices2, ((int3)(ref vIndex))[num2]);
				ref NativeMeshSimplifier.Ref reference4 = ref NativeListAccessExtensions.Get(in Refs, reference3.tStart + reference3.tCount);
				reference4.tId = n;
				reference4.tVertex = num2;
				reference3.tCount++;
			}
		}
		if (!flag)
		{
			return;
		}
		k_FirstUpdate.Begin();
		NativeList<int> list = default(NativeList<int>);
		list..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		NativeList<int> val = default(NativeList<int>);
		val..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		for (int num3 = 0; num3 < Vertices.Length; num3++)
		{
			ref readonly NativeMeshSimplifier.Vertex readonly4 = ref NativeListAccessExtensions.GetReadonly(in Vertices, num3);
			list.Clear();
			val.Clear();
			for (int num4 = 0; num4 < readonly4.tCount; num4++)
			{
				ref readonly NativeMeshSimplifier.Triangle readonly5 = ref NativeListAccessExtensions.GetReadonly(in Triangles, Refs[readonly4.tStart + num4].tId);
				for (int num5 = 0; num5 < 3; num5++)
				{
					int num6 = 0;
					vIndex = readonly5.vIndex;
					int num7;
					for (num7 = ((int3)(ref vIndex))[num5]; num6 < list.Length && val[num6] != num7; num6++)
					{
					}
					if (num6 == list.Length)
					{
						int num8 = 1;
						list.Add(ref num8);
						val.Add(ref num7);
					}
					else
					{
						NativeListAccessExtensions.Get(in list, num6)++;
					}
				}
			}
			for (int num9 = 0; num9 < list.Length; num9++)
			{
				if (list[num9] == 1)
				{
					NativeListAccessExtensions.Get(in Vertices, val[num9]).border = true;
				}
			}
		}
		list.Dispose();
		val.Dispose();
		float3 val2 = default(float3);
		float3x3 val3 = default(float3x3);
		for (int num10 = 0; num10 < Triangles.Length; num10++)
		{
			ref NativeMeshSimplifier.Triangle reference5 = ref NativeListAccessExtensions.Get(in Triangles, num10);
			for (int num11 = 0; num11 < 3; num11++)
			{
				ref readonly NativeMeshSimplifier.Vertex readonly6 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference5.vIndex))[num11]);
				((float3x3)(ref val3))[num11] = readonly6.p;
			}
			val2 = (reference5.n = math.normalizesafe(math.cross(((float3x3)(ref val3))[1] - ((float3x3)(ref val3))[0], ((float3x3)(ref val3))[2] - ((float3x3)(ref val3))[0]), math.right()));
			for (int num12 = 0; num12 < 3; num12++)
			{
				NativeListAccessExtensions.Get(in Vertices, ((int3)(ref reference5.vIndex))[num12]).q += NativeMeshSimplifier.SymmetricMatrix.Plane(val2.x, val2.y, val2.z, 0f - math.dot(val2, ((float3x3)(ref val3))[0]));
			}
		}
		for (int num13 = 0; num13 < Triangles.Length; num13++)
		{
			ref NativeMeshSimplifier.Triangle reference6 = ref NativeListAccessExtensions.Get(in Triangles, num13);
			for (int num14 = 0; num14 < 3; num14++)
			{
				((float4)(ref reference6.err))[num14] = CalculateError(((int3)(ref reference6.vIndex))[num14], ((int3)(ref reference6.vIndex))[(num14 + 1) % 3]);
			}
			((float4)(ref reference6.err))[3] = math.cmin(((float4)(ref reference6.err)).xyz);
		}
		k_FirstUpdate.End();
	}

	private void CompactMesh()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Vertices.Length; i++)
		{
			NativeListAccessExtensions.Get(in Vertices, i).tCount = 0;
		}
		int length = 0;
		for (int j = 0; j < Triangles.Length; j++)
		{
			ref readonly NativeMeshSimplifier.Triangle @readonly = ref NativeListAccessExtensions.GetReadonly(in Triangles, j);
			if (!@readonly.deleted)
			{
				Triangles[length++] = @readonly;
				for (int k = 0; k < 3; k++)
				{
					ref NativeList<NativeMeshSimplifier.Vertex> vertices = ref Vertices;
					int3 vIndex = @readonly.vIndex;
					NativeListAccessExtensions.Get(in vertices, ((int3)(ref vIndex))[k]).tCount = 1;
				}
			}
		}
		Triangles.Length = length;
		length = 0;
		for (int l = 0; l < Vertices.Length; l++)
		{
			ref NativeMeshSimplifier.Vertex reference = ref NativeListAccessExtensions.Get(in Vertices, l);
			if (reference.tCount != 0)
			{
				reference.tStart = length;
				NativeListAccessExtensions.Get(in Vertices, length).p = reference.p;
				length++;
			}
		}
		for (int m = 0; m < Triangles.Length; m++)
		{
			ref NativeMeshSimplifier.Triangle reference2 = ref NativeListAccessExtensions.Get(in Triangles, m);
			for (int n = 0; n < 3; n++)
			{
				((int3)(ref reference2.vIndex))[n] = Vertices[((int3)(ref reference2.vIndex))[n]].tStart;
			}
		}
		Vertices.Length = length;
	}
}


using System.Runtime.InteropServices;
using Unity.Burst;

[StructLayout(LayoutKind.Sequential, Size = 1)]
private struct ProfilerMarkerStub
{
	[BurstDiscard]
	public void Begin()
	{
	}

	[BurstDiscard]
	public void End()
	{
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Facepunch.NativeMeshSimplification;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public class NativeMeshSimplifier : IDisposable
{
	internal struct Triangle
	{
		public int3 vIndex;

		public float3 n;

		public float4 err;

		public bool deleted;

		public bool dirty;
	}

	internal struct Vertex
	{
		public float3 p;

		public SymmetricMatrix q;

		public int tStart;

		public int tCount;

		public bool border;
	}

	internal struct Ref
	{
		public int tId;

		public int tVertex;
	}

	internal struct SymmetricMatrix
	{
		private unsafe fixed float m[10];

		public unsafe float this[int i]
		{
			get
			{
				return m[i];
			}
			set
			{
				m[i] = value;
			}
		}

		private unsafe SymmetricMatrix(float m11, float m12, float m13, float m14, float m22, float m23, float m24, float m33, float m34, float m44)
		{
			m[0] = m11;
			m[1] = m12;
			m[2] = m13;
			m[3] = m14;
			m[4] = m22;
			m[5] = m23;
			m[6] = m24;
			m[7] = m33;
			m[8] = m34;
			m[9] = m44;
		}

		public static SymmetricMatrix Plane(float a, float b, float c, float d)
		{
			SymmetricMatrix result = default(SymmetricMatrix);
			result[0] = a * a;
			result[1] = a * b;
			result[2] = a * c;
			result[3] = a * d;
			result[4] = b * b;
			result[5] = b * c;
			result[6] = b * d;
			result[7] = c * c;
			result[8] = c * d;
			result[9] = d * d;
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe float Det(int a11, int a12, int a13, int a21, int a22, int a23, int a31, int a32, int a33)
		{
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			return math.determinant(new float3x3(m[a11], m[a12], m[a13], m[a21], m[a22], m[a23], m[a31], m[a32], m[a33]));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static SymmetricMatrix operator +(SymmetricMatrix m, SymmetricMatrix n)
		{
			return new SymmetricMatrix(m[0] + n[0], m[1] + n[1], m[2] + n[2], m[3] + n[3], m[4] + n[4], m[5] + n[5], m[6] + n[6], m[7] + n[7], m[8] + n[8], m[9] + n[9]);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void ArrayBoundsCheck(int i)
		{
			if (i < 0 || i > 9)
			{
				throw new IndexOutOfRangeException();
			}
		}
	}

	private NativeList<Vertex> _vertices;

	private NativeList<Triangle> _triangles;

	private NativeList<Ref> _refs;

	public NativeMeshSimplifier()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		_vertices = new NativeList<Vertex>(AllocatorHandle.op_Implicit((Allocator)4));
		_triangles = new NativeList<Triangle>(AllocatorHandle.op_Implicit((Allocator)4));
		_refs = new NativeList<Ref>(AllocatorHandle.op_Implicit((Allocator)4));
	}

	public void Dispose()
	{
		_vertices.Dispose();
		_triangles.Dispose();
		_refs.Dispose();
	}

	public JobHandle ScheduleMeshSimplify(float reductionModifier, NativeList<float3> verticesIn, NativeList<int> indicesIn, NativeList<float3> verticesOut, NativeList<int> indicesOut, JobHandle inputDeps)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		PopulateArraysJob populateArraysJob = default(PopulateArraysJob);
		populateArraysJob.VerticesIn = verticesIn;
		populateArraysJob.VerticesOut = _vertices;
		populateArraysJob.IndicesIn = indicesIn;
		populateArraysJob.TrianglesOut = _triangles;
		inputDeps = IJobExtensions.Schedule<PopulateArraysJob>(populateArraysJob, inputDeps);
		SimplifyMeshJob simplifyMeshJob = default(SimplifyMeshJob);
		simplifyMeshJob.MaxIterations = 128;
		simplifyMeshJob.Aggressiveness = 7;
		simplifyMeshJob.ReductionTarget = reductionModifier;
		simplifyMeshJob.Vertices = _vertices;
		simplifyMeshJob.Triangles = _triangles;
		simplifyMeshJob.Refs = _refs;
		inputDeps = IJobExtensions.Schedule<SimplifyMeshJob>(simplifyMeshJob, inputDeps);
		CopyBackJob copyBackJob = default(CopyBackJob);
		copyBackJob.DstVertices = verticesOut;
		copyBackJob.DstIndices = indicesOut;
		copyBackJob.SrcVertices = _vertices;
		copyBackJob.SrcTriangles = _triangles;
		inputDeps = IJobExtensions.Schedule<CopyBackJob>(copyBackJob, inputDeps);
		return inputDeps;
	}
}


using Unity.Mathematics;

internal struct Triangle
{
	public int3 vIndex;

	public float3 n;

	public float4 err;

	public bool deleted;

	public bool dirty;
}


using Unity.Mathematics;

internal struct Vertex
{
	public float3 p;

	public SymmetricMatrix q;

	public int tStart;

	public int tCount;

	public bool border;
}


internal struct Ref
{
	public int tId;

	public int tVertex;
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Unity.Mathematics;

internal struct SymmetricMatrix
{
	private unsafe fixed float m[10];

	public unsafe float this[int i]
	{
		get
		{
			return m[i];
		}
		set
		{
			m[i] = value;
		}
	}

	private unsafe SymmetricMatrix(float m11, float m12, float m13, float m14, float m22, float m23, float m24, float m33, float m34, float m44)
	{
		m[0] = m11;
		m[1] = m12;
		m[2] = m13;
		m[3] = m14;
		m[4] = m22;
		m[5] = m23;
		m[6] = m24;
		m[7] = m33;
		m[8] = m34;
		m[9] = m44;
	}

	public static SymmetricMatrix Plane(float a, float b, float c, float d)
	{
		SymmetricMatrix result = default(SymmetricMatrix);
		result[0] = a * a;
		result[1] = a * b;
		result[2] = a * c;
		result[3] = a * d;
		result[4] = b * b;
		result[5] = b * c;
		result[6] = b * d;
		result[7] = c * c;
		result[8] = c * d;
		result[9] = d * d;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe float Det(int a11, int a12, int a13, int a21, int a22, int a23, int a31, int a32, int a33)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		return math.determinant(new float3x3(m[a11], m[a12], m[a13], m[a21], m[a22], m[a23], m[a31], m[a32], m[a33]));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static SymmetricMatrix operator +(SymmetricMatrix m, SymmetricMatrix n)
	{
		return new SymmetricMatrix(m[0] + n[0], m[1] + n[1], m[2] + n[2], m[3] + n[3], m[4] + n[4], m[5] + n[5], m[6] + n[6], m[7] + n[7], m[8] + n[8], m[9] + n[9]);
	}

	[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
	private void ArrayBoundsCheck(int i)
	{
		if (i < 0 || i > 9)
		{
			throw new IndexOutOfRangeException();
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
internal struct BakePhysicsMeshesJob : IJobParallelFor
{
	[ReadOnly]
	public NativeArray<int> MeshIds;

	public void Execute(int index)
	{
		Physics.BakeMesh(MeshIds[index], false);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CleanupDuplicateVerticesJob : IJob
{
	[ReadOnly]
	public NativeList<float3> inputVertices;

	[ReadOnly]
	public NativeList<int> inputIndices;

	[WriteOnly]
	public NativeList<float3> outputVertices;

	[WriteOnly]
	public NativeList<int> outputIndices;

	public NativeHashMap<int, int> indexToIndices;

	public float3 vertexOffset;

	public float invScale;

	public int width;

	public int widthHeight;

	public void Execute()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		indexToIndices.Clear();
		outputVertices.Clear();
		outputIndices.Clear();
		int num = 0;
		for (int i = 0; i < inputVertices.Length; i++)
		{
			int3 val = (int3)(inputVertices[i] * invScale + vertexOffset);
			int num2 = inputIndices[i];
			int num3 = val.x + val.y * width + val.z * widthHeight;
			if (indexToIndices.TryGetValue(num3, ref num2))
			{
				outputIndices.Add(ref num2);
				continue;
			}
			indexToIndices.Add(num3, num);
			ref NativeList<float3> reference = ref outputVertices;
			float3 val2 = inputVertices[i];
			reference.Add(ref val2);
			outputIndices.Add(ref num);
			num++;
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct MarchJob : IJob
{
	[ReadOnly]
	public Point3DGrid sampler;

	public NativeList<float3> vertices;

	[WriteOnly]
	public NativeList<int> indices;

	public float3 vertexOffset;

	public float scale;

	public void Execute()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		int width = sampler.Width;
		int height = sampler.Height;
		int depth = sampler.Depth;
		vertices.Clear();
		indices.Clear();
		NativeArray<int3> corners = default(NativeArray<int3>);
		corners..ctor(8, (Allocator)2, (NativeArrayOptions)0);
		NativeArray<float> cornerSamples = default(NativeArray<float>);
		cornerSamples..ctor(8, (Allocator)2, (NativeArrayOptions)0);
		for (int i = 0; i < width - 1; i++)
		{
			for (int j = 0; j < height - 1; j++)
			{
				for (int k = 0; k < depth - 1; k++)
				{
					ProcessCube(new int3(i, j, k), corners, cornerSamples, vertices, indices, sampler, vertexOffset, scale);
				}
			}
		}
	}

	private static void ProcessCube(int3 cubeStart, NativeArray<int3> corners, NativeArray<float> cornerSamples, NativeList<float3> vertices, NativeList<int> indices, Point3DGrid sampler, float3 vertexOffset, float scale)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		corners[0] = cubeStart + new int3(0, 0, 0);
		corners[1] = cubeStart + new int3(1, 0, 0);
		corners[2] = cubeStart + new int3(1, 0, 1);
		corners[3] = cubeStart + new int3(0, 0, 1);
		corners[4] = cubeStart + new int3(0, 1, 0);
		corners[5] = cubeStart + new int3(1, 1, 0);
		corners[6] = cubeStart + new int3(1, 1, 1);
		corners[7] = cubeStart + new int3(0, 1, 1);
		int num = 0;
		for (int i = 0; i < corners.Length; i++)
		{
			float num3 = (cornerSamples[i] = sampler.Sample(corners[i]));
			if (num3 > 0f)
			{
				num |= 1 << i;
			}
		}
		int num4 = num * 16;
		for (int j = 0; j < 16; j += 3)
		{
			int num5 = MarchingCubeLookup.triTableFlat[num4 + j];
			if (num5 != -1)
			{
				int num6 = MarchingCubeLookup.triTableFlat[num4 + j + 1];
				int num7 = MarchingCubeLookup.triTableFlat[num4 + j + 2];
				float3 val = GetVertex(float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexAFromEdge[num5]]), cornerSamples[MarchingCubeLookup.cornerIndexAFromEdge[num5]], float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexBFromEdge[num5]]), cornerSamples[MarchingCubeLookup.cornerIndexBFromEdge[num5]]);
				float3 val2 = GetVertex(float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexAFromEdge[num6]]), cornerSamples[MarchingCubeLookup.cornerIndexAFromEdge[num6]], float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexBFromEdge[num6]]), cornerSamples[MarchingCubeLookup.cornerIndexBFromEdge[num6]]);
				float3 val3 = GetVertex(float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexAFromEdge[num7]]), cornerSamples[MarchingCubeLookup.cornerIndexAFromEdge[num7]], float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexBFromEdge[num7]]), cornerSamples[MarchingCubeLookup.cornerIndexBFromEdge[num7]]);
				int length = vertices.Length;
				float3 val4 = (val - vertexOffset) * scale;
				vertices.Add(ref val4);
				val4 = (val2 - vertexOffset) * scale;
				vertices.Add(ref val4);
				val4 = (val3 - vertexOffset) * scale;
				vertices.Add(ref val4);
				indices.Add(ref length);
				int num8 = length + 1;
				indices.Add(ref num8);
				num8 = length + 2;
				indices.Add(ref num8);
				continue;
			}
			break;
		}
		static float3 GetVertex(float3 v0, float s0, float3 v1, float s1)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			float num9 = (0f - s0) / (s1 - s0);
			return math.lerp(v0, v1, num9);
		}
	}
}


using Unity.IL2CPP.CompilerServices;

[Il2CppEagerStaticClassConstruction]
public static class MarchingCubeLookup
{
	public static readonly int[] edgeTable = new int[256]
	{
		0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309,
		2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666,
		1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219,
		3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340,
		2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681,
		419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214,
		4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367,
		613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912,
		1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317,
		4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370,
		598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899,
		2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204,
		4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505,
		2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966,
		1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167,
		3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616,
		2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013,
		255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154,
		3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635,
		1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988,
		1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129,
		3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590,
		314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975,
		2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400,
		3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541,
		1295, 1030, 778, 515, 265, 0
	};

	public static readonly int[] triTableFlat = new int[4096]
	{
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 0, 8, 3, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 0, 1, 9, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 1, 8,
		3, 9, 8, 1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 2, 10, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 3, 1, 2, 10, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 9, 2, 10, 0,
		2, 9, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 2, 8, 3, 2, 10, 8, 10, 9,
		8, -1, -1, -1, -1, -1, -1, -1, 3, 11,
		2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 0, 11, 2, 8, 11, 0,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		1, 9, 0, 2, 3, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 1, 11, 2, 1,
		9, 11, 9, 8, 11, -1, -1, -1, -1, -1,
		-1, -1, 3, 10, 1, 11, 10, 3, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 10,
		1, 0, 8, 10, 8, 11, 10, -1, -1, -1,
		-1, -1, -1, -1, 3, 9, 0, 3, 11, 9,
		11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
		9, 8, 10, 10, 8, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 4, 7, 8, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 4, 3, 0, 7, 3, 4, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 1,
		9, 8, 4, 7, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 4, 1, 9, 4, 7, 1,
		7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
		1, 2, 10, 8, 4, 7, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 3, 4, 7, 3,
		0, 4, 1, 2, 10, -1, -1, -1, -1, -1,
		-1, -1, 9, 2, 10, 9, 0, 2, 8, 4,
		7, -1, -1, -1, -1, -1, -1, -1, 2, 10,
		9, 2, 9, 7, 2, 7, 3, 7, 9, 4,
		-1, -1, -1, -1, 8, 4, 7, 3, 11, 2,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		11, 4, 7, 11, 2, 4, 2, 0, 4, -1,
		-1, -1, -1, -1, -1, -1, 9, 0, 1, 8,
		4, 7, 2, 3, 11, -1, -1, -1, -1, -1,
		-1, -1, 4, 7, 11, 9, 4, 11, 9, 11,
		2, 9, 2, 1, -1, -1, -1, -1, 3, 10,
		1, 3, 11, 10, 7, 8, 4, -1, -1, -1,
		-1, -1, -1, -1, 1, 11, 10, 1, 4, 11,
		1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
		4, 7, 8, 9, 0, 11, 9, 11, 10, 11,
		0, 3, -1, -1, -1, -1, 4, 7, 11, 4,
		11, 9, 9, 11, 10, -1, -1, -1, -1, -1,
		-1, -1, 9, 5, 4, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 9, 5,
		4, 0, 8, 3, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 0, 5, 4, 1, 5, 0,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		8, 5, 4, 8, 3, 5, 3, 1, 5, -1,
		-1, -1, -1, -1, -1, -1, 1, 2, 10, 9,
		5, 4, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 3, 0, 8, 1, 2, 10, 4, 9,
		5, -1, -1, -1, -1, -1, -1, -1, 5, 2,
		10, 5, 4, 2, 4, 0, 2, -1, -1, -1,
		-1, -1, -1, -1, 2, 10, 5, 3, 2, 5,
		3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
		9, 5, 4, 2, 3, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 0, 11, 2, 0,
		8, 11, 4, 9, 5, -1, -1, -1, -1, -1,
		-1, -1, 0, 5, 4, 0, 1, 5, 2, 3,
		11, -1, -1, -1, -1, -1, -1, -1, 2, 1,
		5, 2, 5, 8, 2, 8, 11, 4, 8, 5,
		-1, -1, -1, -1, 10, 3, 11, 10, 1, 3,
		9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
		4, 9, 5, 0, 8, 1, 8, 10, 1, 8,
		11, 10, -1, -1, -1, -1, 5, 4, 0, 5,
		0, 11, 5, 11, 10, 11, 0, 3, -1, -1,
		-1, -1, 5, 4, 8, 5, 8, 10, 10, 8,
		11, -1, -1, -1, -1, -1, -1, -1, 9, 7,
		8, 5, 7, 9, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 9, 3, 0, 9, 5, 3,
		5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
		0, 7, 8, 0, 1, 7, 1, 5, 7, -1,
		-1, -1, -1, -1, -1, -1, 1, 5, 3, 3,
		5, 7, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 9, 7, 8, 9, 5, 7, 10, 1,
		2, -1, -1, -1, -1, -1, -1, -1, 10, 1,
		2, 9, 5, 0, 5, 3, 0, 5, 7, 3,
		-1, -1, -1, -1, 8, 0, 2, 8, 2, 5,
		8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
		2, 10, 5, 2, 5, 3, 3, 5, 7, -1,
		-1, -1, -1, -1, -1, -1, 7, 9, 5, 7,
		8, 9, 3, 11, 2, -1, -1, -1, -1, -1,
		-1, -1, 9, 5, 7, 9, 7, 2, 9, 2,
		0, 2, 7, 11, -1, -1, -1, -1, 2, 3,
		11, 0, 1, 8, 1, 7, 8, 1, 5, 7,
		-1, -1, -1, -1, 11, 2, 1, 11, 1, 7,
		7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
		9, 5, 8, 8, 5, 7, 10, 1, 3, 10,
		3, 11, -1, -1, -1, -1, 5, 7, 0, 5,
		0, 9, 7, 11, 0, 1, 0, 10, 11, 10,
		0, -1, 11, 10, 0, 11, 0, 3, 10, 5,
		0, 8, 0, 7, 5, 7, 0, -1, 11, 10,
		5, 7, 11, 5, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 10, 6, 5, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 3, 5, 10, 6, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 9, 0, 1, 5,
		10, 6, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 1, 8, 3, 1, 9, 8, 5, 10,
		6, -1, -1, -1, -1, -1, -1, -1, 1, 6,
		5, 2, 6, 1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 6, 5, 1, 2, 6,
		3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
		9, 6, 5, 9, 0, 6, 0, 2, 6, -1,
		-1, -1, -1, -1, -1, -1, 5, 9, 8, 5,
		8, 2, 5, 2, 6, 3, 2, 8, -1, -1,
		-1, -1, 2, 3, 11, 10, 6, 5, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 11, 0,
		8, 11, 2, 0, 10, 6, 5, -1, -1, -1,
		-1, -1, -1, -1, 0, 1, 9, 2, 3, 11,
		5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
		5, 10, 6, 1, 9, 2, 9, 11, 2, 9,
		8, 11, -1, -1, -1, -1, 6, 3, 11, 6,
		5, 3, 5, 1, 3, -1, -1, -1, -1, -1,
		-1, -1, 0, 8, 11, 0, 11, 5, 0, 5,
		1, 5, 11, 6, -1, -1, -1, -1, 3, 11,
		6, 0, 3, 6, 0, 6, 5, 0, 5, 9,
		-1, -1, -1, -1, 6, 5, 9, 6, 9, 11,
		11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
		5, 10, 6, 4, 7, 8, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 4, 3, 0, 4,
		7, 3, 6, 5, 10, -1, -1, -1, -1, -1,
		-1, -1, 1, 9, 0, 5, 10, 6, 8, 4,
		7, -1, -1, -1, -1, -1, -1, -1, 10, 6,
		5, 1, 9, 7, 1, 7, 3, 7, 9, 4,
		-1, -1, -1, -1, 6, 1, 2, 6, 5, 1,
		4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
		1, 2, 5, 5, 2, 6, 3, 0, 4, 3,
		4, 7, -1, -1, -1, -1, 8, 4, 7, 9,
		0, 5, 0, 6, 5, 0, 2, 6, -1, -1,
		-1, -1, 7, 3, 9, 7, 9, 4, 3, 2,
		9, 5, 9, 6, 2, 6, 9, -1, 3, 11,
		2, 7, 8, 4, 10, 6, 5, -1, -1, -1,
		-1, -1, -1, -1, 5, 10, 6, 4, 7, 2,
		4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
		0, 1, 9, 4, 7, 8, 2, 3, 11, 5,
		10, 6, -1, -1, -1, -1, 9, 2, 1, 9,
		11, 2, 9, 4, 11, 7, 11, 4, 5, 10,
		6, -1, 8, 4, 7, 3, 11, 5, 3, 5,
		1, 5, 11, 6, -1, -1, -1, -1, 5, 1,
		11, 5, 11, 6, 1, 0, 11, 7, 11, 4,
		0, 4, 11, -1, 0, 5, 9, 0, 6, 5,
		0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
		6, 5, 9, 6, 9, 11, 4, 7, 9, 7,
		11, 9, -1, -1, -1, -1, 10, 4, 9, 6,
		4, 10, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 4, 10, 6, 4, 9, 10, 0, 8,
		3, -1, -1, -1, -1, -1, -1, -1, 10, 0,
		1, 10, 6, 0, 6, 4, 0, -1, -1, -1,
		-1, -1, -1, -1, 8, 3, 1, 8, 1, 6,
		8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
		1, 4, 9, 1, 2, 4, 2, 6, 4, -1,
		-1, -1, -1, -1, -1, -1, 3, 0, 8, 1,
		2, 9, 2, 4, 9, 2, 6, 4, -1, -1,
		-1, -1, 0, 2, 4, 4, 2, 6, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 8, 3,
		2, 8, 2, 4, 4, 2, 6, -1, -1, -1,
		-1, -1, -1, -1, 10, 4, 9, 10, 6, 4,
		11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 2, 2, 8, 11, 4, 9, 10, 4,
		10, 6, -1, -1, -1, -1, 3, 11, 2, 0,
		1, 6, 0, 6, 4, 6, 1, 10, -1, -1,
		-1, -1, 6, 4, 1, 6, 1, 10, 4, 8,
		1, 2, 1, 11, 8, 11, 1, -1, 9, 6,
		4, 9, 3, 6, 9, 1, 3, 11, 6, 3,
		-1, -1, -1, -1, 8, 11, 1, 8, 1, 0,
		11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
		3, 11, 6, 3, 6, 0, 0, 6, 4, -1,
		-1, -1, -1, -1, -1, -1, 6, 4, 8, 11,
		6, 8, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 7, 10, 6, 7, 8, 10, 8, 9,
		10, -1, -1, -1, -1, -1, -1, -1, 0, 7,
		3, 0, 10, 7, 0, 9, 10, 6, 7, 10,
		-1, -1, -1, -1, 10, 6, 7, 1, 10, 7,
		1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
		10, 6, 7, 10, 7, 1, 1, 7, 3, -1,
		-1, -1, -1, -1, -1, -1, 1, 2, 6, 1,
		6, 8, 1, 8, 9, 8, 6, 7, -1, -1,
		-1, -1, 2, 6, 9, 2, 9, 1, 6, 7,
		9, 0, 9, 3, 7, 3, 9, -1, 7, 8,
		0, 7, 0, 6, 6, 0, 2, -1, -1, -1,
		-1, -1, -1, -1, 7, 3, 2, 6, 7, 2,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		2, 3, 11, 10, 6, 8, 10, 8, 9, 8,
		6, 7, -1, -1, -1, -1, 2, 0, 7, 2,
		7, 11, 0, 9, 7, 6, 7, 10, 9, 10,
		7, -1, 1, 8, 0, 1, 7, 8, 1, 10,
		7, 6, 7, 10, 2, 3, 11, -1, 11, 2,
		1, 11, 1, 7, 10, 6, 1, 6, 7, 1,
		-1, -1, -1, -1, 8, 9, 6, 8, 6, 7,
		9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
		0, 9, 1, 11, 6, 7, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 7, 8, 0, 7,
		0, 6, 3, 11, 0, 11, 6, 0, -1, -1,
		-1, -1, 7, 11, 6, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 7, 6,
		11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 3, 0, 8, 11, 7, 6,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 1, 9, 11, 7, 6, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 8, 1, 9, 8,
		3, 1, 11, 7, 6, -1, -1, -1, -1, -1,
		-1, -1, 10, 1, 2, 6, 11, 7, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 1, 2,
		10, 3, 0, 8, 6, 11, 7, -1, -1, -1,
		-1, -1, -1, -1, 2, 9, 0, 2, 10, 9,
		6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
		6, 11, 7, 2, 10, 3, 10, 8, 3, 10,
		9, 8, -1, -1, -1, -1, 7, 2, 3, 6,
		2, 7, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 7, 0, 8, 7, 6, 0, 6, 2,
		0, -1, -1, -1, -1, -1, -1, -1, 2, 7,
		6, 2, 3, 7, 0, 1, 9, -1, -1, -1,
		-1, -1, -1, -1, 1, 6, 2, 1, 8, 6,
		1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
		10, 7, 6, 10, 1, 7, 1, 3, 7, -1,
		-1, -1, -1, -1, -1, -1, 10, 7, 6, 1,
		7, 10, 1, 8, 7, 1, 0, 8, -1, -1,
		-1, -1, 0, 3, 7, 0, 7, 10, 0, 10,
		9, 6, 10, 7, -1, -1, -1, -1, 7, 6,
		10, 7, 10, 8, 8, 10, 9, -1, -1, -1,
		-1, -1, -1, -1, 6, 8, 4, 11, 8, 6,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		3, 6, 11, 3, 0, 6, 0, 4, 6, -1,
		-1, -1, -1, -1, -1, -1, 8, 6, 11, 8,
		4, 6, 9, 0, 1, -1, -1, -1, -1, -1,
		-1, -1, 9, 4, 6, 9, 6, 3, 9, 3,
		1, 11, 3, 6, -1, -1, -1, -1, 6, 8,
		4, 6, 11, 8, 2, 10, 1, -1, -1, -1,
		-1, -1, -1, -1, 1, 2, 10, 3, 0, 11,
		0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
		4, 11, 8, 4, 6, 11, 0, 2, 9, 2,
		10, 9, -1, -1, -1, -1, 10, 9, 3, 10,
		3, 2, 9, 4, 3, 11, 3, 6, 4, 6,
		3, -1, 8, 2, 3, 8, 4, 2, 4, 6,
		2, -1, -1, -1, -1, -1, -1, -1, 0, 4,
		2, 4, 6, 2, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 9, 0, 2, 3, 4,
		2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
		1, 9, 4, 1, 4, 2, 2, 4, 6, -1,
		-1, -1, -1, -1, -1, -1, 8, 1, 3, 8,
		6, 1, 8, 4, 6, 6, 10, 1, -1, -1,
		-1, -1, 10, 1, 0, 10, 0, 6, 6, 0,
		4, -1, -1, -1, -1, -1, -1, -1, 4, 6,
		3, 4, 3, 8, 6, 10, 3, 0, 3, 9,
		10, 9, 3, -1, 10, 9, 4, 6, 10, 4,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		4, 9, 5, 7, 6, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 0, 8, 3, 4,
		9, 5, 11, 7, 6, -1, -1, -1, -1, -1,
		-1, -1, 5, 0, 1, 5, 4, 0, 7, 6,
		11, -1, -1, -1, -1, -1, -1, -1, 11, 7,
		6, 8, 3, 4, 3, 5, 4, 3, 1, 5,
		-1, -1, -1, -1, 9, 5, 4, 10, 1, 2,
		7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
		6, 11, 7, 1, 2, 10, 0, 8, 3, 4,
		9, 5, -1, -1, -1, -1, 7, 6, 11, 5,
		4, 10, 4, 2, 10, 4, 0, 2, -1, -1,
		-1, -1, 3, 4, 8, 3, 5, 4, 3, 2,
		5, 10, 5, 2, 11, 7, 6, -1, 7, 2,
		3, 7, 6, 2, 5, 4, 9, -1, -1, -1,
		-1, -1, -1, -1, 9, 5, 4, 0, 8, 6,
		0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
		3, 6, 2, 3, 7, 6, 1, 5, 0, 5,
		4, 0, -1, -1, -1, -1, 6, 2, 8, 6,
		8, 7, 2, 1, 8, 4, 8, 5, 1, 5,
		8, -1, 9, 5, 4, 10, 1, 6, 1, 7,
		6, 1, 3, 7, -1, -1, -1, -1, 1, 6,
		10, 1, 7, 6, 1, 0, 7, 8, 7, 0,
		9, 5, 4, -1, 4, 0, 10, 4, 10, 5,
		0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
		7, 6, 10, 7, 10, 8, 5, 4, 10, 4,
		8, 10, -1, -1, -1, -1, 6, 9, 5, 6,
		11, 9, 11, 8, 9, -1, -1, -1, -1, -1,
		-1, -1, 3, 6, 11, 0, 6, 3, 0, 5,
		6, 0, 9, 5, -1, -1, -1, -1, 0, 11,
		8, 0, 5, 11, 0, 1, 5, 5, 6, 11,
		-1, -1, -1, -1, 6, 11, 3, 6, 3, 5,
		5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
		1, 2, 10, 9, 5, 11, 9, 11, 8, 11,
		5, 6, -1, -1, -1, -1, 0, 11, 3, 0,
		6, 11, 0, 9, 6, 5, 6, 9, 1, 2,
		10, -1, 11, 8, 5, 11, 5, 6, 8, 0,
		5, 10, 5, 2, 0, 2, 5, -1, 6, 11,
		3, 6, 3, 5, 2, 10, 3, 10, 5, 3,
		-1, -1, -1, -1, 5, 8, 9, 5, 2, 8,
		5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
		9, 5, 6, 9, 6, 0, 0, 6, 2, -1,
		-1, -1, -1, -1, -1, -1, 1, 5, 8, 1,
		8, 0, 5, 6, 8, 3, 8, 2, 6, 2,
		8, -1, 1, 5, 6, 2, 1, 6, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 1, 3,
		6, 1, 6, 10, 3, 8, 6, 5, 6, 9,
		8, 9, 6, -1, 10, 1, 0, 10, 0, 6,
		9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
		0, 3, 8, 5, 6, 10, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 10, 5, 6, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 11, 5, 10, 7, 5, 11, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 11, 5,
		10, 11, 7, 5, 8, 3, 0, -1, -1, -1,
		-1, -1, -1, -1, 5, 11, 7, 5, 10, 11,
		1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
		10, 7, 5, 10, 11, 7, 9, 8, 1, 8,
		3, 1, -1, -1, -1, -1, 11, 1, 2, 11,
		7, 1, 7, 5, 1, -1, -1, -1, -1, -1,
		-1, -1, 0, 8, 3, 1, 2, 7, 1, 7,
		5, 7, 2, 11, -1, -1, -1, -1, 9, 7,
		5, 9, 2, 7, 9, 0, 2, 2, 11, 7,
		-1, -1, -1, -1, 7, 5, 2, 7, 2, 11,
		5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
		2, 5, 10, 2, 3, 5, 3, 7, 5, -1,
		-1, -1, -1, -1, -1, -1, 8, 2, 0, 8,
		5, 2, 8, 7, 5, 10, 2, 5, -1, -1,
		-1, -1, 9, 0, 1, 5, 10, 3, 5, 3,
		7, 3, 10, 2, -1, -1, -1, -1, 9, 8,
		2, 9, 2, 1, 8, 7, 2, 10, 2, 5,
		7, 5, 2, -1, 1, 3, 5, 3, 7, 5,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 7, 0, 7, 1, 1, 7, 5, -1,
		-1, -1, -1, -1, -1, -1, 9, 0, 3, 9,
		3, 5, 5, 3, 7, -1, -1, -1, -1, -1,
		-1, -1, 9, 8, 7, 5, 9, 7, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 5, 8,
		4, 5, 10, 8, 10, 11, 8, -1, -1, -1,
		-1, -1, -1, -1, 5, 0, 4, 5, 11, 0,
		5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
		0, 1, 9, 8, 4, 10, 8, 10, 11, 10,
		4, 5, -1, -1, -1, -1, 10, 11, 4, 10,
		4, 5, 11, 3, 4, 9, 4, 1, 3, 1,
		4, -1, 2, 5, 1, 2, 8, 5, 2, 11,
		8, 4, 5, 8, -1, -1, -1, -1, 0, 4,
		11, 0, 11, 3, 4, 5, 11, 2, 11, 1,
		5, 1, 11, -1, 0, 2, 5, 0, 5, 9,
		2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
		9, 4, 5, 2, 11, 3, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 2, 5, 10, 3,
		5, 2, 3, 4, 5, 3, 8, 4, -1, -1,
		-1, -1, 5, 10, 2, 5, 2, 4, 4, 2,
		0, -1, -1, -1, -1, -1, -1, -1, 3, 10,
		2, 3, 5, 10, 3, 8, 5, 4, 5, 8,
		0, 1, 9, -1, 5, 10, 2, 5, 2, 4,
		1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
		8, 4, 5, 8, 5, 3, 3, 5, 1, -1,
		-1, -1, -1, -1, -1, -1, 0, 4, 5, 1,
		0, 5, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 8, 4, 5, 8, 5, 3, 9, 0,
		5, 0, 3, 5, -1, -1, -1, -1, 9, 4,
		5, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 4, 11, 7, 4, 9, 11,
		9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 3, 4, 9, 7, 9, 11, 7, 9,
		10, 11, -1, -1, -1, -1, 1, 10, 11, 1,
		11, 4, 1, 4, 0, 7, 4, 11, -1, -1,
		-1, -1, 3, 1, 4, 3, 4, 8, 1, 10,
		4, 7, 4, 11, 10, 11, 4, -1, 4, 11,
		7, 9, 11, 4, 9, 2, 11, 9, 1, 2,
		-1, -1, -1, -1, 9, 7, 4, 9, 11, 7,
		9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
		11, 7, 4, 11, 4, 2, 2, 4, 0, -1,
		-1, -1, -1, -1, -1, -1, 11, 7, 4, 11,
		4, 2, 8, 3, 4, 3, 2, 4, -1, -1,
		-1, -1, 2, 9, 10, 2, 7, 9, 2, 3,
		7, 7, 4, 9, -1, -1, -1, -1, 9, 10,
		7, 9, 7, 4, 10, 2, 7, 8, 7, 0,
		2, 0, 7, -1, 3, 7, 10, 3, 10, 2,
		7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
		1, 10, 2, 8, 7, 4, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 4, 9, 1, 4,
		1, 7, 7, 1, 3, -1, -1, -1, -1, -1,
		-1, -1, 4, 9, 1, 4, 1, 7, 0, 8,
		1, 8, 7, 1, -1, -1, -1, -1, 4, 0,
		3, 7, 4, 3, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 4, 8, 7, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		9, 10, 8, 10, 11, 8, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 3, 0, 9, 3,
		9, 11, 11, 9, 10, -1, -1, -1, -1, -1,
		-1, -1, 0, 1, 10, 0, 10, 8, 8, 10,
		11, -1, -1, -1, -1, -1, -1, -1, 3, 1,
		10, 11, 3, 10, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 2, 11, 1, 11, 9,
		9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
		3, 0, 9, 3, 9, 11, 1, 2, 9, 2,
		11, 9, -1, -1, -1, -1, 0, 2, 11, 8,
		0, 11, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 3, 2, 11, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 2, 3,
		8, 2, 8, 10, 10, 8, 9, -1, -1, -1,
		-1, -1, -1, -1, 9, 10, 2, 0, 9, 2,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		2, 3, 8, 2, 8, 10, 0, 1, 8, 1,
		10, 8, -1, -1, -1, -1, 1, 10, 2, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 1, 3, 8, 9, 1, 8, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 9,
		1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 0, 3, 8, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1
	};

	public static readonly int[] cornerIndexAFromEdge = new int[12]
	{
		0, 1, 2, 3, 4, 5, 6, 7, 0, 1,
		2, 3
	};

	public static readonly int[] cornerIndexBFromEdge = new int[12]
	{
		1, 2, 3, 0, 5, 6, 7, 4, 4, 5,
		6, 7
	};
}


using System;
using System.Collections.Generic;
using Facepunch.MarchingCubes;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class MarchingCubeManager : FacepunchBehaviour
{
	private static MarchingCubeManager _instance;

	public List<MarchingCubesGenerator> AllCubesList;

	private ListHashSet<MarchingCubesGenerator> _cubesWaitingForGeneration;

	private BufferList<MarchingCubesGenerator> _toAssignPhysics;

	private JobHandle _physicsBakeHandle;

	public static MarchingCubeManager Instance
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Expected O, but got Unknown
			if (_instance != null)
			{
				return _instance;
			}
			GameObject val = new GameObject("MarchingCubeManager");
			Object.DontDestroyOnLoad((Object)val);
			_instance = val.AddComponent<MarchingCubeManager>();
			return _instance;
		}
	}

	public void Awake()
	{
		AllCubesList = new List<MarchingCubesGenerator>();
		_cubesWaitingForGeneration = new ListHashSet<MarchingCubesGenerator>();
		_toAssignPhysics = new BufferList<MarchingCubesGenerator>();
	}

	public void FixedUpdate()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (_toAssignPhysics.Count == 0)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PhysicsBakeComplete", 0);
		try
		{
			((JobHandle)(ref _physicsBakeHandle)).Complete();
			_physicsBakeHandle = default(JobHandle);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("PhysicsMeshAssign", 0);
		try
		{
			Enumerator<MarchingCubesGenerator> enumerator = _toAssignPhysics.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					MarchingCubesGenerator current = enumerator.Current;
					current.MeshCollider.sharedMesh = current.Mesh;
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		_toAssignPhysics.Clear();
	}

	public void LateUpdate()
	{
		ProcessQueue();
	}

	public void Add(MarchingCubesGenerator cubes)
	{
		AllCubesList.Add(cubes);
	}

	public void Remove(MarchingCubesGenerator cubes)
	{
		AllCubesList.Remove(cubes);
	}

	public void EnqueueUpdate(MarchingCubesGenerator cubes)
	{
		_cubesWaitingForGeneration.TryAdd(cubes);
	}

	private void ProcessQueue()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (_cubesWaitingForGeneration.Count != 0)
		{
			int count = _cubesWaitingForGeneration.Count;
			NativeArray<JobHandle> val = default(NativeArray<JobHandle>);
			val..ctor(count, (Allocator)2, (NativeArrayOptions)1);
			for (int i = 0; i < count; i++)
			{
				val[i] = _cubesWaitingForGeneration[i].ScheduleMarch();
			}
			JobHandle.CompleteAll(val);
			NativeArray<int> meshIds = default(NativeArray<int>);
			meshIds..ctor(_cubesWaitingForGeneration.Count, (Allocator)3, (NativeArrayOptions)1);
			for (int j = 0; j < count; j++)
			{
				_cubesWaitingForGeneration[j].ApplyUpdate();
				meshIds[j] = _cubesWaitingForGeneration[j].MeshInstanceId;
				_toAssignPhysics.Add(_cubesWaitingForGeneration[j]);
			}
			_physicsBakeHandle = IJobParallelForExtensions.Schedule<BakePhysicsMeshesJob>(new BakePhysicsMeshesJob
			{
				MeshIds = meshIds
			}, count, 1, _physicsBakeHandle);
			meshIds.Dispose(_physicsBakeHandle);
			_cubesWaitingForGeneration.Clear();
		}
	}
}


using System;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Profiling;
using UnityEngine;

public class MarchingCubesGenerator : IDisposable
{
	private readonly Point3DGrid _sampler;

	private readonly Mesh _meshToUpdate;

	private readonly MeshCollider _meshCollider;

	private readonly NativeMeshSimplifier _simplifier;

	private readonly float3 _offset;

	private readonly float _scale;

	private NativeList<float3> vertices0;

	private NativeList<float3> vertices1;

	private NativeList<float3> vertices2;

	private NativeList<int> indices0;

	private NativeList<int> indices1;

	private NativeList<int> indices2;

	private NativeHashMap<int, int> indexToIndices;

	private float4x4 _transform;

	private static readonly ProfilerMarker p_ApplyUpdate = new ProfilerMarker("MarchingCubes.ApplyUpdate");

	public Mesh Mesh => _meshToUpdate;

	public MeshCollider MeshCollider => _meshCollider;

	public int MeshInstanceId => ((Object)_meshToUpdate).GetInstanceID();

	public MarchingCubesGenerator(Point3DGrid sampler, Mesh meshToUpdate, MeshCollider meshCollider, float3 offset, float scale)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		_sampler = sampler;
		_meshToUpdate = meshToUpdate;
		_meshCollider = meshCollider;
		_simplifier = new NativeMeshSimplifier();
		_offset = offset;
		_scale = scale;
		vertices0 = new NativeList<float3>(AllocatorHandle.op_Implicit((Allocator)4));
		vertices1 = new NativeList<float3>(AllocatorHandle.op_Implicit((Allocator)4));
		vertices2 = new NativeList<float3>(AllocatorHandle.op_Implicit((Allocator)4));
		indices0 = new NativeList<int>(AllocatorHandle.op_Implicit((Allocator)4));
		indices1 = new NativeList<int>(AllocatorHandle.op_Implicit((Allocator)4));
		indices2 = new NativeList<int>(AllocatorHandle.op_Implicit((Allocator)4));
		indexToIndices = new NativeHashMap<int, int>(0, AllocatorHandle.op_Implicit((Allocator)4));
		MarchingCubeManager.Instance.Add(this);
	}

	public JobHandle ScheduleMarch()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		float3 vertexOffset = new float3((float)_sampler.Width * 0.5f, (float)_sampler.Height * 0.5f, (float)_sampler.Depth * 0.5f) + _offset;
		MarchJob marchJob = default(MarchJob);
		marchJob.sampler = _sampler;
		marchJob.vertices = vertices0;
		marchJob.indices = indices0;
		marchJob.vertexOffset = vertexOffset;
		marchJob.scale = _scale;
		MarchJob marchJob2 = marchJob;
		CleanupDuplicateVerticesJob cleanupDuplicateVerticesJob = default(CleanupDuplicateVerticesJob);
		cleanupDuplicateVerticesJob.inputVertices = vertices0;
		cleanupDuplicateVerticesJob.inputIndices = indices0;
		cleanupDuplicateVerticesJob.outputVertices = vertices1;
		cleanupDuplicateVerticesJob.outputIndices = indices1;
		cleanupDuplicateVerticesJob.indexToIndices = indexToIndices;
		cleanupDuplicateVerticesJob.vertexOffset = vertexOffset;
		cleanupDuplicateVerticesJob.invScale = math.rcp(_scale);
		cleanupDuplicateVerticesJob.width = _sampler.Width;
		cleanupDuplicateVerticesJob.widthHeight = _sampler.Height * _sampler.Width;
		CleanupDuplicateVerticesJob cleanupDuplicateVerticesJob2 = cleanupDuplicateVerticesJob;
		JobHandle val = IJobExtensions.Schedule<MarchJob>(marchJob2, default(JobHandle));
		return IJobExtensions.Schedule<CleanupDuplicateVerticesJob>(cleanupDuplicateVerticesJob2, val);
	}

	public JobHandle ScheduleSimplification(JobHandle inputDeps)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return _simplifier.ScheduleMeshSimplify(0.4f, vertices1, indices1, vertices2, indices2, inputDeps);
	}

	public void ApplyUpdate(bool fromSimplify = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		ProfilerMarker val = p_ApplyUpdate;
		AutoScope val2 = ((ProfilerMarker)(ref val)).Auto();
		try
		{
			_meshToUpdate.Clear();
			NativeList<float3> val3 = (fromSimplify ? vertices2 : vertices1);
			NativeList<int> val4 = (fromSimplify ? indices2 : indices1);
			_meshToUpdate.SetVertices<float3>(val3.AsArray(), 0, val3.Length);
			_meshToUpdate.SetIndices<int>(val4.AsArray(), 0, val4.Length, (MeshTopology)0, 0, true, 0);
			_meshToUpdate.RecalculateBounds();
			_meshToUpdate.RecalculateNormals();
			if (BaseSculpture.LogMeshStats)
			{
				Debug.Log((object)$"{((Object)_meshToUpdate).name} : tris({val4.Length / 3}) verts({val3.Length})");
			}
		}
		finally
		{
			((IDisposable)(AutoScope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void EnqueueUpdate()
	{
		MarchingCubeManager.Instance.EnqueueUpdate(this);
	}

	public void Dispose()
	{
		vertices0.Dispose();
		vertices1.Dispose();
		vertices2.Dispose();
		indices0.Dispose();
		indices1.Dispose();
		indices2.Dispose();
		indexToIndices.Dispose();
		_simplifier.Dispose();
		MarchingCubeManager.Instance.Remove(this);
	}
}


using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;

[GenerateTestsForBurstCompatibility]
public struct Point3DGrid : IDisposable
{
	private readonly NativeBitArray _array;

	private readonly int _width;

	private readonly int _height;

	private readonly int _depth;

	private readonly int3 _bounds;

	private readonly int _widthHeight;

	private bool _hasDisposed;

	public int Width => _width;

	public int Height => _height;

	public int Depth => _depth;

	public int Length => ((NativeBitArray)(ref _array)).Length;

	public int3 Bounds => _bounds;

	public bool this[int directIndex]
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			return ((NativeBitArray)(ref array)).IsSet(directIndex);
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			((NativeBitArray)(ref array)).Set(directIndex, value);
		}
	}

	public bool this[int x, int y, int z]
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			return ((NativeBitArray)(ref array)).IsSet(ToIndex(x, y, z));
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			((NativeBitArray)(ref array)).Set(ToIndex(x, y, z), value);
		}
	}

	public bool this[int3 p]
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			return this[p.x, p.y, p.z];
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			this[p.x, p.y, p.z] = value;
		}
	}

	public Point3DGrid(int width, int height, int depth)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		_width = width;
		_height = height;
		_depth = depth;
		_bounds = new int3(_width, _height, _depth);
		_widthHeight = _width * _height;
		_array = new NativeBitArray(_widthHeight * _depth, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
		_hasDisposed = false;
	}

	public void Clear()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		((NativeBitArray)(ref array)).Clear();
	}

	public void CopyToByteArray(ref byte[] arr)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		NativeArray<byte> val = ((NativeBitArray)(ref array)).AsNativeArray<byte>();
		if (arr.Length < val.Length)
		{
			arr = new byte[val.Length];
		}
		val.CopyTo(arr);
	}

	public unsafe void CopyFromByteArray(byte[] arr, int count)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		NativeArray<byte> val = ((NativeBitArray)(ref array)).AsNativeArray<byte>();
		if (count != val.Length)
		{
			Debug.LogError((object)"Trying to load non-matching sized grid");
			return;
		}
		fixed (byte* ptr = arr)
		{
			UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafePtr<byte>(val), (void*)ptr, (long)(count * UnsafeUtility.SizeOf<byte>()));
		}
	}

	public void CopyFromNativeBitArray(ref NativeBitArray other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		((NativeBitArray)(ref array)).Copy(0, ref other, 0, ((NativeBitArray)(ref _array)).Length);
	}

	public bool InBounds(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!math.any(p < 0))
		{
			return !math.any(p >= _bounds);
		}
		return false;
	}

	public bool InBoundsNotTouching(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!math.any(p < 1))
		{
			return !math.any(p >= _bounds - new int3(1));
		}
		return false;
	}

	public int ToIndex(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return ToIndex(p.x, p.y, p.z);
	}

	public int ToIndex(int x, int y, int z)
	{
		return x + y * Width + z * _widthHeight;
	}

	public float Sample(int3 localPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (!this[localPosition])
		{
			return 0f;
		}
		return 1f;
	}

	public void Dispose()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!_hasDisposed)
		{
			NativeBitArray array = _array;
			((NativeBitArray)(ref array)).Dispose();
			_hasDisposed = true;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using ProtoBuf;
using UnityEngine;

public class BlackjackController : CardGameController
{
	[Flags]
	public enum BlackjackInputOption
	{
		None = 0,
		SubmitBet = 1,
		Hit = 2,
		Stand = 4,
		Split = 8,
		DoubleDown = 0x10,
		Insurance = 0x20,
		MaxBet = 0x40,
		Abandon = 0x80
	}

	public enum BlackjackRoundResult
	{
		None,
		Bust,
		Loss,
		Standoff,
		Win,
		BlackjackWin
	}

	public enum CardsValueMode
	{
		Low,
		High
	}

	private enum BetType
	{
		Main,
		Split,
		Insurance
	}

	public List<PlayingCard> dealerCards = new List<PlayingCard>();

	public const float BLACKJACK_PAYOUT_RATIO = 1.5f;

	public const float INSURANCE_PAYOUT_RATIO = 2f;

	private const float DEALER_MOVE_TIME = 1f;

	private const int NUM_DECKS = 10;

	private StackOfCards cardStack = new StackOfCards(10);

	public override int MinPlayers => 1;

	public override int MinBuyIn => 5;

	public override int MaxBuyIn => int.MaxValue;

	public override int MinToPlay => MinBuyIn;

	public override int EndRoundDelay => 1;

	public override int TimeBetweenRounds => 4;

	public BlackjackInputOption LastAction { get; private set; }

	public ulong LastActionTarget { get; private set; }

	public int LastActionValue { get; private set; }

	public bool AllBetsPlaced
	{
		get
		{
			if (!base.HasRoundInProgressOrEnding)
			{
				return false;
			}
			foreach (CardPlayerData item in PlayersInRound())
			{
				if (item.betThisRound == 0)
				{
					return false;
				}
			}
			return true;
		}
	}

	public BlackjackController(BaseCardGameEntity owner)
		: base(owner)
	{
	}

	protected override int GetFirstPlayerRelIndex(bool startOfRound)
	{
		return 0;
	}

	public override List<PlayingCard> GetTableCards()
	{
		return dealerCards;
	}

	public void InputsToList(int availableInputs, List<BlackjackInputOption> result)
	{
		BlackjackInputOption[] array = (BlackjackInputOption[])Enum.GetValues(typeof(BlackjackInputOption));
		foreach (BlackjackInputOption blackjackInputOption in array)
		{
			if (blackjackInputOption != 0 && ((uint)availableInputs & (uint)blackjackInputOption) == (uint)blackjackInputOption)
			{
				result.Add(blackjackInputOption);
			}
		}
	}

	public bool WaitingForOtherPlayers(CardPlayerData pData)
	{
		if (!pData.HasUserInCurrentRound)
		{
			return false;
		}
		if (base.State == CardGameState.InGameRound && !pData.HasAvailableInputs)
		{
			foreach (CardPlayerData item in PlayersInRound())
			{
				if (item != pData && item.HasAvailableInputs)
				{
					return true;
				}
			}
		}
		return false;
	}

	public int GetCardsValue(List<PlayingCard> cards, CardsValueMode mode)
	{
		int num = 0;
		foreach (PlayingCard card in cards)
		{
			if (!card.IsUnknownCard)
			{
				num += GetCardValue(card, mode);
				if (card.Rank == Rank.Ace)
				{
					mode = CardsValueMode.Low;
				}
			}
		}
		return num;
	}

	public int GetOptimalCardsValue(List<PlayingCard> cards)
	{
		int cardsValue = GetCardsValue(cards, CardsValueMode.Low);
		int cardsValue2 = GetCardsValue(cards, CardsValueMode.High);
		if (cardsValue2 <= 21)
		{
			return cardsValue2;
		}
		return cardsValue;
	}

	public int GetCardValue(PlayingCard card, CardsValueMode mode)
	{
		int rank = (int)card.Rank;
		if (rank <= 8)
		{
			return rank + 2;
		}
		if (rank <= 11)
		{
			return 10;
		}
		if (mode != 0)
		{
			return 11;
		}
		return 1;
	}

	public bool Has21(List<PlayingCard> cards)
	{
		return GetOptimalCardsValue(cards) == 21;
	}

	public bool HasBlackjack(List<PlayingCard> cards)
	{
		if (GetCardsValue(cards, CardsValueMode.High) == 21)
		{
			return cards.Count == 2;
		}
		return false;
	}

	public bool HasBusted(List<PlayingCard> cards)
	{
		return GetCardsValue(cards, CardsValueMode.Low) > 21;
	}

	private bool CanSplit(CardPlayerDataBlackjack pData)
	{
		if (pData.Cards.Count != 2)
		{
			return false;
		}
		if (HasSplit(pData))
		{
			return false;
		}
		int betThisRound = pData.betThisRound;
		if (pData.GetScrapAmount() < betThisRound)
		{
			return false;
		}
		return GetCardValue(pData.Cards[0], CardsValueMode.Low) == GetCardValue(pData.Cards[1], CardsValueMode.Low);
	}

	private bool HasAnyAces(List<PlayingCard> cards)
	{
		foreach (PlayingCard card in cards)
		{
			if (card.Rank == Rank.Ace)
			{
				return true;
			}
		}
		return false;
	}

	private bool CanDoubleDown(CardPlayerDataBlackjack pData)
	{
		if (pData.Cards.Count != 2)
		{
			return false;
		}
		if (HasAnyAces(pData.Cards))
		{
			return false;
		}
		int betThisRound = pData.betThisRound;
		return pData.GetScrapAmount() >= betThisRound;
	}

	private bool CanTakeInsurance(CardPlayerDataBlackjack pData)
	{
		if (dealerCards.Count != 2)
		{
			return false;
		}
		if (dealerCards[1].Rank != Rank.Ace)
		{
			return false;
		}
		if (pData.insuranceBetThisRound > 0)
		{
			return false;
		}
		int num = Mathf.FloorToInt((float)pData.betThisRound / 2f);
		return pData.GetScrapAmount() >= num;
	}

	private bool HasSplit(CardPlayerDataBlackjack pData)
	{
		return pData.SplitCards.Count > 0;
	}

	protected override CardPlayerData GetNewCardPlayerData(int mountIndex)
	{
		if (base.IsServer)
		{
			return new CardPlayerDataBlackjack(base.ScrapItemID, base.Owner.GetPlayerStorage, mountIndex, base.IsServer);
		}
		return new CardPlayerDataBlackjack(mountIndex, base.IsServer);
	}

	public bool TryGetCardPlayerDataBlackjack(int index, out CardPlayerDataBlackjack cpBlackjack)
	{
		CardPlayerData cardPlayer;
		bool result = TryGetCardPlayerData(index, out cardPlayer);
		cpBlackjack = (CardPlayerDataBlackjack)cardPlayer;
		return result;
	}

	public int ResultsToInt(BlackjackRoundResult mainResult, BlackjackRoundResult splitResult, int insurancePayout)
	{
		return (int)(mainResult + 10 * (int)splitResult + 100 * insurancePayout);
	}

	public void ResultsFromInt(int result, out BlackjackRoundResult mainResult, out BlackjackRoundResult splitResult, out int insurancePayout)
	{
		mainResult = (BlackjackRoundResult)(result % 10);
		splitResult = (BlackjackRoundResult)(result / 10 % 10);
		insurancePayout = (result - mainResult - splitResult) / 100;
	}

	public override void Save(CardGame syncData)
	{
		syncData.blackjack = Pool.Get<Blackjack>();
		syncData.blackjack.dealerCards = Pool.Get<List<int>>();
		syncData.lastActionId = (int)LastAction;
		syncData.lastActionTarget = LastActionTarget;
		syncData.lastActionValue = LastActionValue;
		for (int i = 0; i < dealerCards.Count; i++)
		{
			PlayingCard playingCard = dealerCards[i];
			if (base.HasActiveRound && i == 0)
			{
				syncData.blackjack.dealerCards.Add(-1);
			}
			else
			{
				syncData.blackjack.dealerCards.Add(playingCard.GetIndex());
			}
		}
		base.Save(syncData);
		ClearLastAction();
	}

	private void EditorMakeRandomMove(CardPlayerDataBlackjack pdBlackjack)
	{
		List<BlackjackInputOption> list = Pool.Get<List<BlackjackInputOption>>();
		InputsToList(pdBlackjack.availableInputs, list);
		if (list.Count == 0)
		{
			Debug.Log((object)"No moves currently available.");
			Pool.FreeUnmanaged<BlackjackInputOption>(ref list);
			return;
		}
		BlackjackInputOption blackjackInputOption = list[Random.Range(0, list.Count)];
		if (AllBetsPlaced)
		{
			if (GetOptimalCardsValue(pdBlackjack.Cards) < 17 && list.Contains(BlackjackInputOption.Hit))
			{
				blackjackInputOption = BlackjackInputOption.Hit;
			}
			else if (list.Contains(BlackjackInputOption.Stand))
			{
				blackjackInputOption = BlackjackInputOption.Stand;
			}
		}
		else if (list.Contains(BlackjackInputOption.SubmitBet))
		{
			blackjackInputOption = BlackjackInputOption.SubmitBet;
		}
		if (list.Count > 0)
		{
			int value = 0;
			if (blackjackInputOption == BlackjackInputOption.SubmitBet)
			{
				value = MinBuyIn;
			}
			Debug.Log((object)(pdBlackjack.UserID + " Taking random action: " + blackjackInputOption.ToString() + " with value " + value));
			ReceivedInputFromPlayer(pdBlackjack, (int)blackjackInputOption, countAsAction: true, value);
		}
		else
		{
			Debug.LogWarning((object)(GetType().Name + ": No input options are available for the current player."));
		}
		Pool.FreeUnmanaged<BlackjackInputOption>(ref list);
	}

	protected override int GetAvailableInputsForPlayer(CardPlayerData pData)
	{
		BlackjackInputOption blackjackInputOption = BlackjackInputOption.None;
		CardPlayerDataBlackjack cardPlayerDataBlackjack = (CardPlayerDataBlackjack)pData;
		if (cardPlayerDataBlackjack == null || isWaitingBetweenTurns || cardPlayerDataBlackjack.hasCompletedTurn || !cardPlayerDataBlackjack.HasUserInCurrentRound)
		{
			return (int)blackjackInputOption;
		}
		if (!base.HasActiveRound)
		{
			return (int)blackjackInputOption;
		}
		if (AllBetsPlaced)
		{
			blackjackInputOption |= BlackjackInputOption.Stand;
			if (!Has21(cardPlayerDataBlackjack.Cards))
			{
				blackjackInputOption |= BlackjackInputOption.Hit;
			}
			if (CanSplit(cardPlayerDataBlackjack))
			{
				blackjackInputOption |= BlackjackInputOption.Split;
			}
			if (CanDoubleDown(cardPlayerDataBlackjack))
			{
				blackjackInputOption |= BlackjackInputOption.DoubleDown;
			}
			if (CanTakeInsurance(cardPlayerDataBlackjack))
			{
				blackjackInputOption |= BlackjackInputOption.Insurance;
			}
		}
		else
		{
			blackjackInputOption |= BlackjackInputOption.SubmitBet;
			blackjackInputOption |= BlackjackInputOption.MaxBet;
		}
		return (int)blackjackInputOption;
	}

	protected override void SubEndGameplay()
	{
		dealerCards.Clear();
	}

	protected override void SubEndRound()
	{
		int dealerCardsVal = GetOptimalCardsValue(dealerCards);
		if (dealerCardsVal > 21)
		{
			dealerCardsVal = 0;
		}
		base.resultInfo.winningScore = dealerCardsVal;
		if (NumPlayersInCurrentRound() == 0)
		{
			base.Owner.ClientRPC(RpcTarget.NetworkGroup("OnResultsDeclared"), base.resultInfo);
			return;
		}
		bool dealerHasBlackjack = HasBlackjack(dealerCards);
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			int num = 0;
			int winnings2;
			BlackjackRoundResult mainResult = CheckResult(item.Cards, item.betThisRound, out winnings2);
			num += winnings2;
			BlackjackRoundResult splitResult = CheckResult(item.SplitCards, item.splitBetThisRound, out winnings2);
			num += winnings2;
			int num2 = item.betThisRound + item.splitBetThisRound + item.insuranceBetThisRound;
			int insurancePayout = 0;
			if (dealerHasBlackjack && item.insuranceBetThisRound > 0)
			{
				int num3 = Mathf.FloorToInt((float)item.insuranceBetThisRound * 3f);
				num += num3;
				insurancePayout = num3;
			}
			int resultCode = ResultsToInt(mainResult, splitResult, insurancePayout);
			AddRoundResult(item, num - num2, resultCode);
			PayOut(item, num);
		}
		ClearPot();
		base.Owner.ClientRPC(RpcTarget.NetworkGroup("OnResultsDeclared"), base.resultInfo);
		BlackjackRoundResult CheckResult(List<PlayingCard> cards, int betAmount, out int winnings)
		{
			if (cards.Count == 0)
			{
				winnings = 0;
				return BlackjackRoundResult.None;
			}
			int optimalCardsValue = GetOptimalCardsValue(cards);
			if (optimalCardsValue > 21)
			{
				winnings = 0;
				return BlackjackRoundResult.Bust;
			}
			if (optimalCardsValue > base.resultInfo.winningScore)
			{
				base.resultInfo.winningScore = optimalCardsValue;
			}
			BlackjackRoundResult blackjackRoundResult = BlackjackRoundResult.Loss;
			bool flag = HasBlackjack(cards);
			if (dealerHasBlackjack)
			{
				if (flag)
				{
					blackjackRoundResult = BlackjackRoundResult.Standoff;
				}
			}
			else if (optimalCardsValue > dealerCardsVal)
			{
				blackjackRoundResult = (flag ? BlackjackRoundResult.BlackjackWin : BlackjackRoundResult.Win);
			}
			else if (optimalCardsValue == dealerCardsVal)
			{
				blackjackRoundResult = ((!flag) ? BlackjackRoundResult.Standoff : BlackjackRoundResult.BlackjackWin);
			}
			switch (blackjackRoundResult)
			{
			case BlackjackRoundResult.BlackjackWin:
				winnings = Mathf.FloorToInt((float)betAmount * 2.5f);
				break;
			case BlackjackRoundResult.Win:
				winnings = Mathf.FloorToInt((float)betAmount * 2f);
				break;
			case BlackjackRoundResult.Standoff:
				winnings = betAmount;
				break;
			default:
				winnings = 0;
				break;
			}
			return blackjackRoundResult;
		}
	}

	private int PayOut(CardPlayerData pData, int winnings)
	{
		if (winnings == 0)
		{
			return 0;
		}
		StorageContainer storage = pData.GetStorage();
		if ((Object)(object)storage == (Object)null)
		{
			return 0;
		}
		storage.inventory.AddItem(base.Owner.scrapItemDef, winnings, 0uL, ItemContainer.LimitStack.None);
		return winnings;
	}

	protected override void HandlePlayerLeavingTable(CardPlayerData pData)
	{
		if (pData.HasUserInCurrentRound)
		{
			ReceivedInputFromPlayer(pData, 128, countAsAction: true, 0, playerInitiated: false);
		}
	}

	protected override void SubReceivedInputFromPlayer(CardPlayerData pData, int input, int value, bool countAsAction)
	{
		if (!Enum.IsDefined(typeof(BlackjackInputOption), input))
		{
			return;
		}
		BlackjackInputOption selectedMove = (BlackjackInputOption)input;
		CardPlayerDataBlackjack pdBlackjack = (CardPlayerDataBlackjack)pData;
		if (!base.HasActiveRound)
		{
			LastActionTarget = pData.UserID;
			LastAction = selectedMove;
			LastActionValue = 0;
			return;
		}
		int selectedMoveValue = 0;
		if (AllBetsPlaced)
		{
			DoInRoundPlayerInput(pdBlackjack, ref selectedMove, ref selectedMoveValue);
		}
		else
		{
			DoBettingPhasePlayerInput(pdBlackjack, value, countAsAction, ref selectedMove, ref selectedMoveValue);
		}
		LastActionTarget = pData.UserID;
		LastAction = selectedMove;
		LastActionValue = selectedMoveValue;
		if (NumPlayersInCurrentRound() == 0)
		{
			EndGameplay();
			return;
		}
		if (ShouldEndCycle())
		{
			EndCycle();
			return;
		}
		StartTurnTimer(pData, MaxTurnTime);
		base.Owner.SendNetworkUpdate();
	}

	private void DoInRoundPlayerInput(CardPlayerDataBlackjack pdBlackjack, ref BlackjackInputOption selectedMove, ref int selectedMoveValue)
	{
		if (selectedMove != BlackjackInputOption.Abandon && ((uint)pdBlackjack.availableInputs & (uint)selectedMove) != (uint)selectedMove)
		{
			return;
		}
		switch (selectedMove)
		{
		case BlackjackInputOption.Hit:
		{
			cardStack.TryTakeCard(out var card3);
			pdBlackjack.Cards.Add(card3);
			break;
		}
		case BlackjackInputOption.Stand:
			if (!pdBlackjack.TrySwitchToSplitHand())
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
			break;
		case BlackjackInputOption.Split:
		{
			PlayingCard playingCard = pdBlackjack.Cards[1];
			bool num = playingCard.Rank == Rank.Ace;
			pdBlackjack.SplitCards.Add(playingCard);
			pdBlackjack.Cards.Remove(playingCard);
			cardStack.TryTakeCard(out var card2);
			pdBlackjack.Cards.Add(card2);
			cardStack.TryTakeCard(out card2);
			pdBlackjack.SplitCards.Add(card2);
			selectedMoveValue = TryMakeBet(pdBlackjack, pdBlackjack.betThisRound, BetType.Split);
			if (num)
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
			break;
		}
		case BlackjackInputOption.DoubleDown:
		{
			selectedMoveValue = TryMakeBet(pdBlackjack, pdBlackjack.betThisRound, BetType.Main);
			cardStack.TryTakeCard(out var card);
			pdBlackjack.Cards.Add(card);
			if (!pdBlackjack.TrySwitchToSplitHand())
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
			break;
		}
		case BlackjackInputOption.Insurance:
		{
			int maxAmount = Mathf.FloorToInt((float)pdBlackjack.betThisRound / 2f);
			selectedMoveValue = TryMakeBet(pdBlackjack, maxAmount, BetType.Insurance);
			break;
		}
		case BlackjackInputOption.Abandon:
			pdBlackjack.LeaveGame();
			break;
		}
		if (HasBusted(pdBlackjack.Cards) && !pdBlackjack.TrySwitchToSplitHand())
		{
			pdBlackjack.SetHasCompletedTurn(hasActed: true);
		}
		if (Has21(pdBlackjack.Cards) && !CanTakeInsurance(pdBlackjack) && !CanDoubleDown(pdBlackjack) && !CanSplit(pdBlackjack) && !pdBlackjack.TrySwitchToSplitHand())
		{
			pdBlackjack.SetHasCompletedTurn(hasActed: true);
		}
	}

	private void DoBettingPhasePlayerInput(CardPlayerDataBlackjack pdBlackjack, int value, bool countAsAction, ref BlackjackInputOption selectedMove, ref int selectedMoveValue)
	{
		if (selectedMove != BlackjackInputOption.Abandon && ((uint)pdBlackjack.availableInputs & (uint)selectedMove) != (uint)selectedMove)
		{
			return;
		}
		if (selectedMove == BlackjackInputOption.SubmitBet)
		{
			selectedMoveValue = TryMakeBet(pdBlackjack, value, BetType.Main);
			if (countAsAction)
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
		}
		else if (selectedMove == BlackjackInputOption.MaxBet)
		{
			selectedMoveValue = TryMakeBet(pdBlackjack, BlackjackMachine.maxbet, BetType.Main);
			if (countAsAction)
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
		}
		else if (selectedMove == BlackjackInputOption.Abandon)
		{
			pdBlackjack.LeaveGame();
		}
	}

	private int TryMakeBet(CardPlayerDataBlackjack pdBlackjack, int maxAmount, BetType betType)
	{
		int num = TryMoveToPotStorage(pdBlackjack, maxAmount);
		switch (betType)
		{
		case BetType.Main:
			pdBlackjack.betThisTurn += num;
			pdBlackjack.betThisRound += num;
			break;
		case BetType.Split:
			pdBlackjack.splitBetThisRound += num;
			break;
		case BetType.Insurance:
			pdBlackjack.insuranceBetThisRound += num;
			break;
		}
		return num;
	}

	protected override void SubStartRound()
	{
		dealerCards.Clear();
		cardStack = new StackOfCards(10);
		ClearLastAction();
		ServerPlaySound(CardGameSounds.SoundType.Shuffle);
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			item.EnableSendingCards();
			item.availableInputs = GetAvailableInputsForPlayer(item);
			StartTurnTimer(item, MaxTurnTime);
		}
	}

	protected override void OnTurnTimeout(CardPlayerData pData)
	{
		if (!pData.HasUserInCurrentRound || pData.hasCompletedTurn)
		{
			return;
		}
		BlackjackInputOption blackjackInputOption = BlackjackInputOption.Abandon;
		int value = 0;
		if (AllBetsPlaced)
		{
			if ((pData.availableInputs & 4) == 4)
			{
				blackjackInputOption = BlackjackInputOption.Stand;
				ReceivedInputFromPlayer(pData, 4, countAsAction: true, 0, playerInitiated: false);
			}
		}
		else if ((pData.availableInputs & 1) == 1 && pData.GetScrapAmount() >= MinBuyIn)
		{
			blackjackInputOption = BlackjackInputOption.SubmitBet;
			value = MinBuyIn;
		}
		if (blackjackInputOption != BlackjackInputOption.Abandon)
		{
			ReceivedInputFromPlayer(pData, (int)blackjackInputOption, countAsAction: true, value, playerInitiated: false);
			return;
		}
		blackjackInputOption = BlackjackInputOption.Abandon;
		ReceivedInputFromPlayer(pData, (int)blackjackInputOption, countAsAction: true, 0, playerInitiated: false);
		pData.ClearAllData();
		if (base.HasActiveRound && NumPlayersInCurrentRound() < MinPlayers)
		{
			BeginRoundEnd();
		}
		if (pData.HasUserInGame)
		{
			base.Owner.ClientRPC(RpcTarget.NetworkGroup("ClientOnPlayerLeft"), pData.UserID);
		}
		base.Owner.SendNetworkUpdate();
	}

	protected override void StartNextCycle()
	{
		base.StartNextCycle();
		if (ShouldEndCycle())
		{
			EndCycle();
			return;
		}
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			StartTurnTimer(item, MaxTurnTime);
		}
		UpdateAllAvailableInputs();
		base.Owner.SendNetworkUpdate();
	}

	protected override bool ShouldEndCycle()
	{
		foreach (CardPlayerData item in PlayersInRound())
		{
			if (!item.hasCompletedTurn)
			{
				return false;
			}
		}
		return true;
	}

	protected override void EndCycle()
	{
		CardPlayerData[] playerData = base.PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			playerData[i].SetHasCompletedTurn(hasActed: false);
		}
		if (dealerCards.Count == 0)
		{
			DealInitialCards();
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			QueueNextCycleInvoke();
			return;
		}
		bool flag = true;
		bool flag2 = true;
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			if (!HasBusted(item.Cards))
			{
				flag = false;
			}
			if (!HasBlackjack(item.Cards))
			{
				flag2 = false;
			}
			if (item.SplitCards.Count > 0)
			{
				if (!HasBusted(item.SplitCards))
				{
					flag = false;
				}
				if (!HasBlackjack(item.SplitCards))
				{
					flag2 = false;
				}
			}
			if (!flag && !flag2)
			{
				break;
			}
		}
		ServerPlaySound(CardGameSounds.SoundType.Draw);
		if (NumPlayersInCurrentRound() > 0 && !flag && !flag2)
		{
			((FacepunchBehaviour)base.Owner).Invoke((Action)DealerPlayInvoke, 1f);
			BeginRoundEnd();
		}
		else
		{
			EndRoundWithDelay();
		}
	}

	private void DealerPlayInvoke()
	{
		int cardsValue = GetCardsValue(dealerCards, CardsValueMode.High);
		if (GetCardsValue(dealerCards, CardsValueMode.Low) < 17 && (cardsValue < 18 || cardsValue > 21))
		{
			cardStack.TryTakeCard(out var card);
			dealerCards.Add(card);
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			((FacepunchBehaviour)base.Owner).Invoke((Action)DealerPlayInvoke, 1f);
			base.Owner.SendNetworkUpdate();
		}
		else
		{
			EndRoundWithDelay();
		}
	}

	private void DealInitialCards()
	{
		if (!base.HasActiveRound)
		{
			return;
		}
		PlayingCard card;
		foreach (CardPlayerData item in PlayersInRound())
		{
			cardStack.TryTakeCard(out card);
			item.Cards.Add(card);
		}
		cardStack.TryTakeCard(out card);
		dealerCards.Add(card);
		foreach (CardPlayerData item2 in PlayersInRound())
		{
			cardStack.TryTakeCard(out card);
			item2.Cards.Add(card);
			if (HasBlackjack(item2.Cards))
			{
				item2.SetHasCompletedTurn(hasActed: true);
			}
		}
		cardStack.TryTakeCard(out card);
		dealerCards.Add(card);
	}

	private void ClearLastAction()
	{
		LastAction = BlackjackInputOption.None;
		LastActionTarget = 0uL;
		LastActionValue = 0;
	}
}


using System;

[Flags]
public enum BlackjackInputOption
{
	None = 0,
	SubmitBet = 1,
	Hit = 2,
	Stand = 4,
	Split = 8,
	DoubleDown = 0x10,
	Insurance = 0x20,
	MaxBet = 0x40,
	Abandon = 0x80
}


public enum BlackjackRoundResult
{
	None,
	Bust,
	Loss,
	Standoff,
	Win,
	BlackjackWin
}


public enum CardsValueMode
{
	Low,
	High
}


private enum BetType
{
	Main,
	Split,
	Insurance
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.CardGames;
using Network;
using ProtoBuf;
using UnityEngine;

public abstract class CardGameController : IDisposable
{
	public enum CardGameState
	{
		NotPlaying,
		InGameBetweenRounds,
		InGameRound,
		InGameRoundEnding
	}

	public enum Playability
	{
		OK,
		NoPlayer,
		NotEnoughBuyIn,
		TooMuchBuyIn,
		RanOutOfScrap,
		Idle
	}

	public const int IDLE_KICK_SECONDS = 240;

	public readonly CardList localPlayerCards;

	protected int activePlayerIndex;

	public const int STD_RAISE_INCREMENTS = 5;

	protected bool isWaitingBetweenTurns;

	public CardGameState State { get; set; }

	public bool HasGameInProgress => State >= CardGameState.InGameBetweenRounds;

	public bool HasRoundInProgressOrEnding
	{
		get
		{
			if (State != CardGameState.InGameRound)
			{
				return State == CardGameState.InGameRoundEnding;
			}
			return true;
		}
	}

	public bool HasActiveRound => State == CardGameState.InGameRound;

	public CardPlayerData[] PlayerData { get; private set; }

	public abstract int MinPlayers { get; }

	public abstract int MinBuyIn { get; }

	public abstract int MaxBuyIn { get; }

	public abstract int MinToPlay { get; }

	public virtual float MaxTurnTime => 30f;

	public virtual int EndRoundDelay => 0;

	public virtual int TimeBetweenRounds => 8;

	protected virtual float TimeBetweenTurns => 1f;

	public BaseCardGameEntity Owner { get; set; }

	public int ScrapItemID => Owner.ScrapItemID;

	protected bool IsServer => Owner.isServer;

	protected bool IsClient => Owner.isClient;

	public RoundResults resultInfo { get; private set; }

	public CardGameController(BaseCardGameEntity owner)
	{
		Owner = owner;
		PlayerData = new CardPlayerData[MaxPlayersAtTable()];
		resultInfo = Pool.Get<RoundResults>();
		resultInfo.results = Pool.Get<List<Result>>();
		localPlayerCards = Pool.Get<CardList>();
		localPlayerCards.cards = Pool.Get<List<int>>();
		for (int i = 0; i < PlayerData.Length; i++)
		{
			PlayerData[i] = GetNewCardPlayerData(i);
		}
	}

	public IEnumerable<CardPlayerData> PlayersInRound()
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.HasUserInCurrentRound)
			{
				yield return cardPlayerData;
			}
		}
	}

	protected abstract int GetFirstPlayerRelIndex(bool startOfRound);

	public void Dispose()
	{
		for (int i = 0; i < PlayerData.Length; i++)
		{
			PlayerData[i].Dispose();
		}
		localPlayerCards.Dispose();
		resultInfo.Dispose();
	}

	public int NumPlayersAllowedToPlay(CardPlayerData ignore = null)
	{
		int num = 0;
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData != ignore && IsAllowedToPlay(cardPlayerData))
			{
				num++;
			}
		}
		return num;
	}

	public Playability GetPlayabilityStatus(CardPlayerData cpd)
	{
		if (!cpd.HasUser)
		{
			return Playability.NoPlayer;
		}
		int scrapAmount = cpd.GetScrapAmount();
		if (cpd.HasUserInGame)
		{
			if (scrapAmount < MinToPlay)
			{
				return Playability.RanOutOfScrap;
			}
		}
		else
		{
			if (scrapAmount < MinBuyIn)
			{
				return Playability.NotEnoughBuyIn;
			}
			if (scrapAmount > MaxBuyIn)
			{
				return Playability.TooMuchBuyIn;
			}
		}
		return Playability.OK;
	}

	public bool TryGetActivePlayer(out CardPlayerData activePlayer)
	{
		return ToCardPlayerData(activePlayerIndex, includeOutOfRound: false, out activePlayer);
	}

	protected bool ToCardPlayerData(int relIndex, bool includeOutOfRound, out CardPlayerData result)
	{
		if (!HasRoundInProgressOrEnding)
		{
			Debug.LogWarning((object)(GetType().Name + ": Tried to call ToCardPlayerData while no round was in progress. Returning null."));
			result = null;
			return false;
		}
		int num = (includeOutOfRound ? NumPlayersInGame() : NumPlayersInCurrentRound());
		int index = RelToAbsIndex(relIndex % num, includeOutOfRound);
		return TryGetCardPlayerData(index, out result);
	}

	public int RelToAbsIndex(int relIndex, bool includeFolded)
	{
		if (!HasRoundInProgressOrEnding)
		{
			Debug.LogError((object)(GetType().Name + ": Called RelToAbsIndex outside of a round. No-one is playing. Returning -1."));
			return -1;
		}
		int num = 0;
		for (int i = 0; i < PlayerData.Length; i++)
		{
			if (includeFolded ? PlayerData[i].HasUserInGame : PlayerData[i].HasUserInCurrentRound)
			{
				if (num == relIndex)
				{
					return i;
				}
				num++;
			}
		}
		Debug.LogError((object)$"{GetType().Name}: No absolute index found for relative index {relIndex}. Only {NumPlayersInCurrentRound()} total players are in the round. Returning -1.");
		return -1;
	}

	public int GameToRoundIndex(int gameRelIndex)
	{
		if (!HasRoundInProgressOrEnding)
		{
			Debug.LogError((object)(GetType().Name + ": Called GameToRoundIndex outside of a round. No-one is playing. Returning 0."));
			return 0;
		}
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < PlayerData.Length; i++)
		{
			if (PlayerData[i].HasUserInCurrentRound)
			{
				if (num == gameRelIndex)
				{
					return num2;
				}
				num++;
				num2++;
			}
			else if (PlayerData[i].HasUserInGame)
			{
				if (num == gameRelIndex)
				{
					return num2;
				}
				num++;
			}
		}
		Debug.LogError((object)$"{GetType().Name}: No round index found for game index {gameRelIndex}. Only {NumPlayersInCurrentRound()} total players are in the round. Returning 0.");
		return 0;
	}

	public int NumPlayersInGame()
	{
		int num = 0;
		CardPlayerData[] playerData = PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			if (playerData[i].HasUserInGame)
			{
				num++;
			}
		}
		return num;
	}

	public int NumPlayersInCurrentRound()
	{
		int num = 0;
		CardPlayerData[] playerData = PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			if (playerData[i].HasUserInCurrentRound)
			{
				num++;
			}
		}
		return num;
	}

	public int MaxPlayersAtTable()
	{
		return Owner.mountPoints.Count;
	}

	public bool PlayerIsInGame(BasePlayer player)
	{
		return PlayerData.Any((CardPlayerData data) => data.HasUserInGame && data.UserID == (ulong)player.userID);
	}

	public bool IsAtTable(BasePlayer player)
	{
		return IsAtTable(player.userID);
	}

	public virtual List<PlayingCard> GetTableCards()
	{
		return null;
	}

	public void StartTurnTimer(CardPlayerData pData, float turnTime)
	{
		if (IsServer)
		{
			pData.StartTurnTimer(OnTurnTimeout, turnTime);
			Owner.ClientRPC(RpcTarget.NetworkGroup("ClientStartTurnTimer"), pData.mountIndex, turnTime);
		}
	}

	public bool IsAtTable(ulong userID)
	{
		return PlayerData.Any((CardPlayerData data) => data.UserID == userID);
	}

	public int GetScrapInPot()
	{
		if (IsServer)
		{
			StorageContainer pot = Owner.GetPot();
			if ((Object)(object)pot != (Object)null)
			{
				return pot.inventory.GetAmount(ScrapItemID, onlyUsableAmounts: true);
			}
			return 0;
		}
		return 0;
	}

	public bool TryGetCardPlayerData(int index, out CardPlayerData cardPlayer)
	{
		if (index >= 0 && index < PlayerData.Length)
		{
			cardPlayer = PlayerData[index];
			return true;
		}
		cardPlayer = null;
		return false;
	}

	public bool TryGetCardPlayerData(ulong forPlayer, out CardPlayerData cardPlayer)
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.UserID == forPlayer)
			{
				cardPlayer = cardPlayerData;
				return true;
			}
		}
		cardPlayer = null;
		return false;
	}

	public bool TryGetCardPlayerData(BasePlayer forPlayer, out CardPlayerData cardPlayer)
	{
		for (int i = 0; i < PlayerData.Length; i++)
		{
			if (PlayerData[i].UserID == (ulong)forPlayer.userID)
			{
				cardPlayer = PlayerData[i];
				return true;
			}
		}
		cardPlayer = null;
		return false;
	}

	public bool IsAllowedToPlay(CardPlayerData cpd)
	{
		return GetPlayabilityStatus(cpd) == Playability.OK;
	}

	protected void ClearResultsInfo()
	{
		if (resultInfo.results == null)
		{
			return;
		}
		foreach (Result result in resultInfo.results)
		{
			if (result != null)
			{
				result.Dispose();
			}
		}
		resultInfo.results.Clear();
	}

	protected abstract CardPlayerData GetNewCardPlayerData(int mountIndex);

	protected abstract void OnTurnTimeout(CardPlayerData playerData);

	protected abstract void SubStartRound();

	protected abstract void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction);

	protected abstract int GetAvailableInputsForPlayer(CardPlayerData playerData);

	protected abstract void HandlePlayerLeavingTable(CardPlayerData pData);

	protected abstract void SubEndRound();

	protected abstract void SubEndGameplay();

	protected abstract void EndCycle();

	protected abstract bool ShouldEndCycle();

	public void EditorMakeRandomMove()
	{
	}

	public void JoinTable(BasePlayer player)
	{
		JoinTable(player.userID);
	}

	protected void SyncAllLocalPlayerCards()
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData pData in playerData)
		{
			SyncLocalPlayerCards(pData);
		}
	}

	protected void SyncLocalPlayerCards(CardPlayerData pData)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(pData.UserID);
		if ((Object)(object)basePlayer == (Object)null || !pData.HasUserInGame)
		{
			return;
		}
		localPlayerCards.cards.Clear();
		foreach (PlayingCard card in pData.Cards)
		{
			localPlayerCards.cards.Add(card.GetIndex());
		}
		Owner.ClientRPC(RpcTarget.Player("ReceiveCardsForPlayer", basePlayer), localPlayerCards);
	}

	public void JoinTable(ulong userID)
	{
		if (IsAtTable(userID) || NumPlayersAllowedToPlay() >= MaxPlayersAtTable())
		{
			return;
		}
		int mountPointIndex = Owner.GetMountPointIndex(userID);
		if (mountPointIndex < 0)
		{
			return;
		}
		PlayerData[mountPointIndex].AddUser(userID);
		if (!HasGameInProgress)
		{
			if (!TryStartNewRound())
			{
				Owner.SendNetworkUpdate();
			}
		}
		else
		{
			Owner.SendNetworkUpdate();
		}
	}

	public void LeaveTable(ulong userID)
	{
		if (TryGetCardPlayerData(userID, out var cardPlayer))
		{
			LeaveTable(cardPlayer);
		}
	}

	public void LeaveTable(CardPlayerData pData)
	{
		if (HasActiveRound)
		{
			HandlePlayerLeavingTable(pData);
		}
		pData.ClearAllData();
		if (HasActiveRound && NumPlayersInCurrentRound() < MinPlayers)
		{
			EndRoundWithDelay();
		}
		if (pData.HasUserInGame)
		{
			Owner.ClientRPC(RpcTarget.NetworkGroup("ClientOnPlayerLeft"), pData.UserID);
		}
		Owner.SendNetworkUpdate();
	}

	protected int TryAddBet(CardPlayerData playerData, int maxAmount)
	{
		int num = TryMoveToPotStorage(playerData, maxAmount);
		playerData.betThisRound += num;
		playerData.betThisTurn += num;
		return num;
	}

	protected int GoAllIn(CardPlayerData playerData)
	{
		int num = TryMoveToPotStorage(playerData, 999999);
		playerData.betThisRound += num;
		playerData.betThisTurn += num;
		return num;
	}

	protected int TryMoveToPotStorage(CardPlayerData playerData, int maxAmount)
	{
		int num = 0;
		StorageContainer storage = playerData.GetStorage();
		StorageContainer pot = Owner.GetPot();
		if ((Object)(object)storage != (Object)null && (Object)(object)pot != (Object)null)
		{
			List<Item> list = Pool.Get<List<Item>>();
			num = storage.inventory.Take(list, ScrapItemID, maxAmount);
			if (num > 0)
			{
				foreach (Item item in list)
				{
					if (!item.MoveToContainer(pot.inventory, -1, allowStack: true, ignoreStackLimit: true))
					{
						item.MoveToContainer(storage.inventory);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": TryAddToPot: Null storage."));
		}
		return num;
	}

	protected int PayOutFromPot(CardPlayerData playerData, int maxAmount)
	{
		int num = 0;
		StorageContainer storage = playerData.GetStorage();
		StorageContainer pot = Owner.GetPot();
		if ((Object)(object)storage != (Object)null && (Object)(object)pot != (Object)null)
		{
			List<Item> list = Pool.Get<List<Item>>();
			num = pot.inventory.Take(list, ScrapItemID, maxAmount);
			if (num > 0)
			{
				foreach (Item item in list)
				{
					if (!item.MoveToContainer(storage.inventory, -1, allowStack: true, ignoreStackLimit: true))
					{
						item.MoveToContainer(pot.inventory);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": PayOut: Null storage."));
		}
		return num;
	}

	protected int PayOutAllFromPot(CardPlayerData playerData)
	{
		return PayOutFromPot(playerData, int.MaxValue);
	}

	protected void ClearPot()
	{
		StorageContainer pot = Owner.GetPot();
		if ((Object)(object)pot != (Object)null)
		{
			pot.inventory.Clear();
		}
	}

	public int RemoveScrapFromStorage(CardPlayerData data)
	{
		StorageContainer storage = data.GetStorage();
		BasePlayer basePlayer = BasePlayer.FindByID(data.UserID);
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			List<Item> list = Pool.Get<List<Item>>();
			num = storage.inventory.Take(list, ScrapItemID, int.MaxValue);
			if (num > 0)
			{
				foreach (Item item in list)
				{
					if (!item.MoveToContainer(basePlayer.inventory.containerMain, -1, allowStack: true, ignoreStackLimit: true))
					{
						item.MoveToContainer(storage.inventory);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
		}
		return num;
	}

	public virtual void Save(CardGame syncData)
	{
		syncData.players = Pool.Get<List<CardPlayer>>();
		syncData.state = (int)State;
		syncData.activePlayerIndex = activePlayerIndex;
		CardPlayerData[] playerData = PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			playerData[i].Save(syncData);
		}
		syncData.pot = GetScrapInPot();
	}

	public void InvokeStartNewRound()
	{
		TryStartNewRound();
	}

	public bool TryStartNewRound()
	{
		if (HasRoundInProgressOrEnding)
		{
			return false;
		}
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			BasePlayer basePlayer;
			if (State == CardGameState.NotPlaying)
			{
				cardPlayerData.lastActionTime = Time.unscaledTime;
			}
			else if (cardPlayerData.HasBeenIdleFor(240) && BasePlayer.TryFindByID(cardPlayerData.UserID, out basePlayer))
			{
				basePlayer.GetMounted().DismountPlayer(basePlayer);
			}
		}
		if (NumPlayersAllowedToPlay() < MinPlayers)
		{
			EndGameplay();
			return false;
		}
		playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData2 in playerData)
		{
			if (IsAllowedToPlay(cardPlayerData2))
			{
				cardPlayerData2.JoinRound();
			}
			else
			{
				cardPlayerData2.LeaveGame();
			}
		}
		State = CardGameState.InGameRound;
		SubStartRound();
		Owner.SendNetworkUpdate();
		return true;
	}

	protected void BeginRoundEnd()
	{
		State = CardGameState.InGameRoundEnding;
		CancelNextCycleInvoke();
		Owner.SendNetworkUpdate();
	}

	protected void EndRoundWithDelay()
	{
		State = CardGameState.InGameRoundEnding;
		CancelNextCycleInvoke();
		Owner.SendNetworkUpdate();
		((FacepunchBehaviour)Owner).Invoke((Action)EndRound, (float)EndRoundDelay);
	}

	public void EndRound()
	{
		State = CardGameState.InGameBetweenRounds;
		CancelNextCycleInvoke();
		ClearResultsInfo();
		SubEndRound();
		foreach (CardPlayerData item in PlayersInRound())
		{
			BasePlayer basePlayer = BasePlayer.FindByID(item.UserID);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.metabolism.CanConsume())
			{
				basePlayer.metabolism.MarkConsumption();
				basePlayer.metabolism.ApplyChange(MetabolismAttribute.Type.Calories, 2f, 0f);
				basePlayer.metabolism.ApplyChange(MetabolismAttribute.Type.Hydration, 2f, 0f);
			}
			item.LeaveCurrentRound(clearBets: true, leftRoundEarly: false);
		}
		UpdateAllAvailableInputs();
		Owner.SendNetworkUpdate();
		((FacepunchBehaviour)Owner).Invoke((Action)InvokeStartNewRound, (float)TimeBetweenRounds);
	}

	protected virtual void AddRoundResult(CardPlayerData pData, int winnings, int resultCode)
	{
		foreach (Result result in resultInfo.results)
		{
			if (result.ID == pData.UserID)
			{
				result.winnings += winnings;
				return;
			}
		}
		Result val = Pool.Get<Result>();
		val.ID = pData.UserID;
		val.winnings = winnings;
		val.resultCode = resultCode;
		resultInfo.results.Add(val);
	}

	protected void EndGameplay()
	{
		if (HasGameInProgress)
		{
			CancelNextCycleInvoke();
			SubEndGameplay();
			State = CardGameState.NotPlaying;
			CardPlayerData[] playerData = PlayerData;
			for (int i = 0; i < playerData.Length; i++)
			{
				playerData[i].LeaveGame();
			}
			SyncAllLocalPlayerCards();
			Owner.SendNetworkUpdate();
		}
	}

	public void ReceivedInputFromPlayer(BasePlayer player, int input, bool countAsAction, int value = 0)
	{
		if (!((Object)(object)player == (Object)null))
		{
			player.ResetInputIdleTime();
			if (TryGetCardPlayerData(player, out var cardPlayer))
			{
				ReceivedInputFromPlayer(cardPlayer, input, countAsAction, value);
			}
		}
	}

	public void ReceivedInputFromPlayer(CardPlayerData pData, int input, bool countAsAction, int value = 0, bool playerInitiated = true)
	{
		if (HasGameInProgress && pData != null)
		{
			if (playerInitiated)
			{
				pData.lastActionTime = Time.unscaledTime;
			}
			SubReceivedInputFromPlayer(pData, input, value, countAsAction);
			if (HasActiveRound)
			{
				UpdateAllAvailableInputs();
				Owner.SendNetworkUpdate();
			}
		}
	}

	public void UpdateAllAvailableInputs()
	{
		for (int i = 0; i < PlayerData.Length; i++)
		{
			PlayerData[i].availableInputs = GetAvailableInputsForPlayer(PlayerData[i]);
		}
	}

	public void PlayerStorageChanged()
	{
		if (!HasGameInProgress)
		{
			TryStartNewRound();
		}
	}

	public void ServerPlaySound(CardGameSounds.SoundType type)
	{
		Owner.ClientRPC(RpcTarget.NetworkGroup("ClientPlaySound"), (int)type);
	}

	public void GetConnectionsInGame(List<Connection> connections)
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.HasUserInGame && BasePlayer.TryFindByID(cardPlayerData.UserID, out var basePlayer))
			{
				connections.Add(basePlayer.net.connection);
			}
		}
	}

	public virtual void OnTableDestroyed()
	{
		CardPlayerData[] playerData;
		if (HasGameInProgress)
		{
			playerData = PlayerData;
			foreach (CardPlayerData cardPlayerData in playerData)
			{
				if (cardPlayerData.HasUserInGame)
				{
					PayOutFromPot(cardPlayerData, cardPlayerData.GetTotalBetThisRound());
				}
			}
			if (GetScrapInPot() > 0)
			{
				int maxAmount = GetScrapInPot() / NumPlayersInGame();
				playerData = PlayerData;
				foreach (CardPlayerData cardPlayerData2 in playerData)
				{
					if (cardPlayerData2.HasUserInGame)
					{
						PayOutFromPot(cardPlayerData2, maxAmount);
					}
				}
			}
		}
		playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData3 in playerData)
		{
			if (cardPlayerData3.HasUser)
			{
				RemoveScrapFromStorage(cardPlayerData3);
			}
		}
	}

	protected bool TryMoveToNextPlayerWithInputs(int startIndex, out CardPlayerData newActivePlayer)
	{
		activePlayerIndex = startIndex;
		TryGetActivePlayer(out newActivePlayer);
		int num = 0;
		bool flag = false;
		while (GetAvailableInputsForPlayer(newActivePlayer) == 0)
		{
			if (num == NumPlayersInCurrentRound())
			{
				flag = true;
				break;
			}
			activePlayerIndex = (activePlayerIndex + 1) % NumPlayersInCurrentRound();
			TryGetActivePlayer(out newActivePlayer);
			num++;
		}
		return !flag;
	}

	protected virtual void StartNextCycle()
	{
		isWaitingBetweenTurns = false;
	}

	protected void QueueNextCycleInvoke()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)StartNextCycle, TimeBetweenTurns);
		isWaitingBetweenTurns = true;
		Owner.SendNetworkUpdate();
	}

	private void CancelNextCycleInvoke()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).CancelInvoke((Action)StartNextCycle);
		isWaitingBetweenTurns = false;
	}
}


public enum CardGameState
{
	NotPlaying,
	InGameBetweenRounds,
	InGameRound,
	InGameRoundEnding
}


public enum Playability
{
	OK,
	NoPlayer,
	NotEnoughBuyIn,
	TooMuchBuyIn,
	RanOutOfScrap,
	Idle
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using ProtoBuf;
using UnityEngine;

public class CardPlayerData : IDisposable
{
	public enum CardPlayerState
	{
		None,
		WantsToPlay,
		InGame,
		InCurrentRound
	}

	public List<PlayingCard> Cards;

	public readonly int mountIndex;

	private readonly bool isServer;

	[NonSerialized]
	public int availableInputs;

	public int betThisRound;

	public int betThisTurn;

	[NonSerialized]
	public int finalScore;

	[NonSerialized]
	public float lastActionTime;

	[NonSerialized]
	public int remainingToPayOut;

	private Func<int, StorageContainer> getStorage;

	public readonly int scrapItemID;

	private Action<CardPlayerData> turnTimerCallback;

	public ulong UserID { get; set; }

	public CardPlayerState State { get; set; }

	public bool HasUser => State >= CardPlayerState.WantsToPlay;

	public bool HasUserInGame => State >= CardPlayerState.InGame;

	public bool HasUserInCurrentRound => State == CardPlayerState.InCurrentRound;

	public bool HasAvailableInputs => availableInputs > 0;

	public bool AllCardsAreKnown
	{
		get
		{
			if (Cards.Count == 0)
			{
				return false;
			}
			foreach (PlayingCard card in Cards)
			{
				if (card.IsUnknownCard)
				{
					return false;
				}
			}
			return true;
		}
	}

	private bool IsClient => !isServer;

	public bool LeftRoundEarly { get; set; }

	public bool SendCardDetails { get; set; }

	public bool hasCompletedTurn { get; private set; }

	public CardPlayerData(int mountIndex, bool isServer)
	{
		this.isServer = isServer;
		this.mountIndex = mountIndex;
		Cards = Pool.Get<List<PlayingCard>>();
	}

	public CardPlayerData(int scrapItemID, Func<int, StorageContainer> getStorage, int mountIndex, bool isServer)
		: this(mountIndex, isServer)
	{
		this.scrapItemID = scrapItemID;
		this.getStorage = getStorage;
	}

	public virtual void Dispose()
	{
		Pool.FreeUnmanaged<PlayingCard>(ref Cards);
		if (isServer)
		{
			CancelTurnTimer();
		}
	}

	public int GetScrapAmount()
	{
		if (isServer)
		{
			StorageContainer storage = GetStorage();
			if ((Object)(object)storage != (Object)null)
			{
				return storage.inventory.GetAmount(scrapItemID, onlyUsableAmounts: true);
			}
			Debug.LogError((object)(GetType().Name + ": Couldn't get player storage."));
		}
		return 0;
	}

	public virtual int GetTotalBetThisRound()
	{
		return betThisRound;
	}

	public virtual List<PlayingCard> GetMainCards()
	{
		return Cards;
	}

	public virtual List<PlayingCard> GetSecondaryCards()
	{
		return null;
	}

	public void SetHasCompletedTurn(bool hasActed)
	{
		hasCompletedTurn = hasActed;
		if (!hasActed)
		{
			betThisTurn = 0;
		}
	}

	public bool HasBeenIdleFor(int seconds)
	{
		if (HasUserInGame)
		{
			return Time.unscaledTime > lastActionTime + (float)seconds;
		}
		return false;
	}

	public StorageContainer GetStorage()
	{
		return getStorage(mountIndex);
	}

	public void AddUser(ulong userID)
	{
		ClearAllData();
		UserID = userID;
		State = CardPlayerState.WantsToPlay;
		lastActionTime = Time.unscaledTime;
	}

	public void ClearAllData()
	{
		UserID = 0uL;
		availableInputs = 0;
		State = CardPlayerState.None;
		ClearPerRoundData();
	}

	public void JoinRound()
	{
		if (HasUser)
		{
			State = CardPlayerState.InCurrentRound;
			ClearPerRoundData();
		}
	}

	protected virtual void ClearPerRoundData()
	{
		Cards.Clear();
		betThisRound = 0;
		betThisTurn = 0;
		finalScore = 0;
		LeftRoundEarly = false;
		hasCompletedTurn = false;
		SendCardDetails = false;
	}

	public virtual void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
	{
		if (HasUserInCurrentRound)
		{
			availableInputs = 0;
			finalScore = 0;
			hasCompletedTurn = false;
			if (clearBets)
			{
				betThisRound = 0;
				betThisTurn = 0;
			}
			State = CardPlayerState.InGame;
			LeftRoundEarly = leftRoundEarly;
			CancelTurnTimer();
		}
	}

	public virtual void LeaveGame()
	{
		if (HasUserInGame)
		{
			Cards.Clear();
			availableInputs = 0;
			finalScore = 0;
			SendCardDetails = false;
			LeftRoundEarly = false;
			State = CardPlayerState.WantsToPlay;
		}
	}

	public void EnableSendingCards()
	{
		SendCardDetails = true;
	}

	public string HandToString()
	{
		return HandToString(Cards);
	}

	public static string HandToString(List<PlayingCard> cards)
	{
		string text = string.Empty;
		foreach (PlayingCard card in cards)
		{
			text = text + "23456789TJQKA"[(int)card.Rank] + "♠♥♦♣"[(int)card.Suit] + " ";
		}
		return text;
	}

	public virtual void Save(CardGame syncData)
	{
		CardPlayer val = Pool.Get<CardPlayer>();
		val.userid = UserID;
		val.cards = Pool.Get<List<int>>();
		foreach (PlayingCard card in Cards)
		{
			val.cards.Add(SendCardDetails ? card.GetIndex() : (-1));
		}
		val.scrap = GetScrapAmount();
		val.state = (int)State;
		val.availableInputs = availableInputs;
		val.betThisRound = betThisRound;
		val.betThisTurn = betThisTurn;
		val.leftRoundEarly = LeftRoundEarly;
		val.sendCardDetails = SendCardDetails;
		syncData.players.Add(val);
	}

	public void StartTurnTimer(Action<CardPlayerData> callback, float maxTurnTime)
	{
		turnTimerCallback = callback;
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)TimeoutTurn, maxTurnTime);
	}

	public void CancelTurnTimer()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).CancelInvoke((Action)TimeoutTurn);
	}

	public void TimeoutTurn()
	{
		if (turnTimerCallback != null)
		{
			turnTimerCallback(this);
		}
	}
}


public enum CardPlayerState
{
	None,
	WantsToPlay,
	InGame,
	InCurrentRound
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using ProtoBuf;

public class CardPlayerDataBlackjack : CardPlayerData
{
	public List<PlayingCard> SplitCards;

	public int splitBetThisRound;

	public int insuranceBetThisRound;

	public bool playingSplitCards;

	public CardPlayerDataBlackjack(int mountIndex, bool isServer)
		: base(mountIndex, isServer)
	{
		SplitCards = Pool.Get<List<PlayingCard>>();
	}

	public CardPlayerDataBlackjack(int scrapItemID, Func<int, StorageContainer> getStorage, int mountIndex, bool isServer)
		: base(scrapItemID, getStorage, mountIndex, isServer)
	{
		SplitCards = Pool.Get<List<PlayingCard>>();
	}

	public override void Dispose()
	{
		base.Dispose();
		Pool.FreeUnmanaged<PlayingCard>(ref SplitCards);
	}

	public override int GetTotalBetThisRound()
	{
		return betThisRound + splitBetThisRound + insuranceBetThisRound;
	}

	public override List<PlayingCard> GetSecondaryCards()
	{
		return SplitCards;
	}

	protected override void ClearPerRoundData()
	{
		base.ClearPerRoundData();
		SplitCards.Clear();
		splitBetThisRound = 0;
		insuranceBetThisRound = 0;
		playingSplitCards = false;
	}

	public override void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
	{
		if (base.HasUserInCurrentRound)
		{
			if (clearBets)
			{
				splitBetThisRound = 0;
				insuranceBetThisRound = 0;
			}
			base.LeaveCurrentRound(clearBets, leftRoundEarly);
		}
	}

	public override void LeaveGame()
	{
		base.LeaveGame();
		if (base.HasUserInGame)
		{
			SplitCards.Clear();
		}
	}

	public override void Save(CardGame syncData)
	{
		base.Save(syncData);
		BlackjackCardPlayer val = Pool.Get<BlackjackCardPlayer>();
		val.splitCards = Pool.Get<List<int>>();
		foreach (PlayingCard splitCard in SplitCards)
		{
			val.splitCards.Add(base.SendCardDetails ? splitCard.GetIndex() : (-1));
		}
		val.splitBetThisRound = splitBetThisRound;
		val.insuranceBetThisRound = insuranceBetThisRound;
		val.playingSplitCards = playingSplitCards;
		if (syncData.blackjack.players == null)
		{
			syncData.blackjack.players = Pool.Get<List<BlackjackCardPlayer>>();
		}
		syncData.blackjack.players.Add(val);
	}

	public bool TrySwitchToSplitHand()
	{
		if (SplitCards.Count > 0 && !playingSplitCards)
		{
			SwapSplitCardsWithMain();
			playingSplitCards = true;
			return true;
		}
		return false;
	}

	private void SwapSplitCardsWithMain()
	{
		List<PlayingCard> list = Pool.Get<List<PlayingCard>>();
		list.AddRange(Cards);
		Cards.Clear();
		Cards.AddRange(SplitCards);
		SplitCards.Clear();
		SplitCards.AddRange(list);
		Pool.FreeUnmanaged<PlayingCard>(ref list);
		int num = betThisRound;
		int num2 = splitBetThisRound;
		splitBetThisRound = num;
		betThisRound = num2;
	}
}


using System.Collections.Generic;
using System.Text;
using Facepunch.CardGames;
using UnityEngine;

public class StackOfCards
{
	private readonly List<PlayingCard> cards;

	public StackOfCards(int numDecks)
	{
		cards = new List<PlayingCard>(52 * numDecks);
		for (int i = 0; i < numDecks; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				for (int k = 0; k < 13; k++)
				{
					cards.Add(PlayingCard.GetCard(j, k));
				}
			}
		}
		ShuffleDeck();
	}

	public bool TryTakeCard(out PlayingCard card)
	{
		if (cards.Count == 0)
		{
			card = null;
			return false;
		}
		card = cards[cards.Count - 1];
		cards.RemoveAt(cards.Count - 1);
		return true;
	}

	public void AddCard(PlayingCard card)
	{
		cards.Insert(0, card);
	}

	public void ShuffleDeck()
	{
		int num = cards.Count;
		while (num > 1)
		{
			num--;
			int num2 = Random.Range(0, num);
			List<PlayingCard> list = cards;
			int index = num2;
			List<PlayingCard> list2 = cards;
			int index2 = num;
			PlayingCard playingCard = cards[num];
			PlayingCard playingCard2 = cards[num2];
			PlayingCard playingCard4 = (list[index] = playingCard);
			playingCard4 = (list2[index2] = playingCard2);
		}
	}

	public void Print()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Cards in the deck: ");
		foreach (PlayingCard card in cards)
		{
			stringBuilder.AppendLine(card.Rank.ToString() + " of " + card.Suit);
		}
		Debug.Log((object)stringBuilder.ToString());
	}
}


public enum Rank
{
	Two,
	Three,
	Four,
	Five,
	Six,
	Seven,
	Eight,
	Nine,
	Ten,
	Jack,
	Queen,
	King,
	Ace
}


public enum Suit
{
	Spades,
	Hearts,
	Diamonds,
	Clubs
}


using Facepunch.CardGames;
using PokerEvaluator;
using UnityEngine;

public class PlayingCard
{
	public readonly bool IsUnknownCard;

	public readonly Suit Suit;

	public readonly Rank Rank;

	public static PlayingCard[] cards = GenerateAllCards();

	public static PlayingCard unknownCard = new PlayingCard();

	private PlayingCard(Suit suit, Rank rank)
	{
		IsUnknownCard = false;
		Suit = suit;
		Rank = rank;
	}

	private PlayingCard()
	{
		IsUnknownCard = true;
		Suit = Suit.Spades;
		Rank = Rank.Two;
	}

	public static PlayingCard GetCard(Suit suit, Rank rank)
	{
		return GetCard((int)suit, (int)rank);
	}

	public static PlayingCard GetCard(int suit, int rank)
	{
		return cards[suit * 13 + rank];
	}

	public static PlayingCard GetCard(int index)
	{
		if (index == -1)
		{
			return unknownCard;
		}
		return cards[index];
	}

	public int GetIndex()
	{
		if (IsUnknownCard)
		{
			return -1;
		}
		return GetIndex(Suit, Rank);
	}

	public static int GetIndex(Suit suit, Rank rank)
	{
		return (int)((int)suit * 13 + rank);
	}

	public int GetPokerEvaluationValue()
	{
		if (IsUnknownCard)
		{
			Debug.LogWarning((object)(GetType().Name + ": Called GetPokerEvaluationValue on unknown card."));
		}
		return Arrays.primes[(int)Rank] | ((int)Rank << 8) | GetPokerSuitCode() | (1 << (int)(16 + Rank));
	}

	private int GetPokerSuitCode()
	{
		if (IsUnknownCard)
		{
			Debug.LogWarning((object)(GetType().Name + ": Called GetPokerSuitCode on unknown card."));
		}
		return Suit switch
		{
			Suit.Spades => 4096, 
			Suit.Hearts => 8192, 
			Suit.Diamonds => 16384, 
			Suit.Clubs => 32768, 
			_ => 4096, 
		};
	}

	private static PlayingCard[] GenerateAllCards()
	{
		PlayingCard[] array = new PlayingCard[52];
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 13; j++)
			{
				array[i * 13 + j] = new PlayingCard((Suit)i, (Rank)j);
			}
		}
		return array;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using PokerEvaluator;
using ProtoBuf;
using Rust;
using UnityEngine;

public class TexasHoldEmController : CardGameController
{
	[Flags]
	public enum PokerInputOption
	{
		None = 0,
		Fold = 1,
		Call = 2,
		AllIn = 4,
		Check = 8,
		Raise = 0x10,
		Bet = 0x20,
		RevealHand = 0x40
	}

	public enum PokerRoundResult
	{
		Loss,
		PrimaryWinner,
		SecondaryWinner
	}

	public List<PlayingCard> communityCards = new List<PlayingCard>();

	public const int SMALL_BLIND = 5;

	public const int BIG_BLIND = 10;

	public const string WON_HAND_STAT = "won_hand_texas_holdem";

	private int dealerIndex;

	private StackOfCards deck = new StackOfCards(1);

	public override int MinPlayers => 2;

	public override int MinBuyIn => 100;

	public override int MaxBuyIn => 1000;

	public override int MinToPlay => 10;

	public PokerInputOption LastAction { get; private set; }

	public ulong LastActionTarget { get; private set; }

	public int LastActionValue { get; private set; }

	public int BiggestRaiseThisTurn { get; private set; }

	public TexasHoldEmController(BaseCardGameEntity owner)
		: base(owner)
	{
	}

	public int GetCurrentBet()
	{
		int num = 0;
		foreach (CardPlayerData item in PlayersInRound())
		{
			num = Mathf.Max(num, item.betThisTurn);
		}
		return num;
	}

	public bool TryGetDealer(out CardPlayerData dealer)
	{
		return ToCardPlayerData(dealerIndex, includeOutOfRound: true, out dealer);
	}

	public bool TryGetSmallBlind(out CardPlayerData smallBlind)
	{
		int relIndex = ((NumPlayersInGame() < 3) ? dealerIndex : (dealerIndex + 1));
		return ToCardPlayerData(relIndex, includeOutOfRound: true, out smallBlind);
	}

	public bool TryGetBigBlind(out CardPlayerData bigBlind)
	{
		int relIndex = ((NumPlayersInGame() < 3) ? (dealerIndex + 1) : (dealerIndex + 2));
		return ToCardPlayerData(relIndex, includeOutOfRound: true, out bigBlind);
	}

	protected override int GetFirstPlayerRelIndex(bool startOfRound)
	{
		int num = NumPlayersInGame();
		if (startOfRound && num == 2)
		{
			return dealerIndex;
		}
		return (dealerIndex + 1) % num;
	}

	public static ushort EvaluatePokerHand(List<PlayingCard> cards)
	{
		ushort result = 0;
		int[] array = new int[cards.Count];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = cards[i].GetPokerEvaluationValue();
		}
		if (cards.Count == 5)
		{
			result = PokerLib.Eval5Hand(array);
		}
		else if (cards.Count == 7)
		{
			result = PokerLib.Eval7Hand(array);
		}
		else
		{
			Debug.LogError((object)"Currently we can only evaluate five or seven card hands.");
		}
		return result;
	}

	public int GetCurrentMinRaise(CardPlayerData playerData)
	{
		return Mathf.Max(10, GetCurrentBet() - playerData.betThisTurn + BiggestRaiseThisTurn);
	}

	public override List<PlayingCard> GetTableCards()
	{
		return communityCards;
	}

	public void InputsToList(int availableInputs, List<PokerInputOption> result)
	{
		PokerInputOption[] array = (PokerInputOption[])Enum.GetValues(typeof(PokerInputOption));
		foreach (PokerInputOption pokerInputOption in array)
		{
			if (pokerInputOption != 0 && ((uint)availableInputs & (uint)pokerInputOption) == (uint)pokerInputOption)
			{
				result.Add(pokerInputOption);
			}
		}
	}

	protected override CardPlayerData GetNewCardPlayerData(int mountIndex)
	{
		if (base.IsServer)
		{
			return new CardPlayerData(base.ScrapItemID, base.Owner.GetPlayerStorage, mountIndex, base.IsServer);
		}
		return new CardPlayerData(mountIndex, base.IsServer);
	}

	public override void Save(CardGame syncData)
	{
		base.Save(syncData);
		syncData.texasHoldEm = Pool.Get<TexasHoldEm>();
		syncData.texasHoldEm.dealerIndex = dealerIndex;
		syncData.texasHoldEm.communityCards = Pool.Get<List<int>>();
		syncData.texasHoldEm.biggestRaiseThisTurn = BiggestRaiseThisTurn;
		syncData.lastActionId = (int)LastAction;
		syncData.lastActionTarget = LastActionTarget;
		syncData.lastActionValue = LastActionValue;
		foreach (PlayingCard communityCard in communityCards)
		{
			syncData.texasHoldEm.communityCards.Add(communityCard.GetIndex());
		}
		ClearLastAction();
	}

	protected override void SubStartRound()
	{
		communityCards.Clear();
		deck = new StackOfCards(1);
		BiggestRaiseThisTurn = 0;
		ClearLastAction();
		IncrementDealer();
		DealHoleCards();
		activePlayerIndex = GetFirstPlayerRelIndex(startOfRound: true);
		ServerPlaySound(CardGameSounds.SoundType.Shuffle);
		TryGetActivePlayer(out var activePlayer);
		activePlayer.availableInputs = GetAvailableInputsForPlayer(activePlayer);
		if ((activePlayer.availableInputs & 0x20) == 32)
		{
			ReceivedInputFromPlayer(activePlayer, 32, countAsAction: false, 5, playerInitiated: false);
		}
		else
		{
			ReceivedInputFromPlayer(activePlayer, 4, countAsAction: false, 5, playerInitiated: false);
		}
		TryGetActivePlayer(out activePlayer);
		activePlayer.availableInputs = GetAvailableInputsForPlayer(activePlayer);
		if ((activePlayer.availableInputs & 0x10) == 16)
		{
			ReceivedInputFromPlayer(activePlayer, 16, countAsAction: false, 10, playerInitiated: false);
		}
		else
		{
			ReceivedInputFromPlayer(activePlayer, 4, countAsAction: false, 10, playerInitiated: false);
		}
	}

	protected override void SubEndRound()
	{
		int num = 0;
		List<CardPlayerData> list = Pool.Get<List<CardPlayerData>>();
		CardPlayerData[] playerData = base.PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.betThisRound > 0)
			{
				list.Add(cardPlayerData);
			}
			if (cardPlayerData.HasUserInCurrentRound)
			{
				num++;
			}
		}
		if (list.Count == 0)
		{
			base.Owner.GetPot().inventory.Clear();
			return;
		}
		bool flag = num > 1;
		int num2 = GetScrapInPot();
		playerData = base.PlayerData;
		foreach (CardPlayerData cardPlayerData2 in playerData)
		{
			if (cardPlayerData2.HasUserInGame)
			{
				num2 -= cardPlayerData2.betThisRound;
			}
		}
		bool flag2 = true;
		playerData = base.PlayerData;
		foreach (CardPlayerData obj in playerData)
		{
			obj.remainingToPayOut = obj.betThisRound;
		}
		while (list.Count > 1)
		{
			int num3 = int.MaxValue;
			int num4 = 0;
			playerData = base.PlayerData;
			foreach (CardPlayerData cardPlayerData3 in playerData)
			{
				if (cardPlayerData3.betThisRound > 0)
				{
					if (cardPlayerData3.betThisRound < num3)
					{
						num3 = cardPlayerData3.betThisRound;
					}
					num4++;
				}
			}
			int num5 = num3 * num4;
			foreach (CardPlayerData item in list)
			{
				item.betThisRound -= num3;
			}
			int num6 = int.MaxValue;
			foreach (CardPlayerData item2 in PlayersInRound())
			{
				if (item2.finalScore < num6)
				{
					num6 = item2.finalScore;
				}
			}
			if (flag2)
			{
				base.resultInfo.winningScore = num6;
			}
			int num7 = 0;
			foreach (CardPlayerData item3 in PlayersInRound())
			{
				if (item3.finalScore == num6)
				{
					num7++;
				}
			}
			int num8 = Mathf.CeilToInt((float)(num5 + num2) / (float)num7);
			num2 = 0;
			foreach (CardPlayerData item4 in PlayersInRound())
			{
				if (item4.finalScore == num6)
				{
					if (flag)
					{
						item4.EnableSendingCards();
					}
					PayOutFromPot(item4, num8);
					PokerRoundResult resultCode = (flag2 ? PokerRoundResult.PrimaryWinner : PokerRoundResult.SecondaryWinner);
					AddRoundResult(item4, num8, (int)resultCode);
				}
			}
			for (int num9 = list.Count - 1; num9 >= 0; num9--)
			{
				if (list[num9].betThisRound == 0)
				{
					list.RemoveAt(num9);
				}
			}
			flag2 = false;
		}
		if (list.Count == 1)
		{
			int num10 = list[0].betThisRound + num2;
			num2 = 0;
			PayOutFromPot(list[0], num10);
			PokerRoundResult resultCode2 = ((base.resultInfo.results.Count == 0) ? PokerRoundResult.PrimaryWinner : PokerRoundResult.SecondaryWinner);
			AddRoundResult(list[0], num10, (int)resultCode2);
		}
		base.Owner.ClientRPC(RpcTarget.NetworkGroup("OnResultsDeclared"), base.resultInfo);
		StorageContainer pot = base.Owner.GetPot();
		int amount = pot.inventory.GetAmount(base.ScrapItemID, onlyUsableAmounts: true);
		if (amount > 0)
		{
			Debug.LogError((object)$"{GetType().Name}: Something went wrong in the winner calculation. Pot still has {amount} scrap left over after payouts. Expected 0. Clearing it.");
			pot.inventory.Clear();
		}
		Pool.FreeUnmanaged<CardPlayerData>(ref list);
	}

	protected override void AddRoundResult(CardPlayerData pData, int winnings, int winState)
	{
		base.AddRoundResult(pData, winnings, winState);
		if (GameInfo.HasAchievements)
		{
			BasePlayer basePlayer = base.Owner.IDToPlayer(pData.UserID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.stats.Add("won_hand_texas_holdem", 1);
				basePlayer.stats.Save(forceSteamSave: true);
			}
		}
	}

	protected override void SubEndGameplay()
	{
		communityCards.Clear();
	}

	private void IncrementDealer()
	{
		int num = NumPlayersInGame();
		if (num == 0)
		{
			dealerIndex = 0;
			return;
		}
		dealerIndex = Mathf.Clamp(dealerIndex, 0, num - 1);
		dealerIndex = ++dealerIndex % num;
	}

	private void DealHoleCards()
	{
		for (int i = 0; i < 2; i++)
		{
			foreach (CardPlayerData item in PlayersInRound())
			{
				if (deck.TryTakeCard(out var card))
				{
					item.Cards.Add(card);
				}
				else
				{
					Debug.LogError((object)(GetType().Name + ": No more cards in the deck to deal!"));
				}
			}
		}
		SyncAllLocalPlayerCards();
	}

	private bool DealCommunityCards()
	{
		if (!base.HasActiveRound)
		{
			return false;
		}
		if (communityCards.Count == 0)
		{
			for (int i = 0; i < 3; i++)
			{
				if (deck.TryTakeCard(out var card))
				{
					communityCards.Add(card);
				}
			}
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			return true;
		}
		if (communityCards.Count == 3 || communityCards.Count == 4)
		{
			if (deck.TryTakeCard(out var card2))
			{
				communityCards.Add(card2);
			}
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			return true;
		}
		return false;
	}

	private void ClearLastAction()
	{
		LastAction = PokerInputOption.None;
		LastActionTarget = 0uL;
		LastActionValue = 0;
	}

	protected override void OnTurnTimeout(CardPlayerData pData)
	{
		if (TryGetActivePlayer(out var activePlayer) && activePlayer == pData)
		{
			ReceivedInputFromPlayer(activePlayer, 1, countAsAction: true, 0, playerInitiated: false);
		}
	}

	protected override void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction)
	{
		if (!Enum.IsDefined(typeof(PokerInputOption), input))
		{
			return;
		}
		if (!base.HasActiveRound)
		{
			if (input == 64)
			{
				playerData.EnableSendingCards();
				playerData.availableInputs = GetAvailableInputsForPlayer(playerData);
				base.Owner.SendNetworkUpdate();
			}
			LastActionTarget = playerData.UserID;
			LastAction = (PokerInputOption)input;
			LastActionValue = 0;
		}
		else
		{
			if (!TryGetActivePlayer(out var activePlayer) || activePlayer != playerData)
			{
				return;
			}
			bool flag = false;
			if ((playerData.availableInputs & input) != input)
			{
				return;
			}
			switch (input)
			{
			case 1:
				playerData.LeaveCurrentRound(clearBets: false, leftRoundEarly: true);
				flag = true;
				LastActionValue = 0;
				break;
			case 2:
			{
				int currentBet = GetCurrentBet();
				int num = TryAddBet(playerData, currentBet - playerData.betThisTurn);
				LastActionValue = num;
				break;
			}
			case 16:
			case 32:
			{
				int currentBet = GetCurrentBet();
				int biggestRaiseThisTurn = BiggestRaiseThisTurn;
				if (playerData.betThisTurn + value < currentBet + biggestRaiseThisTurn)
				{
					value = currentBet + biggestRaiseThisTurn - playerData.betThisTurn;
				}
				int num = TryAddBet(playerData, value);
				BiggestRaiseThisTurn = Mathf.Max(BiggestRaiseThisTurn, num - currentBet);
				LastActionValue = num;
				break;
			}
			case 4:
			{
				int currentBet = GetCurrentBet();
				int num = GoAllIn(playerData);
				BiggestRaiseThisTurn = Mathf.Max(BiggestRaiseThisTurn, num - currentBet);
				LastActionValue = num;
				break;
			}
			case 8:
				LastActionValue = 0;
				break;
			}
			if (countAsAction && input != 0)
			{
				playerData.SetHasCompletedTurn(hasActed: true);
			}
			LastActionTarget = playerData.UserID;
			LastAction = (PokerInputOption)input;
			if (flag && NumPlayersInCurrentRound() == 1)
			{
				EndRoundWithDelay();
				return;
			}
			int startIndex = activePlayerIndex;
			if (flag)
			{
				if (activePlayerIndex > NumPlayersInCurrentRound() - 1)
				{
					startIndex = 0;
				}
			}
			else
			{
				startIndex = (activePlayerIndex + 1) % NumPlayersInCurrentRound();
			}
			CardPlayerData newActivePlayer;
			if (ShouldEndCycle())
			{
				EndCycle();
			}
			else if (TryMoveToNextPlayerWithInputs(startIndex, out newActivePlayer))
			{
				StartTurnTimer(newActivePlayer, MaxTurnTime);
				base.Owner.SendNetworkUpdate();
			}
			else
			{
				EndCycle();
			}
		}
	}

	protected override void StartNextCycle()
	{
		base.StartNextCycle();
		int num = GetFirstPlayerRelIndex(startOfRound: false);
		int num2 = NumPlayersInGame();
		int num3 = 0;
		CardPlayerData result;
		while (!ToCardPlayerData(num, includeOutOfRound: true, out result) || !result.HasUserInCurrentRound)
		{
			num = ++num % num2;
			num3++;
			if (num3 > num2)
			{
				Debug.LogError((object)(GetType().Name + ": This should never happen. Ended turn with no players in game?."));
				EndRoundWithDelay();
				return;
			}
		}
		int num4 = GameToRoundIndex(num);
		if (num4 < 0 || num4 > NumPlayersInCurrentRound())
		{
			Debug.LogError((object)$"StartNextCycle NewActiveIndex is out of range: {num4}. Clamping it to between 0 and {NumPlayersInCurrentRound()}.");
			num4 = Mathf.Clamp(num4, 0, NumPlayersInCurrentRound());
		}
		int startIndex = num4;
		CardPlayerData newActivePlayer;
		if (ShouldEndCycle())
		{
			EndCycle();
		}
		else if (TryMoveToNextPlayerWithInputs(startIndex, out newActivePlayer))
		{
			StartTurnTimer(newActivePlayer, MaxTurnTime);
			UpdateAllAvailableInputs();
			base.Owner.SendNetworkUpdate();
		}
		else
		{
			EndCycle();
		}
	}

	protected override bool ShouldEndCycle()
	{
		foreach (CardPlayerData item in PlayersInRound())
		{
			if (item.GetScrapAmount() > 0 && (item.betThisTurn != GetCurrentBet() || !item.hasCompletedTurn))
			{
				return false;
			}
		}
		return true;
	}

	protected override void EndCycle()
	{
		CardPlayerData[] playerData = base.PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			playerData[i].SetHasCompletedTurn(hasActed: false);
		}
		BiggestRaiseThisTurn = 0;
		if (DealCommunityCards())
		{
			QueueNextCycleInvoke();
			return;
		}
		foreach (CardPlayerData item in PlayersInRound())
		{
			List<PlayingCard> list = Pool.Get<List<PlayingCard>>();
			list.AddRange(item.Cards);
			list.AddRange(communityCards);
			ushort finalScore = EvaluatePokerHand(list);
			Pool.FreeUnmanaged<PlayingCard>(ref list);
			item.finalScore = finalScore;
		}
		EndRoundWithDelay();
	}

	protected override int GetAvailableInputsForPlayer(CardPlayerData playerData)
	{
		PokerInputOption pokerInputOption = PokerInputOption.None;
		if (playerData == null || isWaitingBetweenTurns)
		{
			return (int)pokerInputOption;
		}
		if (!base.HasActiveRound)
		{
			if (!playerData.LeftRoundEarly && playerData.Cards.Count > 0 && !playerData.SendCardDetails)
			{
				pokerInputOption |= PokerInputOption.RevealHand;
			}
			return (int)pokerInputOption;
		}
		if (!TryGetActivePlayer(out var activePlayer) || playerData != activePlayer)
		{
			return (int)pokerInputOption;
		}
		int scrapAmount = playerData.GetScrapAmount();
		if (scrapAmount > 0)
		{
			int scrapInPot = GetScrapInPot();
			int currentBet = GetCurrentBet();
			bool flag = AnyoneElseCanBetMore(playerData);
			if (scrapInPot == 0 || flag || playerData.betThisTurn + scrapAmount <= currentBet)
			{
				pokerInputOption |= PokerInputOption.AllIn;
			}
			if (playerData.betThisTurn >= currentBet)
			{
				pokerInputOption |= PokerInputOption.Check;
			}
			pokerInputOption |= PokerInputOption.Fold;
			if (currentBet > playerData.betThisTurn && scrapAmount >= currentBet - playerData.betThisTurn)
			{
				pokerInputOption |= PokerInputOption.Call;
			}
			if (scrapAmount >= GetCurrentMinRaise(playerData) && (scrapInPot == 0 || flag))
			{
				pokerInputOption = ((BiggestRaiseThisTurn != 0) ? (pokerInputOption | PokerInputOption.Raise) : (pokerInputOption | PokerInputOption.Bet));
			}
		}
		return (int)pokerInputOption;
	}

	protected override void HandlePlayerLeavingTable(CardPlayerData pData)
	{
		if (TryGetActivePlayer(out var activePlayer))
		{
			if (pData == activePlayer)
			{
				ReceivedInputFromPlayer(pData, 1, countAsAction: true, 0, playerInitiated: false);
			}
			else if (pData.HasUserInCurrentRound && pData.mountIndex < activePlayer.mountIndex && activePlayerIndex > 0)
			{
				activePlayerIndex--;
			}
		}
	}

	private bool AnyoneElseCanBetMore(CardPlayerData excluding)
	{
		CardPlayerData[] playerData = base.PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData != excluding && cardPlayerData.GetScrapAmount() > 0)
			{
				return true;
			}
		}
		return false;
	}
}


using System;

[Flags]
public enum PokerInputOption
{
	None = 0,
	Fold = 1,
	Call = 2,
	AllIn = 4,
	Check = 8,
	Raise = 0x10,
	Bet = 0x20,
	RevealHand = 0x40
}


public enum PokerRoundResult
{
	Loss,
	PrimaryWinner,
	SecondaryWinner
}


using System;
using Ionic.Zlib;
using UnityEngine;

public class Compression
{
	public static byte[] Compress(byte[] data)
	{
		try
		{
			return GZipStream.CompressBuffer(data);
		}
		catch (Exception)
		{
			return null;
		}
	}

	public static byte[] Uncompress(byte[] data)
	{
		return GZipStream.UncompressBuffer(data);
	}

	public static int PackVector3ToInt(Vector3 vector, float minValue, float maxValue)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.InverseLerp(minValue, maxValue, vector.x), Mathf.InverseLerp(minValue, maxValue, vector.y), Mathf.InverseLerp(minValue, maxValue, vector.z));
		return 0 | ((int)(val.x * 1023f) << 20) | ((int)(val.y * 1023f) << 10) | (int)(val.z * 1023f);
	}

	public static Vector3 UnpackVector3FromInt(int packed, float minValue, float maxValue)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3((float)((packed >> 20) & 0x3FF), (float)((packed >> 10) & 0x3FF), (float)(packed & 0x3FF)) / 1023f;
		return new Vector3(Mathf.Lerp(minValue, maxValue, val.x), Mathf.Lerp(minValue, maxValue, val.y), Mathf.Lerp(minValue, maxValue, val.z));
	}
}


using System;
using UnityEngine;

public static class Controls
{
	public static float labelWidth = 100f;

	public static float FloatSlider(string strLabel, float value, float low, float high, string format = "0.00")
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strLabel, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		float num = float.Parse(GUILayout.TextField(value.ToString(format), (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.ExpandWidth(true) }));
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		float result = GUILayout.HorizontalSlider(num, low, high, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static int IntSlider(string strLabel, int value, int low, int high, string format = "0")
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strLabel, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		int num = int.Parse(GUILayout.TextField(value.ToString(format), (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.ExpandWidth(true) }));
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		int result = (int)GUILayout.HorizontalSlider((float)num, (float)low, (float)high, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static string TextArea(string strName, string value)
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strName, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		string result = GUILayout.TextArea(value, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static bool Checkbox(string strName, bool value)
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strName, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		bool result = GUILayout.Toggle(value, "", Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static bool Button(string strName)
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		bool result = GUILayout.Button(strName, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}
}


using System;
using System.Collections.Generic;
using Facepunch.GUI;
using UnityEngine;

internal class TabbedPanel
{
	public struct Tab
	{
		public string name;

		public Action drawFunc;
	}

	private int selectedTabID;

	private List<Tab> tabs = new List<Tab>();

	public Tab selectedTab => tabs[selectedTabID];

	public void Add(Tab tab)
	{
		tabs.Add(tab);
	}

	internal void DrawVertical(float width)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Expected O, but got Unknown
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Expected O, but got Unknown
		GUILayout.BeginVertical((GUILayoutOption[])(object)new GUILayoutOption[2]
		{
			GUILayout.Width(width),
			GUILayout.ExpandHeight(true)
		});
		for (int i = 0; i < tabs.Count; i++)
		{
			if (GUILayout.Toggle(selectedTabID == i, tabs[i].name, new GUIStyle(GUIStyle.op_Implicit("devtab")), Array.Empty<GUILayoutOption>()))
			{
				selectedTabID = i;
			}
		}
		if (GUILayout.Toggle(false, "", new GUIStyle(GUIStyle.op_Implicit("devtab")), (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.ExpandHeight(true) }))
		{
			selectedTabID = -1;
		}
		GUILayout.EndVertical();
	}

	internal void DrawContents()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		if (selectedTabID >= 0)
		{
			Tab tab = selectedTab;
			GUILayout.BeginVertical(new GUIStyle(GUIStyle.op_Implicit("devtabcontents")), (GUILayoutOption[])(object)new GUILayoutOption[2]
			{
				GUILayout.ExpandHeight(true),
				GUILayout.ExpandWidth(true)
			});
			if (tab.drawFunc != null)
			{
				tab.drawFunc();
			}
			GUILayout.EndVertical();
		}
	}
}


using System;

public struct Tab
{
	public string name;

	public Action drawFunc;
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch.Unity;
using Newtonsoft.Json;
using UnityEngine;

public static class RenderInfo
{
	public struct RendererInstance
	{
		public bool IsVisible;

		public bool CastShadows;

		public bool Enabled;

		public bool RecieveShadows;

		public float Size;

		public float Distance;

		public int BoneCount;

		public int MaterialCount;

		public int VertexCount;

		public int TriangleCount;

		public int SubMeshCount;

		public int BlendShapeCount;

		public string RenderType;

		public string MeshName;

		public string ObjectName;

		public string EntityName;

		public ulong EntityId;

		public bool UpdateWhenOffscreen;

		public int ParticleCount;

		public static RendererInstance From(Renderer renderer)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Invalid comparison between Unknown and I4
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			RendererInstance result = default(RendererInstance);
			result.IsVisible = renderer.isVisible;
			result.CastShadows = (int)renderer.shadowCastingMode > 0;
			result.RecieveShadows = renderer.receiveShadows;
			result.Enabled = renderer.enabled && ((Component)renderer).gameObject.activeInHierarchy;
			Bounds bounds = renderer.bounds;
			Vector3 size = ((Bounds)(ref bounds)).size;
			result.Size = ((Vector3)(ref size)).magnitude;
			bounds = renderer.bounds;
			result.Distance = Vector3.Distance(((Bounds)(ref bounds)).center, ((Component)Camera.main).transform.position);
			result.MaterialCount = renderer.sharedMaterials.Length;
			result.RenderType = ((object)renderer).GetType().Name;
			BaseEntity baseEntity = ((Component)renderer).gameObject.ToBaseEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				result.EntityName = baseEntity.PrefabName;
				if (baseEntity.net != null)
				{
					result.EntityId = baseEntity.net.ID.Value;
				}
			}
			else
			{
				result.ObjectName = ((Component)renderer).transform.GetRecursiveName();
			}
			if (renderer is MeshRenderer)
			{
				result.BoneCount = 0;
				MeshFilter component = ((Component)renderer).GetComponent<MeshFilter>();
				if (Object.op_Implicit((Object)(object)component))
				{
					result.ReadMesh(component.sharedMesh);
				}
			}
			if (renderer is SkinnedMeshRenderer)
			{
				SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((renderer is SkinnedMeshRenderer) ? renderer : null);
				result.ReadMesh(val.sharedMesh);
				result.UpdateWhenOffscreen = val.updateWhenOffscreen;
			}
			if (renderer is ParticleSystemRenderer)
			{
				ParticleSystem component2 = ((Component)renderer).GetComponent<ParticleSystem>();
				if (Object.op_Implicit((Object)(object)component2))
				{
					result.MeshName = ((Object)component2).name;
					result.ParticleCount = component2.particleCount;
				}
			}
			return result;
		}

		public void ReadMesh(Mesh mesh)
		{
			if ((Object)(object)mesh == (Object)null)
			{
				MeshName = "<NULL>";
				return;
			}
			VertexCount = mesh.vertexCount;
			SubMeshCount = mesh.subMeshCount;
			BlendShapeCount = mesh.blendShapeCount;
			MeshName = ((Object)mesh).name;
		}
	}

	public static void GenerateReport()
	{
		Renderer[] array = Object.FindObjectsOfType<Renderer>();
		List<RendererInstance> list = new List<RendererInstance>();
		Renderer[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RendererInstance item = RendererInstance.From(array2[i]);
			list.Add(item);
		}
		string path = string.Format(Application.dataPath + "/../RenderInfo-{0:yyyy-MM-dd_hh-mm-ss-tt}.txt", DateTime.Now);
		string contents = JsonConvert.SerializeObject((object)list, (Formatting)1);
		File.WriteAllText(path, contents);
	}
}


using UnityEngine;

public struct RendererInstance
{
	public bool IsVisible;

	public bool CastShadows;

	public bool Enabled;

	public bool RecieveShadows;

	public float Size;

	public float Distance;

	public int BoneCount;

	public int MaterialCount;

	public int VertexCount;

	public int TriangleCount;

	public int SubMeshCount;

	public int BlendShapeCount;

	public string RenderType;

	public string MeshName;

	public string ObjectName;

	public string EntityName;

	public ulong EntityId;

	public bool UpdateWhenOffscreen;

	public int ParticleCount;

	public static RendererInstance From(Renderer renderer)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Invalid comparison between Unknown and I4
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		RendererInstance result = default(RendererInstance);
		result.IsVisible = renderer.isVisible;
		result.CastShadows = (int)renderer.shadowCastingMode > 0;
		result.RecieveShadows = renderer.receiveShadows;
		result.Enabled = renderer.enabled && ((Component)renderer).gameObject.activeInHierarchy;
		Bounds bounds = renderer.bounds;
		Vector3 size = ((Bounds)(ref bounds)).size;
		result.Size = ((Vector3)(ref size)).magnitude;
		bounds = renderer.bounds;
		result.Distance = Vector3.Distance(((Bounds)(ref bounds)).center, ((Component)Camera.main).transform.position);
		result.MaterialCount = renderer.sharedMaterials.Length;
		result.RenderType = ((object)renderer).GetType().Name;
		BaseEntity baseEntity = ((Component)renderer).gameObject.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			result.EntityName = baseEntity.PrefabName;
			if (baseEntity.net != null)
			{
				result.EntityId = baseEntity.net.ID.Value;
			}
		}
		else
		{
			result.ObjectName = ((Component)renderer).transform.GetRecursiveName();
		}
		if (renderer is MeshRenderer)
		{
			result.BoneCount = 0;
			MeshFilter component = ((Component)renderer).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				result.ReadMesh(component.sharedMesh);
			}
		}
		if (renderer is SkinnedMeshRenderer)
		{
			SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((renderer is SkinnedMeshRenderer) ? renderer : null);
			result.ReadMesh(val.sharedMesh);
			result.UpdateWhenOffscreen = val.updateWhenOffscreen;
		}
		if (renderer is ParticleSystemRenderer)
		{
			ParticleSystem component2 = ((Component)renderer).GetComponent<ParticleSystem>();
			if (Object.op_Implicit((Object)(object)component2))
			{
				result.MeshName = ((Object)component2).name;
				result.ParticleCount = component2.particleCount;
			}
		}
		return result;
	}

	public void ReadMesh(Mesh mesh)
	{
		if ((Object)(object)mesh == (Object)null)
		{
			MeshName = "<NULL>";
			return;
		}
		VertexCount = mesh.vertexCount;
		SubMeshCount = mesh.subMeshCount;
		BlendShapeCount = mesh.blendShapeCount;
		MeshName = ((Object)mesh).name;
	}
}


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Cysharp.Text;
using Facepunch;
using Facepunch.Rust;
using Network;
using ProtoBuf;
using Rust;
using Steamworks;
using UnityEngine;

public static class Analytics
{
	public static class Azure
	{
		public enum ResourceMode
		{
			Produced,
			Consumed
		}

		private static class EventIds
		{
			public const string EntityBuilt = "entity_built";

			public const string EntityPickup = "entity_pickup";

			public const string EntityDamage = "entity_damage";

			public const string PlayerRespawn = "player_respawn";

			public const string ExplosiveLaunched = "explosive_launch";

			public const string Explosion = "explosion";

			public const string ItemEvent = "item_event";

			public const string EntitySum = "entity_sum";

			public const string ItemSum = "item_sum";

			public const string ItemDespawn = "item_despawn";

			public const string ItemDropped = "item_drop";

			public const string ItemPickup = "item_pickup";

			public const string AntihackViolation = "antihack_violation";

			public const string AntihackViolationDetailed = "antihack_violation_detailed";

			public const string PlayerConnect = "player_connect";

			public const string PlayerDisconnect = "player_disconnect";

			public const string ConsumableUsed = "consumeable_used";

			public const string MedUsed = "med_used";

			public const string ResearchStarted = "research_start";

			public const string BlueprintLearned = "blueprint_learned";

			public const string TeamChanged = "team_change";

			public const string EntityAuthChange = "auth_change";

			public const string VendingOrderChanged = "vending_changed";

			public const string VendingSale = "vending_sale";

			public const string ChatMessage = "chat";

			public const string BlockUpgrade = "block_upgrade";

			public const string BlockDemolish = "block_demolish";

			public const string ItemRepair = "item_repair";

			public const string EntityRepair = "entity_repair";

			public const string ItemSkinned = "item_skinned";

			public const string EntitySkinned = "entity_skinned";

			public const string ItemAggregate = "item_aggregate";

			public const string CodelockChanged = "code_change";

			public const string CodelockEntered = "code_enter";

			public const string SleepingBagAssign = "sleeping_bag_assign";

			public const string FallDamage = "fall_damage";

			public const string PlayerWipeIdSet = "player_wipe_id_set";

			public const string ServerInfo = "server_info";

			public const string UnderwaterCrateUntied = "crate_untied";

			public const string VehiclePurchased = "vehicle_purchase";

			public const string NPCVendor = "npc_vendor";

			public const string BlueprintsOnline = "blueprint_aggregate_online";

			public const string PlayerPositions = "player_positions";

			public const string ProjectileInvalid = "projectile_invalid";

			public const string ItemDefinitions = "item_definitions";

			public const string KeycardSwiped = "keycard_swiped";

			public const string EntitySpawned = "entity_spawned";

			public const string EntityKilled = "entity_killed";

			public const string HackableCrateStarted = "hackable_crate_started";

			public const string HackableCrateEnded = "hackable_crate_ended";

			public const string StashHidden = "stash_hidden";

			public const string StashRevealed = "stash_reveal";

			public const string EntityManifest = "entity_manifest";

			public const string LootEntity = "loot_entity";

			public const string OnlineTeams = "online_teams";

			public const string Gambling = "gambing";

			public const string BuildingBlockColor = "building_block_color";

			public const string MissionComplete = "mission_complete";

			public const string PlayerPinged = "player_pinged";

			public const string BagUnclaim = "bag_unclaim";

			public const string SteamAuth = "steam_auth";

			public const string ParachuteUsed = "parachute_used";

			public const string MountEntity = "mount";

			public const string DismountEntity = "dismount";

			public const string BurstToggle = "burst_toggle";

			public const string TutorialStarted = "tutorial_started";

			public const string TutorialCompleted = "tutorial_completed";

			public const string TutorialQuit = "tutorial_quit";

			public const string BaseInteraction = "base_interaction";

			public const string PlayerDeath = "player_death";

			public const string CarShredded = "car_shredded";

			public const string PlayerTick = "player_tick";

			public const string WallpaperPlaced = "wallpaper_placed";

			public const string StartFish = "fishing_start";

			public const string FailedFish = "fishing_failed";

			public const string CaughtFish = "fishing_caught";

			public const string InjureStateChange = "injure_state";

			public const string LifeStoryEnd = "life_story_end";

			public const string ServerRPC = "server_rpc";
		}

		private struct SimpleItemAmount
		{
			public string ItemName;

			public int Amount;

			public ulong Skin;

			public float Condition;

			public SimpleItemAmount(Item item)
			{
				ItemName = item.info.shortname;
				Amount = item.amount;
				Skin = item.skin;
				Condition = item.conditionNormalized;
			}
		}

		private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
		{
			public ulong UserId;

			public int ProjectileId;

			public FiredProjectileKey(ulong userId, int projectileId)
			{
				UserId = userId;
				ProjectileId = projectileId;
			}

			public bool Equals(FiredProjectileKey other)
			{
				if (other.UserId == UserId)
				{
					return other.ProjectileId == ProjectileId;
				}
				return false;
			}
		}

		private class PendingFiredProjectile : IPooled
		{
			public EventRecord Record;

			public BasePlayer.FiredProjectile FiredProjectile;

			public bool Hit;

			public void EnterPool()
			{
				Hit = false;
				Record = null;
				FiredProjectile = null;
			}

			public void LeavePool()
			{
			}
		}

		[JsonModel]
		private struct EntitySumItem
		{
			public uint PrefabId;

			public int Count;

			public int Grade;
		}

		private struct EntityKey : IEquatable<EntityKey>
		{
			public uint PrefabId;

			public int Grade;

			public bool Equals(EntityKey other)
			{
				if (PrefabId == other.PrefabId)
				{
					return Grade == other.Grade;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
			}
		}

		private class PendingItemsData : IPooled
		{
			public PendingItemsKey Key;

			public int amount;

			public string category;

			public void EnterPool()
			{
				Key = default(PendingItemsKey);
				amount = 0;
				category = null;
			}

			public void LeavePool()
			{
			}
		}

		private struct PendingItemsKey : IEquatable<PendingItemsKey>
		{
			public string Item;

			public bool Consumed;

			public string Entity;

			public string Category;

			public NetworkableId EntityId;

			public bool Equals(PendingItemsKey other)
			{
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
				{
					return Category == other.Category;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
			}
		}

		[JsonModel]
		private class PlayerAggregate : IPooled
		{
			public string UserId;

			public Vector3 Position;

			public Vector3 Direction;

			public List<string> Hotbar = new List<string>();

			public List<string> Worn = new List<string>();

			public string ActiveItem;

			public string Biome;

			public void EnterPool()
			{
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				UserId = null;
				Position = default(Vector3);
				Direction = default(Vector3);
				Hotbar.Clear();
				Worn.Clear();
				ActiveItem = null;
				Biome = null;
			}

			public void LeavePool()
			{
			}
		}

		[JsonModel]
		private class TeamInfo : IPooled
		{
			public List<string> online = new List<string>();

			public List<string> offline = new List<string>();

			public int member_count;

			public void EnterPool()
			{
				online.Clear();
				offline.Clear();
				member_count = 0;
			}

			public void LeavePool()
			{
			}
		}

		private static Dictionary<FiredProjectileKey, PendingFiredProjectile> trackedProjectiles = new Dictionary<FiredProjectileKey, PendingFiredProjectile>();

		private static Dictionary<int, string> geneCache = new Dictionary<int, string>();

		public static int MaxMSPerFrame = 5;

		private static Dictionary<PendingItemsKey, PendingItemsData> pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();

		public static bool GameplayAnalytics => GameplayAnalyticsConVar;

		public static void Initialize()
		{
			PushItemDefinitions();
			PushEntityManifest();
			((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(AggregateLoop());
		}

		private static void PushServerInfo()
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("server_info").AddField("seed", World.Seed).AddField("size", World.Size)
					.AddField("url", World.Url)
					.AddField("ip_convar", Net.sv.ip)
					.AddField("port_convar", Net.sv.port)
					.AddField("net_protocol", Net.sv.ProtocolId)
					.AddField("protocol_network", 2594)
					.AddField("protocol_save", 270);
				BuildInfo current = BuildInfo.Current;
				EventRecord eventRecord2 = eventRecord.AddField("changeset", ((current != null) ? current.Scm.ChangeId : null) ?? "0").AddField("unity_version", Application.unityVersion);
				BuildInfo current2 = BuildInfo.Current;
				SubmitPoint(eventRecord2.AddField("branch", ((current2 != null) ? current2.Scm.Branch : null) ?? "empty").AddField("server_tags", ConVar.Server.tags).AddField("device_id", SystemInfo.deviceUniqueIdentifier)
					.AddField("network_id", Net.sv.GetLastUIDGiven()));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void PushItemDefinitions()
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if ((Object)(object)GameManifest.Current == (Object)null)
				{
					return;
				}
				BuildInfo current = BuildInfo.Current;
				object obj;
				if (current == null)
				{
					obj = null;
				}
				else
				{
					ScmInfo scm = current.Scm;
					obj = ((scm != null) ? scm.ChangeId : null);
				}
				if (obj == null)
				{
					return;
				}
				SubmitPoint(EventRecord.New("item_definitions").AddObject("items", from x in ItemManager.itemDictionary
					select x.Value into x
					select new
					{
						item_id = x.itemid,
						shortname = x.shortname,
						craft_time = (x.Blueprint?.GetCraftTime() ?? 0f),
						workbench = (x.Blueprint?.GetWorkbenchLevel() ?? 0),
						category = x.category.ToString(),
						display_name = x.displayName.english,
						despawn_rarity = x.despawnRarity,
						ingredients = (from y in x.Blueprint?.GetIngredients()
							select new
							{
								shortname = y.itemDef.shortname,
								amount = (int)y.amount
							})
					}).AddField("changeset", BuildInfo.Current.Scm.ChangeId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void PushEntityManifest()
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if ((Object)(object)GameManifest.Current == (Object)null)
				{
					return;
				}
				BuildInfo current = BuildInfo.Current;
				object obj;
				if (current == null)
				{
					obj = null;
				}
				else
				{
					ScmInfo scm = current.Scm;
					obj = ((scm != null) ? scm.ChangeId : null);
				}
				if (obj != null)
				{
					EventRecord eventRecord = EventRecord.New("entity_manifest").AddObject("entities", GameManifest.Current.entities.Select((string x) => new
					{
						shortname = Path.GetFileNameWithoutExtension(x),
						prefab_id = StringPool.Get(x.ToLower())
					}));
					BuildInfo current2 = BuildInfo.Current;
					SubmitPoint(eventRecord.AddField("changeset", ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor"));
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void SubmitPoint(EventRecord point)
		{
			point.Submit();
		}

		public static void OnFiredProjectile(BasePlayer player, BasePlayer.FiredProjectile projectile, Guid projectileGroupId)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord record = EventRecord.New("entity_damage").AddField("start_pos", projectile.position).AddField("start_vel", projectile.initialVelocity)
					.AddField("velocity_inherit", projectile.inheritedVelocity)
					.AddField("ammo_item", projectile.itemDef?.shortname)
					.AddField("weapon", (BaseNetworkable)projectile.weaponSource)
					.AddField("projectile_group", projectileGroupId)
					.AddField("projectile_id", projectile.id)
					.AddField("attacker", (BaseNetworkable)player)
					.AddField("look_dir", player.tickViewAngles)
					.AddField("model_state", (player.modelStateTick ?? player.modelState).flags)
					.AddField("burst_mode", projectile.weaponSource?.HasFlag(BaseEntity.Flags.Reserved6) ?? false);
				PendingFiredProjectile pendingFiredProjectile = Pool.Get<PendingFiredProjectile>();
				pendingFiredProjectile.Record = record;
				pendingFiredProjectile.FiredProjectile = projectile;
				trackedProjectiles[new FiredProjectileKey(player.userID, projectile.id)] = pendingFiredProjectile;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFiredProjectileRemoved(BasePlayer player, BasePlayer.FiredProjectile projectile)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				FiredProjectileKey key = new FiredProjectileKey(player.userID, projectile.id);
				if (!trackedProjectiles.TryGetValue(key, out var value))
				{
					return;
				}
				if (!value.Hit)
				{
					EventRecord record = value.Record;
					if (projectile.updates.Count > 0)
					{
						record.AddObject("projectile_updates", projectile.updates);
					}
					SubmitPoint(record);
				}
				Pool.Free<PendingFiredProjectile>(ref value);
				trackedProjectiles.Remove(key);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnQuarryItem(ResourceMode mode, string item, int amount, MiningQuarry sourceEntity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				AddPendingItems(sourceEntity, item, amount, "quarry", mode == ResourceMode.Consumed);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExcavatorProduceItem(Item item, BaseEntity sourceEntity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				AddPendingItems(sourceEntity, item.info.shortname, item.amount, "excavator", consumed: false);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExcavatorConsumeFuel(Item item, int amount, BaseEntity dieselEngine)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Consumed, "excavator", item.info.shortname, amount, dieselEngine, null, safezone: false, null, 0uL);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCraftItem(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Produced, "craft", item, amount, null, null, inSafezone, workbench, player?.userID ?? ((EncryptedValue<ulong>)0uL));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCraftMaterialConsumed(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone, string targetItem)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(safezone: inSafezone, workbench: workbench, targetItem: targetItem, mode: ResourceMode.Consumed, category: "craft", itemName: item, amount: amount, sourceEntity: null, tool: null, steamId: player?.userID ?? ((EncryptedValue<ulong>)0uL));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnConsumableUsed(BasePlayer player, Item item)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("consumeable_used").AddField("player", (BaseNetworkable)player).AddField("item", item));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntitySpawned(BaseEntity entity)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				trackedSpawnedIds.Add(entity.net.ID);
				SubmitPoint(EventRecord.New("entity_spawned").AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void TryLogEntityKilled(BaseNetworkable entity)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (entity.IsValid() && trackedSpawnedIds.Contains(entity.net.ID))
				{
					SubmitPoint(EventRecord.New("entity_killed").AddField("entity", entity));
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnMedUsed(string itemName, BasePlayer player, BasePlayer target)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("med_used").AddField("player", (BaseNetworkable)player).AddField("target", (BaseNetworkable)target)
					.AddField("item_name", itemName));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCodelockChanged(BasePlayer player, CodeLock codeLock, string oldCode, string newCode, bool isGuest)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("code_change").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
					.AddField("old_code", oldCode)
					.AddField("new_code", newCode)
					.AddField("is_guest", isGuest));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCodeLockEntered(BasePlayer player, CodeLock codeLock, bool isGuest)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("code_enter").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
					.AddField("is_guest", isGuest));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTeamChanged(string change, ulong teamId, ulong teamLeader, ulong user, List<ulong> members)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			List<ulong> list = Pool.Get<List<ulong>>();
			try
			{
				if (members != null)
				{
					foreach (ulong member in members)
					{
						list.Add(member);
					}
				}
				SubmitPoint(EventRecord.New("team_change").AddField("team_leader", teamLeader).AddField("team", teamId)
					.AddField("target_user", user)
					.AddField("change", change)
					.AddObject("users", list)
					.AddField("member_count", members.Count));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			Pool.FreeUnmanaged<ulong>(ref list);
		}

		public static void OnEntityAuthChanged(BaseEntity entity, BasePlayer player, IEnumerable<ulong> authedList, string change, ulong targetUser)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("auth_change").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
					.AddField("target", targetUser)
					.AddObject("auth_list", authedList)
					.AddField("change", change));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSleepingBagAssigned(BasePlayer player, SleepingBag bag, ulong targetUser)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("sleeping_bag_assign").AddField("entity", (BaseNetworkable)bag).AddField("player", (BaseNetworkable)player)
					.AddField("target", targetUser));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFallDamage(BasePlayer player, float velocity, float damage)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fall_damage").AddField("player", (BaseNetworkable)player).AddField("velocity", velocity)
					.AddField("damage", damage));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnResearchStarted(BasePlayer player, BaseEntity entity, Item item, int scrapCost)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("research_start").AddField("player", (BaseNetworkable)player).AddField("item", item.info.shortname)
					.AddField("scrap", scrapCost)
					.AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBlueprintLearned(BasePlayer player, ItemDefinition item, string reason, int scrapCost, BaseEntity entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("blueprint_learned").AddField("player", (BaseNetworkable)player).AddField("item", item.shortname)
					.AddField("reason", reason)
					.AddField("entity", (BaseNetworkable)entity)
					.AddField("scrap_cost", scrapCost));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemRecycled(string item, int amount, Recycler recycler)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Consumed, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnRecyclerItemProduced(string item, int amount, Recycler recycler, Item sourceItem)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Produced, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy, null, sourceItem);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnGatherItem(string item, int amount, BaseEntity sourceEntity, BasePlayer player, AttackEntity weapon = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Produced, "gather", item, amount, sourceEntity, weapon, safezone: false, null, player.userID);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFirstLooted(BaseEntity entity, BasePlayer player)
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (entity is LootContainer lootContainer)
				{
					LogItemsLooted(player, entity, lootContainer.inventory);
					SubmitPoint(EventRecord.New("loot_entity").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
						.AddField("monument", GetMonument(entity))
						.AddField("biome", GetBiome(((Component)entity).transform.position)));
				}
				else if (entity is LootableCorpse { containers: var containers })
				{
					foreach (ItemContainer container in containers)
					{
						LogItemsLooted(player, entity, container);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnLootContainerDestroyed(LootContainer entity, BasePlayer player, AttackEntity weapon)
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (entity.DropsLoot && (Object)(object)player != (Object)null && Vector3.Distance(((Component)entity).transform.position, ((Component)player).transform.position) < 50f && entity.inventory?.itemList != null && entity.inventory.itemList.Count > 0)
				{
					LogItemsLooted(player, entity, entity.inventory, weapon);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityDestroyed(BaseNetworkable entity)
		{
			TryLogEntityKilled(entity);
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (!(entity is LootContainer { FirstLooterId: 0uL } lootContainer))
				{
					return;
				}
				foreach (Item item in lootContainer.inventory.itemList)
				{
					OnItemDespawn(lootContainer, item, 3, lootContainer.LastLootedBy);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityBuilt(BaseEntity entity, BasePlayer player)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("entity_built").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity);
				if (entity is SleepingBag)
				{
					int sleepingBagCount = SleepingBag.GetSleepingBagCount(player.userID);
					eventRecord.AddField("bags_active", sleepingBagCount);
					eventRecord.AddField("max_sleeping_bags", ConVar.Server.max_sleeping_bags);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnMountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("mount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
					.AddField("seat", (BaseNetworkable)seat));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnDismountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("dismount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
					.AddField("seat", (BaseNetworkable)seat));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnKeycardSwiped(BasePlayer player, CardReader cardReader)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("keycard_swiped").AddField("player", (BaseNetworkable)player).AddField("card_level", cardReader.accessLevel)
					.AddField("entity", (BaseNetworkable)cardReader));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnLockedCrateStarted(BasePlayer player, HackableLockedCrate crate)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("hackable_crate_started").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)crate));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnLockedCrateFinished(ulong player, HackableLockedCrate crate)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("hackable_crate_ended").AddField("player_steamid", player).AddField("entity", (BaseNetworkable)crate));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnStashHidden(BasePlayer player, StashContainer entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("stash_hidden").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("owner", entity.OwnerID));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnStashRevealed(BasePlayer player, StashContainer entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("stash_reveal").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("owner", entity.OwnerID));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnAntihackViolation(BasePlayer player, AntiHackType type, string message)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("antihack_violation").AddField("player", (BaseNetworkable)player).AddField("violation_type", (int)type)
					.AddField("violation", type.ToString())
					.AddField("message", message);
				if (BuildInfo.Current != null)
				{
					eventRecord.AddField("changeset", BuildInfo.Current.Scm.ChangeId).AddField("network", 2594);
				}
				switch (type)
				{
				case AntiHackType.SpeedHack:
					eventRecord.AddField("speedhack_protection", ConVar.AntiHack.speedhack_protection).AddField("speedhack_forgiveness", ConVar.AntiHack.speedhack_forgiveness).AddField("speedhack_forgiveness_inertia", ConVar.AntiHack.speedhack_forgiveness_inertia)
						.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_penalty)
						.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_reject)
						.AddField("speedhack_slopespeed", ConVar.AntiHack.speedhack_slopespeed);
					break;
				case AntiHackType.NoClip:
					eventRecord.AddField("noclip_protection", ConVar.AntiHack.noclip_protection).AddField("noclip_penalty", ConVar.AntiHack.noclip_penalty).AddField("noclip_maxsteps", ConVar.AntiHack.noclip_maxsteps)
						.AddField("noclip_margin_dismount", ConVar.AntiHack.noclip_margin_dismount)
						.AddField("noclip_margin", ConVar.AntiHack.noclip_margin)
						.AddField("noclip_backtracking", ConVar.AntiHack.noclip_backtracking)
						.AddField("noclip_reject", ConVar.AntiHack.noclip_reject)
						.AddField("noclip_stepsize", ConVar.AntiHack.noclip_stepsize);
					break;
				case AntiHackType.ProjectileHack:
					eventRecord.AddField("projectile_anglechange", ConVar.AntiHack.projectile_anglechange).AddField("projectile_backtracking", ConVar.AntiHack.projectile_backtracking).AddField("projectile_clientframes", ConVar.AntiHack.projectile_clientframes)
						.AddField("projectile_damagedepth", ConVar.AntiHack.projectile_damagedepth)
						.AddField("projectile_desync", ConVar.AntiHack.projectile_desync)
						.AddField("projectile_forgiveness", ConVar.AntiHack.projectile_forgiveness)
						.AddField("projectile_impactspawndepth", ConVar.AntiHack.projectile_impactspawndepth)
						.AddField("projectile_losforgiveness", ConVar.AntiHack.projectile_losforgiveness)
						.AddField("projectile_penalty", ConVar.AntiHack.projectile_penalty)
						.AddField("projectile_positionoffset", ConVar.AntiHack.projectile_positionoffset)
						.AddField("projectile_protection", ConVar.AntiHack.projectile_protection)
						.AddField("projectile_serverframes", ConVar.AntiHack.projectile_serverframes)
						.AddField("projectile_terraincheck", ConVar.AntiHack.projectile_terraincheck)
						.AddField("projectile_trajectory", ConVar.AntiHack.projectile_trajectory)
						.AddField("projectile_vehiclecheck", ConVar.AntiHack.projectile_vehiclecheck)
						.AddField("projectile_velocitychange", ConVar.AntiHack.projectile_velocitychange);
					break;
				case AntiHackType.InsideTerrain:
					eventRecord.AddField("terrain_check_geometry", ConVar.AntiHack.terrain_check_geometry).AddField("terrain_kill", ConVar.AntiHack.terrain_kill).AddField("terrain_padding", ConVar.AntiHack.terrain_padding)
						.AddField("terrain_penalty", ConVar.AntiHack.terrain_penalty)
						.AddField("terrain_protection", ConVar.AntiHack.terrain_protection)
						.AddField("terrain_timeslice", ConVar.AntiHack.terrain_timeslice);
					break;
				case AntiHackType.MeleeHack:
					eventRecord.AddField("melee_backtracking", ConVar.AntiHack.melee_backtracking).AddField("melee_clientframes", ConVar.AntiHack.melee_clientframes).AddField("melee_forgiveness", ConVar.AntiHack.melee_forgiveness)
						.AddField("melee_losforgiveness", ConVar.AntiHack.melee_losforgiveness)
						.AddField("melee_penalty", ConVar.AntiHack.melee_penalty)
						.AddField("melee_protection", ConVar.AntiHack.melee_protection)
						.AddField("melee_serverframes", ConVar.AntiHack.melee_serverframes)
						.AddField("melee_terraincheck", ConVar.AntiHack.melee_terraincheck)
						.AddField("melee_vehiclecheck", ConVar.AntiHack.melee_vehiclecheck);
					break;
				case AntiHackType.FlyHack:
					eventRecord.AddField("flyhack_extrusion", ConVar.AntiHack.flyhack_extrusion).AddField("flyhack_forgiveness_horizontal", ConVar.AntiHack.flyhack_forgiveness_horizontal).AddField("flyhack_forgiveness_horizontal_inertia", ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia)
						.AddField("flyhack_forgiveness_vertical", ConVar.AntiHack.flyhack_forgiveness_vertical)
						.AddField("flyhack_forgiveness_vertical_inertia", ConVar.AntiHack.flyhack_forgiveness_vertical_inertia)
						.AddField("flyhack_margin", ConVar.AntiHack.flyhack_margin)
						.AddField("flyhack_maxsteps", ConVar.AntiHack.flyhack_maxsteps)
						.AddField("flyhack_penalty", ConVar.AntiHack.flyhack_penalty)
						.AddField("flyhack_protection", ConVar.AntiHack.flyhack_protection)
						.AddField("flyhack_reject", ConVar.AntiHack.flyhack_reject);
					break;
				case AntiHackType.EyeHack:
					eventRecord.AddField("eye_clientframes", ConVar.AntiHack.eye_clientframes).AddField("eye_forgiveness", ConVar.AntiHack.eye_forgiveness).AddField("eye_history_forgiveness", ConVar.AntiHack.eye_history_forgiveness)
						.AddField("eye_history_penalty", ConVar.AntiHack.eye_history_penalty)
						.AddField("eye_losradius", ConVar.AntiHack.eye_losradius)
						.AddField("eye_noclip_backtracking", ConVar.AntiHack.eye_noclip_backtracking)
						.AddField("eye_noclip_cutoff", ConVar.AntiHack.eye_noclip_cutoff)
						.AddField("eye_penalty", ConVar.AntiHack.eye_penalty)
						.AddField("eye_protection", ConVar.AntiHack.eye_protection)
						.AddField("eye_serverframes", ConVar.AntiHack.eye_serverframes)
						.AddField("eye_terraincheck", ConVar.AntiHack.eye_terraincheck)
						.AddField("eye_vehiclecheck", ConVar.AntiHack.eye_vehiclecheck);
					break;
				case AntiHackType.AttackHack:
					eventRecord.AddField("maxdesync", ConVar.AntiHack.maxdesync);
					break;
				case AntiHackType.Ticks:
					eventRecord.AddField("max_distance", ConVar.AntiHack.tick_max_distance).AddField("max_distance_falling", ConVar.AntiHack.tick_max_distance_falling).AddField("max_distance_parented", ConVar.AntiHack.tick_max_distance_parented)
						.AddField("tick_buffer_noclip_threshold", ConVar.AntiHack.tick_buffer_noclip_threshold)
						.AddField("tick_buffer_reject_threshold", ConVar.AntiHack.tick_buffer_reject_threshold);
					break;
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEyehackViolation(BasePlayer player, Vector3 eyePos)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 6)
					.AddField("eye_pos", eyePos));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnNoclipViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount, Collider collider)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 1)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount)
					.AddField("collider_name", ((Object)collider).name));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFlyhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 3)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnProjectileHackViolation(BasePlayer.FiredProjectile projectile)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (!projectile.invalid)
				{
					FiredProjectileKey key = new FiredProjectileKey(projectile.attacker.userID, projectile.id);
					if (trackedProjectiles.TryGetValue(key, out var value))
					{
						projectile.invalid = true;
						value.Record.AddField("projectile_invalid", value: true).AddObject("updates", projectile.updates);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSpeedhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 2)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount)
					.AddField("distance", Vector3.Distance(startPos, endPos))
					.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTickViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 13)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount)
					.AddField("distance", Vector3.Distance(startPos, endPos))
					.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTerrainHackViolation(BasePlayer player)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 10)
					.AddField("seed", World.Seed)
					.AddField("size", World.Size)
					.AddField("map_url", World.Url)
					.AddField("map_checksum", World.Checksum));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityTakeDamage(HitInfo info, bool isDeath)
		{
			//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_020a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Unknown result type (might be due to invalid IL or missing references)
			//IL_022c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0361: Unknown result type (might be due to invalid IL or missing references)
			//IL_0366: Unknown result type (might be due to invalid IL or missing references)
			//IL_0426: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0463: Unknown result type (might be due to invalid IL or missing references)
			//IL_047a: Unknown result type (might be due to invalid IL or missing references)
			//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
			//IL_0615: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				BasePlayer basePlayer = info.HitEntity as BasePlayer;
				if (((Object)(object)info.Initiator == (Object)null && !isDeath) || (((Object)(object)initiatorPlayer == (Object)null || initiatorPlayer.IsNpc || initiatorPlayer.IsBot) && ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc || basePlayer.IsBot)))
				{
					return;
				}
				EventRecord eventRecord = null;
				float value = -1f;
				float value2 = -1f;
				if ((Object)(object)initiatorPlayer != (Object)null)
				{
					if (info.IsProjectile())
					{
						FiredProjectileKey key = new FiredProjectileKey(initiatorPlayer.userID, info.ProjectileID);
						if (trackedProjectiles.TryGetValue(key, out var value3))
						{
							eventRecord = value3.Record;
							value = Vector3.Distance(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
							value = Vector3Ex.Distance2D(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
							value3.Hit = info.DidHit;
							if (eventRecord != null && value3.FiredProjectile.updates.Count > 0)
							{
								eventRecord.AddObject("projectile_updates", value3.FiredProjectile.updates);
							}
							if (eventRecord != null && value3.FiredProjectile.simulatedPositions.Count > 0)
							{
								eventRecord.AddObject("simulated_position", value3.FiredProjectile.simulatedPositions);
							}
							if (eventRecord != null)
							{
								eventRecord.AddField("partial_time", value3.FiredProjectile.partialTime);
								eventRecord.AddField("desync_lifetime", value3.FiredProjectile.desyncLifeTime);
								eventRecord.AddField("startpoint_mismatch", value3.FiredProjectile.startPointMismatch);
								eventRecord.AddField("endpoint_mismatch", value3.FiredProjectile.endPointMismatch);
								eventRecord.AddField("entity_distance", value3.FiredProjectile.entityDistance);
								eventRecord.AddField("position_offset", value3.FiredProjectile.initialPositionOffset);
							}
							trackedProjectiles.Remove(key);
							Pool.Free<PendingFiredProjectile>(ref value3);
						}
					}
					else
					{
						value = Vector3.Distance(info.HitNormalWorld, initiatorPlayer.eyes.position);
						value2 = Vector3Ex.Distance2D(info.HitNormalWorld, initiatorPlayer.eyes.position);
					}
				}
				if (eventRecord == null)
				{
					eventRecord = EventRecord.New("entity_damage");
				}
				eventRecord.AddField("is_headshot", info.isHeadshot).AddField("victim", (BaseNetworkable)info.HitEntity).AddField("damage", info.damageTypes.Total())
					.AddField("damage_type", info.damageTypes.GetMajorityDamageType().ToString())
					.AddField("pos_world", info.HitPositionWorld)
					.AddField("pos_local", info.HitPositionLocal)
					.AddField("point_start", info.PointStart)
					.AddField("point_end", info.PointEnd)
					.AddField("normal_world", info.HitNormalWorld)
					.AddField("normal_local", info.HitNormalLocal)
					.AddField("distance_cl", info.ProjectileDistance)
					.AddField("distance", value)
					.AddField("distance_2d", value2);
				if ((Object)(object)info.HitEntity != (Object)null && (Object)(object)info.HitEntity.model != (Object)null)
				{
					eventRecord.AddField("pos_local_model", ((Component)info.HitEntity.model).transform.InverseTransformPoint(info.HitPositionWorld));
				}
				if (!info.IsProjectile())
				{
					eventRecord.AddField("weapon", (BaseNetworkable)info.Weapon);
					eventRecord.AddField("attacker", (BaseNetworkable)info.Initiator);
				}
				if (info.HitBone != 0)
				{
					eventRecord.AddField("bone", info.HitBone).AddField("bone_name", info.boneName).AddField("hit_area", (int)info.boneArea);
				}
				if (info.ProjectileID != 0)
				{
					eventRecord.AddField("projectile_integrity", info.ProjectileIntegrity).AddField("projectile_hits", info.ProjectileHits).AddField("trajectory_mismatch", info.ProjectileTrajectoryMismatch)
						.AddField("travel_time", info.ProjectileTravelTime)
						.AddField("projectile_velocity", info.ProjectileVelocity)
						.AddField("projectile_prefab", ((Object)info.ProjectilePrefab).name);
				}
				if ((Object)(object)initiatorPlayer != (Object)null && !info.IsProjectile())
				{
					eventRecord.AddField("attacker_eye_pos", initiatorPlayer.eyes.position);
					eventRecord.AddField("attacker_eye_dir", initiatorPlayer.eyes.BodyForward());
					if (((object)initiatorPlayer).GetType() == typeof(BasePlayer))
					{
						eventRecord.AddField("attacker_life", initiatorPlayer.respawnId);
					}
				}
				else if ((Object)(object)initiatorPlayer != (Object)null)
				{
					eventRecord.AddObject("attacker_worn", initiatorPlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
					eventRecord.AddObject("attacker_hotbar", initiatorPlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
				}
				if ((Object)(object)basePlayer != (Object)null)
				{
					eventRecord.AddField("victim_life", basePlayer.respawnId);
					eventRecord.AddObject("victim_worn", basePlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
					eventRecord.AddObject("victim_hotbar", basePlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
					eventRecord.AddField("victim_view_dir", basePlayer.tickViewAngles);
					eventRecord.AddField("victim_eye_pos", basePlayer.eyes.position);
					eventRecord.AddField("victim_eye_dir", basePlayer.eyes.BodyForward());
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerRespawned(BasePlayer player, BaseEntity targetEntity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_respawn").AddField("player", (BaseNetworkable)player).AddField("bag", (BaseNetworkable)targetEntity)
					.AddField("life_id", player.respawnId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExplosiveLaunched(BasePlayer player, BaseEntity explosive, BaseEntity launcher = null)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("explosive_launch").AddField("player", (BaseNetworkable)player).AddField("explosive", (BaseNetworkable)explosive)
					.AddField("explosive_velocity", explosive.GetWorldVelocity());
				Vector3 worldVelocity = explosive.GetWorldVelocity();
				EventRecord eventRecord2 = eventRecord.AddField("explosive_direction", ((Vector3)(ref worldVelocity)).normalized);
				if ((Object)(object)launcher != (Object)null)
				{
					eventRecord2.AddField("launcher", (BaseNetworkable)launcher);
				}
				SubmitPoint(eventRecord2);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExplosion(TimedExplosive explosive)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("explosion").AddField("entity", (BaseNetworkable)explosive));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemDespawn(BaseEntity itemContainer, Item item, int dropReason, ulong userId)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("item_despawn").AddField("entity", (BaseNetworkable)itemContainer).AddField("item", item)
					.AddField("drop_reason", dropReason);
				if (userId != 0L)
				{
					eventRecord.AddField("player_userid", userId);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemDropped(BasePlayer player, WorldItem entity, DroppedItem.DropReasonEnum dropReason)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_drop").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("item", entity.GetItem())
					.AddField("drop_reason", (int)dropReason));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemPickup(BasePlayer player, WorldItem entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("item", entity.GetItem()));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerConnected(Connection connection)
		{
			try
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
				SubmitPoint(EventRecord.New("player_connect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
					.AddField("username", connection.username)
					.AddField("ip", connection.ipaddress));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerDisconnected(Connection connection, string reason)
		{
			try
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
				SubmitPoint(EventRecord.New("player_disconnect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
					.AddField("username", connection.username)
					.AddField("reason", reason));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityPickedUp(BasePlayer player, BaseEntity entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("entity_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnChatMessage(BasePlayer player, string message, int channel)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("chat").AddField("player", (BaseNetworkable)player).AddField("message", message)
					.AddField("channel", channel));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnVendingMachineOrderChanged(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, bool added)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
				SubmitPoint(EventRecord.New("vending_changed").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
					.AddField("sell_item", itemDefinition.shortname)
					.AddField("sell_amount", sellAmount)
					.AddField("buy_item", itemDefinition2.shortname)
					.AddField("buy_amount", buyAmount)
					.AddField("is_selling_bp", sellingBp)
					.AddField("is_buying_bp", buyingBp)
					.AddField("change", added ? "added" : "removed"));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuyFromVendingMachine(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, int numberOfTransactions, float discount, BaseEntity drone = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
				SubmitPoint(EventRecord.New("vending_sale").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
					.AddField("sell_item", itemDefinition.shortname)
					.AddField("sell_amount", sellAmount)
					.AddField("buy_item", itemDefinition2.shortname)
					.AddField("buy_amount", buyAmount)
					.AddField("transactions", numberOfTransactions)
					.AddField("is_selling_bp", sellingBp)
					.AddField("is_buying_bp", buyingBp)
					.AddField("drone_terminal", (BaseNetworkable)drone)
					.AddField("discount", discount));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnNPCVendor(BasePlayer player, NPCTalking vendor, int scrapCost, string action)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("npc_vendor").AddField("player", (BaseNetworkable)player).AddField("vendor", (BaseNetworkable)vendor)
					.AddField("scrap_amount", scrapCost)
					.AddField("action", action));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void LogItemsLooted(BasePlayer looter, BaseEntity entity, ItemContainer container, AttackEntity tool = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if ((Object)(object)entity == (Object)null || container == null)
				{
					return;
				}
				foreach (Item item in container.itemList)
				{
					if (item != null)
					{
						string shortname = item.info.shortname;
						int amount = item.amount;
						ulong steamId = looter?.userID ?? ((EncryptedValue<ulong>)0uL);
						LogResource(ResourceMode.Produced, "loot", shortname, amount, entity, tool, safezone: false, null, steamId);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void LogResource(ResourceMode mode, string category, string itemName, int amount, BaseEntity sourceEntity = null, AttackEntity tool = null, bool safezone = false, BaseEntity workbench = null, ulong steamId = 0uL, string sourceEntityPrefab = null, Item sourceItem = null, string targetItem = null)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("item_event").AddField("item_mode", mode.ToString()).AddField("category", category)
					.AddField("item_name", itemName)
					.AddField("amount", amount);
				if ((Object)(object)sourceEntity != (Object)null)
				{
					eventRecord.AddField("entity", (BaseNetworkable)sourceEntity);
					string biome = GetBiome(((Component)sourceEntity).transform.position);
					if (biome != null)
					{
						eventRecord.AddField("biome", biome);
					}
					if (IsOcean(((Component)sourceEntity).transform.position))
					{
						eventRecord.AddField("ocean", value: true);
					}
					string monument = GetMonument(sourceEntity);
					if (monument != null)
					{
						eventRecord.AddField("monument", monument);
					}
				}
				if (sourceEntityPrefab != null)
				{
					eventRecord.AddField("entity_prefab", sourceEntityPrefab);
				}
				if ((Object)(object)tool != (Object)null)
				{
					eventRecord.AddField("tool", (BaseNetworkable)tool);
				}
				if (safezone)
				{
					eventRecord.AddField("safezone", value: true);
				}
				if ((Object)(object)workbench != (Object)null)
				{
					eventRecord.AddField("workbench", (BaseNetworkable)workbench);
				}
				if (sourceEntity is GrowableEntity plant)
				{
					eventRecord.AddField("genes", GetGenesAsString(plant));
				}
				if (sourceItem != null)
				{
					eventRecord.AddField("source_item", sourceItem.info.shortname);
				}
				if (targetItem != null)
				{
					eventRecord.AddField("target_item", targetItem);
				}
				if (steamId != 0L)
				{
					string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(steamId);
					eventRecord.AddField("player_userid", userWipeId);
					eventRecord.AddField("player_steamid", steamId);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSkinChanged(BasePlayer player, RepairBench repairBench, Item item, ulong workshopId)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
					.AddField("item", item)
					.AddField("new_skin", workshopId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntitySkinChanged(BasePlayer player, BaseNetworkable entity, int newSkin)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("entity_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", entity)
					.AddField("new_skin", newSkin));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemRepaired(BasePlayer player, BaseEntity repairBench, Item itemToRepair, float conditionBefore, float maxConditionBefore)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
					.AddField("item", itemToRepair)
					.AddField("old_condition", conditionBefore)
					.AddField("old_max_condition", maxConditionBefore)
					.AddField("max_condition", itemToRepair.maxConditionNormalized));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityRepaired(BasePlayer player, BaseEntity entity, float healthBefore, float healthAfter)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("entity_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("healing", healthAfter - healthBefore)
					.AddField("health_before", healthBefore)
					.AddField("health_after", healthAfter));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuildingBlockUpgraded(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade, uint targetColor, ulong targetSkin)
		{
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("block_upgrade").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock)
					.AddField("old_grade", (int)buildingBlock.grade)
					.AddField("new_grade", (int)targetGrade)
					.AddField("color", targetColor)
					.AddField("biome", GetBiome(((Component)buildingBlock).transform.position))
					.AddField("skin_old", buildingBlock.skinID)
					.AddField("skin", targetSkin));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuildingBlockDemolished(BasePlayer player, StabilityEntity buildingBlock)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("block_demolish").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerInitializedWipeId(ulong userId, string wipeId)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_wipe_id_set").AddField("user_id", userId).AddField("player_wipe_id", wipeId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFreeUnderwaterCrate(BasePlayer player, FreeableLootContainer freeableLootContainer)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("crate_untied").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)freeableLootContainer));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnVehiclePurchased(BasePlayer player, BaseEntity vehicle)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("vehicle_purchase").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vehicle)
					.AddField("price", (BaseNetworkable)vehicle));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnMissionComplete(BasePlayer player, BaseMission mission, BaseMission.MissionFailReason? failReason = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("mission_complete").AddField("player", (BaseNetworkable)player).AddField("mission", mission.shortname);
				if (failReason.HasValue)
				{
					eventRecord.AddField("mission_succeed", value: false).AddField("fail_reason", failReason.Value.ToString());
				}
				else
				{
					eventRecord.AddField("mission_succeed", value: true);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnGamblingResult(BasePlayer player, BaseEntity entity, int scrapPaid, int scrapRecieved, Guid? gambleGroupId = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("gambing").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("scrap_input", scrapPaid)
					.AddField("scrap_output", scrapRecieved);
				if (gambleGroupId.HasValue)
				{
					eventRecord.AddField("gamble_grouping", gambleGroupId.Value);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerPinged(BasePlayer player, BasePlayer.PingType type, bool wasViaWheel)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("pingType", (int)type)
					.AddField("viaWheel", wasViaWheel));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBagUnclaimed(BasePlayer player, SleepingBag bag)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("bag_unclaim").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)bag));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSteamAuth(ulong userId, ulong ownerUserId, string authResponse)
		{
			try
			{
				SubmitPoint(EventRecord.New("steam_auth").AddField("user", userId).AddField("owner", ownerUserId)
					.AddField("response", authResponse)
					.AddField("server_port", Net.sv.port)
					.AddField("network_mode", Net.sv.ProtocolId)
					.AddField("player_count", BasePlayer.activePlayerList.Count)
					.AddField("max_players", ConVar.Server.maxplayers)
					.AddField("hostname", ConVar.Server.hostname)
					.AddField("secure", Net.sv.secure));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuildingBlockColorChanged(BasePlayer player, BuildingBlock block, uint oldColor, uint newColor)
		{
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)block)
					.AddField("color_old", oldColor)
					.AddField("color_new", newColor)
					.AddField("biome", GetBiome(((Component)block).transform.position)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBurstModeToggled(BasePlayer player, BaseProjectile gun, bool state)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("burst_toggle").AddField("player", (BaseNetworkable)player).AddField("weapon", (BaseNetworkable)gun)
					.AddField("enabled", state));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnParachuteUsed(BasePlayer player, float distanceTravelled, float deployHeight, float timeInAir)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("parachute_used").AddField("player", (BaseNetworkable)player).AddField("distanceTravelled", distanceTravelled)
					.AddField("deployHeight", deployHeight)
					.AddField("timeInAir", timeInAir));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTutorialStarted(BasePlayer player)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("tutorial_started").AddField("player", (BaseNetworkable)player));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTutorialCompleted(BasePlayer player, float timeElapsed)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("tutorial_completed").AddField("player", (BaseNetworkable)player).AddLegacyTimespan("duration", TimeSpan.FromSeconds(timeElapsed)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTutorialQuit(BasePlayer player, string activeMissionName)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("tutorial_quit").AddField("player", (BaseNetworkable)player).AddField("activeMissionName", activeMissionName));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBaseInteract(BasePlayer player, BaseEntity entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("base_interaction").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerDeath(BasePlayer player, BasePlayer killer)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_death").AddField("player", (BaseNetworkable)player).AddField("killer", (BaseNetworkable)killer));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCarShredded(MagnetLiftable car, List<Item> produced)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("car_shredded").AddField("player", (BaseNetworkable)car.associatedPlayer).AddField("car", (BaseNetworkable)car.GetBaseEntity());
				foreach (Item item in produced)
				{
					eventRecord.AddField("item_" + item.info.shortname, item);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerTick(BasePlayer player, in BasePlayer.CachedState tickState)
		{
			//IL_010b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0120: Unknown result type (might be due to invalid IL or missing references)
			//IL_013a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0154: Unknown result type (might be due to invalid IL or missing references)
			//IL_016e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0188: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
			if (GameplayTickAnalyticsConVar)
			{
				if (TickLogging.tickUploader.NeedsCreation())
				{
					BuildInfo current = BuildInfo.Current;
					bool num = (current.Scm.Branch != null && current.Scm.Branch == "experimental/release") || current.Scm.Branch == "release";
					bool isEditor = Application.isEditor;
					string text = ((num && !isEditor) ? "release" : (isEditor ? "editor" : "staging"));
					TickLogging.tickUploader = AzureAnalyticsUploader.Create("player_ticks_" + text, TimeSpan.FromSeconds(TickLogging.tick_uploader_lifetime), AnalyticsDocumentMode.CSV);
				}
				TickLogging.tickUploader.Append(EventRecord.New("player_tick").AddField("player_steamid", player.UserIDString).AddField("modelstate", (player.modelStateTick ?? player.modelState).flags)
					.AddField("heldentity", ((Object)(object)player.GetHeldEntity() != (Object)null) ? player.GetHeldEntity().ShortPrefabName : "")
					.AddField("pitch", player.tickViewAngles.x)
					.AddField("yaw", player.tickViewAngles.y)
					.AddField("pos_x", ((Component)player).transform.position.x)
					.AddField("pos_y", ((Component)player).transform.position.y)
					.AddField("pos_z", ((Component)player).transform.position.z)
					.AddField("eye_pos_x", player.eyes.position.x)
					.AddField("eye_pos_y", player.eyes.position.y)
					.AddField("eye_pos_z", player.eyes.position.z)
					.AddField("mouse_delta_x", player.tickMouseDelta.x)
					.AddField("mouse_delta_y", player.tickMouseDelta.y)
					.AddField("mouse_delta_z", player.tickMouseDelta.z)
					.AddField("parented", player.HasParent())
					.AddField("mounted", player.isMounted)
					.AddField("admin", player.IsAdmin || player.IsDeveloper)
					.AddField("water_factor", tickState.WaterFactor)
					.AddField("Timestamp", DateTime.UtcNow));
			}
		}

		public static void OnWallpaperPlaced(BasePlayer player, BuildingBlock buildingBlock, ulong skinID, int side, bool reskin)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("wallpaper_placed").AddField("player", (BaseNetworkable)player).AddField("buildingBlock", (BaseNetworkable)buildingBlock)
					.AddField("skin", skinID)
					.AddField("side", side)
					.AddField("reskin", reskin));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnStartFish(BasePlayer player, Item lure, Vector3 targetPos)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fishing_start").AddField("player", (BaseNetworkable)player).AddField("lure", lure)
					.AddField("target_pos", targetPos));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFailedFish(BasePlayer player, BaseFishingRod.FailReason reason)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fishing_failed").AddField("player", (BaseNetworkable)player).AddField("fail_reason", (int)reason));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCaughtFish(BasePlayer player, Item item)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fishing_caught").AddField("player", (BaseNetworkable)player).AddField("item", item));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerChangeInjureState(BasePlayer player, BasePlayer.InjureState oldState, BasePlayer.InjureState newState)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("injure_state").AddField("player", (BaseNetworkable)player).AddField("old_state", (int)oldState)
					.AddField("new_state", (int)newState));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerLifeStoryEnd(BasePlayer player, PlayerLifeStory lifeStory)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("life_story_end").AddField("player", (BaseNetworkable)player).AddField("time_born", lifeStory.timeBorn)
					.AddField("time_died", lifeStory.timeDied)
					.AddField("meters_walked", lifeStory.metersWalked)
					.AddField("meters_ran", lifeStory.metersRun)
					.AddField("seconds_alive", lifeStory.secondsAlive)
					.AddField("seconds_in_base", lifeStory.secondsInBase)
					.AddField("seconds_in_wilderness", lifeStory.secondsWilderness)
					.AddField("seconds_in_monument", lifeStory.secondsInMonument)
					.AddField("seconds_driving", lifeStory.secondsDriving)
					.AddField("seconds_flying", lifeStory.secondsFlying)
					.AddField("seconds_boating", lifeStory.secondsBoating)
					.AddField("seconds_sleeping", lifeStory.secondsSleeping)
					.AddField("seconds_swimming", lifeStory.secondsSwimming)
					.AddField("total_damage_taken", lifeStory.totalDamageTaken)
					.AddField("total_healed", lifeStory.totalHealing)
					.AddField("killed_players", lifeStory.killedPlayers)
					.AddField("killed_animals", lifeStory.killedAnimals)
					.AddField("killed_scientists", lifeStory.killedScientists)
					.AddObject("death_info", lifeStory.deathInfo)
					.AddObject("weapon_stats", lifeStory.weaponStats));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnServerRPC(BasePlayer player, uint nameID, byte[] data, int length)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("server_rpc").AddField("player", (BaseNetworkable)player).AddField("rpc", StringPool.Get(nameID))
					.AddField("data", data)
					.AddField("length", length));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static string GetGenesAsString(GrowableEntity plant)
		{
			int key = GrowableGeneEncoding.EncodeGenesToInt(plant.Genes);
			if (!geneCache.TryGetValue(key, out var value))
			{
				return string.Join("", from x in plant.Genes.Genes
					group x by x.GetDisplayCharacter() into x
					orderby x.Key
					select x.Count() + x.Key);
			}
			return value;
		}

		private static string GetMonument(BaseEntity entity)
		{
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)entity == (Object)null)
			{
				return null;
			}
			SpawnGroup spawnGroup = null;
			if (entity is BaseCorpse baseCorpse)
			{
				spawnGroup = baseCorpse.spawnGroup;
			}
			if ((Object)(object)spawnGroup == (Object)null)
			{
				SpawnPointInstance component = ((Component)entity).GetComponent<SpawnPointInstance>();
				if ((Object)(object)component != (Object)null)
				{
					spawnGroup = component.parentSpawnPointUser as SpawnGroup;
				}
			}
			if ((Object)(object)spawnGroup != (Object)null)
			{
				if (!string.IsNullOrEmpty(spawnGroup.category))
				{
					return spawnGroup.category;
				}
				if ((Object)(object)spawnGroup.Monument != (Object)null)
				{
					return ((Object)spawnGroup.Monument).name;
				}
			}
			MonumentInfo monumentInfo = TerrainMeta.Path.FindMonumentWithBoundsOverlap(((Component)entity).transform.position);
			if ((Object)(object)monumentInfo != (Object)null)
			{
				return ((Object)monumentInfo).name;
			}
			return null;
		}

		private static string GetBiome(Vector3 position)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected I4, but got Unknown
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Invalid comparison between Unknown and I4
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Invalid comparison between Unknown and I4
			string result = null;
			Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			switch (val - 1)
			{
			default:
				if ((int)val != 8)
				{
					if ((int)val == 16)
					{
						result = "jungle";
					}
				}
				else
				{
					result = "arctic";
				}
				break;
			case 0:
				result = "arid";
				break;
			case 1:
				result = "grass";
				break;
			case 3:
				result = "tundra";
				break;
			case 2:
				break;
			}
			return result;
		}

		private static bool IsOcean(Vector3 position)
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return TerrainMeta.TopologyMap.GetTopology(position) == 128;
		}

		private static IEnumerator AggregateLoop()
		{
			int loop = 0;
			while (!Application.isQuitting)
			{
				yield return CoroutineEx.waitForSecondsRealtime(60f);
				if (GameplayAnalytics)
				{
					yield return TryCatch(AggregatePlayers(blueprints: false, positions: true));
					if (loop % 60 == 0)
					{
						PushServerInfo();
						yield return TryCatch(AggregateEntitiesAndItems());
						yield return TryCatch(AggregatePlayers(blueprints: true));
						yield return TryCatch(AggregateTeams());
						Dictionary<PendingItemsKey, PendingItemsData> dict = pendingItems;
						pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();
						yield return PushPendingItemsLoopAsync(dict);
					}
					loop++;
				}
			}
		}

		private static IEnumerator TryCatch(IEnumerator coroutine)
		{
			while (true)
			{
				try
				{
					if (!coroutine.MoveNext())
					{
						break;
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					break;
				}
				yield return coroutine.Current;
			}
		}

		private static IEnumerator AggregateEntitiesAndItems()
		{
			List<BaseNetworkable> entityQueue = new List<BaseNetworkable>();
			entityQueue.Clear();
			int totalCount = BaseNetworkable.serverEntities.Count;
			entityQueue.AddRange(BaseNetworkable.serverEntities);
			Dictionary<string, int> itemDict = new Dictionary<string, int>();
			Dictionary<EntityKey, int> entityDict = new Dictionary<EntityKey, int>();
			yield return null;
			Debug.Log((object)"Starting to aggregate entities & items...");
			DateTime startTime = DateTime.UtcNow;
			Stopwatch watch = Stopwatch.StartNew();
			foreach (BaseNetworkable entity in entityQueue)
			{
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
				if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
				{
					continue;
				}
				EntityKey entityKey = default(EntityKey);
				entityKey.PrefabId = entity.prefabID;
				EntityKey key = entityKey;
				if (entity is BuildingBlock buildingBlock)
				{
					key.Grade = (int)(buildingBlock.grade + 1);
				}
				entityDict.TryGetValue(key, out var value);
				entityDict[key] = value + 1;
				if (!(entity is LootContainer) && !(entity is BasePlayer { IsNpc: not false }) && !(entity is NPCPlayer))
				{
					if (entity is BasePlayer basePlayer2)
					{
						AddItemsToDict(basePlayer2.inventory.containerMain, itemDict);
						AddItemsToDict(basePlayer2.inventory.containerBelt, itemDict);
						AddItemsToDict(basePlayer2.inventory.containerWear, itemDict);
					}
					else if (entity is IItemContainerEntity itemContainerEntity)
					{
						AddItemsToDict(itemContainerEntity.inventory, itemDict);
					}
					else if (entity is DroppedItemContainer { inventory: not null } droppedItemContainer)
					{
						AddItemsToDict(droppedItemContainer.inventory, itemDict);
					}
				}
			}
			Debug.Log((object)$"Took {Math.Round(DateTime.UtcNow.Subtract(startTime).TotalSeconds, 1)}s to aggregate {totalCount} entities & items...");
			_ = DateTime.UtcNow;
			SubmitPoint(EventRecord.New("entity_sum").AddObject("counts", entityDict.Select(delegate(KeyValuePair<EntityKey, int> x)
			{
				EntitySumItem result = default(EntitySumItem);
				result.PrefabId = x.Key.PrefabId;
				result.Grade = x.Key.Grade;
				result.Count = x.Value;
				return result;
			})));
			yield return null;
			SubmitPoint(EventRecord.New("item_sum").AddObject("counts", itemDict));
			yield return null;
		}

		private static void AddItemsToDict(ItemContainer container, Dictionary<string, int> dict)
		{
			if (container == null || container.itemList == null)
			{
				return;
			}
			foreach (Item item in container.itemList)
			{
				string shortname = item.info.shortname;
				dict.TryGetValue(shortname, out var value);
				dict[shortname] = value + item.amount;
				if (item.contents != null)
				{
					AddItemsToDict(item.contents, dict);
				}
			}
		}

		private static IEnumerator PushPendingItemsLoopAsync(Dictionary<PendingItemsKey, PendingItemsData> dict)
		{
			Stopwatch watch = Stopwatch.StartNew();
			foreach (PendingItemsData value in dict.Values)
			{
				try
				{
					LogResource(value.Key.Consumed ? ResourceMode.Consumed : ResourceMode.Produced, value.category, value.Key.Item, value.amount, null, null, safezone: false, null, 0uL, value.Key.Entity);
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
				}
				PendingItemsData pendingItemsData = value;
				Pool.Free<PendingItemsData>(ref pendingItemsData);
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
			dict.Clear();
		}

		public static void AddPendingItems(BaseEntity entity, string itemName, int amount, string category, bool consumed = true, bool perEntity = false)
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			PendingItemsKey pendingItemsKey = default(PendingItemsKey);
			pendingItemsKey.Entity = entity.ShortPrefabName;
			pendingItemsKey.Category = category;
			pendingItemsKey.Item = itemName;
			pendingItemsKey.Consumed = consumed;
			pendingItemsKey.EntityId = (NetworkableId)(perEntity ? entity.net.ID : default(NetworkableId));
			PendingItemsKey key = pendingItemsKey;
			if (!pendingItems.TryGetValue(key, out var value))
			{
				value = Pool.Get<PendingItemsData>();
				value.Key = key;
				value.category = category;
				pendingItems[key] = value;
			}
			value.amount += amount;
		}

		private static IEnumerator AggregatePlayers(bool blueprints = false, bool positions = false)
		{
			Stopwatch watch = Stopwatch.StartNew();
			Dictionary<int, int> playerBps = (blueprints ? new Dictionary<int, int>() : null);
			List<PlayerAggregate> playerPositions = (positions ? Pool.Get<List<PlayerAggregate>>() : null);
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if ((Object)(object)current == (Object)null || current.IsDestroyed)
					{
						continue;
					}
					if (blueprints)
					{
						foreach (int unlockedItem in current.PersistantPlayerInfo.unlockedItems)
						{
							playerBps.TryGetValue(unlockedItem, out var value);
							playerBps[unlockedItem] = value + 1;
						}
					}
					if (positions)
					{
						PlayerAggregate playerAggregate = Pool.Get<PlayerAggregate>();
						playerAggregate.UserId = current.UserIDString;
						playerAggregate.Position = ((Component)current).transform.position;
						Quaternion bodyRotation = current.eyes.bodyRotation;
						playerAggregate.Direction = ((Quaternion)(ref bodyRotation)).eulerAngles;
						foreach (Item item in current.inventory.containerBelt.itemList)
						{
							playerAggregate.Hotbar.Add(item.info.shortname);
						}
						foreach (Item item2 in current.inventory.containerWear.itemList)
						{
							playerAggregate.Worn.Add(item2.info.shortname);
						}
						playerAggregate.ActiveItem = current.GetActiveItem()?.info.shortname;
						playerAggregate.Biome = GetBiome(((Component)current).transform.position);
						playerPositions.Add(playerAggregate);
					}
					if (watch.ElapsedMilliseconds > MaxMSPerFrame)
					{
						yield return null;
						watch.Restart();
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			if (blueprints)
			{
				SubmitPoint(EventRecord.New("blueprint_aggregate_online").AddObject("blueprints", playerBps.Select((KeyValuePair<int, int> x) => new
				{
					Key = ItemManager.FindItemDefinition(x.Key).shortname,
					value = x.Value
				})));
			}
			if (positions)
			{
				SubmitPoint(EventRecord.New("player_positions").AddObject("positions", playerPositions).AddObject("player_count", playerPositions.Count));
				Pool.Free<PlayerAggregate>(ref playerPositions, true);
			}
		}

		private static IEnumerator AggregateTeams()
		{
			yield return null;
			HashSet<ulong> teamIds = new HashSet<ulong>();
			int inTeam = 0;
			int notInTeam = 0;
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if ((Object)(object)current != (Object)null && !current.IsDestroyed && current.currentTeam != 0L)
					{
						teamIds.Add(current.currentTeam);
						inTeam++;
					}
					else
					{
						notInTeam++;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			yield return null;
			Stopwatch watch = Stopwatch.StartNew();
			List<TeamInfo> teams = Pool.Get<List<TeamInfo>>();
			foreach (ulong item in teamIds)
			{
				RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(item);
				if (playerTeam == null || !((playerTeam.members != null) & (playerTeam.members.Count > 0)))
				{
					continue;
				}
				TeamInfo teamInfo = Pool.Get<TeamInfo>();
				teams.Add(teamInfo);
				foreach (ulong member in playerTeam.members)
				{
					BasePlayer basePlayer = RelationshipManager.FindByID(member);
					if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed && basePlayer.IsConnected && !basePlayer.IsSleeping())
					{
						teamInfo.online.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
					}
					else
					{
						teamInfo.offline.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
					}
				}
				teamInfo.member_count = teamInfo.online.Count + teamInfo.offline.Count;
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
			SubmitPoint(EventRecord.New("online_teams").AddObject("teams", teams).AddField("users_in_team", inTeam)
				.AddField("users_not_in_team", notInTeam));
			foreach (TeamInfo item2 in teams)
			{
				TeamInfo current4 = item2;
				Pool.Free<TeamInfo>(ref current4);
			}
			Pool.Free<TeamInfo>(ref teams, false);
		}
	}

	public class AzureWebInterface
	{
		public static readonly AzureWebInterface client = new AzureWebInterface(isClient: true);

		public static readonly AzureWebInterface server = new AzureWebInterface(isClient: false);

		private AzureAnalyticsUploader GameplayBulkUploader;

		public bool IsClient;

		public int MaxRetries = 1;

		public int FlushSize = 1000;

		public TimeSpan FlushDelay = TimeSpan.FromSeconds(30.0);

		private DateTime nextFlush;

		private ConcurrentQueue<EventRecord> uploadQueue = new ConcurrentQueue<EventRecord>();

		private HttpClient HttpClient = new HttpClient();

		private static readonly MediaTypeHeaderValue JsonContentType = new MediaTypeHeaderValue("application/json")
		{
			CharSet = Encoding.UTF8.WebName
		};

		public int PendingCount => uploadQueue.Count;

		public AzureWebInterface(bool isClient)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Expected O, but got Unknown
			IsClient = isClient;
			Task.Run((Func<Task?>)UploadSchedulingThread);
		}

		public void EnqueueEvent(EventRecord point)
		{
			if (!IsClient && !string.IsNullOrEmpty(GetContainerUrl()))
			{
				if (GameplayBulkUploader.NeedsCreation())
				{
					GameplayBulkUploader = AzureAnalyticsUploader.Create("gameplay_events", TimeSpan.FromMinutes(5.0));
					GameplayBulkUploader.UseJsonDataObject = true;
				}
				GameplayBulkUploader.Append(point);
			}
			else
			{
				point.MarkSubmitted();
				uploadQueue.Enqueue(point);
			}
		}

		private async Task UploadSchedulingThread()
		{
			while (!Application.isQuitting)
			{
				try
				{
					DateTime utcNow = DateTime.UtcNow;
					if (uploadQueue.IsEmpty || (uploadQueue.Count < FlushSize && nextFlush > utcNow))
					{
						await Task.Delay(1000);
						continue;
					}
					nextFlush = utcNow.Add(FlushDelay);
					List<EventRecord> list = Pool.Get<List<EventRecord>>();
					EventRecord result;
					while (uploadQueue.TryDequeue(out result))
					{
						list.Add(result);
					}
					Task.Run(async delegate
					{
						await UploadAsync(list);
					});
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					await Task.Delay(1000);
				}
			}
		}

		private void SerializeEvents(List<EventRecord> records, MemoryStream stream)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			Utf8ValueStringBuilder writer = ZString.CreateUtf8StringBuilder();
			try
			{
				((Utf8ValueStringBuilder)(ref writer)).Append("[");
				foreach (EventRecord record in records)
				{
					if (num > 0)
					{
						((Utf8ValueStringBuilder)(ref writer)).Append(',');
					}
					record.SerializeAsJson(ref writer);
					num++;
				}
				((Utf8ValueStringBuilder)(ref writer)).Append("]");
				((Utf8ValueStringBuilder)(ref writer)).WriteTo((Stream)stream);
			}
			finally
			{
				((Utf8ValueStringBuilder)(ref writer)).Dispose();
			}
		}

		private async Task UploadAsync(List<EventRecord> records, bool useStoredAuthTicket = false)
		{
			if (!(IsClient ? (Application.Manifest?.Features?.ClientAnalytics == true) : (Application.Manifest?.Features?.ServerAnalytics == true)))
			{
				Pool.Free<EventRecord>(ref records, true);
				return;
			}
			if (records.Count == 0)
			{
				Pool.Free<EventRecord>(ref records, false);
				return;
			}
			MemoryStream stream = Pool.Get<MemoryStream>();
			stream.Position = 0L;
			stream.SetLength(0L);
			try
			{
				SerializeEvents(records, stream);
				AuthTicket ticket = null;
				for (int attempt = 0; attempt < MaxRetries; attempt++)
				{
					try
					{
						ByteArrayContent content = new ByteArrayContent(stream.GetBuffer(), 0, (int)stream.Length);
						try
						{
							((HttpContent)content).Headers.ContentType = JsonContentType;
							if (!string.IsNullOrEmpty(AnalyticsSecret))
							{
								((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsSecret);
							}
							else
							{
								((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsPublicKey);
							}
							if (!IsClient)
							{
								((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-IP", Net.sv.ip);
								((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-PORT", Net.sv.port.ToString());
							}
							(await HttpClient.PostAsync(IsClient ? ClientAnalyticsUrl : ServerAnalyticsUrl, (HttpContent)(object)content)).EnsureSuccessStatusCode();
						}
						finally
						{
							((IDisposable)content)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						HttpRequestException val = (HttpRequestException)(object)((ex is HttpRequestException) ? ex : null);
						if (val != null)
						{
							Debug.Log((object)("HTTP Error when uploading analytics: " + ((Exception)(object)val).Message));
						}
						else
						{
							Debug.LogException(ex);
						}
						goto IL_02ae;
					}
					break;
					IL_02ae:
					if (ticket != null)
					{
						try
						{
							ticket.Cancel();
						}
						catch (Exception ex2)
						{
							Debug.LogError((object)("Failed to cancel auth ticket in analytics: " + ex2.ToString()));
						}
					}
				}
			}
			catch (Exception ex3)
			{
				if (IsClient)
				{
					Debug.LogWarning((object)ex3.ToString());
				}
				else
				{
					Debug.LogException(ex3);
				}
			}
			finally
			{
				Pool.Free<EventRecord>(ref records, true);
				Pool.FreeUnmanaged(ref stream);
			}
		}
	}

	private static HashSet<NetworkableId> trackedSpawnedIds = new HashSet<NetworkableId>();

	public static string ClientAnalyticsUrl { get; set; } = "https://rust-api.facepunch.com/api/public/analytics/rust/client";

	[ServerVar(Name = "server_analytics_url")]
	public static string ServerAnalyticsUrl { get; set; } = "https://rust-api.facepunch.com/api/public/analytics/rust/server";

	[ServerVar(Name = "analytics_header", Saved = true, Help = "Header key of secret when uploading analytics")]
	public static string AnalyticsHeader { get; set; } = "X-API-KEY";

	[ServerVar(Name = "analytics_secret", Saved = true, Help = "Header secret value when uploading analytics")]
	public static string AnalyticsSecret { get; set; } = "";

	public static string AnalyticsPublicKey { get; set; } = "pub878ABLezSB6onshSwBCRGYDCpEI";

	[ServerVar(Name = "analytics_bulk_upload_url", Saved = true, Help = "Azure blob container url + SAS token, enables a more efficient upload method")]
	public static string BulkUploadConnectionString { get; set; }

	[ServerVar(Name = "analytics_bulk_container_url", Saved = true, Help = "Azure blob container url for use with client secret authentication")]
	public static string BulkContainerUrl { get; set; }

	[ServerVar(Name = "azure_tenant_id", Saved = true, Help = "Azure tenant id for authentication")]
	public static string AzureTenantId { get; set; }

	[ServerVar(Name = "azure_client_id", Saved = true, Help = "Azure client id for authentication")]
	public static string AzureClientId { get; set; }

	[ServerVar(Name = "azure_client_secret", Saved = true, Help = "Azure client secret for authentication")]
	public static string AzureClientSecret { get; set; }

	[ServerVar(Name = "performance_analytics", Saved = true, Help = "Toggle to turn off server performance collection")]
	public static bool ServerPerformanceConVar { get; set; } = true;

	[ServerVar(Name = "gameplay_analytics", Saved = true, Help = "Toggle whether gameplay analytics is collected")]
	public static bool GameplayAnalyticsConVar { get; set; }

	[ServerVar(Name = "gameplay_tick_analytics", Saved = true, Help = "Toggle whether gameplay tick analytics is collected")]
	public static bool GameplayTickAnalyticsConVar { get; set; }

	[ServerVar(Name = "small_buffer_send_limit", Saved = true, Help = "Size of analytics events, in bytes, that we try to send off using the same task thread. To disable, set to -1")]
	public static int SmallBufferSendLimit
	{
		get
		{
			return AzureAnalyticsUploader.SmallBufferSendLimit;
		}
		set
		{
			AzureAnalyticsUploader.SmallBufferSendLimit = value;
		}
	}

	[ClientVar(Name = "pending_analytics", Help = "Shows how many analytics events are pending upload")]
	[ServerVar(Name = "pending_analytics", Help = "Shows how many analytics events are pending upload")]
	public static void GetPendingAnalytics(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Server Pending: {AzureWebInterface.server.PendingCount}");
		arg.ReplyWith(stringBuilder.ToString());
	}

	public static string GetContainerUrl()
	{
		if (string.IsNullOrEmpty(BulkUploadConnectionString))
		{
			return BulkContainerUrl;
		}
		return BulkUploadConnectionString;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using ConVar;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public static class Azure
{
	public enum ResourceMode
	{
		Produced,
		Consumed
	}

	private static class EventIds
	{
		public const string EntityBuilt = "entity_built";

		public const string EntityPickup = "entity_pickup";

		public const string EntityDamage = "entity_damage";

		public const string PlayerRespawn = "player_respawn";

		public const string ExplosiveLaunched = "explosive_launch";

		public const string Explosion = "explosion";

		public const string ItemEvent = "item_event";

		public const string EntitySum = "entity_sum";

		public const string ItemSum = "item_sum";

		public const string ItemDespawn = "item_despawn";

		public const string ItemDropped = "item_drop";

		public const string ItemPickup = "item_pickup";

		public const string AntihackViolation = "antihack_violation";

		public const string AntihackViolationDetailed = "antihack_violation_detailed";

		public const string PlayerConnect = "player_connect";

		public const string PlayerDisconnect = "player_disconnect";

		public const string ConsumableUsed = "consumeable_used";

		public const string MedUsed = "med_used";

		public const string ResearchStarted = "research_start";

		public const string BlueprintLearned = "blueprint_learned";

		public const string TeamChanged = "team_change";

		public const string EntityAuthChange = "auth_change";

		public const string VendingOrderChanged = "vending_changed";

		public const string VendingSale = "vending_sale";

		public const string ChatMessage = "chat";

		public const string BlockUpgrade = "block_upgrade";

		public const string BlockDemolish = "block_demolish";

		public const string ItemRepair = "item_repair";

		public const string EntityRepair = "entity_repair";

		public const string ItemSkinned = "item_skinned";

		public const string EntitySkinned = "entity_skinned";

		public const string ItemAggregate = "item_aggregate";

		public const string CodelockChanged = "code_change";

		public const string CodelockEntered = "code_enter";

		public const string SleepingBagAssign = "sleeping_bag_assign";

		public const string FallDamage = "fall_damage";

		public const string PlayerWipeIdSet = "player_wipe_id_set";

		public const string ServerInfo = "server_info";

		public const string UnderwaterCrateUntied = "crate_untied";

		public const string VehiclePurchased = "vehicle_purchase";

		public const string NPCVendor = "npc_vendor";

		public const string BlueprintsOnline = "blueprint_aggregate_online";

		public const string PlayerPositions = "player_positions";

		public const string ProjectileInvalid = "projectile_invalid";

		public const string ItemDefinitions = "item_definitions";

		public const string KeycardSwiped = "keycard_swiped";

		public const string EntitySpawned = "entity_spawned";

		public const string EntityKilled = "entity_killed";

		public const string HackableCrateStarted = "hackable_crate_started";

		public const string HackableCrateEnded = "hackable_crate_ended";

		public const string StashHidden = "stash_hidden";

		public const string StashRevealed = "stash_reveal";

		public const string EntityManifest = "entity_manifest";

		public const string LootEntity = "loot_entity";

		public const string OnlineTeams = "online_teams";

		public const string Gambling = "gambing";

		public const string BuildingBlockColor = "building_block_color";

		public const string MissionComplete = "mission_complete";

		public const string PlayerPinged = "player_pinged";

		public const string BagUnclaim = "bag_unclaim";

		public const string SteamAuth = "steam_auth";

		public const string ParachuteUsed = "parachute_used";

		public const string MountEntity = "mount";

		public const string DismountEntity = "dismount";

		public const string BurstToggle = "burst_toggle";

		public const string TutorialStarted = "tutorial_started";

		public const string TutorialCompleted = "tutorial_completed";

		public const string TutorialQuit = "tutorial_quit";

		public const string BaseInteraction = "base_interaction";

		public const string PlayerDeath = "player_death";

		public const string CarShredded = "car_shredded";

		public const string PlayerTick = "player_tick";

		public const string WallpaperPlaced = "wallpaper_placed";

		public const string StartFish = "fishing_start";

		public const string FailedFish = "fishing_failed";

		public const string CaughtFish = "fishing_caught";

		public const string InjureStateChange = "injure_state";

		public const string LifeStoryEnd = "life_story_end";

		public const string ServerRPC = "server_rpc";
	}

	private struct SimpleItemAmount
	{
		public string ItemName;

		public int Amount;

		public ulong Skin;

		public float Condition;

		public SimpleItemAmount(Item item)
		{
			ItemName = item.info.shortname;
			Amount = item.amount;
			Skin = item.skin;
			Condition = item.conditionNormalized;
		}
	}

	private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
	{
		public ulong UserId;

		public int ProjectileId;

		public FiredProjectileKey(ulong userId, int projectileId)
		{
			UserId = userId;
			ProjectileId = projectileId;
		}

		public bool Equals(FiredProjectileKey other)
		{
			if (other.UserId == UserId)
			{
				return other.ProjectileId == ProjectileId;
			}
			return false;
		}
	}

	private class PendingFiredProjectile : IPooled
	{
		public EventRecord Record;

		public BasePlayer.FiredProjectile FiredProjectile;

		public bool Hit;

		public void EnterPool()
		{
			Hit = false;
			Record = null;
			FiredProjectile = null;
		}

		public void LeavePool()
		{
		}
	}

	[JsonModel]
	private struct EntitySumItem
	{
		public uint PrefabId;

		public int Count;

		public int Grade;
	}

	private struct EntityKey : IEquatable<EntityKey>
	{
		public uint PrefabId;

		public int Grade;

		public bool Equals(EntityKey other)
		{
			if (PrefabId == other.PrefabId)
			{
				return Grade == other.Grade;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
		}
	}

	private class PendingItemsData : IPooled
	{
		public PendingItemsKey Key;

		public int amount;

		public string category;

		public void EnterPool()
		{
			Key = default(PendingItemsKey);
			amount = 0;
			category = null;
		}

		public void LeavePool()
		{
		}
	}

	private struct PendingItemsKey : IEquatable<PendingItemsKey>
	{
		public string Item;

		public bool Consumed;

		public string Entity;

		public string Category;

		public NetworkableId EntityId;

		public bool Equals(PendingItemsKey other)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
			{
				return Category == other.Category;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
		}
	}

	[JsonModel]
	private class PlayerAggregate : IPooled
	{
		public string UserId;

		public Vector3 Position;

		public Vector3 Direction;

		public List<string> Hotbar = new List<string>();

		public List<string> Worn = new List<string>();

		public string ActiveItem;

		public string Biome;

		public void EnterPool()
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			UserId = null;
			Position = default(Vector3);
			Direction = default(Vector3);
			Hotbar.Clear();
			Worn.Clear();
			ActiveItem = null;
			Biome = null;
		}

		public void LeavePool()
		{
		}
	}

	[JsonModel]
	private class TeamInfo : IPooled
	{
		public List<string> online = new List<string>();

		public List<string> offline = new List<string>();

		public int member_count;

		public void EnterPool()
		{
			online.Clear();
			offline.Clear();
			member_count = 0;
		}

		public void LeavePool()
		{
		}
	}

	private static Dictionary<FiredProjectileKey, PendingFiredProjectile> trackedProjectiles = new Dictionary<FiredProjectileKey, PendingFiredProjectile>();

	private static Dictionary<int, string> geneCache = new Dictionary<int, string>();

	public static int MaxMSPerFrame = 5;

	private static Dictionary<PendingItemsKey, PendingItemsData> pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();

	public static bool GameplayAnalytics => GameplayAnalyticsConVar;

	public static void Initialize()
	{
		PushItemDefinitions();
		PushEntityManifest();
		((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(AggregateLoop());
	}

	private static void PushServerInfo()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("server_info").AddField("seed", World.Seed).AddField("size", World.Size)
				.AddField("url", World.Url)
				.AddField("ip_convar", Net.sv.ip)
				.AddField("port_convar", Net.sv.port)
				.AddField("net_protocol", Net.sv.ProtocolId)
				.AddField("protocol_network", 2594)
				.AddField("protocol_save", 270);
			BuildInfo current = BuildInfo.Current;
			EventRecord eventRecord2 = eventRecord.AddField("changeset", ((current != null) ? current.Scm.ChangeId : null) ?? "0").AddField("unity_version", Application.unityVersion);
			BuildInfo current2 = BuildInfo.Current;
			SubmitPoint(eventRecord2.AddField("branch", ((current2 != null) ? current2.Scm.Branch : null) ?? "empty").AddField("server_tags", ConVar.Server.tags).AddField("device_id", SystemInfo.deviceUniqueIdentifier)
				.AddField("network_id", Net.sv.GetLastUIDGiven()));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void PushItemDefinitions()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)GameManifest.Current == (Object)null)
			{
				return;
			}
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj == null)
			{
				return;
			}
			SubmitPoint(EventRecord.New("item_definitions").AddObject("items", from x in ItemManager.itemDictionary
				select x.Value into x
				select new
				{
					item_id = x.itemid,
					shortname = x.shortname,
					craft_time = (x.Blueprint?.GetCraftTime() ?? 0f),
					workbench = (x.Blueprint?.GetWorkbenchLevel() ?? 0),
					category = x.category.ToString(),
					display_name = x.displayName.english,
					despawn_rarity = x.despawnRarity,
					ingredients = (from y in x.Blueprint?.GetIngredients()
						select new
						{
							shortname = y.itemDef.shortname,
							amount = (int)y.amount
						})
				}).AddField("changeset", BuildInfo.Current.Scm.ChangeId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void PushEntityManifest()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)GameManifest.Current == (Object)null)
			{
				return;
			}
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj != null)
			{
				EventRecord eventRecord = EventRecord.New("entity_manifest").AddObject("entities", GameManifest.Current.entities.Select((string x) => new
				{
					shortname = Path.GetFileNameWithoutExtension(x),
					prefab_id = StringPool.Get(x.ToLower())
				}));
				BuildInfo current2 = BuildInfo.Current;
				SubmitPoint(eventRecord.AddField("changeset", ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor"));
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void SubmitPoint(EventRecord point)
	{
		point.Submit();
	}

	public static void OnFiredProjectile(BasePlayer player, BasePlayer.FiredProjectile projectile, Guid projectileGroupId)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord record = EventRecord.New("entity_damage").AddField("start_pos", projectile.position).AddField("start_vel", projectile.initialVelocity)
				.AddField("velocity_inherit", projectile.inheritedVelocity)
				.AddField("ammo_item", projectile.itemDef?.shortname)
				.AddField("weapon", (BaseNetworkable)projectile.weaponSource)
				.AddField("projectile_group", projectileGroupId)
				.AddField("projectile_id", projectile.id)
				.AddField("attacker", (BaseNetworkable)player)
				.AddField("look_dir", player.tickViewAngles)
				.AddField("model_state", (player.modelStateTick ?? player.modelState).flags)
				.AddField("burst_mode", projectile.weaponSource?.HasFlag(BaseEntity.Flags.Reserved6) ?? false);
			PendingFiredProjectile pendingFiredProjectile = Pool.Get<PendingFiredProjectile>();
			pendingFiredProjectile.Record = record;
			pendingFiredProjectile.FiredProjectile = projectile;
			trackedProjectiles[new FiredProjectileKey(player.userID, projectile.id)] = pendingFiredProjectile;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFiredProjectileRemoved(BasePlayer player, BasePlayer.FiredProjectile projectile)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			FiredProjectileKey key = new FiredProjectileKey(player.userID, projectile.id);
			if (!trackedProjectiles.TryGetValue(key, out var value))
			{
				return;
			}
			if (!value.Hit)
			{
				EventRecord record = value.Record;
				if (projectile.updates.Count > 0)
				{
					record.AddObject("projectile_updates", projectile.updates);
				}
				SubmitPoint(record);
			}
			Pool.Free<PendingFiredProjectile>(ref value);
			trackedProjectiles.Remove(key);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnQuarryItem(ResourceMode mode, string item, int amount, MiningQuarry sourceEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			AddPendingItems(sourceEntity, item, amount, "quarry", mode == ResourceMode.Consumed);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExcavatorProduceItem(Item item, BaseEntity sourceEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			AddPendingItems(sourceEntity, item.info.shortname, item.amount, "excavator", consumed: false);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExcavatorConsumeFuel(Item item, int amount, BaseEntity dieselEngine)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Consumed, "excavator", item.info.shortname, amount, dieselEngine, null, safezone: false, null, 0uL);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCraftItem(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "craft", item, amount, null, null, inSafezone, workbench, player?.userID ?? ((EncryptedValue<ulong>)0uL));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCraftMaterialConsumed(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone, string targetItem)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(safezone: inSafezone, workbench: workbench, targetItem: targetItem, mode: ResourceMode.Consumed, category: "craft", itemName: item, amount: amount, sourceEntity: null, tool: null, steamId: player?.userID ?? ((EncryptedValue<ulong>)0uL));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnConsumableUsed(BasePlayer player, Item item)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("consumeable_used").AddField("player", (BaseNetworkable)player).AddField("item", item));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntitySpawned(BaseEntity entity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			trackedSpawnedIds.Add(entity.net.ID);
			SubmitPoint(EventRecord.New("entity_spawned").AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void TryLogEntityKilled(BaseNetworkable entity)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity.IsValid() && trackedSpawnedIds.Contains(entity.net.ID))
			{
				SubmitPoint(EventRecord.New("entity_killed").AddField("entity", entity));
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMedUsed(string itemName, BasePlayer player, BasePlayer target)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("med_used").AddField("player", (BaseNetworkable)player).AddField("target", (BaseNetworkable)target)
				.AddField("item_name", itemName));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCodelockChanged(BasePlayer player, CodeLock codeLock, string oldCode, string newCode, bool isGuest)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("code_change").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
				.AddField("old_code", oldCode)
				.AddField("new_code", newCode)
				.AddField("is_guest", isGuest));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCodeLockEntered(BasePlayer player, CodeLock codeLock, bool isGuest)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("code_enter").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
				.AddField("is_guest", isGuest));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTeamChanged(string change, ulong teamId, ulong teamLeader, ulong user, List<ulong> members)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		try
		{
			if (members != null)
			{
				foreach (ulong member in members)
				{
					list.Add(member);
				}
			}
			SubmitPoint(EventRecord.New("team_change").AddField("team_leader", teamLeader).AddField("team", teamId)
				.AddField("target_user", user)
				.AddField("change", change)
				.AddObject("users", list)
				.AddField("member_count", members.Count));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		Pool.FreeUnmanaged<ulong>(ref list);
	}

	public static void OnEntityAuthChanged(BaseEntity entity, BasePlayer player, IEnumerable<ulong> authedList, string change, ulong targetUser)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("auth_change").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
				.AddField("target", targetUser)
				.AddObject("auth_list", authedList)
				.AddField("change", change));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSleepingBagAssigned(BasePlayer player, SleepingBag bag, ulong targetUser)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("sleeping_bag_assign").AddField("entity", (BaseNetworkable)bag).AddField("player", (BaseNetworkable)player)
				.AddField("target", targetUser));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFallDamage(BasePlayer player, float velocity, float damage)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fall_damage").AddField("player", (BaseNetworkable)player).AddField("velocity", velocity)
				.AddField("damage", damage));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnResearchStarted(BasePlayer player, BaseEntity entity, Item item, int scrapCost)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("research_start").AddField("player", (BaseNetworkable)player).AddField("item", item.info.shortname)
				.AddField("scrap", scrapCost)
				.AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBlueprintLearned(BasePlayer player, ItemDefinition item, string reason, int scrapCost, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("blueprint_learned").AddField("player", (BaseNetworkable)player).AddField("item", item.shortname)
				.AddField("reason", reason)
				.AddField("entity", (BaseNetworkable)entity)
				.AddField("scrap_cost", scrapCost));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemRecycled(string item, int amount, Recycler recycler)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Consumed, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnRecyclerItemProduced(string item, int amount, Recycler recycler, Item sourceItem)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy, null, sourceItem);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnGatherItem(string item, int amount, BaseEntity sourceEntity, BasePlayer player, AttackEntity weapon = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "gather", item, amount, sourceEntity, weapon, safezone: false, null, player.userID);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFirstLooted(BaseEntity entity, BasePlayer player)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity is LootContainer lootContainer)
			{
				LogItemsLooted(player, entity, lootContainer.inventory);
				SubmitPoint(EventRecord.New("loot_entity").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
					.AddField("monument", GetMonument(entity))
					.AddField("biome", GetBiome(((Component)entity).transform.position)));
			}
			else if (entity is LootableCorpse { containers: var containers })
			{
				foreach (ItemContainer container in containers)
				{
					LogItemsLooted(player, entity, container);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLootContainerDestroyed(LootContainer entity, BasePlayer player, AttackEntity weapon)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity.DropsLoot && (Object)(object)player != (Object)null && Vector3.Distance(((Component)entity).transform.position, ((Component)player).transform.position) < 50f && entity.inventory?.itemList != null && entity.inventory.itemList.Count > 0)
			{
				LogItemsLooted(player, entity, entity.inventory, weapon);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityDestroyed(BaseNetworkable entity)
	{
		TryLogEntityKilled(entity);
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (!(entity is LootContainer { FirstLooterId: 0uL } lootContainer))
			{
				return;
			}
			foreach (Item item in lootContainer.inventory.itemList)
			{
				OnItemDespawn(lootContainer, item, 3, lootContainer.LastLootedBy);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityBuilt(BaseEntity entity, BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("entity_built").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity);
			if (entity is SleepingBag)
			{
				int sleepingBagCount = SleepingBag.GetSleepingBagCount(player.userID);
				eventRecord.AddField("bags_active", sleepingBagCount);
				eventRecord.AddField("max_sleeping_bags", ConVar.Server.max_sleeping_bags);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("mount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
				.AddField("seat", (BaseNetworkable)seat));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnDismountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("dismount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
				.AddField("seat", (BaseNetworkable)seat));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnKeycardSwiped(BasePlayer player, CardReader cardReader)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("keycard_swiped").AddField("player", (BaseNetworkable)player).AddField("card_level", cardReader.accessLevel)
				.AddField("entity", (BaseNetworkable)cardReader));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLockedCrateStarted(BasePlayer player, HackableLockedCrate crate)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("hackable_crate_started").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)crate));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLockedCrateFinished(ulong player, HackableLockedCrate crate)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("hackable_crate_ended").AddField("player_steamid", player).AddField("entity", (BaseNetworkable)crate));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStashHidden(BasePlayer player, StashContainer entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("stash_hidden").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("owner", entity.OwnerID));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStashRevealed(BasePlayer player, StashContainer entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("stash_reveal").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("owner", entity.OwnerID));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnAntihackViolation(BasePlayer player, AntiHackType type, string message)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("antihack_violation").AddField("player", (BaseNetworkable)player).AddField("violation_type", (int)type)
				.AddField("violation", type.ToString())
				.AddField("message", message);
			if (BuildInfo.Current != null)
			{
				eventRecord.AddField("changeset", BuildInfo.Current.Scm.ChangeId).AddField("network", 2594);
			}
			switch (type)
			{
			case AntiHackType.SpeedHack:
				eventRecord.AddField("speedhack_protection", ConVar.AntiHack.speedhack_protection).AddField("speedhack_forgiveness", ConVar.AntiHack.speedhack_forgiveness).AddField("speedhack_forgiveness_inertia", ConVar.AntiHack.speedhack_forgiveness_inertia)
					.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_penalty)
					.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_reject)
					.AddField("speedhack_slopespeed", ConVar.AntiHack.speedhack_slopespeed);
				break;
			case AntiHackType.NoClip:
				eventRecord.AddField("noclip_protection", ConVar.AntiHack.noclip_protection).AddField("noclip_penalty", ConVar.AntiHack.noclip_penalty).AddField("noclip_maxsteps", ConVar.AntiHack.noclip_maxsteps)
					.AddField("noclip_margin_dismount", ConVar.AntiHack.noclip_margin_dismount)
					.AddField("noclip_margin", ConVar.AntiHack.noclip_margin)
					.AddField("noclip_backtracking", ConVar.AntiHack.noclip_backtracking)
					.AddField("noclip_reject", ConVar.AntiHack.noclip_reject)
					.AddField("noclip_stepsize", ConVar.AntiHack.noclip_stepsize);
				break;
			case AntiHackType.ProjectileHack:
				eventRecord.AddField("projectile_anglechange", ConVar.AntiHack.projectile_anglechange).AddField("projectile_backtracking", ConVar.AntiHack.projectile_backtracking).AddField("projectile_clientframes", ConVar.AntiHack.projectile_clientframes)
					.AddField("projectile_damagedepth", ConVar.AntiHack.projectile_damagedepth)
					.AddField("projectile_desync", ConVar.AntiHack.projectile_desync)
					.AddField("projectile_forgiveness", ConVar.AntiHack.projectile_forgiveness)
					.AddField("projectile_impactspawndepth", ConVar.AntiHack.projectile_impactspawndepth)
					.AddField("projectile_losforgiveness", ConVar.AntiHack.projectile_losforgiveness)
					.AddField("projectile_penalty", ConVar.AntiHack.projectile_penalty)
					.AddField("projectile_positionoffset", ConVar.AntiHack.projectile_positionoffset)
					.AddField("projectile_protection", ConVar.AntiHack.projectile_protection)
					.AddField("projectile_serverframes", ConVar.AntiHack.projectile_serverframes)
					.AddField("projectile_terraincheck", ConVar.AntiHack.projectile_terraincheck)
					.AddField("projectile_trajectory", ConVar.AntiHack.projectile_trajectory)
					.AddField("projectile_vehiclecheck", ConVar.AntiHack.projectile_vehiclecheck)
					.AddField("projectile_velocitychange", ConVar.AntiHack.projectile_velocitychange);
				break;
			case AntiHackType.InsideTerrain:
				eventRecord.AddField("terrain_check_geometry", ConVar.AntiHack.terrain_check_geometry).AddField("terrain_kill", ConVar.AntiHack.terrain_kill).AddField("terrain_padding", ConVar.AntiHack.terrain_padding)
					.AddField("terrain_penalty", ConVar.AntiHack.terrain_penalty)
					.AddField("terrain_protection", ConVar.AntiHack.terrain_protection)
					.AddField("terrain_timeslice", ConVar.AntiHack.terrain_timeslice);
				break;
			case AntiHackType.MeleeHack:
				eventRecord.AddField("melee_backtracking", ConVar.AntiHack.melee_backtracking).AddField("melee_clientframes", ConVar.AntiHack.melee_clientframes).AddField("melee_forgiveness", ConVar.AntiHack.melee_forgiveness)
					.AddField("melee_losforgiveness", ConVar.AntiHack.melee_losforgiveness)
					.AddField("melee_penalty", ConVar.AntiHack.melee_penalty)
					.AddField("melee_protection", ConVar.AntiHack.melee_protection)
					.AddField("melee_serverframes", ConVar.AntiHack.melee_serverframes)
					.AddField("melee_terraincheck", ConVar.AntiHack.melee_terraincheck)
					.AddField("melee_vehiclecheck", ConVar.AntiHack.melee_vehiclecheck);
				break;
			case AntiHackType.FlyHack:
				eventRecord.AddField("flyhack_extrusion", ConVar.AntiHack.flyhack_extrusion).AddField("flyhack_forgiveness_horizontal", ConVar.AntiHack.flyhack_forgiveness_horizontal).AddField("flyhack_forgiveness_horizontal_inertia", ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia)
					.AddField("flyhack_forgiveness_vertical", ConVar.AntiHack.flyhack_forgiveness_vertical)
					.AddField("flyhack_forgiveness_vertical_inertia", ConVar.AntiHack.flyhack_forgiveness_vertical_inertia)
					.AddField("flyhack_margin", ConVar.AntiHack.flyhack_margin)
					.AddField("flyhack_maxsteps", ConVar.AntiHack.flyhack_maxsteps)
					.AddField("flyhack_penalty", ConVar.AntiHack.flyhack_penalty)
					.AddField("flyhack_protection", ConVar.AntiHack.flyhack_protection)
					.AddField("flyhack_reject", ConVar.AntiHack.flyhack_reject);
				break;
			case AntiHackType.EyeHack:
				eventRecord.AddField("eye_clientframes", ConVar.AntiHack.eye_clientframes).AddField("eye_forgiveness", ConVar.AntiHack.eye_forgiveness).AddField("eye_history_forgiveness", ConVar.AntiHack.eye_history_forgiveness)
					.AddField("eye_history_penalty", ConVar.AntiHack.eye_history_penalty)
					.AddField("eye_losradius", ConVar.AntiHack.eye_losradius)
					.AddField("eye_noclip_backtracking", ConVar.AntiHack.eye_noclip_backtracking)
					.AddField("eye_noclip_cutoff", ConVar.AntiHack.eye_noclip_cutoff)
					.AddField("eye_penalty", ConVar.AntiHack.eye_penalty)
					.AddField("eye_protection", ConVar.AntiHack.eye_protection)
					.AddField("eye_serverframes", ConVar.AntiHack.eye_serverframes)
					.AddField("eye_terraincheck", ConVar.AntiHack.eye_terraincheck)
					.AddField("eye_vehiclecheck", ConVar.AntiHack.eye_vehiclecheck);
				break;
			case AntiHackType.AttackHack:
				eventRecord.AddField("maxdesync", ConVar.AntiHack.maxdesync);
				break;
			case AntiHackType.Ticks:
				eventRecord.AddField("max_distance", ConVar.AntiHack.tick_max_distance).AddField("max_distance_falling", ConVar.AntiHack.tick_max_distance_falling).AddField("max_distance_parented", ConVar.AntiHack.tick_max_distance_parented)
					.AddField("tick_buffer_noclip_threshold", ConVar.AntiHack.tick_buffer_noclip_threshold)
					.AddField("tick_buffer_reject_threshold", ConVar.AntiHack.tick_buffer_reject_threshold);
				break;
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEyehackViolation(BasePlayer player, Vector3 eyePos)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 6)
				.AddField("eye_pos", eyePos));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnNoclipViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount, Collider collider)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 1)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("collider_name", ((Object)collider).name));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFlyhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 3)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnProjectileHackViolation(BasePlayer.FiredProjectile projectile)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (!projectile.invalid)
			{
				FiredProjectileKey key = new FiredProjectileKey(projectile.attacker.userID, projectile.id);
				if (trackedProjectiles.TryGetValue(key, out var value))
				{
					projectile.invalid = true;
					value.Record.AddField("projectile_invalid", value: true).AddObject("updates", projectile.updates);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSpeedhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 2)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("distance", Vector3.Distance(startPos, endPos))
				.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTickViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 13)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("distance", Vector3.Distance(startPos, endPos))
				.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTerrainHackViolation(BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 10)
				.AddField("seed", World.Seed)
				.AddField("size", World.Size)
				.AddField("map_url", World.Url)
				.AddField("map_checksum", World.Checksum));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityTakeDamage(HitInfo info, bool isDeath)
	{
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0463: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0615: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			BasePlayer basePlayer = info.HitEntity as BasePlayer;
			if (((Object)(object)info.Initiator == (Object)null && !isDeath) || (((Object)(object)initiatorPlayer == (Object)null || initiatorPlayer.IsNpc || initiatorPlayer.IsBot) && ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc || basePlayer.IsBot)))
			{
				return;
			}
			EventRecord eventRecord = null;
			float value = -1f;
			float value2 = -1f;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				if (info.IsProjectile())
				{
					FiredProjectileKey key = new FiredProjectileKey(initiatorPlayer.userID, info.ProjectileID);
					if (trackedProjectiles.TryGetValue(key, out var value3))
					{
						eventRecord = value3.Record;
						value = Vector3.Distance(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
						value = Vector3Ex.Distance2D(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
						value3.Hit = info.DidHit;
						if (eventRecord != null && value3.FiredProjectile.updates.Count > 0)
						{
							eventRecord.AddObject("projectile_updates", value3.FiredProjectile.updates);
						}
						if (eventRecord != null && value3.FiredProjectile.simulatedPositions.Count > 0)
						{
							eventRecord.AddObject("simulated_position", value3.FiredProjectile.simulatedPositions);
						}
						if (eventRecord != null)
						{
							eventRecord.AddField("partial_time", value3.FiredProjectile.partialTime);
							eventRecord.AddField("desync_lifetime", value3.FiredProjectile.desyncLifeTime);
							eventRecord.AddField("startpoint_mismatch", value3.FiredProjectile.startPointMismatch);
							eventRecord.AddField("endpoint_mismatch", value3.FiredProjectile.endPointMismatch);
							eventRecord.AddField("entity_distance", value3.FiredProjectile.entityDistance);
							eventRecord.AddField("position_offset", value3.FiredProjectile.initialPositionOffset);
						}
						trackedProjectiles.Remove(key);
						Pool.Free<PendingFiredProjectile>(ref value3);
					}
				}
				else
				{
					value = Vector3.Distance(info.HitNormalWorld, initiatorPlayer.eyes.position);
					value2 = Vector3Ex.Distance2D(info.HitNormalWorld, initiatorPlayer.eyes.position);
				}
			}
			if (eventRecord == null)
			{
				eventRecord = EventRecord.New("entity_damage");
			}
			eventRecord.AddField("is_headshot", info.isHeadshot).AddField("victim", (BaseNetworkable)info.HitEntity).AddField("damage", info.damageTypes.Total())
				.AddField("damage_type", info.damageTypes.GetMajorityDamageType().ToString())
				.AddField("pos_world", info.HitPositionWorld)
				.AddField("pos_local", info.HitPositionLocal)
				.AddField("point_start", info.PointStart)
				.AddField("point_end", info.PointEnd)
				.AddField("normal_world", info.HitNormalWorld)
				.AddField("normal_local", info.HitNormalLocal)
				.AddField("distance_cl", info.ProjectileDistance)
				.AddField("distance", value)
				.AddField("distance_2d", value2);
			if ((Object)(object)info.HitEntity != (Object)null && (Object)(object)info.HitEntity.model != (Object)null)
			{
				eventRecord.AddField("pos_local_model", ((Component)info.HitEntity.model).transform.InverseTransformPoint(info.HitPositionWorld));
			}
			if (!info.IsProjectile())
			{
				eventRecord.AddField("weapon", (BaseNetworkable)info.Weapon);
				eventRecord.AddField("attacker", (BaseNetworkable)info.Initiator);
			}
			if (info.HitBone != 0)
			{
				eventRecord.AddField("bone", info.HitBone).AddField("bone_name", info.boneName).AddField("hit_area", (int)info.boneArea);
			}
			if (info.ProjectileID != 0)
			{
				eventRecord.AddField("projectile_integrity", info.ProjectileIntegrity).AddField("projectile_hits", info.ProjectileHits).AddField("trajectory_mismatch", info.ProjectileTrajectoryMismatch)
					.AddField("travel_time", info.ProjectileTravelTime)
					.AddField("projectile_velocity", info.ProjectileVelocity)
					.AddField("projectile_prefab", ((Object)info.ProjectilePrefab).name);
			}
			if ((Object)(object)initiatorPlayer != (Object)null && !info.IsProjectile())
			{
				eventRecord.AddField("attacker_eye_pos", initiatorPlayer.eyes.position);
				eventRecord.AddField("attacker_eye_dir", initiatorPlayer.eyes.BodyForward());
				if (((object)initiatorPlayer).GetType() == typeof(BasePlayer))
				{
					eventRecord.AddField("attacker_life", initiatorPlayer.respawnId);
				}
			}
			else if ((Object)(object)initiatorPlayer != (Object)null)
			{
				eventRecord.AddObject("attacker_worn", initiatorPlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddObject("attacker_hotbar", initiatorPlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
			}
			if ((Object)(object)basePlayer != (Object)null)
			{
				eventRecord.AddField("victim_life", basePlayer.respawnId);
				eventRecord.AddObject("victim_worn", basePlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddObject("victim_hotbar", basePlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddField("victim_view_dir", basePlayer.tickViewAngles);
				eventRecord.AddField("victim_eye_pos", basePlayer.eyes.position);
				eventRecord.AddField("victim_eye_dir", basePlayer.eyes.BodyForward());
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerRespawned(BasePlayer player, BaseEntity targetEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_respawn").AddField("player", (BaseNetworkable)player).AddField("bag", (BaseNetworkable)targetEntity)
				.AddField("life_id", player.respawnId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExplosiveLaunched(BasePlayer player, BaseEntity explosive, BaseEntity launcher = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("explosive_launch").AddField("player", (BaseNetworkable)player).AddField("explosive", (BaseNetworkable)explosive)
				.AddField("explosive_velocity", explosive.GetWorldVelocity());
			Vector3 worldVelocity = explosive.GetWorldVelocity();
			EventRecord eventRecord2 = eventRecord.AddField("explosive_direction", ((Vector3)(ref worldVelocity)).normalized);
			if ((Object)(object)launcher != (Object)null)
			{
				eventRecord2.AddField("launcher", (BaseNetworkable)launcher);
			}
			SubmitPoint(eventRecord2);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExplosion(TimedExplosive explosive)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("explosion").AddField("entity", (BaseNetworkable)explosive));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemDespawn(BaseEntity itemContainer, Item item, int dropReason, ulong userId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("item_despawn").AddField("entity", (BaseNetworkable)itemContainer).AddField("item", item)
				.AddField("drop_reason", dropReason);
			if (userId != 0L)
			{
				eventRecord.AddField("player_userid", userId);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemDropped(BasePlayer player, WorldItem entity, DroppedItem.DropReasonEnum dropReason)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_drop").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("item", entity.GetItem())
				.AddField("drop_reason", (int)dropReason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemPickup(BasePlayer player, WorldItem entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("item", entity.GetItem()));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerConnected(Connection connection)
	{
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
			SubmitPoint(EventRecord.New("player_connect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
				.AddField("username", connection.username)
				.AddField("ip", connection.ipaddress));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerDisconnected(Connection connection, string reason)
	{
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
			SubmitPoint(EventRecord.New("player_disconnect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
				.AddField("username", connection.username)
				.AddField("reason", reason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityPickedUp(BasePlayer player, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnChatMessage(BasePlayer player, string message, int channel)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("chat").AddField("player", (BaseNetworkable)player).AddField("message", message)
				.AddField("channel", channel));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnVendingMachineOrderChanged(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, bool added)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
			SubmitPoint(EventRecord.New("vending_changed").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
				.AddField("sell_item", itemDefinition.shortname)
				.AddField("sell_amount", sellAmount)
				.AddField("buy_item", itemDefinition2.shortname)
				.AddField("buy_amount", buyAmount)
				.AddField("is_selling_bp", sellingBp)
				.AddField("is_buying_bp", buyingBp)
				.AddField("change", added ? "added" : "removed"));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuyFromVendingMachine(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, int numberOfTransactions, float discount, BaseEntity drone = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
			SubmitPoint(EventRecord.New("vending_sale").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
				.AddField("sell_item", itemDefinition.shortname)
				.AddField("sell_amount", sellAmount)
				.AddField("buy_item", itemDefinition2.shortname)
				.AddField("buy_amount", buyAmount)
				.AddField("transactions", numberOfTransactions)
				.AddField("is_selling_bp", sellingBp)
				.AddField("is_buying_bp", buyingBp)
				.AddField("drone_terminal", (BaseNetworkable)drone)
				.AddField("discount", discount));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnNPCVendor(BasePlayer player, NPCTalking vendor, int scrapCost, string action)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("npc_vendor").AddField("player", (BaseNetworkable)player).AddField("vendor", (BaseNetworkable)vendor)
				.AddField("scrap_amount", scrapCost)
				.AddField("action", action));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void LogItemsLooted(BasePlayer looter, BaseEntity entity, ItemContainer container, AttackEntity tool = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)entity == (Object)null || container == null)
			{
				return;
			}
			foreach (Item item in container.itemList)
			{
				if (item != null)
				{
					string shortname = item.info.shortname;
					int amount = item.amount;
					ulong steamId = looter?.userID ?? ((EncryptedValue<ulong>)0uL);
					LogResource(ResourceMode.Produced, "loot", shortname, amount, entity, tool, safezone: false, null, steamId);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void LogResource(ResourceMode mode, string category, string itemName, int amount, BaseEntity sourceEntity = null, AttackEntity tool = null, bool safezone = false, BaseEntity workbench = null, ulong steamId = 0uL, string sourceEntityPrefab = null, Item sourceItem = null, string targetItem = null)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("item_event").AddField("item_mode", mode.ToString()).AddField("category", category)
				.AddField("item_name", itemName)
				.AddField("amount", amount);
			if ((Object)(object)sourceEntity != (Object)null)
			{
				eventRecord.AddField("entity", (BaseNetworkable)sourceEntity);
				string biome = GetBiome(((Component)sourceEntity).transform.position);
				if (biome != null)
				{
					eventRecord.AddField("biome", biome);
				}
				if (IsOcean(((Component)sourceEntity).transform.position))
				{
					eventRecord.AddField("ocean", value: true);
				}
				string monument = GetMonument(sourceEntity);
				if (monument != null)
				{
					eventRecord.AddField("monument", monument);
				}
			}
			if (sourceEntityPrefab != null)
			{
				eventRecord.AddField("entity_prefab", sourceEntityPrefab);
			}
			if ((Object)(object)tool != (Object)null)
			{
				eventRecord.AddField("tool", (BaseNetworkable)tool);
			}
			if (safezone)
			{
				eventRecord.AddField("safezone", value: true);
			}
			if ((Object)(object)workbench != (Object)null)
			{
				eventRecord.AddField("workbench", (BaseNetworkable)workbench);
			}
			if (sourceEntity is GrowableEntity plant)
			{
				eventRecord.AddField("genes", GetGenesAsString(plant));
			}
			if (sourceItem != null)
			{
				eventRecord.AddField("source_item", sourceItem.info.shortname);
			}
			if (targetItem != null)
			{
				eventRecord.AddField("target_item", targetItem);
			}
			if (steamId != 0L)
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(steamId);
				eventRecord.AddField("player_userid", userWipeId);
				eventRecord.AddField("player_steamid", steamId);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSkinChanged(BasePlayer player, RepairBench repairBench, Item item, ulong workshopId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
				.AddField("item", item)
				.AddField("new_skin", workshopId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntitySkinChanged(BasePlayer player, BaseNetworkable entity, int newSkin)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", entity)
				.AddField("new_skin", newSkin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemRepaired(BasePlayer player, BaseEntity repairBench, Item itemToRepair, float conditionBefore, float maxConditionBefore)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
				.AddField("item", itemToRepair)
				.AddField("old_condition", conditionBefore)
				.AddField("old_max_condition", maxConditionBefore)
				.AddField("max_condition", itemToRepair.maxConditionNormalized));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityRepaired(BasePlayer player, BaseEntity entity, float healthBefore, float healthAfter)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("healing", healthAfter - healthBefore)
				.AddField("health_before", healthBefore)
				.AddField("health_after", healthAfter));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockUpgraded(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade, uint targetColor, ulong targetSkin)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("block_upgrade").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock)
				.AddField("old_grade", (int)buildingBlock.grade)
				.AddField("new_grade", (int)targetGrade)
				.AddField("color", targetColor)
				.AddField("biome", GetBiome(((Component)buildingBlock).transform.position))
				.AddField("skin_old", buildingBlock.skinID)
				.AddField("skin", targetSkin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockDemolished(BasePlayer player, StabilityEntity buildingBlock)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("block_demolish").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerInitializedWipeId(ulong userId, string wipeId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_wipe_id_set").AddField("user_id", userId).AddField("player_wipe_id", wipeId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFreeUnderwaterCrate(BasePlayer player, FreeableLootContainer freeableLootContainer)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("crate_untied").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)freeableLootContainer));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnVehiclePurchased(BasePlayer player, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("vehicle_purchase").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vehicle)
				.AddField("price", (BaseNetworkable)vehicle));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMissionComplete(BasePlayer player, BaseMission mission, BaseMission.MissionFailReason? failReason = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("mission_complete").AddField("player", (BaseNetworkable)player).AddField("mission", mission.shortname);
			if (failReason.HasValue)
			{
				eventRecord.AddField("mission_succeed", value: false).AddField("fail_reason", failReason.Value.ToString());
			}
			else
			{
				eventRecord.AddField("mission_succeed", value: true);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnGamblingResult(BasePlayer player, BaseEntity entity, int scrapPaid, int scrapRecieved, Guid? gambleGroupId = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("gambing").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("scrap_input", scrapPaid)
				.AddField("scrap_output", scrapRecieved);
			if (gambleGroupId.HasValue)
			{
				eventRecord.AddField("gamble_grouping", gambleGroupId.Value);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerPinged(BasePlayer player, BasePlayer.PingType type, bool wasViaWheel)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("pingType", (int)type)
				.AddField("viaWheel", wasViaWheel));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBagUnclaimed(BasePlayer player, SleepingBag bag)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("bag_unclaim").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)bag));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSteamAuth(ulong userId, ulong ownerUserId, string authResponse)
	{
		try
		{
			SubmitPoint(EventRecord.New("steam_auth").AddField("user", userId).AddField("owner", ownerUserId)
				.AddField("response", authResponse)
				.AddField("server_port", Net.sv.port)
				.AddField("network_mode", Net.sv.ProtocolId)
				.AddField("player_count", BasePlayer.activePlayerList.Count)
				.AddField("max_players", ConVar.Server.maxplayers)
				.AddField("hostname", ConVar.Server.hostname)
				.AddField("secure", Net.sv.secure));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockColorChanged(BasePlayer player, BuildingBlock block, uint oldColor, uint newColor)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)block)
				.AddField("color_old", oldColor)
				.AddField("color_new", newColor)
				.AddField("biome", GetBiome(((Component)block).transform.position)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBurstModeToggled(BasePlayer player, BaseProjectile gun, bool state)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("burst_toggle").AddField("player", (BaseNetworkable)player).AddField("weapon", (BaseNetworkable)gun)
				.AddField("enabled", state));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnParachuteUsed(BasePlayer player, float distanceTravelled, float deployHeight, float timeInAir)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("parachute_used").AddField("player", (BaseNetworkable)player).AddField("distanceTravelled", distanceTravelled)
				.AddField("deployHeight", deployHeight)
				.AddField("timeInAir", timeInAir));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialStarted(BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_started").AddField("player", (BaseNetworkable)player));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialCompleted(BasePlayer player, float timeElapsed)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_completed").AddField("player", (BaseNetworkable)player).AddLegacyTimespan("duration", TimeSpan.FromSeconds(timeElapsed)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialQuit(BasePlayer player, string activeMissionName)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_quit").AddField("player", (BaseNetworkable)player).AddField("activeMissionName", activeMissionName));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBaseInteract(BasePlayer player, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("base_interaction").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerDeath(BasePlayer player, BasePlayer killer)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_death").AddField("player", (BaseNetworkable)player).AddField("killer", (BaseNetworkable)killer));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCarShredded(MagnetLiftable car, List<Item> produced)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("car_shredded").AddField("player", (BaseNetworkable)car.associatedPlayer).AddField("car", (BaseNetworkable)car.GetBaseEntity());
			foreach (Item item in produced)
			{
				eventRecord.AddField("item_" + item.info.shortname, item);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerTick(BasePlayer player, in BasePlayer.CachedState tickState)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		if (GameplayTickAnalyticsConVar)
		{
			if (TickLogging.tickUploader.NeedsCreation())
			{
				BuildInfo current = BuildInfo.Current;
				bool num = (current.Scm.Branch != null && current.Scm.Branch == "experimental/release") || current.Scm.Branch == "release";
				bool isEditor = Application.isEditor;
				string text = ((num && !isEditor) ? "release" : (isEditor ? "editor" : "staging"));
				TickLogging.tickUploader = AzureAnalyticsUploader.Create("player_ticks_" + text, TimeSpan.FromSeconds(TickLogging.tick_uploader_lifetime), AnalyticsDocumentMode.CSV);
			}
			TickLogging.tickUploader.Append(EventRecord.New("player_tick").AddField("player_steamid", player.UserIDString).AddField("modelstate", (player.modelStateTick ?? player.modelState).flags)
				.AddField("heldentity", ((Object)(object)player.GetHeldEntity() != (Object)null) ? player.GetHeldEntity().ShortPrefabName : "")
				.AddField("pitch", player.tickViewAngles.x)
				.AddField("yaw", player.tickViewAngles.y)
				.AddField("pos_x", ((Component)player).transform.position.x)
				.AddField("pos_y", ((Component)player).transform.position.y)
				.AddField("pos_z", ((Component)player).transform.position.z)
				.AddField("eye_pos_x", player.eyes.position.x)
				.AddField("eye_pos_y", player.eyes.position.y)
				.AddField("eye_pos_z", player.eyes.position.z)
				.AddField("mouse_delta_x", player.tickMouseDelta.x)
				.AddField("mouse_delta_y", player.tickMouseDelta.y)
				.AddField("mouse_delta_z", player.tickMouseDelta.z)
				.AddField("parented", player.HasParent())
				.AddField("mounted", player.isMounted)
				.AddField("admin", player.IsAdmin || player.IsDeveloper)
				.AddField("water_factor", tickState.WaterFactor)
				.AddField("Timestamp", DateTime.UtcNow));
		}
	}

	public static void OnWallpaperPlaced(BasePlayer player, BuildingBlock buildingBlock, ulong skinID, int side, bool reskin)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("wallpaper_placed").AddField("player", (BaseNetworkable)player).AddField("buildingBlock", (BaseNetworkable)buildingBlock)
				.AddField("skin", skinID)
				.AddField("side", side)
				.AddField("reskin", reskin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStartFish(BasePlayer player, Item lure, Vector3 targetPos)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_start").AddField("player", (BaseNetworkable)player).AddField("lure", lure)
				.AddField("target_pos", targetPos));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFailedFish(BasePlayer player, BaseFishingRod.FailReason reason)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_failed").AddField("player", (BaseNetworkable)player).AddField("fail_reason", (int)reason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCaughtFish(BasePlayer player, Item item)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_caught").AddField("player", (BaseNetworkable)player).AddField("item", item));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerChangeInjureState(BasePlayer player, BasePlayer.InjureState oldState, BasePlayer.InjureState newState)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("injure_state").AddField("player", (BaseNetworkable)player).AddField("old_state", (int)oldState)
				.AddField("new_state", (int)newState));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerLifeStoryEnd(BasePlayer player, PlayerLifeStory lifeStory)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("life_story_end").AddField("player", (BaseNetworkable)player).AddField("time_born", lifeStory.timeBorn)
				.AddField("time_died", lifeStory.timeDied)
				.AddField("meters_walked", lifeStory.metersWalked)
				.AddField("meters_ran", lifeStory.metersRun)
				.AddField("seconds_alive", lifeStory.secondsAlive)
				.AddField("seconds_in_base", lifeStory.secondsInBase)
				.AddField("seconds_in_wilderness", lifeStory.secondsWilderness)
				.AddField("seconds_in_monument", lifeStory.secondsInMonument)
				.AddField("seconds_driving", lifeStory.secondsDriving)
				.AddField("seconds_flying", lifeStory.secondsFlying)
				.AddField("seconds_boating", lifeStory.secondsBoating)
				.AddField("seconds_sleeping", lifeStory.secondsSleeping)
				.AddField("seconds_swimming", lifeStory.secondsSwimming)
				.AddField("total_damage_taken", lifeStory.totalDamageTaken)
				.AddField("total_healed", lifeStory.totalHealing)
				.AddField("killed_players", lifeStory.killedPlayers)
				.AddField("killed_animals", lifeStory.killedAnimals)
				.AddField("killed_scientists", lifeStory.killedScientists)
				.AddObject("death_info", lifeStory.deathInfo)
				.AddObject("weapon_stats", lifeStory.weaponStats));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnServerRPC(BasePlayer player, uint nameID, byte[] data, int length)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("server_rpc").AddField("player", (BaseNetworkable)player).AddField("rpc", StringPool.Get(nameID))
				.AddField("data", data)
				.AddField("length", length));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static string GetGenesAsString(GrowableEntity plant)
	{
		int key = GrowableGeneEncoding.EncodeGenesToInt(plant.Genes);
		if (!geneCache.TryGetValue(key, out var value))
		{
			return string.Join("", from x in plant.Genes.Genes
				group x by x.GetDisplayCharacter() into x
				orderby x.Key
				select x.Count() + x.Key);
		}
		return value;
	}

	private static string GetMonument(BaseEntity entity)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return null;
		}
		SpawnGroup spawnGroup = null;
		if (entity is BaseCorpse baseCorpse)
		{
			spawnGroup = baseCorpse.spawnGroup;
		}
		if ((Object)(object)spawnGroup == (Object)null)
		{
			SpawnPointInstance component = ((Component)entity).GetComponent<SpawnPointInstance>();
			if ((Object)(object)component != (Object)null)
			{
				spawnGroup = component.parentSpawnPointUser as SpawnGroup;
			}
		}
		if ((Object)(object)spawnGroup != (Object)null)
		{
			if (!string.IsNullOrEmpty(spawnGroup.category))
			{
				return spawnGroup.category;
			}
			if ((Object)(object)spawnGroup.Monument != (Object)null)
			{
				return ((Object)spawnGroup.Monument).name;
			}
		}
		MonumentInfo monumentInfo = TerrainMeta.Path.FindMonumentWithBoundsOverlap(((Component)entity).transform.position);
		if ((Object)(object)monumentInfo != (Object)null)
		{
			return ((Object)monumentInfo).name;
		}
		return null;
	}

	private static string GetBiome(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected I4, but got Unknown
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Invalid comparison between Unknown and I4
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Invalid comparison between Unknown and I4
		string result = null;
		Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
		switch (val - 1)
		{
		default:
			if ((int)val != 8)
			{
				if ((int)val == 16)
				{
					result = "jungle";
				}
			}
			else
			{
				result = "arctic";
			}
			break;
		case 0:
			result = "arid";
			break;
		case 1:
			result = "grass";
			break;
		case 3:
			result = "tundra";
			break;
		case 2:
			break;
		}
		return result;
	}

	private static bool IsOcean(Vector3 position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.TopologyMap.GetTopology(position) == 128;
	}

	private static IEnumerator AggregateLoop()
	{
		int loop = 0;
		while (!Application.isQuitting)
		{
			yield return CoroutineEx.waitForSecondsRealtime(60f);
			if (GameplayAnalytics)
			{
				yield return TryCatch(AggregatePlayers(blueprints: false, positions: true));
				if (loop % 60 == 0)
				{
					PushServerInfo();
					yield return TryCatch(AggregateEntitiesAndItems());
					yield return TryCatch(AggregatePlayers(blueprints: true));
					yield return TryCatch(AggregateTeams());
					Dictionary<PendingItemsKey, PendingItemsData> dict = pendingItems;
					pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();
					yield return PushPendingItemsLoopAsync(dict);
				}
				loop++;
			}
		}
	}

	private static IEnumerator TryCatch(IEnumerator coroutine)
	{
		while (true)
		{
			try
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				break;
			}
			yield return coroutine.Current;
		}
	}

	private static IEnumerator AggregateEntitiesAndItems()
	{
		List<BaseNetworkable> entityQueue = new List<BaseNetworkable>();
		entityQueue.Clear();
		int totalCount = BaseNetworkable.serverEntities.Count;
		entityQueue.AddRange(BaseNetworkable.serverEntities);
		Dictionary<string, int> itemDict = new Dictionary<string, int>();
		Dictionary<EntityKey, int> entityDict = new Dictionary<EntityKey, int>();
		yield return null;
		Debug.Log((object)"Starting to aggregate entities & items...");
		DateTime startTime = DateTime.UtcNow;
		Stopwatch watch = Stopwatch.StartNew();
		foreach (BaseNetworkable entity in entityQueue)
		{
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
			if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
			{
				continue;
			}
			EntityKey entityKey = default(EntityKey);
			entityKey.PrefabId = entity.prefabID;
			EntityKey key = entityKey;
			if (entity is BuildingBlock buildingBlock)
			{
				key.Grade = (int)(buildingBlock.grade + 1);
			}
			entityDict.TryGetValue(key, out var value);
			entityDict[key] = value + 1;
			if (!(entity is LootContainer) && !(entity is BasePlayer { IsNpc: not false }) && !(entity is NPCPlayer))
			{
				if (entity is BasePlayer basePlayer2)
				{
					AddItemsToDict(basePlayer2.inventory.containerMain, itemDict);
					AddItemsToDict(basePlayer2.inventory.containerBelt, itemDict);
					AddItemsToDict(basePlayer2.inventory.containerWear, itemDict);
				}
				else if (entity is IItemContainerEntity itemContainerEntity)
				{
					AddItemsToDict(itemContainerEntity.inventory, itemDict);
				}
				else if (entity is DroppedItemContainer { inventory: not null } droppedItemContainer)
				{
					AddItemsToDict(droppedItemContainer.inventory, itemDict);
				}
			}
		}
		Debug.Log((object)$"Took {Math.Round(DateTime.UtcNow.Subtract(startTime).TotalSeconds, 1)}s to aggregate {totalCount} entities & items...");
		_ = DateTime.UtcNow;
		SubmitPoint(EventRecord.New("entity_sum").AddObject("counts", entityDict.Select(delegate(KeyValuePair<EntityKey, int> x)
		{
			EntitySumItem result = default(EntitySumItem);
			result.PrefabId = x.Key.PrefabId;
			result.Grade = x.Key.Grade;
			result.Count = x.Value;
			return result;
		})));
		yield return null;
		SubmitPoint(EventRecord.New("item_sum").AddObject("counts", itemDict));
		yield return null;
	}

	private static void AddItemsToDict(ItemContainer container, Dictionary<string, int> dict)
	{
		if (container == null || container.itemList == null)
		{
			return;
		}
		foreach (Item item in container.itemList)
		{
			string shortname = item.info.shortname;
			dict.TryGetValue(shortname, out var value);
			dict[shortname] = value + item.amount;
			if (item.contents != null)
			{
				AddItemsToDict(item.contents, dict);
			}
		}
	}

	private static IEnumerator PushPendingItemsLoopAsync(Dictionary<PendingItemsKey, PendingItemsData> dict)
	{
		Stopwatch watch = Stopwatch.StartNew();
		foreach (PendingItemsData value in dict.Values)
		{
			try
			{
				LogResource(value.Key.Consumed ? ResourceMode.Consumed : ResourceMode.Produced, value.category, value.Key.Item, value.amount, null, null, safezone: false, null, 0uL, value.Key.Entity);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			PendingItemsData pendingItemsData = value;
			Pool.Free<PendingItemsData>(ref pendingItemsData);
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		dict.Clear();
	}

	public static void AddPendingItems(BaseEntity entity, string itemName, int amount, string category, bool consumed = true, bool perEntity = false)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		PendingItemsKey pendingItemsKey = default(PendingItemsKey);
		pendingItemsKey.Entity = entity.ShortPrefabName;
		pendingItemsKey.Category = category;
		pendingItemsKey.Item = itemName;
		pendingItemsKey.Consumed = consumed;
		pendingItemsKey.EntityId = (NetworkableId)(perEntity ? entity.net.ID : default(NetworkableId));
		PendingItemsKey key = pendingItemsKey;
		if (!pendingItems.TryGetValue(key, out var value))
		{
			value = Pool.Get<PendingItemsData>();
			value.Key = key;
			value.category = category;
			pendingItems[key] = value;
		}
		value.amount += amount;
	}

	private static IEnumerator AggregatePlayers(bool blueprints = false, bool positions = false)
	{
		Stopwatch watch = Stopwatch.StartNew();
		Dictionary<int, int> playerBps = (blueprints ? new Dictionary<int, int>() : null);
		List<PlayerAggregate> playerPositions = (positions ? Pool.Get<List<PlayerAggregate>>() : null);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((Object)(object)current == (Object)null || current.IsDestroyed)
				{
					continue;
				}
				if (blueprints)
				{
					foreach (int unlockedItem in current.PersistantPlayerInfo.unlockedItems)
					{
						playerBps.TryGetValue(unlockedItem, out var value);
						playerBps[unlockedItem] = value + 1;
					}
				}
				if (positions)
				{
					PlayerAggregate playerAggregate = Pool.Get<PlayerAggregate>();
					playerAggregate.UserId = current.UserIDString;
					playerAggregate.Position = ((Component)current).transform.position;
					Quaternion bodyRotation = current.eyes.bodyRotation;
					playerAggregate.Direction = ((Quaternion)(ref bodyRotation)).eulerAngles;
					foreach (Item item in current.inventory.containerBelt.itemList)
					{
						playerAggregate.Hotbar.Add(item.info.shortname);
					}
					foreach (Item item2 in current.inventory.containerWear.itemList)
					{
						playerAggregate.Worn.Add(item2.info.shortname);
					}
					playerAggregate.ActiveItem = current.GetActiveItem()?.info.shortname;
					playerAggregate.Biome = GetBiome(((Component)current).transform.position);
					playerPositions.Add(playerAggregate);
				}
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (blueprints)
		{
			SubmitPoint(EventRecord.New("blueprint_aggregate_online").AddObject("blueprints", playerBps.Select((KeyValuePair<int, int> x) => new
			{
				Key = ItemManager.FindItemDefinition(x.Key).shortname,
				value = x.Value
			})));
		}
		if (positions)
		{
			SubmitPoint(EventRecord.New("player_positions").AddObject("positions", playerPositions).AddObject("player_count", playerPositions.Count));
			Pool.Free<PlayerAggregate>(ref playerPositions, true);
		}
	}

	private static IEnumerator AggregateTeams()
	{
		yield return null;
		HashSet<ulong> teamIds = new HashSet<ulong>();
		int inTeam = 0;
		int notInTeam = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((Object)(object)current != (Object)null && !current.IsDestroyed && current.currentTeam != 0L)
				{
					teamIds.Add(current.currentTeam);
					inTeam++;
				}
				else
				{
					notInTeam++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		yield return null;
		Stopwatch watch = Stopwatch.StartNew();
		List<TeamInfo> teams = Pool.Get<List<TeamInfo>>();
		foreach (ulong item in teamIds)
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(item);
			if (playerTeam == null || !((playerTeam.members != null) & (playerTeam.members.Count > 0)))
			{
				continue;
			}
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			teams.Add(teamInfo);
			foreach (ulong member in playerTeam.members)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed && basePlayer.IsConnected && !basePlayer.IsSleeping())
				{
					teamInfo.online.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
				else
				{
					teamInfo.offline.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
			}
			teamInfo.member_count = teamInfo.online.Count + teamInfo.offline.Count;
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		SubmitPoint(EventRecord.New("online_teams").AddObject("teams", teams).AddField("users_in_team", inTeam)
			.AddField("users_not_in_team", notInTeam));
		foreach (TeamInfo item2 in teams)
		{
			TeamInfo current4 = item2;
			Pool.Free<TeamInfo>(ref current4);
		}
		Pool.Free<TeamInfo>(ref teams, false);
	}
}


public enum ResourceMode
{
	Produced,
	Consumed
}


private static class EventIds
{
	public const string EntityBuilt = "entity_built";

	public const string EntityPickup = "entity_pickup";

	public const string EntityDamage = "entity_damage";

	public const string PlayerRespawn = "player_respawn";

	public const string ExplosiveLaunched = "explosive_launch";

	public const string Explosion = "explosion";

	public const string ItemEvent = "item_event";

	public const string EntitySum = "entity_sum";

	public const string ItemSum = "item_sum";

	public const string ItemDespawn = "item_despawn";

	public const string ItemDropped = "item_drop";

	public const string ItemPickup = "item_pickup";

	public const string AntihackViolation = "antihack_violation";

	public const string AntihackViolationDetailed = "antihack_violation_detailed";

	public const string PlayerConnect = "player_connect";

	public const string PlayerDisconnect = "player_disconnect";

	public const string ConsumableUsed = "consumeable_used";

	public const string MedUsed = "med_used";

	public const string ResearchStarted = "research_start";

	public const string BlueprintLearned = "blueprint_learned";

	public const string TeamChanged = "team_change";

	public const string EntityAuthChange = "auth_change";

	public const string VendingOrderChanged = "vending_changed";

	public const string VendingSale = "vending_sale";

	public const string ChatMessage = "chat";

	public const string BlockUpgrade = "block_upgrade";

	public const string BlockDemolish = "block_demolish";

	public const string ItemRepair = "item_repair";

	public const string EntityRepair = "entity_repair";

	public const string ItemSkinned = "item_skinned";

	public const string EntitySkinned = "entity_skinned";

	public const string ItemAggregate = "item_aggregate";

	public const string CodelockChanged = "code_change";

	public const string CodelockEntered = "code_enter";

	public const string SleepingBagAssign = "sleeping_bag_assign";

	public const string FallDamage = "fall_damage";

	public const string PlayerWipeIdSet = "player_wipe_id_set";

	public const string ServerInfo = "server_info";

	public const string UnderwaterCrateUntied = "crate_untied";

	public const string VehiclePurchased = "vehicle_purchase";

	public const string NPCVendor = "npc_vendor";

	public const string BlueprintsOnline = "blueprint_aggregate_online";

	public const string PlayerPositions = "player_positions";

	public const string ProjectileInvalid = "projectile_invalid";

	public const string ItemDefinitions = "item_definitions";

	public const string KeycardSwiped = "keycard_swiped";

	public const string EntitySpawned = "entity_spawned";

	public const string EntityKilled = "entity_killed";

	public const string HackableCrateStarted = "hackable_crate_started";

	public const string HackableCrateEnded = "hackable_crate_ended";

	public const string StashHidden = "stash_hidden";

	public const string StashRevealed = "stash_reveal";

	public const string EntityManifest = "entity_manifest";

	public const string LootEntity = "loot_entity";

	public const string OnlineTeams = "online_teams";

	public const string Gambling = "gambing";

	public const string BuildingBlockColor = "building_block_color";

	public const string MissionComplete = "mission_complete";

	public const string PlayerPinged = "player_pinged";

	public const string BagUnclaim = "bag_unclaim";

	public const string SteamAuth = "steam_auth";

	public const string ParachuteUsed = "parachute_used";

	public const string MountEntity = "mount";

	public const string DismountEntity = "dismount";

	public const string BurstToggle = "burst_toggle";

	public const string TutorialStarted = "tutorial_started";

	public const string TutorialCompleted = "tutorial_completed";

	public const string TutorialQuit = "tutorial_quit";

	public const string BaseInteraction = "base_interaction";

	public const string PlayerDeath = "player_death";

	public const string CarShredded = "car_shredded";

	public const string PlayerTick = "player_tick";

	public const string WallpaperPlaced = "wallpaper_placed";

	public const string StartFish = "fishing_start";

	public const string FailedFish = "fishing_failed";

	public const string CaughtFish = "fishing_caught";

	public const string InjureStateChange = "injure_state";

	public const string LifeStoryEnd = "life_story_end";

	public const string ServerRPC = "server_rpc";
}


private struct SimpleItemAmount
{
	public string ItemName;

	public int Amount;

	public ulong Skin;

	public float Condition;

	public SimpleItemAmount(Item item)
	{
		ItemName = item.info.shortname;
		Amount = item.amount;
		Skin = item.skin;
		Condition = item.conditionNormalized;
	}
}


using System;

private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
{
	public ulong UserId;

	public int ProjectileId;

	public FiredProjectileKey(ulong userId, int projectileId)
	{
		UserId = userId;
		ProjectileId = projectileId;
	}

	public bool Equals(FiredProjectileKey other)
	{
		if (other.UserId == UserId)
		{
			return other.ProjectileId == ProjectileId;
		}
		return false;
	}
}


private class PendingFiredProjectile : IPooled
{
	public EventRecord Record;

	public BasePlayer.FiredProjectile FiredProjectile;

	public bool Hit;

	public void EnterPool()
	{
		Hit = false;
		Record = null;
		FiredProjectile = null;
	}

	public void LeavePool()
	{
	}
}


[JsonModel]
private struct EntitySumItem
{
	public uint PrefabId;

	public int Count;

	public int Grade;
}


using System;

private struct EntityKey : IEquatable<EntityKey>
{
	public uint PrefabId;

	public int Grade;

	public bool Equals(EntityKey other)
	{
		if (PrefabId == other.PrefabId)
		{
			return Grade == other.Grade;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
	}
}


private class PendingItemsData : IPooled
{
	public PendingItemsKey Key;

	public int amount;

	public string category;

	public void EnterPool()
	{
		Key = default(PendingItemsKey);
		amount = 0;
		category = null;
	}

	public void LeavePool()
	{
	}
}


using System;

private struct PendingItemsKey : IEquatable<PendingItemsKey>
{
	public string Item;

	public bool Consumed;

	public string Entity;

	public string Category;

	public NetworkableId EntityId;

	public bool Equals(PendingItemsKey other)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
		{
			return Category == other.Category;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
	}
}


using System.Collections.Generic;
using UnityEngine;

[JsonModel]
private class PlayerAggregate : IPooled
{
	public string UserId;

	public Vector3 Position;

	public Vector3 Direction;

	public List<string> Hotbar = new List<string>();

	public List<string> Worn = new List<string>();

	public string ActiveItem;

	public string Biome;

	public void EnterPool()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		UserId = null;
		Position = default(Vector3);
		Direction = default(Vector3);
		Hotbar.Clear();
		Worn.Clear();
		ActiveItem = null;
		Biome = null;
	}

	public void LeavePool()
	{
	}
}


using System.Collections.Generic;

[JsonModel]
private class TeamInfo : IPooled
{
	public List<string> online = new List<string>();

	public List<string> offline = new List<string>();

	public int member_count;

	public void EnterPool()
	{
		online.Clear();
		offline.Clear();
		member_count = 0;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using Cysharp.Text;
using Network;
using Rust;
using Steamworks;
using UnityEngine;

public class AzureWebInterface
{
	public static readonly AzureWebInterface client = new AzureWebInterface(isClient: true);

	public static readonly AzureWebInterface server = new AzureWebInterface(isClient: false);

	private AzureAnalyticsUploader GameplayBulkUploader;

	public bool IsClient;

	public int MaxRetries = 1;

	public int FlushSize = 1000;

	public TimeSpan FlushDelay = TimeSpan.FromSeconds(30.0);

	private DateTime nextFlush;

	private ConcurrentQueue<EventRecord> uploadQueue = new ConcurrentQueue<EventRecord>();

	private HttpClient HttpClient = new HttpClient();

	private static readonly MediaTypeHeaderValue JsonContentType = new MediaTypeHeaderValue("application/json")
	{
		CharSet = Encoding.UTF8.WebName
	};

	public int PendingCount => uploadQueue.Count;

	public AzureWebInterface(bool isClient)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		IsClient = isClient;
		Task.Run((Func<Task?>)UploadSchedulingThread);
	}

	public void EnqueueEvent(EventRecord point)
	{
		if (!IsClient && !string.IsNullOrEmpty(GetContainerUrl()))
		{
			if (GameplayBulkUploader.NeedsCreation())
			{
				GameplayBulkUploader = AzureAnalyticsUploader.Create("gameplay_events", TimeSpan.FromMinutes(5.0));
				GameplayBulkUploader.UseJsonDataObject = true;
			}
			GameplayBulkUploader.Append(point);
		}
		else
		{
			point.MarkSubmitted();
			uploadQueue.Enqueue(point);
		}
	}

	private async Task UploadSchedulingThread()
	{
		while (!Application.isQuitting)
		{
			try
			{
				DateTime utcNow = DateTime.UtcNow;
				if (uploadQueue.IsEmpty || (uploadQueue.Count < FlushSize && nextFlush > utcNow))
				{
					await Task.Delay(1000);
					continue;
				}
				nextFlush = utcNow.Add(FlushDelay);
				List<EventRecord> list = Pool.Get<List<EventRecord>>();
				EventRecord result;
				while (uploadQueue.TryDequeue(out result))
				{
					list.Add(result);
				}
				Task.Run(async delegate
				{
					await UploadAsync(list);
				});
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				await Task.Delay(1000);
			}
		}
	}

	private void SerializeEvents(List<EventRecord> records, MemoryStream stream)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Utf8ValueStringBuilder writer = ZString.CreateUtf8StringBuilder();
		try
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("[");
			foreach (EventRecord record in records)
			{
				if (num > 0)
				{
					((Utf8ValueStringBuilder)(ref writer)).Append(',');
				}
				record.SerializeAsJson(ref writer);
				num++;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("]");
			((Utf8ValueStringBuilder)(ref writer)).WriteTo((Stream)stream);
		}
		finally
		{
			((Utf8ValueStringBuilder)(ref writer)).Dispose();
		}
	}

	private async Task UploadAsync(List<EventRecord> records, bool useStoredAuthTicket = false)
	{
		if (!(IsClient ? (Application.Manifest?.Features?.ClientAnalytics == true) : (Application.Manifest?.Features?.ServerAnalytics == true)))
		{
			Pool.Free<EventRecord>(ref records, true);
			return;
		}
		if (records.Count == 0)
		{
			Pool.Free<EventRecord>(ref records, false);
			return;
		}
		MemoryStream stream = Pool.Get<MemoryStream>();
		stream.Position = 0L;
		stream.SetLength(0L);
		try
		{
			SerializeEvents(records, stream);
			AuthTicket ticket = null;
			for (int attempt = 0; attempt < MaxRetries; attempt++)
			{
				try
				{
					ByteArrayContent content = new ByteArrayContent(stream.GetBuffer(), 0, (int)stream.Length);
					try
					{
						((HttpContent)content).Headers.ContentType = JsonContentType;
						if (!string.IsNullOrEmpty(AnalyticsSecret))
						{
							((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsSecret);
						}
						else
						{
							((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsPublicKey);
						}
						if (!IsClient)
						{
							((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-IP", Net.sv.ip);
							((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-PORT", Net.sv.port.ToString());
						}
						(await HttpClient.PostAsync(IsClient ? ClientAnalyticsUrl : ServerAnalyticsUrl, (HttpContent)(object)content)).EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)content)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					HttpRequestException val = (HttpRequestException)(object)((ex is HttpRequestException) ? ex : null);
					if (val != null)
					{
						Debug.Log((object)("HTTP Error when uploading analytics: " + ((Exception)(object)val).Message));
					}
					else
					{
						Debug.LogException(ex);
					}
					goto IL_02ae;
				}
				break;
				IL_02ae:
				if (ticket != null)
				{
					try
					{
						ticket.Cancel();
					}
					catch (Exception ex2)
					{
						Debug.LogError((object)("Failed to cancel auth ticket in analytics: " + ex2.ToString()));
					}
				}
			}
		}
		catch (Exception ex3)
		{
			if (IsClient)
			{
				Debug.LogWarning((object)ex3.ToString());
			}
			else
			{
				Debug.LogException(ex3);
			}
		}
		finally
		{
			Pool.Free<EventRecord>(ref records, true);
			Pool.FreeUnmanaged(ref stream);
		}
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Auto)]
private struct <<UploadSchedulingThread>b__0>d : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder <>t__builder;

	public <>c__DisplayClass15_0 <>4__this;

	private TaskAwaiter <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		<>c__DisplayClass15_0 <>c__DisplayClass15_ = <>4__this;
		try
		{
			TaskAwaiter awaiter;
			if (num != 0)
			{
				awaiter = <>c__DisplayClass15_.<>4__this.UploadAsync(<>c__DisplayClass15_.list).GetAwaiter();
				if (!awaiter.IsCompleted)
				{
					num = (<>1__state = 0);
					<>u__1 = awaiter;
					<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
					return;
				}
			}
			else
			{
				awaiter = <>u__1;
				<>u__1 = default(TaskAwaiter);
				num = (<>1__state = -1);
			}
			awaiter.GetResult();
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult();
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		<>t__builder.SetStateMachine(stateMachine);
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}


using Facepunch.Rust;

public static class AzureAnalyticsUploaderEx
{
	public static bool NeedsCreation(this AzureAnalyticsUploader uploader)
	{
		return uploader?.TryFlush() ?? true;
	}
}


public enum AnalyticsDocumentMode
{
	JSON,
	CSV
}


