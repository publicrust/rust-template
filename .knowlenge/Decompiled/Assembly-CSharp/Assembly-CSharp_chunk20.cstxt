using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(MotionBlurRenderer), "Unity/Motion Blur", false)]
public sealed class MotionBlur : PostProcessEffectSettings
{
	[Tooltip("The angle of rotary shutter. Larger values give longer exposure.")]
	[Range(0f, 360f)]
	public FloatParameter shutterAngle = new FloatParameter
	{
		value = 270f
	};

	[Tooltip("The amount of sample points. This affects quality and performance.")]
	[Range(4f, 32f)]
	public IntParameter sampleCount = new IntParameter
	{
		value = 10
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value && shutterAngle.value > 0f && SystemInfo.supportsMotionVectors && ((RenderTextureFormat)13).IsSupported())
		{
			return !RuntimeUtilities.isVREnabled;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class MotionBlurRenderer : PostProcessEffectRenderer<MotionBlur>
{
	private enum Pass
	{
		VelocitySetup,
		TileMax1,
		TileMax2,
		TileMaxV,
		NeighborMax,
		Reconstruction
	}

	public override DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)5;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		if (m_ResetHistory)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			m_ResetHistory = false;
			return;
		}
		RenderTextureFormat val = (RenderTextureFormat)13;
		RenderTextureFormat val2 = (RenderTextureFormat)(((RenderTextureFormat)8).IsSupported() ? 8 : 0);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.motionBlur);
		command.BeginSample("MotionBlur");
		int num = (int)(5f * (float)context.height / 100f);
		int num2 = ((num - 1) / 8 + 1) * 8;
		float num3 = (float)base.settings.shutterAngle / 360f;
		propertySheet.properties.SetFloat(ShaderIDs.VelocityScale, num3);
		propertySheet.properties.SetFloat(ShaderIDs.MaxBlurRadius, (float)num);
		propertySheet.properties.SetFloat(ShaderIDs.RcpMaxBlurRadius, 1f / (float)num);
		int velocityTex = ShaderIDs.VelocityTex;
		command.GetTemporaryRT(velocityTex, context.width, context.height, 0, (FilterMode)0, val2, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit(velocityTex), propertySheet, 0, clear: false, null);
		int tile2RT = ShaderIDs.Tile2RT;
		command.GetTemporaryRT(tile2RT, context.width / 2, context.height / 2, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(velocityTex), RenderTargetIdentifier.op_Implicit(tile2RT), propertySheet, 1, clear: false, null);
		int tile4RT = ShaderIDs.Tile4RT;
		command.GetTemporaryRT(tile4RT, context.width / 4, context.height / 4, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tile2RT), RenderTargetIdentifier.op_Implicit(tile4RT), propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(tile2RT);
		int tile8RT = ShaderIDs.Tile8RT;
		command.GetTemporaryRT(tile8RT, context.width / 8, context.height / 8, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tile4RT), RenderTargetIdentifier.op_Implicit(tile8RT), propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(tile4RT);
		Vector2 val3 = Vector2.one * ((float)num2 / 8f - 1f) * -0.5f;
		propertySheet.properties.SetVector(ShaderIDs.TileMaxOffs, Vector4.op_Implicit(val3));
		propertySheet.properties.SetFloat(ShaderIDs.TileMaxLoop, (float)(int)((float)num2 / 8f));
		int tileVRT = ShaderIDs.TileVRT;
		command.GetTemporaryRT(tileVRT, context.width / num2, context.height / num2, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tile8RT), RenderTargetIdentifier.op_Implicit(tileVRT), propertySheet, 3, clear: false, null);
		command.ReleaseTemporaryRT(tile8RT);
		int neighborMaxTex = ShaderIDs.NeighborMaxTex;
		int num4 = context.width / num2;
		int num5 = context.height / num2;
		command.GetTemporaryRT(neighborMaxTex, num4, num5, 0, (FilterMode)0, val, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(tileVRT), RenderTargetIdentifier.op_Implicit(neighborMaxTex), propertySheet, 4, clear: false, null);
		command.ReleaseTemporaryRT(tileVRT);
		propertySheet.properties.SetFloat(ShaderIDs.LoopCount, (float)Mathf.Clamp((int)base.settings.sampleCount / 2, 1, 64));
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, clear: false, null);
		command.ReleaseTemporaryRT(velocityTex);
		command.ReleaseTemporaryRT(neighborMaxTex);
		command.EndSample("MotionBlur");
	}
}


private enum Pass
{
	VelocitySetup,
	TileMax1,
	TileMax2,
	TileMaxV,
	NeighborMax,
	Reconstruction
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
internal sealed class MultiScaleVO : IAmbientOcclusionMethod
{
	internal enum MipLevel
	{
		Original,
		L1,
		L2,
		L3,
		L4,
		L5,
		L6
	}

	private enum Pass
	{
		DepthCopy,
		CompositionDeferred,
		CompositionForward,
		DebugOverlay
	}

	private readonly float[] m_SampleThickness = new float[12]
	{
		Mathf.Sqrt(0.96f),
		Mathf.Sqrt(0.84f),
		Mathf.Sqrt(0.64f),
		Mathf.Sqrt(0.35999995f),
		Mathf.Sqrt(0.91999996f),
		Mathf.Sqrt(0.79999995f),
		Mathf.Sqrt(0.59999996f),
		Mathf.Sqrt(0.31999993f),
		Mathf.Sqrt(0.67999995f),
		Mathf.Sqrt(0.47999996f),
		Mathf.Sqrt(0.19999993f),
		Mathf.Sqrt(0.27999997f)
	};

	private readonly float[] m_InvThicknessTable = new float[12];

	private readonly float[] m_SampleWeightTable = new float[12];

	private readonly int[] m_Widths = new int[7];

	private readonly int[] m_Heights = new int[7];

	private AmbientOcclusion m_Settings;

	private PropertySheet m_PropertySheet;

	private PostProcessResources m_Resources;

	private RenderTexture m_AmbientOnlyAO;

	private readonly RenderTargetIdentifier[] m_MRT = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2]
	{
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)10),
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2)
	};

	public MultiScaleVO(AmbientOcclusion settings)
	{
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		m_Settings = settings;
	}

	public DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)1;
	}

	public void SetResources(PostProcessResources resources)
	{
		m_Resources = resources;
	}

	private void Alloc(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureDescriptor val = default(RenderTextureDescriptor);
		((RenderTextureDescriptor)(ref val)).width = m_Widths[(int)size];
		((RenderTextureDescriptor)(ref val)).height = m_Heights[(int)size];
		((RenderTextureDescriptor)(ref val)).colorFormat = format;
		((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
		((RenderTextureDescriptor)(ref val)).volumeDepth = 1;
		((RenderTextureDescriptor)(ref val)).autoGenerateMips = false;
		((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
		((RenderTextureDescriptor)(ref val)).enableRandomWrite = uav;
		((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)2;
		((RenderTextureDescriptor)(ref val)).sRGB = false;
		cmd.GetTemporaryRT(id, val, (FilterMode)0);
	}

	private void AllocArray(CommandBuffer cmd, int id, MipLevel size, RenderTextureFormat format, bool uav)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		RenderTextureDescriptor val = default(RenderTextureDescriptor);
		((RenderTextureDescriptor)(ref val)).width = m_Widths[(int)size];
		((RenderTextureDescriptor)(ref val)).height = m_Heights[(int)size];
		((RenderTextureDescriptor)(ref val)).colorFormat = format;
		((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
		((RenderTextureDescriptor)(ref val)).volumeDepth = 16;
		((RenderTextureDescriptor)(ref val)).autoGenerateMips = false;
		((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
		((RenderTextureDescriptor)(ref val)).enableRandomWrite = uav;
		((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)5;
		((RenderTextureDescriptor)(ref val)).sRGB = false;
		cmd.GetTemporaryRT(id, val, (FilterMode)0);
	}

	private void Release(CommandBuffer cmd, int id)
	{
		cmd.ReleaseTemporaryRT(id);
	}

	private Vector4 CalculateZBufferParams(Camera camera)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		float num = camera.farClipPlane / camera.nearClipPlane;
		if (SystemInfo.usesReversedZBuffer)
		{
			return new Vector4(num - 1f, 1f, 0f, 0f);
		}
		return new Vector4(1f - num, num, 0f, 0f);
	}

	private float CalculateTanHalfFovHeight(Camera camera)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 projectionMatrix = camera.projectionMatrix;
		return 1f / ((Matrix4x4)(ref projectionMatrix))[0, 0];
	}

	private Vector2 GetSize(MipLevel mip)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)m_Widths[(int)mip], (float)m_Heights[(int)mip]);
	}

	private Vector3 GetSizeArray(MipLevel mip)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)m_Widths[(int)mip], (float)m_Heights[(int)mip], 16f);
	}

	public void GenerateAOMap(CommandBuffer cmd, Camera camera, RenderTargetIdentifier destination, RenderTargetIdentifier? depthMap, bool invert, bool isMSAA)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		m_Widths[0] = camera.pixelWidth * ((!RuntimeUtilities.isSinglePassStereoEnabled) ? 1 : 2);
		m_Heights[0] = camera.pixelHeight;
		for (int i = 1; i < 7; i++)
		{
			int num = 1 << i;
			m_Widths[i] = (m_Widths[0] + (num - 1)) / num;
			m_Heights[i] = (m_Heights[0] + (num - 1)) / num;
		}
		PushAllocCommands(cmd, isMSAA);
		PushDownsampleCommands(cmd, camera, depthMap, isMSAA);
		float tanHalfFovH = CalculateTanHalfFovHeight(camera);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth1, ShaderIDs.Occlusion1, GetSizeArray(MipLevel.L3), tanHalfFovH, isMSAA);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth2, ShaderIDs.Occlusion2, GetSizeArray(MipLevel.L4), tanHalfFovH, isMSAA);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth3, ShaderIDs.Occlusion3, GetSizeArray(MipLevel.L5), tanHalfFovH, isMSAA);
		PushRenderCommands(cmd, ShaderIDs.TiledDepth4, ShaderIDs.Occlusion4, GetSizeArray(MipLevel.L6), tanHalfFovH, isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth4, ShaderIDs.Occlusion4, ShaderIDs.LowDepth3, ShaderIDs.Occlusion3, RenderTargetIdentifier.op_Implicit(ShaderIDs.Combined3), Vector2.op_Implicit(GetSize(MipLevel.L4)), GetSize(MipLevel.L3), isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth3, ShaderIDs.Combined3, ShaderIDs.LowDepth2, ShaderIDs.Occlusion2, RenderTargetIdentifier.op_Implicit(ShaderIDs.Combined2), Vector2.op_Implicit(GetSize(MipLevel.L3)), GetSize(MipLevel.L2), isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth2, ShaderIDs.Combined2, ShaderIDs.LowDepth1, ShaderIDs.Occlusion1, RenderTargetIdentifier.op_Implicit(ShaderIDs.Combined1), Vector2.op_Implicit(GetSize(MipLevel.L2)), GetSize(MipLevel.L1), isMSAA);
		PushUpsampleCommands(cmd, ShaderIDs.LowDepth1, ShaderIDs.Combined1, ShaderIDs.LinearDepth, null, destination, Vector2.op_Implicit(GetSize(MipLevel.L1)), GetSize(MipLevel.Original), isMSAA, invert);
		PushReleaseCommands(cmd);
	}

	private void PushAllocCommands(CommandBuffer cmd, bool isMSAA)
	{
		if (isMSAA)
		{
			Alloc(cmd, ShaderIDs.LinearDepth, MipLevel.Original, (RenderTextureFormat)13, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth1, MipLevel.L1, (RenderTextureFormat)12, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth2, MipLevel.L2, (RenderTextureFormat)12, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth3, MipLevel.L3, (RenderTextureFormat)12, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth4, MipLevel.L4, (RenderTextureFormat)12, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth1, MipLevel.L3, (RenderTextureFormat)13, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth2, MipLevel.L4, (RenderTextureFormat)13, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth3, MipLevel.L5, (RenderTextureFormat)13, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth4, MipLevel.L6, (RenderTextureFormat)13, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion1, MipLevel.L1, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion2, MipLevel.L2, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion3, MipLevel.L3, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion4, MipLevel.L4, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Combined1, MipLevel.L1, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Combined2, MipLevel.L2, (RenderTextureFormat)25, uav: true);
			Alloc(cmd, ShaderIDs.Combined3, MipLevel.L3, (RenderTextureFormat)25, uav: true);
		}
		else
		{
			Alloc(cmd, ShaderIDs.LinearDepth, MipLevel.Original, (RenderTextureFormat)15, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth1, MipLevel.L1, (RenderTextureFormat)14, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth2, MipLevel.L2, (RenderTextureFormat)14, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth3, MipLevel.L3, (RenderTextureFormat)14, uav: true);
			Alloc(cmd, ShaderIDs.LowDepth4, MipLevel.L4, (RenderTextureFormat)14, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth1, MipLevel.L3, (RenderTextureFormat)15, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth2, MipLevel.L4, (RenderTextureFormat)15, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth3, MipLevel.L5, (RenderTextureFormat)15, uav: true);
			AllocArray(cmd, ShaderIDs.TiledDepth4, MipLevel.L6, (RenderTextureFormat)15, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion1, MipLevel.L1, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion2, MipLevel.L2, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion3, MipLevel.L3, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Occlusion4, MipLevel.L4, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Combined1, MipLevel.L1, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Combined2, MipLevel.L2, (RenderTextureFormat)16, uav: true);
			Alloc(cmd, ShaderIDs.Combined3, MipLevel.L3, (RenderTextureFormat)16, uav: true);
		}
	}

	private void PushDownsampleCommands(CommandBuffer cmd, Camera camera, RenderTargetIdentifier? depthMap, bool isMSAA)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		RenderTargetIdentifier val = default(RenderTargetIdentifier);
		if (depthMap.HasValue)
		{
			val = depthMap.Value;
		}
		else if (!RuntimeUtilities.IsResolvedDepthAvailable(camera))
		{
			Alloc(cmd, ShaderIDs.DepthCopy, MipLevel.Original, (RenderTextureFormat)14, uav: false);
			((RenderTargetIdentifier)(ref val))..ctor(ShaderIDs.DepthCopy);
			cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), val, m_PropertySheet, 0, clear: false, null);
			flag = true;
		}
		else
		{
			val = RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)5);
		}
		ComputeShader multiScaleAODownsample = m_Resources.computeShaders.multiScaleAODownsample1;
		int num = multiScaleAODownsample.FindKernel(isMSAA ? "MultiScaleVODownsample1_MSAA" : "MultiScaleVODownsample1");
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "LinearZ", RenderTargetIdentifier.op_Implicit(ShaderIDs.LinearDepth));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS2x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth1));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS4x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth2));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS2xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth1));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS4xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth2));
		cmd.SetComputeVectorParam(multiScaleAODownsample, "ZBufferParams", CalculateZBufferParams(camera));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "Depth", val);
		cmd.DispatchCompute(multiScaleAODownsample, num, m_Widths[4], m_Heights[4], 1);
		if (flag)
		{
			Release(cmd, ShaderIDs.DepthCopy);
		}
		multiScaleAODownsample = m_Resources.computeShaders.multiScaleAODownsample2;
		num = (isMSAA ? multiScaleAODownsample.FindKernel("MultiScaleVODownsample2_MSAA") : multiScaleAODownsample.FindKernel("MultiScaleVODownsample2"));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS4x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth2));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS8x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth3));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS16x", RenderTargetIdentifier.op_Implicit(ShaderIDs.LowDepth4));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS8xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth3));
		cmd.SetComputeTextureParam(multiScaleAODownsample, num, "DS16xAtlas", RenderTargetIdentifier.op_Implicit(ShaderIDs.TiledDepth4));
		cmd.DispatchCompute(multiScaleAODownsample, num, m_Widths[6], m_Heights[6], 1);
	}

	private void PushRenderCommands(CommandBuffer cmd, int source, int destination, Vector3 sourceSize, float tanHalfFovH, bool isMSAA)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		float num = 2f * tanHalfFovH * 10f / sourceSize.x;
		if (RuntimeUtilities.isSinglePassStereoEnabled)
		{
			num *= 2f;
		}
		float num2 = 1f / num;
		for (int i = 0; i < 12; i++)
		{
			m_InvThicknessTable[i] = num2 / m_SampleThickness[i];
		}
		m_SampleWeightTable[0] = 4f * m_SampleThickness[0];
		m_SampleWeightTable[1] = 4f * m_SampleThickness[1];
		m_SampleWeightTable[2] = 4f * m_SampleThickness[2];
		m_SampleWeightTable[3] = 4f * m_SampleThickness[3];
		m_SampleWeightTable[4] = 4f * m_SampleThickness[4];
		m_SampleWeightTable[5] = 8f * m_SampleThickness[5];
		m_SampleWeightTable[6] = 8f * m_SampleThickness[6];
		m_SampleWeightTable[7] = 8f * m_SampleThickness[7];
		m_SampleWeightTable[8] = 4f * m_SampleThickness[8];
		m_SampleWeightTable[9] = 8f * m_SampleThickness[9];
		m_SampleWeightTable[10] = 8f * m_SampleThickness[10];
		m_SampleWeightTable[11] = 4f * m_SampleThickness[11];
		m_SampleWeightTable[0] = 0f;
		m_SampleWeightTable[2] = 0f;
		m_SampleWeightTable[5] = 0f;
		m_SampleWeightTable[7] = 0f;
		m_SampleWeightTable[9] = 0f;
		float num3 = 0f;
		float[] sampleWeightTable = m_SampleWeightTable;
		foreach (float num4 in sampleWeightTable)
		{
			num3 += num4;
		}
		for (int k = 0; k < m_SampleWeightTable.Length; k++)
		{
			m_SampleWeightTable[k] /= num3;
		}
		ComputeShader multiScaleAORender = m_Resources.computeShaders.multiScaleAORender;
		int num5 = (isMSAA ? multiScaleAORender.FindKernel("MultiScaleVORender_MSAA_interleaved") : multiScaleAORender.FindKernel("MultiScaleVORender_interleaved"));
		cmd.SetComputeFloatParams(multiScaleAORender, "gInvThicknessTable", m_InvThicknessTable);
		cmd.SetComputeFloatParams(multiScaleAORender, "gSampleWeightTable", m_SampleWeightTable);
		cmd.SetComputeVectorParam(multiScaleAORender, "gInvSliceDimension", Vector4.op_Implicit(new Vector2(1f / sourceSize.x, 1f / sourceSize.y)));
		cmd.SetComputeVectorParam(multiScaleAORender, "AdditionalParams", Vector4.op_Implicit(new Vector2(-1f / m_Settings.thicknessModifier.value, m_Settings.intensity.value)));
		cmd.SetComputeTextureParam(multiScaleAORender, num5, "DepthTex", RenderTargetIdentifier.op_Implicit(source));
		cmd.SetComputeTextureParam(multiScaleAORender, num5, "Occlusion", RenderTargetIdentifier.op_Implicit(destination));
		uint num6 = default(uint);
		uint num7 = default(uint);
		uint num8 = default(uint);
		multiScaleAORender.GetKernelThreadGroupSizes(num5, ref num6, ref num7, ref num8);
		cmd.DispatchCompute(multiScaleAORender, num5, ((int)sourceSize.x + (int)num6 - 1) / (int)num6, ((int)sourceSize.y + (int)num7 - 1) / (int)num7, ((int)sourceSize.z + (int)num8 - 1) / (int)num8);
	}

	private void PushUpsampleCommands(CommandBuffer cmd, int lowResDepth, int interleavedAO, int highResDepth, int? highResAO, RenderTargetIdentifier dest, Vector3 lowResDepthSize, Vector2 highResDepthSize, bool isMSAA, bool invert = false)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		ComputeShader multiScaleAOUpsample = m_Resources.computeShaders.multiScaleAOUpsample;
		int num = 0;
		num = (isMSAA ? multiScaleAOUpsample.FindKernel(highResAO.HasValue ? "MultiScaleVOUpSample_MSAA_blendout" : (invert ? "MultiScaleVOUpSample_MSAA_invert" : "MultiScaleVOUpSample_MSAA")) : multiScaleAOUpsample.FindKernel(highResAO.HasValue ? "MultiScaleVOUpSample_blendout" : (invert ? "MultiScaleVOUpSample_invert" : "MultiScaleVOUpSample")));
		float num2 = 1920f / lowResDepthSize.x;
		float num3 = 1f - Mathf.Pow(10f, m_Settings.blurTolerance.value) * num2;
		num3 *= num3;
		float num4 = Mathf.Pow(10f, m_Settings.upsampleTolerance.value);
		float num5 = 1f / (Mathf.Pow(10f, m_Settings.noiseFilterTolerance.value) + num4);
		cmd.SetComputeVectorParam(multiScaleAOUpsample, "InvLowResolution", Vector4.op_Implicit(new Vector2(1f / lowResDepthSize.x, 1f / lowResDepthSize.y)));
		cmd.SetComputeVectorParam(multiScaleAOUpsample, "InvHighResolution", Vector4.op_Implicit(new Vector2(1f / highResDepthSize.x, 1f / highResDepthSize.y)));
		cmd.SetComputeVectorParam(multiScaleAOUpsample, "AdditionalParams", new Vector4(num5, num2, num3, num4));
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "LoResDB", RenderTargetIdentifier.op_Implicit(lowResDepth));
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "HiResDB", RenderTargetIdentifier.op_Implicit(highResDepth));
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "LoResAO1", RenderTargetIdentifier.op_Implicit(interleavedAO));
		if (highResAO.HasValue)
		{
			cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "HiResAO", RenderTargetIdentifier.op_Implicit(highResAO.Value));
		}
		cmd.SetComputeTextureParam(multiScaleAOUpsample, num, "AoResult", dest);
		int num6 = ((int)highResDepthSize.x + 17) / 16;
		int num7 = ((int)highResDepthSize.y + 17) / 16;
		cmd.DispatchCompute(multiScaleAOUpsample, num, num6, num7, 1);
	}

	private void PushReleaseCommands(CommandBuffer cmd)
	{
		Release(cmd, ShaderIDs.LinearDepth);
		Release(cmd, ShaderIDs.LowDepth1);
		Release(cmd, ShaderIDs.LowDepth2);
		Release(cmd, ShaderIDs.LowDepth3);
		Release(cmd, ShaderIDs.LowDepth4);
		Release(cmd, ShaderIDs.TiledDepth1);
		Release(cmd, ShaderIDs.TiledDepth2);
		Release(cmd, ShaderIDs.TiledDepth3);
		Release(cmd, ShaderIDs.TiledDepth4);
		Release(cmd, ShaderIDs.Occlusion1);
		Release(cmd, ShaderIDs.Occlusion2);
		Release(cmd, ShaderIDs.Occlusion3);
		Release(cmd, ShaderIDs.Occlusion4);
		Release(cmd, ShaderIDs.Combined1);
		Release(cmd, ShaderIDs.Combined2);
		Release(cmd, ShaderIDs.Combined3);
	}

	private void PreparePropertySheet(PostProcessRenderContext context)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(m_Resources.shaders.multiScaleAO);
		propertySheet.ClearKeywords();
		propertySheet.properties.SetVector(ShaderIDs.AOColor, Color.op_Implicit(Color.white - m_Settings.color.value));
		m_PropertySheet = propertySheet;
	}

	private void CheckAOTexture(PostProcessRenderContext context)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Expected O, but got Unknown
		if ((Object)(object)m_AmbientOnlyAO == (Object)null || !m_AmbientOnlyAO.IsCreated() || ((Texture)m_AmbientOnlyAO).width != context.width || ((Texture)m_AmbientOnlyAO).height != context.height)
		{
			RuntimeUtilities.Destroy((Object)(object)m_AmbientOnlyAO);
			m_AmbientOnlyAO = new RenderTexture(context.width, context.height, 0, (RenderTextureFormat)16, (RenderTextureReadWrite)1)
			{
				hideFlags = (HideFlags)52,
				filterMode = (FilterMode)0,
				enableRandomWrite = true
			};
			m_AmbientOnlyAO.Create();
		}
	}

	private void PushDebug(PostProcessRenderContext context)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion))
		{
			context.PushDebugOverlay(context.command, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO), m_PropertySheet, 3);
		}
	}

	public void RenderAfterOpaque(PostProcessRenderContext context)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Invalid comparison between Unknown and I4
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion");
		SetResources(context.resources);
		PreparePropertySheet(context);
		CheckAOTexture(context);
		if ((int)context.camera.actualRenderingPath == 1 && RenderSettings.fog)
		{
			m_PropertySheet.EnableKeyword("APPLY_FORWARD_FOG");
			m_PropertySheet.properties.SetVector(ShaderIDs.FogParams, Vector4.op_Implicit(new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance)));
		}
		GenerateAOMap(command, context.camera, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO), null, invert: false, isMSAA: false);
		PushDebug(context);
		command.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 2, (RenderBufferLoadAction)0, null);
		command.EndSample("Ambient Occlusion");
	}

	public void RenderAmbientOnly(PostProcessRenderContext context)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Render");
		SetResources(context.resources);
		PreparePropertySheet(context);
		CheckAOTexture(context);
		GenerateAOMap(command, context.camera, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO), null, invert: false, isMSAA: false);
		PushDebug(context);
		command.EndSample("Ambient Occlusion Render");
	}

	public void CompositeAmbientOnly(PostProcessRenderContext context)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Composite");
		command.SetGlobalTexture(ShaderIDs.MSVOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_AmbientOnlyAO));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), m_MRT, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 1, clear: false, null);
		command.EndSample("Ambient Occlusion Composite");
	}

	public void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_AmbientOnlyAO);
		m_AmbientOnlyAO = null;
	}
}


internal enum MipLevel
{
	Original,
	L1,
	L2,
	L3,
	L4,
	L5,
	L6
}


private enum Pass
{
	DepthCopy,
	CompositionDeferred,
	CompositionForward,
	DebugOverlay
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
internal sealed class ScalableAO : IAmbientOcclusionMethod
{
	private enum Pass
	{
		OcclusionEstimationForward,
		OcclusionEstimationDeferred,
		HorizontalBlurForward,
		HorizontalBlurDeferred,
		VerticalBlur,
		CompositionForward,
		CompositionDeferred,
		DebugOverlay
	}

	private RenderTexture m_Result;

	private PropertySheet m_PropertySheet;

	private AmbientOcclusion m_Settings;

	private readonly RenderTargetIdentifier[] m_MRT = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2]
	{
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)10),
		RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2)
	};

	private readonly int[] m_SampleCount = new int[5] { 4, 6, 10, 8, 12 };

	public ScalableAO(AmbientOcclusion settings)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		m_Settings = settings;
	}

	public DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)3;
	}

	private void DoLazyInitialization(PostProcessRenderContext context)
	{
		m_PropertySheet = context.propertySheets.Get(context.resources.shaders.scalableAO);
		bool flag = false;
		if ((Object)(object)m_Result == (Object)null || !m_Result.IsCreated())
		{
			m_Result = context.GetScreenSpaceTemporaryRT(0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
			((Object)m_Result).hideFlags = (HideFlags)52;
			((Texture)m_Result).filterMode = (FilterMode)1;
			flag = true;
		}
		else if (((Texture)m_Result).width != context.width || ((Texture)m_Result).height != context.height)
		{
			m_Result.Release();
			((Texture)m_Result).width = context.width;
			((Texture)m_Result).height = context.height;
			flag = true;
		}
		if (flag)
		{
			m_Result.Create();
		}
	}

	private void Render(PostProcessRenderContext context, CommandBuffer cmd, int occlusionSource)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Invalid comparison between Unknown and I4
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		DoLazyInitialization(context);
		m_Settings.radius.value = Mathf.Max(m_Settings.radius.value, 0.0001f);
		bool num = m_Settings.quality.value < AmbientOcclusionQuality.High;
		float value = m_Settings.intensity.value;
		float value2 = m_Settings.radius.value;
		float num2 = (num ? 0.5f : 1f);
		float num3 = m_SampleCount[(int)m_Settings.quality.value];
		PropertySheet propertySheet = m_PropertySheet;
		propertySheet.ClearKeywords();
		propertySheet.properties.SetVector(ShaderIDs.AOParams, new Vector4(value, value2, num2, num3));
		propertySheet.properties.SetVector(ShaderIDs.AOColor, Color.op_Implicit(Color.white - m_Settings.color.value));
		if ((int)context.camera.actualRenderingPath == 1 && RenderSettings.fog)
		{
			propertySheet.EnableKeyword("APPLY_FORWARD_FOG");
			propertySheet.properties.SetVector(ShaderIDs.FogParams, Vector4.op_Implicit(new Vector3(RenderSettings.fogDensity, RenderSettings.fogStartDistance, RenderSettings.fogEndDistance)));
		}
		int num4 = ((!num) ? 1 : 2);
		int occlusionTexture = ShaderIDs.OcclusionTexture1;
		int widthOverride = context.width / num4;
		int heightOverride = context.height / num4;
		context.GetScreenSpaceTemporaryRT(cmd, occlusionTexture, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1, (FilterMode)1, widthOverride, heightOverride);
		cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit(occlusionTexture), propertySheet, occlusionSource, clear: false, null);
		int occlusionTexture2 = ShaderIDs.OcclusionTexture2;
		context.GetScreenSpaceTemporaryRT(cmd, occlusionTexture2, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1, (FilterMode)1);
		cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(occlusionTexture), RenderTargetIdentifier.op_Implicit(occlusionTexture2), propertySheet, 2 + occlusionSource, clear: false, null);
		cmd.ReleaseTemporaryRT(occlusionTexture);
		cmd.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(occlusionTexture2), RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result), propertySheet, 4, clear: false, null);
		cmd.ReleaseTemporaryRT(occlusionTexture2);
		if (context.IsDebugOverlayEnabled(DebugOverlay.AmbientOcclusion))
		{
			context.PushDebugOverlay(cmd, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result), propertySheet, 7);
		}
	}

	public void RenderAfterOpaque(PostProcessRenderContext context)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion");
		Render(context, command, 0);
		command.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 5, (RenderBufferLoadAction)0, null);
		command.EndSample("Ambient Occlusion");
	}

	public void RenderAmbientOnly(PostProcessRenderContext context)
	{
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Render");
		Render(context, command, 1);
		command.EndSample("Ambient Occlusion Render");
	}

	public void CompositeAmbientOnly(PostProcessRenderContext context)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Ambient Occlusion Composite");
		command.SetGlobalTexture(ShaderIDs.SAOcclusionTexture, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Result));
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), m_MRT, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2), m_PropertySheet, 6, clear: false, null);
		command.EndSample("Ambient Occlusion Composite");
	}

	public void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_Result);
		m_Result = null;
	}
}


private enum Pass
{
	OcclusionEstimationForward,
	OcclusionEstimationDeferred,
	HorizontalBlurForward,
	HorizontalBlurDeferred,
	VerticalBlur,
	CompositionForward,
	CompositionDeferred,
	DebugOverlay
}


public enum ScreenSpaceReflectionPreset
{
	Lower,
	Low,
	Medium,
	High,
	Higher,
	Ultra,
	Overkill,
	Custom
}


public enum ScreenSpaceReflectionResolution
{
	Downsampled,
	FullSize,
	Supersampled
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ScreenSpaceReflectionPresetParameter : ParameterOverride<ScreenSpaceReflectionPreset>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ScreenSpaceReflectionResolutionParameter : ParameterOverride<ScreenSpaceReflectionResolution>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ScreenSpaceReflectionsRenderer), "Unity/Screen-space reflections", true)]
public sealed class ScreenSpaceReflections : PostProcessEffectSettings
{
	[Tooltip("Choose a quality preset, or use \"Custom\" to create your own custom preset. Don't use a preset higher than \"Medium\" if you desire good performance on consoles.")]
	public ScreenSpaceReflectionPresetParameter preset = new ScreenSpaceReflectionPresetParameter
	{
		value = ScreenSpaceReflectionPreset.Medium
	};

	[Range(0f, 256f)]
	[Tooltip("Maximum number of steps in the raymarching pass. Higher values mean more reflections.")]
	public IntParameter maximumIterationCount = new IntParameter
	{
		value = 16
	};

	[Tooltip("Changes the size of the SSR buffer. Downsample it to maximize performances or supersample it for higher quality results with reduced performance.")]
	public ScreenSpaceReflectionResolutionParameter resolution = new ScreenSpaceReflectionResolutionParameter
	{
		value = ScreenSpaceReflectionResolution.Downsampled
	};

	[Range(1f, 64f)]
	[Tooltip("Ray thickness. Lower values are more expensive but allow the effect to detect smaller details.")]
	public FloatParameter thickness = new FloatParameter
	{
		value = 8f
	};

	[Tooltip("Maximum distance to traverse after which it will stop drawing reflections.")]
	public FloatParameter maximumMarchDistance = new FloatParameter
	{
		value = 100f
	};

	[Tooltip("Fades reflections close to the near planes.")]
	[Range(0f, 1f)]
	public FloatParameter distanceFade = new FloatParameter
	{
		value = 0.5f
	};

	[Range(0f, 1f)]
	[Tooltip("Fades reflections close to the screen edges.")]
	public FloatParameter vignette = new FloatParameter
	{
		value = 0.5f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Invalid comparison between Unknown and I4
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Invalid comparison between Unknown and I4
		if ((bool)enabled && (int)context.camera.actualRenderingPath == 3 && SystemInfo.supportsMotionVectors && SystemInfo.supportsComputeShaders && (int)SystemInfo.copyTextureSupport > 0 && Object.op_Implicit((Object)(object)context.resources.shaders.screenSpaceReflections) && context.resources.shaders.screenSpaceReflections.isSupported)
		{
			return Object.op_Implicit((Object)(object)context.resources.computeShaders.gaussianDownsample);
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class ScreenSpaceReflectionsRenderer : PostProcessEffectRenderer<ScreenSpaceReflections>
{
	private class QualityPreset
	{
		public int maximumIterationCount;

		public float thickness;

		public ScreenSpaceReflectionResolution downsampling;
	}

	private enum Pass
	{
		Test,
		Resolve,
		Reproject,
		Composite
	}

	private RenderTexture m_Resolve;

	private RenderTexture m_History;

	private int[] m_MipIDs;

	private readonly QualityPreset[] m_Presets = new QualityPreset[7]
	{
		new QualityPreset
		{
			maximumIterationCount = 10,
			thickness = 32f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 16,
			thickness = 32f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 32,
			thickness = 16f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 48,
			thickness = 8f,
			downsampling = ScreenSpaceReflectionResolution.Downsampled
		},
		new QualityPreset
		{
			maximumIterationCount = 16,
			thickness = 32f,
			downsampling = ScreenSpaceReflectionResolution.FullSize
		},
		new QualityPreset
		{
			maximumIterationCount = 48,
			thickness = 16f,
			downsampling = ScreenSpaceReflectionResolution.FullSize
		},
		new QualityPreset
		{
			maximumIterationCount = 128,
			thickness = 12f,
			downsampling = ScreenSpaceReflectionResolution.Supersampled
		}
	};

	public override DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)5;
	}

	internal void CheckRT(ref RenderTexture rt, int width, int height, FilterMode filterMode, bool useMipMap)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Expected O, but got Unknown
		if ((Object)(object)rt == (Object)null || !rt.IsCreated() || ((Texture)rt).width != width || ((Texture)rt).height != height)
		{
			if ((Object)(object)rt != (Object)null)
			{
				rt.Release();
				RuntimeUtilities.Destroy((Object)(object)rt);
			}
			rt = new RenderTexture(width, height, 0, RuntimeUtilities.defaultHDRRenderTextureFormat)
			{
				filterMode = filterMode,
				useMipMap = useMipMap,
				autoGenerateMips = false,
				hideFlags = (HideFlags)61
			};
			rt.Create();
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_036d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_043c: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0529: Unknown result type (might be due to invalid IL or missing references)
		//IL_0540: Unknown result type (might be due to invalid IL or missing references)
		//IL_055a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0580: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0617: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Screen-space Reflections");
		if (base.settings.preset.value != ScreenSpaceReflectionPreset.Custom)
		{
			int value = (int)base.settings.preset.value;
			base.settings.maximumIterationCount.value = m_Presets[value].maximumIterationCount;
			base.settings.thickness.value = m_Presets[value].thickness;
			base.settings.resolution.value = m_Presets[value].downsampling;
		}
		base.settings.maximumMarchDistance.value = Mathf.Max(0f, base.settings.maximumMarchDistance.value);
		int num = Mathf.ClosestPowerOfTwo(Mathf.Min(context.width, context.height));
		if (base.settings.resolution.value == ScreenSpaceReflectionResolution.Downsampled)
		{
			num >>= 1;
		}
		else if (base.settings.resolution.value == ScreenSpaceReflectionResolution.Supersampled)
		{
			num <<= 1;
		}
		int num2 = Mathf.FloorToInt(Mathf.Log((float)num, 2f) - 3f);
		num2 = Mathf.Min(num2, 12);
		CheckRT(ref m_Resolve, num, num, (FilterMode)2, useMipMap: true);
		Texture2D val = context.resources.blueNoise256[0];
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.screenSpaceReflections);
		propertySheet.properties.SetTexture(ShaderIDs.Noise, (Texture)(object)val);
		Matrix4x4 val2 = default(Matrix4x4);
		((Matrix4x4)(ref val2)).SetRow(0, new Vector4((float)num * 0.5f, 0f, 0f, (float)num * 0.5f));
		((Matrix4x4)(ref val2)).SetRow(1, new Vector4(0f, (float)num * 0.5f, 0f, (float)num * 0.5f));
		((Matrix4x4)(ref val2)).SetRow(2, new Vector4(0f, 0f, 1f, 0f));
		((Matrix4x4)(ref val2)).SetRow(3, new Vector4(0f, 0f, 0f, 1f));
		Matrix4x4 gPUProjectionMatrix = GL.GetGPUProjectionMatrix(context.camera.projectionMatrix, false);
		val2 *= gPUProjectionMatrix;
		propertySheet.properties.SetMatrix(ShaderIDs.ViewMatrix, context.camera.worldToCameraMatrix);
		MaterialPropertyBlock properties = propertySheet.properties;
		int inverseViewMatrix = ShaderIDs.InverseViewMatrix;
		Matrix4x4 worldToCameraMatrix = context.camera.worldToCameraMatrix;
		properties.SetMatrix(inverseViewMatrix, ((Matrix4x4)(ref worldToCameraMatrix)).inverse);
		propertySheet.properties.SetMatrix(ShaderIDs.InverseProjectionMatrix, ((Matrix4x4)(ref gPUProjectionMatrix)).inverse);
		propertySheet.properties.SetMatrix(ShaderIDs.ScreenSpaceProjectionMatrix, val2);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(base.settings.vignette.value, base.settings.distanceFade.value, base.settings.maximumMarchDistance.value, (float)num2));
		propertySheet.properties.SetVector(ShaderIDs.Params2, new Vector4((float)context.width / (float)context.height, (float)num / (float)((Texture)val).width, base.settings.thickness.value, (float)base.settings.maximumIterationCount.value));
		command.GetTemporaryRT(ShaderIDs.Test, num, num, 0, (FilterMode)0, context.sourceFormat);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.Test), propertySheet, 0, clear: false, null);
		if (context.isSceneView)
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), propertySheet, 1, clear: false, null);
		}
		else
		{
			CheckRT(ref m_History, num, num, (FilterMode)1, useMipMap: false);
			if (m_ResetHistory)
			{
				context.command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)m_History), clear: false, null);
				m_ResetHistory = false;
			}
			command.GetTemporaryRT(ShaderIDs.SSRResolveTemp, num, num, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.SSRResolveTemp), propertySheet, 1, clear: false, null);
			propertySheet.properties.SetTexture(ShaderIDs.History, (Texture)(object)m_History);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.SSRResolveTemp), RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), propertySheet, 2, clear: false, null);
			command.CopyTexture(RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), 0, 0, RenderTargetIdentifier.op_Implicit((Texture)(object)m_History), 0, 0);
			command.ReleaseTemporaryRT(ShaderIDs.SSRResolveTemp);
		}
		command.ReleaseTemporaryRT(ShaderIDs.Test);
		if (m_MipIDs == null || m_MipIDs.Length == 0)
		{
			m_MipIDs = new int[12];
			for (int i = 0; i < 12; i++)
			{
				m_MipIDs[i] = Shader.PropertyToID("_SSRGaussianMip" + i);
			}
		}
		ComputeShader gaussianDownsample = context.resources.computeShaders.gaussianDownsample;
		int num3 = gaussianDownsample.FindKernel("KMain");
		RenderTargetIdentifier val3 = default(RenderTargetIdentifier);
		((RenderTargetIdentifier)(ref val3))..ctor((Texture)(object)m_Resolve);
		for (int j = 0; j < num2; j++)
		{
			num >>= 1;
			Assert.IsTrue(num > 0);
			command.GetTemporaryRT(m_MipIDs[j], num, num, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0, 1, true);
			command.SetComputeTextureParam(gaussianDownsample, num3, "_Source", val3);
			command.SetComputeTextureParam(gaussianDownsample, num3, "_Result", RenderTargetIdentifier.op_Implicit(m_MipIDs[j]));
			command.SetComputeVectorParam(gaussianDownsample, "_Size", new Vector4((float)num, (float)num, 1f / (float)num, 1f / (float)num));
			command.DispatchCompute(gaussianDownsample, num3, num / 8, num / 8, 1);
			command.CopyTexture(RenderTargetIdentifier.op_Implicit(m_MipIDs[j]), 0, 0, RenderTargetIdentifier.op_Implicit((Texture)(object)m_Resolve), 0, j + 1);
			val3 = RenderTargetIdentifier.op_Implicit(m_MipIDs[j]);
		}
		for (int k = 0; k < num2; k++)
		{
			command.ReleaseTemporaryRT(m_MipIDs[k]);
		}
		propertySheet.properties.SetTexture(ShaderIDs.Resolve, (Texture)(object)m_Resolve);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 3, clear: false, null);
		command.EndSample("Screen-space Reflections");
	}

	public override void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)m_Resolve);
		RuntimeUtilities.Destroy((Object)(object)m_History);
		m_Resolve = null;
		m_History = null;
	}
}


private class QualityPreset
{
	public int maximumIterationCount;

	public float thickness;

	public ScreenSpaceReflectionResolution downsampling;
}


private enum Pass
{
	Test,
	Resolve,
	Reproject,
	Composite
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
public sealed class SubpixelMorphologicalAntialiasing
{
	private enum Pass
	{
		EdgeDetection = 0,
		BlendWeights = 3,
		NeighborhoodBlending = 6
	}

	public enum Quality
	{
		Low,
		Medium,
		High
	}

	[Tooltip("Lower quality is faster at the expense of visual quality (Low = ~60%, Medium = ~80%).")]
	public Quality quality = Quality.High;

	public bool IsSupported()
	{
		return !RuntimeUtilities.isSinglePassStereoEnabled;
	}

	internal void Render(PostProcessRenderContext context)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.subpixelMorphologicalAntialiasing);
		propertySheet.properties.SetTexture("_AreaTex", (Texture)(object)context.resources.smaaLuts.area);
		propertySheet.properties.SetTexture("_SearchTex", (Texture)(object)context.resources.smaaLuts.search);
		CommandBuffer command = context.command;
		command.BeginSample("SubpixelMorphologicalAntialiasing");
		command.GetTemporaryRT(ShaderIDs.SMAA_Flip, context.width, context.height, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)1);
		command.GetTemporaryRT(ShaderIDs.SMAA_Flop, context.width, context.height, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)1);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flip), propertySheet, (int)quality, clear: true, null);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flip), RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flop), propertySheet, (int)(3 + quality), clear: false, null);
		command.SetGlobalTexture("_BlendTex", RenderTargetIdentifier.op_Implicit(ShaderIDs.SMAA_Flop));
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 6, clear: false, null);
		command.ReleaseTemporaryRT(ShaderIDs.SMAA_Flip);
		command.ReleaseTemporaryRT(ShaderIDs.SMAA_Flop);
		command.EndSample("SubpixelMorphologicalAntialiasing");
	}
}


private enum Pass
{
	EdgeDetection = 0,
	BlendWeights = 3,
	NeighborhoodBlending = 6
}


public enum Quality
{
	Low,
	Medium,
	High
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Serializable]
[Preserve]
public sealed class TemporalAntialiasing
{
	private enum Pass
	{
		SolverDilate,
		SolverNoDilate
	}

	[Tooltip("The diameter (in texels) inside which jitter samples are spread. Smaller values result in crisper but more aliased output, while larger values result in more stable, but blurrier, output.")]
	[Range(0.1f, 1f)]
	public float jitterSpread = 0.75f;

	[Tooltip("Controls the amount of sharpening applied to the color buffer. High values may introduce dark-border artifacts.")]
	[Range(0f, 3f)]
	public float sharpness = 0.25f;

	[Range(0f, 0.99f)]
	[Tooltip("The blend coefficient for a stationary fragment. Controls the percentage of history sample blended into the final color.")]
	public float stationaryBlending = 0.95f;

	[Range(0f, 0.99f)]
	[Tooltip("The blend coefficient for a fragment with significant motion. Controls the percentage of history sample blended into the final color.")]
	public float motionBlending = 0.85f;

	public Func<Camera, Vector2, Matrix4x4> jitteredMatrixFunc;

	private readonly RenderTargetIdentifier[] m_Mrt = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2];

	private bool m_ResetHistory = true;

	private const int k_NumEyes = 2;

	private const int k_NumHistoryTextures = 2;

	private readonly RenderTexture[][] m_HistoryTextures = new RenderTexture[2][];

	private readonly int[] m_HistoryPingPong = new int[2];

	public Vector2 jitter { get; private set; }

	public Vector2 jitterRaw { get; private set; }

	public int sampleIndex { get; private set; }

	public int sampleCount { get; set; }

	public bool IsSupported()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Invalid comparison between Unknown and I4
		if (SystemInfo.supportedRenderTargetCount >= 2 && SystemInfo.supportsMotionVectors)
		{
			return (int)SystemInfo.graphicsDeviceType != 8;
		}
		return false;
	}

	internal DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)5;
	}

	internal void ResetHistory()
	{
		m_ResetHistory = true;
	}

	private Vector2 GenerateRandomOffset()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Vector2 result = new Vector2(HaltonSeq.Get((sampleIndex & 0x3FF) + 1, 2) - 0.5f, HaltonSeq.Get((sampleIndex & 0x3FF) + 1, 3) - 0.5f);
		if (++sampleIndex >= sampleCount)
		{
			sampleIndex = 0;
		}
		return result;
	}

	public Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		jitter = GenerateRandomOffset();
		Matrix4x4 result = ((jitteredMatrixFunc == null) ? (camera.orthographic ? RuntimeUtilities.GetJitteredOrthographicProjectionMatrix(camera, jitter) : RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, jitter)) : jitteredMatrixFunc(camera, jitter));
		jitterRaw = jitter;
		jitter = new Vector2(jitter.x / (float)camera.pixelWidth, jitter.y / (float)camera.pixelHeight);
		return result;
	}

	public void ConfigureJitteredProjectionMatrix(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
		camera.projectionMatrix = GetJitteredProjectionMatrix(camera);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}

	public void ConfigureStereoJitteredProjectionMatrices(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Invalid comparison between Unknown and I4
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		jitter = GenerateRandomOffset();
		for (StereoscopicEye val = (StereoscopicEye)0; (int)val <= 1; val = (StereoscopicEye)(val + 1))
		{
			context.camera.CopyStereoDeviceProjectionMatrixToNonJittered(val);
			Matrix4x4 stereoNonJitteredProjectionMatrix = context.camera.GetStereoNonJitteredProjectionMatrix(val);
			Matrix4x4 val2 = RuntimeUtilities.GenerateJitteredProjectionMatrixFromOriginal(context, stereoNonJitteredProjectionMatrix, jitter);
			context.camera.SetStereoProjectionMatrix(val, val2);
		}
		jitter = new Vector2(jitter.x / (float)context.screenWidth, jitter.y / (float)context.screenHeight);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}

	private void GenerateHistoryName(RenderTexture rt, int id, PostProcessRenderContext context)
	{
		((Object)rt).name = "Temporal Anti-aliasing History id #" + id;
		if (context.stereoActive)
		{
			((Object)rt).name = ((Object)rt).name + " for eye " + context.xrActiveEye;
		}
	}

	private RenderTexture CheckHistory(int id, PostProcessRenderContext context)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		int xrActiveEye = context.xrActiveEye;
		if (m_HistoryTextures[xrActiveEye] == null)
		{
			m_HistoryTextures[xrActiveEye] = (RenderTexture[])(object)new RenderTexture[2];
		}
		RenderTexture val = m_HistoryTextures[xrActiveEye][id];
		if (m_ResetHistory || (Object)(object)val == (Object)null || !val.IsCreated())
		{
			RenderTexture.ReleaseTemporary(val);
			val = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat, (RenderTextureReadWrite)0);
			GenerateHistoryName(val, id, context);
			((Texture)val).filterMode = (FilterMode)1;
			m_HistoryTextures[xrActiveEye][id] = val;
			context.command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)val), clear: false, null);
		}
		else if (((Texture)val).width != context.width || ((Texture)val).height != context.height)
		{
			RenderTexture screenSpaceTemporaryRT = context.GetScreenSpaceTemporaryRT(0, context.sourceFormat, (RenderTextureReadWrite)0);
			GenerateHistoryName(screenSpaceTemporaryRT, id, context);
			((Texture)screenSpaceTemporaryRT).filterMode = (FilterMode)1;
			m_HistoryTextures[xrActiveEye][id] = screenSpaceTemporaryRT;
			context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((Texture)(object)val), RenderTargetIdentifier.op_Implicit((Texture)(object)screenSpaceTemporaryRT), clear: false, null);
			RenderTexture.ReleaseTemporary(val);
		}
		return m_HistoryTextures[xrActiveEye][id];
	}

	internal void Render(PostProcessRenderContext context)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.temporalAntialiasing);
		CommandBuffer command = context.command;
		command.BeginSample("TemporalAntialiasing");
		int num = m_HistoryPingPong[context.xrActiveEye];
		RenderTexture val = CheckHistory(++num % 2, context);
		RenderTexture val2 = CheckHistory(++num % 2, context);
		m_HistoryPingPong[context.xrActiveEye] = ++num % 2;
		propertySheet.properties.SetVector(ShaderIDs.Jitter, Vector4.op_Implicit(jitter));
		propertySheet.properties.SetFloat(ShaderIDs.Sharpness, sharpness);
		propertySheet.properties.SetVector(ShaderIDs.FinalBlendParameters, new Vector4(stationaryBlending, motionBlending, 6000f, 0f));
		propertySheet.properties.SetTexture(ShaderIDs.HistoryTex, (Texture)(object)val);
		int pass = (context.camera.orthographic ? 1 : 0);
		m_Mrt[0] = context.destination;
		m_Mrt[1] = RenderTargetIdentifier.op_Implicit((Texture)(object)val2);
		command.BlitFullscreenTriangle(context.source, m_Mrt, context.source, propertySheet, pass, clear: false, null);
		command.EndSample("TemporalAntialiasing");
		m_ResetHistory = false;
	}

	internal void Release()
	{
		if (m_HistoryTextures != null)
		{
			for (int i = 0; i < m_HistoryTextures.Length; i++)
			{
				if (m_HistoryTextures[i] != null)
				{
					for (int j = 0; j < m_HistoryTextures[i].Length; j++)
					{
						RenderTexture.ReleaseTemporary(m_HistoryTextures[i][j]);
						m_HistoryTextures[i][j] = null;
					}
					m_HistoryTextures[i] = null;
				}
			}
		}
		sampleIndex = 0;
		m_HistoryPingPong[0] = 0;
		m_HistoryPingPong[1] = 0;
		ResetHistory();
	}
}


private enum Pass
{
	SolverDilate,
	SolverNoDilate
}


public enum VignetteMode
{
	Classic,
	Masked
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class VignetteModeParameter : ParameterOverride<VignetteMode>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(VignetteRenderer), "Unity/Vignette", true)]
public sealed class Vignette : PostProcessEffectSettings
{
	[Tooltip("Use the \"Classic\" mode for parametric controls. Use the \"Masked\" mode to use your own texture mask.")]
	public VignetteModeParameter mode = new VignetteModeParameter
	{
		value = VignetteMode.Classic
	};

	[Tooltip("Vignette color.")]
	public ColorParameter color = new ColorParameter
	{
		value = new Color(0f, 0f, 0f, 1f)
	};

	[Tooltip("Sets the vignette center point (screen center is [0.5, 0.5]).")]
	public Vector2Parameter center = new Vector2Parameter
	{
		value = new Vector2(0.5f, 0.5f)
	};

	[Range(0f, 1f)]
	[Tooltip("Amount of vignetting on screen.")]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Range(0.01f, 1f)]
	[Tooltip("Smoothness of the vignette borders.")]
	public FloatParameter smoothness = new FloatParameter
	{
		value = 0.2f
	};

	[Range(0f, 1f)]
	[Tooltip("Lower values will make a square-ish vignette.")]
	public FloatParameter roundness = new FloatParameter
	{
		value = 1f
	};

	[Tooltip("Set to true to mark the vignette to be perfectly round. False will make its shape dependent on the current aspect ratio.")]
	public BoolParameter rounded = new BoolParameter
	{
		value = false
	};

	[Tooltip("A black and white mask to use as a vignette.")]
	public TextureParameter mask = new TextureParameter
	{
		value = null
	};

	[Range(0f, 1f)]
	[Tooltip("Mask opacity.")]
	public FloatParameter opacity = new FloatParameter
	{
		value = 1f
	};

	public override bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		if (enabled.value)
		{
			if (mode.value != 0 || !(intensity.value > 0f))
			{
				if (mode.value == VignetteMode.Masked && opacity.value > 0f)
				{
					return (Object)(object)mask.value != (Object)null;
				}
				return false;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.Scripting;

[Preserve]
internal sealed class VignetteRenderer : PostProcessEffectRenderer<Vignette>
{
	public override void Render(PostProcessRenderContext context)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet uberSheet = context.uberSheet;
		uberSheet.EnableKeyword("VIGNETTE");
		uberSheet.properties.SetColor(ShaderIDs.Vignette_Color, base.settings.color.value);
		if ((VignetteMode)base.settings.mode == VignetteMode.Classic)
		{
			uberSheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 0f);
			uberSheet.properties.SetVector(ShaderIDs.Vignette_Center, Vector4.op_Implicit(base.settings.center.value));
			float num = (1f - base.settings.roundness.value) * 6f + base.settings.roundness.value;
			uberSheet.properties.SetVector(ShaderIDs.Vignette_Settings, new Vector4(base.settings.intensity.value * 3f, base.settings.smoothness.value * 5f, num, base.settings.rounded.value ? 1f : 0f));
		}
		else
		{
			uberSheet.properties.SetFloat(ShaderIDs.Vignette_Mode, 1f);
			uberSheet.properties.SetTexture(ShaderIDs.Vignette_Mask, base.settings.mask.value);
			uberSheet.properties.SetFloat(ShaderIDs.Vignette_Opacity, Mathf.Clamp01(base.settings.opacity.value));
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class HistogramMonitor : Monitor
{
	public enum Channel
	{
		Red,
		Green,
		Blue,
		Master
	}

	public int width = 512;

	public int height = 256;

	public Channel channel = Channel.Master;

	private ComputeBuffer m_Data;

	private const int k_NumBins = 256;

	private const int k_ThreadGroupSizeX = 16;

	private const int k_ThreadGroupSizeY = 16;

	internal override void OnDisable()
	{
		base.OnDisable();
		if (m_Data != null)
		{
			m_Data.Release();
		}
		m_Data = null;
	}

	internal override bool NeedsHalfRes()
	{
		return true;
	}

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		return Object.op_Implicit((Object)(object)context.resources.computeShaders.gammaHistogram);
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected O, but got Unknown
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		CheckOutput(width, height);
		if (m_Data == null)
		{
			m_Data = new ComputeBuffer(256, 4);
		}
		ComputeShader gammaHistogram = context.resources.computeShaders.gammaHistogram;
		CommandBuffer command = context.command;
		command.BeginSample("GammaHistogram");
		int num = gammaHistogram.FindKernel("KHistogramClear");
		command.SetComputeBufferParam(gammaHistogram, num, "_HistogramBuffer", m_Data);
		command.DispatchCompute(gammaHistogram, num, Mathf.CeilToInt(16f), 1, 1);
		num = gammaHistogram.FindKernel("KHistogramGather");
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor((float)(context.width / 2), (float)(context.height / 2), (float)(RuntimeUtilities.isLinearColorSpace ? 1 : 0), (float)channel);
		command.SetComputeVectorParam(gammaHistogram, "_Params", val);
		command.SetComputeTextureParam(gammaHistogram, num, "_Source", RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy));
		command.SetComputeBufferParam(gammaHistogram, num, "_HistogramBuffer", m_Data);
		command.DispatchCompute(gammaHistogram, num, Mathf.CeilToInt(val.x / 16f), Mathf.CeilToInt(val.y / 16f), 1);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.gammaHistogram);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)width, (float)height, 0f, 0f));
		propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, m_Data);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("GammaHistogram");
	}
}


public enum Channel
{
	Red,
	Green,
	Blue,
	Master
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class LightMeterMonitor : Monitor
{
	public int width = 512;

	public int height = 256;

	public bool showCurves = true;

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		if (Object.op_Implicit((Object)(object)context.resources.shaders.lightMeter))
		{
			return context.resources.shaders.lightMeter.isSupported;
		}
		return false;
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		CheckOutput(width, height);
		LogHistogram logHistogram = context.logHistogram;
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.lightMeter);
		propertySheet.ClearKeywords();
		propertySheet.properties.SetBuffer(ShaderIDs.HistogramBuffer, logHistogram.data);
		Vector4 histogramScaleOffsetRes = logHistogram.GetHistogramScaleOffsetRes(context);
		histogramScaleOffsetRes.z = 1f / (float)width;
		histogramScaleOffsetRes.w = 1f / (float)height;
		propertySheet.properties.SetVector(ShaderIDs.ScaleOffsetRes, histogramScaleOffsetRes);
		if ((Object)(object)context.logLut != (Object)null && showCurves)
		{
			propertySheet.EnableKeyword("COLOR_GRADING_HDR");
			propertySheet.properties.SetTexture(ShaderIDs.Lut3D, context.logLut);
		}
		AutoExposure autoExposure = context.autoExposure;
		if ((Object)(object)autoExposure != (Object)null)
		{
			float x = autoExposure.filtering.value.x;
			float y = autoExposure.filtering.value.y;
			y = Mathf.Clamp(y, 1.01f, 99f);
			x = Mathf.Clamp(x, 1f, y - 0.01f);
			Vector4 val = default(Vector4);
			((Vector4)(ref val))..ctor(x * 0.01f, y * 0.01f, RuntimeUtilities.Exp2(autoExposure.minLuminance.value), RuntimeUtilities.Exp2(autoExposure.maxLuminance.value));
			propertySheet.EnableKeyword("AUTO_EXPOSURE");
			propertySheet.properties.SetVector(ShaderIDs.Params, val);
		}
		CommandBuffer command = context.command;
		command.BeginSample("LightMeter");
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("LightMeter");
	}
}


public enum MonitorType
{
	LightMeter,
	Histogram,
	Waveform,
	Vectorscope
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class Monitor
{
	internal bool requested;

	public RenderTexture output { get; protected set; }

	public bool IsRequestedAndSupported(PostProcessRenderContext context)
	{
		if (requested && SystemInfo.supportsComputeShaders && !RuntimeUtilities.isAndroidOpenGL)
		{
			return ShaderResourcesAvailable(context);
		}
		return false;
	}

	internal abstract bool ShaderResourcesAvailable(PostProcessRenderContext context);

	internal virtual bool NeedsHalfRes()
	{
		return false;
	}

	protected void CheckOutput(int width, int height)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Expected O, but got Unknown
		if ((Object)(object)output == (Object)null || !output.IsCreated() || ((Texture)output).width != width || ((Texture)output).height != height)
		{
			RuntimeUtilities.Destroy((Object)(object)output);
			output = new RenderTexture(width, height, 0, (RenderTextureFormat)0)
			{
				anisoLevel = 0,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				useMipMap = false
			};
		}
	}

	internal virtual void OnEnable()
	{
	}

	internal virtual void OnDisable()
	{
		RuntimeUtilities.Destroy((Object)(object)output);
	}

	internal abstract void Render(PostProcessRenderContext context);
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class VectorscopeMonitor : Monitor
{
	public int size = 256;

	public float exposure = 0.12f;

	private ComputeBuffer m_Data;

	private const int k_ThreadGroupSizeX = 16;

	private const int k_ThreadGroupSizeY = 16;

	internal override void OnDisable()
	{
		base.OnDisable();
		if (m_Data != null)
		{
			m_Data.Release();
		}
		m_Data = null;
	}

	internal override bool NeedsHalfRes()
	{
		return true;
	}

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		return Object.op_Implicit((Object)(object)context.resources.computeShaders.vectorscope);
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected O, but got Unknown
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Expected O, but got Unknown
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		CheckOutput(size, size);
		exposure = Mathf.Max(0f, exposure);
		int num = size * size;
		if (m_Data == null)
		{
			m_Data = new ComputeBuffer(num, 4);
		}
		else if (m_Data.count != num)
		{
			m_Data.Release();
			m_Data = new ComputeBuffer(num, 4);
		}
		ComputeShader vectorscope = context.resources.computeShaders.vectorscope;
		CommandBuffer command = context.command;
		command.BeginSample("Vectorscope");
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor((float)(context.width / 2), (float)(context.height / 2), (float)size, (float)(RuntimeUtilities.isLinearColorSpace ? 1 : 0));
		int num2 = vectorscope.FindKernel("KVectorscopeClear");
		command.SetComputeBufferParam(vectorscope, num2, "_VectorscopeBuffer", m_Data);
		command.SetComputeVectorParam(vectorscope, "_Params", val);
		command.DispatchCompute(vectorscope, num2, Mathf.CeilToInt((float)size / 16f), Mathf.CeilToInt((float)size / 16f), 1);
		num2 = vectorscope.FindKernel("KVectorscopeGather");
		command.SetComputeBufferParam(vectorscope, num2, "_VectorscopeBuffer", m_Data);
		command.SetComputeTextureParam(vectorscope, num2, "_Source", RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy));
		command.DispatchCompute(vectorscope, num2, Mathf.CeilToInt(val.x / 16f), Mathf.CeilToInt(val.y / 16f), 1);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.vectorscope);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)size, (float)size, exposure, 0f));
		propertySheet.properties.SetBuffer(ShaderIDs.VectorscopeBuffer, m_Data);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("Vectorscope");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class WaveformMonitor : Monitor
{
	public float exposure = 0.12f;

	public int height = 256;

	private ComputeBuffer m_Data;

	private const int k_ThreadGroupSize = 256;

	private const int k_ThreadGroupSizeX = 16;

	private const int k_ThreadGroupSizeY = 16;

	internal override void OnDisable()
	{
		base.OnDisable();
		if (m_Data != null)
		{
			m_Data.Release();
		}
		m_Data = null;
	}

	internal override bool NeedsHalfRes()
	{
		return true;
	}

	internal override bool ShaderResourcesAvailable(PostProcessRenderContext context)
	{
		return Object.op_Implicit((Object)(object)context.resources.computeShaders.waveform);
	}

	internal override void Render(PostProcessRenderContext context)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Expected O, but got Unknown
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Expected O, but got Unknown
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		float num = (float)context.width / 2f / ((float)context.height / 2f);
		int num2 = Mathf.FloorToInt((float)height * num);
		CheckOutput(num2, height);
		exposure = Mathf.Max(0f, exposure);
		int num3 = num2 * height;
		if (m_Data == null)
		{
			m_Data = new ComputeBuffer(num3, 16);
		}
		else if (m_Data.count < num3)
		{
			m_Data.Release();
			m_Data = new ComputeBuffer(num3, 16);
		}
		ComputeShader waveform = context.resources.computeShaders.waveform;
		CommandBuffer command = context.command;
		command.BeginSample("Waveform");
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor((float)num2, (float)height, (float)(RuntimeUtilities.isLinearColorSpace ? 1 : 0), 0f);
		int num4 = waveform.FindKernel("KWaveformClear");
		command.SetComputeBufferParam(waveform, num4, "_WaveformBuffer", m_Data);
		command.SetComputeVectorParam(waveform, "_Params", val);
		command.DispatchCompute(waveform, num4, Mathf.CeilToInt((float)num2 / 16f), Mathf.CeilToInt((float)height / 16f), 1);
		command.GetTemporaryRT(ShaderIDs.WaveformSource, num2, height, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy), RenderTargetIdentifier.op_Implicit(ShaderIDs.WaveformSource), clear: false, null);
		num4 = waveform.FindKernel("KWaveformGather");
		command.SetComputeBufferParam(waveform, num4, "_WaveformBuffer", m_Data);
		command.SetComputeTextureParam(waveform, num4, "_Source", RenderTargetIdentifier.op_Implicit(ShaderIDs.WaveformSource));
		command.SetComputeVectorParam(waveform, "_Params", val);
		command.DispatchCompute(waveform, num4, num2, Mathf.CeilToInt((float)height / 256f), 1);
		command.ReleaseTemporaryRT(ShaderIDs.WaveformSource);
		PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.waveform);
		propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4((float)num2, (float)height, exposure, 0f));
		propertySheet.properties.SetBuffer(ShaderIDs.WaveformBuffer, m_Data);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), RenderTargetIdentifier.op_Implicit((Texture)(object)base.output), propertySheet, 0, clear: false, null);
		command.EndSample("Waveform");
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public abstract class ParameterOverride
{
	public bool overrideState;

	internal abstract void Interp(ParameterOverride from, ParameterOverride to, float t);

	public abstract int GetHash();

	public T GetValue<T>()
	{
		return ((ParameterOverride<T>)this).value;
	}

	protected internal virtual void OnEnable()
	{
	}

	protected internal virtual void OnDisable()
	{
	}

	internal abstract void SetValue(ParameterOverride parameter);
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class ParameterOverride<T> : ParameterOverride
{
	public T value;

	public ParameterOverride()
		: this(default(T), overrideState: false)
	{
	}

	public ParameterOverride(T value)
		: this(value, overrideState: false)
	{
	}

	public ParameterOverride(T value, bool overrideState)
	{
		this.value = value;
		base.overrideState = overrideState;
	}

	internal override void Interp(ParameterOverride from, ParameterOverride to, float t)
	{
		Interp(from.GetValue<T>(), to.GetValue<T>(), t);
	}

	public virtual void Interp(T from, T to, float t)
	{
		value = ((t > 0f) ? to : from);
	}

	public void Override(T x)
	{
		overrideState = true;
		value = x;
	}

	internal override void SetValue(ParameterOverride parameter)
	{
		value = parameter.GetValue<T>();
	}

	public override int GetHash()
	{
		return (17 * 23 + overrideState.GetHashCode()) * 23 + value.GetHashCode();
	}

	public static implicit operator T(ParameterOverride<T> prop)
	{
		return prop.value;
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class FloatParameter : ParameterOverride<float>
{
	public override void Interp(float from, float to, float t)
	{
		value = from + (to - from) * t;
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class IntParameter : ParameterOverride<int>
{
	public override void Interp(int from, int to, float t)
	{
		value = (int)((float)from + (float)(to - from) * t);
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BoolParameter : ParameterOverride<bool>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ColorParameter : ParameterOverride<Color>
{
	public override void Interp(Color from, Color to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		value.r = from.r + (to.r - from.r) * t;
		value.g = from.g + (to.g - from.g) * t;
		value.b = from.b + (to.b - from.b) * t;
		value.a = from.a + (to.a - from.a) * t;
	}

	public static implicit operator Vector4(ColorParameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Color.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class Vector2Parameter : ParameterOverride<Vector2>
{
	public override void Interp(Vector2 from, Vector2 to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		value.x = from.x + (to.x - from.x) * t;
		value.y = from.y + (to.y - from.y) * t;
	}

	public static implicit operator Vector3(Vector2Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(prop.value);
	}

	public static implicit operator Vector4(Vector2Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class Vector3Parameter : ParameterOverride<Vector3>
{
	public override void Interp(Vector3 from, Vector3 to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		value.x = from.x + (to.x - from.x) * t;
		value.y = from.y + (to.y - from.y) * t;
		value.z = from.z + (to.z - from.z) * t;
	}

	public static implicit operator Vector2(Vector3Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.op_Implicit(prop.value);
	}

	public static implicit operator Vector4(Vector3Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class Vector4Parameter : ParameterOverride<Vector4>
{
	public override void Interp(Vector4 from, Vector4 to, float t)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		value.x = from.x + (to.x - from.x) * t;
		value.y = from.y + (to.y - from.y) * t;
		value.z = from.z + (to.z - from.z) * t;
		value.w = from.w + (to.w - from.w) * t;
	}

	public static implicit operator Vector2(Vector4Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}

	public static implicit operator Vector3(Vector4Parameter prop)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return Vector4.op_Implicit(prop.value);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class SplineParameter : ParameterOverride<Spline>
{
	protected internal override void OnEnable()
	{
		if (value != null)
		{
			value.Cache(int.MinValue);
		}
	}

	internal override void SetValue(ParameterOverride parameter)
	{
		base.SetValue(parameter);
		if (value != null)
		{
			value.Cache(Time.renderedFrameCount);
		}
	}

	public override void Interp(Spline from, Spline to, float t)
	{
		if (from == null || to == null)
		{
			base.Interp(from, to, t);
			return;
		}
		int renderedFrameCount = Time.renderedFrameCount;
		from.Cache(renderedFrameCount);
		to.Cache(renderedFrameCount);
		for (int i = 0; i < 128; i++)
		{
			float num = from.cachedData[i];
			float num2 = to.cachedData[i];
			value.cachedData[i] = num + (num2 - num) * t;
		}
	}
}


public enum TextureParameterDefault
{
	None,
	Black,
	White,
	Transparent,
	Lut2D
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class TextureParameter : ParameterOverride<Texture>
{
	public TextureParameterDefault defaultState = TextureParameterDefault.Black;

	public override void Interp(Texture from, Texture to, float t)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)from == (Object)null && (Object)(object)to == (Object)null)
		{
			value = null;
			return;
		}
		if ((Object)(object)from != (Object)null && (Object)(object)to != (Object)null)
		{
			value = TextureLerper.instance.Lerp(from, to, t);
			return;
		}
		if (defaultState == TextureParameterDefault.Lut2D)
		{
			Texture lutStrip = (Texture)(object)RuntimeUtilities.GetLutStrip(((Object)(object)from != (Object)null) ? from.height : to.height);
			if ((Object)(object)from == (Object)null)
			{
				from = lutStrip;
			}
			if ((Object)(object)to == (Object)null)
			{
				to = lutStrip;
			}
		}
		Color to2;
		switch (defaultState)
		{
		case TextureParameterDefault.Black:
			to2 = Color.black;
			break;
		case TextureParameterDefault.White:
			to2 = Color.white;
			break;
		case TextureParameterDefault.Transparent:
			to2 = Color.clear;
			break;
		case TextureParameterDefault.Lut2D:
		{
			Texture lutStrip2 = (Texture)(object)RuntimeUtilities.GetLutStrip(((Object)(object)from != (Object)null) ? from.height : to.height);
			if ((Object)(object)from == (Object)null)
			{
				from = lutStrip2;
			}
			if ((Object)(object)to == (Object)null)
			{
				to = lutStrip2;
			}
			if (from.width != to.width || from.height != to.height)
			{
				value = null;
			}
			else
			{
				value = TextureLerper.instance.Lerp(from, to, t);
			}
			return;
		}
		default:
			base.Interp(from, to, t);
			return;
		}
		if ((Object)(object)from == (Object)null)
		{
			value = TextureLerper.instance.Lerp(to, to2, 1f - t);
		}
		else
		{
			value = TextureLerper.instance.Lerp(from, to2, t);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessBundle
{
	private PostProcessEffectRenderer m_Renderer;

	public PostProcessAttribute attribute { get; private set; }

	public PostProcessEffectSettings settings { get; private set; }

	internal PostProcessEffectRenderer renderer
	{
		get
		{
			if (m_Renderer == null)
			{
				Assert.IsNotNull<Type>(attribute.renderer);
				Type type = attribute.renderer;
				m_Renderer = (PostProcessEffectRenderer)Activator.CreateInstance(type);
				m_Renderer.SetSettings(settings);
				m_Renderer.Init();
			}
			return m_Renderer;
		}
	}

	internal PostProcessBundle(PostProcessEffectSettings settings)
	{
		Assert.IsNotNull<PostProcessEffectSettings>(settings);
		this.settings = settings;
		attribute = ((object)settings).GetType().GetAttribute<PostProcessAttribute>();
	}

	internal void Release()
	{
		if (m_Renderer != null)
		{
			m_Renderer.Release();
		}
		RuntimeUtilities.Destroy((Object)(object)settings);
	}

	internal void ResetHistory()
	{
		if (m_Renderer != null)
		{
			m_Renderer.ResetHistory();
		}
	}

	internal T CastSettings<T>() where T : PostProcessEffectSettings
	{
		return (T)settings;
	}

	internal T CastRenderer<T>() where T : PostProcessEffectRenderer
	{
		return (T)renderer;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[AddComponentMenu("Rendering/Post-process Debug", 1002)]
[ExecuteAlways]
public sealed class PostProcessDebug : MonoBehaviour
{
	public PostProcessLayer postProcessLayer;

	private PostProcessLayer m_PreviousPostProcessLayer;

	public bool lightMeter;

	public bool histogram;

	public bool waveform;

	public bool vectorscope;

	public DebugOverlay debugOverlay;

	private Camera m_CurrentCamera;

	private CommandBuffer m_CmdAfterEverything;

	private void OnEnable()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Expected O, but got Unknown
		m_CmdAfterEverything = new CommandBuffer
		{
			name = "Post-processing Debug Overlay"
		};
	}

	private void OnDisable()
	{
		if ((Object)(object)m_CurrentCamera != (Object)null)
		{
			m_CurrentCamera.RemoveCommandBuffer((CameraEvent)19, m_CmdAfterEverything);
		}
		m_CurrentCamera = null;
		m_PreviousPostProcessLayer = null;
	}

	private void Update()
	{
		UpdateStates();
	}

	private void Reset()
	{
		postProcessLayer = ((Component)this).GetComponent<PostProcessLayer>();
	}

	private void UpdateStates()
	{
		if ((Object)(object)m_PreviousPostProcessLayer != (Object)(object)postProcessLayer)
		{
			if ((Object)(object)m_CurrentCamera != (Object)null)
			{
				m_CurrentCamera.RemoveCommandBuffer((CameraEvent)19, m_CmdAfterEverything);
				m_CurrentCamera = null;
			}
			m_PreviousPostProcessLayer = postProcessLayer;
			if ((Object)(object)postProcessLayer != (Object)null)
			{
				m_CurrentCamera = ((Component)postProcessLayer).GetComponent<Camera>();
				m_CurrentCamera.AddCommandBuffer((CameraEvent)19, m_CmdAfterEverything);
			}
		}
		if (!((Object)(object)postProcessLayer == (Object)null) && ((Behaviour)postProcessLayer).enabled)
		{
			if (lightMeter)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.LightMeter);
			}
			if (histogram)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Histogram);
			}
			if (waveform)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Waveform);
			}
			if (vectorscope)
			{
				postProcessLayer.debugLayer.RequestMonitorPass(MonitorType.Vectorscope);
			}
			postProcessLayer.debugLayer.RequestDebugOverlay(debugOverlay);
		}
	}

	private void OnPostRender()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		m_CmdAfterEverything.Clear();
		if (!((Object)(object)postProcessLayer == (Object)null) && ((Behaviour)postProcessLayer).enabled && postProcessLayer.debugLayer.debugOverlayActive)
		{
			m_CmdAfterEverything.Blit((Texture)(object)postProcessLayer.debugLayer.debugOverlayTarget, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)2));
		}
	}

	private void OnGUI()
	{
		if (!((Object)(object)postProcessLayer == (Object)null) && ((Behaviour)postProcessLayer).enabled)
		{
			RenderTexture.active = null;
			Rect rect = default(Rect);
			((Rect)(ref rect))..ctor(5f, 5f, 0f, 0f);
			PostProcessDebugLayer debugLayer = postProcessLayer.debugLayer;
			DrawMonitor(ref rect, debugLayer.lightMeter, lightMeter);
			DrawMonitor(ref rect, debugLayer.histogram, histogram);
			DrawMonitor(ref rect, debugLayer.waveform, waveform);
			DrawMonitor(ref rect, debugLayer.vectorscope, vectorscope);
		}
	}

	private void DrawMonitor(ref Rect rect, Monitor monitor, bool enabled)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (enabled && !((Object)(object)monitor.output == (Object)null))
		{
			((Rect)(ref rect)).width = ((Texture)monitor.output).width;
			((Rect)(ref rect)).height = ((Texture)monitor.output).height;
			GUI.DrawTexture(rect, (Texture)(object)monitor.output);
			((Rect)(ref rect)).x = ((Rect)(ref rect)).x + ((float)((Texture)monitor.output).width + 5f);
		}
	}
}


public enum DebugOverlay
{
	None,
	Depth,
	Normals,
	MotionVectors,
	NANTracker,
	ColorBlindnessSimulation,
	_,
	AmbientOcclusion,
	BloomBuffer,
	BloomThreshold,
	DepthOfField
}


public enum ColorBlindnessType
{
	Deuteranopia,
	Protanopia,
	Tritanopia
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class PostProcessDebugLayer
{
	[Serializable]
	public class OverlaySettings
	{
		public bool linearDepth;

		[Range(0f, 16f)]
		public float motionColorIntensity = 4f;

		[Range(4f, 128f)]
		public int motionGridSize = 64;

		public ColorBlindnessType colorBlindnessType;

		[Range(0f, 1f)]
		public float colorBlindnessStrength = 1f;
	}

	public LightMeterMonitor lightMeter;

	public HistogramMonitor histogram;

	public WaveformMonitor waveform;

	public VectorscopeMonitor vectorscope;

	private Dictionary<MonitorType, Monitor> m_Monitors;

	private int frameWidth;

	private int frameHeight;

	public OverlaySettings overlaySettings;

	public RenderTexture debugOverlayTarget { get; private set; }

	public bool debugOverlayActive { get; private set; }

	public DebugOverlay debugOverlay { get; private set; }

	internal void OnEnable()
	{
		RuntimeUtilities.CreateIfNull(ref lightMeter);
		RuntimeUtilities.CreateIfNull(ref histogram);
		RuntimeUtilities.CreateIfNull(ref waveform);
		RuntimeUtilities.CreateIfNull(ref vectorscope);
		RuntimeUtilities.CreateIfNull(ref overlaySettings);
		m_Monitors = new Dictionary<MonitorType, Monitor>
		{
			{
				MonitorType.LightMeter,
				lightMeter
			},
			{
				MonitorType.Histogram,
				histogram
			},
			{
				MonitorType.Waveform,
				waveform
			},
			{
				MonitorType.Vectorscope,
				vectorscope
			}
		};
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			monitor.Value.OnEnable();
		}
	}

	internal void OnDisable()
	{
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			monitor.Value.OnDisable();
		}
		DestroyDebugOverlayTarget();
	}

	private void DestroyDebugOverlayTarget()
	{
		RuntimeUtilities.Destroy((Object)(object)debugOverlayTarget);
		debugOverlayTarget = null;
	}

	public void RequestMonitorPass(MonitorType monitor)
	{
		m_Monitors[monitor].requested = true;
	}

	public void RequestDebugOverlay(DebugOverlay mode)
	{
		debugOverlay = mode;
	}

	internal void SetFrameSize(int width, int height)
	{
		frameWidth = width;
		frameHeight = height;
		debugOverlayActive = false;
	}

	public void PushDebugOverlay(CommandBuffer cmd, RenderTargetIdentifier source, PropertySheet sheet, int pass)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Expected O, but got Unknown
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)debugOverlayTarget == (Object)null || !debugOverlayTarget.IsCreated() || ((Texture)debugOverlayTarget).width != frameWidth || ((Texture)debugOverlayTarget).height != frameHeight)
		{
			RuntimeUtilities.Destroy((Object)(object)debugOverlayTarget);
			debugOverlayTarget = new RenderTexture(frameWidth, frameHeight, 0, (RenderTextureFormat)0)
			{
				name = "Debug Overlay Target",
				anisoLevel = 1,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				hideFlags = (HideFlags)61
			};
			debugOverlayTarget.Create();
		}
		cmd.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit((Texture)(object)debugOverlayTarget), sheet, pass, clear: false, null);
		debugOverlayActive = true;
	}

	internal DepthTextureMode GetCameraFlags()
	{
		if (debugOverlay != DebugOverlay.Depth)
		{
			if (debugOverlay != DebugOverlay.Normals)
			{
				if (debugOverlay != DebugOverlay.MotionVectors)
				{
					return (DepthTextureMode)0;
				}
				return (DepthTextureMode)5;
			}
			return (DepthTextureMode)2;
		}
		return (DepthTextureMode)1;
	}

	internal void RenderMonitors(PostProcessRenderContext context)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		bool flag2 = false;
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			bool flag3 = monitor.Value.IsRequestedAndSupported(context);
			flag = flag || flag3;
			flag2 |= flag3 && monitor.Value.NeedsHalfRes();
		}
		if (!flag)
		{
			return;
		}
		CommandBuffer command = context.command;
		command.BeginSample("Monitors");
		if (flag2)
		{
			command.GetTemporaryRT(ShaderIDs.HalfResFinalCopy, context.width / 2, context.height / 2, 0, (FilterMode)1, context.sourceFormat);
			command.Blit(context.destination, RenderTargetIdentifier.op_Implicit(ShaderIDs.HalfResFinalCopy));
		}
		foreach (KeyValuePair<MonitorType, Monitor> monitor2 in m_Monitors)
		{
			Monitor value = monitor2.Value;
			if (value.requested)
			{
				value.Render(context);
			}
		}
		if (flag2)
		{
			command.ReleaseTemporaryRT(ShaderIDs.HalfResFinalCopy);
		}
		command.EndSample("Monitors");
	}

	internal void RenderSpecialOverlays(PostProcessRenderContext context)
	{
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Invalid comparison between Unknown and I4
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		if (debugOverlay == DebugOverlay.Depth)
		{
			PropertySheet propertySheet = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.linearDepth ? 1f : 0f, 0f, 0f, 0f));
			PushDebugOverlay(context.command, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet, 0);
		}
		else if (debugOverlay == DebugOverlay.Normals)
		{
			PropertySheet propertySheet2 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet2.ClearKeywords();
			if ((int)context.camera.actualRenderingPath == 2)
			{
				propertySheet2.EnableKeyword("SOURCE_GBUFFER");
			}
			PushDebugOverlay(context.command, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet2, 1);
		}
		else if (debugOverlay == DebugOverlay.MotionVectors)
		{
			PropertySheet propertySheet3 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet3.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.motionColorIntensity, (float)overlaySettings.motionGridSize, 0f, 0f));
			PushDebugOverlay(context.command, context.source, propertySheet3, 2);
		}
		else if (debugOverlay == DebugOverlay.NANTracker)
		{
			PropertySheet sheet = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			PushDebugOverlay(context.command, context.source, sheet, 3);
		}
		else if (debugOverlay == DebugOverlay.ColorBlindnessSimulation)
		{
			PropertySheet propertySheet4 = context.propertySheets.Get(context.resources.shaders.debugOverlays);
			propertySheet4.properties.SetVector(ShaderIDs.Params, new Vector4(overlaySettings.colorBlindnessStrength, 0f, 0f, 0f));
			PushDebugOverlay(context.command, context.source, propertySheet4, (int)(4 + overlaySettings.colorBlindnessType));
		}
	}

	internal void EndFrame()
	{
		foreach (KeyValuePair<MonitorType, Monitor> monitor in m_Monitors)
		{
			monitor.Value.requested = false;
		}
		if (!debugOverlayActive)
		{
			DestroyDebugOverlayTarget();
		}
		debugOverlay = DebugOverlay.None;
	}
}


using System;

[Serializable]
public class OverlaySettings
{
	public bool linearDepth;

	[Range(0f, 16f)]
	public float motionColorIntensity = 4f;

	[Range(4f, 128f)]
	public int motionGridSize = 64;

	public ColorBlindnessType colorBlindnessType;

	[Range(0f, 1f)]
	public float colorBlindnessStrength = 1f;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public abstract class PostProcessEffectRenderer
{
	protected bool m_ResetHistory = true;

	public virtual void Init()
	{
	}

	public virtual DepthTextureMode GetCameraFlags()
	{
		return (DepthTextureMode)0;
	}

	public virtual void ResetHistory()
	{
		m_ResetHistory = true;
	}

	public virtual void Release()
	{
		ResetHistory();
	}

	public abstract void Render(PostProcessRenderContext context);

	internal abstract void SetSettings(PostProcessEffectSettings settings);
}


using UnityEngine.Rendering.PostProcessing;

public abstract class PostProcessEffectRenderer<T> : PostProcessEffectRenderer where T : PostProcessEffectSettings
{
	public T settings { get; internal set; }

	internal override void SetSettings(PostProcessEffectSettings settings)
	{
		this.settings = (T)settings;
	}
}


using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Reflection;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class PostProcessEffectSettings : ScriptableObject
{
	public bool active = true;

	public BoolParameter enabled = new BoolParameter
	{
		overrideState = true,
		value = false
	};

	internal ReadOnlyCollection<ParameterOverride> parameters;

	private void OnEnable()
	{
		parameters = (from t in ((object)this).GetType().GetFields(BindingFlags.Instance | BindingFlags.Public)
			where t.FieldType.IsSubclassOf(typeof(ParameterOverride))
			orderby t.MetadataToken
			select (ParameterOverride)t.GetValue(this)).ToList().AsReadOnly();
		foreach (ParameterOverride parameter in parameters)
		{
			parameter.OnEnable();
		}
	}

	private void OnDisable()
	{
		if (parameters == null)
		{
			return;
		}
		foreach (ParameterOverride parameter in parameters)
		{
			parameter.OnDisable();
		}
	}

	public void SetAllOverridesTo(bool state, bool excludeEnabled = true)
	{
		foreach (ParameterOverride parameter in parameters)
		{
			if (!excludeEnabled || parameter != enabled)
			{
				parameter.overrideState = state;
			}
		}
	}

	public virtual bool IsEnabledAndSupported(PostProcessRenderContext context)
	{
		return enabled.value;
	}

	public int GetHash()
	{
		int num = 17;
		foreach (ParameterOverride parameter in parameters)
		{
			num = num * 23 + parameter.GetHash();
		}
		return num;
	}
}


public enum PostProcessEvent
{
	BeforeTransparent,
	BeforeStack,
	AfterStack
}


using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine.Rendering.PostProcessing;

[StructLayout(LayoutKind.Sequential, Size = 1)]
internal struct PostProcessEventComparer : IEqualityComparer<PostProcessEvent>
{
	public bool Equals(PostProcessEvent x, PostProcessEvent y)
	{
		return x == y;
	}

	public int GetHashCode(PostProcessEvent obj)
	{
		return (int)obj;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessManager
{
	private static PostProcessManager s_Instance;

	private const int k_MaxLayerCount = 32;

	private readonly Dictionary<int, List<PostProcessVolume>> m_SortedVolumes;

	private readonly List<PostProcessVolume> m_Volumes;

	private readonly Dictionary<int, bool> m_SortNeeded;

	private readonly List<PostProcessEffectSettings> m_BaseSettings;

	public readonly Dictionary<Type, PostProcessAttribute> settingsTypes;

	public static PostProcessManager instance
	{
		get
		{
			if (s_Instance == null)
			{
				s_Instance = new PostProcessManager();
			}
			return s_Instance;
		}
	}

	private PostProcessManager()
	{
		m_SortedVolumes = new Dictionary<int, List<PostProcessVolume>>();
		m_Volumes = new List<PostProcessVolume>();
		m_SortNeeded = new Dictionary<int, bool>();
		m_BaseSettings = new List<PostProcessEffectSettings>();
		settingsTypes = new Dictionary<Type, PostProcessAttribute>();
		ReloadBaseTypes();
	}

	private void CleanBaseTypes()
	{
		settingsTypes.Clear();
		foreach (PostProcessEffectSettings baseSetting in m_BaseSettings)
		{
			RuntimeUtilities.Destroy((Object)(object)baseSetting);
		}
		m_BaseSettings.Clear();
	}

	private void ReloadBaseTypes()
	{
		CleanBaseTypes();
		foreach (Type item in from t in RuntimeUtilities.GetAllAssemblyTypes()
			where t.IsSubclassOf(typeof(PostProcessEffectSettings)) && t.IsDefined(typeof(PostProcessAttribute), inherit: false) && !t.IsAbstract
			select t)
		{
			settingsTypes.Add(item, item.GetAttribute<PostProcessAttribute>());
			PostProcessEffectSettings postProcessEffectSettings = (PostProcessEffectSettings)(object)ScriptableObject.CreateInstance(item);
			postProcessEffectSettings.SetAllOverridesTo(state: true, excludeEnabled: false);
			m_BaseSettings.Add(postProcessEffectSettings);
		}
	}

	public void GetActiveVolumes(PostProcessLayer layer, List<PostProcessVolume> results, bool skipDisabled = true, bool skipZeroWeight = true)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		int value = ((LayerMask)(ref layer.volumeLayer)).value;
		Transform volumeTrigger = layer.volumeTrigger;
		bool flag = (Object)(object)volumeTrigger == (Object)null;
		Vector3 val = (flag ? Vector3.zero : volumeTrigger.position);
		OBB val2 = default(OBB);
		foreach (PostProcessVolume item in GrabVolumes(LayerMask.op_Implicit(value)))
		{
			if ((skipDisabled && !((Behaviour)item).enabled) || (Object)(object)item.profileRef == (Object)null || (skipZeroWeight && item.weight <= 0f))
			{
				continue;
			}
			if (item.isGlobal)
			{
				results.Add(item);
			}
			else if (!flag)
			{
				((OBB)(ref val2))..ctor(((Component)item).transform, item.bounds);
				Vector3 val3 = (((OBB)(ref val2)).ClosestPoint(val) - val) / 2f;
				float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
				float num = item.blendDistance * item.blendDistance;
				if (sqrMagnitude <= num)
				{
					results.Add(item);
				}
			}
		}
	}

	public PostProcessVolume GetHighestPriorityVolume(PostProcessLayer layer)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)layer == (Object)null)
		{
			throw new ArgumentNullException("layer");
		}
		return GetHighestPriorityVolume(layer.volumeLayer);
	}

	public PostProcessVolume GetHighestPriorityVolume(LayerMask mask)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		float num = float.NegativeInfinity;
		PostProcessVolume result = null;
		if (m_SortedVolumes.TryGetValue(LayerMask.op_Implicit(mask), out var value))
		{
			foreach (PostProcessVolume item in value)
			{
				if (item.priority > num)
				{
					num = item.priority;
					result = item;
				}
			}
		}
		return result;
	}

	public PostProcessVolume QuickVolume(int layer, float priority, params PostProcessEffectSettings[] settings)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		PostProcessVolume postProcessVolume = new GameObject
		{
			name = "Quick Volume",
			layer = layer,
			hideFlags = (HideFlags)61
		}.AddComponent<PostProcessVolume>();
		postProcessVolume.priority = priority;
		postProcessVolume.isGlobal = true;
		PostProcessProfile profile = postProcessVolume.profile;
		foreach (PostProcessEffectSettings postProcessEffectSettings in settings)
		{
			Assert.IsNotNull<PostProcessEffectSettings>(postProcessEffectSettings, "Trying to create a volume with null effects");
			profile.AddSettings(postProcessEffectSettings);
		}
		return postProcessVolume;
	}

	internal void SetLayerDirty(int layer)
	{
		Assert.IsTrue(layer >= 0 && layer <= 32, "Invalid layer bit");
		foreach (KeyValuePair<int, List<PostProcessVolume>> sortedVolume in m_SortedVolumes)
		{
			int key = sortedVolume.Key;
			if ((key & (1 << layer)) != 0)
			{
				m_SortNeeded[key] = true;
			}
		}
	}

	internal void UpdateVolumeLayer(PostProcessVolume volume, int prevLayer, int newLayer)
	{
		Assert.IsTrue(prevLayer >= 0 && prevLayer <= 32, "Invalid layer bit");
		Unregister(volume, prevLayer);
		Register(volume, newLayer);
	}

	private void Register(PostProcessVolume volume, int layer)
	{
		m_Volumes.Add(volume);
		foreach (KeyValuePair<int, List<PostProcessVolume>> sortedVolume in m_SortedVolumes)
		{
			if ((sortedVolume.Key & (1 << layer)) != 0)
			{
				sortedVolume.Value.Add(volume);
			}
		}
		SetLayerDirty(layer);
	}

	internal void Register(PostProcessVolume volume)
	{
		int layer = ((Component)volume).gameObject.layer;
		Register(volume, layer);
	}

	private void Unregister(PostProcessVolume volume, int layer)
	{
		m_Volumes.Remove(volume);
		foreach (KeyValuePair<int, List<PostProcessVolume>> sortedVolume in m_SortedVolumes)
		{
			if ((sortedVolume.Key & (1 << layer)) != 0)
			{
				sortedVolume.Value.Remove(volume);
			}
		}
	}

	internal void Unregister(PostProcessVolume volume)
	{
		int layer = ((Component)volume).gameObject.layer;
		Unregister(volume, layer);
	}

	private void ReplaceData(PostProcessLayer postProcessLayer)
	{
		foreach (PostProcessEffectSettings baseSetting in m_BaseSettings)
		{
			PostProcessEffectSettings settings = postProcessLayer.GetBundle(((object)baseSetting).GetType()).settings;
			int count = baseSetting.parameters.Count;
			for (int i = 0; i < count; i++)
			{
				settings.parameters[i].SetValue(baseSetting.parameters[i]);
			}
		}
	}

	internal void UpdateSettings(PostProcessLayer postProcessLayer, Camera camera)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		ReplaceData(postProcessLayer);
		int value = ((LayerMask)(ref postProcessLayer.volumeLayer)).value;
		Transform volumeTrigger = postProcessLayer.volumeTrigger;
		bool flag = (Object)(object)volumeTrigger == (Object)null;
		Vector3 val = (flag ? Vector3.zero : volumeTrigger.position);
		OBB val2 = default(OBB);
		foreach (PostProcessVolume item in GrabVolumes(LayerMask.op_Implicit(value)))
		{
			if (!((Behaviour)item).enabled || (Object)(object)item.profileRef == (Object)null || item.weight <= 0f)
			{
				continue;
			}
			List<PostProcessEffectSettings> settings = item.profileRef.settings;
			if (item.isGlobal)
			{
				postProcessLayer.OverrideSettings(settings, Mathf.Clamp01(item.weight));
			}
			else
			{
				if (flag)
				{
					continue;
				}
				((OBB)(ref val2))..ctor(((Component)item).transform, item.bounds);
				Vector3 val3 = (((OBB)(ref val2)).ClosestPoint(val) - val) / 2f;
				float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
				float num = item.blendDistance * item.blendDistance;
				if (!(sqrMagnitude > num))
				{
					float num2 = 1f;
					if (num > 0f)
					{
						num2 = 1f - sqrMagnitude / num;
					}
					postProcessLayer.OverrideSettings(settings, num2 * Mathf.Clamp01(item.weight));
				}
			}
		}
	}

	private List<PostProcessVolume> GrabVolumes(LayerMask mask)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if (!m_SortedVolumes.TryGetValue(LayerMask.op_Implicit(mask), out var value))
		{
			value = new List<PostProcessVolume>();
			foreach (PostProcessVolume volume in m_Volumes)
			{
				if ((LayerMask.op_Implicit(mask) & (1 << ((Component)volume).gameObject.layer)) != 0)
				{
					value.Add(volume);
					m_SortNeeded[LayerMask.op_Implicit(mask)] = true;
				}
			}
			m_SortedVolumes.Add(LayerMask.op_Implicit(mask), value);
		}
		if (m_SortNeeded.TryGetValue(LayerMask.op_Implicit(mask), out var value2) && value2)
		{
			m_SortNeeded[LayerMask.op_Implicit(mask)] = false;
			SortByPriority(value);
		}
		return value;
	}

	private static void SortByPriority(List<PostProcessVolume> volumes)
	{
		Assert.IsNotNull<List<PostProcessVolume>>(volumes, "Trying to sort volumes of non-initialized layer");
		for (int i = 1; i < volumes.Count; i++)
		{
			PostProcessVolume postProcessVolume = volumes[i];
			int num = i - 1;
			while (num >= 0 && volumes[num].priority > postProcessVolume.priority)
			{
				volumes[num + 1] = volumes[num];
				num--;
			}
			volumes[num + 1] = postProcessVolume;
		}
	}

	private static bool IsVolumeRenderedByCamera(PostProcessVolume volume, Camera camera)
	{
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessProfile : ScriptableObject
{
	[Tooltip("A list of all settings currently stored in this profile.")]
	public List<PostProcessEffectSettings> settings = new List<PostProcessEffectSettings>();

	[NonSerialized]
	public bool isDirty = true;

	private void OnEnable()
	{
		settings.RemoveAll((PostProcessEffectSettings x) => (Object)(object)x == (Object)null);
	}

	public T AddSettings<T>() where T : PostProcessEffectSettings
	{
		return (T)AddSettings(typeof(T));
	}

	public PostProcessEffectSettings AddSettings(Type type)
	{
		if (HasSettings(type))
		{
			throw new InvalidOperationException("Effect already exists in the stack");
		}
		PostProcessEffectSettings postProcessEffectSettings = (PostProcessEffectSettings)(object)ScriptableObject.CreateInstance(type);
		((Object)postProcessEffectSettings).hideFlags = (HideFlags)3;
		((Object)postProcessEffectSettings).name = type.Name;
		postProcessEffectSettings.enabled.value = true;
		settings.Add(postProcessEffectSettings);
		isDirty = true;
		return postProcessEffectSettings;
	}

	public PostProcessEffectSettings AddSettings(PostProcessEffectSettings effect)
	{
		if (HasSettings(settings.GetType()))
		{
			throw new InvalidOperationException("Effect already exists in the stack");
		}
		settings.Add(effect);
		isDirty = true;
		return effect;
	}

	public void RemoveSettings<T>() where T : PostProcessEffectSettings
	{
		RemoveSettings(typeof(T));
	}

	public void RemoveSettings(Type type)
	{
		int num = -1;
		for (int i = 0; i < settings.Count; i++)
		{
			if (((object)settings[i]).GetType() == type)
			{
				num = i;
				break;
			}
		}
		if (num < 0)
		{
			throw new InvalidOperationException("Effect doesn't exist in the profile");
		}
		settings.RemoveAt(num);
		isDirty = true;
	}

	public bool HasSettings<T>() where T : PostProcessEffectSettings
	{
		return HasSettings(typeof(T));
	}

	public bool HasSettings(Type type)
	{
		foreach (PostProcessEffectSettings setting in settings)
		{
			if (((object)setting).GetType() == type)
			{
				return true;
			}
		}
		return false;
	}

	public T GetSetting<T>() where T : PostProcessEffectSettings
	{
		foreach (PostProcessEffectSettings setting in settings)
		{
			if (setting is T)
			{
				return setting as T;
			}
		}
		return null;
	}

	public bool TryGetSettings<T>(out T outSetting) where T : PostProcessEffectSettings
	{
		Type typeFromHandle = typeof(T);
		outSetting = null;
		foreach (PostProcessEffectSettings setting in settings)
		{
			if (((object)setting).GetType() == typeFromHandle)
			{
				outSetting = (T)setting;
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PostProcessResources : ScriptableObject
{
	[Serializable]
	public sealed class Shaders
	{
		public Shader bloom;

		public Shader copy;

		public Shader copyStd;

		public Shader copyStdFromTexArray;

		public Shader copyStdFromDoubleWide;

		public Shader discardAlpha;

		public Shader depthOfField;

		public Shader finalPass;

		public Shader grainBaker;

		public Shader motionBlur;

		public Shader temporalAntialiasing;

		public Shader subpixelMorphologicalAntialiasing;

		public Shader texture2dLerp;

		public Shader uber;

		public Shader lut2DBaker;

		public Shader lightMeter;

		public Shader gammaHistogram;

		public Shader waveform;

		public Shader vectorscope;

		public Shader debugOverlays;

		public Shader deferredFog;

		public Shader scalableAO;

		public Shader multiScaleAO;

		public Shader screenSpaceReflections;

		public Shaders Clone()
		{
			return (Shaders)MemberwiseClone();
		}
	}

	[Serializable]
	public sealed class ComputeShaders
	{
		public ComputeShader autoExposure;

		public ComputeShader exposureHistogram;

		public ComputeShader lut3DBaker;

		public ComputeShader texture3dLerp;

		public ComputeShader gammaHistogram;

		public ComputeShader waveform;

		public ComputeShader vectorscope;

		public ComputeShader multiScaleAODownsample1;

		public ComputeShader multiScaleAODownsample2;

		public ComputeShader multiScaleAORender;

		public ComputeShader multiScaleAOUpsample;

		public ComputeShader gaussianDownsample;

		public ComputeShaders Clone()
		{
			return (ComputeShaders)MemberwiseClone();
		}
	}

	[Serializable]
	public sealed class SMAALuts
	{
		public Texture2D area;

		public Texture2D search;
	}

	public Texture2D[] blueNoise64;

	public Texture2D[] blueNoise256;

	public SMAALuts smaaLuts;

	public Shaders shaders;

	public ComputeShaders computeShaders;
}


using System;

[Serializable]
public sealed class Shaders
{
	public Shader bloom;

	public Shader copy;

	public Shader copyStd;

	public Shader copyStdFromTexArray;

	public Shader copyStdFromDoubleWide;

	public Shader discardAlpha;

	public Shader depthOfField;

	public Shader finalPass;

	public Shader grainBaker;

	public Shader motionBlur;

	public Shader temporalAntialiasing;

	public Shader subpixelMorphologicalAntialiasing;

	public Shader texture2dLerp;

	public Shader uber;

	public Shader lut2DBaker;

	public Shader lightMeter;

	public Shader gammaHistogram;

	public Shader waveform;

	public Shader vectorscope;

	public Shader debugOverlays;

	public Shader deferredFog;

	public Shader scalableAO;

	public Shader multiScaleAO;

	public Shader screenSpaceReflections;

	public Shaders Clone()
	{
		return (Shaders)MemberwiseClone();
	}
}


using System;

[Serializable]
public sealed class ComputeShaders
{
	public ComputeShader autoExposure;

	public ComputeShader exposureHistogram;

	public ComputeShader lut3DBaker;

	public ComputeShader texture3dLerp;

	public ComputeShader gammaHistogram;

	public ComputeShader waveform;

	public ComputeShader vectorscope;

	public ComputeShader multiScaleAODownsample1;

	public ComputeShader multiScaleAODownsample2;

	public ComputeShader multiScaleAORender;

	public ComputeShader multiScaleAOUpsample;

	public ComputeShader gaussianDownsample;

	public ComputeShaders Clone()
	{
		return (ComputeShaders)MemberwiseClone();
	}
}


using System;

[Serializable]
public sealed class SMAALuts
{
	public Texture2D area;

	public Texture2D search;
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[AddComponentMenu("Rendering/Post-process Volume", 1001)]
[ExecuteAlways]
public sealed class PostProcessVolume : MonoBehaviour
{
	public PostProcessProfile sharedProfile;

	[Tooltip("Check this box to mark this volume as global. This volume's Profile will be applied to the whole Scene.")]
	public bool isGlobal;

	public Bounds bounds;

	[Min(0f)]
	[Tooltip("The distance (from the attached Collider) to start blending from. A value of 0 means there will be no blending and the Volume overrides will be applied immediatly upon entry to the attached Collider.")]
	public float blendDistance;

	[Tooltip("The total weight of this Volume in the Scene. A value of 0 signifies that it will have no effect, 1 signifies full effect.")]
	[Range(0f, 1f)]
	public float weight = 1f;

	[Tooltip("The volume priority in the stack. A higher value means higher priority. Negative values are supported.")]
	public float priority;

	private int m_PreviousLayer;

	private float m_PreviousPriority;

	private PostProcessProfile m_InternalProfile;

	public PostProcessProfile profile
	{
		get
		{
			if ((Object)(object)m_InternalProfile == (Object)null)
			{
				m_InternalProfile = ScriptableObject.CreateInstance<PostProcessProfile>();
				if ((Object)(object)sharedProfile != (Object)null)
				{
					foreach (PostProcessEffectSettings setting in sharedProfile.settings)
					{
						PostProcessEffectSettings item = Object.Instantiate<PostProcessEffectSettings>(setting);
						m_InternalProfile.settings.Add(item);
					}
				}
			}
			return m_InternalProfile;
		}
		set
		{
			m_InternalProfile = value;
		}
	}

	internal PostProcessProfile profileRef
	{
		get
		{
			if (!((Object)(object)m_InternalProfile == (Object)null))
			{
				return m_InternalProfile;
			}
			return sharedProfile;
		}
	}

	public bool HasInstantiatedProfile()
	{
		return (Object)(object)m_InternalProfile != (Object)null;
	}

	private void OnEnable()
	{
		PostProcessManager.instance.Register(this);
		m_PreviousLayer = ((Component)this).gameObject.layer;
	}

	private void OnDisable()
	{
		PostProcessManager.instance.Unregister(this);
	}

	private void Update()
	{
		int layer = ((Component)this).gameObject.layer;
		if (layer != m_PreviousLayer)
		{
			PostProcessManager.instance.UpdateVolumeLayer(this, m_PreviousLayer, layer);
			m_PreviousLayer = layer;
		}
		if (priority != m_PreviousPriority)
		{
			PostProcessManager.instance.SetLayerDirty(layer);
			m_PreviousPriority = priority;
		}
	}

	private void OnDrawGizmos()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (!isGlobal)
		{
			Vector3 lossyScale = ((Component)this).transform.lossyScale;
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(1f / lossyScale.x, 1f / lossyScale.y, 1f / lossyScale.z);
			Gizmos.matrix = Matrix4x4.TRS(((Component)this).transform.position, ((Component)this).transform.rotation, lossyScale);
			Gizmos.DrawCube(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size);
			Gizmos.DrawWireCube(((Bounds)(ref bounds)).center, ((Bounds)(ref bounds)).size + val * blendDistance * 4f);
			Gizmos.matrix = Matrix4x4.identity;
		}
	}
}


using UnityEngine;

public static class ColorUtilities
{
	private const float logC_cut = 0.011361f;

	private const float logC_a = 5.555556f;

	private const float logC_b = 0.047996f;

	private const float logC_c = 0.244161f;

	private const float logC_d = 0.386036f;

	private const float logC_e = 5.301883f;

	private const float logC_f = 0.092819f;

	public static float StandardIlluminantY(float x)
	{
		return 2.87f * x - 3f * x * x - 0.27509508f;
	}

	public static Vector3 CIExyToLMS(float x, float y)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		float num2 = num * x / y;
		float num3 = num * (1f - x - y) / y;
		float num4 = 0.7328f * num2 + 0.4296f * num - 0.1624f * num3;
		float num5 = -0.7036f * num2 + 1.6975f * num + 0.0061f * num3;
		float num6 = 0.003f * num2 + 0.0136f * num + 0.9834f * num3;
		return new Vector3(num4, num5, num6);
	}

	public static Vector3 ComputeColorBalance(float temperature, float tint)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		float num = temperature / 60f;
		float num2 = tint / 60f;
		float x = 0.31271f - num * ((num < 0f) ? 0.1f : 0.05f);
		float y = StandardIlluminantY(x) + num2 * 0.05f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(0.949237f, 1.03542f, 1.08728f);
		Vector3 val2 = CIExyToLMS(x, y);
		return new Vector3(val.x / val2.x, val.y / val2.y, val.z / val2.z);
	}

	public static Vector3 ColorToLift(Vector4 color)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(color.x, color.y, color.z);
		float num = val.x * 0.2126f + val.y * 0.7152f + val.z * 0.0722f;
		((Vector3)(ref val))..ctor(val.x - num, val.y - num, val.z - num);
		float w = color.w;
		return new Vector3(val.x + w, val.y + w, val.z + w);
	}

	public static Vector3 ColorToInverseGamma(Vector4 color)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(color.x, color.y, color.z);
		float num = val.x * 0.2126f + val.y * 0.7152f + val.z * 0.0722f;
		((Vector3)(ref val))..ctor(val.x - num, val.y - num, val.z - num);
		float num2 = color.w + 1f;
		return new Vector3(1f / Mathf.Max(val.x + num2, 0.001f), 1f / Mathf.Max(val.y + num2, 0.001f), 1f / Mathf.Max(val.z + num2, 0.001f));
	}

	public static Vector3 ColorToGain(Vector4 color)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(color.x, color.y, color.z);
		float num = val.x * 0.2126f + val.y * 0.7152f + val.z * 0.0722f;
		((Vector3)(ref val))..ctor(val.x - num, val.y - num, val.z - num);
		float num2 = color.w + 1f;
		return new Vector3(val.x + num2, val.y + num2, val.z + num2);
	}

	public static float LogCToLinear(float x)
	{
		if (!(x > 0.1530537f))
		{
			return (x - 0.092819f) / 5.301883f;
		}
		return (Mathf.Pow(10f, (x - 0.386036f) / 0.244161f) - 0.047996f) / 5.555556f;
	}

	public static float LinearToLogC(float x)
	{
		if (!(x > 0.011361f))
		{
			return 5.301883f * x + 0.092819f;
		}
		return 0.244161f * Mathf.Log10(5.555556f * x + 0.047996f) + 0.386036f;
	}

	public static uint ToHex(Color c)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		return ((uint)(c.a * 255f) << 24) | ((uint)(c.r * 255f) << 16) | ((uint)(c.g * 255f) << 8) | (uint)(c.b * 255f);
	}

	public static Color ToRGBA(uint hex)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		return new Color((float)((hex >> 16) & 0xFF) / 255f, (float)((hex >> 8) & 0xFF) / 255f, (float)(hex & 0xFF) / 255f, (float)((hex >> 24) & 0xFF) / 255f);
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class HableCurve
{
	private class Segment
	{
		public float offsetX;

		public float offsetY;

		public float scaleX;

		public float scaleY;

		public float lnA;

		public float B;

		public float Eval(float x)
		{
			float num = (x - offsetX) * scaleX;
			float num2 = 0f;
			if (num > 0f)
			{
				num2 = Mathf.Exp(lnA + B * Mathf.Log(num));
			}
			return num2 * scaleY + offsetY;
		}
	}

	private struct DirectParams
	{
		internal float x0;

		internal float y0;

		internal float x1;

		internal float y1;

		internal float W;

		internal float overshootX;

		internal float overshootY;

		internal float gamma;
	}

	public class Uniforms
	{
		private HableCurve parent;

		public Vector4 curve => new Vector4(parent.inverseWhitePoint, parent.x0, parent.x1, 0f);

		public Vector4 toeSegmentA
		{
			get
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[0];
				return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
			}
		}

		public Vector4 toeSegmentB
		{
			get
			{
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[0];
				return new Vector4(segment.lnA, segment.B, 0f, 0f);
			}
		}

		public Vector4 midSegmentA
		{
			get
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[1];
				return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
			}
		}

		public Vector4 midSegmentB
		{
			get
			{
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[1];
				return new Vector4(segment.lnA, segment.B, 0f, 0f);
			}
		}

		public Vector4 shoSegmentA
		{
			get
			{
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[2];
				return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
			}
		}

		public Vector4 shoSegmentB
		{
			get
			{
				//IL_0024: Unknown result type (might be due to invalid IL or missing references)
				Segment segment = parent.m_Segments[2];
				return new Vector4(segment.lnA, segment.B, 0f, 0f);
			}
		}

		internal Uniforms(HableCurve parent)
		{
			this.parent = parent;
		}
	}

	private readonly Segment[] m_Segments = new Segment[3];

	public readonly Uniforms uniforms;

	public float whitePoint { get; private set; }

	public float inverseWhitePoint { get; private set; }

	internal float x0 { get; private set; }

	internal float x1 { get; private set; }

	public HableCurve()
	{
		for (int i = 0; i < 3; i++)
		{
			m_Segments[i] = new Segment();
		}
		uniforms = new Uniforms(this);
	}

	public float Eval(float x)
	{
		float num = x * inverseWhitePoint;
		int num2 = ((!(num < x0)) ? ((num < x1) ? 1 : 2) : 0);
		return m_Segments[num2].Eval(num);
	}

	public void Init(float toeStrength, float toeLength, float shoulderStrength, float shoulderLength, float shoulderAngle, float gamma)
	{
		DirectParams srcParams = default(DirectParams);
		toeLength = Mathf.Pow(Mathf.Clamp01(toeLength), 2.2f);
		toeStrength = Mathf.Clamp01(toeStrength);
		shoulderAngle = Mathf.Clamp01(shoulderAngle);
		shoulderStrength = Mathf.Clamp(shoulderStrength, 1E-05f, 0.99999f);
		shoulderLength = Mathf.Max(0f, shoulderLength);
		gamma = Mathf.Max(1E-05f, gamma);
		float num = toeLength * 0.5f;
		float num2 = (1f - toeStrength) * num;
		float num3 = 1f - num2;
		float num4 = num + num3;
		float num5 = (1f - shoulderStrength) * num3;
		float num6 = num + num5;
		float y = num2 + num5;
		float num7 = RuntimeUtilities.Exp2(shoulderLength) - 1f;
		float w = num4 + num7;
		srcParams.x0 = num;
		srcParams.y0 = num2;
		srcParams.x1 = num6;
		srcParams.y1 = y;
		srcParams.W = w;
		srcParams.gamma = gamma;
		srcParams.overshootX = srcParams.W * 2f * shoulderAngle * shoulderLength;
		srcParams.overshootY = 0.5f * shoulderAngle * shoulderLength;
		InitSegments(srcParams);
	}

	private void InitSegments(DirectParams srcParams)
	{
		DirectParams directParams = srcParams;
		whitePoint = srcParams.W;
		inverseWhitePoint = 1f / srcParams.W;
		directParams.W = 1f;
		directParams.x0 /= srcParams.W;
		directParams.x1 /= srcParams.W;
		directParams.overshootX = srcParams.overshootX / srcParams.W;
		float num = 0f;
		float num2 = 0f;
		AsSlopeIntercept(out var m, out var b, directParams.x0, directParams.x1, directParams.y0, directParams.y1);
		float gamma = srcParams.gamma;
		Segment obj = m_Segments[1];
		obj.offsetX = 0f - b / m;
		obj.offsetY = 0f;
		obj.scaleX = 1f;
		obj.scaleY = 1f;
		obj.lnA = gamma * Mathf.Log(m);
		obj.B = gamma;
		num = EvalDerivativeLinearGamma(m, b, gamma, directParams.x0);
		num2 = EvalDerivativeLinearGamma(m, b, gamma, directParams.x1);
		directParams.y0 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y0, directParams.gamma));
		directParams.y1 = Mathf.Max(1E-05f, Mathf.Pow(directParams.y1, directParams.gamma));
		directParams.overshootY = Mathf.Pow(1f + directParams.overshootY, directParams.gamma) - 1f;
		x0 = directParams.x0;
		x1 = directParams.x1;
		Segment obj2 = m_Segments[0];
		obj2.offsetX = 0f;
		obj2.offsetY = 0f;
		obj2.scaleX = 1f;
		obj2.scaleY = 1f;
		SolveAB(out var lnA, out var B, directParams.x0, directParams.y0, num);
		obj2.lnA = lnA;
		obj2.B = B;
		Segment obj3 = m_Segments[2];
		float num3 = 1f + directParams.overshootX - directParams.x1;
		float y = 1f + directParams.overshootY - directParams.y1;
		SolveAB(out var lnA2, out var B2, num3, y, num2);
		obj3.offsetX = 1f + directParams.overshootX;
		obj3.offsetY = 1f + directParams.overshootY;
		obj3.scaleX = -1f;
		obj3.scaleY = -1f;
		obj3.lnA = lnA2;
		obj3.B = B2;
		float num4 = m_Segments[2].Eval(1f);
		float num5 = 1f / num4;
		m_Segments[0].offsetY *= num5;
		m_Segments[0].scaleY *= num5;
		m_Segments[1].offsetY *= num5;
		m_Segments[1].scaleY *= num5;
		m_Segments[2].offsetY *= num5;
		m_Segments[2].scaleY *= num5;
	}

	private void SolveAB(out float lnA, out float B, float x0, float y0, float m)
	{
		B = m * x0 / y0;
		lnA = Mathf.Log(y0) - B * Mathf.Log(x0);
	}

	private void AsSlopeIntercept(out float m, out float b, float x0, float x1, float y0, float y1)
	{
		float num = y1 - y0;
		float num2 = x1 - x0;
		if (num2 == 0f)
		{
			m = 1f;
		}
		else
		{
			m = num / num2;
		}
		b = y0 - x0 * m;
	}

	private float EvalDerivativeLinearGamma(float m, float b, float g, float x)
	{
		return g * m * Mathf.Pow(m * x + b, g - 1f);
	}
}


private class Segment
{
	public float offsetX;

	public float offsetY;

	public float scaleX;

	public float scaleY;

	public float lnA;

	public float B;

	public float Eval(float x)
	{
		float num = (x - offsetX) * scaleX;
		float num2 = 0f;
		if (num > 0f)
		{
			num2 = Mathf.Exp(lnA + B * Mathf.Log(num));
		}
		return num2 * scaleY + offsetY;
	}
}


private struct DirectParams
{
	internal float x0;

	internal float y0;

	internal float x1;

	internal float y1;

	internal float W;

	internal float overshootX;

	internal float overshootY;

	internal float gamma;
}


public class Uniforms
{
	private HableCurve parent;

	public Vector4 curve => new Vector4(parent.inverseWhitePoint, parent.x0, parent.x1, 0f);

	public Vector4 toeSegmentA
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[0];
			return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
		}
	}

	public Vector4 toeSegmentB
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[0];
			return new Vector4(segment.lnA, segment.B, 0f, 0f);
		}
	}

	public Vector4 midSegmentA
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[1];
			return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
		}
	}

	public Vector4 midSegmentB
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[1];
			return new Vector4(segment.lnA, segment.B, 0f, 0f);
		}
	}

	public Vector4 shoSegmentA
	{
		get
		{
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[2];
			return new Vector4(segment.offsetX, segment.offsetY, segment.scaleX, segment.scaleY);
		}
	}

	public Vector4 shoSegmentB
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			Segment segment = parent.m_Segments[2];
			return new Vector4(segment.lnA, segment.B, 0f, 0f);
		}
	}

	internal Uniforms(HableCurve parent)
	{
		this.parent = parent;
	}
}


public static class HaltonSeq
{
	public static float Get(int index, int radix)
	{
		float num = 0f;
		float num2 = 1f / (float)radix;
		while (index > 0)
		{
			num += (float)(index % radix) * num2;
			index /= radix;
			num2 /= (float)radix;
		}
		return num;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

internal sealed class LogHistogram
{
	public const int rangeMin = -9;

	public const int rangeMax = 9;

	private const int k_Bins = 128;

	public ComputeBuffer data { get; private set; }

	public void Generate(PostProcessRenderContext context)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (data == null)
		{
			data = new ComputeBuffer(128, 4);
		}
		Vector4 histogramScaleOffsetRes = GetHistogramScaleOffsetRes(context);
		ComputeShader exposureHistogram = context.resources.computeShaders.exposureHistogram;
		CommandBuffer command = context.command;
		command.BeginSample("LogHistogram");
		int num = exposureHistogram.FindKernel("KEyeHistogramClear");
		command.SetComputeBufferParam(exposureHistogram, num, "_HistogramBuffer", data);
		uint num2 = default(uint);
		uint num3 = default(uint);
		uint num4 = default(uint);
		exposureHistogram.GetKernelThreadGroupSizes(num, ref num2, ref num3, ref num4);
		command.DispatchCompute(exposureHistogram, num, Mathf.CeilToInt(128f / (float)num2), 1, 1);
		num = exposureHistogram.FindKernel("KEyeHistogram");
		command.SetComputeBufferParam(exposureHistogram, num, "_HistogramBuffer", data);
		command.SetComputeTextureParam(exposureHistogram, num, "_Source", context.source);
		command.SetComputeVectorParam(exposureHistogram, "_ScaleOffsetRes", histogramScaleOffsetRes);
		exposureHistogram.GetKernelThreadGroupSizes(num, ref num2, ref num3, ref num4);
		command.DispatchCompute(exposureHistogram, num, Mathf.CeilToInt(histogramScaleOffsetRes.z / 2f / (float)num2), Mathf.CeilToInt(histogramScaleOffsetRes.w / 2f / (float)num3), 1);
		command.EndSample("LogHistogram");
	}

	public Vector4 GetHistogramScaleOffsetRes(PostProcessRenderContext context)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = 18f;
		float num2 = 1f / num;
		float num3 = 9f * num2;
		return new Vector4(num2, num3, (float)context.width, (float)context.height);
	}

	public void Release()
	{
		if (data != null)
		{
			data.Release();
		}
		data = null;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering.PostProcessing;

internal static class MeshUtilities
{
	private static Dictionary<PrimitiveType, Mesh> s_Primitives;

	private static Dictionary<Type, PrimitiveType> s_ColliderPrimitives;

	static MeshUtilities()
	{
		s_Primitives = new Dictionary<PrimitiveType, Mesh>();
		s_ColliderPrimitives = new Dictionary<Type, PrimitiveType>
		{
			{
				typeof(BoxCollider),
				(PrimitiveType)3
			},
			{
				typeof(SphereCollider),
				(PrimitiveType)0
			},
			{
				typeof(CapsuleCollider),
				(PrimitiveType)1
			}
		};
	}

	internal static Mesh GetColliderMesh(Collider collider)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Type type = ((object)collider).GetType();
		if (type == typeof(MeshCollider))
		{
			return ((MeshCollider)collider).sharedMesh;
		}
		Assert.IsTrue(s_ColliderPrimitives.ContainsKey(type), "Unknown collider");
		return GetPrimitive(s_ColliderPrimitives[type]);
	}

	internal static Mesh GetPrimitive(PrimitiveType primitiveType)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (!s_Primitives.TryGetValue(primitiveType, out var value))
		{
			value = GetBuiltinMesh(primitiveType);
			s_Primitives.Add(primitiveType, value);
		}
		return value;
	}

	private static Mesh GetBuiltinMesh(PrimitiveType primitiveType)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = GameObject.CreatePrimitive(primitiveType);
		Mesh sharedMesh = obj.GetComponent<MeshFilter>().sharedMesh;
		RuntimeUtilities.Destroy((Object)(object)obj);
		return sharedMesh;
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PropertySheet
{
	public MaterialPropertyBlock properties { get; private set; }

	internal Material material { get; private set; }

	internal PropertySheet(Material material)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Expected O, but got Unknown
		this.material = material;
		properties = new MaterialPropertyBlock();
	}

	public void ClearKeywords()
	{
		material.shaderKeywords = null;
	}

	public void EnableKeyword(string keyword)
	{
		material.EnableKeyword(keyword);
	}

	public void DisableKeyword(string keyword)
	{
		material.DisableKeyword(keyword);
	}

	internal void Release()
	{
		RuntimeUtilities.Destroy((Object)(object)material);
		material = null;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public sealed class PropertySheetFactory
{
	private readonly Dictionary<Shader, PropertySheet> m_Sheets;

	public PropertySheetFactory()
	{
		m_Sheets = new Dictionary<Shader, PropertySheet>();
	}

	[Obsolete("Use PropertySheet.Get(Shader) with a direct reference to the Shader instead.")]
	public PropertySheet Get(string shaderName)
	{
		Shader val = Shader.Find(shaderName);
		if ((Object)(object)val == (Object)null)
		{
			throw new ArgumentException($"Invalid shader ({shaderName})");
		}
		return Get(val);
	}

	public PropertySheet Get(Shader shader)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Expected O, but got Unknown
		if ((Object)(object)shader == (Object)null)
		{
			throw new ArgumentException($"Invalid shader ({shader})");
		}
		if (m_Sheets.TryGetValue(shader, out var value))
		{
			return value;
		}
		string name = ((Object)shader).name;
		value = new PropertySheet(new Material(shader)
		{
			name = $"PostProcess - {name.Substring(name.LastIndexOf('/') + 1)}",
			hideFlags = (HideFlags)52
		});
		m_Sheets.Add(shader, value);
		return value;
	}

	public void Release()
	{
		foreach (PropertySheet value in m_Sheets.Values)
		{
			value.Release();
		}
		m_Sheets.Clear();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.SceneManagement;

public static class RuntimeUtilities
{
	private static Texture2D m_WhiteTexture;

	private static Texture3D m_WhiteTexture3D;

	private static Texture2D m_BlackTexture;

	private static Texture3D m_BlackTexture3D;

	private static Texture2D m_TransparentTexture;

	private static Texture3D m_TransparentTexture3D;

	private static Dictionary<int, Texture2D> m_LutStrips = new Dictionary<int, Texture2D>();

	internal static PostProcessResources s_Resources;

	private static Mesh s_FullscreenTriangle;

	private static Material s_CopyStdMaterial;

	private static Material s_CopyStdFromDoubleWideMaterial;

	private static Material s_CopyMaterial;

	private static Material s_CopyFromTexArrayMaterial;

	private static PropertySheet s_CopySheet;

	private static PropertySheet s_CopyFromTexArraySheet;

	private static IEnumerable<Type> m_AssemblyTypes;

	public static Texture2D whiteTexture
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_WhiteTexture == (Object)null)
			{
				m_WhiteTexture = new Texture2D(1, 1, (TextureFormat)5, false)
				{
					name = "White Texture"
				};
				m_WhiteTexture.SetPixel(0, 0, Color.white);
				m_WhiteTexture.Apply();
			}
			return m_WhiteTexture;
		}
	}

	public static Texture3D whiteTexture3D
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_WhiteTexture3D == (Object)null)
			{
				m_WhiteTexture3D = new Texture3D(1, 1, 1, (TextureFormat)5, false)
				{
					name = "White Texture 3D"
				};
				m_WhiteTexture3D.SetPixels((Color[])(object)new Color[1] { Color.white });
				m_WhiteTexture3D.Apply();
			}
			return m_WhiteTexture3D;
		}
	}

	public static Texture2D blackTexture
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_BlackTexture == (Object)null)
			{
				m_BlackTexture = new Texture2D(1, 1, (TextureFormat)5, false)
				{
					name = "Black Texture"
				};
				m_BlackTexture.SetPixel(0, 0, Color.black);
				m_BlackTexture.Apply();
			}
			return m_BlackTexture;
		}
	}

	public static Texture3D blackTexture3D
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_BlackTexture3D == (Object)null)
			{
				m_BlackTexture3D = new Texture3D(1, 1, 1, (TextureFormat)5, false)
				{
					name = "Black Texture 3D"
				};
				m_BlackTexture3D.SetPixels((Color[])(object)new Color[1] { Color.black });
				m_BlackTexture3D.Apply();
			}
			return m_BlackTexture3D;
		}
	}

	public static Texture2D transparentTexture
	{
		get
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Expected O, but got Unknown
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_TransparentTexture == (Object)null)
			{
				m_TransparentTexture = new Texture2D(1, 1, (TextureFormat)5, false)
				{
					name = "Transparent Texture"
				};
				m_TransparentTexture.SetPixel(0, 0, Color.clear);
				m_TransparentTexture.Apply();
			}
			return m_TransparentTexture;
		}
	}

	public static Texture3D transparentTexture3D
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected O, but got Unknown
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)m_TransparentTexture3D == (Object)null)
			{
				m_TransparentTexture3D = new Texture3D(1, 1, 1, (TextureFormat)5, false)
				{
					name = "Transparent Texture 3D"
				};
				m_TransparentTexture3D.SetPixels((Color[])(object)new Color[1] { Color.clear });
				m_TransparentTexture3D.Apply();
			}
			return m_TransparentTexture3D;
		}
	}

	public static Mesh fullscreenTriangle
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Expected O, but got Unknown
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)s_FullscreenTriangle != (Object)null)
			{
				return s_FullscreenTriangle;
			}
			s_FullscreenTriangle = new Mesh
			{
				name = "Fullscreen Triangle"
			};
			s_FullscreenTriangle.SetVertices(new List<Vector3>
			{
				new Vector3(-1f, -1f, 0f),
				new Vector3(-1f, 3f, 0f),
				new Vector3(3f, -1f, 0f)
			});
			s_FullscreenTriangle.SetIndices(new int[3] { 0, 1, 2 }, (MeshTopology)0, 0, false);
			s_FullscreenTriangle.UploadMeshData(false);
			return s_FullscreenTriangle;
		}
	}

	public static Material copyStdMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyStdMaterial != (Object)null)
			{
				return s_CopyStdMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyStdMaterial = new Material(s_Resources.shaders.copyStd)
			{
				name = "PostProcess - CopyStd",
				hideFlags = (HideFlags)61
			};
			return s_CopyStdMaterial;
		}
	}

	public static Material copyStdFromDoubleWideMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyStdFromDoubleWideMaterial != (Object)null)
			{
				return s_CopyStdFromDoubleWideMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyStdFromDoubleWideMaterial = new Material(s_Resources.shaders.copyStdFromDoubleWide)
			{
				name = "PostProcess - CopyStdFromDoubleWide",
				hideFlags = (HideFlags)61
			};
			return s_CopyStdFromDoubleWideMaterial;
		}
	}

	public static Material copyMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyMaterial != (Object)null)
			{
				return s_CopyMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyMaterial = new Material(s_Resources.shaders.copy)
			{
				name = "PostProcess - Copy",
				hideFlags = (HideFlags)61
			};
			return s_CopyMaterial;
		}
	}

	public static Material copyFromTexArrayMaterial
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Expected O, but got Unknown
			if ((Object)(object)s_CopyFromTexArrayMaterial != (Object)null)
			{
				return s_CopyFromTexArrayMaterial;
			}
			Assert.IsNotNull<PostProcessResources>(s_Resources);
			s_CopyFromTexArrayMaterial = new Material(s_Resources.shaders.copyStdFromTexArray)
			{
				name = "PostProcess - CopyFromTexArray",
				hideFlags = (HideFlags)61
			};
			return s_CopyFromTexArrayMaterial;
		}
	}

	public static PropertySheet copySheet
	{
		get
		{
			if (s_CopySheet == null)
			{
				s_CopySheet = new PropertySheet(copyMaterial);
			}
			return s_CopySheet;
		}
	}

	public static PropertySheet copyFromTexArraySheet
	{
		get
		{
			if (s_CopyFromTexArraySheet == null)
			{
				s_CopyFromTexArraySheet = new PropertySheet(copyFromTexArrayMaterial);
			}
			return s_CopyFromTexArraySheet;
		}
	}

	public static bool scriptableRenderPipelineActive => (Object)(object)GraphicsSettings.renderPipelineAsset != (Object)null;

	public static bool supportsDeferredShading
	{
		get
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Invalid comparison between Unknown and I4
			if (!scriptableRenderPipelineActive)
			{
				return (int)GraphicsSettings.GetShaderMode((BuiltinShaderType)0) > 0;
			}
			return true;
		}
	}

	public static bool supportsDepthNormals
	{
		get
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Invalid comparison between Unknown and I4
			if (!scriptableRenderPipelineActive)
			{
				return (int)GraphicsSettings.GetShaderMode((BuiltinShaderType)4) > 0;
			}
			return true;
		}
	}

	public static bool isSinglePassStereoEnabled => false;

	public static bool isVREnabled => false;

	public static bool isAndroidOpenGL
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Invalid comparison between Unknown and I4
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Invalid comparison between Unknown and I4
			if ((int)Application.platform == 11)
			{
				return (int)SystemInfo.graphicsDeviceType != 21;
			}
			return false;
		}
	}

	public static RenderTextureFormat defaultHDRRenderTextureFormat => (RenderTextureFormat)9;

	public static bool isLinearColorSpace => (int)QualitySettings.activeColorSpace == 1;

	public static Texture2D GetLutStrip(int size)
	{
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Expected O, but got Unknown
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (!m_LutStrips.TryGetValue(size, out var value))
		{
			int num = size * size;
			int num2 = size;
			Color[] array = (Color[])(object)new Color[num * num2];
			float num3 = 1f / ((float)size - 1f);
			for (int i = 0; i < size; i++)
			{
				int num4 = i * size;
				float num5 = (float)i * num3;
				for (int j = 0; j < size; j++)
				{
					float num6 = (float)j * num3;
					for (int k = 0; k < size; k++)
					{
						float num7 = (float)k * num3;
						array[j * num + num4 + k] = new Color(num7, num6, num5);
					}
				}
			}
			TextureFormat val = (TextureFormat)17;
			if (!val.IsSupported())
			{
				val = (TextureFormat)5;
			}
			value = new Texture2D(size * size, size, val, false, true)
			{
				name = "Strip Lut" + size,
				hideFlags = (HideFlags)52,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				anisoLevel = 0
			};
			value.SetPixels(array);
			value.Apply();
			m_LutStrips.Add(size, value);
		}
		return value;
	}

	public static void SetRenderTargetWithLoadStoreAction(this CommandBuffer cmd, RenderTargetIdentifier rt, RenderBufferLoadAction loadAction, RenderBufferStoreAction storeAction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(rt, loadAction, storeAction);
	}

	public static void SetRenderTargetWithLoadStoreAction(this CommandBuffer cmd, RenderTargetIdentifier color, RenderBufferLoadAction colorLoadAction, RenderBufferStoreAction colorStoreAction, RenderTargetIdentifier depth, RenderBufferLoadAction depthLoadAction, RenderBufferStoreAction depthStoreAction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(color, colorLoadAction, colorStoreAction, depth, depthLoadAction, depthStoreAction);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, bool clear = false, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetRenderTargetWithLoadStoreAction(destination, (RenderBufferLoadAction)((!viewport.HasValue) ? 2 : 0), (RenderBufferStoreAction)0);
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, copyMaterial, 0, 0);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, RenderBufferLoadAction loadAction, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		bool num = (int)loadAction == 1;
		if (num)
		{
			loadAction = (RenderBufferLoadAction)2;
		}
		cmd.SetRenderTargetWithLoadStoreAction(destination, (RenderBufferLoadAction)((!viewport.HasValue) ? ((int)loadAction) : 0), (RenderBufferStoreAction)0);
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		if (num)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		cmd.BlitFullscreenTriangle(source, destination, propertySheet, pass, (RenderBufferLoadAction)(clear ? 1 : 2), viewport);
	}

	public static void BlitFullscreenTriangleFromDoubleWide(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material material, int pass, int eye)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(0.5f, 1f, 0f, 0f);
		if (eye == 1)
		{
			val.z = 0.5f;
		}
		cmd.SetGlobalVector(ShaderIDs.UVScaleOffset, val);
		cmd.BuiltinBlit(source, destination, material, pass);
	}

	public static void BlitFullscreenTriangleToDoubleWide(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, int eye)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(0.5f, 1f, -0.5f, 0f);
		if (eye == 1)
		{
			val.z = 0.5f;
		}
		propertySheet.EnableKeyword("STEREO_DOUBLEWIDE_TARGET");
		propertySheet.properties.SetVector(ShaderIDs.PosScaleOffset, val);
		cmd.BlitFullscreenTriangle(source, destination, propertySheet, 0, clear: false, null);
	}

	public static void BlitFullscreenTriangleFromTexArray(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, int depthSlice = -1)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetGlobalFloat(ShaderIDs.DepthSlice, (float)depthSlice);
		cmd.SetRenderTargetWithLoadStoreAction(destination, (RenderBufferLoadAction)2, (RenderBufferStoreAction)0);
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangleToTexArray(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, PropertySheet propertySheet, int pass, bool clear = false, int depthSlice = -1)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetGlobalFloat(ShaderIDs.DepthSlice, (float)depthSlice);
		cmd.SetRenderTarget(destination, 0, (CubemapFace)(-1), -1);
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		RenderBufferLoadAction val = (RenderBufferLoadAction)((!viewport.HasValue) ? 2 : 0);
		if (clear)
		{
			cmd.SetRenderTargetWithLoadStoreAction(destination, val, (RenderBufferStoreAction)0, depth, val, (RenderBufferStoreAction)0);
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		else
		{
			cmd.SetRenderTargetWithLoadStoreAction(destination, val, (RenderBufferStoreAction)0, depth, (RenderBufferLoadAction)0, (RenderBufferStoreAction)0);
		}
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BlitFullscreenTriangle(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier[] destinations, RenderTargetIdentifier depth, PropertySheet propertySheet, int pass, bool clear = false, Rect? viewport = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetGlobalTexture(ShaderIDs.MainTex, source);
		cmd.SetRenderTarget(destinations, depth);
		if (viewport.HasValue)
		{
			cmd.SetViewport(viewport.Value);
		}
		if (clear)
		{
			cmd.ClearRenderTarget(true, true, Color.clear);
		}
		cmd.DrawMesh(fullscreenTriangle, Matrix4x4.identity, propertySheet.material, 0, pass, propertySheet.properties);
	}

	public static void BuiltinBlit(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(destination, (RenderBufferLoadAction)2, (RenderBufferStoreAction)0);
		destination = RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)1);
		cmd.Blit(source, destination);
	}

	public static void BuiltinBlit(this CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination, Material mat, int pass = 0)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		cmd.SetRenderTarget(destination, (RenderBufferLoadAction)2, (RenderBufferStoreAction)0);
		destination = RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)1);
		cmd.Blit(source, destination, mat, pass);
	}

	public static void CopyTexture(CommandBuffer cmd, RenderTargetIdentifier source, RenderTargetIdentifier destination)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		if ((int)SystemInfo.copyTextureSupport > 0)
		{
			cmd.CopyTexture(source, destination);
		}
		else
		{
			cmd.BlitFullscreenTriangle(source, destination, clear: false, null);
		}
	}

	public static bool isFloatingPointFormat(RenderTextureFormat format)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Invalid comparison between Unknown and I4
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Invalid comparison between Unknown and I4
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Invalid comparison between Unknown and I4
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Invalid comparison between Unknown and I4
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Invalid comparison between Unknown and I4
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Invalid comparison between Unknown and I4
		if ((int)format != 9 && (int)format != 2 && (int)format != 11 && (int)format != 12 && (int)format != 13 && (int)format != 14 && (int)format != 15)
		{
			return (int)format == 22;
		}
		return true;
	}

	public static void Destroy(Object obj)
	{
		if (obj != (Object)null)
		{
			Object.Destroy(obj);
		}
	}

	public static bool IsResolvedDepthAvailable(Camera camera)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Invalid comparison between Unknown and I4
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Invalid comparison between Unknown and I4
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Invalid comparison between Unknown and I4
		GraphicsDeviceType graphicsDeviceType = SystemInfo.graphicsDeviceType;
		if ((int)camera.actualRenderingPath == 3)
		{
			if ((int)graphicsDeviceType != 2 && (int)graphicsDeviceType != 18)
			{
				return (int)graphicsDeviceType == 14;
			}
			return true;
		}
		return false;
	}

	public static void DestroyProfile(PostProcessProfile profile, bool destroyEffects)
	{
		if (destroyEffects)
		{
			foreach (PostProcessEffectSettings setting in profile.settings)
			{
				Destroy((Object)(object)setting);
			}
		}
		Destroy((Object)(object)profile);
	}

	public static void DestroyVolume(PostProcessVolume volume, bool destroyProfile, bool destroyGameObject = false)
	{
		if (destroyProfile)
		{
			DestroyProfile(volume.profileRef, destroyEffects: true);
		}
		GameObject gameObject = ((Component)volume).gameObject;
		Destroy((Object)(object)volume);
		if (destroyGameObject)
		{
			Destroy((Object)(object)gameObject);
		}
	}

	public static bool IsPostProcessingActive(PostProcessLayer layer)
	{
		if ((Object)(object)layer != (Object)null)
		{
			return ((Behaviour)layer).enabled;
		}
		return false;
	}

	public static bool IsTemporalAntialiasingActive(PostProcessLayer layer)
	{
		if (IsPostProcessingActive(layer) && layer.antialiasingMode == PostProcessLayer.Antialiasing.TemporalAntialiasing)
		{
			return layer.temporalAntialiasing.IsSupported();
		}
		return false;
	}

	public static IEnumerable<T> GetAllSceneObjects<T>() where T : Component
	{
		Queue<Transform> queue = new Queue<Transform>();
		Scene activeScene = SceneManager.GetActiveScene();
		GameObject[] rootGameObjects = ((Scene)(ref activeScene)).GetRootGameObjects();
		GameObject[] array = rootGameObjects;
		foreach (GameObject val in array)
		{
			queue.Enqueue(val.transform);
			T component = val.GetComponent<T>();
			if ((Object)(object)component != (Object)null)
			{
				yield return component;
			}
		}
		while (queue.Count > 0)
		{
			foreach (Transform item in queue.Dequeue())
			{
				Transform val2 = item;
				queue.Enqueue(val2);
				T component2 = ((Component)val2).GetComponent<T>();
				if ((Object)(object)component2 != (Object)null)
				{
					yield return component2;
				}
			}
		}
	}

	public static void CreateIfNull<T>(ref T obj) where T : class, new()
	{
		if (obj == null)
		{
			obj = new T();
		}
	}

	public static float Exp2(float x)
	{
		return Mathf.Exp(x * 0.6931472f);
	}

	public static Matrix4x4 GetJitteredPerspectiveProjectionMatrix(Camera camera, Vector2 offset)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		float nearClipPlane = camera.nearClipPlane;
		_ = camera.farClipPlane;
		float num = Mathf.Tan(MathF.PI / 360f * camera.fieldOfView) * nearClipPlane;
		float num2 = num * camera.aspect;
		offset.x *= num2 / (0.5f * (float)camera.pixelWidth);
		offset.y *= num / (0.5f * (float)camera.pixelHeight);
		Matrix4x4 projectionMatrix = camera.projectionMatrix;
		ref Matrix4x4 reference = ref projectionMatrix;
		((Matrix4x4)(ref reference))[0, 2] = ((Matrix4x4)(ref reference))[0, 2] + offset.x / num2;
		reference = ref projectionMatrix;
		((Matrix4x4)(ref reference))[1, 2] = ((Matrix4x4)(ref reference))[1, 2] + offset.y / num;
		return projectionMatrix;
	}

	public static Matrix4x4 GetJitteredOrthographicProjectionMatrix(Camera camera, Vector2 offset)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		float orthographicSize = camera.orthographicSize;
		float num = orthographicSize * camera.aspect;
		offset.x *= num / (0.5f * (float)camera.pixelWidth);
		offset.y *= orthographicSize / (0.5f * (float)camera.pixelHeight);
		float num2 = offset.x - num;
		float num3 = offset.x + num;
		float num4 = offset.y + orthographicSize;
		float num5 = offset.y - orthographicSize;
		return Matrix4x4.Ortho(num2, num3, num5, num4, camera.nearClipPlane, camera.farClipPlane);
	}

	public static Matrix4x4 GenerateJitteredProjectionMatrixFromOriginal(PostProcessRenderContext context, Matrix4x4 origProj, Vector2 jitter)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		FrustumPlanes decomposeProjection = ((Matrix4x4)(ref origProj)).decomposeProjection;
		float num = Math.Abs(decomposeProjection.top) + Math.Abs(decomposeProjection.bottom);
		float num2 = Math.Abs(decomposeProjection.left) + Math.Abs(decomposeProjection.right);
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(jitter.x * num2 / (float)context.screenWidth, jitter.y * num / (float)context.screenHeight);
		decomposeProjection.left += val.x;
		decomposeProjection.right += val.x;
		decomposeProjection.top += val.y;
		decomposeProjection.bottom += val.y;
		return Matrix4x4.Frustum(decomposeProjection);
	}

	public static IEnumerable<Type> GetAllAssemblyTypes()
	{
		if (m_AssemblyTypes == null)
		{
			m_AssemblyTypes = AppDomain.CurrentDomain.GetAssemblies().SelectMany(delegate(Assembly t)
			{
				Type[] result = new Type[0];
				try
				{
					result = t.GetTypes();
				}
				catch
				{
				}
				return result;
			});
		}
		return m_AssemblyTypes;
	}

	public static T GetAttribute<T>(this Type type) where T : Attribute
	{
		Assert.IsTrue(type.IsDefined(typeof(T), inherit: false), "Attribute not found");
		return (T)type.GetCustomAttributes(typeof(T), inherit: false)[0];
	}

	public static Attribute[] GetMemberAttributes<TType, TValue>(Expression<Func<TType, TValue>> expr)
	{
		Expression expression = expr;
		if (expression is LambdaExpression)
		{
			expression = ((LambdaExpression)expression).Body;
		}
		if (expression.NodeType == ExpressionType.MemberAccess)
		{
			return ((FieldInfo)((MemberExpression)expression).Member).GetCustomAttributes(inherit: false).Cast<Attribute>().ToArray();
		}
		throw new InvalidOperationException();
	}

	public static string GetFieldPath<TType, TValue>(Expression<Func<TType, TValue>> expr)
	{
		if (expr.Body.NodeType == ExpressionType.MemberAccess)
		{
			MemberExpression memberExpression = expr.Body as MemberExpression;
			List<string> list = new List<string>();
			while (memberExpression != null)
			{
				list.Add(memberExpression.Member.Name);
				memberExpression = memberExpression.Expression as MemberExpression;
			}
			StringBuilder stringBuilder = new StringBuilder();
			for (int num = list.Count - 1; num >= 0; num--)
			{
				stringBuilder.Append(list[num]);
				if (num > 0)
				{
					stringBuilder.Append('.');
				}
			}
			return stringBuilder.ToString();
		}
		throw new InvalidOperationException();
	}
}


using UnityEngine;

internal static class ShaderIDs
{
	internal static readonly int MainTex = Shader.PropertyToID("_MainTex");

	internal static readonly int Jitter = Shader.PropertyToID("_Jitter");

	internal static readonly int Sharpness = Shader.PropertyToID("_Sharpness");

	internal static readonly int FinalBlendParameters = Shader.PropertyToID("_FinalBlendParameters");

	internal static readonly int HistoryTex = Shader.PropertyToID("_HistoryTex");

	internal static readonly int SMAA_Flip = Shader.PropertyToID("_SMAA_Flip");

	internal static readonly int SMAA_Flop = Shader.PropertyToID("_SMAA_Flop");

	internal static readonly int AOParams = Shader.PropertyToID("_AOParams");

	internal static readonly int AOColor = Shader.PropertyToID("_AOColor");

	internal static readonly int OcclusionTexture1 = Shader.PropertyToID("_OcclusionTexture1");

	internal static readonly int OcclusionTexture2 = Shader.PropertyToID("_OcclusionTexture2");

	internal static readonly int SAOcclusionTexture = Shader.PropertyToID("_SAOcclusionTexture");

	internal static readonly int MSVOcclusionTexture = Shader.PropertyToID("_MSVOcclusionTexture");

	internal static readonly int DepthCopy = Shader.PropertyToID("DepthCopy");

	internal static readonly int LinearDepth = Shader.PropertyToID("LinearDepth");

	internal static readonly int LowDepth1 = Shader.PropertyToID("LowDepth1");

	internal static readonly int LowDepth2 = Shader.PropertyToID("LowDepth2");

	internal static readonly int LowDepth3 = Shader.PropertyToID("LowDepth3");

	internal static readonly int LowDepth4 = Shader.PropertyToID("LowDepth4");

	internal static readonly int TiledDepth1 = Shader.PropertyToID("TiledDepth1");

	internal static readonly int TiledDepth2 = Shader.PropertyToID("TiledDepth2");

	internal static readonly int TiledDepth3 = Shader.PropertyToID("TiledDepth3");

	internal static readonly int TiledDepth4 = Shader.PropertyToID("TiledDepth4");

	internal static readonly int Occlusion1 = Shader.PropertyToID("Occlusion1");

	internal static readonly int Occlusion2 = Shader.PropertyToID("Occlusion2");

	internal static readonly int Occlusion3 = Shader.PropertyToID("Occlusion3");

	internal static readonly int Occlusion4 = Shader.PropertyToID("Occlusion4");

	internal static readonly int Combined1 = Shader.PropertyToID("Combined1");

	internal static readonly int Combined2 = Shader.PropertyToID("Combined2");

	internal static readonly int Combined3 = Shader.PropertyToID("Combined3");

	internal static readonly int SSRResolveTemp = Shader.PropertyToID("_SSRResolveTemp");

	internal static readonly int Noise = Shader.PropertyToID("_Noise");

	internal static readonly int Test = Shader.PropertyToID("_Test");

	internal static readonly int Resolve = Shader.PropertyToID("_Resolve");

	internal static readonly int History = Shader.PropertyToID("_History");

	internal static readonly int ViewMatrix = Shader.PropertyToID("_ViewMatrix");

	internal static readonly int InverseViewMatrix = Shader.PropertyToID("_InverseViewMatrix");

	internal static readonly int InverseProjectionMatrix = Shader.PropertyToID("_InverseProjectionMatrix");

	internal static readonly int ScreenSpaceProjectionMatrix = Shader.PropertyToID("_ScreenSpaceProjectionMatrix");

	internal static readonly int Params2 = Shader.PropertyToID("_Params2");

	internal static readonly int FogColor = Shader.PropertyToID("_FogColor");

	internal static readonly int FogParams = Shader.PropertyToID("_FogParams");

	internal static readonly int VelocityScale = Shader.PropertyToID("_VelocityScale");

	internal static readonly int MaxBlurRadius = Shader.PropertyToID("_MaxBlurRadius");

	internal static readonly int RcpMaxBlurRadius = Shader.PropertyToID("_RcpMaxBlurRadius");

	internal static readonly int VelocityTex = Shader.PropertyToID("_VelocityTex");

	internal static readonly int Tile2RT = Shader.PropertyToID("_Tile2RT");

	internal static readonly int Tile4RT = Shader.PropertyToID("_Tile4RT");

	internal static readonly int Tile8RT = Shader.PropertyToID("_Tile8RT");

	internal static readonly int TileMaxOffs = Shader.PropertyToID("_TileMaxOffs");

	internal static readonly int TileMaxLoop = Shader.PropertyToID("_TileMaxLoop");

	internal static readonly int TileVRT = Shader.PropertyToID("_TileVRT");

	internal static readonly int NeighborMaxTex = Shader.PropertyToID("_NeighborMaxTex");

	internal static readonly int LoopCount = Shader.PropertyToID("_LoopCount");

	internal static readonly int DepthOfFieldTemp = Shader.PropertyToID("_DepthOfFieldTemp");

	internal static readonly int DepthOfFieldTex = Shader.PropertyToID("_DepthOfFieldTex");

	internal static readonly int Distance = Shader.PropertyToID("_Distance");

	internal static readonly int LensCoeff = Shader.PropertyToID("_LensCoeff");

	internal static readonly int MaxCoC = Shader.PropertyToID("_MaxCoC");

	internal static readonly int RcpMaxCoC = Shader.PropertyToID("_RcpMaxCoC");

	internal static readonly int RcpAspect = Shader.PropertyToID("_RcpAspect");

	internal static readonly int CoCTex = Shader.PropertyToID("_CoCTex");

	internal static readonly int TaaParams = Shader.PropertyToID("_TaaParams");

	internal static readonly int AutoExposureTex = Shader.PropertyToID("_AutoExposureTex");

	internal static readonly int HistogramBuffer = Shader.PropertyToID("_HistogramBuffer");

	internal static readonly int Params = Shader.PropertyToID("_Params");

	internal static readonly int ScaleOffsetRes = Shader.PropertyToID("_ScaleOffsetRes");

	internal static readonly int BloomTex = Shader.PropertyToID("_BloomTex");

	internal static readonly int SampleScale = Shader.PropertyToID("_SampleScale");

	internal static readonly int Threshold = Shader.PropertyToID("_Threshold");

	internal static readonly int ColorIntensity = Shader.PropertyToID("_ColorIntensity");

	internal static readonly int Bloom_DirtTex = Shader.PropertyToID("_Bloom_DirtTex");

	internal static readonly int Bloom_Settings = Shader.PropertyToID("_Bloom_Settings");

	internal static readonly int Bloom_Color = Shader.PropertyToID("_Bloom_Color");

	internal static readonly int Bloom_DirtTileOffset = Shader.PropertyToID("_Bloom_DirtTileOffset");

	internal static readonly int ChromaticAberration_Amount = Shader.PropertyToID("_ChromaticAberration_Amount");

	internal static readonly int ChromaticAberration_SpectralLut = Shader.PropertyToID("_ChromaticAberration_SpectralLut");

	internal static readonly int Distortion_CenterScale = Shader.PropertyToID("_Distortion_CenterScale");

	internal static readonly int Distortion_Amount = Shader.PropertyToID("_Distortion_Amount");

	internal static readonly int Lut2D = Shader.PropertyToID("_Lut2D");

	internal static readonly int Lut3D = Shader.PropertyToID("_Lut3D");

	internal static readonly int Lut3D_Params = Shader.PropertyToID("_Lut3D_Params");

	internal static readonly int Lut2D_Params = Shader.PropertyToID("_Lut2D_Params");

	internal static readonly int UserLut2D_Params = Shader.PropertyToID("_UserLut2D_Params");

	internal static readonly int PostExposure = Shader.PropertyToID("_PostExposure");

	internal static readonly int ColorBalance = Shader.PropertyToID("_ColorBalance");

	internal static readonly int ColorFilter = Shader.PropertyToID("_ColorFilter");

	internal static readonly int HueSatCon = Shader.PropertyToID("_HueSatCon");

	internal static readonly int Brightness = Shader.PropertyToID("_Brightness");

	internal static readonly int ChannelMixerRed = Shader.PropertyToID("_ChannelMixerRed");

	internal static readonly int ChannelMixerGreen = Shader.PropertyToID("_ChannelMixerGreen");

	internal static readonly int ChannelMixerBlue = Shader.PropertyToID("_ChannelMixerBlue");

	internal static readonly int Lift = Shader.PropertyToID("_Lift");

	internal static readonly int InvGamma = Shader.PropertyToID("_InvGamma");

	internal static readonly int Gain = Shader.PropertyToID("_Gain");

	internal static readonly int Curves = Shader.PropertyToID("_Curves");

	internal static readonly int CustomToneCurve = Shader.PropertyToID("_CustomToneCurve");

	internal static readonly int ToeSegmentA = Shader.PropertyToID("_ToeSegmentA");

	internal static readonly int ToeSegmentB = Shader.PropertyToID("_ToeSegmentB");

	internal static readonly int MidSegmentA = Shader.PropertyToID("_MidSegmentA");

	internal static readonly int MidSegmentB = Shader.PropertyToID("_MidSegmentB");

	internal static readonly int ShoSegmentA = Shader.PropertyToID("_ShoSegmentA");

	internal static readonly int ShoSegmentB = Shader.PropertyToID("_ShoSegmentB");

	internal static readonly int MaskMode = Shader.PropertyToID("_MaskMode");

	internal static readonly int MaskIntensity = Shader.PropertyToID("_MaskIntensity");

	internal static readonly int Vignette_Color = Shader.PropertyToID("_Vignette_Color");

	internal static readonly int Vignette_Center = Shader.PropertyToID("_Vignette_Center");

	internal static readonly int Vignette_Settings = Shader.PropertyToID("_Vignette_Settings");

	internal static readonly int Vignette_Mask = Shader.PropertyToID("_Vignette_Mask");

	internal static readonly int Vignette_Opacity = Shader.PropertyToID("_Vignette_Opacity");

	internal static readonly int Vignette_Mode = Shader.PropertyToID("_Vignette_Mode");

	internal static readonly int Grain_Params1 = Shader.PropertyToID("_Grain_Params1");

	internal static readonly int Grain_Params2 = Shader.PropertyToID("_Grain_Params2");

	internal static readonly int GrainTex = Shader.PropertyToID("_GrainTex");

	internal static readonly int Phase = Shader.PropertyToID("_Phase");

	internal static readonly int GrainNoiseParameters = Shader.PropertyToID("_NoiseParameters");

	internal static readonly int LumaInAlpha = Shader.PropertyToID("_LumaInAlpha");

	internal static readonly int DitheringTex = Shader.PropertyToID("_DitheringTex");

	internal static readonly int Dithering_Coords = Shader.PropertyToID("_Dithering_Coords");

	internal static readonly int From = Shader.PropertyToID("_From");

	internal static readonly int To = Shader.PropertyToID("_To");

	internal static readonly int Interp = Shader.PropertyToID("_Interp");

	internal static readonly int TargetColor = Shader.PropertyToID("_TargetColor");

	internal static readonly int HalfResFinalCopy = Shader.PropertyToID("_HalfResFinalCopy");

	internal static readonly int WaveformSource = Shader.PropertyToID("_WaveformSource");

	internal static readonly int WaveformBuffer = Shader.PropertyToID("_WaveformBuffer");

	internal static readonly int VectorscopeBuffer = Shader.PropertyToID("_VectorscopeBuffer");

	internal static readonly int RenderViewportScaleFactor = Shader.PropertyToID("_RenderViewportScaleFactor");

	internal static readonly int UVTransform = Shader.PropertyToID("_UVTransform");

	internal static readonly int DepthSlice = Shader.PropertyToID("_DepthSlice");

	internal static readonly int UVScaleOffset = Shader.PropertyToID("_UVScaleOffset");

	internal static readonly int PosScaleOffset = Shader.PropertyToID("_PosScaleOffset");
}


using System;
using UnityEngine;
using UnityEngine.Assertions;

[Serializable]
public sealed class Spline
{
	public const int k_Precision = 128;

	public const float k_Step = 1f / 128f;

	public AnimationCurve curve;

	[SerializeField]
	private bool m_Loop;

	[SerializeField]
	private float m_ZeroValue;

	[SerializeField]
	private float m_Range;

	private AnimationCurve m_InternalLoopingCurve;

	private int frameCount = -1;

	public float[] cachedData;

	public Spline(AnimationCurve curve, float zeroValue, bool loop, Vector2 bounds)
	{
		Assert.IsNotNull<AnimationCurve>(curve);
		this.curve = curve;
		m_ZeroValue = zeroValue;
		m_Loop = loop;
		m_Range = ((Vector2)(ref bounds)).magnitude;
		cachedData = new float[128];
	}

	public void Cache(int frame)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected O, but got Unknown
		if (frame == frameCount)
		{
			return;
		}
		int length = curve.length;
		if (m_Loop && length > 1)
		{
			if (m_InternalLoopingCurve == null)
			{
				m_InternalLoopingCurve = new AnimationCurve();
			}
			Keyframe val = curve[length - 1];
			((Keyframe)(ref val)).time = ((Keyframe)(ref val)).time - m_Range;
			Keyframe val2 = curve[0];
			((Keyframe)(ref val2)).time = ((Keyframe)(ref val2)).time + m_Range;
			m_InternalLoopingCurve.keys = curve.keys;
			m_InternalLoopingCurve.AddKey(val);
			m_InternalLoopingCurve.AddKey(val2);
		}
		for (int i = 0; i < 128; i++)
		{
			cachedData[i] = Evaluate((float)i * (1f / 128f), length);
		}
		frameCount = Time.renderedFrameCount;
	}

	public float Evaluate(float t, int length)
	{
		if (length == 0)
		{
			return m_ZeroValue;
		}
		if (!m_Loop || length == 1)
		{
			return curve.Evaluate(t);
		}
		return m_InternalLoopingCurve.Evaluate(t);
	}

	public float Evaluate(float t)
	{
		return Evaluate(t, curve.length);
	}

	public override int GetHashCode()
	{
		return 17 * 23 + ((object)curve).GetHashCode();
	}
}


using System.Collections.Generic;
using UnityEngine;

internal class TargetPool
{
	private readonly List<int> m_Pool;

	private int m_Current;

	internal TargetPool()
	{
		m_Pool = new List<int>();
		Get();
	}

	internal int Get()
	{
		int result = Get(m_Current);
		m_Current++;
		return result;
	}

	private int Get(int i)
	{
		if (m_Pool.Count > i)
		{
			return m_Pool[i];
		}
		while (m_Pool.Count <= i)
		{
			m_Pool.Add(Shader.PropertyToID("_TargetPool" + i));
		}
		return m_Pool[i];
	}

	internal void Reset()
	{
		m_Current = 0;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;

public static class TextureFormatUtilities
{
	private static Dictionary<int, RenderTextureFormat> s_FormatAliasMap;

	private static Dictionary<int, bool> s_SupportedRenderTextureFormats;

	private static Dictionary<int, bool> s_SupportedTextureFormats;

	static TextureFormatUtilities()
	{
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		s_FormatAliasMap = new Dictionary<int, RenderTextureFormat>
		{
			{
				1,
				(RenderTextureFormat)0
			},
			{
				2,
				(RenderTextureFormat)5
			},
			{
				3,
				(RenderTextureFormat)0
			},
			{
				4,
				(RenderTextureFormat)0
			},
			{
				5,
				(RenderTextureFormat)0
			},
			{
				7,
				(RenderTextureFormat)4
			},
			{
				9,
				(RenderTextureFormat)15
			},
			{
				10,
				(RenderTextureFormat)0
			},
			{
				12,
				(RenderTextureFormat)0
			},
			{
				13,
				(RenderTextureFormat)5
			},
			{
				14,
				(RenderTextureFormat)0
			},
			{
				15,
				(RenderTextureFormat)15
			},
			{
				16,
				(RenderTextureFormat)13
			},
			{
				17,
				(RenderTextureFormat)2
			},
			{
				18,
				(RenderTextureFormat)14
			},
			{
				19,
				(RenderTextureFormat)12
			},
			{
				20,
				(RenderTextureFormat)11
			},
			{
				22,
				(RenderTextureFormat)2
			},
			{
				26,
				(RenderTextureFormat)16
			},
			{
				27,
				(RenderTextureFormat)13
			},
			{
				24,
				(RenderTextureFormat)2
			},
			{
				25,
				(RenderTextureFormat)0
			},
			{
				28,
				(RenderTextureFormat)0
			},
			{
				29,
				(RenderTextureFormat)0
			},
			{
				30,
				(RenderTextureFormat)0
			},
			{
				31,
				(RenderTextureFormat)0
			},
			{
				32,
				(RenderTextureFormat)0
			},
			{
				33,
				(RenderTextureFormat)0
			},
			{
				34,
				(RenderTextureFormat)0
			},
			{
				45,
				(RenderTextureFormat)0
			},
			{
				46,
				(RenderTextureFormat)0
			},
			{
				47,
				(RenderTextureFormat)0
			},
			{
				48,
				(RenderTextureFormat)0
			},
			{
				49,
				(RenderTextureFormat)0
			},
			{
				50,
				(RenderTextureFormat)0
			},
			{
				51,
				(RenderTextureFormat)0
			},
			{
				52,
				(RenderTextureFormat)0
			},
			{
				53,
				(RenderTextureFormat)0
			}
		};
		s_SupportedRenderTextureFormats = new Dictionary<int, bool>();
		foreach (object value3 in Enum.GetValues(typeof(RenderTextureFormat)))
		{
			if ((int)value3 >= 0 && !IsObsolete(value3))
			{
				bool value = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)value3);
				s_SupportedRenderTextureFormats[(int)value3] = value;
			}
		}
		s_SupportedTextureFormats = new Dictionary<int, bool>();
		foreach (object value4 in Enum.GetValues(typeof(TextureFormat)))
		{
			if ((int)value4 >= 0 && !IsObsolete(value4))
			{
				bool value2 = SystemInfo.SupportsTextureFormat((TextureFormat)value4);
				s_SupportedTextureFormats[(int)value4] = value2;
			}
		}
	}

	private static bool IsObsolete(object value)
	{
		ObsoleteAttribute[] array = (ObsoleteAttribute[])value.GetType().GetField(value.ToString()).GetCustomAttributes(typeof(ObsoleteAttribute), inherit: false);
		if (array != null)
		{
			return array.Length != 0;
		}
		return false;
	}

	public static RenderTextureFormat GetUncompressedRenderTextureFormat(Texture texture)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Expected I4, but got Unknown
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<Texture>(texture);
		if (texture is RenderTexture)
		{
			return ((RenderTexture)((texture is RenderTexture) ? texture : null)).format;
		}
		if (texture is Texture2D)
		{
			TextureFormat format = ((Texture2D)texture).format;
			if (!s_FormatAliasMap.TryGetValue((int)format, out var value))
			{
				throw new NotSupportedException("Texture format not supported");
			}
			return value;
		}
		return (RenderTextureFormat)7;
	}

	internal static bool IsSupported(this RenderTextureFormat format)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected I4, but got Unknown
		s_SupportedRenderTextureFormats.TryGetValue((int)format, out var value);
		return value;
	}

	internal static bool IsSupported(this TextureFormat format)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected I4, but got Unknown
		s_SupportedTextureFormats.TryGetValue((int)format, out var value);
		return value;
	}
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

internal class TextureLerper
{
	private static TextureLerper m_Instance;

	private CommandBuffer m_Command;

	private PropertySheetFactory m_PropertySheets;

	private PostProcessResources m_Resources;

	private List<RenderTexture> m_Recycled;

	private List<RenderTexture> m_Actives;

	internal static TextureLerper instance
	{
		get
		{
			if (m_Instance == null)
			{
				m_Instance = new TextureLerper();
			}
			return m_Instance;
		}
	}

	private TextureLerper()
	{
		m_Recycled = new List<RenderTexture>();
		m_Actives = new List<RenderTexture>();
	}

	internal void BeginFrame(PostProcessRenderContext context)
	{
		m_Command = context.command;
		m_PropertySheets = context.propertySheets;
		m_Resources = context.resources;
	}

	internal void EndFrame()
	{
		if (m_Recycled.Count > 0)
		{
			foreach (RenderTexture item in m_Recycled)
			{
				RuntimeUtilities.Destroy((Object)(object)item);
			}
			m_Recycled.Clear();
		}
		if (m_Actives.Count <= 0)
		{
			return;
		}
		foreach (RenderTexture active in m_Actives)
		{
			m_Recycled.Add(active);
		}
		m_Actives.Clear();
	}

	private RenderTexture Get(RenderTextureFormat format, int w, int h, int d = 1, bool enableRandomWrite = false, bool force3D = false)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Invalid comparison between Unknown and I4
		RenderTexture val = null;
		int count = m_Recycled.Count;
		int i;
		for (i = 0; i < count; i++)
		{
			RenderTexture val2 = m_Recycled[i];
			if (((Texture)val2).width == w && ((Texture)val2).height == h && val2.volumeDepth == d && val2.format == format && val2.enableRandomWrite == enableRandomWrite && (!force3D || (int)((Texture)val2).dimension == 3))
			{
				val = val2;
				break;
			}
		}
		if ((Object)(object)val == (Object)null)
		{
			TextureDimension dimension = (TextureDimension)((d > 1 || force3D) ? 3 : 2);
			val = new RenderTexture(w, h, 0, format)
			{
				dimension = dimension,
				filterMode = (FilterMode)1,
				wrapMode = (TextureWrapMode)1,
				anisoLevel = 0,
				volumeDepth = d,
				enableRandomWrite = enableRandomWrite
			};
			val.Create();
		}
		else
		{
			m_Recycled.RemoveAt(i);
		}
		m_Actives.Add(val);
		return val;
	}

	internal Texture Lerp(Texture from, Texture to, float t)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<Texture>(from);
		Assert.IsNotNull<Texture>(to);
		Assert.AreEqual(from.width, to.width);
		Assert.AreEqual(from.height, to.height);
		if ((Object)(object)from == (Object)(object)to)
		{
			return from;
		}
		if (t <= 0f)
		{
			return from;
		}
		if (t >= 1f)
		{
			return to;
		}
		RenderTexture val;
		if (from is Texture3D || (from is RenderTexture && ((RenderTexture)from).volumeDepth > 1))
		{
			int num = ((from is Texture3D) ? ((Texture3D)from).depth : ((RenderTexture)from).volumeDepth);
			int num2 = Mathf.Max(Mathf.Max(from.width, from.height), num);
			val = Get((RenderTextureFormat)2, from.width, from.height, num, enableRandomWrite: true, force3D: true);
			ComputeShader texture3dLerp = m_Resources.computeShaders.texture3dLerp;
			int num3 = texture3dLerp.FindKernel("KTexture3DLerp");
			m_Command.SetComputeVectorParam(texture3dLerp, "_DimensionsAndLerp", new Vector4((float)from.width, (float)from.height, (float)num, t));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_Output", RenderTargetIdentifier.op_Implicit((Texture)(object)val));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_From", RenderTargetIdentifier.op_Implicit(from));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_To", RenderTargetIdentifier.op_Implicit(to));
			uint num4 = default(uint);
			uint num5 = default(uint);
			uint num6 = default(uint);
			texture3dLerp.GetKernelThreadGroupSizes(num3, ref num4, ref num5, ref num6);
			Assert.AreEqual(num4, num5);
			int num7 = Mathf.CeilToInt((float)num2 / (float)num4);
			int num8 = Mathf.CeilToInt((float)num2 / (float)num6);
			m_Command.DispatchCompute(texture3dLerp, num3, num7, num7, num8);
			return (Texture)(object)val;
		}
		RenderTextureFormat uncompressedRenderTextureFormat = TextureFormatUtilities.GetUncompressedRenderTextureFormat(to);
		val = Get(uncompressedRenderTextureFormat, to.width, to.height);
		PropertySheet propertySheet = m_PropertySheets.Get(m_Resources.shaders.texture2dLerp);
		propertySheet.properties.SetTexture(ShaderIDs.To, to);
		propertySheet.properties.SetFloat(ShaderIDs.Interp, t);
		m_Command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(from), RenderTargetIdentifier.op_Implicit((Texture)(object)val), propertySheet, 0, clear: false, null);
		return (Texture)(object)val;
	}

	internal Texture Lerp(Texture from, Color to, float t)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<Texture>(from);
		if ((double)t < 1E-05)
		{
			return from;
		}
		RenderTexture val;
		if (from is Texture3D || (from is RenderTexture && ((RenderTexture)from).volumeDepth > 1))
		{
			int num = ((from is Texture3D) ? ((Texture3D)from).depth : ((RenderTexture)from).volumeDepth);
			int num2 = Mathf.Max(Mathf.Max(from.width, from.height), num);
			val = Get((RenderTextureFormat)2, from.width, from.height, num, enableRandomWrite: true, force3D: true);
			ComputeShader texture3dLerp = m_Resources.computeShaders.texture3dLerp;
			int num3 = texture3dLerp.FindKernel("KTexture3DLerpToColor");
			m_Command.SetComputeVectorParam(texture3dLerp, "_DimensionsAndLerp", new Vector4((float)from.width, (float)from.height, (float)num, t));
			m_Command.SetComputeVectorParam(texture3dLerp, "_TargetColor", new Vector4(to.r, to.g, to.b, to.a));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_Output", RenderTargetIdentifier.op_Implicit((Texture)(object)val));
			m_Command.SetComputeTextureParam(texture3dLerp, num3, "_From", RenderTargetIdentifier.op_Implicit(from));
			int num4 = Mathf.CeilToInt((float)num2 / 4f);
			m_Command.DispatchCompute(texture3dLerp, num3, num4, num4, num4);
			return (Texture)(object)val;
		}
		RenderTextureFormat uncompressedRenderTextureFormat = TextureFormatUtilities.GetUncompressedRenderTextureFormat(from);
		val = Get(uncompressedRenderTextureFormat, from.width, from.height);
		PropertySheet propertySheet = m_PropertySheets.Get(m_Resources.shaders.texture2dLerp);
		propertySheet.properties.SetVector(ShaderIDs.TargetColor, new Vector4(to.r, to.g, to.b, to.a));
		propertySheet.properties.SetFloat(ShaderIDs.Interp, t);
		m_Command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(from), RenderTargetIdentifier.op_Implicit((Texture)(object)val), propertySheet, 1, clear: false, null);
		return (Texture)(object)val;
	}

	internal void Clear()
	{
		foreach (RenderTexture active in m_Actives)
		{
			RuntimeUtilities.Destroy((Object)(object)active);
		}
		foreach (RenderTexture item in m_Recycled)
		{
			RuntimeUtilities.Destroy((Object)(object)item);
		}
		m_Actives.Clear();
		m_Recycled.Clear();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Math;
using UnityEngine;

public static class Output
{
	public struct Entry
	{
		public string Message;

		public string Stacktrace;

		public string Type;

		public int Time;
	}

	public static bool installed = false;

	public static List<Entry> HistoryOutput = new List<Entry>();

	public static event Action<string, string, LogType> OnMessage;

	public static event Action<string, string, LogType> OnPostMessage;

	public static void Install()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		if (!installed)
		{
			Application.logMessageReceived += new LogCallback(LogHandler);
			installed = true;
		}
	}

	public static void LogHandler(string log, string stacktrace, LogType type)
	{
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		if ((Output.OnMessage == null && Output.OnPostMessage == null) || log.StartsWith("Kinematic body only supports Speculative Continuous collision detection") || log.StartsWith("Non-convex MeshCollider with non-kinematic Rigidbody is no longer supported") || log.StartsWith("Too many layers used to exclude objects from lighting") || log.StartsWith("Skipped frame because GfxDevice") || log.StartsWith("Your current multi-scene setup has inconsistent Lighting") || log.Contains("HandleD3DDeviceLost") || log.Contains("ResetD3DDevice") || log.Contains("dev->Reset") || log.Contains("D3Dwindow device not lost anymore") || log.Contains("D3D device reset") || log.Contains("group < 0xfff") || log.Contains("Mesh can not have more than 65000 vert") || log.Contains("Trying to add (Layout Rebuilder for)") || log.Contains("Coroutine continue failure") || log.Contains("No texture data available to upload") || log.Contains("Trying to reload asset from disk that is not") || log.Contains("Unable to find shaders used for the terrain engine.") || log.Contains("Canvas element contains more than 65535 vertices") || log.Contains("RectTransform.set_anchorMin") || log.Contains("FMOD failed to initialize the output device") || log.Contains("Cannot create FMOD::Sound") || log.Contains("invalid utf-16 sequence") || log.Contains("missing surrogate tail") || log.Contains("Failed to create agent because it is not close enough to the Nav") || log.Contains("user-provided triangle mesh descriptor is invalid") || log.Contains("Releasing render texture that is set as"))
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Facepunch.Output.LogHandler", 0);
		try
		{
			try
			{
				Output.OnMessage?.Invoke(log, stacktrace, type);
			}
			catch (Exception)
			{
			}
			try
			{
				Output.OnPostMessage?.Invoke(log, stacktrace, type);
			}
			catch (Exception)
			{
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		HistoryOutput.Add(new Entry
		{
			Message = log,
			Stacktrace = stacktrace,
			Type = ((object)(LogType)(ref type)/*cast due to .constrained prefix*/).ToString(),
			Time = Epoch.Current
		});
		while (HistoryOutput.Count > 65536)
		{
			HistoryOutput.RemoveAt(0);
		}
	}
}


public struct Entry
{
	public string Message;

	public string Stacktrace;

	public string Type;

	public int Time;
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rcon;
using Facepunch.Rust.Profiling;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using UnityEngine;

public class RCon
{
	public struct Command
	{
		public IPAddress Ip;

		public int ConnectionId;

		public string Name;

		public string Message;

		public int Identifier;
	}

	public enum LogType
	{
		Generic,
		Error,
		Warning,
		Chat,
		Report,
		ClientPerf,
		Subscription
	}

	public struct Response
	{
		public string Message;

		public int Identifier;

		[JsonConverter(typeof(StringEnumConverter))]
		public LogType Type;

		public string Stacktrace;
	}

	internal struct BannedAddresses
	{
		public IPAddress addr;

		public float banTime;
	}

	public static class ReservedIdentifiers
	{
		public const int PlayerPostionsUpdate = -64001;

		public const int FoundationsUpdate = -64002;
	}

	internal class RConClient
	{
		private Socket socket;

		private bool isAuthorised;

		private string connectionName;

		private int lastMessageID = -1;

		private bool runningConsoleCommand;

		private bool utf8Mode;

		internal RConClient(Socket cl)
		{
			socket = cl;
			socket.NoDelay = true;
			connectionName = socket.RemoteEndPoint.ToString();
		}

		internal bool IsValid()
		{
			return socket != null;
		}

		internal void Update()
		{
			if (socket == null)
			{
				return;
			}
			if (!socket.Connected)
			{
				Close("Disconnected");
				return;
			}
			int available = socket.Available;
			if (available < 14)
			{
				return;
			}
			if (available > 4096)
			{
				Close("overflow");
				return;
			}
			byte[] buffer = new byte[available];
			socket.Receive(buffer);
			using BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer, writable: false), utf8Mode ? Encoding.UTF8 : Encoding.ASCII);
			int num = binaryReader.ReadInt32();
			if (available < num)
			{
				Close("invalid packet");
				return;
			}
			lastMessageID = binaryReader.ReadInt32();
			int type = binaryReader.ReadInt32();
			string msg = ReadNullTerminatedString(binaryReader);
			ReadNullTerminatedString(binaryReader);
			if (!HandleMessage(type, msg))
			{
				Close("invalid packet");
			}
			else
			{
				lastMessageID = -1;
			}
		}

		internal bool HandleMessage(int type, string msg)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			if (!isAuthorised)
			{
				return HandleMessage_UnAuthed(type, msg);
			}
			if (type == SERVERDATA_SWITCH_UTF8)
			{
				utf8Mode = true;
				return true;
			}
			if (type == SERVERDATA_EXECCOMMAND)
			{
				Debug.Log((object)("[RCON][" + connectionName + "] " + msg));
				runningConsoleCommand = true;
				ConsoleSystem.Run(Option.Server, msg, Array.Empty<object>());
				runningConsoleCommand = false;
				Reply(-1, SERVERDATA_RESPONSE_VALUE, "");
				return true;
			}
			if (type == SERVERDATA_RESPONSE_VALUE)
			{
				Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
				return true;
			}
			Debug.Log((object)("[RCON][" + connectionName + "] Unhandled: " + lastMessageID + " -> " + type + " -> " + msg));
			return false;
		}

		internal bool HandleMessage_UnAuthed(int type, string msg)
		{
			if (type != SERVERDATA_AUTH)
			{
				BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
				Close("Invalid Command - Not Authed");
				return false;
			}
			Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
			isAuthorised = Password == msg;
			if (!isAuthorised)
			{
				Reply(-1, SERVERDATA_AUTH_RESPONSE, "");
				BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
				Close("Invalid Password");
				return true;
			}
			Reply(lastMessageID, SERVERDATA_AUTH_RESPONSE, "");
			Debug.Log((object)("[RCON] Auth: " + connectionName));
			Output.OnMessage += Output_OnMessage;
			return true;
		}

		private void Output_OnMessage(string message, string stacktrace, LogType type)
		{
			if (isAuthorised && IsValid())
			{
				if (lastMessageID != -1 && runningConsoleCommand)
				{
					Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, message);
				}
				Reply(0, SERVERDATA_CONSOLE_LOG, message);
			}
		}

		internal void Reply(int id, int type, string msg)
		{
			MemoryStream memoryStream = new MemoryStream(1024);
			using BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
			if (utf8Mode)
			{
				byte[] bytes = Encoding.UTF8.GetBytes(msg);
				int value = 10 + bytes.Length;
				binaryWriter.Write(value);
				binaryWriter.Write(id);
				binaryWriter.Write(type);
				binaryWriter.Write(bytes);
			}
			else
			{
				int value2 = 10 + msg.Length;
				binaryWriter.Write(value2);
				binaryWriter.Write(id);
				binaryWriter.Write(type);
				foreach (char c in msg)
				{
					binaryWriter.Write((sbyte)c);
				}
			}
			binaryWriter.Write((sbyte)0);
			binaryWriter.Write((sbyte)0);
			binaryWriter.Flush();
			try
			{
				socket.Send(memoryStream.GetBuffer(), (int)memoryStream.Position, SocketFlags.None);
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)("Error sending rcon reply: " + ex));
				Close("Exception");
			}
		}

		internal void Close(string strReasn)
		{
			Output.OnMessage -= Output_OnMessage;
			if (socket != null)
			{
				Debug.Log((object)("[RCON][" + connectionName + "] Disconnected: " + strReasn));
				socket.Close();
				socket = null;
			}
		}

		internal string ReadNullTerminatedString(BinaryReader read)
		{
			string text = "";
			do
			{
				if (read.BaseStream.Position == read.BaseStream.Length)
				{
					return "";
				}
				char c = read.ReadChar();
				if (c == '\0')
				{
					return text;
				}
				text += c;
			}
			while (text.Length <= 8192);
			return string.Empty;
		}
	}

	internal class RConListener
	{
		private TcpListener server;

		private List<RConClient> clients = new List<RConClient>();

		internal RConListener()
		{
			IPAddress address = IPAddress.Any;
			if (!IPAddress.TryParse(Ip, out address))
			{
				address = IPAddress.Any;
			}
			server = new TcpListener(address, Port);
			try
			{
				server.Start();
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)("Couldn't start RCON Listener: " + ex.Message));
				server = null;
			}
		}

		internal void Shutdown()
		{
			if (server != null)
			{
				server.Stop();
				server = null;
			}
		}

		internal void Cycle()
		{
			if (server != null)
			{
				ProcessConnections();
				RemoveDeadClients();
				UpdateClients();
			}
		}

		private void ProcessConnections()
		{
			if (!server.Pending())
			{
				return;
			}
			Socket socket = server.AcceptSocket();
			if (socket != null)
			{
				IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
				if (Interface.CallHook("OnRconConnection", (object)iPEndPoint.Address) != null)
				{
					socket.Close();
				}
				else if (IsBanned(iPEndPoint.Address))
				{
					Debug.Log((object)("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString()));
					socket.Close();
				}
				else
				{
					clients.Add(new RConClient(socket));
				}
			}
		}

		private void UpdateClients()
		{
			foreach (RConClient client in clients)
			{
				client.Update();
			}
		}

		private void RemoveDeadClients()
		{
			clients.RemoveAll((RConClient x) => !x.IsValid());
		}
	}

	public static string Password = "";

	[ServerVar(Help = "Port to listen for RCON connections")]
	public static int Port = 0;

	[ServerVar(Help = "IP Address to listen for RCON connections")]
	public static string Ip = "";

	[ServerVar(Help = "If set to true, use websocket RCON. If set to false use legacy, source engine RCON. Source engine RCON is DEPRECATED")]
	public static bool Web = true;

	[ServerVar(Help = "If true, RCON commands will be printed in the console")]
	public static bool Print = false;

	private static bool _enableSubscriptions;

	internal static RConListener listener = null;

	public static Listener listenerNew = null;

	private static ConcurrentQueue<Command> Commands = new ConcurrentQueue<Command>();

	private static float lastRunTime = 0f;

	internal static List<BannedAddresses> bannedAddresses = new List<BannedAddresses>();

	private static int responseIdentifier;

	private static int responseConnection = -1;

	private static bool isInput;

	private static Stopwatch timer = new Stopwatch();

	internal static int SERVERDATA_AUTH = 3;

	internal static int SERVERDATA_EXECCOMMAND = 2;

	internal static int SERVERDATA_AUTH_RESPONSE = 2;

	internal static int SERVERDATA_RESPONSE_VALUE = 0;

	internal static int SERVERDATA_CONSOLE_LOG = 4;

	internal static int SERVERDATA_SWITCH_UTF8 = 5;

	public static bool HasSubscribers
	{
		get
		{
			if (EnableSubscriptions)
			{
				return listenerNew.HasSubscribers;
			}
			return false;
		}
	}

	[ServerVar(Help = "If true, allow RCON connections to subscribe to server events. This could be a performance hit and should only be used if you need it.", Saved = true, ShowInAdminUI = true)]
	public static bool EnableSubscriptions
	{
		get
		{
			return _enableSubscriptions;
		}
		set
		{
			if (_enableSubscriptions != value)
			{
				_enableSubscriptions = value;
				if (value)
				{
					ServerSubscriptions.StartSubscribeFeed();
				}
				else
				{
					ServerSubscriptions.StopSubscribeFeed();
				}
			}
		}
	}

	[ServerVar(Help = "Ban an IP address from RCON, preventing it from connecting and kick any clients from this IP, this is permanent and persistent")]
	public static void ban_ip(Arg arg)
	{
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
		}
		else if (arg.Args.Length < 1)
		{
			arg.ReplyWith("Usage: rcon.ban_ip <ip or cidr network>");
		}
		else
		{
			arg.ReplyWith(listenerNew.BanIP(arg.Args[0]) ? ("Banned " + arg.Args[0]) : (arg.Args[0] + " is not a valid IP address or CIDR formatted network."));
		}
	}

	[ServerVar(Help = "Unban an IP address from connecting to RCON, will also remove all attempt history")]
	public static void unban_ip(Arg arg)
	{
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		if (arg.Args.Length < 1)
		{
			arg.ReplyWith("Usage: rcon.unban_ip <ip>");
			return;
		}
		try
		{
			bool flag = listenerNew.UnbanIP(arg.Args[0]);
			arg.ReplyWith(flag ? ("Unbanned IP " + arg.Args[0]) : ("IP " + arg.Args[0] + " was not banned"));
		}
		catch
		{
			arg.ReplyWith("Invalid IP address");
		}
	}

	[ServerVar(Help = "Clear all failed login attempts")]
	public static void clear_rcon_failed_logins(Arg arg)
	{
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		listenerNew.ClearFailedIPData();
		arg.ReplyWith("Cleared failed login attempts");
	}

	[ServerVar(Help = "Print a table of permanently banned IPs and networks. Use '--json' to return a JSON object")]
	public static void print_rcon_bans(Arg arg)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		bool flag = arg.HasArg("--json", true);
		IList<IPNetwork> bannedNetworks = listenerNew.GetBannedNetworks();
		TextTable val = new TextTable();
		val.AddColumns(new string[4] { "address", "prefix", "netmask", "cidr" });
		foreach (IPNetwork item in bannedNetworks)
		{
			IPNetwork current = item;
			string[] obj = new string[4]
			{
				((IPNetwork)(ref current)).NetworkAddress().ToString(),
				null,
				null,
				null
			};
			byte prefixLength = current.PrefixLength;
			obj[1] = prefixLength.ToString();
			obj[2] = ((IPNetwork)(ref current)).Netmask().ToString();
			obj[3] = ((object)(IPNetwork)(ref current)/*cast due to .constrained prefix*/).ToString();
			val.AddRow(obj);
		}
		arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Print a table of clients with failed passwords.  Use '--json' to return a JSON object")]
	public static void print_rcon_failed_logins(Arg arg)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		bool flag = arg.HasArg("--json", true);
		Dictionary<IPAddress, FailedIPData> failedIPs = listenerNew.GetFailedIPs();
		TextTable val = new TextTable();
		val.AddColumns(new string[4] { "ip", "attempts", "banned", "ban_time" });
		foreach (KeyValuePair<IPAddress, FailedIPData> item in failedIPs)
		{
			val.AddRow(new string[4]
			{
				item.Key.ToString(),
				item.Value.Attempts.ToString(),
				item.Value.IsBanned.ToString(),
				((int)item.Value.BanTime).ToString()
			});
		}
		arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Print a table of connected RCON clients. Use '--json' to return a JSON object")]
	public static void print_rcon_clients(Arg arg)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		if (listenerNew == null)
		{
			arg.ReplyWith("No RCON server running");
			return;
		}
		bool flag = arg.HasArg("--json", true);
		IList<RconClientStats> clientStats = listenerNew.GetClientStats();
		TextTable val = new TextTable();
		val.AddColumns(new string[9] { "index", "connection_id", "ip", "port", "connected_time", "inbound_messages", "outbound_messages", "broadcast_messages", "subscribed" });
		for (int i = 0; i < clientStats.Count; i++)
		{
			RconClientStats val2 = clientStats[i];
			TimeSpan timeSpan = DateTime.UtcNow.Subtract(val2.ConnectedAt);
			val.AddRow(new string[9]
			{
				i.ToString(),
				val2.ConnectionId.ToString(),
				val2.IP.ToString(),
				val2.Port.ToString(),
				Math.Floor(timeSpan.TotalSeconds).ToString(),
				val2.RecievedMessages.ToString(),
				val2.SentMessages.ToString(),
				val2.BroadcastedMessages.ToString(),
				val2.IsSubscribed.ToString()
			});
		}
		arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
	}

	[ServerVar(Help = "Clears all subscribers from the server.")]
	public static void clear_subscribers(Arg arg)
	{
		listenerNew.ClearSubscribers();
		arg.ReplyWith("Cleared subscribers");
	}

	[ServerVar(Help = "Un/Subscribes the current RCON connection to changes in server state. This could be a performance hit and should only be used if you need it.")]
	public static void subscribe(Arg arg)
	{
		if (!EnableSubscriptions)
		{
			arg.ReplyWith("Subscriptions are disabled. Enable them with enablesubscriptions");
			return;
		}
		if (!arg.IsRcon || ((Option)(ref arg.Option)).RconConnectionId == 0)
		{
			arg.ReplyWith("Must be an RCON connection to subscribe to server state");
			return;
		}
		bool flag = SetEventSubscriber(((Option)(ref arg.Option)).RconConnectionId);
		arg.ReplyWith(flag ? "Subscribed" : "Unsubscribed");
	}

	public static void Initialize()
	{
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Expected O, but got Unknown
		if (Interface.CallHook("IOnRconInitialize") != null)
		{
			return;
		}
		if (Port == 0)
		{
			Port = Server.port;
		}
		Password = CommandLine.GetSwitch("-rcon.password", CommandLine.GetSwitch("+rcon.password", ""));
		if (Password.Length < 8)
		{
			Debug.Log((object)"\r\n*******************************************************\r\n**                                                   **\r\n** RCON password length is very insecure.            **\r\n** Support for passwords less than 8 characters may  **\r\n** be removed in the future.                         **\r\n**                                                   **\r\n*******************************************************\r\n");
		}
		switch (Password.ToLower())
		{
		case "changeme":
		case "abc123":
		case "qwerty":
		case "qwerty123":
		case "123456":
		case "000000":
		case "password123":
		case "password":
		case "":
			Debug.Log((object)"\r\n*******************************************************\r\n**                                                   **\r\n** RCON password is very insecure, RCON is disabled. **\r\n**                                                   **\r\n*******************************************************\r\n");
			return;
		}
		Output.OnMessage += OnMessage;
		if (Web)
		{
			listenerNew = new Listener();
			string serverFolder = Server.GetServerFolder("cfg");
			listenerNew.BansFile = serverFolder + "/rcon-bans.cfg";
			if (!string.IsNullOrEmpty(Ip))
			{
				listenerNew.Address = Ip;
			}
			listenerNew.Password = Password;
			listenerNew.Port = Port;
			listenerNew.SslCertificate = CommandLine.GetSwitch("-rcon.ssl", CommandLine.GetSwitch("+rcon.ssl", (string)null));
			listenerNew.SslCertificatePassword = CommandLine.GetSwitch("-rcon.sslpwd", CommandLine.GetSwitch("+rcon.sslpwd", (string)null));
			listenerNew.OnMessage = delegate(IPAddress ip, int id, string msg)
			{
				Command item = JsonConvert.DeserializeObject<Command>(msg);
				item.Ip = ip;
				item.ConnectionId = id;
				Commands.Enqueue(item);
			};
			listenerNew.Start();
			Debug.Log((object)$"WebSocket RCON Started on {Ip}:{Port}");
		}
		else
		{
			listener = new RConListener();
			Debug.Log((object)("RCON Started on " + Port));
			Debug.Log((object)"\r\n*********************************************************************\r\n**                                                                 **\r\n** Source engine style TCP RCON is deprecated and will be removed. **\r\n** Please switch to Websocket RCON by setting rcon.web to true     **\r\n**                                                                 **\r\n*********************************************************************");
		}
	}

	public static void Shutdown()
	{
		if (listenerNew != null)
		{
			listenerNew.Shutdown();
			listenerNew = null;
		}
		if (listener != null)
		{
			listener.Shutdown();
			listener = null;
		}
	}

	public static void SendMessageToSubscribers(string message, int identifier = -1)
	{
		if (listenerNew != null)
		{
			Response response = default(Response);
			response.Identifier = identifier;
			response.Message = message;
			response.Type = LogType.Subscription;
			string text = JsonConvert.SerializeObject((object)response, (Formatting)1);
			listenerNew.SendMessageToSubscribers(text);
		}
	}

	public static void Broadcast(LogType type, object obj)
	{
		if (listenerNew != null)
		{
			string message = JsonConvert.SerializeObject(obj, (Formatting)1);
			Broadcast(type, message);
		}
	}

	public static void Broadcast(LogType type, string message)
	{
		if (listenerNew != null && !string.IsNullOrWhiteSpace(message))
		{
			Response response = default(Response);
			response.Identifier = -1;
			response.Message = message;
			response.Type = type;
			if (responseConnection < 0)
			{
				listenerNew.BroadcastMessage(JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
			else
			{
				listenerNew.SendMessage(responseConnection, JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
		}
	}

	public static void Update()
	{
		Command result;
		while (Commands.TryDequeue(out result))
		{
			OnCommand(result);
		}
		if (listener == null || lastRunTime + 0.02f >= Time.realtimeSinceStartup)
		{
			return;
		}
		lastRunTime = Time.realtimeSinceStartup;
		try
		{
			bannedAddresses.RemoveAll((BannedAddresses x) => x.banTime < Time.realtimeSinceStartup);
			listener.Cycle();
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)"Rcon Exception");
			Debug.LogException(ex);
		}
	}

	public static void BanIP(IPAddress addr, float seconds)
	{
		RCon.bannedAddresses.RemoveAll((BannedAddresses x) => x.addr == addr);
		BannedAddresses bannedAddresses = default(BannedAddresses);
		bannedAddresses.addr = addr;
		bannedAddresses.banTime = Time.realtimeSinceStartup + seconds;
	}

	public static bool IsBanned(IPAddress addr)
	{
		return bannedAddresses.Count((BannedAddresses x) => x.addr == addr && x.banTime > Time.realtimeSinceStartup) > 0;
	}

	private static void OnCommand(Command cmd)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			responseIdentifier = cmd.Identifier;
			responseConnection = cmd.ConnectionId;
			isInput = true;
			if (Print)
			{
				Debug.Log((object)("[rcon] " + cmd.Ip?.ToString() + ": " + cmd.Message));
			}
			isInput = false;
			timer.Restart();
			Option val = Option.Server;
			val = ((Option)(ref val)).Quiet();
			string text = ConsoleSystem.Run(((Option)(ref val)).WithRconId(cmd.ConnectionId), cmd.Message, Array.Empty<object>());
			timer.Stop();
			TimeSpan elapsed = timer.Elapsed;
			if (RconProfiler.mode > 0)
			{
				RconProfiler.ExecutionTime += elapsed;
			}
			if (elapsed > RuntimeProfiler.RconCommandWarningThreshold)
			{
				LagSpikeProfiler.RconCommand(timer.Elapsed, cmd.Message);
			}
			if (text != null)
			{
				OnMessage(text, string.Empty, (LogType)3);
			}
		}
		finally
		{
			responseIdentifier = 0;
			responseConnection = -1;
		}
	}

	private static void OnMessage(string message, string stacktrace, LogType type)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Invalid comparison between Unknown and I4
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Invalid comparison between Unknown and I4
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Invalid comparison between Unknown and I4
		if (!isInput && listenerNew != null)
		{
			Response response = default(Response);
			response.Identifier = responseIdentifier;
			response.Message = message;
			response.Stacktrace = stacktrace;
			response.Type = LogType.Generic;
			if ((int)type == 0 || (int)type == 4)
			{
				response.Type = LogType.Error;
			}
			if ((int)type == 1 || (int)type == 2)
			{
				response.Type = LogType.Warning;
			}
			if (responseConnection < 0)
			{
				listenerNew.BroadcastMessage(JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
			else
			{
				listenerNew.SendMessage(responseConnection, JsonConvert.SerializeObject((object)response, (Formatting)1));
			}
		}
	}

	public static bool SetEventSubscriber(int optionRconConnectionId)
	{
		return listenerNew.AddOrRemoveEventListener(optionRconConnectionId);
	}
}


using System.Net;

public struct Command
{
	public IPAddress Ip;

	public int ConnectionId;

	public string Name;

	public string Message;

	public int Identifier;
}


public enum LogType
{
	Generic,
	Error,
	Warning,
	Chat,
	Report,
	ClientPerf,
	Subscription
}


using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

public struct Response
{
	public string Message;

	public int Identifier;

	[JsonConverter(typeof(StringEnumConverter))]
	public LogType Type;

	public string Stacktrace;
}


using System.Net;

internal struct BannedAddresses
{
	public IPAddress addr;

	public float banTime;
}


public static class ReservedIdentifiers
{
	public const int PlayerPostionsUpdate = -64001;

	public const int FoundationsUpdate = -64002;
}


using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using UnityEngine;

internal class RConClient
{
	private Socket socket;

	private bool isAuthorised;

	private string connectionName;

	private int lastMessageID = -1;

	private bool runningConsoleCommand;

	private bool utf8Mode;

	internal RConClient(Socket cl)
	{
		socket = cl;
		socket.NoDelay = true;
		connectionName = socket.RemoteEndPoint.ToString();
	}

	internal bool IsValid()
	{
		return socket != null;
	}

	internal void Update()
	{
		if (socket == null)
		{
			return;
		}
		if (!socket.Connected)
		{
			Close("Disconnected");
			return;
		}
		int available = socket.Available;
		if (available < 14)
		{
			return;
		}
		if (available > 4096)
		{
			Close("overflow");
			return;
		}
		byte[] buffer = new byte[available];
		socket.Receive(buffer);
		using BinaryReader binaryReader = new BinaryReader(new MemoryStream(buffer, writable: false), utf8Mode ? Encoding.UTF8 : Encoding.ASCII);
		int num = binaryReader.ReadInt32();
		if (available < num)
		{
			Close("invalid packet");
			return;
		}
		lastMessageID = binaryReader.ReadInt32();
		int type = binaryReader.ReadInt32();
		string msg = ReadNullTerminatedString(binaryReader);
		ReadNullTerminatedString(binaryReader);
		if (!HandleMessage(type, msg))
		{
			Close("invalid packet");
		}
		else
		{
			lastMessageID = -1;
		}
	}

	internal bool HandleMessage(int type, string msg)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!isAuthorised)
		{
			return HandleMessage_UnAuthed(type, msg);
		}
		if (type == SERVERDATA_SWITCH_UTF8)
		{
			utf8Mode = true;
			return true;
		}
		if (type == SERVERDATA_EXECCOMMAND)
		{
			Debug.Log((object)("[RCON][" + connectionName + "] " + msg));
			runningConsoleCommand = true;
			ConsoleSystem.Run(Option.Server, msg, Array.Empty<object>());
			runningConsoleCommand = false;
			Reply(-1, SERVERDATA_RESPONSE_VALUE, "");
			return true;
		}
		if (type == SERVERDATA_RESPONSE_VALUE)
		{
			Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
			return true;
		}
		Debug.Log((object)("[RCON][" + connectionName + "] Unhandled: " + lastMessageID + " -> " + type + " -> " + msg));
		return false;
	}

	internal bool HandleMessage_UnAuthed(int type, string msg)
	{
		if (type != SERVERDATA_AUTH)
		{
			BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
			Close("Invalid Command - Not Authed");
			return false;
		}
		Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, "");
		isAuthorised = Password == msg;
		if (!isAuthorised)
		{
			Reply(-1, SERVERDATA_AUTH_RESPONSE, "");
			BanIP((socket.RemoteEndPoint as IPEndPoint).Address, 60f);
			Close("Invalid Password");
			return true;
		}
		Reply(lastMessageID, SERVERDATA_AUTH_RESPONSE, "");
		Debug.Log((object)("[RCON] Auth: " + connectionName));
		Output.OnMessage += Output_OnMessage;
		return true;
	}

	private void Output_OnMessage(string message, string stacktrace, LogType type)
	{
		if (isAuthorised && IsValid())
		{
			if (lastMessageID != -1 && runningConsoleCommand)
			{
				Reply(lastMessageID, SERVERDATA_RESPONSE_VALUE, message);
			}
			Reply(0, SERVERDATA_CONSOLE_LOG, message);
		}
	}

	internal void Reply(int id, int type, string msg)
	{
		MemoryStream memoryStream = new MemoryStream(1024);
		using BinaryWriter binaryWriter = new BinaryWriter(memoryStream);
		if (utf8Mode)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(msg);
			int value = 10 + bytes.Length;
			binaryWriter.Write(value);
			binaryWriter.Write(id);
			binaryWriter.Write(type);
			binaryWriter.Write(bytes);
		}
		else
		{
			int value2 = 10 + msg.Length;
			binaryWriter.Write(value2);
			binaryWriter.Write(id);
			binaryWriter.Write(type);
			foreach (char c in msg)
			{
				binaryWriter.Write((sbyte)c);
			}
		}
		binaryWriter.Write((sbyte)0);
		binaryWriter.Write((sbyte)0);
		binaryWriter.Flush();
		try
		{
			socket.Send(memoryStream.GetBuffer(), (int)memoryStream.Position, SocketFlags.None);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("Error sending rcon reply: " + ex));
			Close("Exception");
		}
	}

	internal void Close(string strReasn)
	{
		Output.OnMessage -= Output_OnMessage;
		if (socket != null)
		{
			Debug.Log((object)("[RCON][" + connectionName + "] Disconnected: " + strReasn));
			socket.Close();
			socket = null;
		}
	}

	internal string ReadNullTerminatedString(BinaryReader read)
	{
		string text = "";
		do
		{
			if (read.BaseStream.Position == read.BaseStream.Length)
			{
				return "";
			}
			char c = read.ReadChar();
			if (c == '\0')
			{
				return text;
			}
			text += c;
		}
		while (text.Length <= 8192);
		return string.Empty;
	}
}


using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using Oxide.Core;
using UnityEngine;

internal class RConListener
{
	private TcpListener server;

	private List<RConClient> clients = new List<RConClient>();

	internal RConListener()
	{
		IPAddress address = IPAddress.Any;
		if (!IPAddress.TryParse(Ip, out address))
		{
			address = IPAddress.Any;
		}
		server = new TcpListener(address, Port);
		try
		{
			server.Start();
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)("Couldn't start RCON Listener: " + ex.Message));
			server = null;
		}
	}

	internal void Shutdown()
	{
		if (server != null)
		{
			server.Stop();
			server = null;
		}
	}

	internal void Cycle()
	{
		if (server != null)
		{
			ProcessConnections();
			RemoveDeadClients();
			UpdateClients();
		}
	}

	private void ProcessConnections()
	{
		if (!server.Pending())
		{
			return;
		}
		Socket socket = server.AcceptSocket();
		if (socket != null)
		{
			IPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;
			if (Interface.CallHook("OnRconConnection", (object)iPEndPoint.Address) != null)
			{
				socket.Close();
			}
			else if (IsBanned(iPEndPoint.Address))
			{
				Debug.Log((object)("[RCON] Ignoring connection - banned. " + iPEndPoint.Address.ToString()));
				socket.Close();
			}
			else
			{
				clients.Add(new RConClient(socket));
			}
		}
	}

	private void UpdateClients()
	{
		foreach (RConClient client in clients)
		{
			client.Update();
		}
	}

	private void RemoveDeadClients()
	{
		clients.RemoveAll((RConClient x) => !x.IsValid());
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class VirtualScroll : MonoBehaviour
{
	public interface IDataSource
	{
		int GetItemCount();

		void SetItemData(int i, GameObject obj);
	}

	public interface IVisualUpdate
	{
		void OnVisualUpdate(int i, GameObject obj);
	}

	public int ItemHeight = 40;

	public int ItemSpacing = 10;

	public RectOffset Padding;

	[Tooltip("Optional, we'll try to GetComponent IDataSource from this object on awake")]
	public GameObject DataSourceObject;

	public GameObject SourceObject;

	public ScrollRect ScrollRect;

	public RectTransform OverrideContentRoot;

	private IDataSource dataSource;

	private Dictionary<int, GameObject> ActivePool = new Dictionary<int, GameObject>();

	private Stack<GameObject> InactivePool = new Stack<GameObject>();

	private int BlockHeight => ItemHeight + ItemSpacing;

	public void Awake()
	{
		((UnityEvent<Vector2>)(object)ScrollRect.onValueChanged).AddListener((UnityAction<Vector2>)OnScrollChanged);
		if ((Object)(object)DataSourceObject != (Object)null)
		{
			SetDataSource(DataSourceObject.GetComponent<IDataSource>());
		}
	}

	public void OnDestroy()
	{
		((UnityEvent<Vector2>)(object)ScrollRect.onValueChanged).RemoveListener((UnityAction<Vector2>)OnScrollChanged);
	}

	private void OnScrollChanged(Vector2 pos)
	{
		Rebuild();
	}

	public void SetDataSource(IDataSource source, bool forceRebuild = false)
	{
		if (dataSource != source || forceRebuild)
		{
			dataSource = source;
			FullRebuild();
		}
	}

	public void FullRebuild()
	{
		int[] array = ActivePool.Keys.ToArray();
		foreach (int key in array)
		{
			Recycle(key);
		}
		Rebuild();
	}

	public void DataChanged()
	{
		foreach (KeyValuePair<int, GameObject> item in ActivePool)
		{
			dataSource.SetItemData(item.Key, item.Value);
		}
		Rebuild();
	}

	public void Rebuild()
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		if (dataSource == null)
		{
			return;
		}
		int itemCount = dataSource.GetItemCount();
		object obj = (((Object)(object)OverrideContentRoot != (Object)null) ? ((object)OverrideContentRoot) : ((object)/*isinst with value type is only supported in some contexts*/));
		((RectTransform)obj).SetSizeWithCurrentAnchors((Axis)1, (float)(BlockHeight * itemCount - ItemSpacing + Padding.top + Padding.bottom));
		Rect rect = ScrollRect.viewport.rect;
		int num = Mathf.Max(2, Mathf.CeilToInt(((Rect)(ref rect)).height / (float)BlockHeight));
		int num2 = Mathf.FloorToInt((((RectTransform)obj).anchoredPosition.y - (float)Padding.top) / (float)BlockHeight);
		int num3 = num2 + num;
		RecycleOutOfRange(num2, num3);
		for (int i = num2; i <= num3; i++)
		{
			if (i >= 0 && i < itemCount)
			{
				BuildItem(i);
			}
		}
	}

	public void Update()
	{
		if (!(dataSource is IVisualUpdate visualUpdate))
		{
			return;
		}
		foreach (KeyValuePair<int, GameObject> item in ActivePool)
		{
			visualUpdate.OnVisualUpdate(item.Key, item.Value);
		}
	}

	private void RecycleOutOfRange(int startVisible, float endVisible)
	{
		int[] array = (from x in ActivePool.Keys
			where x < startVisible || (float)x > endVisible
			select (x)).ToArray();
		foreach (int key in array)
		{
			Recycle(key);
		}
	}

	private void Recycle(int key)
	{
		GameObject val = ActivePool[key];
		val.SetActive(false);
		ActivePool.Remove(key);
		InactivePool.Push(val);
	}

	private void BuildItem(int i)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		if (i >= 0 && !ActivePool.ContainsKey(i))
		{
			GameObject item = GetItem();
			item.SetActive(true);
			dataSource.SetItemData(i, item);
			Transform transform = item.transform;
			Transform obj = ((transform is RectTransform) ? transform : null);
			((RectTransform)obj).anchorMin = new Vector2(0f, 1f);
			((RectTransform)obj).anchorMax = new Vector2(1f, 1f);
			((RectTransform)obj).pivot = new Vector2(0.5f, 1f);
			((RectTransform)obj).offsetMin = new Vector2(0f, 0f);
			((RectTransform)obj).offsetMax = new Vector2(0f, (float)ItemHeight);
			((RectTransform)obj).sizeDelta = new Vector2((float)((Padding.left + Padding.right) * -1), (float)ItemHeight);
			((RectTransform)obj).anchoredPosition = new Vector2((float)(Padding.left - Padding.right) * 0.5f, (float)(-1 * (i * BlockHeight + Padding.top)));
			ActivePool[i] = item;
		}
	}

	private GameObject GetItem()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (InactivePool.Count == 0)
		{
			GameObject val = Object.Instantiate<GameObject>(SourceObject);
			val.transform.SetParent((Transform)(((Object)(object)OverrideContentRoot != (Object)null) ? ((object)OverrideContentRoot) : ((object)((Transform)ScrollRect.viewport).GetChild(0))), false);
			val.transform.localScale = Vector3.one;
			val.SetActive(false);
			InactivePool.Push(val);
		}
		return InactivePool.Pop();
	}
}


using UnityEngine;

public interface IDataSource
{
	int GetItemCount();

	void SetItemData(int i, GameObject obj);
}


using UnityEngine;

public interface IVisualUpdate
{
	void OnVisualUpdate(int i, GameObject obj);
}


using Facepunch;
using Unity.Collections;
using UnityEngine;

public class FPNativeList<T> : IPooled where T : struct
{
	private NativeArray<T> _array;

	private int _length;

	private int _capacity;

	public NativeArray<T> Array => _array;

	public int Count => _length;

	public int Capacity => _capacity;

	public T this[int index]
	{
		get
		{
			return _array[index];
		}
		set
		{
			_array[index] = value;
		}
	}

	public void Add(T item)
	{
		EnsureCapacity(_length + 1);
		_array[_length++] = item;
	}

	public void RemoveLast()
	{
		_length--;
		_array[_length] = default(T);
	}

	public void SetLength(int newLength)
	{
		if (newLength > _length)
		{
			EnsureCapacity(newLength);
		}
		else
		{
			_length = newLength;
		}
	}

	public void Clear()
	{
		for (int i = 0; i < _array.Length; i++)
		{
			_array[i] = default(T);
		}
		_length = 0;
	}

	public void Resize(int count)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (_array.IsCreated)
		{
			_array.Dispose();
		}
		_array = new NativeArray<T>(count, (Allocator)4, (NativeArrayOptions)1);
		_length = count;
	}

	public void EnsureCapacity(int requiredCapacity)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		if (!_array.IsCreated || _array.Length < requiredCapacity)
		{
			_capacity = Mathf.Max(_array.Length * 2, requiredCapacity);
			NativeArray<T> array = default(NativeArray<T>);
			array..ctor(_capacity, (Allocator)4, (NativeArrayOptions)1);
			if (_array.IsCreated)
			{
				_array.CopyTo(array.GetSubArray(0, _array.Length));
				_array.Dispose();
			}
			_array = array;
		}
	}

	public void EnterPool()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (_array.IsCreated)
		{
			_array.Dispose();
		}
		_array = default(NativeArray<T>);
		_length = 0;
		_capacity = 0;
	}

	public void LeavePool()
	{
	}
}


using Facepunch.UI;
using UnityEngine;

public class ESPCanvas : SingletonComponent<ESPCanvas>
{
	[Tooltip("Amount of times per second we should update the visible panels")]
	public float RefreshRate = 5f;

	[Tooltip("This object will be duplicated in place")]
	public ESPPlayerInfo Source;

	private static int NameplateCount = 32;

	[ClientVar(ClientAdmin = true)]
	public static float OverrideMaxDisplayDistance = 0f;

	[ClientVar(ClientAdmin = true)]
	public static bool DisableOcclusionChecks = false;

	[ClientVar(ClientAdmin = true)]
	public static bool ShowHealth = false;

	[ClientVar(ClientAdmin = true)]
	public static bool ColourCodeTeams = false;

	[ClientVar(ClientAdmin = true)]
	public static bool UseRandomTeamColours = false;

	[ClientVar(ClientAdmin = true, Help = "Max amount of nameplates to show at once")]
	public static int MaxNameplates
	{
		get
		{
			return NameplateCount;
		}
		set
		{
			NameplateCount = Mathf.Clamp(value, 16, 150);
		}
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class ESPPlayerInfo : MonoBehaviour
{
	public Vector3 WorldOffset;

	public RustText Text;

	public TextMeshProUGUI[] TextElements;

	public RustIcon Loading;

	public GameObject ClanElement;

	public RustText ClanText;

	public CanvasGroup group;

	public Gradient gradientNormal;

	public Gradient gradientTeam;

	public AccessibilityColourCollection TeamLookup;

	public AccessibilityColourCollection ClanLookup;

	public AccessibilityColourCollection AllyLookup;

	public AccessibilityColourCollection EnemyLookup;

	public QueryVis visCheck;

	public BasePlayer Entity { get; set; }
}


using Facepunch.NativeMeshSimplification;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CopyBackJob : IJob
{
	[WriteOnly]
	public NativeList<float3> DstVertices;

	[WriteOnly]
	public NativeList<int> DstIndices;

	[ReadOnly]
	public NativeList<NativeMeshSimplifier.Triangle> SrcTriangles;

	[ReadOnly]
	public NativeList<NativeMeshSimplifier.Vertex> SrcVertices;

	public void Execute()
	{
		DstVertices.Clear();
		DstVertices.SetCapacity(SrcVertices.Length);
		for (int i = 0; i < SrcVertices.Length; i++)
		{
			ref NativeList<float3> dstVertices = ref DstVertices;
			NativeMeshSimplifier.Vertex vertex = SrcVertices[i];
			dstVertices.Add(ref vertex.p);
		}
		DstIndices.Clear();
		DstIndices.SetCapacity(SrcTriangles.Length * 3);
		for (int j = 0; j < SrcTriangles.Length; j++)
		{
			ref NativeList<int> dstIndices = ref DstIndices;
			NativeMeshSimplifier.Triangle triangle = SrcTriangles[j];
			int num = ((int3)(ref triangle.vIndex))[0];
			dstIndices.Add(ref num);
			ref NativeList<int> dstIndices2 = ref DstIndices;
			triangle = SrcTriangles[j];
			num = ((int3)(ref triangle.vIndex))[1];
			dstIndices2.Add(ref num);
			ref NativeList<int> dstIndices3 = ref DstIndices;
			triangle = SrcTriangles[j];
			num = ((int3)(ref triangle.vIndex))[2];
			dstIndices3.Add(ref num);
		}
	}
}


using System;
using System.Diagnostics;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

public static class NativeListAccessExtensions
{
	[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
	private static void ArrayBoundsCheck<T>(in NativeList<T> list, int i) where T : unmanaged
	{
		if (i < 0 || i >= list.Length)
		{
			throw new IndexOutOfRangeException();
		}
	}

	public unsafe static ref T Get<T>(this in NativeList<T> list, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return ref NativeListUnsafeUtility.GetUnsafePtr<T>(list)[index];
	}

	public unsafe static ref readonly T GetReadonly<T>(this in NativeList<T> list, int index) where T : unmanaged
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return ref NativeListUnsafeUtility.GetUnsafeReadOnlyPtr<T>(list)[index];
	}
}


using Facepunch.NativeMeshSimplification;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct PopulateArraysJob : IJob
{
	[ReadOnly]
	public NativeList<float3> VerticesIn;

	[ReadOnly]
	public NativeList<int> IndicesIn;

	public NativeList<NativeMeshSimplifier.Triangle> TrianglesOut;

	public NativeList<NativeMeshSimplifier.Vertex> VerticesOut;

	public void Execute()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		if (VerticesOut.Capacity < VerticesIn.Length)
		{
			VerticesOut.SetCapacity(VerticesIn.Length);
		}
		VerticesOut.Clear();
		for (int i = 0; i < VerticesIn.Length; i++)
		{
			ref NativeList<NativeMeshSimplifier.Vertex> verticesOut = ref VerticesOut;
			NativeMeshSimplifier.Vertex vertex = new NativeMeshSimplifier.Vertex
			{
				p = VerticesIn[i]
			};
			verticesOut.Add(ref vertex);
		}
		if (TrianglesOut.Capacity < IndicesIn.Length / 3)
		{
			TrianglesOut.SetCapacity(IndicesIn.Length / 3);
		}
		TrianglesOut.Clear();
		for (int j = 0; j < IndicesIn.Length; j += 3)
		{
			ref NativeList<NativeMeshSimplifier.Triangle> trianglesOut = ref TrianglesOut;
			NativeMeshSimplifier.Triangle triangle = new NativeMeshSimplifier.Triangle
			{
				vIndex = new int3(IndicesIn[j], IndicesIn[j + 1], IndicesIn[j + 2])
			};
			trianglesOut.Add(ref triangle);
		}
	}
}


using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Facepunch.NativeMeshSimplification;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct SimplifyMeshJob : IJob
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	private struct ProfilerMarkerStub
	{
		[BurstDiscard]
		public void Begin()
		{
		}

		[BurstDiscard]
		public void End()
		{
		}
	}

	public int MaxIterations;

	public float ReductionTarget;

	public int Aggressiveness;

	public NativeList<NativeMeshSimplifier.Triangle> Triangles;

	public NativeList<NativeMeshSimplifier.Vertex> Vertices;

	public NativeList<NativeMeshSimplifier.Ref> Refs;

	private static readonly ProfilerMarkerStub k_Iteration;

	private static readonly ProfilerMarkerStub k_UpdateMesh;

	private static readonly ProfilerMarkerStub k_FirstUpdate;

	private static readonly ProfilerMarkerStub k_CompactMesh;

	private static readonly ProfilerMarkerStub k_Flipped;

	private static readonly ProfilerMarkerStub k_UpdateTriangles;

	private static readonly ProfilerMarkerStub k_MemCpy;

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		Refs.Clear();
		NativeList<int> deleted = default(NativeList<int>);
		deleted..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		NativeList<int> deleted2 = default(NativeList<int>);
		deleted2..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		int deletedTriangles = 0;
		int length = Triangles.Length;
		int num = (int)((float)length * ReductionTarget);
		NativeSlice<NativeMeshSimplifier.Ref> val2 = default(NativeSlice<NativeMeshSimplifier.Ref>);
		NativeSlice<NativeMeshSimplifier.Ref> val3 = default(NativeSlice<NativeMeshSimplifier.Ref>);
		for (int i = 0; i < MaxIterations; i++)
		{
			k_Iteration.Begin();
			if (length - deletedTriangles <= num)
			{
				k_Iteration.End();
				break;
			}
			if (i % 5 == 0)
			{
				k_UpdateMesh.Begin();
				UpdateMesh(i);
				k_UpdateMesh.End();
			}
			for (int j = 0; j < Triangles.Length; j++)
			{
				NativeListAccessExtensions.Get(in Triangles, j).dirty = false;
			}
			float num2 = 1E-09f * math.pow((float)i + 3f, (float)Aggressiveness);
			for (int k = 0; k < Triangles.Length; k++)
			{
				ref readonly NativeMeshSimplifier.Triangle @readonly = ref NativeListAccessExtensions.GetReadonly(in Triangles, k);
				float4 err = @readonly.err;
				if (math.any(new bool3(((float4)(ref err))[3] > num2, @readonly.deleted, @readonly.dirty)))
				{
					continue;
				}
				for (int l = 0; l < 3; l++)
				{
					err = @readonly.err;
					if (((float4)(ref err))[l] > num2)
					{
						continue;
					}
					int3 vIndex = @readonly.vIndex;
					int num3 = ((int3)(ref vIndex))[l];
					vIndex = @readonly.vIndex;
					int num4 = ((int3)(ref vIndex))[(l + 1) % 3];
					ref NativeMeshSimplifier.Vertex reference = ref NativeListAccessExtensions.Get(in Vertices, num3);
					ref readonly NativeMeshSimplifier.Vertex readonly2 = ref NativeListAccessExtensions.GetReadonly(in Vertices, num4);
					if (reference.border != readonly2.border)
					{
						continue;
					}
					CalculateError(in reference, in readonly2, out var pResult);
					deleted.Length = reference.tCount;
					deleted2.Length = readonly2.tCount;
					if (Flipped(pResult, num4, in reference, ref deleted) || Flipped(pResult, num3, in readonly2, ref deleted2))
					{
						continue;
					}
					reference.p = pResult;
					reference.q = readonly2.q + reference.q;
					int length2 = Refs.Length;
					k_UpdateTriangles.Begin();
					UpdateTriangles(num3, in reference, in deleted, ref deletedTriangles);
					UpdateTriangles(num3, in readonly2, in deleted2, ref deletedTriangles);
					k_UpdateTriangles.End();
					int num5 = Refs.Length - length2;
					if (num5 <= reference.tCount)
					{
						if (num5 > 0)
						{
							k_MemCpy.Begin();
							NativeArray<NativeMeshSimplifier.Ref> val = Refs.AsArray();
							val2..ctor(val, reference.tStart, num5);
							val3..ctor(val, length2, num5);
							val2.CopyFrom(val3);
							k_MemCpy.End();
						}
					}
					else
					{
						reference.tStart = length2;
					}
					reference.tCount = num5;
					break;
				}
				if (length - deletedTriangles <= num)
				{
					break;
				}
			}
			k_Iteration.End();
		}
		k_CompactMesh.Begin();
		CompactMesh();
		k_CompactMesh.End();
		deleted.Dispose();
		deleted2.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float VertexError(in NativeMeshSimplifier.SymmetricMatrix q, in float3 v)
	{
		float x = v.x;
		float y = v.y;
		float z = v.z;
		return q[0] * x * x + 2f * q[1] * x * y + 2f * q[2] * x * z + 2f * q[3] * x + q[4] * y * y + 2f * q[5] * y * z + 2f * q[6] * y + q[7] * z * z + 2f * q[8] * z + q[9];
	}

	private float CalculateError(int idV1, int idV2)
	{
		float3 pResult;
		return CalculateError(in NativeListAccessExtensions.Get(in Vertices, idV1), in NativeListAccessExtensions.Get(in Vertices, idV2), out pResult);
	}

	private float CalculateError(in NativeMeshSimplifier.Vertex v1, in NativeMeshSimplifier.Vertex v2, out float3 pResult)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		pResult = default(float3);
		NativeMeshSimplifier.SymmetricMatrix q = v1.q + v2.q;
		bool flag = v1.border & v2.border;
		float num = 0f;
		float num2 = q.Det(0, 1, 2, 1, 4, 5, 2, 5, 7);
		if (num2 != 0f && !flag)
		{
			float num3 = math.rcp(num2);
			pResult.x = (0f - num3) * q.Det(1, 2, 3, 4, 5, 6, 5, 7, 8);
			pResult.y = num3 * q.Det(0, 2, 3, 1, 5, 6, 2, 7, 8);
			pResult.z = (0f - num3) * q.Det(0, 1, 3, 1, 4, 6, 2, 5, 8);
			num = VertexError(in q, in pResult);
		}
		else
		{
			float3 v3 = v1.p;
			float3 v4 = v2.p;
			float3 v5 = (v3 + v4) * 0.5f;
			float num4 = VertexError(in q, in v3);
			float num5 = VertexError(in q, in v4);
			float num6 = VertexError(in q, in v5);
			num = math.min(num4, math.min(num5, num6));
			if (num4 == num)
			{
				pResult = v3;
			}
			if (num5 == num)
			{
				pResult = v4;
			}
			if (num6 == num)
			{
				pResult = v5;
			}
		}
		return num;
	}

	private bool Flipped(float3 p, int i1, in NativeMeshSimplifier.Vertex v0, ref NativeList<int> deleted)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		k_Flipped.Begin();
		for (int j = 0; j < v0.tCount; j++)
		{
			ref readonly NativeMeshSimplifier.Ref @readonly = ref NativeListAccessExtensions.GetReadonly(in Refs, v0.tStart + j);
			ref readonly NativeMeshSimplifier.Triangle readonly2 = ref NativeListAccessExtensions.GetReadonly(in Triangles, @readonly.tId);
			if (readonly2.deleted)
			{
				continue;
			}
			int tVertex = @readonly.tVertex;
			int3 vIndex = readonly2.vIndex;
			int num = ((int3)(ref vIndex))[(tVertex + 1) % 3];
			vIndex = readonly2.vIndex;
			int num2 = ((int3)(ref vIndex))[(tVertex + 2) % 3];
			if (num == i1 || num2 == i1)
			{
				deleted[j] = 1;
				continue;
			}
			float3 val = Vertices[num].p - p;
			float3 val2 = Vertices[num2].p - p;
			float3 val3 = math.cross(val, val2);
			if (math.lengthsq(val3) == 0f)
			{
				k_Flipped.End();
				return true;
			}
			float3 val4 = math.normalize(val3);
			deleted[j] = 0;
			if (math.dot(val4, readonly2.n) < 0.2f)
			{
				k_Flipped.End();
				return true;
			}
		}
		k_Flipped.End();
		return false;
	}

	private void UpdateTriangles(int i0, in NativeMeshSimplifier.Vertex v, in NativeList<int> deleted, ref int deletedTriangles)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		for (int j = 0; j < v.tCount; j++)
		{
			ref readonly NativeMeshSimplifier.Ref @readonly = ref NativeListAccessExtensions.GetReadonly(in Refs, v.tStart + j);
			ref NativeMeshSimplifier.Triangle reference = ref NativeListAccessExtensions.Get(in Triangles, @readonly.tId);
			if (!reference.deleted)
			{
				if (deleted[j] > 0)
				{
					reference.deleted = true;
					deletedTriangles++;
					continue;
				}
				ref readonly NativeMeshSimplifier.Vertex readonly2 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference.vIndex))[0]);
				ref readonly NativeMeshSimplifier.Vertex readonly3 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference.vIndex))[1]);
				ref readonly NativeMeshSimplifier.Vertex readonly4 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference.vIndex))[2]);
				((int3)(ref reference.vIndex))[@readonly.tVertex] = i0;
				reference.dirty = true;
				((float4)(ref reference.err))[0] = CalculateError(in readonly2, in readonly3, out var pResult);
				((float4)(ref reference.err))[1] = CalculateError(in readonly3, in readonly4, out pResult);
				((float4)(ref reference.err))[2] = CalculateError(in readonly4, in readonly2, out pResult);
				((float4)(ref reference.err))[3] = math.cmin(((float4)(ref reference.err)).xyz);
				Refs.Add(ref @readonly);
			}
		}
	}

	private void UpdateMesh(int iteration)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0405: Unknown result type (might be due to invalid IL or missing references)
		//IL_0409: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0434: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = iteration == 0;
		if (!flag)
		{
			int length = 0;
			for (int i = 0; i < Triangles.Length; i++)
			{
				ref readonly NativeMeshSimplifier.Triangle @readonly = ref NativeListAccessExtensions.GetReadonly(in Triangles, i);
				if (!@readonly.deleted)
				{
					Triangles[length++] = @readonly;
				}
			}
			Triangles.Length = length;
		}
		for (int j = 0; j < Vertices.Length; j++)
		{
			ref NativeMeshSimplifier.Vertex reference = ref NativeListAccessExtensions.Get(in Vertices, j);
			reference.tStart = 0;
			reference.tCount = 0;
		}
		int3 vIndex;
		for (int k = 0; k < Triangles.Length; k++)
		{
			ref readonly NativeMeshSimplifier.Triangle readonly2 = ref NativeListAccessExtensions.GetReadonly(in Triangles, k);
			for (int l = 0; l < 3; l++)
			{
				ref NativeList<NativeMeshSimplifier.Vertex> vertices = ref Vertices;
				vIndex = readonly2.vIndex;
				NativeListAccessExtensions.Get(in vertices, ((int3)(ref vIndex))[l]).tCount++;
			}
		}
		int num = 0;
		for (int m = 0; m < Vertices.Length; m++)
		{
			ref NativeMeshSimplifier.Vertex reference2 = ref NativeListAccessExtensions.Get(in Vertices, m);
			reference2.tStart = num;
			num += reference2.tCount;
			reference2.tCount = 0;
		}
		Refs.Length = Triangles.Length * 3;
		for (int n = 0; n < Triangles.Length; n++)
		{
			ref readonly NativeMeshSimplifier.Triangle readonly3 = ref NativeListAccessExtensions.GetReadonly(in Triangles, n);
			for (int num2 = 0; num2 < 3; num2++)
			{
				ref NativeList<NativeMeshSimplifier.Vertex> vertices2 = ref Vertices;
				vIndex = readonly3.vIndex;
				ref NativeMeshSimplifier.Vertex reference3 = ref NativeListAccessExtensions.Get(in vertices2, ((int3)(ref vIndex))[num2]);
				ref NativeMeshSimplifier.Ref reference4 = ref NativeListAccessExtensions.Get(in Refs, reference3.tStart + reference3.tCount);
				reference4.tId = n;
				reference4.tVertex = num2;
				reference3.tCount++;
			}
		}
		if (!flag)
		{
			return;
		}
		k_FirstUpdate.Begin();
		NativeList<int> list = default(NativeList<int>);
		list..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		NativeList<int> val = default(NativeList<int>);
		val..ctor(AllocatorHandle.op_Implicit((Allocator)2));
		for (int num3 = 0; num3 < Vertices.Length; num3++)
		{
			ref readonly NativeMeshSimplifier.Vertex readonly4 = ref NativeListAccessExtensions.GetReadonly(in Vertices, num3);
			list.Clear();
			val.Clear();
			for (int num4 = 0; num4 < readonly4.tCount; num4++)
			{
				ref readonly NativeMeshSimplifier.Triangle readonly5 = ref NativeListAccessExtensions.GetReadonly(in Triangles, Refs[readonly4.tStart + num4].tId);
				for (int num5 = 0; num5 < 3; num5++)
				{
					int num6 = 0;
					vIndex = readonly5.vIndex;
					int num7;
					for (num7 = ((int3)(ref vIndex))[num5]; num6 < list.Length && val[num6] != num7; num6++)
					{
					}
					if (num6 == list.Length)
					{
						int num8 = 1;
						list.Add(ref num8);
						val.Add(ref num7);
					}
					else
					{
						NativeListAccessExtensions.Get(in list, num6)++;
					}
				}
			}
			for (int num9 = 0; num9 < list.Length; num9++)
			{
				if (list[num9] == 1)
				{
					NativeListAccessExtensions.Get(in Vertices, val[num9]).border = true;
				}
			}
		}
		list.Dispose();
		val.Dispose();
		float3 val2 = default(float3);
		float3x3 val3 = default(float3x3);
		for (int num10 = 0; num10 < Triangles.Length; num10++)
		{
			ref NativeMeshSimplifier.Triangle reference5 = ref NativeListAccessExtensions.Get(in Triangles, num10);
			for (int num11 = 0; num11 < 3; num11++)
			{
				ref readonly NativeMeshSimplifier.Vertex readonly6 = ref NativeListAccessExtensions.GetReadonly(in Vertices, ((int3)(ref reference5.vIndex))[num11]);
				((float3x3)(ref val3))[num11] = readonly6.p;
			}
			val2 = (reference5.n = math.normalizesafe(math.cross(((float3x3)(ref val3))[1] - ((float3x3)(ref val3))[0], ((float3x3)(ref val3))[2] - ((float3x3)(ref val3))[0]), math.right()));
			for (int num12 = 0; num12 < 3; num12++)
			{
				NativeListAccessExtensions.Get(in Vertices, ((int3)(ref reference5.vIndex))[num12]).q += NativeMeshSimplifier.SymmetricMatrix.Plane(val2.x, val2.y, val2.z, 0f - math.dot(val2, ((float3x3)(ref val3))[0]));
			}
		}
		for (int num13 = 0; num13 < Triangles.Length; num13++)
		{
			ref NativeMeshSimplifier.Triangle reference6 = ref NativeListAccessExtensions.Get(in Triangles, num13);
			for (int num14 = 0; num14 < 3; num14++)
			{
				((float4)(ref reference6.err))[num14] = CalculateError(((int3)(ref reference6.vIndex))[num14], ((int3)(ref reference6.vIndex))[(num14 + 1) % 3]);
			}
			((float4)(ref reference6.err))[3] = math.cmin(((float4)(ref reference6.err)).xyz);
		}
		k_FirstUpdate.End();
	}

	private void CompactMesh()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Vertices.Length; i++)
		{
			NativeListAccessExtensions.Get(in Vertices, i).tCount = 0;
		}
		int length = 0;
		for (int j = 0; j < Triangles.Length; j++)
		{
			ref readonly NativeMeshSimplifier.Triangle @readonly = ref NativeListAccessExtensions.GetReadonly(in Triangles, j);
			if (!@readonly.deleted)
			{
				Triangles[length++] = @readonly;
				for (int k = 0; k < 3; k++)
				{
					ref NativeList<NativeMeshSimplifier.Vertex> vertices = ref Vertices;
					int3 vIndex = @readonly.vIndex;
					NativeListAccessExtensions.Get(in vertices, ((int3)(ref vIndex))[k]).tCount = 1;
				}
			}
		}
		Triangles.Length = length;
		length = 0;
		for (int l = 0; l < Vertices.Length; l++)
		{
			ref NativeMeshSimplifier.Vertex reference = ref NativeListAccessExtensions.Get(in Vertices, l);
			if (reference.tCount != 0)
			{
				reference.tStart = length;
				NativeListAccessExtensions.Get(in Vertices, length).p = reference.p;
				length++;
			}
		}
		for (int m = 0; m < Triangles.Length; m++)
		{
			ref NativeMeshSimplifier.Triangle reference2 = ref NativeListAccessExtensions.Get(in Triangles, m);
			for (int n = 0; n < 3; n++)
			{
				((int3)(ref reference2.vIndex))[n] = Vertices[((int3)(ref reference2.vIndex))[n]].tStart;
			}
		}
		Vertices.Length = length;
	}
}


using System.Runtime.InteropServices;
using Unity.Burst;

[StructLayout(LayoutKind.Sequential, Size = 1)]
private struct ProfilerMarkerStub
{
	[BurstDiscard]
	public void Begin()
	{
	}

	[BurstDiscard]
	public void End()
	{
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Facepunch.NativeMeshSimplification;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

public class NativeMeshSimplifier : IDisposable
{
	internal struct Triangle
	{
		public int3 vIndex;

		public float3 n;

		public float4 err;

		public bool deleted;

		public bool dirty;
	}

	internal struct Vertex
	{
		public float3 p;

		public SymmetricMatrix q;

		public int tStart;

		public int tCount;

		public bool border;
	}

	internal struct Ref
	{
		public int tId;

		public int tVertex;
	}

	internal struct SymmetricMatrix
	{
		private unsafe fixed float m[10];

		public unsafe float this[int i]
		{
			get
			{
				return m[i];
			}
			set
			{
				m[i] = value;
			}
		}

		private unsafe SymmetricMatrix(float m11, float m12, float m13, float m14, float m22, float m23, float m24, float m33, float m34, float m44)
		{
			m[0] = m11;
			m[1] = m12;
			m[2] = m13;
			m[3] = m14;
			m[4] = m22;
			m[5] = m23;
			m[6] = m24;
			m[7] = m33;
			m[8] = m34;
			m[9] = m44;
		}

		public static SymmetricMatrix Plane(float a, float b, float c, float d)
		{
			SymmetricMatrix result = default(SymmetricMatrix);
			result[0] = a * a;
			result[1] = a * b;
			result[2] = a * c;
			result[3] = a * d;
			result[4] = b * b;
			result[5] = b * c;
			result[6] = b * d;
			result[7] = c * c;
			result[8] = c * d;
			result[9] = d * d;
			return result;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public unsafe float Det(int a11, int a12, int a13, int a21, int a22, int a23, int a31, int a32, int a33)
		{
			//IL_009f: Unknown result type (might be due to invalid IL or missing references)
			return math.determinant(new float3x3(m[a11], m[a12], m[a13], m[a21], m[a22], m[a23], m[a31], m[a32], m[a33]));
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public static SymmetricMatrix operator +(SymmetricMatrix m, SymmetricMatrix n)
		{
			return new SymmetricMatrix(m[0] + n[0], m[1] + n[1], m[2] + n[2], m[3] + n[3], m[4] + n[4], m[5] + n[5], m[6] + n[6], m[7] + n[7], m[8] + n[8], m[9] + n[9]);
		}

		[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
		private void ArrayBoundsCheck(int i)
		{
			if (i < 0 || i > 9)
			{
				throw new IndexOutOfRangeException();
			}
		}
	}

	private NativeList<Vertex> _vertices;

	private NativeList<Triangle> _triangles;

	private NativeList<Ref> _refs;

	public NativeMeshSimplifier()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		_vertices = new NativeList<Vertex>(AllocatorHandle.op_Implicit((Allocator)4));
		_triangles = new NativeList<Triangle>(AllocatorHandle.op_Implicit((Allocator)4));
		_refs = new NativeList<Ref>(AllocatorHandle.op_Implicit((Allocator)4));
	}

	public void Dispose()
	{
		_vertices.Dispose();
		_triangles.Dispose();
		_refs.Dispose();
	}

	public JobHandle ScheduleMeshSimplify(float reductionModifier, NativeList<float3> verticesIn, NativeList<int> indicesIn, NativeList<float3> verticesOut, NativeList<int> indicesOut, JobHandle inputDeps)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		PopulateArraysJob populateArraysJob = default(PopulateArraysJob);
		populateArraysJob.VerticesIn = verticesIn;
		populateArraysJob.VerticesOut = _vertices;
		populateArraysJob.IndicesIn = indicesIn;
		populateArraysJob.TrianglesOut = _triangles;
		inputDeps = IJobExtensions.Schedule<PopulateArraysJob>(populateArraysJob, inputDeps);
		SimplifyMeshJob simplifyMeshJob = default(SimplifyMeshJob);
		simplifyMeshJob.MaxIterations = 128;
		simplifyMeshJob.Aggressiveness = 7;
		simplifyMeshJob.ReductionTarget = reductionModifier;
		simplifyMeshJob.Vertices = _vertices;
		simplifyMeshJob.Triangles = _triangles;
		simplifyMeshJob.Refs = _refs;
		inputDeps = IJobExtensions.Schedule<SimplifyMeshJob>(simplifyMeshJob, inputDeps);
		CopyBackJob copyBackJob = default(CopyBackJob);
		copyBackJob.DstVertices = verticesOut;
		copyBackJob.DstIndices = indicesOut;
		copyBackJob.SrcVertices = _vertices;
		copyBackJob.SrcTriangles = _triangles;
		inputDeps = IJobExtensions.Schedule<CopyBackJob>(copyBackJob, inputDeps);
		return inputDeps;
	}
}


using Unity.Mathematics;

internal struct Triangle
{
	public int3 vIndex;

	public float3 n;

	public float4 err;

	public bool deleted;

	public bool dirty;
}


using Unity.Mathematics;

internal struct Vertex
{
	public float3 p;

	public SymmetricMatrix q;

	public int tStart;

	public int tCount;

	public bool border;
}


internal struct Ref
{
	public int tId;

	public int tVertex;
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using Unity.Mathematics;

internal struct SymmetricMatrix
{
	private unsafe fixed float m[10];

	public unsafe float this[int i]
	{
		get
		{
			return m[i];
		}
		set
		{
			m[i] = value;
		}
	}

	private unsafe SymmetricMatrix(float m11, float m12, float m13, float m14, float m22, float m23, float m24, float m33, float m34, float m44)
	{
		m[0] = m11;
		m[1] = m12;
		m[2] = m13;
		m[3] = m14;
		m[4] = m22;
		m[5] = m23;
		m[6] = m24;
		m[7] = m33;
		m[8] = m34;
		m[9] = m44;
	}

	public static SymmetricMatrix Plane(float a, float b, float c, float d)
	{
		SymmetricMatrix result = default(SymmetricMatrix);
		result[0] = a * a;
		result[1] = a * b;
		result[2] = a * c;
		result[3] = a * d;
		result[4] = b * b;
		result[5] = b * c;
		result[6] = b * d;
		result[7] = c * c;
		result[8] = c * d;
		result[9] = d * d;
		return result;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public unsafe float Det(int a11, int a12, int a13, int a21, int a22, int a23, int a31, int a32, int a33)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		return math.determinant(new float3x3(m[a11], m[a12], m[a13], m[a21], m[a22], m[a23], m[a31], m[a32], m[a33]));
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static SymmetricMatrix operator +(SymmetricMatrix m, SymmetricMatrix n)
	{
		return new SymmetricMatrix(m[0] + n[0], m[1] + n[1], m[2] + n[2], m[3] + n[3], m[4] + n[4], m[5] + n[5], m[6] + n[6], m[7] + n[7], m[8] + n[8], m[9] + n[9]);
	}

	[Conditional("ENABLE_UNITY_COLLECTIONS_CHECKS")]
	private void ArrayBoundsCheck(int i)
	{
		if (i < 0 || i > 9)
		{
			throw new IndexOutOfRangeException();
		}
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

[BurstCompile]
internal struct BakePhysicsMeshesJob : IJobParallelFor
{
	[ReadOnly]
	public NativeArray<int> MeshIds;

	public void Execute(int index)
	{
		Physics.BakeMesh(MeshIds[index], false);
	}
}


using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CleanupDuplicateVerticesJob : IJob
{
	[ReadOnly]
	public NativeList<float3> inputVertices;

	[ReadOnly]
	public NativeList<int> inputIndices;

	[WriteOnly]
	public NativeList<float3> outputVertices;

	[WriteOnly]
	public NativeList<int> outputIndices;

	public NativeHashMap<int, int> indexToIndices;

	public float3 vertexOffset;

	public float invScale;

	public int width;

	public int widthHeight;

	public void Execute()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		indexToIndices.Clear();
		outputVertices.Clear();
		outputIndices.Clear();
		int num = 0;
		for (int i = 0; i < inputVertices.Length; i++)
		{
			int3 val = (int3)(inputVertices[i] * invScale + vertexOffset);
			int num2 = inputIndices[i];
			int num3 = val.x + val.y * width + val.z * widthHeight;
			if (indexToIndices.TryGetValue(num3, ref num2))
			{
				outputIndices.Add(ref num2);
				continue;
			}
			indexToIndices.Add(num3, num);
			ref NativeList<float3> reference = ref outputVertices;
			float3 val2 = inputVertices[i];
			reference.Add(ref val2);
			outputIndices.Add(ref num);
			num++;
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct MarchJob : IJob
{
	[ReadOnly]
	public Point3DGrid sampler;

	public NativeList<float3> vertices;

	[WriteOnly]
	public NativeList<int> indices;

	public float3 vertexOffset;

	public float scale;

	public void Execute()
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		int width = sampler.Width;
		int height = sampler.Height;
		int depth = sampler.Depth;
		vertices.Clear();
		indices.Clear();
		NativeArray<int3> corners = default(NativeArray<int3>);
		corners..ctor(8, (Allocator)2, (NativeArrayOptions)0);
		NativeArray<float> cornerSamples = default(NativeArray<float>);
		cornerSamples..ctor(8, (Allocator)2, (NativeArrayOptions)0);
		for (int i = 0; i < width - 1; i++)
		{
			for (int j = 0; j < height - 1; j++)
			{
				for (int k = 0; k < depth - 1; k++)
				{
					ProcessCube(new int3(i, j, k), corners, cornerSamples, vertices, indices, sampler, vertexOffset, scale);
				}
			}
		}
	}

	private static void ProcessCube(int3 cubeStart, NativeArray<int3> corners, NativeArray<float> cornerSamples, NativeList<float3> vertices, NativeList<int> indices, Point3DGrid sampler, float3 vertexOffset, float scale)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		corners[0] = cubeStart + new int3(0, 0, 0);
		corners[1] = cubeStart + new int3(1, 0, 0);
		corners[2] = cubeStart + new int3(1, 0, 1);
		corners[3] = cubeStart + new int3(0, 0, 1);
		corners[4] = cubeStart + new int3(0, 1, 0);
		corners[5] = cubeStart + new int3(1, 1, 0);
		corners[6] = cubeStart + new int3(1, 1, 1);
		corners[7] = cubeStart + new int3(0, 1, 1);
		int num = 0;
		for (int i = 0; i < corners.Length; i++)
		{
			float num3 = (cornerSamples[i] = sampler.Sample(corners[i]));
			if (num3 > 0f)
			{
				num |= 1 << i;
			}
		}
		int num4 = num * 16;
		for (int j = 0; j < 16; j += 3)
		{
			int num5 = MarchingCubeLookup.triTableFlat[num4 + j];
			if (num5 != -1)
			{
				int num6 = MarchingCubeLookup.triTableFlat[num4 + j + 1];
				int num7 = MarchingCubeLookup.triTableFlat[num4 + j + 2];
				float3 val = GetVertex(float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexAFromEdge[num5]]), cornerSamples[MarchingCubeLookup.cornerIndexAFromEdge[num5]], float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexBFromEdge[num5]]), cornerSamples[MarchingCubeLookup.cornerIndexBFromEdge[num5]]);
				float3 val2 = GetVertex(float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexAFromEdge[num6]]), cornerSamples[MarchingCubeLookup.cornerIndexAFromEdge[num6]], float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexBFromEdge[num6]]), cornerSamples[MarchingCubeLookup.cornerIndexBFromEdge[num6]]);
				float3 val3 = GetVertex(float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexAFromEdge[num7]]), cornerSamples[MarchingCubeLookup.cornerIndexAFromEdge[num7]], float3.op_Implicit(corners[MarchingCubeLookup.cornerIndexBFromEdge[num7]]), cornerSamples[MarchingCubeLookup.cornerIndexBFromEdge[num7]]);
				int length = vertices.Length;
				float3 val4 = (val - vertexOffset) * scale;
				vertices.Add(ref val4);
				val4 = (val2 - vertexOffset) * scale;
				vertices.Add(ref val4);
				val4 = (val3 - vertexOffset) * scale;
				vertices.Add(ref val4);
				indices.Add(ref length);
				int num8 = length + 1;
				indices.Add(ref num8);
				num8 = length + 2;
				indices.Add(ref num8);
				continue;
			}
			break;
		}
		static float3 GetVertex(float3 v0, float s0, float3 v1, float s1)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			float num9 = (0f - s0) / (s1 - s0);
			return math.lerp(v0, v1, num9);
		}
	}
}


[Il2CppEagerStaticClassConstruction]
public static class MarchingCubeLookup
{
	public static readonly int[] edgeTable = new int[256]
	{
		0, 265, 515, 778, 1030, 1295, 1541, 1804, 2060, 2309,
		2575, 2822, 3082, 3331, 3593, 3840, 400, 153, 915, 666,
		1430, 1183, 1941, 1692, 2460, 2197, 2975, 2710, 3482, 3219,
		3993, 3728, 560, 825, 51, 314, 1590, 1855, 1077, 1340,
		2620, 2869, 2111, 2358, 3642, 3891, 3129, 3376, 928, 681,
		419, 170, 1958, 1711, 1445, 1196, 2988, 2725, 2479, 2214,
		4010, 3747, 3497, 3232, 1120, 1385, 1635, 1898, 102, 367,
		613, 876, 3180, 3429, 3695, 3942, 2154, 2403, 2665, 2912,
		1520, 1273, 2035, 1786, 502, 255, 1013, 764, 3580, 3317,
		4095, 3830, 2554, 2291, 3065, 2800, 1616, 1881, 1107, 1370,
		598, 863, 85, 348, 3676, 3925, 3167, 3414, 2650, 2899,
		2137, 2384, 1984, 1737, 1475, 1226, 966, 719, 453, 204,
		4044, 3781, 3535, 3270, 3018, 2755, 2505, 2240, 2240, 2505,
		2755, 3018, 3270, 3535, 3781, 4044, 204, 453, 719, 966,
		1226, 1475, 1737, 1984, 2384, 2137, 2899, 2650, 3414, 3167,
		3925, 3676, 348, 85, 863, 598, 1370, 1107, 1881, 1616,
		2800, 3065, 2291, 2554, 3830, 4095, 3317, 3580, 764, 1013,
		255, 502, 1786, 2035, 1273, 1520, 2912, 2665, 2403, 2154,
		3942, 3695, 3429, 3180, 876, 613, 367, 102, 1898, 1635,
		1385, 1120, 3232, 3497, 3747, 4010, 2214, 2479, 2725, 2988,
		1196, 1445, 1711, 1958, 170, 419, 681, 928, 3376, 3129,
		3891, 3642, 2358, 2111, 2869, 2620, 1340, 1077, 1855, 1590,
		314, 51, 825, 560, 3728, 3993, 3219, 3482, 2710, 2975,
		2197, 2460, 1692, 1941, 1183, 1430, 666, 915, 153, 400,
		3840, 3593, 3331, 3082, 2822, 2575, 2309, 2060, 1804, 1541,
		1295, 1030, 778, 515, 265, 0
	};

	public static readonly int[] triTableFlat = new int[4096]
	{
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 0, 8, 3, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 0, 1, 9, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 1, 8,
		3, 9, 8, 1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 2, 10, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 3, 1, 2, 10, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 9, 2, 10, 0,
		2, 9, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 2, 8, 3, 2, 10, 8, 10, 9,
		8, -1, -1, -1, -1, -1, -1, -1, 3, 11,
		2, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 0, 11, 2, 8, 11, 0,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		1, 9, 0, 2, 3, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 1, 11, 2, 1,
		9, 11, 9, 8, 11, -1, -1, -1, -1, -1,
		-1, -1, 3, 10, 1, 11, 10, 3, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 10,
		1, 0, 8, 10, 8, 11, 10, -1, -1, -1,
		-1, -1, -1, -1, 3, 9, 0, 3, 11, 9,
		11, 10, 9, -1, -1, -1, -1, -1, -1, -1,
		9, 8, 10, 10, 8, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 4, 7, 8, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 4, 3, 0, 7, 3, 4, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 1,
		9, 8, 4, 7, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 4, 1, 9, 4, 7, 1,
		7, 3, 1, -1, -1, -1, -1, -1, -1, -1,
		1, 2, 10, 8, 4, 7, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 3, 4, 7, 3,
		0, 4, 1, 2, 10, -1, -1, -1, -1, -1,
		-1, -1, 9, 2, 10, 9, 0, 2, 8, 4,
		7, -1, -1, -1, -1, -1, -1, -1, 2, 10,
		9, 2, 9, 7, 2, 7, 3, 7, 9, 4,
		-1, -1, -1, -1, 8, 4, 7, 3, 11, 2,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		11, 4, 7, 11, 2, 4, 2, 0, 4, -1,
		-1, -1, -1, -1, -1, -1, 9, 0, 1, 8,
		4, 7, 2, 3, 11, -1, -1, -1, -1, -1,
		-1, -1, 4, 7, 11, 9, 4, 11, 9, 11,
		2, 9, 2, 1, -1, -1, -1, -1, 3, 10,
		1, 3, 11, 10, 7, 8, 4, -1, -1, -1,
		-1, -1, -1, -1, 1, 11, 10, 1, 4, 11,
		1, 0, 4, 7, 11, 4, -1, -1, -1, -1,
		4, 7, 8, 9, 0, 11, 9, 11, 10, 11,
		0, 3, -1, -1, -1, -1, 4, 7, 11, 4,
		11, 9, 9, 11, 10, -1, -1, -1, -1, -1,
		-1, -1, 9, 5, 4, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 9, 5,
		4, 0, 8, 3, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 0, 5, 4, 1, 5, 0,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		8, 5, 4, 8, 3, 5, 3, 1, 5, -1,
		-1, -1, -1, -1, -1, -1, 1, 2, 10, 9,
		5, 4, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 3, 0, 8, 1, 2, 10, 4, 9,
		5, -1, -1, -1, -1, -1, -1, -1, 5, 2,
		10, 5, 4, 2, 4, 0, 2, -1, -1, -1,
		-1, -1, -1, -1, 2, 10, 5, 3, 2, 5,
		3, 5, 4, 3, 4, 8, -1, -1, -1, -1,
		9, 5, 4, 2, 3, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 0, 11, 2, 0,
		8, 11, 4, 9, 5, -1, -1, -1, -1, -1,
		-1, -1, 0, 5, 4, 0, 1, 5, 2, 3,
		11, -1, -1, -1, -1, -1, -1, -1, 2, 1,
		5, 2, 5, 8, 2, 8, 11, 4, 8, 5,
		-1, -1, -1, -1, 10, 3, 11, 10, 1, 3,
		9, 5, 4, -1, -1, -1, -1, -1, -1, -1,
		4, 9, 5, 0, 8, 1, 8, 10, 1, 8,
		11, 10, -1, -1, -1, -1, 5, 4, 0, 5,
		0, 11, 5, 11, 10, 11, 0, 3, -1, -1,
		-1, -1, 5, 4, 8, 5, 8, 10, 10, 8,
		11, -1, -1, -1, -1, -1, -1, -1, 9, 7,
		8, 5, 7, 9, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 9, 3, 0, 9, 5, 3,
		5, 7, 3, -1, -1, -1, -1, -1, -1, -1,
		0, 7, 8, 0, 1, 7, 1, 5, 7, -1,
		-1, -1, -1, -1, -1, -1, 1, 5, 3, 3,
		5, 7, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 9, 7, 8, 9, 5, 7, 10, 1,
		2, -1, -1, -1, -1, -1, -1, -1, 10, 1,
		2, 9, 5, 0, 5, 3, 0, 5, 7, 3,
		-1, -1, -1, -1, 8, 0, 2, 8, 2, 5,
		8, 5, 7, 10, 5, 2, -1, -1, -1, -1,
		2, 10, 5, 2, 5, 3, 3, 5, 7, -1,
		-1, -1, -1, -1, -1, -1, 7, 9, 5, 7,
		8, 9, 3, 11, 2, -1, -1, -1, -1, -1,
		-1, -1, 9, 5, 7, 9, 7, 2, 9, 2,
		0, 2, 7, 11, -1, -1, -1, -1, 2, 3,
		11, 0, 1, 8, 1, 7, 8, 1, 5, 7,
		-1, -1, -1, -1, 11, 2, 1, 11, 1, 7,
		7, 1, 5, -1, -1, -1, -1, -1, -1, -1,
		9, 5, 8, 8, 5, 7, 10, 1, 3, 10,
		3, 11, -1, -1, -1, -1, 5, 7, 0, 5,
		0, 9, 7, 11, 0, 1, 0, 10, 11, 10,
		0, -1, 11, 10, 0, 11, 0, 3, 10, 5,
		0, 8, 0, 7, 5, 7, 0, -1, 11, 10,
		5, 7, 11, 5, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 10, 6, 5, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 3, 5, 10, 6, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 9, 0, 1, 5,
		10, 6, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 1, 8, 3, 1, 9, 8, 5, 10,
		6, -1, -1, -1, -1, -1, -1, -1, 1, 6,
		5, 2, 6, 1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 6, 5, 1, 2, 6,
		3, 0, 8, -1, -1, -1, -1, -1, -1, -1,
		9, 6, 5, 9, 0, 6, 0, 2, 6, -1,
		-1, -1, -1, -1, -1, -1, 5, 9, 8, 5,
		8, 2, 5, 2, 6, 3, 2, 8, -1, -1,
		-1, -1, 2, 3, 11, 10, 6, 5, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 11, 0,
		8, 11, 2, 0, 10, 6, 5, -1, -1, -1,
		-1, -1, -1, -1, 0, 1, 9, 2, 3, 11,
		5, 10, 6, -1, -1, -1, -1, -1, -1, -1,
		5, 10, 6, 1, 9, 2, 9, 11, 2, 9,
		8, 11, -1, -1, -1, -1, 6, 3, 11, 6,
		5, 3, 5, 1, 3, -1, -1, -1, -1, -1,
		-1, -1, 0, 8, 11, 0, 11, 5, 0, 5,
		1, 5, 11, 6, -1, -1, -1, -1, 3, 11,
		6, 0, 3, 6, 0, 6, 5, 0, 5, 9,
		-1, -1, -1, -1, 6, 5, 9, 6, 9, 11,
		11, 9, 8, -1, -1, -1, -1, -1, -1, -1,
		5, 10, 6, 4, 7, 8, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 4, 3, 0, 4,
		7, 3, 6, 5, 10, -1, -1, -1, -1, -1,
		-1, -1, 1, 9, 0, 5, 10, 6, 8, 4,
		7, -1, -1, -1, -1, -1, -1, -1, 10, 6,
		5, 1, 9, 7, 1, 7, 3, 7, 9, 4,
		-1, -1, -1, -1, 6, 1, 2, 6, 5, 1,
		4, 7, 8, -1, -1, -1, -1, -1, -1, -1,
		1, 2, 5, 5, 2, 6, 3, 0, 4, 3,
		4, 7, -1, -1, -1, -1, 8, 4, 7, 9,
		0, 5, 0, 6, 5, 0, 2, 6, -1, -1,
		-1, -1, 7, 3, 9, 7, 9, 4, 3, 2,
		9, 5, 9, 6, 2, 6, 9, -1, 3, 11,
		2, 7, 8, 4, 10, 6, 5, -1, -1, -1,
		-1, -1, -1, -1, 5, 10, 6, 4, 7, 2,
		4, 2, 0, 2, 7, 11, -1, -1, -1, -1,
		0, 1, 9, 4, 7, 8, 2, 3, 11, 5,
		10, 6, -1, -1, -1, -1, 9, 2, 1, 9,
		11, 2, 9, 4, 11, 7, 11, 4, 5, 10,
		6, -1, 8, 4, 7, 3, 11, 5, 3, 5,
		1, 5, 11, 6, -1, -1, -1, -1, 5, 1,
		11, 5, 11, 6, 1, 0, 11, 7, 11, 4,
		0, 4, 11, -1, 0, 5, 9, 0, 6, 5,
		0, 3, 6, 11, 6, 3, 8, 4, 7, -1,
		6, 5, 9, 6, 9, 11, 4, 7, 9, 7,
		11, 9, -1, -1, -1, -1, 10, 4, 9, 6,
		4, 10, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 4, 10, 6, 4, 9, 10, 0, 8,
		3, -1, -1, -1, -1, -1, -1, -1, 10, 0,
		1, 10, 6, 0, 6, 4, 0, -1, -1, -1,
		-1, -1, -1, -1, 8, 3, 1, 8, 1, 6,
		8, 6, 4, 6, 1, 10, -1, -1, -1, -1,
		1, 4, 9, 1, 2, 4, 2, 6, 4, -1,
		-1, -1, -1, -1, -1, -1, 3, 0, 8, 1,
		2, 9, 2, 4, 9, 2, 6, 4, -1, -1,
		-1, -1, 0, 2, 4, 4, 2, 6, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 8, 3,
		2, 8, 2, 4, 4, 2, 6, -1, -1, -1,
		-1, -1, -1, -1, 10, 4, 9, 10, 6, 4,
		11, 2, 3, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 2, 2, 8, 11, 4, 9, 10, 4,
		10, 6, -1, -1, -1, -1, 3, 11, 2, 0,
		1, 6, 0, 6, 4, 6, 1, 10, -1, -1,
		-1, -1, 6, 4, 1, 6, 1, 10, 4, 8,
		1, 2, 1, 11, 8, 11, 1, -1, 9, 6,
		4, 9, 3, 6, 9, 1, 3, 11, 6, 3,
		-1, -1, -1, -1, 8, 11, 1, 8, 1, 0,
		11, 6, 1, 9, 1, 4, 6, 4, 1, -1,
		3, 11, 6, 3, 6, 0, 0, 6, 4, -1,
		-1, -1, -1, -1, -1, -1, 6, 4, 8, 11,
		6, 8, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 7, 10, 6, 7, 8, 10, 8, 9,
		10, -1, -1, -1, -1, -1, -1, -1, 0, 7,
		3, 0, 10, 7, 0, 9, 10, 6, 7, 10,
		-1, -1, -1, -1, 10, 6, 7, 1, 10, 7,
		1, 7, 8, 1, 8, 0, -1, -1, -1, -1,
		10, 6, 7, 10, 7, 1, 1, 7, 3, -1,
		-1, -1, -1, -1, -1, -1, 1, 2, 6, 1,
		6, 8, 1, 8, 9, 8, 6, 7, -1, -1,
		-1, -1, 2, 6, 9, 2, 9, 1, 6, 7,
		9, 0, 9, 3, 7, 3, 9, -1, 7, 8,
		0, 7, 0, 6, 6, 0, 2, -1, -1, -1,
		-1, -1, -1, -1, 7, 3, 2, 6, 7, 2,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		2, 3, 11, 10, 6, 8, 10, 8, 9, 8,
		6, 7, -1, -1, -1, -1, 2, 0, 7, 2,
		7, 11, 0, 9, 7, 6, 7, 10, 9, 10,
		7, -1, 1, 8, 0, 1, 7, 8, 1, 10,
		7, 6, 7, 10, 2, 3, 11, -1, 11, 2,
		1, 11, 1, 7, 10, 6, 1, 6, 7, 1,
		-1, -1, -1, -1, 8, 9, 6, 8, 6, 7,
		9, 1, 6, 11, 6, 3, 1, 3, 6, -1,
		0, 9, 1, 11, 6, 7, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 7, 8, 0, 7,
		0, 6, 3, 11, 0, 11, 6, 0, -1, -1,
		-1, -1, 7, 11, 6, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 7, 6,
		11, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 3, 0, 8, 11, 7, 6,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 1, 9, 11, 7, 6, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 8, 1, 9, 8,
		3, 1, 11, 7, 6, -1, -1, -1, -1, -1,
		-1, -1, 10, 1, 2, 6, 11, 7, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 1, 2,
		10, 3, 0, 8, 6, 11, 7, -1, -1, -1,
		-1, -1, -1, -1, 2, 9, 0, 2, 10, 9,
		6, 11, 7, -1, -1, -1, -1, -1, -1, -1,
		6, 11, 7, 2, 10, 3, 10, 8, 3, 10,
		9, 8, -1, -1, -1, -1, 7, 2, 3, 6,
		2, 7, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 7, 0, 8, 7, 6, 0, 6, 2,
		0, -1, -1, -1, -1, -1, -1, -1, 2, 7,
		6, 2, 3, 7, 0, 1, 9, -1, -1, -1,
		-1, -1, -1, -1, 1, 6, 2, 1, 8, 6,
		1, 9, 8, 8, 7, 6, -1, -1, -1, -1,
		10, 7, 6, 10, 1, 7, 1, 3, 7, -1,
		-1, -1, -1, -1, -1, -1, 10, 7, 6, 1,
		7, 10, 1, 8, 7, 1, 0, 8, -1, -1,
		-1, -1, 0, 3, 7, 0, 7, 10, 0, 10,
		9, 6, 10, 7, -1, -1, -1, -1, 7, 6,
		10, 7, 10, 8, 8, 10, 9, -1, -1, -1,
		-1, -1, -1, -1, 6, 8, 4, 11, 8, 6,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		3, 6, 11, 3, 0, 6, 0, 4, 6, -1,
		-1, -1, -1, -1, -1, -1, 8, 6, 11, 8,
		4, 6, 9, 0, 1, -1, -1, -1, -1, -1,
		-1, -1, 9, 4, 6, 9, 6, 3, 9, 3,
		1, 11, 3, 6, -1, -1, -1, -1, 6, 8,
		4, 6, 11, 8, 2, 10, 1, -1, -1, -1,
		-1, -1, -1, -1, 1, 2, 10, 3, 0, 11,
		0, 6, 11, 0, 4, 6, -1, -1, -1, -1,
		4, 11, 8, 4, 6, 11, 0, 2, 9, 2,
		10, 9, -1, -1, -1, -1, 10, 9, 3, 10,
		3, 2, 9, 4, 3, 11, 3, 6, 4, 6,
		3, -1, 8, 2, 3, 8, 4, 2, 4, 6,
		2, -1, -1, -1, -1, -1, -1, -1, 0, 4,
		2, 4, 6, 2, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 9, 0, 2, 3, 4,
		2, 4, 6, 4, 3, 8, -1, -1, -1, -1,
		1, 9, 4, 1, 4, 2, 2, 4, 6, -1,
		-1, -1, -1, -1, -1, -1, 8, 1, 3, 8,
		6, 1, 8, 4, 6, 6, 10, 1, -1, -1,
		-1, -1, 10, 1, 0, 10, 0, 6, 6, 0,
		4, -1, -1, -1, -1, -1, -1, -1, 4, 6,
		3, 4, 3, 8, 6, 10, 3, 0, 3, 9,
		10, 9, 3, -1, 10, 9, 4, 6, 10, 4,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		4, 9, 5, 7, 6, 11, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 0, 8, 3, 4,
		9, 5, 11, 7, 6, -1, -1, -1, -1, -1,
		-1, -1, 5, 0, 1, 5, 4, 0, 7, 6,
		11, -1, -1, -1, -1, -1, -1, -1, 11, 7,
		6, 8, 3, 4, 3, 5, 4, 3, 1, 5,
		-1, -1, -1, -1, 9, 5, 4, 10, 1, 2,
		7, 6, 11, -1, -1, -1, -1, -1, -1, -1,
		6, 11, 7, 1, 2, 10, 0, 8, 3, 4,
		9, 5, -1, -1, -1, -1, 7, 6, 11, 5,
		4, 10, 4, 2, 10, 4, 0, 2, -1, -1,
		-1, -1, 3, 4, 8, 3, 5, 4, 3, 2,
		5, 10, 5, 2, 11, 7, 6, -1, 7, 2,
		3, 7, 6, 2, 5, 4, 9, -1, -1, -1,
		-1, -1, -1, -1, 9, 5, 4, 0, 8, 6,
		0, 6, 2, 6, 8, 7, -1, -1, -1, -1,
		3, 6, 2, 3, 7, 6, 1, 5, 0, 5,
		4, 0, -1, -1, -1, -1, 6, 2, 8, 6,
		8, 7, 2, 1, 8, 4, 8, 5, 1, 5,
		8, -1, 9, 5, 4, 10, 1, 6, 1, 7,
		6, 1, 3, 7, -1, -1, -1, -1, 1, 6,
		10, 1, 7, 6, 1, 0, 7, 8, 7, 0,
		9, 5, 4, -1, 4, 0, 10, 4, 10, 5,
		0, 3, 10, 6, 10, 7, 3, 7, 10, -1,
		7, 6, 10, 7, 10, 8, 5, 4, 10, 4,
		8, 10, -1, -1, -1, -1, 6, 9, 5, 6,
		11, 9, 11, 8, 9, -1, -1, -1, -1, -1,
		-1, -1, 3, 6, 11, 0, 6, 3, 0, 5,
		6, 0, 9, 5, -1, -1, -1, -1, 0, 11,
		8, 0, 5, 11, 0, 1, 5, 5, 6, 11,
		-1, -1, -1, -1, 6, 11, 3, 6, 3, 5,
		5, 3, 1, -1, -1, -1, -1, -1, -1, -1,
		1, 2, 10, 9, 5, 11, 9, 11, 8, 11,
		5, 6, -1, -1, -1, -1, 0, 11, 3, 0,
		6, 11, 0, 9, 6, 5, 6, 9, 1, 2,
		10, -1, 11, 8, 5, 11, 5, 6, 8, 0,
		5, 10, 5, 2, 0, 2, 5, -1, 6, 11,
		3, 6, 3, 5, 2, 10, 3, 10, 5, 3,
		-1, -1, -1, -1, 5, 8, 9, 5, 2, 8,
		5, 6, 2, 3, 8, 2, -1, -1, -1, -1,
		9, 5, 6, 9, 6, 0, 0, 6, 2, -1,
		-1, -1, -1, -1, -1, -1, 1, 5, 8, 1,
		8, 0, 5, 6, 8, 3, 8, 2, 6, 2,
		8, -1, 1, 5, 6, 2, 1, 6, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 1, 3,
		6, 1, 6, 10, 3, 8, 6, 5, 6, 9,
		8, 9, 6, -1, 10, 1, 0, 10, 0, 6,
		9, 5, 0, 5, 6, 0, -1, -1, -1, -1,
		0, 3, 8, 5, 6, 10, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 10, 5, 6, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 11, 5, 10, 7, 5, 11, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 11, 5,
		10, 11, 7, 5, 8, 3, 0, -1, -1, -1,
		-1, -1, -1, -1, 5, 11, 7, 5, 10, 11,
		1, 9, 0, -1, -1, -1, -1, -1, -1, -1,
		10, 7, 5, 10, 11, 7, 9, 8, 1, 8,
		3, 1, -1, -1, -1, -1, 11, 1, 2, 11,
		7, 1, 7, 5, 1, -1, -1, -1, -1, -1,
		-1, -1, 0, 8, 3, 1, 2, 7, 1, 7,
		5, 7, 2, 11, -1, -1, -1, -1, 9, 7,
		5, 9, 2, 7, 9, 0, 2, 2, 11, 7,
		-1, -1, -1, -1, 7, 5, 2, 7, 2, 11,
		5, 9, 2, 3, 2, 8, 9, 8, 2, -1,
		2, 5, 10, 2, 3, 5, 3, 7, 5, -1,
		-1, -1, -1, -1, -1, -1, 8, 2, 0, 8,
		5, 2, 8, 7, 5, 10, 2, 5, -1, -1,
		-1, -1, 9, 0, 1, 5, 10, 3, 5, 3,
		7, 3, 10, 2, -1, -1, -1, -1, 9, 8,
		2, 9, 2, 1, 8, 7, 2, 10, 2, 5,
		7, 5, 2, -1, 1, 3, 5, 3, 7, 5,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 7, 0, 7, 1, 1, 7, 5, -1,
		-1, -1, -1, -1, -1, -1, 9, 0, 3, 9,
		3, 5, 5, 3, 7, -1, -1, -1, -1, -1,
		-1, -1, 9, 8, 7, 5, 9, 7, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 5, 8,
		4, 5, 10, 8, 10, 11, 8, -1, -1, -1,
		-1, -1, -1, -1, 5, 0, 4, 5, 11, 0,
		5, 10, 11, 11, 3, 0, -1, -1, -1, -1,
		0, 1, 9, 8, 4, 10, 8, 10, 11, 10,
		4, 5, -1, -1, -1, -1, 10, 11, 4, 10,
		4, 5, 11, 3, 4, 9, 4, 1, 3, 1,
		4, -1, 2, 5, 1, 2, 8, 5, 2, 11,
		8, 4, 5, 8, -1, -1, -1, -1, 0, 4,
		11, 0, 11, 3, 4, 5, 11, 2, 11, 1,
		5, 1, 11, -1, 0, 2, 5, 0, 5, 9,
		2, 11, 5, 4, 5, 8, 11, 8, 5, -1,
		9, 4, 5, 2, 11, 3, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 2, 5, 10, 3,
		5, 2, 3, 4, 5, 3, 8, 4, -1, -1,
		-1, -1, 5, 10, 2, 5, 2, 4, 4, 2,
		0, -1, -1, -1, -1, -1, -1, -1, 3, 10,
		2, 3, 5, 10, 3, 8, 5, 4, 5, 8,
		0, 1, 9, -1, 5, 10, 2, 5, 2, 4,
		1, 9, 2, 9, 4, 2, -1, -1, -1, -1,
		8, 4, 5, 8, 5, 3, 3, 5, 1, -1,
		-1, -1, -1, -1, -1, -1, 0, 4, 5, 1,
		0, 5, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 8, 4, 5, 8, 5, 3, 9, 0,
		5, 0, 3, 5, -1, -1, -1, -1, 9, 4,
		5, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 4, 11, 7, 4, 9, 11,
		9, 10, 11, -1, -1, -1, -1, -1, -1, -1,
		0, 8, 3, 4, 9, 7, 9, 11, 7, 9,
		10, 11, -1, -1, -1, -1, 1, 10, 11, 1,
		11, 4, 1, 4, 0, 7, 4, 11, -1, -1,
		-1, -1, 3, 1, 4, 3, 4, 8, 1, 10,
		4, 7, 4, 11, 10, 11, 4, -1, 4, 11,
		7, 9, 11, 4, 9, 2, 11, 9, 1, 2,
		-1, -1, -1, -1, 9, 7, 4, 9, 11, 7,
		9, 1, 11, 2, 11, 1, 0, 8, 3, -1,
		11, 7, 4, 11, 4, 2, 2, 4, 0, -1,
		-1, -1, -1, -1, -1, -1, 11, 7, 4, 11,
		4, 2, 8, 3, 4, 3, 2, 4, -1, -1,
		-1, -1, 2, 9, 10, 2, 7, 9, 2, 3,
		7, 7, 4, 9, -1, -1, -1, -1, 9, 10,
		7, 9, 7, 4, 10, 2, 7, 8, 7, 0,
		2, 0, 7, -1, 3, 7, 10, 3, 10, 2,
		7, 4, 10, 1, 10, 0, 4, 0, 10, -1,
		1, 10, 2, 8, 7, 4, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 4, 9, 1, 4,
		1, 7, 7, 1, 3, -1, -1, -1, -1, -1,
		-1, -1, 4, 9, 1, 4, 1, 7, 0, 8,
		1, 8, 7, 1, -1, -1, -1, -1, 4, 0,
		3, 7, 4, 3, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 4, 8, 7, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		9, 10, 8, 10, 11, 8, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, 3, 0, 9, 3,
		9, 11, 11, 9, 10, -1, -1, -1, -1, -1,
		-1, -1, 0, 1, 10, 0, 10, 8, 8, 10,
		11, -1, -1, -1, -1, -1, -1, -1, 3, 1,
		10, 11, 3, 10, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 1, 2, 11, 1, 11, 9,
		9, 11, 8, -1, -1, -1, -1, -1, -1, -1,
		3, 0, 9, 3, 9, 11, 1, 2, 9, 2,
		11, 9, -1, -1, -1, -1, 0, 2, 11, 8,
		0, 11, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 3, 2, 11, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 2, 3,
		8, 2, 8, 10, 10, 8, 9, -1, -1, -1,
		-1, -1, -1, -1, 9, 10, 2, 0, 9, 2,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		2, 3, 8, 2, 8, 10, 0, 1, 8, 1,
		10, 8, -1, -1, -1, -1, 1, 10, 2, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, 1, 3, 8, 9, 1, 8, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, 0, 9,
		1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, 0, 3, 8, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1
	};

	public static readonly int[] cornerIndexAFromEdge = new int[12]
	{
		0, 1, 2, 3, 4, 5, 6, 7, 0, 1,
		2, 3
	};

	public static readonly int[] cornerIndexBFromEdge = new int[12]
	{
		1, 2, 3, 0, 5, 6, 7, 4, 4, 5,
		6, 7
	};
}


using System;
using System.Collections.Generic;
using Facepunch.MarchingCubes;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class MarchingCubeManager : FacepunchBehaviour
{
	private static MarchingCubeManager _instance;

	public List<MarchingCubesGenerator> AllCubesList;

	private ListHashSet<MarchingCubesGenerator> _cubesWaitingForGeneration;

	private BufferList<MarchingCubesGenerator> _toAssignPhysics;

	private JobHandle _physicsBakeHandle;

	public static MarchingCubeManager Instance
	{
		get
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Expected O, but got Unknown
			if (_instance != null)
			{
				return _instance;
			}
			GameObject val = new GameObject("MarchingCubeManager");
			Object.DontDestroyOnLoad((Object)val);
			_instance = val.AddComponent<MarchingCubeManager>();
			return _instance;
		}
	}

	public void Awake()
	{
		AllCubesList = new List<MarchingCubesGenerator>();
		_cubesWaitingForGeneration = new ListHashSet<MarchingCubesGenerator>(8);
		_toAssignPhysics = new BufferList<MarchingCubesGenerator>();
	}

	public void FixedUpdate()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (_toAssignPhysics.Count == 0)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PhysicsBakeComplete", 0);
		try
		{
			((JobHandle)(ref _physicsBakeHandle)).Complete();
			_physicsBakeHandle = default(JobHandle);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("PhysicsMeshAssign", 0);
		try
		{
			Enumerator<MarchingCubesGenerator> enumerator = _toAssignPhysics.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					MarchingCubesGenerator current = enumerator.Current;
					current.MeshCollider.sharedMesh = current.Mesh;
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		_toAssignPhysics.Clear();
	}

	public void LateUpdate()
	{
		ProcessQueue();
	}

	public void Add(MarchingCubesGenerator cubes)
	{
		AllCubesList.Add(cubes);
	}

	public void Remove(MarchingCubesGenerator cubes)
	{
		AllCubesList.Remove(cubes);
	}

	public void EnqueueUpdate(MarchingCubesGenerator cubes)
	{
		_cubesWaitingForGeneration.TryAdd(cubes);
	}

	private void ProcessQueue()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (_cubesWaitingForGeneration.Count != 0)
		{
			int count = _cubesWaitingForGeneration.Count;
			NativeArray<JobHandle> val = default(NativeArray<JobHandle>);
			val..ctor(count, (Allocator)2, (NativeArrayOptions)1);
			for (int i = 0; i < count; i++)
			{
				val[i] = _cubesWaitingForGeneration[i].ScheduleMarch();
			}
			JobHandle.CompleteAll(val);
			NativeArray<int> meshIds = default(NativeArray<int>);
			meshIds..ctor(_cubesWaitingForGeneration.Count, (Allocator)3, (NativeArrayOptions)1);
			for (int j = 0; j < count; j++)
			{
				_cubesWaitingForGeneration[j].ApplyUpdate();
				meshIds[j] = _cubesWaitingForGeneration[j].MeshInstanceId;
				_toAssignPhysics.Add(_cubesWaitingForGeneration[j]);
			}
			_physicsBakeHandle = IJobParallelForExtensions.Schedule<BakePhysicsMeshesJob>(new BakePhysicsMeshesJob
			{
				MeshIds = meshIds
			}, count, 1, _physicsBakeHandle);
			meshIds.Dispose(_physicsBakeHandle);
			_cubesWaitingForGeneration.Clear();
		}
	}
}


using System;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Profiling;
using UnityEngine;

public class MarchingCubesGenerator : IDisposable
{
	private readonly Point3DGrid _sampler;

	private readonly Mesh _meshToUpdate;

	private readonly MeshCollider _meshCollider;

	private readonly NativeMeshSimplifier _simplifier;

	private readonly float3 _offset;

	private readonly float _scale;

	private NativeList<float3> vertices0;

	private NativeList<float3> vertices1;

	private NativeList<float3> vertices2;

	private NativeList<int> indices0;

	private NativeList<int> indices1;

	private NativeList<int> indices2;

	private NativeHashMap<int, int> indexToIndices;

	private float4x4 _transform;

	private static readonly ProfilerMarker p_ApplyUpdate = new ProfilerMarker("MarchingCubes.ApplyUpdate");

	public Mesh Mesh => _meshToUpdate;

	public MeshCollider MeshCollider => _meshCollider;

	public int MeshInstanceId => ((Object)_meshToUpdate).GetInstanceID();

	public MarchingCubesGenerator(Point3DGrid sampler, Mesh meshToUpdate, MeshCollider meshCollider, float3 offset, float scale)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		_sampler = sampler;
		_meshToUpdate = meshToUpdate;
		_meshCollider = meshCollider;
		_simplifier = new NativeMeshSimplifier();
		_offset = offset;
		_scale = scale;
		vertices0 = new NativeList<float3>(AllocatorHandle.op_Implicit((Allocator)4));
		vertices1 = new NativeList<float3>(AllocatorHandle.op_Implicit((Allocator)4));
		vertices2 = new NativeList<float3>(AllocatorHandle.op_Implicit((Allocator)4));
		indices0 = new NativeList<int>(AllocatorHandle.op_Implicit((Allocator)4));
		indices1 = new NativeList<int>(AllocatorHandle.op_Implicit((Allocator)4));
		indices2 = new NativeList<int>(AllocatorHandle.op_Implicit((Allocator)4));
		indexToIndices = new NativeHashMap<int, int>(0, AllocatorHandle.op_Implicit((Allocator)4));
		MarchingCubeManager.Instance.Add(this);
	}

	public JobHandle ScheduleMarch()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		float3 vertexOffset = new float3((float)_sampler.Width * 0.5f, (float)_sampler.Height * 0.5f, (float)_sampler.Depth * 0.5f) + _offset;
		MarchJob marchJob = default(MarchJob);
		marchJob.sampler = _sampler;
		marchJob.vertices = vertices0;
		marchJob.indices = indices0;
		marchJob.vertexOffset = vertexOffset;
		marchJob.scale = _scale;
		MarchJob marchJob2 = marchJob;
		CleanupDuplicateVerticesJob cleanupDuplicateVerticesJob = default(CleanupDuplicateVerticesJob);
		cleanupDuplicateVerticesJob.inputVertices = vertices0;
		cleanupDuplicateVerticesJob.inputIndices = indices0;
		cleanupDuplicateVerticesJob.outputVertices = vertices1;
		cleanupDuplicateVerticesJob.outputIndices = indices1;
		cleanupDuplicateVerticesJob.indexToIndices = indexToIndices;
		cleanupDuplicateVerticesJob.vertexOffset = vertexOffset;
		cleanupDuplicateVerticesJob.invScale = math.rcp(_scale);
		cleanupDuplicateVerticesJob.width = _sampler.Width;
		cleanupDuplicateVerticesJob.widthHeight = _sampler.Height * _sampler.Width;
		CleanupDuplicateVerticesJob cleanupDuplicateVerticesJob2 = cleanupDuplicateVerticesJob;
		JobHandle val = IJobExtensions.Schedule<MarchJob>(marchJob2, default(JobHandle));
		return IJobExtensions.Schedule<CleanupDuplicateVerticesJob>(cleanupDuplicateVerticesJob2, val);
	}

	public JobHandle ScheduleSimplification(JobHandle inputDeps)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		return _simplifier.ScheduleMeshSimplify(0.4f, vertices1, indices1, vertices2, indices2, inputDeps);
	}

	public void ApplyUpdate(bool fromSimplify = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		ProfilerMarker val = p_ApplyUpdate;
		AutoScope val2 = ((ProfilerMarker)(ref val)).Auto();
		try
		{
			_meshToUpdate.Clear();
			NativeList<float3> val3 = (fromSimplify ? vertices2 : vertices1);
			NativeList<int> val4 = (fromSimplify ? indices2 : indices1);
			_meshToUpdate.SetVertices<float3>(val3.AsArray(), 0, val3.Length);
			_meshToUpdate.SetIndices<int>(val4.AsArray(), 0, val4.Length, (MeshTopology)0, 0, true, 0);
			_meshToUpdate.RecalculateBounds();
			_meshToUpdate.RecalculateNormals();
			if (BaseSculpture.LogMeshStats)
			{
				Debug.Log((object)$"{((Object)_meshToUpdate).name} : tris({val4.Length / 3}) verts({val3.Length})");
			}
		}
		finally
		{
			((IDisposable)(AutoScope)(ref val2)/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void EnqueueUpdate()
	{
		MarchingCubeManager.Instance.EnqueueUpdate(this);
	}

	public void Dispose()
	{
		vertices0.Dispose();
		vertices1.Dispose();
		vertices2.Dispose();
		indices0.Dispose();
		indices1.Dispose();
		indices2.Dispose();
		indexToIndices.Dispose();
		_simplifier.Dispose();
		MarchingCubeManager.Instance.Remove(this);
	}
}


using System;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;

[GenerateTestsForBurstCompatibility]
public struct Point3DGrid : IDisposable
{
	private readonly NativeBitArray _array;

	private readonly int _width;

	private readonly int _height;

	private readonly int _depth;

	private readonly int3 _bounds;

	private readonly int _widthHeight;

	private bool _hasDisposed;

	public int Width => _width;

	public int Height => _height;

	public int Depth => _depth;

	public int Length => ((NativeBitArray)(ref _array)).Length;

	public int3 Bounds => _bounds;

	public bool this[int directIndex]
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			return ((NativeBitArray)(ref array)).IsSet(directIndex);
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			((NativeBitArray)(ref array)).Set(directIndex, value);
		}
	}

	public bool this[int x, int y, int z]
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			return ((NativeBitArray)(ref array)).IsSet(ToIndex(x, y, z));
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			NativeBitArray array = _array;
			((NativeBitArray)(ref array)).Set(ToIndex(x, y, z), value);
		}
	}

	public bool this[int3 p]
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			return this[p.x, p.y, p.z];
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			this[p.x, p.y, p.z] = value;
		}
	}

	public Point3DGrid(int width, int height, int depth)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		_width = width;
		_height = height;
		_depth = depth;
		_bounds = new int3(_width, _height, _depth);
		_widthHeight = _width * _height;
		_array = new NativeBitArray(_widthHeight * _depth, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
		_hasDisposed = false;
	}

	public void Clear()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		((NativeBitArray)(ref array)).Clear();
	}

	public void CopyToByteArray(ref byte[] arr)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		NativeArray<byte> val = ((NativeBitArray)(ref array)).AsNativeArray<byte>();
		if (arr.Length < val.Length)
		{
			arr = new byte[val.Length];
		}
		val.CopyTo(arr);
	}

	public unsafe void CopyFromByteArray(byte[] arr, int count)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		NativeArray<byte> val = ((NativeBitArray)(ref array)).AsNativeArray<byte>();
		if (count != val.Length)
		{
			Debug.LogError((object)"Trying to load non-matching sized grid");
			return;
		}
		fixed (byte* ptr = arr)
		{
			UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafePtr<byte>(val), (void*)ptr, (long)(count * UnsafeUtility.SizeOf<byte>()));
		}
	}

	public void CopyFromNativeBitArray(ref NativeBitArray other)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray array = _array;
		((NativeBitArray)(ref array)).Copy(0, ref other, 0, ((NativeBitArray)(ref _array)).Length);
	}

	public bool InBounds(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!math.any(p < 0))
		{
			return !math.any(p >= _bounds);
		}
		return false;
	}

	public bool InBoundsNotTouching(int3 p)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (!math.any(p < 1))
		{
			return !math.any(p >= _bounds - new int3(1));
		}
		return false;
	}

	public int ToIndex(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return ToIndex(p.x, p.y, p.z);
	}

	public int ToIndex(int x, int y, int z)
	{
		return x + y * Width + z * _widthHeight;
	}

	public float Sample(int3 localPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		if (!this[localPosition])
		{
			return 0f;
		}
		return 1f;
	}

	public void Dispose()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!_hasDisposed)
		{
			NativeBitArray array = _array;
			((NativeBitArray)(ref array)).Dispose();
			_hasDisposed = true;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using ProtoBuf;
using UnityEngine;

public class BlackjackController : CardGameController
{
	[Flags]
	public enum BlackjackInputOption
	{
		None = 0,
		SubmitBet = 1,
		Hit = 2,
		Stand = 4,
		Split = 8,
		DoubleDown = 0x10,
		Insurance = 0x20,
		MaxBet = 0x40,
		Abandon = 0x80
	}

	public enum BlackjackRoundResult
	{
		None,
		Bust,
		Loss,
		Standoff,
		Win,
		BlackjackWin
	}

	public enum CardsValueMode
	{
		Low,
		High
	}

	private enum BetType
	{
		Main,
		Split,
		Insurance
	}

	public List<PlayingCard> dealerCards = new List<PlayingCard>();

	public const float BLACKJACK_PAYOUT_RATIO = 1.5f;

	public const float INSURANCE_PAYOUT_RATIO = 2f;

	private const float DEALER_MOVE_TIME = 1f;

	private const int NUM_DECKS = 10;

	private StackOfCards cardStack = new StackOfCards(10);

	public override int MinPlayers => 1;

	public override int MinBuyIn => 5;

	public override int MaxBuyIn => int.MaxValue;

	public override int MinToPlay => MinBuyIn;

	public override int EndRoundDelay => 1;

	public override int TimeBetweenRounds => 4;

	public BlackjackInputOption LastAction { get; private set; }

	public ulong LastActionTarget { get; private set; }

	public int LastActionValue { get; private set; }

	public bool AllBetsPlaced
	{
		get
		{
			if (!base.HasRoundInProgressOrEnding)
			{
				return false;
			}
			foreach (CardPlayerData item in PlayersInRound())
			{
				if (item.betThisRound == 0)
				{
					return false;
				}
			}
			return true;
		}
	}

	public BlackjackController(BaseCardGameEntity owner)
		: base(owner)
	{
	}

	protected override int GetFirstPlayerRelIndex(bool startOfRound)
	{
		return 0;
	}

	public override List<PlayingCard> GetTableCards()
	{
		return dealerCards;
	}

	public void InputsToList(int availableInputs, List<BlackjackInputOption> result)
	{
		BlackjackInputOption[] array = (BlackjackInputOption[])Enum.GetValues(typeof(BlackjackInputOption));
		foreach (BlackjackInputOption blackjackInputOption in array)
		{
			if (blackjackInputOption != 0 && ((uint)availableInputs & (uint)blackjackInputOption) == (uint)blackjackInputOption)
			{
				result.Add(blackjackInputOption);
			}
		}
	}

	public bool WaitingForOtherPlayers(CardPlayerData pData)
	{
		if (!pData.HasUserInCurrentRound)
		{
			return false;
		}
		if (base.State == CardGameState.InGameRound && !pData.HasAvailableInputs)
		{
			foreach (CardPlayerData item in PlayersInRound())
			{
				if (item != pData && item.HasAvailableInputs)
				{
					return true;
				}
			}
		}
		return false;
	}

	public int GetCardsValue(List<PlayingCard> cards, CardsValueMode mode)
	{
		int num = 0;
		foreach (PlayingCard card in cards)
		{
			if (!card.IsUnknownCard)
			{
				num += GetCardValue(card, mode);
				if (card.Rank == Rank.Ace)
				{
					mode = CardsValueMode.Low;
				}
			}
		}
		return num;
	}

	public int GetOptimalCardsValue(List<PlayingCard> cards)
	{
		int cardsValue = GetCardsValue(cards, CardsValueMode.Low);
		int cardsValue2 = GetCardsValue(cards, CardsValueMode.High);
		if (cardsValue2 <= 21)
		{
			return cardsValue2;
		}
		return cardsValue;
	}

	public int GetCardValue(PlayingCard card, CardsValueMode mode)
	{
		int rank = (int)card.Rank;
		if (rank <= 8)
		{
			return rank + 2;
		}
		if (rank <= 11)
		{
			return 10;
		}
		if (mode != 0)
		{
			return 11;
		}
		return 1;
	}

	public bool Has21(List<PlayingCard> cards)
	{
		return GetOptimalCardsValue(cards) == 21;
	}

	public bool HasBlackjack(List<PlayingCard> cards)
	{
		if (GetCardsValue(cards, CardsValueMode.High) == 21)
		{
			return cards.Count == 2;
		}
		return false;
	}

	public bool HasBusted(List<PlayingCard> cards)
	{
		return GetCardsValue(cards, CardsValueMode.Low) > 21;
	}

	private bool CanSplit(CardPlayerDataBlackjack pData)
	{
		if (pData.Cards.Count != 2)
		{
			return false;
		}
		if (HasSplit(pData))
		{
			return false;
		}
		int betThisRound = pData.betThisRound;
		if (pData.GetScrapAmount() < betThisRound)
		{
			return false;
		}
		return GetCardValue(pData.Cards[0], CardsValueMode.Low) == GetCardValue(pData.Cards[1], CardsValueMode.Low);
	}

	private bool HasAnyAces(List<PlayingCard> cards)
	{
		foreach (PlayingCard card in cards)
		{
			if (card.Rank == Rank.Ace)
			{
				return true;
			}
		}
		return false;
	}

	private bool CanDoubleDown(CardPlayerDataBlackjack pData)
	{
		if (pData.Cards.Count != 2)
		{
			return false;
		}
		if (HasAnyAces(pData.Cards))
		{
			return false;
		}
		int betThisRound = pData.betThisRound;
		return pData.GetScrapAmount() >= betThisRound;
	}

	private bool CanTakeInsurance(CardPlayerDataBlackjack pData)
	{
		if (dealerCards.Count != 2)
		{
			return false;
		}
		if (dealerCards[1].Rank != Rank.Ace)
		{
			return false;
		}
		if (pData.insuranceBetThisRound > 0)
		{
			return false;
		}
		int num = Mathf.FloorToInt((float)pData.betThisRound / 2f);
		return pData.GetScrapAmount() >= num;
	}

	private bool HasSplit(CardPlayerDataBlackjack pData)
	{
		return pData.SplitCards.Count > 0;
	}

	protected override CardPlayerData GetNewCardPlayerData(int mountIndex)
	{
		if (base.IsServer)
		{
			return new CardPlayerDataBlackjack(base.ScrapItemID, base.Owner.GetPlayerStorage, mountIndex, base.IsServer);
		}
		return new CardPlayerDataBlackjack(mountIndex, base.IsServer);
	}

	public bool TryGetCardPlayerDataBlackjack(int index, out CardPlayerDataBlackjack cpBlackjack)
	{
		CardPlayerData cardPlayer;
		bool result = TryGetCardPlayerData(index, out cardPlayer);
		cpBlackjack = (CardPlayerDataBlackjack)cardPlayer;
		return result;
	}

	public int ResultsToInt(BlackjackRoundResult mainResult, BlackjackRoundResult splitResult, int insurancePayout)
	{
		return (int)(mainResult + 10 * (int)splitResult + 100 * insurancePayout);
	}

	public void ResultsFromInt(int result, out BlackjackRoundResult mainResult, out BlackjackRoundResult splitResult, out int insurancePayout)
	{
		mainResult = (BlackjackRoundResult)(result % 10);
		splitResult = (BlackjackRoundResult)(result / 10 % 10);
		insurancePayout = (result - mainResult - splitResult) / 100;
	}

	public override void Save(CardGame syncData)
	{
		syncData.blackjack = Pool.Get<Blackjack>();
		syncData.blackjack.dealerCards = Pool.Get<List<int>>();
		syncData.lastActionId = (int)LastAction;
		syncData.lastActionTarget = LastActionTarget;
		syncData.lastActionValue = LastActionValue;
		for (int i = 0; i < dealerCards.Count; i++)
		{
			PlayingCard playingCard = dealerCards[i];
			if (base.HasActiveRound && i == 0)
			{
				syncData.blackjack.dealerCards.Add(-1);
			}
			else
			{
				syncData.blackjack.dealerCards.Add(playingCard.GetIndex());
			}
		}
		base.Save(syncData);
		ClearLastAction();
	}

	private void EditorMakeRandomMove(CardPlayerDataBlackjack pdBlackjack)
	{
		List<BlackjackInputOption> list = Pool.Get<List<BlackjackInputOption>>();
		InputsToList(pdBlackjack.availableInputs, list);
		if (list.Count == 0)
		{
			Debug.Log((object)"No moves currently available.");
			Pool.FreeUnmanaged<BlackjackInputOption>(ref list);
			return;
		}
		BlackjackInputOption blackjackInputOption = list[Random.Range(0, list.Count)];
		if (AllBetsPlaced)
		{
			if (GetOptimalCardsValue(pdBlackjack.Cards) < 17 && list.Contains(BlackjackInputOption.Hit))
			{
				blackjackInputOption = BlackjackInputOption.Hit;
			}
			else if (list.Contains(BlackjackInputOption.Stand))
			{
				blackjackInputOption = BlackjackInputOption.Stand;
			}
		}
		else if (list.Contains(BlackjackInputOption.SubmitBet))
		{
			blackjackInputOption = BlackjackInputOption.SubmitBet;
		}
		if (list.Count > 0)
		{
			int value = 0;
			if (blackjackInputOption == BlackjackInputOption.SubmitBet)
			{
				value = MinBuyIn;
			}
			Debug.Log((object)(pdBlackjack.UserID + " Taking random action: " + blackjackInputOption.ToString() + " with value " + value));
			ReceivedInputFromPlayer(pdBlackjack, (int)blackjackInputOption, countAsAction: true, value);
		}
		else
		{
			Debug.LogWarning((object)(GetType().Name + ": No input options are available for the current player."));
		}
		Pool.FreeUnmanaged<BlackjackInputOption>(ref list);
	}

	protected override int GetAvailableInputsForPlayer(CardPlayerData pData)
	{
		BlackjackInputOption blackjackInputOption = BlackjackInputOption.None;
		CardPlayerDataBlackjack cardPlayerDataBlackjack = (CardPlayerDataBlackjack)pData;
		if (cardPlayerDataBlackjack == null || isWaitingBetweenTurns || cardPlayerDataBlackjack.hasCompletedTurn || !cardPlayerDataBlackjack.HasUserInCurrentRound)
		{
			return (int)blackjackInputOption;
		}
		if (!base.HasActiveRound)
		{
			return (int)blackjackInputOption;
		}
		if (AllBetsPlaced)
		{
			blackjackInputOption |= BlackjackInputOption.Stand;
			if (!Has21(cardPlayerDataBlackjack.Cards))
			{
				blackjackInputOption |= BlackjackInputOption.Hit;
			}
			if (CanSplit(cardPlayerDataBlackjack))
			{
				blackjackInputOption |= BlackjackInputOption.Split;
			}
			if (CanDoubleDown(cardPlayerDataBlackjack))
			{
				blackjackInputOption |= BlackjackInputOption.DoubleDown;
			}
			if (CanTakeInsurance(cardPlayerDataBlackjack))
			{
				blackjackInputOption |= BlackjackInputOption.Insurance;
			}
		}
		else
		{
			blackjackInputOption |= BlackjackInputOption.SubmitBet;
			blackjackInputOption |= BlackjackInputOption.MaxBet;
		}
		return (int)blackjackInputOption;
	}

	protected override void SubEndGameplay()
	{
		dealerCards.Clear();
	}

	protected override void SubEndRound()
	{
		int dealerCardsVal = GetOptimalCardsValue(dealerCards);
		if (dealerCardsVal > 21)
		{
			dealerCardsVal = 0;
		}
		base.resultInfo.winningScore = dealerCardsVal;
		if (NumPlayersInCurrentRound() == 0)
		{
			base.Owner.ClientRPC<RoundResults>(RpcTarget.NetworkGroup("OnResultsDeclared"), base.resultInfo);
			return;
		}
		bool dealerHasBlackjack = HasBlackjack(dealerCards);
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			int num = 0;
			int winnings2;
			BlackjackRoundResult mainResult = CheckResult(item.Cards, item.betThisRound, out winnings2);
			num += winnings2;
			BlackjackRoundResult splitResult = CheckResult(item.SplitCards, item.splitBetThisRound, out winnings2);
			num += winnings2;
			int num2 = item.betThisRound + item.splitBetThisRound + item.insuranceBetThisRound;
			int insurancePayout = 0;
			if (dealerHasBlackjack && item.insuranceBetThisRound > 0)
			{
				int num3 = Mathf.FloorToInt((float)item.insuranceBetThisRound * 3f);
				num += num3;
				insurancePayout = num3;
			}
			int resultCode = ResultsToInt(mainResult, splitResult, insurancePayout);
			AddRoundResult(item, num - num2, resultCode);
			PayOut(item, num);
		}
		ClearPot();
		base.Owner.ClientRPC<RoundResults>(RpcTarget.NetworkGroup("OnResultsDeclared"), base.resultInfo);
		BlackjackRoundResult CheckResult(List<PlayingCard> cards, int betAmount, out int winnings)
		{
			if (cards.Count == 0)
			{
				winnings = 0;
				return BlackjackRoundResult.None;
			}
			int optimalCardsValue = GetOptimalCardsValue(cards);
			if (optimalCardsValue > 21)
			{
				winnings = 0;
				return BlackjackRoundResult.Bust;
			}
			if (optimalCardsValue > base.resultInfo.winningScore)
			{
				base.resultInfo.winningScore = optimalCardsValue;
			}
			BlackjackRoundResult blackjackRoundResult = BlackjackRoundResult.Loss;
			bool flag = HasBlackjack(cards);
			if (dealerHasBlackjack)
			{
				if (flag)
				{
					blackjackRoundResult = BlackjackRoundResult.Standoff;
				}
			}
			else if (optimalCardsValue > dealerCardsVal)
			{
				blackjackRoundResult = (flag ? BlackjackRoundResult.BlackjackWin : BlackjackRoundResult.Win);
			}
			else if (optimalCardsValue == dealerCardsVal)
			{
				blackjackRoundResult = ((!flag) ? BlackjackRoundResult.Standoff : BlackjackRoundResult.BlackjackWin);
			}
			switch (blackjackRoundResult)
			{
			case BlackjackRoundResult.BlackjackWin:
				winnings = Mathf.FloorToInt((float)betAmount * 2.5f);
				break;
			case BlackjackRoundResult.Win:
				winnings = Mathf.FloorToInt((float)betAmount * 2f);
				break;
			case BlackjackRoundResult.Standoff:
				winnings = betAmount;
				break;
			default:
				winnings = 0;
				break;
			}
			return blackjackRoundResult;
		}
	}

	private int PayOut(CardPlayerData pData, int winnings)
	{
		if (winnings == 0)
		{
			return 0;
		}
		StorageContainer storage = pData.GetStorage();
		if ((Object)(object)storage == (Object)null)
		{
			return 0;
		}
		storage.inventory.AddItem(base.Owner.scrapItemDef, winnings, 0uL, ItemContainer.LimitStack.None);
		return winnings;
	}

	protected override void HandlePlayerLeavingTable(CardPlayerData pData)
	{
		if (pData.HasUserInCurrentRound)
		{
			ReceivedInputFromPlayer(pData, 128, countAsAction: true, 0, playerInitiated: false);
		}
	}

	protected override void SubReceivedInputFromPlayer(CardPlayerData pData, int input, int value, bool countAsAction)
	{
		if (!Enum.IsDefined(typeof(BlackjackInputOption), input))
		{
			return;
		}
		BlackjackInputOption selectedMove = (BlackjackInputOption)input;
		CardPlayerDataBlackjack pdBlackjack = (CardPlayerDataBlackjack)pData;
		if (!base.HasActiveRound)
		{
			LastActionTarget = pData.UserID;
			LastAction = selectedMove;
			LastActionValue = 0;
			return;
		}
		int selectedMoveValue = 0;
		if (AllBetsPlaced)
		{
			DoInRoundPlayerInput(pdBlackjack, ref selectedMove, ref selectedMoveValue);
		}
		else
		{
			DoBettingPhasePlayerInput(pdBlackjack, value, countAsAction, ref selectedMove, ref selectedMoveValue);
		}
		LastActionTarget = pData.UserID;
		LastAction = selectedMove;
		LastActionValue = selectedMoveValue;
		if (NumPlayersInCurrentRound() == 0)
		{
			EndGameplay();
			return;
		}
		if (ShouldEndCycle())
		{
			EndCycle();
			return;
		}
		StartTurnTimer(pData, MaxTurnTime);
		base.Owner.SendNetworkUpdate();
	}

	private void DoInRoundPlayerInput(CardPlayerDataBlackjack pdBlackjack, ref BlackjackInputOption selectedMove, ref int selectedMoveValue)
	{
		if (selectedMove != BlackjackInputOption.Abandon && ((uint)pdBlackjack.availableInputs & (uint)selectedMove) != (uint)selectedMove)
		{
			return;
		}
		switch (selectedMove)
		{
		case BlackjackInputOption.Hit:
		{
			cardStack.TryTakeCard(out var card3);
			pdBlackjack.Cards.Add(card3);
			break;
		}
		case BlackjackInputOption.Stand:
			if (!pdBlackjack.TrySwitchToSplitHand())
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
			break;
		case BlackjackInputOption.Split:
		{
			PlayingCard playingCard = pdBlackjack.Cards[1];
			bool num = playingCard.Rank == Rank.Ace;
			pdBlackjack.SplitCards.Add(playingCard);
			pdBlackjack.Cards.Remove(playingCard);
			cardStack.TryTakeCard(out var card2);
			pdBlackjack.Cards.Add(card2);
			cardStack.TryTakeCard(out card2);
			pdBlackjack.SplitCards.Add(card2);
			selectedMoveValue = TryMakeBet(pdBlackjack, pdBlackjack.betThisRound, BetType.Split);
			if (num)
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
			break;
		}
		case BlackjackInputOption.DoubleDown:
		{
			selectedMoveValue = TryMakeBet(pdBlackjack, pdBlackjack.betThisRound, BetType.Main);
			cardStack.TryTakeCard(out var card);
			pdBlackjack.Cards.Add(card);
			if (!pdBlackjack.TrySwitchToSplitHand())
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
			break;
		}
		case BlackjackInputOption.Insurance:
		{
			int maxAmount = Mathf.FloorToInt((float)pdBlackjack.betThisRound / 2f);
			selectedMoveValue = TryMakeBet(pdBlackjack, maxAmount, BetType.Insurance);
			break;
		}
		case BlackjackInputOption.Abandon:
			pdBlackjack.LeaveGame();
			break;
		}
		if (HasBusted(pdBlackjack.Cards) && !pdBlackjack.TrySwitchToSplitHand())
		{
			pdBlackjack.SetHasCompletedTurn(hasActed: true);
		}
		if (Has21(pdBlackjack.Cards) && !CanTakeInsurance(pdBlackjack) && !CanDoubleDown(pdBlackjack) && !CanSplit(pdBlackjack) && !pdBlackjack.TrySwitchToSplitHand())
		{
			pdBlackjack.SetHasCompletedTurn(hasActed: true);
		}
	}

	private void DoBettingPhasePlayerInput(CardPlayerDataBlackjack pdBlackjack, int value, bool countAsAction, ref BlackjackInputOption selectedMove, ref int selectedMoveValue)
	{
		if (selectedMove != BlackjackInputOption.Abandon && ((uint)pdBlackjack.availableInputs & (uint)selectedMove) != (uint)selectedMove)
		{
			return;
		}
		if (selectedMove == BlackjackInputOption.SubmitBet)
		{
			selectedMoveValue = TryMakeBet(pdBlackjack, value, BetType.Main);
			if (countAsAction)
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
		}
		else if (selectedMove == BlackjackInputOption.MaxBet)
		{
			selectedMoveValue = TryMakeBet(pdBlackjack, BlackjackMachine.maxbet, BetType.Main);
			if (countAsAction)
			{
				pdBlackjack.SetHasCompletedTurn(hasActed: true);
			}
		}
		else if (selectedMove == BlackjackInputOption.Abandon)
		{
			pdBlackjack.LeaveGame();
		}
	}

	private int TryMakeBet(CardPlayerDataBlackjack pdBlackjack, int maxAmount, BetType betType)
	{
		int num = TryMoveToPotStorage(pdBlackjack, maxAmount);
		switch (betType)
		{
		case BetType.Main:
			pdBlackjack.betThisTurn += num;
			pdBlackjack.betThisRound += num;
			break;
		case BetType.Split:
			pdBlackjack.splitBetThisRound += num;
			break;
		case BetType.Insurance:
			pdBlackjack.insuranceBetThisRound += num;
			break;
		}
		return num;
	}

	protected override void SubStartRound()
	{
		dealerCards.Clear();
		cardStack = new StackOfCards(10);
		ClearLastAction();
		ServerPlaySound(CardGameSounds.SoundType.Shuffle);
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			item.EnableSendingCards();
			item.availableInputs = GetAvailableInputsForPlayer(item);
			StartTurnTimer(item, MaxTurnTime);
		}
	}

	protected override void OnTurnTimeout(CardPlayerData pData)
	{
		if (!pData.HasUserInCurrentRound || pData.hasCompletedTurn)
		{
			return;
		}
		BlackjackInputOption blackjackInputOption = BlackjackInputOption.Abandon;
		int value = 0;
		if (AllBetsPlaced)
		{
			if ((pData.availableInputs & 4) == 4)
			{
				blackjackInputOption = BlackjackInputOption.Stand;
				ReceivedInputFromPlayer(pData, 4, countAsAction: true, 0, playerInitiated: false);
			}
		}
		else if ((pData.availableInputs & 1) == 1 && pData.GetScrapAmount() >= MinBuyIn)
		{
			blackjackInputOption = BlackjackInputOption.SubmitBet;
			value = MinBuyIn;
		}
		if (blackjackInputOption != BlackjackInputOption.Abandon)
		{
			ReceivedInputFromPlayer(pData, (int)blackjackInputOption, countAsAction: true, value, playerInitiated: false);
			return;
		}
		blackjackInputOption = BlackjackInputOption.Abandon;
		ReceivedInputFromPlayer(pData, (int)blackjackInputOption, countAsAction: true, 0, playerInitiated: false);
		pData.ClearAllData();
		if (base.HasActiveRound && NumPlayersInCurrentRound() < MinPlayers)
		{
			BeginRoundEnd();
		}
		if (pData.HasUserInGame)
		{
			base.Owner.ClientRPC(RpcTarget.NetworkGroup("ClientOnPlayerLeft"), pData.UserID);
		}
		base.Owner.SendNetworkUpdate();
	}

	protected override void StartNextCycle()
	{
		base.StartNextCycle();
		if (ShouldEndCycle())
		{
			EndCycle();
			return;
		}
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			StartTurnTimer(item, MaxTurnTime);
		}
		UpdateAllAvailableInputs();
		base.Owner.SendNetworkUpdate();
	}

	protected override bool ShouldEndCycle()
	{
		foreach (CardPlayerData item in PlayersInRound())
		{
			if (!item.hasCompletedTurn)
			{
				return false;
			}
		}
		return true;
	}

	protected override void EndCycle()
	{
		CardPlayerData[] playerData = base.PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			playerData[i].SetHasCompletedTurn(hasActed: false);
		}
		if (dealerCards.Count == 0)
		{
			DealInitialCards();
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			QueueNextCycleInvoke();
			return;
		}
		bool flag = true;
		bool flag2 = true;
		foreach (CardPlayerDataBlackjack item in PlayersInRound())
		{
			if (!HasBusted(item.Cards))
			{
				flag = false;
			}
			if (!HasBlackjack(item.Cards))
			{
				flag2 = false;
			}
			if (item.SplitCards.Count > 0)
			{
				if (!HasBusted(item.SplitCards))
				{
					flag = false;
				}
				if (!HasBlackjack(item.SplitCards))
				{
					flag2 = false;
				}
			}
			if (!flag && !flag2)
			{
				break;
			}
		}
		ServerPlaySound(CardGameSounds.SoundType.Draw);
		if (NumPlayersInCurrentRound() > 0 && !flag && !flag2)
		{
			((FacepunchBehaviour)base.Owner).Invoke((Action)DealerPlayInvoke, 1f);
			BeginRoundEnd();
		}
		else
		{
			EndRoundWithDelay();
		}
	}

	private void DealerPlayInvoke()
	{
		int cardsValue = GetCardsValue(dealerCards, CardsValueMode.High);
		if (GetCardsValue(dealerCards, CardsValueMode.Low) < 17 && (cardsValue < 18 || cardsValue > 21))
		{
			cardStack.TryTakeCard(out var card);
			dealerCards.Add(card);
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			((FacepunchBehaviour)base.Owner).Invoke((Action)DealerPlayInvoke, 1f);
			base.Owner.SendNetworkUpdate();
		}
		else
		{
			EndRoundWithDelay();
		}
	}

	private void DealInitialCards()
	{
		if (!base.HasActiveRound)
		{
			return;
		}
		PlayingCard card;
		foreach (CardPlayerData item in PlayersInRound())
		{
			cardStack.TryTakeCard(out card);
			item.Cards.Add(card);
		}
		cardStack.TryTakeCard(out card);
		dealerCards.Add(card);
		foreach (CardPlayerData item2 in PlayersInRound())
		{
			cardStack.TryTakeCard(out card);
			item2.Cards.Add(card);
			if (HasBlackjack(item2.Cards))
			{
				item2.SetHasCompletedTurn(hasActed: true);
			}
		}
		cardStack.TryTakeCard(out card);
		dealerCards.Add(card);
	}

	private void ClearLastAction()
	{
		LastAction = BlackjackInputOption.None;
		LastActionTarget = 0uL;
		LastActionValue = 0;
	}
}


using System;

[Flags]
public enum BlackjackInputOption
{
	None = 0,
	SubmitBet = 1,
	Hit = 2,
	Stand = 4,
	Split = 8,
	DoubleDown = 0x10,
	Insurance = 0x20,
	MaxBet = 0x40,
	Abandon = 0x80
}


public enum BlackjackRoundResult
{
	None,
	Bust,
	Loss,
	Standoff,
	Win,
	BlackjackWin
}


public enum CardsValueMode
{
	Low,
	High
}


private enum BetType
{
	Main,
	Split,
	Insurance
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.CardGames;
using Network;
using ProtoBuf;
using UnityEngine;

public abstract class CardGameController : IDisposable
{
	public enum CardGameState
	{
		NotPlaying,
		InGameBetweenRounds,
		InGameRound,
		InGameRoundEnding
	}

	public enum Playability
	{
		OK,
		NoPlayer,
		NotEnoughBuyIn,
		TooMuchBuyIn,
		RanOutOfScrap,
		Idle
	}

	public const int IDLE_KICK_SECONDS = 240;

	public readonly CardList localPlayerCards;

	protected int activePlayerIndex;

	public const int STD_RAISE_INCREMENTS = 5;

	protected bool isWaitingBetweenTurns;

	public CardGameState State { get; set; }

	public bool HasGameInProgress => State >= CardGameState.InGameBetweenRounds;

	public bool HasRoundInProgressOrEnding
	{
		get
		{
			if (State != CardGameState.InGameRound)
			{
				return State == CardGameState.InGameRoundEnding;
			}
			return true;
		}
	}

	public bool HasActiveRound => State == CardGameState.InGameRound;

	public CardPlayerData[] PlayerData { get; private set; }

	public abstract int MinPlayers { get; }

	public abstract int MinBuyIn { get; }

	public abstract int MaxBuyIn { get; }

	public abstract int MinToPlay { get; }

	public virtual float MaxTurnTime => 30f;

	public virtual int EndRoundDelay => 0;

	public virtual int TimeBetweenRounds => 8;

	protected virtual float TimeBetweenTurns => 1f;

	public BaseCardGameEntity Owner { get; set; }

	public int ScrapItemID => Owner.ScrapItemID;

	protected bool IsServer => Owner.isServer;

	protected bool IsClient => Owner.isClient;

	public RoundResults resultInfo { get; private set; }

	public CardGameController(BaseCardGameEntity owner)
	{
		Owner = owner;
		PlayerData = new CardPlayerData[MaxPlayersAtTable()];
		resultInfo = Pool.Get<RoundResults>();
		resultInfo.results = Pool.Get<List<Result>>();
		localPlayerCards = Pool.Get<CardList>();
		localPlayerCards.cards = Pool.Get<List<int>>();
		for (int i = 0; i < PlayerData.Length; i++)
		{
			PlayerData[i] = GetNewCardPlayerData(i);
		}
	}

	public IEnumerable<CardPlayerData> PlayersInRound()
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.HasUserInCurrentRound)
			{
				yield return cardPlayerData;
			}
		}
	}

	protected abstract int GetFirstPlayerRelIndex(bool startOfRound);

	public void Dispose()
	{
		for (int i = 0; i < PlayerData.Length; i++)
		{
			PlayerData[i].Dispose();
		}
		localPlayerCards.Dispose();
		resultInfo.Dispose();
	}

	public int NumPlayersAllowedToPlay(CardPlayerData ignore = null)
	{
		int num = 0;
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData != ignore && IsAllowedToPlay(cardPlayerData))
			{
				num++;
			}
		}
		return num;
	}

	public Playability GetPlayabilityStatus(CardPlayerData cpd)
	{
		if (!cpd.HasUser)
		{
			return Playability.NoPlayer;
		}
		int scrapAmount = cpd.GetScrapAmount();
		if (cpd.HasUserInGame)
		{
			if (scrapAmount < MinToPlay)
			{
				return Playability.RanOutOfScrap;
			}
		}
		else
		{
			if (scrapAmount < MinBuyIn)
			{
				return Playability.NotEnoughBuyIn;
			}
			if (scrapAmount > MaxBuyIn)
			{
				return Playability.TooMuchBuyIn;
			}
		}
		return Playability.OK;
	}

	public bool TryGetActivePlayer(out CardPlayerData activePlayer)
	{
		return ToCardPlayerData(activePlayerIndex, includeOutOfRound: false, out activePlayer);
	}

	protected bool ToCardPlayerData(int relIndex, bool includeOutOfRound, out CardPlayerData result)
	{
		if (!HasRoundInProgressOrEnding)
		{
			Debug.LogWarning((object)(GetType().Name + ": Tried to call ToCardPlayerData while no round was in progress. Returning null."));
			result = null;
			return false;
		}
		int num = (includeOutOfRound ? NumPlayersInGame() : NumPlayersInCurrentRound());
		int index = RelToAbsIndex(relIndex % num, includeOutOfRound);
		return TryGetCardPlayerData(index, out result);
	}

	public int RelToAbsIndex(int relIndex, bool includeFolded)
	{
		if (!HasRoundInProgressOrEnding)
		{
			Debug.LogError((object)(GetType().Name + ": Called RelToAbsIndex outside of a round. No-one is playing. Returning -1."));
			return -1;
		}
		int num = 0;
		for (int i = 0; i < PlayerData.Length; i++)
		{
			if (includeFolded ? PlayerData[i].HasUserInGame : PlayerData[i].HasUserInCurrentRound)
			{
				if (num == relIndex)
				{
					return i;
				}
				num++;
			}
		}
		Debug.LogError((object)$"{GetType().Name}: No absolute index found for relative index {relIndex}. Only {NumPlayersInCurrentRound()} total players are in the round. Returning -1.");
		return -1;
	}

	public int GameToRoundIndex(int gameRelIndex)
	{
		if (!HasRoundInProgressOrEnding)
		{
			Debug.LogError((object)(GetType().Name + ": Called GameToRoundIndex outside of a round. No-one is playing. Returning 0."));
			return 0;
		}
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < PlayerData.Length; i++)
		{
			if (PlayerData[i].HasUserInCurrentRound)
			{
				if (num == gameRelIndex)
				{
					return num2;
				}
				num++;
				num2++;
			}
			else if (PlayerData[i].HasUserInGame)
			{
				if (num == gameRelIndex)
				{
					return num2;
				}
				num++;
			}
		}
		Debug.LogError((object)$"{GetType().Name}: No round index found for game index {gameRelIndex}. Only {NumPlayersInCurrentRound()} total players are in the round. Returning 0.");
		return 0;
	}

	public int NumPlayersInGame()
	{
		int num = 0;
		CardPlayerData[] playerData = PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			if (playerData[i].HasUserInGame)
			{
				num++;
			}
		}
		return num;
	}

	public int NumPlayersInCurrentRound()
	{
		int num = 0;
		CardPlayerData[] playerData = PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			if (playerData[i].HasUserInCurrentRound)
			{
				num++;
			}
		}
		return num;
	}

	public int MaxPlayersAtTable()
	{
		return Owner.mountPoints.Count;
	}

	public bool PlayerIsInGame(BasePlayer player)
	{
		return PlayerData.Any((CardPlayerData data) => data.HasUserInGame && data.UserID == (ulong)player.userID);
	}

	public bool IsAtTable(BasePlayer player)
	{
		return IsAtTable(player.userID);
	}

	public virtual List<PlayingCard> GetTableCards()
	{
		return null;
	}

	public void StartTurnTimer(CardPlayerData pData, float turnTime)
	{
		if (IsServer)
		{
			pData.StartTurnTimer(OnTurnTimeout, turnTime);
			Owner.ClientRPC(RpcTarget.NetworkGroup("ClientStartTurnTimer"), pData.mountIndex, turnTime);
		}
	}

	public bool IsAtTable(ulong userID)
	{
		return PlayerData.Any((CardPlayerData data) => data.UserID == userID);
	}

	public int GetScrapInPot()
	{
		if (IsServer)
		{
			StorageContainer pot = Owner.GetPot();
			if ((Object)(object)pot != (Object)null)
			{
				return pot.inventory.GetAmount(ScrapItemID, onlyUsableAmounts: true);
			}
			return 0;
		}
		return 0;
	}

	public bool TryGetCardPlayerData(int index, out CardPlayerData cardPlayer)
	{
		if (index >= 0 && index < PlayerData.Length)
		{
			cardPlayer = PlayerData[index];
			return true;
		}
		cardPlayer = null;
		return false;
	}

	public bool TryGetCardPlayerData(ulong forPlayer, out CardPlayerData cardPlayer)
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.UserID == forPlayer)
			{
				cardPlayer = cardPlayerData;
				return true;
			}
		}
		cardPlayer = null;
		return false;
	}

	public bool TryGetCardPlayerData(BasePlayer forPlayer, out CardPlayerData cardPlayer)
	{
		for (int i = 0; i < PlayerData.Length; i++)
		{
			if (PlayerData[i].UserID == (ulong)forPlayer.userID)
			{
				cardPlayer = PlayerData[i];
				return true;
			}
		}
		cardPlayer = null;
		return false;
	}

	public bool IsAllowedToPlay(CardPlayerData cpd)
	{
		return GetPlayabilityStatus(cpd) == Playability.OK;
	}

	protected void ClearResultsInfo()
	{
		if (resultInfo.results == null)
		{
			return;
		}
		foreach (Result result in resultInfo.results)
		{
			if (result != null)
			{
				result.Dispose();
			}
		}
		resultInfo.results.Clear();
	}

	protected abstract CardPlayerData GetNewCardPlayerData(int mountIndex);

	protected abstract void OnTurnTimeout(CardPlayerData playerData);

	protected abstract void SubStartRound();

	protected abstract void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction);

	protected abstract int GetAvailableInputsForPlayer(CardPlayerData playerData);

	protected abstract void HandlePlayerLeavingTable(CardPlayerData pData);

	protected abstract void SubEndRound();

	protected abstract void SubEndGameplay();

	protected abstract void EndCycle();

	protected abstract bool ShouldEndCycle();

	public void EditorMakeRandomMove()
	{
	}

	public void JoinTable(BasePlayer player)
	{
		JoinTable(player.userID);
	}

	protected void SyncAllLocalPlayerCards()
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData pData in playerData)
		{
			SyncLocalPlayerCards(pData);
		}
	}

	protected void SyncLocalPlayerCards(CardPlayerData pData)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(pData.UserID);
		if ((Object)(object)basePlayer == (Object)null || !pData.HasUserInGame)
		{
			return;
		}
		localPlayerCards.cards.Clear();
		foreach (PlayingCard card in pData.Cards)
		{
			localPlayerCards.cards.Add(card.GetIndex());
		}
		Owner.ClientRPC<CardList>(RpcTarget.Player("ReceiveCardsForPlayer", basePlayer), localPlayerCards);
	}

	public void JoinTable(ulong userID)
	{
		if (IsAtTable(userID) || NumPlayersAllowedToPlay() >= MaxPlayersAtTable())
		{
			return;
		}
		int mountPointIndex = Owner.GetMountPointIndex(userID);
		if (mountPointIndex < 0)
		{
			return;
		}
		PlayerData[mountPointIndex].AddUser(userID);
		if (!HasGameInProgress)
		{
			if (!TryStartNewRound())
			{
				Owner.SendNetworkUpdate();
			}
		}
		else
		{
			Owner.SendNetworkUpdate();
		}
	}

	public void LeaveTable(ulong userID)
	{
		if (TryGetCardPlayerData(userID, out var cardPlayer))
		{
			LeaveTable(cardPlayer);
		}
	}

	public void LeaveTable(CardPlayerData pData)
	{
		if (HasActiveRound)
		{
			HandlePlayerLeavingTable(pData);
		}
		pData.ClearAllData();
		if (HasActiveRound && NumPlayersInCurrentRound() < MinPlayers)
		{
			EndRoundWithDelay();
		}
		if (pData.HasUserInGame)
		{
			Owner.ClientRPC(RpcTarget.NetworkGroup("ClientOnPlayerLeft"), pData.UserID);
		}
		Owner.SendNetworkUpdate();
	}

	protected int TryAddBet(CardPlayerData playerData, int maxAmount)
	{
		int num = TryMoveToPotStorage(playerData, maxAmount);
		playerData.betThisRound += num;
		playerData.betThisTurn += num;
		return num;
	}

	protected int GoAllIn(CardPlayerData playerData)
	{
		int num = TryMoveToPotStorage(playerData, 999999);
		playerData.betThisRound += num;
		playerData.betThisTurn += num;
		return num;
	}

	protected int TryMoveToPotStorage(CardPlayerData playerData, int maxAmount)
	{
		int num = 0;
		StorageContainer storage = playerData.GetStorage();
		StorageContainer pot = Owner.GetPot();
		if ((Object)(object)storage != (Object)null && (Object)(object)pot != (Object)null)
		{
			List<Item> list = Pool.Get<List<Item>>();
			num = storage.inventory.Take(list, ScrapItemID, maxAmount);
			if (num > 0)
			{
				foreach (Item item in list)
				{
					if (!item.MoveToContainer(pot.inventory, -1, allowStack: true, ignoreStackLimit: true))
					{
						item.MoveToContainer(storage.inventory);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": TryAddToPot: Null storage."));
		}
		return num;
	}

	protected int PayOutFromPot(CardPlayerData playerData, int maxAmount)
	{
		int num = 0;
		StorageContainer storage = playerData.GetStorage();
		StorageContainer pot = Owner.GetPot();
		if ((Object)(object)storage != (Object)null && (Object)(object)pot != (Object)null)
		{
			List<Item> list = Pool.Get<List<Item>>();
			num = pot.inventory.Take(list, ScrapItemID, maxAmount);
			if (num > 0)
			{
				foreach (Item item in list)
				{
					if (!item.MoveToContainer(storage.inventory, -1, allowStack: true, ignoreStackLimit: true))
					{
						item.MoveToContainer(pot.inventory);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
		}
		else
		{
			Debug.LogError((object)(GetType().Name + ": PayOut: Null storage."));
		}
		return num;
	}

	protected int PayOutAllFromPot(CardPlayerData playerData)
	{
		return PayOutFromPot(playerData, int.MaxValue);
	}

	protected void ClearPot()
	{
		StorageContainer pot = Owner.GetPot();
		if ((Object)(object)pot != (Object)null)
		{
			pot.inventory.Clear();
		}
	}

	public int RemoveScrapFromStorage(CardPlayerData data)
	{
		StorageContainer storage = data.GetStorage();
		BasePlayer basePlayer = BasePlayer.FindByID(data.UserID);
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			List<Item> list = Pool.Get<List<Item>>();
			num = storage.inventory.Take(list, ScrapItemID, int.MaxValue);
			if (num > 0)
			{
				foreach (Item item in list)
				{
					if (!item.MoveToContainer(basePlayer.inventory.containerMain, -1, allowStack: true, ignoreStackLimit: true))
					{
						item.MoveToContainer(storage.inventory);
					}
				}
			}
			Pool.Free<Item>(ref list, false);
		}
		return num;
	}

	public virtual void Save(CardGame syncData)
	{
		syncData.players = Pool.Get<List<CardPlayer>>();
		syncData.state = (int)State;
		syncData.activePlayerIndex = activePlayerIndex;
		CardPlayerData[] playerData = PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			playerData[i].Save(syncData);
		}
		syncData.pot = GetScrapInPot();
	}

	public void InvokeStartNewRound()
	{
		TryStartNewRound();
	}

	public bool TryStartNewRound()
	{
		if (HasRoundInProgressOrEnding)
		{
			return false;
		}
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			BasePlayer basePlayer;
			if (State == CardGameState.NotPlaying)
			{
				cardPlayerData.lastActionTime = Time.unscaledTime;
			}
			else if (cardPlayerData.HasBeenIdleFor(240) && BasePlayer.TryFindByID(cardPlayerData.UserID, out basePlayer))
			{
				basePlayer.GetMounted().DismountPlayer(basePlayer);
			}
		}
		if (NumPlayersAllowedToPlay() < MinPlayers)
		{
			EndGameplay();
			return false;
		}
		playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData2 in playerData)
		{
			if (IsAllowedToPlay(cardPlayerData2))
			{
				cardPlayerData2.JoinRound();
			}
			else
			{
				cardPlayerData2.LeaveGame();
			}
		}
		State = CardGameState.InGameRound;
		SubStartRound();
		Owner.SendNetworkUpdate();
		return true;
	}

	protected void BeginRoundEnd()
	{
		State = CardGameState.InGameRoundEnding;
		CancelNextCycleInvoke();
		Owner.SendNetworkUpdate();
	}

	protected void EndRoundWithDelay()
	{
		State = CardGameState.InGameRoundEnding;
		CancelNextCycleInvoke();
		Owner.SendNetworkUpdate();
		((FacepunchBehaviour)Owner).Invoke((Action)EndRound, (float)EndRoundDelay);
	}

	public void EndRound()
	{
		State = CardGameState.InGameBetweenRounds;
		CancelNextCycleInvoke();
		ClearResultsInfo();
		SubEndRound();
		foreach (CardPlayerData item in PlayersInRound())
		{
			BasePlayer basePlayer = BasePlayer.FindByID(item.UserID);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.metabolism.CanConsume())
			{
				basePlayer.metabolism.MarkConsumption();
				basePlayer.metabolism.ApplyChange(MetabolismAttribute.Type.Calories, 2f, 0f);
				basePlayer.metabolism.ApplyChange(MetabolismAttribute.Type.Hydration, 2f, 0f);
			}
			item.LeaveCurrentRound(clearBets: true, leftRoundEarly: false);
		}
		UpdateAllAvailableInputs();
		Owner.SendNetworkUpdate();
		((FacepunchBehaviour)Owner).Invoke((Action)InvokeStartNewRound, (float)TimeBetweenRounds);
	}

	protected virtual void AddRoundResult(CardPlayerData pData, int winnings, int resultCode)
	{
		foreach (Result result in resultInfo.results)
		{
			if (result.ID == pData.UserID)
			{
				result.winnings += winnings;
				return;
			}
		}
		Result val = Pool.Get<Result>();
		val.ID = pData.UserID;
		val.winnings = winnings;
		val.resultCode = resultCode;
		resultInfo.results.Add(val);
	}

	protected void EndGameplay()
	{
		if (HasGameInProgress)
		{
			CancelNextCycleInvoke();
			SubEndGameplay();
			State = CardGameState.NotPlaying;
			CardPlayerData[] playerData = PlayerData;
			for (int i = 0; i < playerData.Length; i++)
			{
				playerData[i].LeaveGame();
			}
			SyncAllLocalPlayerCards();
			Owner.SendNetworkUpdate();
		}
	}

	public void ReceivedInputFromPlayer(BasePlayer player, int input, bool countAsAction, int value = 0)
	{
		if (!((Object)(object)player == (Object)null))
		{
			player.ResetInputIdleTime();
			if (TryGetCardPlayerData(player, out var cardPlayer))
			{
				ReceivedInputFromPlayer(cardPlayer, input, countAsAction, value);
			}
		}
	}

	public void ReceivedInputFromPlayer(CardPlayerData pData, int input, bool countAsAction, int value = 0, bool playerInitiated = true)
	{
		if (HasGameInProgress && pData != null)
		{
			if (playerInitiated)
			{
				pData.lastActionTime = Time.unscaledTime;
			}
			SubReceivedInputFromPlayer(pData, input, value, countAsAction);
			if (HasActiveRound)
			{
				UpdateAllAvailableInputs();
				Owner.SendNetworkUpdate();
			}
		}
	}

	public void UpdateAllAvailableInputs()
	{
		for (int i = 0; i < PlayerData.Length; i++)
		{
			PlayerData[i].availableInputs = GetAvailableInputsForPlayer(PlayerData[i]);
		}
	}

	public void PlayerStorageChanged()
	{
		if (!HasGameInProgress)
		{
			TryStartNewRound();
		}
	}

	public void ServerPlaySound(CardGameSounds.SoundType type)
	{
		Owner.ClientRPC(RpcTarget.NetworkGroup("ClientPlaySound"), (int)type);
	}

	public void GetConnectionsInGame(List<Connection> connections)
	{
		CardPlayerData[] playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.HasUserInGame && BasePlayer.TryFindByID(cardPlayerData.UserID, out var basePlayer))
			{
				connections.Add(basePlayer.net.connection);
			}
		}
	}

	public virtual void OnTableDestroyed()
	{
		CardPlayerData[] playerData;
		if (HasGameInProgress)
		{
			playerData = PlayerData;
			foreach (CardPlayerData cardPlayerData in playerData)
			{
				if (cardPlayerData.HasUserInGame)
				{
					PayOutFromPot(cardPlayerData, cardPlayerData.GetTotalBetThisRound());
				}
			}
			if (GetScrapInPot() > 0)
			{
				int maxAmount = GetScrapInPot() / NumPlayersInGame();
				playerData = PlayerData;
				foreach (CardPlayerData cardPlayerData2 in playerData)
				{
					if (cardPlayerData2.HasUserInGame)
					{
						PayOutFromPot(cardPlayerData2, maxAmount);
					}
				}
			}
		}
		playerData = PlayerData;
		foreach (CardPlayerData cardPlayerData3 in playerData)
		{
			if (cardPlayerData3.HasUser)
			{
				RemoveScrapFromStorage(cardPlayerData3);
			}
		}
	}

	protected bool TryMoveToNextPlayerWithInputs(int startIndex, out CardPlayerData newActivePlayer)
	{
		activePlayerIndex = startIndex;
		TryGetActivePlayer(out newActivePlayer);
		int num = 0;
		bool flag = false;
		while (GetAvailableInputsForPlayer(newActivePlayer) == 0)
		{
			if (num == NumPlayersInCurrentRound())
			{
				flag = true;
				break;
			}
			activePlayerIndex = (activePlayerIndex + 1) % NumPlayersInCurrentRound();
			TryGetActivePlayer(out newActivePlayer);
			num++;
		}
		return !flag;
	}

	protected virtual void StartNextCycle()
	{
		isWaitingBetweenTurns = false;
	}

	protected void QueueNextCycleInvoke()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)StartNextCycle, TimeBetweenTurns);
		isWaitingBetweenTurns = true;
		Owner.SendNetworkUpdate();
	}

	private void CancelNextCycleInvoke()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).CancelInvoke((Action)StartNextCycle);
		isWaitingBetweenTurns = false;
	}
}


public enum CardGameState
{
	NotPlaying,
	InGameBetweenRounds,
	InGameRound,
	InGameRoundEnding
}


public enum Playability
{
	OK,
	NoPlayer,
	NotEnoughBuyIn,
	TooMuchBuyIn,
	RanOutOfScrap,
	Idle
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using ProtoBuf;
using UnityEngine;

public class CardPlayerData : IDisposable
{
	public enum CardPlayerState
	{
		None,
		WantsToPlay,
		InGame,
		InCurrentRound
	}

	public List<PlayingCard> Cards;

	public readonly int mountIndex;

	private readonly bool isServer;

	[NonSerialized]
	public int availableInputs;

	public int betThisRound;

	public int betThisTurn;

	[NonSerialized]
	public int finalScore;

	[NonSerialized]
	public float lastActionTime;

	[NonSerialized]
	public int remainingToPayOut;

	private Func<int, StorageContainer> getStorage;

	public readonly int scrapItemID;

	private Action<CardPlayerData> turnTimerCallback;

	public ulong UserID { get; set; }

	public CardPlayerState State { get; set; }

	public bool HasUser => State >= CardPlayerState.WantsToPlay;

	public bool HasUserInGame => State >= CardPlayerState.InGame;

	public bool HasUserInCurrentRound => State == CardPlayerState.InCurrentRound;

	public bool HasAvailableInputs => availableInputs > 0;

	public bool AllCardsAreKnown
	{
		get
		{
			if (Cards.Count == 0)
			{
				return false;
			}
			foreach (PlayingCard card in Cards)
			{
				if (card.IsUnknownCard)
				{
					return false;
				}
			}
			return true;
		}
	}

	private bool IsClient => !isServer;

	public bool LeftRoundEarly { get; set; }

	public bool SendCardDetails { get; set; }

	public bool hasCompletedTurn { get; private set; }

	public CardPlayerData(int mountIndex, bool isServer)
	{
		this.isServer = isServer;
		this.mountIndex = mountIndex;
		Cards = Pool.Get<List<PlayingCard>>();
	}

	public CardPlayerData(int scrapItemID, Func<int, StorageContainer> getStorage, int mountIndex, bool isServer)
		: this(mountIndex, isServer)
	{
		this.scrapItemID = scrapItemID;
		this.getStorage = getStorage;
	}

	public virtual void Dispose()
	{
		Pool.FreeUnmanaged<PlayingCard>(ref Cards);
		if (isServer)
		{
			CancelTurnTimer();
		}
	}

	public int GetScrapAmount()
	{
		if (isServer)
		{
			StorageContainer storage = GetStorage();
			if ((Object)(object)storage != (Object)null)
			{
				return storage.inventory.GetAmount(scrapItemID, onlyUsableAmounts: true);
			}
			Debug.LogError((object)(GetType().Name + ": Couldn't get player storage."));
		}
		return 0;
	}

	public virtual int GetTotalBetThisRound()
	{
		return betThisRound;
	}

	public virtual List<PlayingCard> GetMainCards()
	{
		return Cards;
	}

	public virtual List<PlayingCard> GetSecondaryCards()
	{
		return null;
	}

	public void SetHasCompletedTurn(bool hasActed)
	{
		hasCompletedTurn = hasActed;
		if (!hasActed)
		{
			betThisTurn = 0;
		}
	}

	public bool HasBeenIdleFor(int seconds)
	{
		if (HasUserInGame)
		{
			return Time.unscaledTime > lastActionTime + (float)seconds;
		}
		return false;
	}

	public StorageContainer GetStorage()
	{
		return getStorage(mountIndex);
	}

	public void AddUser(ulong userID)
	{
		ClearAllData();
		UserID = userID;
		State = CardPlayerState.WantsToPlay;
		lastActionTime = Time.unscaledTime;
	}

	public void ClearAllData()
	{
		UserID = 0uL;
		availableInputs = 0;
		State = CardPlayerState.None;
		ClearPerRoundData();
	}

	public void JoinRound()
	{
		if (HasUser)
		{
			State = CardPlayerState.InCurrentRound;
			ClearPerRoundData();
		}
	}

	protected virtual void ClearPerRoundData()
	{
		Cards.Clear();
		betThisRound = 0;
		betThisTurn = 0;
		finalScore = 0;
		LeftRoundEarly = false;
		hasCompletedTurn = false;
		SendCardDetails = false;
	}

	public virtual void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
	{
		if (HasUserInCurrentRound)
		{
			availableInputs = 0;
			finalScore = 0;
			hasCompletedTurn = false;
			if (clearBets)
			{
				betThisRound = 0;
				betThisTurn = 0;
			}
			State = CardPlayerState.InGame;
			LeftRoundEarly = leftRoundEarly;
			CancelTurnTimer();
		}
	}

	public virtual void LeaveGame()
	{
		if (HasUserInGame)
		{
			Cards.Clear();
			availableInputs = 0;
			finalScore = 0;
			SendCardDetails = false;
			LeftRoundEarly = false;
			State = CardPlayerState.WantsToPlay;
		}
	}

	public void EnableSendingCards()
	{
		SendCardDetails = true;
	}

	public string HandToString()
	{
		return HandToString(Cards);
	}

	public static string HandToString(List<PlayingCard> cards)
	{
		string text = string.Empty;
		foreach (PlayingCard card in cards)
		{
			text = text + "23456789TJQKA"[(int)card.Rank] + ""[(int)card.Suit] + " ";
		}
		return text;
	}

	public virtual void Save(CardGame syncData)
	{
		CardPlayer val = Pool.Get<CardPlayer>();
		val.userid = UserID;
		val.cards = Pool.Get<List<int>>();
		foreach (PlayingCard card in Cards)
		{
			val.cards.Add(SendCardDetails ? card.GetIndex() : (-1));
		}
		val.scrap = GetScrapAmount();
		val.state = (int)State;
		val.availableInputs = availableInputs;
		val.betThisRound = betThisRound;
		val.betThisTurn = betThisTurn;
		val.leftRoundEarly = LeftRoundEarly;
		val.sendCardDetails = SendCardDetails;
		syncData.players.Add(val);
	}

	public void StartTurnTimer(Action<CardPlayerData> callback, float maxTurnTime)
	{
		turnTimerCallback = callback;
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)TimeoutTurn, maxTurnTime);
	}

	public void CancelTurnTimer()
	{
		((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).CancelInvoke((Action)TimeoutTurn);
	}

	public void TimeoutTurn()
	{
		if (turnTimerCallback != null)
		{
			turnTimerCallback(this);
		}
	}
}


public enum CardPlayerState
{
	None,
	WantsToPlay,
	InGame,
	InCurrentRound
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using ProtoBuf;

public class CardPlayerDataBlackjack : CardPlayerData
{
	public List<PlayingCard> SplitCards;

	public int splitBetThisRound;

	public int insuranceBetThisRound;

	public bool playingSplitCards;

	public CardPlayerDataBlackjack(int mountIndex, bool isServer)
		: base(mountIndex, isServer)
	{
		SplitCards = Pool.Get<List<PlayingCard>>();
	}

	public CardPlayerDataBlackjack(int scrapItemID, Func<int, StorageContainer> getStorage, int mountIndex, bool isServer)
		: base(scrapItemID, getStorage, mountIndex, isServer)
	{
		SplitCards = Pool.Get<List<PlayingCard>>();
	}

	public override void Dispose()
	{
		base.Dispose();
		Pool.FreeUnmanaged<PlayingCard>(ref SplitCards);
	}

	public override int GetTotalBetThisRound()
	{
		return betThisRound + splitBetThisRound + insuranceBetThisRound;
	}

	public override List<PlayingCard> GetSecondaryCards()
	{
		return SplitCards;
	}

	protected override void ClearPerRoundData()
	{
		base.ClearPerRoundData();
		SplitCards.Clear();
		splitBetThisRound = 0;
		insuranceBetThisRound = 0;
		playingSplitCards = false;
	}

	public override void LeaveCurrentRound(bool clearBets, bool leftRoundEarly)
	{
		if (base.HasUserInCurrentRound)
		{
			if (clearBets)
			{
				splitBetThisRound = 0;
				insuranceBetThisRound = 0;
			}
			base.LeaveCurrentRound(clearBets, leftRoundEarly);
		}
	}

	public override void LeaveGame()
	{
		base.LeaveGame();
		if (base.HasUserInGame)
		{
			SplitCards.Clear();
		}
	}

	public override void Save(CardGame syncData)
	{
		base.Save(syncData);
		BlackjackCardPlayer val = Pool.Get<BlackjackCardPlayer>();
		val.splitCards = Pool.Get<List<int>>();
		foreach (PlayingCard splitCard in SplitCards)
		{
			val.splitCards.Add(base.SendCardDetails ? splitCard.GetIndex() : (-1));
		}
		val.splitBetThisRound = splitBetThisRound;
		val.insuranceBetThisRound = insuranceBetThisRound;
		val.playingSplitCards = playingSplitCards;
		if (syncData.blackjack.players == null)
		{
			syncData.blackjack.players = Pool.Get<List<BlackjackCardPlayer>>();
		}
		syncData.blackjack.players.Add(val);
	}

	public bool TrySwitchToSplitHand()
	{
		if (SplitCards.Count > 0 && !playingSplitCards)
		{
			SwapSplitCardsWithMain();
			playingSplitCards = true;
			return true;
		}
		return false;
	}

	private void SwapSplitCardsWithMain()
	{
		List<PlayingCard> list = Pool.Get<List<PlayingCard>>();
		list.AddRange(Cards);
		Cards.Clear();
		Cards.AddRange(SplitCards);
		SplitCards.Clear();
		SplitCards.AddRange(list);
		Pool.FreeUnmanaged<PlayingCard>(ref list);
		int num = betThisRound;
		int num2 = splitBetThisRound;
		splitBetThisRound = num;
		betThisRound = num2;
	}
}


using System.Collections.Generic;
using System.Text;
using Facepunch.CardGames;
using UnityEngine;

public class StackOfCards
{
	private readonly List<PlayingCard> cards;

	public StackOfCards(int numDecks)
	{
		cards = new List<PlayingCard>(52 * numDecks);
		for (int i = 0; i < numDecks; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				for (int k = 0; k < 13; k++)
				{
					cards.Add(PlayingCard.GetCard(j, k));
				}
			}
		}
		ShuffleDeck();
	}

	public bool TryTakeCard(out PlayingCard card)
	{
		if (cards.Count == 0)
		{
			card = null;
			return false;
		}
		card = cards[cards.Count - 1];
		cards.RemoveAt(cards.Count - 1);
		return true;
	}

	public void AddCard(PlayingCard card)
	{
		cards.Insert(0, card);
	}

	public void ShuffleDeck()
	{
		int num = cards.Count;
		while (num > 1)
		{
			num--;
			int num2 = Random.Range(0, num);
			List<PlayingCard> list = cards;
			int index = num2;
			List<PlayingCard> list2 = cards;
			int index2 = num;
			PlayingCard playingCard = cards[num];
			PlayingCard playingCard2 = cards[num2];
			PlayingCard playingCard4 = (list[index] = playingCard);
			playingCard4 = (list2[index2] = playingCard2);
		}
	}

	public void Print()
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Cards in the deck: ");
		foreach (PlayingCard card in cards)
		{
			stringBuilder.AppendLine(card.Rank.ToString() + " of " + card.Suit);
		}
		Debug.Log((object)stringBuilder.ToString());
	}
}


public enum Rank
{
	Two,
	Three,
	Four,
	Five,
	Six,
	Seven,
	Eight,
	Nine,
	Ten,
	Jack,
	Queen,
	King,
	Ace
}


public enum Suit
{
	Spades,
	Hearts,
	Diamonds,
	Clubs
}


using Facepunch.CardGames;
using PokerEvaluator;
using UnityEngine;

public class PlayingCard
{
	public readonly bool IsUnknownCard;

	public readonly Suit Suit;

	public readonly Rank Rank;

	public static PlayingCard[] cards = GenerateAllCards();

	public static PlayingCard unknownCard = new PlayingCard();

	private PlayingCard(Suit suit, Rank rank)
	{
		IsUnknownCard = false;
		Suit = suit;
		Rank = rank;
	}

	private PlayingCard()
	{
		IsUnknownCard = true;
		Suit = Suit.Spades;
		Rank = Rank.Two;
	}

	public static PlayingCard GetCard(Suit suit, Rank rank)
	{
		return GetCard((int)suit, (int)rank);
	}

	public static PlayingCard GetCard(int suit, int rank)
	{
		return cards[suit * 13 + rank];
	}

	public static PlayingCard GetCard(int index)
	{
		if (index == -1)
		{
			return unknownCard;
		}
		return cards[index];
	}

	public int GetIndex()
	{
		if (IsUnknownCard)
		{
			return -1;
		}
		return GetIndex(Suit, Rank);
	}

	public static int GetIndex(Suit suit, Rank rank)
	{
		return (int)((int)suit * 13 + rank);
	}

	public int GetPokerEvaluationValue()
	{
		if (IsUnknownCard)
		{
			Debug.LogWarning((object)(GetType().Name + ": Called GetPokerEvaluationValue on unknown card."));
		}
		return Arrays.primes[(int)Rank] | ((int)Rank << 8) | GetPokerSuitCode() | (1 << (int)(16 + Rank));
	}

	private int GetPokerSuitCode()
	{
		if (IsUnknownCard)
		{
			Debug.LogWarning((object)(GetType().Name + ": Called GetPokerSuitCode on unknown card."));
		}
		return Suit switch
		{
			Suit.Spades => 4096, 
			Suit.Hearts => 8192, 
			Suit.Diamonds => 16384, 
			Suit.Clubs => 32768, 
			_ => 4096, 
		};
	}

	private static PlayingCard[] GenerateAllCards()
	{
		PlayingCard[] array = new PlayingCard[52];
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 13; j++)
			{
				array[i * 13 + j] = new PlayingCard((Suit)i, (Rank)j);
			}
		}
		return array;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.CardGames;
using PokerEvaluator;
using ProtoBuf;
using Rust;
using UnityEngine;

public class TexasHoldEmController : CardGameController
{
	[Flags]
	public enum PokerInputOption
	{
		None = 0,
		Fold = 1,
		Call = 2,
		AllIn = 4,
		Check = 8,
		Raise = 0x10,
		Bet = 0x20,
		RevealHand = 0x40
	}

	public enum PokerRoundResult
	{
		Loss,
		PrimaryWinner,
		SecondaryWinner
	}

	public List<PlayingCard> communityCards = new List<PlayingCard>();

	public const int SMALL_BLIND = 5;

	public const int BIG_BLIND = 10;

	public const string WON_HAND_STAT = "won_hand_texas_holdem";

	private int dealerIndex;

	private StackOfCards deck = new StackOfCards(1);

	public override int MinPlayers => 2;

	public override int MinBuyIn => 100;

	public override int MaxBuyIn => 1000;

	public override int MinToPlay => 10;

	public PokerInputOption LastAction { get; private set; }

	public ulong LastActionTarget { get; private set; }

	public int LastActionValue { get; private set; }

	public int BiggestRaiseThisTurn { get; private set; }

	public TexasHoldEmController(BaseCardGameEntity owner)
		: base(owner)
	{
	}

	public int GetCurrentBet()
	{
		int num = 0;
		foreach (CardPlayerData item in PlayersInRound())
		{
			num = Mathf.Max(num, item.betThisTurn);
		}
		return num;
	}

	public bool TryGetDealer(out CardPlayerData dealer)
	{
		return ToCardPlayerData(dealerIndex, includeOutOfRound: true, out dealer);
	}

	public bool TryGetSmallBlind(out CardPlayerData smallBlind)
	{
		int relIndex = ((NumPlayersInGame() < 3) ? dealerIndex : (dealerIndex + 1));
		return ToCardPlayerData(relIndex, includeOutOfRound: true, out smallBlind);
	}

	public bool TryGetBigBlind(out CardPlayerData bigBlind)
	{
		int relIndex = ((NumPlayersInGame() < 3) ? (dealerIndex + 1) : (dealerIndex + 2));
		return ToCardPlayerData(relIndex, includeOutOfRound: true, out bigBlind);
	}

	protected override int GetFirstPlayerRelIndex(bool startOfRound)
	{
		int num = NumPlayersInGame();
		if (startOfRound && num == 2)
		{
			return dealerIndex;
		}
		return (dealerIndex + 1) % num;
	}

	public static ushort EvaluatePokerHand(List<PlayingCard> cards)
	{
		ushort result = 0;
		int[] array = new int[cards.Count];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = cards[i].GetPokerEvaluationValue();
		}
		if (cards.Count == 5)
		{
			result = PokerLib.Eval5Hand(array);
		}
		else if (cards.Count == 7)
		{
			result = PokerLib.Eval7Hand(array);
		}
		else
		{
			Debug.LogError((object)"Currently we can only evaluate five or seven card hands.");
		}
		return result;
	}

	public int GetCurrentMinRaise(CardPlayerData playerData)
	{
		return Mathf.Max(10, GetCurrentBet() - playerData.betThisTurn + BiggestRaiseThisTurn);
	}

	public override List<PlayingCard> GetTableCards()
	{
		return communityCards;
	}

	public void InputsToList(int availableInputs, List<PokerInputOption> result)
	{
		PokerInputOption[] array = (PokerInputOption[])Enum.GetValues(typeof(PokerInputOption));
		foreach (PokerInputOption pokerInputOption in array)
		{
			if (pokerInputOption != 0 && ((uint)availableInputs & (uint)pokerInputOption) == (uint)pokerInputOption)
			{
				result.Add(pokerInputOption);
			}
		}
	}

	protected override CardPlayerData GetNewCardPlayerData(int mountIndex)
	{
		if (base.IsServer)
		{
			return new CardPlayerData(base.ScrapItemID, base.Owner.GetPlayerStorage, mountIndex, base.IsServer);
		}
		return new CardPlayerData(mountIndex, base.IsServer);
	}

	public override void Save(CardGame syncData)
	{
		base.Save(syncData);
		syncData.texasHoldEm = Pool.Get<TexasHoldEm>();
		syncData.texasHoldEm.dealerIndex = dealerIndex;
		syncData.texasHoldEm.communityCards = Pool.Get<List<int>>();
		syncData.texasHoldEm.biggestRaiseThisTurn = BiggestRaiseThisTurn;
		syncData.lastActionId = (int)LastAction;
		syncData.lastActionTarget = LastActionTarget;
		syncData.lastActionValue = LastActionValue;
		foreach (PlayingCard communityCard in communityCards)
		{
			syncData.texasHoldEm.communityCards.Add(communityCard.GetIndex());
		}
		ClearLastAction();
	}

	protected override void SubStartRound()
	{
		communityCards.Clear();
		deck = new StackOfCards(1);
		BiggestRaiseThisTurn = 0;
		ClearLastAction();
		IncrementDealer();
		DealHoleCards();
		activePlayerIndex = GetFirstPlayerRelIndex(startOfRound: true);
		ServerPlaySound(CardGameSounds.SoundType.Shuffle);
		TryGetActivePlayer(out var activePlayer);
		activePlayer.availableInputs = GetAvailableInputsForPlayer(activePlayer);
		if ((activePlayer.availableInputs & 0x20) == 32)
		{
			ReceivedInputFromPlayer(activePlayer, 32, countAsAction: false, 5, playerInitiated: false);
		}
		else
		{
			ReceivedInputFromPlayer(activePlayer, 4, countAsAction: false, 5, playerInitiated: false);
		}
		TryGetActivePlayer(out activePlayer);
		activePlayer.availableInputs = GetAvailableInputsForPlayer(activePlayer);
		if ((activePlayer.availableInputs & 0x10) == 16)
		{
			ReceivedInputFromPlayer(activePlayer, 16, countAsAction: false, 10, playerInitiated: false);
		}
		else
		{
			ReceivedInputFromPlayer(activePlayer, 4, countAsAction: false, 10, playerInitiated: false);
		}
	}

	protected override void SubEndRound()
	{
		int num = 0;
		List<CardPlayerData> list = Pool.Get<List<CardPlayerData>>();
		CardPlayerData[] playerData = base.PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData.betThisRound > 0)
			{
				list.Add(cardPlayerData);
			}
			if (cardPlayerData.HasUserInCurrentRound)
			{
				num++;
			}
		}
		if (list.Count == 0)
		{
			base.Owner.GetPot().inventory.Clear();
			return;
		}
		bool flag = num > 1;
		int num2 = GetScrapInPot();
		playerData = base.PlayerData;
		foreach (CardPlayerData cardPlayerData2 in playerData)
		{
			if (cardPlayerData2.HasUserInGame)
			{
				num2 -= cardPlayerData2.betThisRound;
			}
		}
		bool flag2 = true;
		playerData = base.PlayerData;
		foreach (CardPlayerData obj in playerData)
		{
			obj.remainingToPayOut = obj.betThisRound;
		}
		while (list.Count > 1)
		{
			int num3 = int.MaxValue;
			int num4 = 0;
			playerData = base.PlayerData;
			foreach (CardPlayerData cardPlayerData3 in playerData)
			{
				if (cardPlayerData3.betThisRound > 0)
				{
					if (cardPlayerData3.betThisRound < num3)
					{
						num3 = cardPlayerData3.betThisRound;
					}
					num4++;
				}
			}
			int num5 = num3 * num4;
			foreach (CardPlayerData item in list)
			{
				item.betThisRound -= num3;
			}
			int num6 = int.MaxValue;
			foreach (CardPlayerData item2 in PlayersInRound())
			{
				if (item2.finalScore < num6)
				{
					num6 = item2.finalScore;
				}
			}
			if (flag2)
			{
				base.resultInfo.winningScore = num6;
			}
			int num7 = 0;
			foreach (CardPlayerData item3 in PlayersInRound())
			{
				if (item3.finalScore == num6)
				{
					num7++;
				}
			}
			int num8 = Mathf.CeilToInt((float)(num5 + num2) / (float)num7);
			num2 = 0;
			foreach (CardPlayerData item4 in PlayersInRound())
			{
				if (item4.finalScore == num6)
				{
					if (flag)
					{
						item4.EnableSendingCards();
					}
					PayOutFromPot(item4, num8);
					PokerRoundResult resultCode = (flag2 ? PokerRoundResult.PrimaryWinner : PokerRoundResult.SecondaryWinner);
					AddRoundResult(item4, num8, (int)resultCode);
				}
			}
			for (int num9 = list.Count - 1; num9 >= 0; num9--)
			{
				if (list[num9].betThisRound == 0)
				{
					list.RemoveAt(num9);
				}
			}
			flag2 = false;
		}
		if (list.Count == 1)
		{
			int num10 = list[0].betThisRound + num2;
			num2 = 0;
			PayOutFromPot(list[0], num10);
			PokerRoundResult resultCode2 = ((base.resultInfo.results.Count == 0) ? PokerRoundResult.PrimaryWinner : PokerRoundResult.SecondaryWinner);
			AddRoundResult(list[0], num10, (int)resultCode2);
		}
		base.Owner.ClientRPC<RoundResults>(RpcTarget.NetworkGroup("OnResultsDeclared"), base.resultInfo);
		StorageContainer pot = base.Owner.GetPot();
		int amount = pot.inventory.GetAmount(base.ScrapItemID, onlyUsableAmounts: true);
		if (amount > 0)
		{
			Debug.LogError((object)$"{GetType().Name}: Something went wrong in the winner calculation. Pot still has {amount} scrap left over after payouts. Expected 0. Clearing it.");
			pot.inventory.Clear();
		}
		Pool.FreeUnmanaged<CardPlayerData>(ref list);
	}

	protected override void AddRoundResult(CardPlayerData pData, int winnings, int winState)
	{
		base.AddRoundResult(pData, winnings, winState);
		if (GameInfo.HasAchievements)
		{
			BasePlayer basePlayer = base.Owner.IDToPlayer(pData.UserID);
			if ((Object)(object)basePlayer != (Object)null)
			{
				basePlayer.stats.Add("won_hand_texas_holdem", 1);
				basePlayer.stats.Save(forceSteamSave: true);
			}
		}
	}

	protected override void SubEndGameplay()
	{
		communityCards.Clear();
	}

	private void IncrementDealer()
	{
		int num = NumPlayersInGame();
		if (num == 0)
		{
			dealerIndex = 0;
			return;
		}
		dealerIndex = Mathf.Clamp(dealerIndex, 0, num - 1);
		dealerIndex = ++dealerIndex % num;
	}

	private void DealHoleCards()
	{
		for (int i = 0; i < 2; i++)
		{
			foreach (CardPlayerData item in PlayersInRound())
			{
				if (deck.TryTakeCard(out var card))
				{
					item.Cards.Add(card);
				}
				else
				{
					Debug.LogError((object)(GetType().Name + ": No more cards in the deck to deal!"));
				}
			}
		}
		SyncAllLocalPlayerCards();
	}

	private bool DealCommunityCards()
	{
		if (!base.HasActiveRound)
		{
			return false;
		}
		if (communityCards.Count == 0)
		{
			for (int i = 0; i < 3; i++)
			{
				if (deck.TryTakeCard(out var card))
				{
					communityCards.Add(card);
				}
			}
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			return true;
		}
		if (communityCards.Count == 3 || communityCards.Count == 4)
		{
			if (deck.TryTakeCard(out var card2))
			{
				communityCards.Add(card2);
			}
			ServerPlaySound(CardGameSounds.SoundType.Draw);
			return true;
		}
		return false;
	}

	private void ClearLastAction()
	{
		LastAction = PokerInputOption.None;
		LastActionTarget = 0uL;
		LastActionValue = 0;
	}

	protected override void OnTurnTimeout(CardPlayerData pData)
	{
		if (TryGetActivePlayer(out var activePlayer) && activePlayer == pData)
		{
			ReceivedInputFromPlayer(activePlayer, 1, countAsAction: true, 0, playerInitiated: false);
		}
	}

	protected override void SubReceivedInputFromPlayer(CardPlayerData playerData, int input, int value, bool countAsAction)
	{
		if (!Enum.IsDefined(typeof(PokerInputOption), input))
		{
			return;
		}
		if (!base.HasActiveRound)
		{
			if (input == 64)
			{
				playerData.EnableSendingCards();
				playerData.availableInputs = GetAvailableInputsForPlayer(playerData);
				base.Owner.SendNetworkUpdate();
			}
			LastActionTarget = playerData.UserID;
			LastAction = (PokerInputOption)input;
			LastActionValue = 0;
		}
		else
		{
			if (!TryGetActivePlayer(out var activePlayer) || activePlayer != playerData)
			{
				return;
			}
			bool flag = false;
			if ((playerData.availableInputs & input) != input)
			{
				return;
			}
			switch (input)
			{
			case 1:
				playerData.LeaveCurrentRound(clearBets: false, leftRoundEarly: true);
				flag = true;
				LastActionValue = 0;
				break;
			case 2:
			{
				int currentBet = GetCurrentBet();
				int num = TryAddBet(playerData, currentBet - playerData.betThisTurn);
				LastActionValue = num;
				break;
			}
			case 16:
			case 32:
			{
				int currentBet = GetCurrentBet();
				int biggestRaiseThisTurn = BiggestRaiseThisTurn;
				if (playerData.betThisTurn + value < currentBet + biggestRaiseThisTurn)
				{
					value = currentBet + biggestRaiseThisTurn - playerData.betThisTurn;
				}
				int num = TryAddBet(playerData, value);
				BiggestRaiseThisTurn = Mathf.Max(BiggestRaiseThisTurn, num - currentBet);
				LastActionValue = num;
				break;
			}
			case 4:
			{
				int currentBet = GetCurrentBet();
				int num = GoAllIn(playerData);
				BiggestRaiseThisTurn = Mathf.Max(BiggestRaiseThisTurn, num - currentBet);
				LastActionValue = num;
				break;
			}
			case 8:
				LastActionValue = 0;
				break;
			}
			if (countAsAction && input != 0)
			{
				playerData.SetHasCompletedTurn(hasActed: true);
			}
			LastActionTarget = playerData.UserID;
			LastAction = (PokerInputOption)input;
			if (flag && NumPlayersInCurrentRound() == 1)
			{
				EndRoundWithDelay();
				return;
			}
			int startIndex = activePlayerIndex;
			if (flag)
			{
				if (activePlayerIndex > NumPlayersInCurrentRound() - 1)
				{
					startIndex = 0;
				}
			}
			else
			{
				startIndex = (activePlayerIndex + 1) % NumPlayersInCurrentRound();
			}
			CardPlayerData newActivePlayer;
			if (ShouldEndCycle())
			{
				EndCycle();
			}
			else if (TryMoveToNextPlayerWithInputs(startIndex, out newActivePlayer))
			{
				StartTurnTimer(newActivePlayer, MaxTurnTime);
				base.Owner.SendNetworkUpdate();
			}
			else
			{
				EndCycle();
			}
		}
	}

	protected override void StartNextCycle()
	{
		base.StartNextCycle();
		int num = GetFirstPlayerRelIndex(startOfRound: false);
		int num2 = NumPlayersInGame();
		int num3 = 0;
		CardPlayerData result;
		while (!ToCardPlayerData(num, includeOutOfRound: true, out result) || !result.HasUserInCurrentRound)
		{
			num = ++num % num2;
			num3++;
			if (num3 > num2)
			{
				Debug.LogError((object)(GetType().Name + ": This should never happen. Ended turn with no players in game?."));
				EndRoundWithDelay();
				return;
			}
		}
		int num4 = GameToRoundIndex(num);
		if (num4 < 0 || num4 > NumPlayersInCurrentRound())
		{
			Debug.LogError((object)$"StartNextCycle NewActiveIndex is out of range: {num4}. Clamping it to between 0 and {NumPlayersInCurrentRound()}.");
			num4 = Mathf.Clamp(num4, 0, NumPlayersInCurrentRound());
		}
		int startIndex = num4;
		CardPlayerData newActivePlayer;
		if (ShouldEndCycle())
		{
			EndCycle();
		}
		else if (TryMoveToNextPlayerWithInputs(startIndex, out newActivePlayer))
		{
			StartTurnTimer(newActivePlayer, MaxTurnTime);
			UpdateAllAvailableInputs();
			base.Owner.SendNetworkUpdate();
		}
		else
		{
			EndCycle();
		}
	}

	protected override bool ShouldEndCycle()
	{
		foreach (CardPlayerData item in PlayersInRound())
		{
			if (item.GetScrapAmount() > 0 && (item.betThisTurn != GetCurrentBet() || !item.hasCompletedTurn))
			{
				return false;
			}
		}
		return true;
	}

	protected override void EndCycle()
	{
		CardPlayerData[] playerData = base.PlayerData;
		for (int i = 0; i < playerData.Length; i++)
		{
			playerData[i].SetHasCompletedTurn(hasActed: false);
		}
		BiggestRaiseThisTurn = 0;
		if (DealCommunityCards())
		{
			QueueNextCycleInvoke();
			return;
		}
		foreach (CardPlayerData item in PlayersInRound())
		{
			List<PlayingCard> list = Pool.Get<List<PlayingCard>>();
			list.AddRange(item.Cards);
			list.AddRange(communityCards);
			ushort finalScore = EvaluatePokerHand(list);
			Pool.FreeUnmanaged<PlayingCard>(ref list);
			item.finalScore = finalScore;
		}
		EndRoundWithDelay();
	}

	protected override int GetAvailableInputsForPlayer(CardPlayerData playerData)
	{
		PokerInputOption pokerInputOption = PokerInputOption.None;
		if (playerData == null || isWaitingBetweenTurns)
		{
			return (int)pokerInputOption;
		}
		if (!base.HasActiveRound)
		{
			if (!playerData.LeftRoundEarly && playerData.Cards.Count > 0 && !playerData.SendCardDetails)
			{
				pokerInputOption |= PokerInputOption.RevealHand;
			}
			return (int)pokerInputOption;
		}
		if (!TryGetActivePlayer(out var activePlayer) || playerData != activePlayer)
		{
			return (int)pokerInputOption;
		}
		int scrapAmount = playerData.GetScrapAmount();
		if (scrapAmount > 0)
		{
			int scrapInPot = GetScrapInPot();
			int currentBet = GetCurrentBet();
			bool flag = AnyoneElseCanBetMore(playerData);
			if (scrapInPot == 0 || flag || playerData.betThisTurn + scrapAmount <= currentBet)
			{
				pokerInputOption |= PokerInputOption.AllIn;
			}
			if (playerData.betThisTurn >= currentBet)
			{
				pokerInputOption |= PokerInputOption.Check;
			}
			pokerInputOption |= PokerInputOption.Fold;
			if (currentBet > playerData.betThisTurn && scrapAmount >= currentBet - playerData.betThisTurn)
			{
				pokerInputOption |= PokerInputOption.Call;
			}
			if (scrapAmount >= GetCurrentMinRaise(playerData) && (scrapInPot == 0 || flag))
			{
				pokerInputOption = ((BiggestRaiseThisTurn != 0) ? (pokerInputOption | PokerInputOption.Raise) : (pokerInputOption | PokerInputOption.Bet));
			}
		}
		return (int)pokerInputOption;
	}

	protected override void HandlePlayerLeavingTable(CardPlayerData pData)
	{
		if (TryGetActivePlayer(out var activePlayer))
		{
			if (pData == activePlayer)
			{
				ReceivedInputFromPlayer(pData, 1, countAsAction: true, 0, playerInitiated: false);
			}
			else if (pData.HasUserInCurrentRound && pData.mountIndex < activePlayer.mountIndex && activePlayerIndex > 0)
			{
				activePlayerIndex--;
			}
		}
	}

	private bool AnyoneElseCanBetMore(CardPlayerData excluding)
	{
		CardPlayerData[] playerData = base.PlayerData;
		foreach (CardPlayerData cardPlayerData in playerData)
		{
			if (cardPlayerData != excluding && cardPlayerData.GetScrapAmount() > 0)
			{
				return true;
			}
		}
		return false;
	}
}


using System;

[Flags]
public enum PokerInputOption
{
	None = 0,
	Fold = 1,
	Call = 2,
	AllIn = 4,
	Check = 8,
	Raise = 0x10,
	Bet = 0x20,
	RevealHand = 0x40
}


public enum PokerRoundResult
{
	Loss,
	PrimaryWinner,
	SecondaryWinner
}


using System;
using Ionic.Zlib;
using UnityEngine;

public class Compression
{
	public static byte[] Compress(byte[] data)
	{
		try
		{
			return GZipStream.CompressBuffer(data);
		}
		catch (Exception)
		{
			return null;
		}
	}

	public static byte[] Uncompress(byte[] data)
	{
		return GZipStream.UncompressBuffer(data);
	}

	public static int PackVector3ToInt(Vector3 vector, float minValue, float maxValue)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.InverseLerp(minValue, maxValue, vector.x), Mathf.InverseLerp(minValue, maxValue, vector.y), Mathf.InverseLerp(minValue, maxValue, vector.z));
		return 0 | ((int)(val.x * 1023f) << 20) | ((int)(val.y * 1023f) << 10) | (int)(val.z * 1023f);
	}

	public static Vector3 UnpackVector3FromInt(int packed, float minValue, float maxValue)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3((float)((packed >> 20) & 0x3FF), (float)((packed >> 10) & 0x3FF), (float)(packed & 0x3FF)) / 1023f;
		return new Vector3(Mathf.Lerp(minValue, maxValue, val.x), Mathf.Lerp(minValue, maxValue, val.y), Mathf.Lerp(minValue, maxValue, val.z));
	}
}


using System;
using UnityEngine;

public static class Controls
{
	public static float labelWidth = 100f;

	public static float FloatSlider(string strLabel, float value, float low, float high, string format = "0.00")
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strLabel, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		float num = float.Parse(GUILayout.TextField(value.ToString(format), (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.ExpandWidth(true) }));
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		float result = GUILayout.HorizontalSlider(num, low, high, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static int IntSlider(string strLabel, int value, int low, int high, string format = "0")
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strLabel, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		int num = int.Parse(GUILayout.TextField(value.ToString(format), (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.ExpandWidth(true) }));
		GUILayout.EndHorizontal();
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		int result = (int)GUILayout.HorizontalSlider((float)num, (float)low, (float)high, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static string TextArea(string strName, string value)
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strName, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		string result = GUILayout.TextArea(value, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static bool Checkbox(string strName, bool value)
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		GUILayout.Label(strName, (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.Width(labelWidth) });
		bool result = GUILayout.Toggle(value, "", Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}

	public static bool Button(string strName)
	{
		GUILayout.BeginHorizontal(Array.Empty<GUILayoutOption>());
		bool result = GUILayout.Button(strName, Array.Empty<GUILayoutOption>());
		GUILayout.EndHorizontal();
		return result;
	}
}


using System;
using System.Collections.Generic;
using Facepunch.GUI;
using UnityEngine;

internal class TabbedPanel
{
	public struct Tab
	{
		public string name;

		public Action drawFunc;
	}

	private int selectedTabID;

	private List<Tab> tabs = new List<Tab>();

	public Tab selectedTab => tabs[selectedTabID];

	public void Add(Tab tab)
	{
		tabs.Add(tab);
	}

	internal void DrawVertical(float width)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Expected O, but got Unknown
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Expected O, but got Unknown
		GUILayout.BeginVertical((GUILayoutOption[])(object)new GUILayoutOption[2]
		{
			GUILayout.Width(width),
			GUILayout.ExpandHeight(true)
		});
		for (int i = 0; i < tabs.Count; i++)
		{
			if (GUILayout.Toggle(selectedTabID == i, tabs[i].name, new GUIStyle(GUIStyle.op_Implicit("devtab")), Array.Empty<GUILayoutOption>()))
			{
				selectedTabID = i;
			}
		}
		if (GUILayout.Toggle(false, "", new GUIStyle(GUIStyle.op_Implicit("devtab")), (GUILayoutOption[])(object)new GUILayoutOption[1] { GUILayout.ExpandHeight(true) }))
		{
			selectedTabID = -1;
		}
		GUILayout.EndVertical();
	}

	internal void DrawContents()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		if (selectedTabID >= 0)
		{
			Tab tab = selectedTab;
			GUILayout.BeginVertical(new GUIStyle(GUIStyle.op_Implicit("devtabcontents")), (GUILayoutOption[])(object)new GUILayoutOption[2]
			{
				GUILayout.ExpandHeight(true),
				GUILayout.ExpandWidth(true)
			});
			if (tab.drawFunc != null)
			{
				tab.drawFunc();
			}
			GUILayout.EndVertical();
		}
	}
}


using System;

public struct Tab
{
	public string name;

	public Action drawFunc;
}


using System;
using System.Collections.Generic;
using System.IO;
using Facepunch.Unity;
using Newtonsoft.Json;
using UnityEngine;

public static class RenderInfo
{
	public struct RendererInstance
	{
		public bool IsVisible;

		public bool CastShadows;

		public bool Enabled;

		public bool RecieveShadows;

		public float Size;

		public float Distance;

		public int BoneCount;

		public int MaterialCount;

		public int VertexCount;

		public int TriangleCount;

		public int SubMeshCount;

		public int BlendShapeCount;

		public string RenderType;

		public string MeshName;

		public string ObjectName;

		public string EntityName;

		public ulong EntityId;

		public bool UpdateWhenOffscreen;

		public int ParticleCount;

		public static RendererInstance From(Renderer renderer)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Invalid comparison between Unknown and I4
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			RendererInstance result = default(RendererInstance);
			result.IsVisible = renderer.isVisible;
			result.CastShadows = (int)renderer.shadowCastingMode > 0;
			result.RecieveShadows = renderer.receiveShadows;
			result.Enabled = renderer.enabled && ((Component)renderer).gameObject.activeInHierarchy;
			Bounds bounds = renderer.bounds;
			Vector3 size = ((Bounds)(ref bounds)).size;
			result.Size = ((Vector3)(ref size)).magnitude;
			bounds = renderer.bounds;
			result.Distance = Vector3.Distance(((Bounds)(ref bounds)).center, ((Component)Camera.main).transform.position);
			result.MaterialCount = renderer.sharedMaterials.Length;
			result.RenderType = ((object)renderer).GetType().Name;
			BaseEntity baseEntity = ((Component)renderer).gameObject.ToBaseEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				result.EntityName = baseEntity.PrefabName;
				if (baseEntity.net != null)
				{
					result.EntityId = baseEntity.net.ID.Value;
				}
			}
			else
			{
				result.ObjectName = ((Component)renderer).transform.GetRecursiveName();
			}
			if (renderer is MeshRenderer)
			{
				result.BoneCount = 0;
				MeshFilter component = ((Component)renderer).GetComponent<MeshFilter>();
				if (Object.op_Implicit((Object)(object)component))
				{
					result.ReadMesh(component.sharedMesh);
				}
			}
			if (renderer is SkinnedMeshRenderer)
			{
				SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((renderer is SkinnedMeshRenderer) ? renderer : null);
				result.ReadMesh(val.sharedMesh);
				result.UpdateWhenOffscreen = val.updateWhenOffscreen;
			}
			if (renderer is ParticleSystemRenderer)
			{
				ParticleSystem component2 = ((Component)renderer).GetComponent<ParticleSystem>();
				if (Object.op_Implicit((Object)(object)component2))
				{
					result.MeshName = ((Object)component2).name;
					result.ParticleCount = component2.particleCount;
				}
			}
			return result;
		}

		public void ReadMesh(Mesh mesh)
		{
			if ((Object)(object)mesh == (Object)null)
			{
				MeshName = "<NULL>";
				return;
			}
			VertexCount = mesh.vertexCount;
			SubMeshCount = mesh.subMeshCount;
			BlendShapeCount = mesh.blendShapeCount;
			MeshName = ((Object)mesh).name;
		}
	}

	public static void GenerateReport()
	{
		Renderer[] array = Object.FindObjectsOfType<Renderer>();
		List<RendererInstance> list = new List<RendererInstance>();
		Renderer[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			RendererInstance item = RendererInstance.From(array2[i]);
			list.Add(item);
		}
		string path = string.Format(Application.dataPath + "/../RenderInfo-{0:yyyy-MM-dd_hh-mm-ss-tt}.txt", DateTime.Now);
		string contents = JsonConvert.SerializeObject((object)list, (Formatting)1);
		File.WriteAllText(path, contents);
	}
}


using UnityEngine;

public struct RendererInstance
{
	public bool IsVisible;

	public bool CastShadows;

	public bool Enabled;

	public bool RecieveShadows;

	public float Size;

	public float Distance;

	public int BoneCount;

	public int MaterialCount;

	public int VertexCount;

	public int TriangleCount;

	public int SubMeshCount;

	public int BlendShapeCount;

	public string RenderType;

	public string MeshName;

	public string ObjectName;

	public string EntityName;

	public ulong EntityId;

	public bool UpdateWhenOffscreen;

	public int ParticleCount;

	public static RendererInstance From(Renderer renderer)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Invalid comparison between Unknown and I4
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		RendererInstance result = default(RendererInstance);
		result.IsVisible = renderer.isVisible;
		result.CastShadows = (int)renderer.shadowCastingMode > 0;
		result.RecieveShadows = renderer.receiveShadows;
		result.Enabled = renderer.enabled && ((Component)renderer).gameObject.activeInHierarchy;
		Bounds bounds = renderer.bounds;
		Vector3 size = ((Bounds)(ref bounds)).size;
		result.Size = ((Vector3)(ref size)).magnitude;
		bounds = renderer.bounds;
		result.Distance = Vector3.Distance(((Bounds)(ref bounds)).center, ((Component)Camera.main).transform.position);
		result.MaterialCount = renderer.sharedMaterials.Length;
		result.RenderType = ((object)renderer).GetType().Name;
		BaseEntity baseEntity = ((Component)renderer).gameObject.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			result.EntityName = baseEntity.PrefabName;
			if (baseEntity.net != null)
			{
				result.EntityId = baseEntity.net.ID.Value;
			}
		}
		else
		{
			result.ObjectName = ((Component)renderer).transform.GetRecursiveName();
		}
		if (renderer is MeshRenderer)
		{
			result.BoneCount = 0;
			MeshFilter component = ((Component)renderer).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				result.ReadMesh(component.sharedMesh);
			}
		}
		if (renderer is SkinnedMeshRenderer)
		{
			SkinnedMeshRenderer val = (SkinnedMeshRenderer)(object)((renderer is SkinnedMeshRenderer) ? renderer : null);
			result.ReadMesh(val.sharedMesh);
			result.UpdateWhenOffscreen = val.updateWhenOffscreen;
		}
		if (renderer is ParticleSystemRenderer)
		{
			ParticleSystem component2 = ((Component)renderer).GetComponent<ParticleSystem>();
			if (Object.op_Implicit((Object)(object)component2))
			{
				result.MeshName = ((Object)component2).name;
				result.ParticleCount = component2.particleCount;
			}
		}
		return result;
	}

	public void ReadMesh(Mesh mesh)
	{
		if ((Object)(object)mesh == (Object)null)
		{
			MeshName = "<NULL>";
			return;
		}
		VertexCount = mesh.vertexCount;
		SubMeshCount = mesh.subMeshCount;
		BlendShapeCount = mesh.blendShapeCount;
		MeshName = ((Object)mesh).name;
	}
}


using System;
using System.Collections;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Cysharp.Text;
using Facepunch;
using Facepunch.Rust;
using Network;
using Rust;
using Steamworks;
using UnityEngine;

public static class Analytics
{
	public static class Azure
	{
		public enum ResourceMode
		{
			Produced,
			Consumed
		}

		private static class EventIds
		{
			public const string EntityBuilt = "entity_built";

			public const string EntityPickup = "entity_pickup";

			public const string EntityDamage = "entity_damage";

			public const string PlayerRespawn = "player_respawn";

			public const string ExplosiveLaunched = "explosive_launch";

			public const string Explosion = "explosion";

			public const string ItemEvent = "item_event";

			public const string EntitySum = "entity_sum";

			public const string ItemSum = "item_sum";

			public const string ItemDespawn = "item_despawn";

			public const string ItemDropped = "item_drop";

			public const string ItemPickup = "item_pickup";

			public const string AntihackViolation = "antihack_violation";

			public const string AntihackViolationDetailed = "antihack_violation_detailed";

			public const string PlayerConnect = "player_connect";

			public const string PlayerDisconnect = "player_disconnect";

			public const string ConsumableUsed = "consumeable_used";

			public const string MedUsed = "med_used";

			public const string ResearchStarted = "research_start";

			public const string BlueprintLearned = "blueprint_learned";

			public const string TeamChanged = "team_change";

			public const string EntityAuthChange = "auth_change";

			public const string VendingOrderChanged = "vending_changed";

			public const string VendingSale = "vending_sale";

			public const string ChatMessage = "chat";

			public const string BlockUpgrade = "block_upgrade";

			public const string BlockDemolish = "block_demolish";

			public const string ItemRepair = "item_repair";

			public const string EntityRepair = "entity_repair";

			public const string ItemSkinned = "item_skinned";

			public const string EntitySkinned = "entity_skinned";

			public const string ItemAggregate = "item_aggregate";

			public const string CodelockChanged = "code_change";

			public const string CodelockEntered = "code_enter";

			public const string SleepingBagAssign = "sleeping_bag_assign";

			public const string FallDamage = "fall_damage";

			public const string PlayerWipeIdSet = "player_wipe_id_set";

			public const string ServerInfo = "server_info";

			public const string UnderwaterCrateUntied = "crate_untied";

			public const string VehiclePurchased = "vehicle_purchase";

			public const string NPCVendor = "npc_vendor";

			public const string BlueprintsOnline = "blueprint_aggregate_online";

			public const string PlayerPositions = "player_positions";

			public const string ProjectileInvalid = "projectile_invalid";

			public const string ItemDefinitions = "item_definitions";

			public const string KeycardSwiped = "keycard_swiped";

			public const string EntitySpawned = "entity_spawned";

			public const string EntityKilled = "entity_killed";

			public const string HackableCrateStarted = "hackable_crate_started";

			public const string HackableCrateEnded = "hackable_crate_ended";

			public const string StashHidden = "stash_hidden";

			public const string StashRevealed = "stash_reveal";

			public const string EntityManifest = "entity_manifest";

			public const string LootEntity = "loot_entity";

			public const string OnlineTeams = "online_teams";

			public const string Gambling = "gambing";

			public const string BuildingBlockColor = "building_block_color";

			public const string MissionComplete = "mission_complete";

			public const string PlayerPinged = "player_pinged";

			public const string BagUnclaim = "bag_unclaim";

			public const string SteamAuth = "steam_auth";

			public const string ParachuteUsed = "parachute_used";

			public const string MountEntity = "mount";

			public const string DismountEntity = "dismount";

			public const string BurstToggle = "burst_toggle";

			public const string TutorialStarted = "tutorial_started";

			public const string TutorialCompleted = "tutorial_completed";

			public const string TutorialQuit = "tutorial_quit";

			public const string BaseInteraction = "base_interaction";

			public const string PlayerDeath = "player_death";

			public const string CarShredded = "car_shredded";

			public const string PlayerTick = "player_tick";

			public const string WallpaperPlaced = "wallpaper_placed";

			public const string StartFish = "fishing_start";

			public const string FailedFish = "fishing_failed";

			public const string CaughtFish = "fishing_caught";
		}

		private struct SimpleItemAmount
		{
			public string ItemName;

			public int Amount;

			public ulong Skin;

			public float Condition;

			public SimpleItemAmount(Item item)
			{
				ItemName = item.info.shortname;
				Amount = item.amount;
				Skin = item.skin;
				Condition = item.conditionNormalized;
			}
		}

		private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
		{
			public ulong UserId;

			public int ProjectileId;

			public FiredProjectileKey(ulong userId, int projectileId)
			{
				UserId = userId;
				ProjectileId = projectileId;
			}

			public bool Equals(FiredProjectileKey other)
			{
				if (other.UserId == UserId)
				{
					return other.ProjectileId == ProjectileId;
				}
				return false;
			}
		}

		private class PendingFiredProjectile : IPooled
		{
			public EventRecord Record;

			public BasePlayer.FiredProjectile FiredProjectile;

			public bool Hit;

			public void EnterPool()
			{
				Hit = false;
				Record = null;
				FiredProjectile = null;
			}

			public void LeavePool()
			{
			}
		}

		[JsonModel]
		private struct EntitySumItem
		{
			public uint PrefabId;

			public int Count;

			public int Grade;
		}

		private struct EntityKey : IEquatable<EntityKey>
		{
			public uint PrefabId;

			public int Grade;

			public bool Equals(EntityKey other)
			{
				if (PrefabId == other.PrefabId)
				{
					return Grade == other.Grade;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
			}
		}

		private class PendingItemsData : IPooled
		{
			public PendingItemsKey Key;

			public int amount;

			public string category;

			public void EnterPool()
			{
				Key = default(PendingItemsKey);
				amount = 0;
				category = null;
			}

			public void LeavePool()
			{
			}
		}

		private struct PendingItemsKey : IEquatable<PendingItemsKey>
		{
			public string Item;

			public bool Consumed;

			public string Entity;

			public string Category;

			public NetworkableId EntityId;

			public bool Equals(PendingItemsKey other)
			{
				//IL_0027: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
				{
					return Category == other.Category;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
			}
		}

		[JsonModel]
		private class PlayerAggregate : IPooled
		{
			public string UserId;

			public Vector3 Position;

			public Vector3 Direction;

			public List<string> Hotbar = new List<string>();

			public List<string> Worn = new List<string>();

			public string ActiveItem;

			public void EnterPool()
			{
				//IL_000d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				UserId = null;
				Position = default(Vector3);
				Direction = default(Vector3);
				Hotbar.Clear();
				Worn.Clear();
				ActiveItem = null;
			}

			public void LeavePool()
			{
			}
		}

		[JsonModel]
		private class TeamInfo : IPooled
		{
			public List<string> online = new List<string>();

			public List<string> offline = new List<string>();

			public int member_count;

			public void EnterPool()
			{
				online.Clear();
				offline.Clear();
				member_count = 0;
			}

			public void LeavePool()
			{
			}
		}

		private static Dictionary<FiredProjectileKey, PendingFiredProjectile> trackedProjectiles = new Dictionary<FiredProjectileKey, PendingFiredProjectile>();

		private static Dictionary<int, string> geneCache = new Dictionary<int, string>();

		public static int MaxMSPerFrame = 5;

		private static Dictionary<PendingItemsKey, PendingItemsData> pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();

		public static bool GameplayAnalytics => GameplayAnalyticsConVar;

		public static void Initialize()
		{
			PushItemDefinitions();
			PushEntityManifest();
			((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(AggregateLoop());
		}

		private static void PushServerInfo()
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("server_info").AddField("seed", World.Seed).AddField("size", World.Size)
					.AddField("url", World.Url)
					.AddField("wipe_id", SaveRestore.WipeId)
					.AddField("ip_convar", Net.sv.ip)
					.AddField("port_convar", Net.sv.port)
					.AddField("net_protocol", Net.sv.ProtocolId)
					.AddField("protocol_network", 2585)
					.AddField("protocol_save", 266);
				BuildInfo current = BuildInfo.Current;
				EventRecord eventRecord2 = eventRecord.AddField("changeset", ((current != null) ? current.Scm.ChangeId : null) ?? "0").AddField("unity_version", Application.unityVersion);
				BuildInfo current2 = BuildInfo.Current;
				SubmitPoint(eventRecord2.AddField("branch", ((current2 != null) ? current2.Scm.Branch : null) ?? "empty").AddField("server_tags", ConVar.Server.tags).AddField("device_id", SystemInfo.deviceUniqueIdentifier)
					.AddField("network_id", Net.sv.GetLastUIDGiven()));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void PushItemDefinitions()
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if ((Object)(object)GameManifest.Current == (Object)null)
				{
					return;
				}
				BuildInfo current = BuildInfo.Current;
				object obj;
				if (current == null)
				{
					obj = null;
				}
				else
				{
					ScmInfo scm = current.Scm;
					obj = ((scm != null) ? scm.ChangeId : null);
				}
				if (obj == null)
				{
					return;
				}
				SubmitPoint(EventRecord.New("item_definitions").AddObject("items", from x in ItemManager.itemDictionary
					select x.Value into x
					select new
					{
						item_id = x.itemid,
						shortname = x.shortname,
						craft_time = (x.Blueprint?.GetCraftTime() ?? 0f),
						workbench = (x.Blueprint?.GetWorkbenchLevel() ?? 0),
						category = x.category.ToString(),
						display_name = x.displayName.english,
						despawn_rarity = x.despawnRarity,
						ingredients = (from y in x.Blueprint?.GetIngredients()
							select new
							{
								shortname = y.itemDef.shortname,
								amount = (int)y.amount
							})
					}).AddField("changeset", BuildInfo.Current.Scm.ChangeId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void PushEntityManifest()
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if ((Object)(object)GameManifest.Current == (Object)null)
				{
					return;
				}
				BuildInfo current = BuildInfo.Current;
				object obj;
				if (current == null)
				{
					obj = null;
				}
				else
				{
					ScmInfo scm = current.Scm;
					obj = ((scm != null) ? scm.ChangeId : null);
				}
				if (obj != null)
				{
					EventRecord eventRecord = EventRecord.New("entity_manifest").AddObject("entities", GameManifest.Current.entities.Select((string x) => new
					{
						shortname = Path.GetFileNameWithoutExtension(x),
						prefab_id = StringPool.Get(x.ToLower())
					}));
					BuildInfo current2 = BuildInfo.Current;
					SubmitPoint(eventRecord.AddField("changeset", ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor"));
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void SubmitPoint(EventRecord point)
		{
			point.Submit();
		}

		public static void OnFiredProjectile(BasePlayer player, BasePlayer.FiredProjectile projectile, Guid projectileGroupId)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord record = EventRecord.New("entity_damage").AddField("start_pos", projectile.position).AddField("start_vel", projectile.initialVelocity)
					.AddField("velocity_inherit", projectile.inheritedVelocity)
					.AddField("ammo_item", projectile.itemDef?.shortname)
					.AddField("weapon", (BaseNetworkable)projectile.weaponSource)
					.AddField("projectile_group", projectileGroupId)
					.AddField("projectile_id", projectile.id)
					.AddField("attacker", (BaseNetworkable)player)
					.AddField("look_dir", player.tickViewAngles)
					.AddField("model_state", (player.modelStateTick ?? player.modelState).flags)
					.AddField("burst_mode", projectile.weaponSource?.HasFlag(BaseEntity.Flags.Reserved6) ?? false);
				PendingFiredProjectile pendingFiredProjectile = Pool.Get<PendingFiredProjectile>();
				pendingFiredProjectile.Record = record;
				pendingFiredProjectile.FiredProjectile = projectile;
				trackedProjectiles[new FiredProjectileKey(player.userID, projectile.id)] = pendingFiredProjectile;
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFiredProjectileRemoved(BasePlayer player, BasePlayer.FiredProjectile projectile)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				FiredProjectileKey key = new FiredProjectileKey(player.userID, projectile.id);
				if (!trackedProjectiles.TryGetValue(key, out var value))
				{
					return;
				}
				if (!value.Hit)
				{
					EventRecord record = value.Record;
					if (projectile.updates.Count > 0)
					{
						record.AddObject("projectile_updates", projectile.updates);
					}
					SubmitPoint(record);
				}
				Pool.Free<PendingFiredProjectile>(ref value);
				trackedProjectiles.Remove(key);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnQuarryItem(ResourceMode mode, string item, int amount, MiningQuarry sourceEntity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				AddPendingItems(sourceEntity, item, amount, "quarry", mode == ResourceMode.Consumed);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExcavatorProduceItem(Item item, BaseEntity sourceEntity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				AddPendingItems(sourceEntity, item.info.shortname, item.amount, "excavator", consumed: false);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExcavatorConsumeFuel(Item item, int amount, BaseEntity dieselEngine)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Consumed, "excavator", item.info.shortname, amount, dieselEngine, null, safezone: false, null, 0uL);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCraftItem(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Produced, "craft", item, amount, null, null, inSafezone, workbench, player?.userID ?? ((EncryptedValue<ulong>)0uL));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCraftMaterialConsumed(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone, string targetItem)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(safezone: inSafezone, workbench: workbench, targetItem: targetItem, mode: ResourceMode.Consumed, category: "craft", itemName: item, amount: amount, sourceEntity: null, tool: null, steamId: player?.userID ?? ((EncryptedValue<ulong>)0uL));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnConsumableUsed(BasePlayer player, Item item)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("consumeable_used").AddField("player", (BaseNetworkable)player).AddField("item", item));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntitySpawned(BaseEntity entity)
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				trackedSpawnedIds.Add(entity.net.ID);
				SubmitPoint(EventRecord.New("entity_spawned").AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void TryLogEntityKilled(BaseNetworkable entity)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (entity.IsValid() && trackedSpawnedIds.Contains(entity.net.ID))
				{
					SubmitPoint(EventRecord.New("entity_killed").AddField("entity", entity));
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnMedUsed(string itemName, BasePlayer player, BasePlayer target)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("med_used").AddField("player", (BaseNetworkable)player).AddField("target", (BaseNetworkable)target)
					.AddField("item_name", itemName));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCodelockChanged(BasePlayer player, CodeLock codeLock, string oldCode, string newCode, bool isGuest)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("code_change").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
					.AddField("old_code", oldCode)
					.AddField("new_code", newCode)
					.AddField("is_guest", isGuest));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCodeLockEntered(BasePlayer player, CodeLock codeLock, bool isGuest)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("code_enter").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
					.AddField("is_guest", isGuest));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTeamChanged(string change, ulong teamId, ulong teamLeader, ulong user, List<ulong> members)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			List<string> list = Pool.Get<List<string>>();
			try
			{
				if (members != null)
				{
					foreach (ulong member in members)
					{
						list.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
					}
				}
				SubmitPoint(EventRecord.New("team_change").AddField("team_leader", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(teamLeader)).AddField("team", teamId)
					.AddField("target_user", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(user))
					.AddField("change", change)
					.AddObject("users", list)
					.AddField("member_count", members.Count));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			Pool.FreeUnmanaged<string>(ref list);
		}

		public static void OnEntityAuthChanged(BaseEntity entity, BasePlayer player, IEnumerable<ulong> authedList, string change, ulong targetUser)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(targetUser);
				SubmitPoint(EventRecord.New("auth_change").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
					.AddField("target", userWipeId)
					.AddObject("auth_list", authedList.Select((ulong x) => SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(x)))
					.AddField("change", change));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSleepingBagAssigned(BasePlayer player, SleepingBag bag, ulong targetUser)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				string value = ((targetUser != 0L) ? SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(targetUser) : "");
				SubmitPoint(EventRecord.New("sleeping_bag_assign").AddField("entity", (BaseNetworkable)bag).AddField("player", (BaseNetworkable)player)
					.AddField("target", value));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFallDamage(BasePlayer player, float velocity, float damage)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fall_damage").AddField("player", (BaseNetworkable)player).AddField("velocity", velocity)
					.AddField("damage", damage));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnResearchStarted(BasePlayer player, BaseEntity entity, Item item, int scrapCost)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("research_start").AddField("player", (BaseNetworkable)player).AddField("item", item.info.shortname)
					.AddField("scrap", scrapCost)
					.AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBlueprintLearned(BasePlayer player, ItemDefinition item, string reason, int scrapCost, BaseEntity entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("blueprint_learned").AddField("player", (BaseNetworkable)player).AddField("item", item.shortname)
					.AddField("reason", reason)
					.AddField("entity", (BaseNetworkable)entity)
					.AddField("scrap_cost", scrapCost));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemRecycled(string item, int amount, Recycler recycler)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Consumed, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnRecyclerItemProduced(string item, int amount, Recycler recycler, Item sourceItem)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Produced, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy, null, sourceItem);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnGatherItem(string item, int amount, BaseEntity sourceEntity, BasePlayer player, AttackEntity weapon = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				LogResource(ResourceMode.Produced, "gather", item, amount, sourceEntity, weapon, safezone: false, null, player.userID);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFirstLooted(BaseEntity entity, BasePlayer player)
		{
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (entity is LootContainer lootContainer)
				{
					LogItemsLooted(player, entity, lootContainer.inventory);
					SubmitPoint(EventRecord.New("loot_entity").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
						.AddField("monument", GetMonument(entity))
						.AddField("biome", GetBiome(((Component)entity).transform.position)));
				}
				else if (entity is LootableCorpse { containers: var containers })
				{
					foreach (ItemContainer container in containers)
					{
						LogItemsLooted(player, entity, container);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnLootContainerDestroyed(LootContainer entity, BasePlayer player, AttackEntity weapon)
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (entity.DropsLoot && (Object)(object)player != (Object)null && Vector3.Distance(((Component)entity).transform.position, ((Component)player).transform.position) < 50f && entity.inventory?.itemList != null && entity.inventory.itemList.Count > 0)
				{
					LogItemsLooted(player, entity, entity.inventory, weapon);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityDestroyed(BaseNetworkable entity)
		{
			TryLogEntityKilled(entity);
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if (!(entity is LootContainer { FirstLooterId: 0uL } lootContainer))
				{
					return;
				}
				foreach (Item item in lootContainer.inventory.itemList)
				{
					OnItemDespawn(lootContainer, item, 3, lootContainer.LastLootedBy);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityBuilt(BaseEntity entity, BasePlayer player)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("entity_built").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity);
				if (entity is SleepingBag)
				{
					int sleepingBagCount = SleepingBag.GetSleepingBagCount(player.userID);
					eventRecord.AddField("bags_active", sleepingBagCount);
					eventRecord.AddField("max_sleeping_bags", ConVar.Server.max_sleeping_bags);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnMountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("mount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
					.AddField("seat", (BaseNetworkable)seat));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnDismountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("dismount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
					.AddField("seat", (BaseNetworkable)seat));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnKeycardSwiped(BasePlayer player, CardReader cardReader)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("keycard_swiped").AddField("player", (BaseNetworkable)player).AddField("card_level", cardReader.accessLevel)
					.AddField("entity", (BaseNetworkable)cardReader));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnLockedCrateStarted(BasePlayer player, HackableLockedCrate crate)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("hackable_crate_started").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)crate));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnLockedCrateFinished(ulong player, HackableLockedCrate crate)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(player);
				SubmitPoint(EventRecord.New("hackable_crate_ended").AddField("player_userid", userWipeId).AddField("entity", (BaseNetworkable)crate));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnStashHidden(BasePlayer player, StashContainer entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("stash_hidden").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("owner", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(entity.OwnerID)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnStashRevealed(BasePlayer player, StashContainer entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("stash_reveal").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("owner", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(entity.OwnerID)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnAntihackViolation(BasePlayer player, AntiHackType type, string message)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("antihack_violation").AddField("player", (BaseNetworkable)player).AddField("violation_type", (int)type)
					.AddField("violation", type.ToString())
					.AddField("message", message);
				if (BuildInfo.Current != null)
				{
					eventRecord.AddField("changeset", BuildInfo.Current.Scm.ChangeId).AddField("network", 2585);
				}
				switch (type)
				{
				case AntiHackType.SpeedHack:
					eventRecord.AddField("speedhack_protection", ConVar.AntiHack.speedhack_protection).AddField("speedhack_forgiveness", ConVar.AntiHack.speedhack_forgiveness).AddField("speedhack_forgiveness_inertia", ConVar.AntiHack.speedhack_forgiveness_inertia)
						.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_penalty)
						.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_reject)
						.AddField("speedhack_slopespeed", ConVar.AntiHack.speedhack_slopespeed);
					break;
				case AntiHackType.NoClip:
					eventRecord.AddField("noclip_protection", ConVar.AntiHack.noclip_protection).AddField("noclip_penalty", ConVar.AntiHack.noclip_penalty).AddField("noclip_maxsteps", ConVar.AntiHack.noclip_maxsteps)
						.AddField("noclip_margin_dismount", ConVar.AntiHack.noclip_margin_dismount)
						.AddField("noclip_margin", ConVar.AntiHack.noclip_margin)
						.AddField("noclip_backtracking", ConVar.AntiHack.noclip_backtracking)
						.AddField("noclip_reject", ConVar.AntiHack.noclip_reject)
						.AddField("noclip_stepsize", ConVar.AntiHack.noclip_stepsize);
					break;
				case AntiHackType.ProjectileHack:
					eventRecord.AddField("projectile_anglechange", ConVar.AntiHack.projectile_anglechange).AddField("projectile_backtracking", ConVar.AntiHack.projectile_backtracking).AddField("projectile_clientframes", ConVar.AntiHack.projectile_clientframes)
						.AddField("projectile_damagedepth", ConVar.AntiHack.projectile_damagedepth)
						.AddField("projectile_desync", ConVar.AntiHack.projectile_desync)
						.AddField("projectile_forgiveness", ConVar.AntiHack.projectile_forgiveness)
						.AddField("projectile_impactspawndepth", ConVar.AntiHack.projectile_impactspawndepth)
						.AddField("projectile_losforgiveness", ConVar.AntiHack.projectile_losforgiveness)
						.AddField("projectile_penalty", ConVar.AntiHack.projectile_penalty)
						.AddField("projectile_positionoffset", ConVar.AntiHack.projectile_positionoffset)
						.AddField("projectile_protection", ConVar.AntiHack.projectile_protection)
						.AddField("projectile_serverframes", ConVar.AntiHack.projectile_serverframes)
						.AddField("projectile_terraincheck", ConVar.AntiHack.projectile_terraincheck)
						.AddField("projectile_trajectory", ConVar.AntiHack.projectile_trajectory)
						.AddField("projectile_vehiclecheck", ConVar.AntiHack.projectile_vehiclecheck)
						.AddField("projectile_velocitychange", ConVar.AntiHack.projectile_velocitychange);
					break;
				case AntiHackType.InsideTerrain:
					eventRecord.AddField("terrain_check_geometry", ConVar.AntiHack.terrain_check_geometry).AddField("terrain_kill", ConVar.AntiHack.terrain_kill).AddField("terrain_padding", ConVar.AntiHack.terrain_padding)
						.AddField("terrain_penalty", ConVar.AntiHack.terrain_penalty)
						.AddField("terrain_protection", ConVar.AntiHack.terrain_protection)
						.AddField("terrain_timeslice", ConVar.AntiHack.terrain_timeslice);
					break;
				case AntiHackType.MeleeHack:
					eventRecord.AddField("melee_backtracking", ConVar.AntiHack.melee_backtracking).AddField("melee_clientframes", ConVar.AntiHack.melee_clientframes).AddField("melee_forgiveness", ConVar.AntiHack.melee_forgiveness)
						.AddField("melee_losforgiveness", ConVar.AntiHack.melee_losforgiveness)
						.AddField("melee_penalty", ConVar.AntiHack.melee_penalty)
						.AddField("melee_protection", ConVar.AntiHack.melee_protection)
						.AddField("melee_serverframes", ConVar.AntiHack.melee_serverframes)
						.AddField("melee_terraincheck", ConVar.AntiHack.melee_terraincheck)
						.AddField("melee_vehiclecheck", ConVar.AntiHack.melee_vehiclecheck);
					break;
				case AntiHackType.FlyHack:
					eventRecord.AddField("flyhack_extrusion", ConVar.AntiHack.flyhack_extrusion).AddField("flyhack_forgiveness_horizontal", ConVar.AntiHack.flyhack_forgiveness_horizontal).AddField("flyhack_forgiveness_horizontal_inertia", ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia)
						.AddField("flyhack_forgiveness_vertical", ConVar.AntiHack.flyhack_forgiveness_vertical)
						.AddField("flyhack_forgiveness_vertical_inertia", ConVar.AntiHack.flyhack_forgiveness_vertical_inertia)
						.AddField("flyhack_margin", ConVar.AntiHack.flyhack_margin)
						.AddField("flyhack_maxsteps", ConVar.AntiHack.flyhack_maxsteps)
						.AddField("flyhack_penalty", ConVar.AntiHack.flyhack_penalty)
						.AddField("flyhack_protection", ConVar.AntiHack.flyhack_protection)
						.AddField("flyhack_reject", ConVar.AntiHack.flyhack_reject);
					break;
				case AntiHackType.EyeHack:
					eventRecord.AddField("eye_clientframes", ConVar.AntiHack.eye_clientframes).AddField("eye_forgiveness", ConVar.AntiHack.eye_forgiveness).AddField("eye_history_forgiveness", ConVar.AntiHack.eye_history_forgiveness)
						.AddField("eye_history_penalty", ConVar.AntiHack.eye_history_penalty)
						.AddField("eye_losradius", ConVar.AntiHack.eye_losradius)
						.AddField("eye_noclip_backtracking", ConVar.AntiHack.eye_noclip_backtracking)
						.AddField("eye_noclip_cutoff", ConVar.AntiHack.eye_noclip_cutoff)
						.AddField("eye_penalty", ConVar.AntiHack.eye_penalty)
						.AddField("eye_protection", ConVar.AntiHack.eye_protection)
						.AddField("eye_serverframes", ConVar.AntiHack.eye_serverframes)
						.AddField("eye_terraincheck", ConVar.AntiHack.eye_terraincheck)
						.AddField("eye_vehiclecheck", ConVar.AntiHack.eye_vehiclecheck);
					break;
				case AntiHackType.AttackHack:
					eventRecord.AddField("maxdesync", ConVar.AntiHack.maxdesync);
					break;
				case AntiHackType.Ticks:
					eventRecord.AddField("max_distance", ConVar.AntiHack.tick_max_distance).AddField("max_distance_falling", ConVar.AntiHack.tick_max_distance_falling).AddField("max_distance_parented", ConVar.AntiHack.tick_max_distance_parented)
						.AddField("tick_buffer_noclip_threshold", ConVar.AntiHack.tick_buffer_noclip_threshold)
						.AddField("tick_buffer_reject_threshold", ConVar.AntiHack.tick_buffer_reject_threshold);
					break;
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEyehackViolation(BasePlayer player, Vector3 eyePos)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 6)
					.AddField("eye_pos", eyePos));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnNoclipViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount, Collider collider)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 1)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount)
					.AddField("collider_name", ((Object)collider).name));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFlyhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 3)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnProjectileHackViolation(BasePlayer.FiredProjectile projectile)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				FiredProjectileKey key = new FiredProjectileKey(projectile.attacker.userID, projectile.id);
				if (trackedProjectiles.TryGetValue(key, out var value))
				{
					value.Record.AddField("projectile_invalid", value: true).AddObject("updates", projectile.updates);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSpeedhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 2)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount)
					.AddField("distance", Vector3.Distance(startPos, endPos))
					.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTickViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 13)
					.AddField("start_pos", startPos)
					.AddField("end_pos", endPos)
					.AddField("tick_count", tickCount)
					.AddField("distance", Vector3.Distance(startPos, endPos))
					.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTerrainHackViolation(BasePlayer player)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 10)
					.AddField("seed", World.Seed)
					.AddField("size", World.Size)
					.AddField("map_url", World.Url)
					.AddField("map_checksum", World.Checksum));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityTakeDamage(HitInfo info, bool isDeath)
		{
			//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
			//IL_020a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0215: Unknown result type (might be due to invalid IL or missing references)
			//IL_0221: Unknown result type (might be due to invalid IL or missing references)
			//IL_022c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0371: Unknown result type (might be due to invalid IL or missing references)
			//IL_0376: Unknown result type (might be due to invalid IL or missing references)
			//IL_0446: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_0483: Unknown result type (might be due to invalid IL or missing references)
			//IL_049a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0607: Unknown result type (might be due to invalid IL or missing references)
			//IL_061e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0635: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				BasePlayer initiatorPlayer = info.InitiatorPlayer;
				BasePlayer basePlayer = info.HitEntity as BasePlayer;
				if (((Object)(object)info.Initiator == (Object)null && !isDeath) || (((Object)(object)initiatorPlayer == (Object)null || initiatorPlayer.IsNpc || initiatorPlayer.IsBot) && ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc || basePlayer.IsBot)))
				{
					return;
				}
				EventRecord eventRecord = null;
				float value = -1f;
				float value2 = -1f;
				if ((Object)(object)initiatorPlayer != (Object)null)
				{
					if (info.IsProjectile())
					{
						FiredProjectileKey key = new FiredProjectileKey(initiatorPlayer.userID, info.ProjectileID);
						if (trackedProjectiles.TryGetValue(key, out var value3))
						{
							eventRecord = value3.Record;
							value = Vector3.Distance(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
							value = Vector3Ex.Distance2D(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
							value3.Hit = info.DidHit;
							if (eventRecord != null && value3.FiredProjectile.updates.Count > 0)
							{
								eventRecord.AddObject("projectile_updates", value3.FiredProjectile.updates);
							}
							if (eventRecord != null && value3.FiredProjectile.simulatedPositions.Count > 0)
							{
								eventRecord.AddObject("simulated_position", value3.FiredProjectile.simulatedPositions);
							}
							if (eventRecord != null)
							{
								eventRecord.AddField("partial_time", value3.FiredProjectile.partialTime);
								eventRecord.AddField("desync_lifetime", value3.FiredProjectile.desyncLifeTime);
								eventRecord.AddField("startpoint_mismatch", value3.FiredProjectile.startPointMismatch);
								eventRecord.AddField("endpoint_mismatch", value3.FiredProjectile.endPointMismatch);
								eventRecord.AddField("entity_distance", value3.FiredProjectile.entityDistance);
								eventRecord.AddField("position_offset", value3.FiredProjectile.initialPositionOffset);
							}
							trackedProjectiles.Remove(key);
							Pool.Free<PendingFiredProjectile>(ref value3);
						}
					}
					else
					{
						value = Vector3.Distance(info.HitNormalWorld, initiatorPlayer.eyes.position);
						value2 = Vector3Ex.Distance2D(info.HitNormalWorld, initiatorPlayer.eyes.position);
					}
				}
				if (eventRecord == null)
				{
					eventRecord = EventRecord.New("entity_damage");
				}
				eventRecord.AddField("is_headshot", info.isHeadshot).AddField("victim", (BaseNetworkable)info.HitEntity).AddField("damage", info.damageTypes.Total())
					.AddField("damage_type", info.damageTypes.GetMajorityDamageType().ToString())
					.AddField("pos_world", info.HitPositionWorld)
					.AddField("pos_local", info.HitPositionLocal)
					.AddField("point_start", info.PointStart)
					.AddField("point_end", info.PointEnd)
					.AddField("normal_world", info.HitNormalWorld)
					.AddField("normal_local", info.HitNormalLocal)
					.AddField("distance_cl", info.ProjectileDistance)
					.AddField("distance", value)
					.AddField("distance_2d", value2)
					.AddField("attacker_parented", info.InitiatorParented);
				if ((Object)(object)info.HitEntity != (Object)null && (Object)(object)info.HitEntity.model != (Object)null)
				{
					eventRecord.AddField("pos_local_model", ((Component)info.HitEntity.model).transform.InverseTransformPoint(info.HitPositionWorld));
				}
				if (!info.IsProjectile())
				{
					eventRecord.AddField("weapon", (BaseNetworkable)info.Weapon);
					eventRecord.AddField("attacker", (BaseNetworkable)info.Initiator);
				}
				if (info.HitBone != 0)
				{
					eventRecord.AddField("bone", info.HitBone).AddField("bone_name", info.boneName).AddField("hit_area", (int)info.boneArea);
				}
				if (info.ProjectileID != 0)
				{
					eventRecord.AddField("projectile_id", info.ProjectileID).AddField("projectile_integrity", info.ProjectileIntegrity).AddField("projectile_hits", info.ProjectileHits)
						.AddField("trajectory_mismatch", info.ProjectileTrajectoryMismatch)
						.AddField("travel_time", info.ProjectileTravelTime)
						.AddField("projectile_velocity", info.ProjectileVelocity)
						.AddField("projectile_prefab", ((Object)info.ProjectilePrefab).name);
				}
				if ((Object)(object)initiatorPlayer != (Object)null && !info.IsProjectile())
				{
					eventRecord.AddField("attacker_eye_pos", initiatorPlayer.eyes.position);
					eventRecord.AddField("attacker_eye_dir", initiatorPlayer.eyes.BodyForward());
					if (((object)initiatorPlayer).GetType() == typeof(BasePlayer))
					{
						eventRecord.AddField("attacker_life", initiatorPlayer.respawnId);
					}
				}
				else if ((Object)(object)initiatorPlayer != (Object)null)
				{
					eventRecord.AddObject("attacker_worn", initiatorPlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
					eventRecord.AddObject("attacker_hotbar", initiatorPlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
				}
				if ((Object)(object)basePlayer != (Object)null)
				{
					eventRecord.AddField("victim_life", basePlayer.respawnId);
					eventRecord.AddObject("victim_worn", basePlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
					eventRecord.AddObject("victim_hotbar", basePlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
					eventRecord.AddField("victim_view_dir", basePlayer.tickViewAngles);
					eventRecord.AddField("victim_eye_pos", basePlayer.eyes.position);
					eventRecord.AddField("victim_eye_dir", basePlayer.eyes.BodyForward());
					eventRecord.AddField("victim_parented", info.HitEntityParented);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerRespawned(BasePlayer player, BaseEntity targetEntity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_respawn").AddField("player", (BaseNetworkable)player).AddField("bag", (BaseNetworkable)targetEntity)
					.AddField("life_id", player.respawnId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExplosiveLaunched(BasePlayer player, BaseEntity explosive, BaseEntity launcher = null)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("explosive_launch").AddField("player", (BaseNetworkable)player).AddField("explosive", (BaseNetworkable)explosive)
					.AddField("explosive_velocity", explosive.GetWorldVelocity());
				Vector3 worldVelocity = explosive.GetWorldVelocity();
				EventRecord eventRecord2 = eventRecord.AddField("explosive_direction", ((Vector3)(ref worldVelocity)).normalized);
				if ((Object)(object)launcher != (Object)null)
				{
					eventRecord2.AddField("launcher", (BaseNetworkable)launcher);
				}
				SubmitPoint(eventRecord2);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnExplosion(TimedExplosive explosive)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("explosion").AddField("entity", (BaseNetworkable)explosive));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemDespawn(BaseEntity itemContainer, Item item, int dropReason, ulong userId)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("item_despawn").AddField("entity", (BaseNetworkable)itemContainer).AddField("item", item)
					.AddField("drop_reason", dropReason);
				if (userId != 0L)
				{
					eventRecord.AddField("player_userid", userId);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemDropped(BasePlayer player, WorldItem entity, DroppedItem.DropReasonEnum dropReason)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_drop").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("item", entity.GetItem())
					.AddField("drop_reason", (int)dropReason));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemPickup(BasePlayer player, WorldItem entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("item", entity.GetItem()));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerConnected(Connection connection)
		{
			try
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
				SubmitPoint(EventRecord.New("player_connect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
					.AddField("username", connection.username)
					.AddField("ip", connection.ipaddress));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerDisconnected(Connection connection, string reason)
		{
			try
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
				SubmitPoint(EventRecord.New("player_disconnect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
					.AddField("username", connection.username)
					.AddField("reason", reason));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityPickedUp(BasePlayer player, BaseEntity entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("entity_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnChatMessage(BasePlayer player, string message, int channel)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("chat").AddField("player", (BaseNetworkable)player).AddField("message", message)
					.AddField("channel", channel));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnVendingMachineOrderChanged(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, bool added)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
				SubmitPoint(EventRecord.New("vending_changed").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
					.AddField("sell_item", itemDefinition.shortname)
					.AddField("sell_amount", sellAmount)
					.AddField("buy_item", itemDefinition2.shortname)
					.AddField("buy_amount", buyAmount)
					.AddField("is_selling_bp", sellingBp)
					.AddField("is_buying_bp", buyingBp)
					.AddField("change", added ? "added" : "removed"));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuyFromVendingMachine(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, int numberOfTransactions, float discount, BaseEntity drone = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
				ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
				SubmitPoint(EventRecord.New("vending_sale").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
					.AddField("sell_item", itemDefinition.shortname)
					.AddField("sell_amount", sellAmount)
					.AddField("buy_item", itemDefinition2.shortname)
					.AddField("buy_amount", buyAmount)
					.AddField("transactions", numberOfTransactions)
					.AddField("is_selling_bp", sellingBp)
					.AddField("is_buying_bp", buyingBp)
					.AddField("drone_terminal", (BaseNetworkable)drone)
					.AddField("discount", discount));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnNPCVendor(BasePlayer player, NPCTalking vendor, int scrapCost, string action)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("npc_vendor").AddField("player", (BaseNetworkable)player).AddField("vendor", (BaseNetworkable)vendor)
					.AddField("scrap_amount", scrapCost)
					.AddField("action", action));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static void LogItemsLooted(BasePlayer looter, BaseEntity entity, ItemContainer container, AttackEntity tool = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				if ((Object)(object)entity == (Object)null || container == null)
				{
					return;
				}
				foreach (Item item in container.itemList)
				{
					if (item != null)
					{
						string shortname = item.info.shortname;
						int amount = item.amount;
						ulong steamId = looter?.userID ?? ((EncryptedValue<ulong>)0uL);
						LogResource(ResourceMode.Produced, "loot", shortname, amount, entity, tool, safezone: false, null, steamId);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void LogResource(ResourceMode mode, string category, string itemName, int amount, BaseEntity sourceEntity = null, AttackEntity tool = null, bool safezone = false, BaseEntity workbench = null, ulong steamId = 0uL, string sourceEntityPrefab = null, Item sourceItem = null, string targetItem = null)
		{
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("item_event").AddField("item_mode", mode.ToString()).AddField("category", category)
					.AddField("item_name", itemName)
					.AddField("amount", amount);
				if ((Object)(object)sourceEntity != (Object)null)
				{
					eventRecord.AddField("entity", (BaseNetworkable)sourceEntity);
					string biome = GetBiome(((Component)sourceEntity).transform.position);
					if (biome != null)
					{
						eventRecord.AddField("biome", biome);
					}
					if (IsOcean(((Component)sourceEntity).transform.position))
					{
						eventRecord.AddField("ocean", value: true);
					}
					string monument = GetMonument(sourceEntity);
					if (monument != null)
					{
						eventRecord.AddField("monument", monument);
					}
				}
				if (sourceEntityPrefab != null)
				{
					eventRecord.AddField("entity_prefab", sourceEntityPrefab);
				}
				if ((Object)(object)tool != (Object)null)
				{
					eventRecord.AddField("tool", (BaseNetworkable)tool);
				}
				if (safezone)
				{
					eventRecord.AddField("safezone", value: true);
				}
				if ((Object)(object)workbench != (Object)null)
				{
					eventRecord.AddField("workbench", (BaseNetworkable)workbench);
				}
				if (sourceEntity is GrowableEntity plant)
				{
					eventRecord.AddField("genes", GetGenesAsString(plant));
				}
				if (sourceItem != null)
				{
					eventRecord.AddField("source_item", sourceItem.info.shortname);
				}
				if (targetItem != null)
				{
					eventRecord.AddField("target_item", targetItem);
				}
				if (steamId != 0L)
				{
					string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(steamId);
					eventRecord.AddField("player_userid", userWipeId);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSkinChanged(BasePlayer player, RepairBench repairBench, Item item, ulong workshopId)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
					.AddField("item", item)
					.AddField("new_skin", workshopId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntitySkinChanged(BasePlayer player, BaseNetworkable entity, int newSkin)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("entity_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", entity)
					.AddField("new_skin", newSkin));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnItemRepaired(BasePlayer player, BaseEntity repairBench, Item itemToRepair, float conditionBefore, float maxConditionBefore)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("item_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
					.AddField("item", itemToRepair)
					.AddField("old_condition", conditionBefore)
					.AddField("old_max_condition", maxConditionBefore)
					.AddField("max_condition", itemToRepair.maxConditionNormalized));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnEntityRepaired(BasePlayer player, BaseEntity entity, float healthBefore, float healthAfter)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("entity_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("healing", healthAfter - healthBefore)
					.AddField("health_before", healthBefore)
					.AddField("health_after", healthAfter));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuildingBlockUpgraded(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade, uint targetColor, ulong targetSkin)
		{
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("block_upgrade").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock)
					.AddField("old_grade", (int)buildingBlock.grade)
					.AddField("new_grade", (int)targetGrade)
					.AddField("color", targetColor)
					.AddField("biome", GetBiome(((Component)buildingBlock).transform.position))
					.AddField("skin_old", buildingBlock.skinID)
					.AddField("skin", targetSkin));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuildingBlockDemolished(BasePlayer player, StabilityEntity buildingBlock)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("block_demolish").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerInitializedWipeId(ulong userId, string wipeId)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_wipe_id_set").AddField("user_id", userId).AddField("player_wipe_id", wipeId));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFreeUnderwaterCrate(BasePlayer player, FreeableLootContainer freeableLootContainer)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("crate_untied").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)freeableLootContainer));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnVehiclePurchased(BasePlayer player, BaseEntity vehicle)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("vehicle_purchase").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vehicle)
					.AddField("price", (BaseNetworkable)vehicle));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnMissionComplete(BasePlayer player, BaseMission mission, BaseMission.MissionFailReason? failReason = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("mission_complete").AddField("player", (BaseNetworkable)player).AddField("mission", mission.shortname)
					.AddField("mission_succeed", value: true);
				if (failReason.HasValue)
				{
					eventRecord.AddField("mission_succeed", value: false).AddField("fail_reason", failReason.Value.ToString());
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnGamblingResult(BasePlayer player, BaseEntity entity, int scrapPaid, int scrapRecieved, Guid? gambleGroupId = null)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("gambing").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
					.AddField("scrap_input", scrapPaid)
					.AddField("scrap_output", scrapRecieved);
				if (gambleGroupId.HasValue)
				{
					eventRecord.AddField("gamble_grouping", gambleGroupId.Value);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerPinged(BasePlayer player, BasePlayer.PingType type, bool wasViaWheel)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("pingType", (int)type)
					.AddField("viaWheel", wasViaWheel));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBagUnclaimed(BasePlayer player, SleepingBag bag)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("bag_unclaim").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)bag));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnSteamAuth(ulong userId, ulong ownerUserId, string authResponse)
		{
			try
			{
				SubmitPoint(EventRecord.New("steam_auth").AddField("user", userId).AddField("owner", ownerUserId)
					.AddField("response", authResponse)
					.AddField("server_port", Net.sv.port)
					.AddField("network_mode", Net.sv.ProtocolId)
					.AddField("player_count", BasePlayer.activePlayerList.Count)
					.AddField("max_players", ConVar.Server.maxplayers)
					.AddField("hostname", ConVar.Server.hostname));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBuildingBlockColorChanged(BasePlayer player, BuildingBlock block, uint oldColor, uint newColor)
		{
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)block)
					.AddField("color_old", oldColor)
					.AddField("color_new", newColor)
					.AddField("biome", GetBiome(((Component)block).transform.position)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBurstModeToggled(BasePlayer player, BaseProjectile gun, bool state)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("burst_toggle").AddField("player", (BaseNetworkable)player).AddField("weapon", (BaseNetworkable)gun)
					.AddField("enabled", state));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnParachuteUsed(BasePlayer player, float distanceTravelled, float deployHeight, float timeInAir)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("parachute_used").AddField("player", (BaseNetworkable)player).AddField("distanceTravelled", distanceTravelled)
					.AddField("deployHeight", deployHeight)
					.AddField("timeInAir", timeInAir));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTutorialStarted(BasePlayer player)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("tutorial_started").AddField("player", (BaseNetworkable)player));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTutorialCompleted(BasePlayer player, float timeElapsed)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("tutorial_completed").AddField("player", (BaseNetworkable)player).AddLegacyTimespan("duration", TimeSpan.FromSeconds(timeElapsed)));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnTutorialQuit(BasePlayer player, string activeMissionName)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("tutorial_quit").AddField("player", (BaseNetworkable)player).AddField("activeMissionName", activeMissionName));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnBaseInteract(BasePlayer player, BaseEntity entity)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("base_interaction").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerDeath(BasePlayer player, BasePlayer killer)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("player_death").AddField("player", (BaseNetworkable)player).AddField("killer", (BaseNetworkable)killer));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCarShredded(MagnetLiftable car, List<Item> produced)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				EventRecord eventRecord = EventRecord.New("car_shredded").AddField("player", (BaseNetworkable)car.associatedPlayer).AddField("car", (BaseNetworkable)car.GetBaseEntity());
				foreach (Item item in produced)
				{
					eventRecord.AddField("item_" + item.info.shortname, item);
				}
				SubmitPoint(eventRecord);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnPlayerTick(BasePlayer player)
		{
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
			//IL_0101: Unknown result type (might be due to invalid IL or missing references)
			//IL_011b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0164: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_018e: Unknown result type (might be due to invalid IL or missing references)
			if (GameplayTickAnalyticsConVar)
			{
				if (TickLogging.tickUploader.NeedsCreation())
				{
					TickLogging.tickUploader = AzureAnalyticsUploader.Create("player_ticks", TimeSpan.FromSeconds(TickLogging.tick_uploader_lifetime), AnalyticsDocumentMode.CSV);
				}
				TickLogging.tickUploader.Append(EventRecord.New("player_tick").AddField("player_userid", player.WipeId).AddField("modelstate", (player.modelStateTick ?? player.modelState).flags)
					.AddField("heldentity", ((Object)(object)player.GetHeldEntity() != (Object)null) ? player.GetHeldEntity().ShortPrefabName : "")
					.AddField("pitch", player.tickViewAngles.x)
					.AddField("yaw", player.tickViewAngles.y)
					.AddField("pos_x", ((Component)player).transform.position.x)
					.AddField("pos_y", ((Component)player).transform.position.y)
					.AddField("pos_z", ((Component)player).transform.position.z)
					.AddField("eye_pos_x", player.eyes.position.x)
					.AddField("eye_pos_y", player.eyes.position.y)
					.AddField("eye_pos_z", player.eyes.position.z)
					.AddField("mouse_delta_x", player.tickMouseDelta.x)
					.AddField("mouse_delta_y", player.tickMouseDelta.y)
					.AddField("mouse_delta_z", player.tickMouseDelta.z)
					.AddField("parented", player.HasParent())
					.AddField("mounted", player.isMounted)
					.AddField("admin", player.IsAdmin || player.IsDeveloper)
					.AddField("Timestamp", DateTime.UtcNow));
			}
		}

		public static void OnWallpaperPlaced(BasePlayer player, BuildingBlock buildingBlock, ulong skinID, int side, bool reskin)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("wallpaper_placed").AddField("player", (BaseNetworkable)player).AddField("buildingBlock", (BaseNetworkable)buildingBlock)
					.AddField("skin", skinID)
					.AddField("side", side)
					.AddField("reskin", reskin));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnStartFish(BasePlayer player, Item lure, Vector3 targetPos)
		{
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fishing_start").AddField("player", (BaseNetworkable)player).AddField("lure", lure)
					.AddField("target_pos", targetPos));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnFailedFish(BasePlayer player, BaseFishingRod.FailReason reason)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fishing_failed").AddField("player", (BaseNetworkable)player).AddField("fail_reason", (int)reason));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		public static void OnCaughtFish(BasePlayer player, Item item)
		{
			if (!GameplayAnalytics)
			{
				return;
			}
			try
			{
				SubmitPoint(EventRecord.New("fishing_caught").AddField("player", (BaseNetworkable)player).AddField("item", item));
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}

		private static string GetGenesAsString(GrowableEntity plant)
		{
			int key = GrowableGeneEncoding.EncodeGenesToInt(plant.Genes);
			if (!geneCache.TryGetValue(key, out var value))
			{
				return string.Join("", from x in plant.Genes.Genes
					group x by x.GetDisplayCharacter() into x
					orderby x.Key
					select x.Count() + x.Key);
			}
			return value;
		}

		private static string GetMonument(BaseEntity entity)
		{
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)entity == (Object)null)
			{
				return null;
			}
			SpawnGroup spawnGroup = null;
			if (entity is BaseCorpse baseCorpse)
			{
				spawnGroup = baseCorpse.spawnGroup;
			}
			if ((Object)(object)spawnGroup == (Object)null)
			{
				SpawnPointInstance component = ((Component)entity).GetComponent<SpawnPointInstance>();
				if ((Object)(object)component != (Object)null)
				{
					spawnGroup = component.parentSpawnPointUser as SpawnGroup;
				}
			}
			if ((Object)(object)spawnGroup != (Object)null)
			{
				if (!string.IsNullOrEmpty(spawnGroup.category))
				{
					return spawnGroup.category;
				}
				if ((Object)(object)spawnGroup.Monument != (Object)null)
				{
					return ((Object)spawnGroup.Monument).name;
				}
			}
			MonumentInfo monumentInfo = TerrainMeta.Path.FindMonumentWithBoundsOverlap(((Component)entity).transform.position);
			if ((Object)(object)monumentInfo != (Object)null)
			{
				return ((Object)monumentInfo).name;
			}
			return null;
		}

		private static string GetBiome(Vector3 position)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Expected I4, but got Unknown
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Invalid comparison between Unknown and I4
			string result = null;
			Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
			switch (val - 1)
			{
			default:
				if ((int)val == 8)
				{
					result = "arctic";
				}
				break;
			case 0:
				result = "arid";
				break;
			case 1:
				result = "grass";
				break;
			case 3:
				result = "tundra";
				break;
			case 2:
				break;
			}
			return result;
		}

		private static bool IsOcean(Vector3 position)
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			return TerrainMeta.TopologyMap.GetTopology(position) == 128;
		}

		private static IEnumerator AggregateLoop()
		{
			int loop = 0;
			while (!Application.isQuitting)
			{
				yield return CoroutineEx.waitForSecondsRealtime(60f);
				if (GameplayAnalytics)
				{
					yield return TryCatch(AggregatePlayers(blueprints: false, positions: true));
					if (loop % 60 == 0)
					{
						PushServerInfo();
						yield return TryCatch(AggregateEntitiesAndItems());
						yield return TryCatch(AggregatePlayers(blueprints: true));
						yield return TryCatch(AggregateTeams());
						Dictionary<PendingItemsKey, PendingItemsData> dict = pendingItems;
						pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();
						yield return PushPendingItemsLoopAsync(dict);
					}
					loop++;
				}
			}
		}

		private static IEnumerator TryCatch(IEnumerator coroutine)
		{
			while (true)
			{
				try
				{
					if (!coroutine.MoveNext())
					{
						break;
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					break;
				}
				yield return coroutine.Current;
			}
		}

		private static IEnumerator AggregateEntitiesAndItems()
		{
			List<BaseNetworkable> entityQueue = new List<BaseNetworkable>();
			entityQueue.Clear();
			int totalCount = BaseNetworkable.serverEntities.Count;
			entityQueue.AddRange(BaseNetworkable.serverEntities);
			Dictionary<string, int> itemDict = new Dictionary<string, int>();
			Dictionary<EntityKey, int> entityDict = new Dictionary<EntityKey, int>();
			yield return null;
			Debug.Log((object)"Starting to aggregate entities & items...");
			DateTime startTime = DateTime.UtcNow;
			Stopwatch watch = Stopwatch.StartNew();
			foreach (BaseNetworkable entity in entityQueue)
			{
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
				if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
				{
					continue;
				}
				EntityKey entityKey = default(EntityKey);
				entityKey.PrefabId = entity.prefabID;
				EntityKey key = entityKey;
				if (entity is BuildingBlock buildingBlock)
				{
					key.Grade = (int)(buildingBlock.grade + 1);
				}
				entityDict.TryGetValue(key, out var value);
				entityDict[key] = value + 1;
				if (!(entity is LootContainer) && !(entity is BasePlayer { IsNpc: not false }) && !(entity is NPCPlayer))
				{
					if (entity is BasePlayer basePlayer2)
					{
						AddItemsToDict(basePlayer2.inventory.containerMain, itemDict);
						AddItemsToDict(basePlayer2.inventory.containerBelt, itemDict);
						AddItemsToDict(basePlayer2.inventory.containerWear, itemDict);
					}
					else if (entity is IItemContainerEntity itemContainerEntity)
					{
						AddItemsToDict(itemContainerEntity.inventory, itemDict);
					}
					else if (entity is DroppedItemContainer { inventory: not null } droppedItemContainer)
					{
						AddItemsToDict(droppedItemContainer.inventory, itemDict);
					}
				}
			}
			Debug.Log((object)$"Took {Math.Round(DateTime.UtcNow.Subtract(startTime).TotalSeconds, 1)}s to aggregate {totalCount} entities & items...");
			_ = DateTime.UtcNow;
			SubmitPoint(EventRecord.New("entity_sum").AddObject("counts", entityDict.Select(delegate(KeyValuePair<EntityKey, int> x)
			{
				EntitySumItem result = default(EntitySumItem);
				result.PrefabId = x.Key.PrefabId;
				result.Grade = x.Key.Grade;
				result.Count = x.Value;
				return result;
			})));
			yield return null;
			SubmitPoint(EventRecord.New("item_sum").AddObject("counts", itemDict));
			yield return null;
		}

		private static void AddItemsToDict(ItemContainer container, Dictionary<string, int> dict)
		{
			if (container == null || container.itemList == null)
			{
				return;
			}
			foreach (Item item in container.itemList)
			{
				string shortname = item.info.shortname;
				dict.TryGetValue(shortname, out var value);
				dict[shortname] = value + item.amount;
				if (item.contents != null)
				{
					AddItemsToDict(item.contents, dict);
				}
			}
		}

		private static IEnumerator PushPendingItemsLoopAsync(Dictionary<PendingItemsKey, PendingItemsData> dict)
		{
			Stopwatch watch = Stopwatch.StartNew();
			foreach (PendingItemsData value in dict.Values)
			{
				try
				{
					LogResource(value.Key.Consumed ? ResourceMode.Consumed : ResourceMode.Produced, value.category, value.Key.Item, value.amount, null, null, safezone: false, null, 0uL, value.Key.Entity);
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
				}
				PendingItemsData pendingItemsData = value;
				Pool.Free<PendingItemsData>(ref pendingItemsData);
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
			dict.Clear();
		}

		public static void AddPendingItems(BaseEntity entity, string itemName, int amount, string category, bool consumed = true, bool perEntity = false)
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			PendingItemsKey pendingItemsKey = default(PendingItemsKey);
			pendingItemsKey.Entity = entity.ShortPrefabName;
			pendingItemsKey.Category = category;
			pendingItemsKey.Item = itemName;
			pendingItemsKey.Consumed = consumed;
			pendingItemsKey.EntityId = (NetworkableId)(perEntity ? entity.net.ID : default(NetworkableId));
			PendingItemsKey key = pendingItemsKey;
			if (!pendingItems.TryGetValue(key, out var value))
			{
				value = Pool.Get<PendingItemsData>();
				value.Key = key;
				value.category = category;
				pendingItems[key] = value;
			}
			value.amount += amount;
		}

		private static IEnumerator AggregatePlayers(bool blueprints = false, bool positions = false)
		{
			Stopwatch watch = Stopwatch.StartNew();
			List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
			list.AddRange((IEnumerable<BasePlayer>)BasePlayer.activePlayerList);
			Dictionary<int, int> playerBps = (blueprints ? new Dictionary<int, int>() : null);
			List<PlayerAggregate> playerPositions = (positions ? Pool.Get<List<PlayerAggregate>>() : null);
			foreach (BasePlayer item in list)
			{
				if ((Object)(object)item == (Object)null || item.IsDestroyed)
				{
					continue;
				}
				if (blueprints)
				{
					foreach (int unlockedItem in item.PersistantPlayerInfo.unlockedItems)
					{
						playerBps.TryGetValue(unlockedItem, out var value);
						playerBps[unlockedItem] = value + 1;
					}
				}
				if (positions)
				{
					PlayerAggregate playerAggregate = Pool.Get<PlayerAggregate>();
					playerAggregate.UserId = item.WipeId;
					playerAggregate.Position = ((Component)item).transform.position;
					Quaternion bodyRotation = item.eyes.bodyRotation;
					playerAggregate.Direction = ((Quaternion)(ref bodyRotation)).eulerAngles;
					foreach (Item item2 in item.inventory.containerBelt.itemList)
					{
						playerAggregate.Hotbar.Add(item2.info.shortname);
					}
					foreach (Item item3 in item.inventory.containerWear.itemList)
					{
						playerAggregate.Worn.Add(item3.info.shortname);
					}
					playerAggregate.ActiveItem = item.GetActiveItem()?.info.shortname;
					playerPositions.Add(playerAggregate);
				}
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
			if (blueprints)
			{
				SubmitPoint(EventRecord.New("blueprint_aggregate_online").AddObject("blueprints", playerBps.Select((KeyValuePair<int, int> x) => new
				{
					Key = ItemManager.FindItemDefinition(x.Key).shortname,
					value = x.Value
				})));
			}
			if (!positions)
			{
				yield break;
			}
			SubmitPoint(EventRecord.New("player_positions").AddObject("positions", playerPositions).AddObject("player_count", playerPositions.Count));
			foreach (PlayerAggregate item4 in playerPositions)
			{
				PlayerAggregate current5 = item4;
				Pool.Free<PlayerAggregate>(ref current5);
			}
			Pool.Free<PlayerAggregate>(ref playerPositions, false);
		}

		private static IEnumerator AggregateTeams()
		{
			yield return null;
			HashSet<ulong> teamIds = new HashSet<ulong>();
			int inTeam = 0;
			int notInTeam = 0;
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if ((Object)(object)current != (Object)null && !current.IsDestroyed && current.currentTeam != 0L)
					{
						teamIds.Add(current.currentTeam);
						inTeam++;
					}
					else
					{
						notInTeam++;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			yield return null;
			Stopwatch watch = Stopwatch.StartNew();
			List<TeamInfo> teams = Pool.Get<List<TeamInfo>>();
			foreach (ulong item in teamIds)
			{
				RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(item);
				if (playerTeam == null || !((playerTeam.members != null) & (playerTeam.members.Count > 0)))
				{
					continue;
				}
				TeamInfo teamInfo = Pool.Get<TeamInfo>();
				teams.Add(teamInfo);
				foreach (ulong member in playerTeam.members)
				{
					BasePlayer basePlayer = RelationshipManager.FindByID(member);
					if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed && basePlayer.IsConnected && !basePlayer.IsSleeping())
					{
						teamInfo.online.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
					}
					else
					{
						teamInfo.offline.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
					}
				}
				teamInfo.member_count = teamInfo.online.Count + teamInfo.offline.Count;
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
			SubmitPoint(EventRecord.New("online_teams").AddObject("teams", teams).AddField("users_in_team", inTeam)
				.AddField("users_not_in_team", notInTeam));
			foreach (TeamInfo item2 in teams)
			{
				TeamInfo current4 = item2;
				Pool.Free<TeamInfo>(ref current4);
			}
			Pool.Free<TeamInfo>(ref teams, false);
		}
	}

	public class AzureWebInterface
	{
		public static readonly AzureWebInterface client = new AzureWebInterface(isClient: true);

		public static readonly AzureWebInterface server = new AzureWebInterface(isClient: false);

		private AzureAnalyticsUploader GameplayBulkUploader;

		public bool IsClient;

		public int MaxRetries = 1;

		public int FlushSize = 1000;

		public TimeSpan FlushDelay = TimeSpan.FromSeconds(30.0);

		private DateTime nextFlush;

		private ConcurrentQueue<EventRecord> uploadQueue = new ConcurrentQueue<EventRecord>();

		private HttpClient HttpClient = new HttpClient();

		private static readonly MediaTypeHeaderValue JsonContentType = new MediaTypeHeaderValue("application/json")
		{
			CharSet = Encoding.UTF8.WebName
		};

		public int PendingCount => uploadQueue.Count;

		public AzureWebInterface(bool isClient)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Expected O, but got Unknown
			IsClient = isClient;
			Task.Run((Func<Task?>)UploadSchedulingThread);
		}

		public void EnqueueEvent(EventRecord point)
		{
			if (!IsClient && !string.IsNullOrEmpty(GetContainerUrl()))
			{
				if (GameplayBulkUploader.NeedsCreation())
				{
					GameplayBulkUploader = AzureAnalyticsUploader.Create("gameplay_events", TimeSpan.FromMinutes(5.0));
					GameplayBulkUploader.UseJsonDataObject = true;
				}
				GameplayBulkUploader.Append(point);
			}
			else
			{
				point.MarkSubmitted();
				uploadQueue.Enqueue(point);
			}
		}

		private async Task UploadSchedulingThread()
		{
			while (!Application.isQuitting)
			{
				try
				{
					DateTime utcNow = DateTime.UtcNow;
					if (uploadQueue.IsEmpty || (uploadQueue.Count < FlushSize && nextFlush > utcNow))
					{
						await Task.Delay(1000);
						continue;
					}
					nextFlush = utcNow.Add(FlushDelay);
					List<EventRecord> list = Pool.Get<List<EventRecord>>();
					EventRecord result;
					while (uploadQueue.TryDequeue(out result))
					{
						list.Add(result);
					}
					Task.Run(async delegate
					{
						await UploadAsync(list);
					});
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					await Task.Delay(1000);
				}
			}
		}

		private void SerializeEvents(List<EventRecord> records, MemoryStream stream)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			Utf8ValueStringBuilder writer = ZString.CreateUtf8StringBuilder();
			try
			{
				((Utf8ValueStringBuilder)(ref writer)).Append("[");
				foreach (EventRecord record in records)
				{
					if (num > 0)
					{
						((Utf8ValueStringBuilder)(ref writer)).Append(',');
					}
					record.SerializeAsJson(ref writer);
					num++;
				}
				((Utf8ValueStringBuilder)(ref writer)).Append("]");
				((Utf8ValueStringBuilder)(ref writer)).WriteTo((Stream)stream);
			}
			finally
			{
				((Utf8ValueStringBuilder)(ref writer)).Dispose();
			}
		}

		private async Task UploadAsync(List<EventRecord> records)
		{
			if (!(IsClient ? (Application.Manifest?.Features?.ClientAnalytics == true) : (Application.Manifest?.Features?.ServerAnalytics == true)))
			{
				Pool.Free<EventRecord>(ref records, true);
				return;
			}
			if (records.Count == 0)
			{
				Pool.Free<EventRecord>(ref records, false);
				return;
			}
			MemoryStream stream = Pool.Get<MemoryStream>();
			stream.Position = 0L;
			stream.SetLength(0L);
			try
			{
				SerializeEvents(records, stream);
				AuthTicket ticket = null;
				for (int attempt = 0; attempt < MaxRetries; attempt++)
				{
					try
					{
						ByteArrayContent content = new ByteArrayContent(stream.GetBuffer(), 0, (int)stream.Length);
						try
						{
							((HttpContent)content).Headers.ContentType = JsonContentType;
							if (!string.IsNullOrEmpty(AnalyticsSecret))
							{
								((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsSecret);
							}
							else
							{
								((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsPublicKey);
							}
							if (!IsClient)
							{
								((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-IP", Net.sv.ip);
								((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-PORT", Net.sv.port.ToString());
							}
							(await HttpClient.PostAsync(IsClient ? ClientAnalyticsUrl : ServerAnalyticsUrl, (HttpContent)(object)content)).EnsureSuccessStatusCode();
						}
						finally
						{
							((IDisposable)content)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						HttpRequestException val = (HttpRequestException)(object)((ex is HttpRequestException) ? ex : null);
						if (val != null)
						{
							Debug.Log((object)("HTTP Error when uploading analytics: " + ((Exception)(object)val).Message));
						}
						else
						{
							Debug.LogException(ex);
						}
						goto IL_02ae;
					}
					break;
					IL_02ae:
					if (ticket != null)
					{
						try
						{
							ticket.Cancel();
						}
						catch (Exception ex2)
						{
							Debug.LogError((object)("Failed to cancel auth ticket in analytics: " + ex2.ToString()));
						}
					}
				}
			}
			catch (Exception ex3)
			{
				if (IsClient)
				{
					Debug.LogWarning((object)ex3.ToString());
				}
				else
				{
					Debug.LogException(ex3);
				}
			}
			finally
			{
				Pool.Free<EventRecord>(ref records, true);
				Pool.FreeUnmanaged(ref stream);
			}
		}
	}

	private static HashSet<NetworkableId> trackedSpawnedIds = new HashSet<NetworkableId>();

	public static string ClientAnalyticsUrl { get; set; } = "https://rust-api.facepunch.com/api/public/analytics/rust/client";

	[ServerVar(Name = "server_analytics_url")]
	public static string ServerAnalyticsUrl { get; set; } = "https://rust-api.facepunch.com/api/public/analytics/rust/server";

	[ServerVar(Name = "analytics_header", Saved = true, Help = "Header key of secret when uploading analytics")]
	public static string AnalyticsHeader { get; set; } = "X-API-KEY";

	[ServerVar(Name = "analytics_secret", Saved = true, Help = "Header secret value when uploading analytics")]
	public static string AnalyticsSecret { get; set; } = "";

	public static string AnalyticsPublicKey { get; set; } = "pub878ABLezSB6onshSwBCRGYDCpEI";

	[ServerVar(Name = "analytics_bulk_upload_url", Saved = true, Help = "Azure blob container url + SAS token, enables a more efficient upload method")]
	public static string BulkUploadConnectionString { get; set; }

	[ServerVar(Name = "analytics_bulk_container_url", Saved = true, Help = "Azure blob container url for use with client secret authentication")]
	public static string BulkContainerUrl { get; set; }

	[ServerVar(Name = "azure_tenant_id", Saved = true, Help = "Azure tenant id for authentication")]
	public static string AzureTenantId { get; set; }

	[ServerVar(Name = "azure_client_id", Saved = true, Help = "Azure client id for authentication")]
	public static string AzureClientId { get; set; }

	[ServerVar(Name = "azure_client_secret", Saved = true, Help = "Azure client secret for authentication")]
	public static string AzureClientSecret { get; set; }

	[ServerVar(Name = "performance_analytics", Saved = true, Help = "Toggle to turn off server performance collection")]
	public static bool ServerPerformanceConVar { get; set; } = true;

	[ServerVar(Name = "gameplay_analytics", Saved = true, Help = "Toggle whether gameplay analytics is collected")]
	public static bool GameplayAnalyticsConVar { get; set; }

	[ServerVar(Name = "gameplay_tick_analytics", Saved = true, Help = "Toggle whether gameplay tick analytics is collected")]
	public static bool GameplayTickAnalyticsConVar { get; set; }

	[ServerVar(Name = "small_buffer_send_limit", Saved = true, Help = "Size of analytics events, in bytes, that we try to send off using the same task thread. To disable, set to -1")]
	public static int SmallBufferSendLimit
	{
		get
		{
			return AzureAnalyticsUploader.SmallBufferSendLimit;
		}
		set
		{
			AzureAnalyticsUploader.SmallBufferSendLimit = value;
		}
	}

	[ServerVar(Name = "pending_analytics", Help = "Shows how many analytics events are pending upload")]
	[ClientVar(Name = "pending_analytics", Help = "Shows how many analytics events are pending upload")]
	public static void GetPendingAnalytics(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Server Pending: {AzureWebInterface.server.PendingCount}");
		arg.ReplyWith(stringBuilder.ToString());
	}

	public static string GetContainerUrl()
	{
		if (string.IsNullOrEmpty(BulkUploadConnectionString))
		{
			return BulkContainerUrl;
		}
		return BulkUploadConnectionString;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using ConVar;
using Network;
using Rust;
using UnityEngine;

public static class Azure
{
	public enum ResourceMode
	{
		Produced,
		Consumed
	}

	private static class EventIds
	{
		public const string EntityBuilt = "entity_built";

		public const string EntityPickup = "entity_pickup";

		public const string EntityDamage = "entity_damage";

		public const string PlayerRespawn = "player_respawn";

		public const string ExplosiveLaunched = "explosive_launch";

		public const string Explosion = "explosion";

		public const string ItemEvent = "item_event";

		public const string EntitySum = "entity_sum";

		public const string ItemSum = "item_sum";

		public const string ItemDespawn = "item_despawn";

		public const string ItemDropped = "item_drop";

		public const string ItemPickup = "item_pickup";

		public const string AntihackViolation = "antihack_violation";

		public const string AntihackViolationDetailed = "antihack_violation_detailed";

		public const string PlayerConnect = "player_connect";

		public const string PlayerDisconnect = "player_disconnect";

		public const string ConsumableUsed = "consumeable_used";

		public const string MedUsed = "med_used";

		public const string ResearchStarted = "research_start";

		public const string BlueprintLearned = "blueprint_learned";

		public const string TeamChanged = "team_change";

		public const string EntityAuthChange = "auth_change";

		public const string VendingOrderChanged = "vending_changed";

		public const string VendingSale = "vending_sale";

		public const string ChatMessage = "chat";

		public const string BlockUpgrade = "block_upgrade";

		public const string BlockDemolish = "block_demolish";

		public const string ItemRepair = "item_repair";

		public const string EntityRepair = "entity_repair";

		public const string ItemSkinned = "item_skinned";

		public const string EntitySkinned = "entity_skinned";

		public const string ItemAggregate = "item_aggregate";

		public const string CodelockChanged = "code_change";

		public const string CodelockEntered = "code_enter";

		public const string SleepingBagAssign = "sleeping_bag_assign";

		public const string FallDamage = "fall_damage";

		public const string PlayerWipeIdSet = "player_wipe_id_set";

		public const string ServerInfo = "server_info";

		public const string UnderwaterCrateUntied = "crate_untied";

		public const string VehiclePurchased = "vehicle_purchase";

		public const string NPCVendor = "npc_vendor";

		public const string BlueprintsOnline = "blueprint_aggregate_online";

		public const string PlayerPositions = "player_positions";

		public const string ProjectileInvalid = "projectile_invalid";

		public const string ItemDefinitions = "item_definitions";

		public const string KeycardSwiped = "keycard_swiped";

		public const string EntitySpawned = "entity_spawned";

		public const string EntityKilled = "entity_killed";

		public const string HackableCrateStarted = "hackable_crate_started";

		public const string HackableCrateEnded = "hackable_crate_ended";

		public const string StashHidden = "stash_hidden";

		public const string StashRevealed = "stash_reveal";

		public const string EntityManifest = "entity_manifest";

		public const string LootEntity = "loot_entity";

		public const string OnlineTeams = "online_teams";

		public const string Gambling = "gambing";

		public const string BuildingBlockColor = "building_block_color";

		public const string MissionComplete = "mission_complete";

		public const string PlayerPinged = "player_pinged";

		public const string BagUnclaim = "bag_unclaim";

		public const string SteamAuth = "steam_auth";

		public const string ParachuteUsed = "parachute_used";

		public const string MountEntity = "mount";

		public const string DismountEntity = "dismount";

		public const string BurstToggle = "burst_toggle";

		public const string TutorialStarted = "tutorial_started";

		public const string TutorialCompleted = "tutorial_completed";

		public const string TutorialQuit = "tutorial_quit";

		public const string BaseInteraction = "base_interaction";

		public const string PlayerDeath = "player_death";

		public const string CarShredded = "car_shredded";

		public const string PlayerTick = "player_tick";

		public const string WallpaperPlaced = "wallpaper_placed";

		public const string StartFish = "fishing_start";

		public const string FailedFish = "fishing_failed";

		public const string CaughtFish = "fishing_caught";
	}

	private struct SimpleItemAmount
	{
		public string ItemName;

		public int Amount;

		public ulong Skin;

		public float Condition;

		public SimpleItemAmount(Item item)
		{
			ItemName = item.info.shortname;
			Amount = item.amount;
			Skin = item.skin;
			Condition = item.conditionNormalized;
		}
	}

	private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
	{
		public ulong UserId;

		public int ProjectileId;

		public FiredProjectileKey(ulong userId, int projectileId)
		{
			UserId = userId;
			ProjectileId = projectileId;
		}

		public bool Equals(FiredProjectileKey other)
		{
			if (other.UserId == UserId)
			{
				return other.ProjectileId == ProjectileId;
			}
			return false;
		}
	}

	private class PendingFiredProjectile : IPooled
	{
		public EventRecord Record;

		public BasePlayer.FiredProjectile FiredProjectile;

		public bool Hit;

		public void EnterPool()
		{
			Hit = false;
			Record = null;
			FiredProjectile = null;
		}

		public void LeavePool()
		{
		}
	}

	[JsonModel]
	private struct EntitySumItem
	{
		public uint PrefabId;

		public int Count;

		public int Grade;
	}

	private struct EntityKey : IEquatable<EntityKey>
	{
		public uint PrefabId;

		public int Grade;

		public bool Equals(EntityKey other)
		{
			if (PrefabId == other.PrefabId)
			{
				return Grade == other.Grade;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
		}
	}

	private class PendingItemsData : IPooled
	{
		public PendingItemsKey Key;

		public int amount;

		public string category;

		public void EnterPool()
		{
			Key = default(PendingItemsKey);
			amount = 0;
			category = null;
		}

		public void LeavePool()
		{
		}
	}

	private struct PendingItemsKey : IEquatable<PendingItemsKey>
	{
		public string Item;

		public bool Consumed;

		public string Entity;

		public string Category;

		public NetworkableId EntityId;

		public bool Equals(PendingItemsKey other)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
			{
				return Category == other.Category;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
		}
	}

	[JsonModel]
	private class PlayerAggregate : IPooled
	{
		public string UserId;

		public Vector3 Position;

		public Vector3 Direction;

		public List<string> Hotbar = new List<string>();

		public List<string> Worn = new List<string>();

		public string ActiveItem;

		public void EnterPool()
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			UserId = null;
			Position = default(Vector3);
			Direction = default(Vector3);
			Hotbar.Clear();
			Worn.Clear();
			ActiveItem = null;
		}

		public void LeavePool()
		{
		}
	}

	[JsonModel]
	private class TeamInfo : IPooled
	{
		public List<string> online = new List<string>();

		public List<string> offline = new List<string>();

		public int member_count;

		public void EnterPool()
		{
			online.Clear();
			offline.Clear();
			member_count = 0;
		}

		public void LeavePool()
		{
		}
	}

	private static Dictionary<FiredProjectileKey, PendingFiredProjectile> trackedProjectiles = new Dictionary<FiredProjectileKey, PendingFiredProjectile>();

	private static Dictionary<int, string> geneCache = new Dictionary<int, string>();

	public static int MaxMSPerFrame = 5;

	private static Dictionary<PendingItemsKey, PendingItemsData> pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();

	public static bool GameplayAnalytics => GameplayAnalyticsConVar;

	public static void Initialize()
	{
		PushItemDefinitions();
		PushEntityManifest();
		((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(AggregateLoop());
	}

	private static void PushServerInfo()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("server_info").AddField("seed", World.Seed).AddField("size", World.Size)
				.AddField("url", World.Url)
				.AddField("wipe_id", SaveRestore.WipeId)
				.AddField("ip_convar", Net.sv.ip)
				.AddField("port_convar", Net.sv.port)
				.AddField("net_protocol", Net.sv.ProtocolId)
				.AddField("protocol_network", 2585)
				.AddField("protocol_save", 266);
			BuildInfo current = BuildInfo.Current;
			EventRecord eventRecord2 = eventRecord.AddField("changeset", ((current != null) ? current.Scm.ChangeId : null) ?? "0").AddField("unity_version", Application.unityVersion);
			BuildInfo current2 = BuildInfo.Current;
			SubmitPoint(eventRecord2.AddField("branch", ((current2 != null) ? current2.Scm.Branch : null) ?? "empty").AddField("server_tags", ConVar.Server.tags).AddField("device_id", SystemInfo.deviceUniqueIdentifier)
				.AddField("network_id", Net.sv.GetLastUIDGiven()));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void PushItemDefinitions()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)GameManifest.Current == (Object)null)
			{
				return;
			}
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj == null)
			{
				return;
			}
			SubmitPoint(EventRecord.New("item_definitions").AddObject("items", from x in ItemManager.itemDictionary
				select x.Value into x
				select new
				{
					item_id = x.itemid,
					shortname = x.shortname,
					craft_time = (x.Blueprint?.GetCraftTime() ?? 0f),
					workbench = (x.Blueprint?.GetWorkbenchLevel() ?? 0),
					category = x.category.ToString(),
					display_name = x.displayName.english,
					despawn_rarity = x.despawnRarity,
					ingredients = (from y in x.Blueprint?.GetIngredients()
						select new
						{
							shortname = y.itemDef.shortname,
							amount = (int)y.amount
						})
				}).AddField("changeset", BuildInfo.Current.Scm.ChangeId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void PushEntityManifest()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)GameManifest.Current == (Object)null)
			{
				return;
			}
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj != null)
			{
				EventRecord eventRecord = EventRecord.New("entity_manifest").AddObject("entities", GameManifest.Current.entities.Select((string x) => new
				{
					shortname = Path.GetFileNameWithoutExtension(x),
					prefab_id = StringPool.Get(x.ToLower())
				}));
				BuildInfo current2 = BuildInfo.Current;
				SubmitPoint(eventRecord.AddField("changeset", ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor"));
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void SubmitPoint(EventRecord point)
	{
		point.Submit();
	}

	public static void OnFiredProjectile(BasePlayer player, BasePlayer.FiredProjectile projectile, Guid projectileGroupId)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord record = EventRecord.New("entity_damage").AddField("start_pos", projectile.position).AddField("start_vel", projectile.initialVelocity)
				.AddField("velocity_inherit", projectile.inheritedVelocity)
				.AddField("ammo_item", projectile.itemDef?.shortname)
				.AddField("weapon", (BaseNetworkable)projectile.weaponSource)
				.AddField("projectile_group", projectileGroupId)
				.AddField("projectile_id", projectile.id)
				.AddField("attacker", (BaseNetworkable)player)
				.AddField("look_dir", player.tickViewAngles)
				.AddField("model_state", (player.modelStateTick ?? player.modelState).flags)
				.AddField("burst_mode", projectile.weaponSource?.HasFlag(BaseEntity.Flags.Reserved6) ?? false);
			PendingFiredProjectile pendingFiredProjectile = Pool.Get<PendingFiredProjectile>();
			pendingFiredProjectile.Record = record;
			pendingFiredProjectile.FiredProjectile = projectile;
			trackedProjectiles[new FiredProjectileKey(player.userID, projectile.id)] = pendingFiredProjectile;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFiredProjectileRemoved(BasePlayer player, BasePlayer.FiredProjectile projectile)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			FiredProjectileKey key = new FiredProjectileKey(player.userID, projectile.id);
			if (!trackedProjectiles.TryGetValue(key, out var value))
			{
				return;
			}
			if (!value.Hit)
			{
				EventRecord record = value.Record;
				if (projectile.updates.Count > 0)
				{
					record.AddObject("projectile_updates", projectile.updates);
				}
				SubmitPoint(record);
			}
			Pool.Free<PendingFiredProjectile>(ref value);
			trackedProjectiles.Remove(key);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnQuarryItem(ResourceMode mode, string item, int amount, MiningQuarry sourceEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			AddPendingItems(sourceEntity, item, amount, "quarry", mode == ResourceMode.Consumed);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExcavatorProduceItem(Item item, BaseEntity sourceEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			AddPendingItems(sourceEntity, item.info.shortname, item.amount, "excavator", consumed: false);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExcavatorConsumeFuel(Item item, int amount, BaseEntity dieselEngine)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Consumed, "excavator", item.info.shortname, amount, dieselEngine, null, safezone: false, null, 0uL);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCraftItem(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "craft", item, amount, null, null, inSafezone, workbench, player?.userID ?? ((EncryptedValue<ulong>)0uL));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCraftMaterialConsumed(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone, string targetItem)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(safezone: inSafezone, workbench: workbench, targetItem: targetItem, mode: ResourceMode.Consumed, category: "craft", itemName: item, amount: amount, sourceEntity: null, tool: null, steamId: player?.userID ?? ((EncryptedValue<ulong>)0uL));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnConsumableUsed(BasePlayer player, Item item)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("consumeable_used").AddField("player", (BaseNetworkable)player).AddField("item", item));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntitySpawned(BaseEntity entity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			trackedSpawnedIds.Add(entity.net.ID);
			SubmitPoint(EventRecord.New("entity_spawned").AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void TryLogEntityKilled(BaseNetworkable entity)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity.IsValid() && trackedSpawnedIds.Contains(entity.net.ID))
			{
				SubmitPoint(EventRecord.New("entity_killed").AddField("entity", entity));
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMedUsed(string itemName, BasePlayer player, BasePlayer target)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("med_used").AddField("player", (BaseNetworkable)player).AddField("target", (BaseNetworkable)target)
				.AddField("item_name", itemName));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCodelockChanged(BasePlayer player, CodeLock codeLock, string oldCode, string newCode, bool isGuest)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("code_change").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
				.AddField("old_code", oldCode)
				.AddField("new_code", newCode)
				.AddField("is_guest", isGuest));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCodeLockEntered(BasePlayer player, CodeLock codeLock, bool isGuest)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("code_enter").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
				.AddField("is_guest", isGuest));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTeamChanged(string change, ulong teamId, ulong teamLeader, ulong user, List<ulong> members)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		List<string> list = Pool.Get<List<string>>();
		try
		{
			if (members != null)
			{
				foreach (ulong member in members)
				{
					list.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
			}
			SubmitPoint(EventRecord.New("team_change").AddField("team_leader", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(teamLeader)).AddField("team", teamId)
				.AddField("target_user", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(user))
				.AddField("change", change)
				.AddObject("users", list)
				.AddField("member_count", members.Count));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	public static void OnEntityAuthChanged(BaseEntity entity, BasePlayer player, IEnumerable<ulong> authedList, string change, ulong targetUser)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(targetUser);
			SubmitPoint(EventRecord.New("auth_change").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
				.AddField("target", userWipeId)
				.AddObject("auth_list", authedList.Select((ulong x) => SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(x)))
				.AddField("change", change));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSleepingBagAssigned(BasePlayer player, SleepingBag bag, ulong targetUser)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			string value = ((targetUser != 0L) ? SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(targetUser) : "");
			SubmitPoint(EventRecord.New("sleeping_bag_assign").AddField("entity", (BaseNetworkable)bag).AddField("player", (BaseNetworkable)player)
				.AddField("target", value));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFallDamage(BasePlayer player, float velocity, float damage)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fall_damage").AddField("player", (BaseNetworkable)player).AddField("velocity", velocity)
				.AddField("damage", damage));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnResearchStarted(BasePlayer player, BaseEntity entity, Item item, int scrapCost)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("research_start").AddField("player", (BaseNetworkable)player).AddField("item", item.info.shortname)
				.AddField("scrap", scrapCost)
				.AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBlueprintLearned(BasePlayer player, ItemDefinition item, string reason, int scrapCost, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("blueprint_learned").AddField("player", (BaseNetworkable)player).AddField("item", item.shortname)
				.AddField("reason", reason)
				.AddField("entity", (BaseNetworkable)entity)
				.AddField("scrap_cost", scrapCost));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemRecycled(string item, int amount, Recycler recycler)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Consumed, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnRecyclerItemProduced(string item, int amount, Recycler recycler, Item sourceItem)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy, null, sourceItem);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnGatherItem(string item, int amount, BaseEntity sourceEntity, BasePlayer player, AttackEntity weapon = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "gather", item, amount, sourceEntity, weapon, safezone: false, null, player.userID);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFirstLooted(BaseEntity entity, BasePlayer player)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity is LootContainer lootContainer)
			{
				LogItemsLooted(player, entity, lootContainer.inventory);
				SubmitPoint(EventRecord.New("loot_entity").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
					.AddField("monument", GetMonument(entity))
					.AddField("biome", GetBiome(((Component)entity).transform.position)));
			}
			else if (entity is LootableCorpse { containers: var containers })
			{
				foreach (ItemContainer container in containers)
				{
					LogItemsLooted(player, entity, container);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLootContainerDestroyed(LootContainer entity, BasePlayer player, AttackEntity weapon)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity.DropsLoot && (Object)(object)player != (Object)null && Vector3.Distance(((Component)entity).transform.position, ((Component)player).transform.position) < 50f && entity.inventory?.itemList != null && entity.inventory.itemList.Count > 0)
			{
				LogItemsLooted(player, entity, entity.inventory, weapon);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityDestroyed(BaseNetworkable entity)
	{
		TryLogEntityKilled(entity);
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (!(entity is LootContainer { FirstLooterId: 0uL } lootContainer))
			{
				return;
			}
			foreach (Item item in lootContainer.inventory.itemList)
			{
				OnItemDespawn(lootContainer, item, 3, lootContainer.LastLootedBy);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityBuilt(BaseEntity entity, BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("entity_built").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity);
			if (entity is SleepingBag)
			{
				int sleepingBagCount = SleepingBag.GetSleepingBagCount(player.userID);
				eventRecord.AddField("bags_active", sleepingBagCount);
				eventRecord.AddField("max_sleeping_bags", ConVar.Server.max_sleeping_bags);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("mount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
				.AddField("seat", (BaseNetworkable)seat));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnDismountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("dismount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
				.AddField("seat", (BaseNetworkable)seat));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnKeycardSwiped(BasePlayer player, CardReader cardReader)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("keycard_swiped").AddField("player", (BaseNetworkable)player).AddField("card_level", cardReader.accessLevel)
				.AddField("entity", (BaseNetworkable)cardReader));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLockedCrateStarted(BasePlayer player, HackableLockedCrate crate)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("hackable_crate_started").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)crate));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLockedCrateFinished(ulong player, HackableLockedCrate crate)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(player);
			SubmitPoint(EventRecord.New("hackable_crate_ended").AddField("player_userid", userWipeId).AddField("entity", (BaseNetworkable)crate));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStashHidden(BasePlayer player, StashContainer entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("stash_hidden").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("owner", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(entity.OwnerID)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStashRevealed(BasePlayer player, StashContainer entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("stash_reveal").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("owner", SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(entity.OwnerID)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnAntihackViolation(BasePlayer player, AntiHackType type, string message)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("antihack_violation").AddField("player", (BaseNetworkable)player).AddField("violation_type", (int)type)
				.AddField("violation", type.ToString())
				.AddField("message", message);
			if (BuildInfo.Current != null)
			{
				eventRecord.AddField("changeset", BuildInfo.Current.Scm.ChangeId).AddField("network", 2585);
			}
			switch (type)
			{
			case AntiHackType.SpeedHack:
				eventRecord.AddField("speedhack_protection", ConVar.AntiHack.speedhack_protection).AddField("speedhack_forgiveness", ConVar.AntiHack.speedhack_forgiveness).AddField("speedhack_forgiveness_inertia", ConVar.AntiHack.speedhack_forgiveness_inertia)
					.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_penalty)
					.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_reject)
					.AddField("speedhack_slopespeed", ConVar.AntiHack.speedhack_slopespeed);
				break;
			case AntiHackType.NoClip:
				eventRecord.AddField("noclip_protection", ConVar.AntiHack.noclip_protection).AddField("noclip_penalty", ConVar.AntiHack.noclip_penalty).AddField("noclip_maxsteps", ConVar.AntiHack.noclip_maxsteps)
					.AddField("noclip_margin_dismount", ConVar.AntiHack.noclip_margin_dismount)
					.AddField("noclip_margin", ConVar.AntiHack.noclip_margin)
					.AddField("noclip_backtracking", ConVar.AntiHack.noclip_backtracking)
					.AddField("noclip_reject", ConVar.AntiHack.noclip_reject)
					.AddField("noclip_stepsize", ConVar.AntiHack.noclip_stepsize);
				break;
			case AntiHackType.ProjectileHack:
				eventRecord.AddField("projectile_anglechange", ConVar.AntiHack.projectile_anglechange).AddField("projectile_backtracking", ConVar.AntiHack.projectile_backtracking).AddField("projectile_clientframes", ConVar.AntiHack.projectile_clientframes)
					.AddField("projectile_damagedepth", ConVar.AntiHack.projectile_damagedepth)
					.AddField("projectile_desync", ConVar.AntiHack.projectile_desync)
					.AddField("projectile_forgiveness", ConVar.AntiHack.projectile_forgiveness)
					.AddField("projectile_impactspawndepth", ConVar.AntiHack.projectile_impactspawndepth)
					.AddField("projectile_losforgiveness", ConVar.AntiHack.projectile_losforgiveness)
					.AddField("projectile_penalty", ConVar.AntiHack.projectile_penalty)
					.AddField("projectile_positionoffset", ConVar.AntiHack.projectile_positionoffset)
					.AddField("projectile_protection", ConVar.AntiHack.projectile_protection)
					.AddField("projectile_serverframes", ConVar.AntiHack.projectile_serverframes)
					.AddField("projectile_terraincheck", ConVar.AntiHack.projectile_terraincheck)
					.AddField("projectile_trajectory", ConVar.AntiHack.projectile_trajectory)
					.AddField("projectile_vehiclecheck", ConVar.AntiHack.projectile_vehiclecheck)
					.AddField("projectile_velocitychange", ConVar.AntiHack.projectile_velocitychange);
				break;
			case AntiHackType.InsideTerrain:
				eventRecord.AddField("terrain_check_geometry", ConVar.AntiHack.terrain_check_geometry).AddField("terrain_kill", ConVar.AntiHack.terrain_kill).AddField("terrain_padding", ConVar.AntiHack.terrain_padding)
					.AddField("terrain_penalty", ConVar.AntiHack.terrain_penalty)
					.AddField("terrain_protection", ConVar.AntiHack.terrain_protection)
					.AddField("terrain_timeslice", ConVar.AntiHack.terrain_timeslice);
				break;
			case AntiHackType.MeleeHack:
				eventRecord.AddField("melee_backtracking", ConVar.AntiHack.melee_backtracking).AddField("melee_clientframes", ConVar.AntiHack.melee_clientframes).AddField("melee_forgiveness", ConVar.AntiHack.melee_forgiveness)
					.AddField("melee_losforgiveness", ConVar.AntiHack.melee_losforgiveness)
					.AddField("melee_penalty", ConVar.AntiHack.melee_penalty)
					.AddField("melee_protection", ConVar.AntiHack.melee_protection)
					.AddField("melee_serverframes", ConVar.AntiHack.melee_serverframes)
					.AddField("melee_terraincheck", ConVar.AntiHack.melee_terraincheck)
					.AddField("melee_vehiclecheck", ConVar.AntiHack.melee_vehiclecheck);
				break;
			case AntiHackType.FlyHack:
				eventRecord.AddField("flyhack_extrusion", ConVar.AntiHack.flyhack_extrusion).AddField("flyhack_forgiveness_horizontal", ConVar.AntiHack.flyhack_forgiveness_horizontal).AddField("flyhack_forgiveness_horizontal_inertia", ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia)
					.AddField("flyhack_forgiveness_vertical", ConVar.AntiHack.flyhack_forgiveness_vertical)
					.AddField("flyhack_forgiveness_vertical_inertia", ConVar.AntiHack.flyhack_forgiveness_vertical_inertia)
					.AddField("flyhack_margin", ConVar.AntiHack.flyhack_margin)
					.AddField("flyhack_maxsteps", ConVar.AntiHack.flyhack_maxsteps)
					.AddField("flyhack_penalty", ConVar.AntiHack.flyhack_penalty)
					.AddField("flyhack_protection", ConVar.AntiHack.flyhack_protection)
					.AddField("flyhack_reject", ConVar.AntiHack.flyhack_reject);
				break;
			case AntiHackType.EyeHack:
				eventRecord.AddField("eye_clientframes", ConVar.AntiHack.eye_clientframes).AddField("eye_forgiveness", ConVar.AntiHack.eye_forgiveness).AddField("eye_history_forgiveness", ConVar.AntiHack.eye_history_forgiveness)
					.AddField("eye_history_penalty", ConVar.AntiHack.eye_history_penalty)
					.AddField("eye_losradius", ConVar.AntiHack.eye_losradius)
					.AddField("eye_noclip_backtracking", ConVar.AntiHack.eye_noclip_backtracking)
					.AddField("eye_noclip_cutoff", ConVar.AntiHack.eye_noclip_cutoff)
					.AddField("eye_penalty", ConVar.AntiHack.eye_penalty)
					.AddField("eye_protection", ConVar.AntiHack.eye_protection)
					.AddField("eye_serverframes", ConVar.AntiHack.eye_serverframes)
					.AddField("eye_terraincheck", ConVar.AntiHack.eye_terraincheck)
					.AddField("eye_vehiclecheck", ConVar.AntiHack.eye_vehiclecheck);
				break;
			case AntiHackType.AttackHack:
				eventRecord.AddField("maxdesync", ConVar.AntiHack.maxdesync);
				break;
			case AntiHackType.Ticks:
				eventRecord.AddField("max_distance", ConVar.AntiHack.tick_max_distance).AddField("max_distance_falling", ConVar.AntiHack.tick_max_distance_falling).AddField("max_distance_parented", ConVar.AntiHack.tick_max_distance_parented)
					.AddField("tick_buffer_noclip_threshold", ConVar.AntiHack.tick_buffer_noclip_threshold)
					.AddField("tick_buffer_reject_threshold", ConVar.AntiHack.tick_buffer_reject_threshold);
				break;
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEyehackViolation(BasePlayer player, Vector3 eyePos)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 6)
				.AddField("eye_pos", eyePos));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnNoclipViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount, Collider collider)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 1)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("collider_name", ((Object)collider).name));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFlyhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 3)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnProjectileHackViolation(BasePlayer.FiredProjectile projectile)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			FiredProjectileKey key = new FiredProjectileKey(projectile.attacker.userID, projectile.id);
			if (trackedProjectiles.TryGetValue(key, out var value))
			{
				value.Record.AddField("projectile_invalid", value: true).AddObject("updates", projectile.updates);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSpeedhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 2)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("distance", Vector3.Distance(startPos, endPos))
				.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTickViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 13)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("distance", Vector3.Distance(startPos, endPos))
				.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTerrainHackViolation(BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 10)
				.AddField("seed", World.Seed)
				.AddField("size", World.Size)
				.AddField("map_url", World.Url)
				.AddField("map_checksum", World.Checksum));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityTakeDamage(HitInfo info, bool isDeath)
	{
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_049a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		//IL_061e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			BasePlayer basePlayer = info.HitEntity as BasePlayer;
			if (((Object)(object)info.Initiator == (Object)null && !isDeath) || (((Object)(object)initiatorPlayer == (Object)null || initiatorPlayer.IsNpc || initiatorPlayer.IsBot) && ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc || basePlayer.IsBot)))
			{
				return;
			}
			EventRecord eventRecord = null;
			float value = -1f;
			float value2 = -1f;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				if (info.IsProjectile())
				{
					FiredProjectileKey key = new FiredProjectileKey(initiatorPlayer.userID, info.ProjectileID);
					if (trackedProjectiles.TryGetValue(key, out var value3))
					{
						eventRecord = value3.Record;
						value = Vector3.Distance(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
						value = Vector3Ex.Distance2D(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
						value3.Hit = info.DidHit;
						if (eventRecord != null && value3.FiredProjectile.updates.Count > 0)
						{
							eventRecord.AddObject("projectile_updates", value3.FiredProjectile.updates);
						}
						if (eventRecord != null && value3.FiredProjectile.simulatedPositions.Count > 0)
						{
							eventRecord.AddObject("simulated_position", value3.FiredProjectile.simulatedPositions);
						}
						if (eventRecord != null)
						{
							eventRecord.AddField("partial_time", value3.FiredProjectile.partialTime);
							eventRecord.AddField("desync_lifetime", value3.FiredProjectile.desyncLifeTime);
							eventRecord.AddField("startpoint_mismatch", value3.FiredProjectile.startPointMismatch);
							eventRecord.AddField("endpoint_mismatch", value3.FiredProjectile.endPointMismatch);
							eventRecord.AddField("entity_distance", value3.FiredProjectile.entityDistance);
							eventRecord.AddField("position_offset", value3.FiredProjectile.initialPositionOffset);
						}
						trackedProjectiles.Remove(key);
						Pool.Free<PendingFiredProjectile>(ref value3);
					}
				}
				else
				{
					value = Vector3.Distance(info.HitNormalWorld, initiatorPlayer.eyes.position);
					value2 = Vector3Ex.Distance2D(info.HitNormalWorld, initiatorPlayer.eyes.position);
				}
			}
			if (eventRecord == null)
			{
				eventRecord = EventRecord.New("entity_damage");
			}
			eventRecord.AddField("is_headshot", info.isHeadshot).AddField("victim", (BaseNetworkable)info.HitEntity).AddField("damage", info.damageTypes.Total())
				.AddField("damage_type", info.damageTypes.GetMajorityDamageType().ToString())
				.AddField("pos_world", info.HitPositionWorld)
				.AddField("pos_local", info.HitPositionLocal)
				.AddField("point_start", info.PointStart)
				.AddField("point_end", info.PointEnd)
				.AddField("normal_world", info.HitNormalWorld)
				.AddField("normal_local", info.HitNormalLocal)
				.AddField("distance_cl", info.ProjectileDistance)
				.AddField("distance", value)
				.AddField("distance_2d", value2)
				.AddField("attacker_parented", info.InitiatorParented);
			if ((Object)(object)info.HitEntity != (Object)null && (Object)(object)info.HitEntity.model != (Object)null)
			{
				eventRecord.AddField("pos_local_model", ((Component)info.HitEntity.model).transform.InverseTransformPoint(info.HitPositionWorld));
			}
			if (!info.IsProjectile())
			{
				eventRecord.AddField("weapon", (BaseNetworkable)info.Weapon);
				eventRecord.AddField("attacker", (BaseNetworkable)info.Initiator);
			}
			if (info.HitBone != 0)
			{
				eventRecord.AddField("bone", info.HitBone).AddField("bone_name", info.boneName).AddField("hit_area", (int)info.boneArea);
			}
			if (info.ProjectileID != 0)
			{
				eventRecord.AddField("projectile_id", info.ProjectileID).AddField("projectile_integrity", info.ProjectileIntegrity).AddField("projectile_hits", info.ProjectileHits)
					.AddField("trajectory_mismatch", info.ProjectileTrajectoryMismatch)
					.AddField("travel_time", info.ProjectileTravelTime)
					.AddField("projectile_velocity", info.ProjectileVelocity)
					.AddField("projectile_prefab", ((Object)info.ProjectilePrefab).name);
			}
			if ((Object)(object)initiatorPlayer != (Object)null && !info.IsProjectile())
			{
				eventRecord.AddField("attacker_eye_pos", initiatorPlayer.eyes.position);
				eventRecord.AddField("attacker_eye_dir", initiatorPlayer.eyes.BodyForward());
				if (((object)initiatorPlayer).GetType() == typeof(BasePlayer))
				{
					eventRecord.AddField("attacker_life", initiatorPlayer.respawnId);
				}
			}
			else if ((Object)(object)initiatorPlayer != (Object)null)
			{
				eventRecord.AddObject("attacker_worn", initiatorPlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddObject("attacker_hotbar", initiatorPlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
			}
			if ((Object)(object)basePlayer != (Object)null)
			{
				eventRecord.AddField("victim_life", basePlayer.respawnId);
				eventRecord.AddObject("victim_worn", basePlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddObject("victim_hotbar", basePlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddField("victim_view_dir", basePlayer.tickViewAngles);
				eventRecord.AddField("victim_eye_pos", basePlayer.eyes.position);
				eventRecord.AddField("victim_eye_dir", basePlayer.eyes.BodyForward());
				eventRecord.AddField("victim_parented", info.HitEntityParented);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerRespawned(BasePlayer player, BaseEntity targetEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_respawn").AddField("player", (BaseNetworkable)player).AddField("bag", (BaseNetworkable)targetEntity)
				.AddField("life_id", player.respawnId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExplosiveLaunched(BasePlayer player, BaseEntity explosive, BaseEntity launcher = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("explosive_launch").AddField("player", (BaseNetworkable)player).AddField("explosive", (BaseNetworkable)explosive)
				.AddField("explosive_velocity", explosive.GetWorldVelocity());
			Vector3 worldVelocity = explosive.GetWorldVelocity();
			EventRecord eventRecord2 = eventRecord.AddField("explosive_direction", ((Vector3)(ref worldVelocity)).normalized);
			if ((Object)(object)launcher != (Object)null)
			{
				eventRecord2.AddField("launcher", (BaseNetworkable)launcher);
			}
			SubmitPoint(eventRecord2);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExplosion(TimedExplosive explosive)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("explosion").AddField("entity", (BaseNetworkable)explosive));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemDespawn(BaseEntity itemContainer, Item item, int dropReason, ulong userId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("item_despawn").AddField("entity", (BaseNetworkable)itemContainer).AddField("item", item)
				.AddField("drop_reason", dropReason);
			if (userId != 0L)
			{
				eventRecord.AddField("player_userid", userId);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemDropped(BasePlayer player, WorldItem entity, DroppedItem.DropReasonEnum dropReason)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_drop").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("item", entity.GetItem())
				.AddField("drop_reason", (int)dropReason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemPickup(BasePlayer player, WorldItem entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("item", entity.GetItem()));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerConnected(Connection connection)
	{
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
			SubmitPoint(EventRecord.New("player_connect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
				.AddField("username", connection.username)
				.AddField("ip", connection.ipaddress));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerDisconnected(Connection connection, string reason)
	{
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
			SubmitPoint(EventRecord.New("player_disconnect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
				.AddField("username", connection.username)
				.AddField("reason", reason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityPickedUp(BasePlayer player, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnChatMessage(BasePlayer player, string message, int channel)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("chat").AddField("player", (BaseNetworkable)player).AddField("message", message)
				.AddField("channel", channel));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnVendingMachineOrderChanged(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, bool added)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
			SubmitPoint(EventRecord.New("vending_changed").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
				.AddField("sell_item", itemDefinition.shortname)
				.AddField("sell_amount", sellAmount)
				.AddField("buy_item", itemDefinition2.shortname)
				.AddField("buy_amount", buyAmount)
				.AddField("is_selling_bp", sellingBp)
				.AddField("is_buying_bp", buyingBp)
				.AddField("change", added ? "added" : "removed"));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuyFromVendingMachine(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, int numberOfTransactions, float discount, BaseEntity drone = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
			SubmitPoint(EventRecord.New("vending_sale").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
				.AddField("sell_item", itemDefinition.shortname)
				.AddField("sell_amount", sellAmount)
				.AddField("buy_item", itemDefinition2.shortname)
				.AddField("buy_amount", buyAmount)
				.AddField("transactions", numberOfTransactions)
				.AddField("is_selling_bp", sellingBp)
				.AddField("is_buying_bp", buyingBp)
				.AddField("drone_terminal", (BaseNetworkable)drone)
				.AddField("discount", discount));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnNPCVendor(BasePlayer player, NPCTalking vendor, int scrapCost, string action)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("npc_vendor").AddField("player", (BaseNetworkable)player).AddField("vendor", (BaseNetworkable)vendor)
				.AddField("scrap_amount", scrapCost)
				.AddField("action", action));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void LogItemsLooted(BasePlayer looter, BaseEntity entity, ItemContainer container, AttackEntity tool = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)entity == (Object)null || container == null)
			{
				return;
			}
			foreach (Item item in container.itemList)
			{
				if (item != null)
				{
					string shortname = item.info.shortname;
					int amount = item.amount;
					ulong steamId = looter?.userID ?? ((EncryptedValue<ulong>)0uL);
					LogResource(ResourceMode.Produced, "loot", shortname, amount, entity, tool, safezone: false, null, steamId);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void LogResource(ResourceMode mode, string category, string itemName, int amount, BaseEntity sourceEntity = null, AttackEntity tool = null, bool safezone = false, BaseEntity workbench = null, ulong steamId = 0uL, string sourceEntityPrefab = null, Item sourceItem = null, string targetItem = null)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("item_event").AddField("item_mode", mode.ToString()).AddField("category", category)
				.AddField("item_name", itemName)
				.AddField("amount", amount);
			if ((Object)(object)sourceEntity != (Object)null)
			{
				eventRecord.AddField("entity", (BaseNetworkable)sourceEntity);
				string biome = GetBiome(((Component)sourceEntity).transform.position);
				if (biome != null)
				{
					eventRecord.AddField("biome", biome);
				}
				if (IsOcean(((Component)sourceEntity).transform.position))
				{
					eventRecord.AddField("ocean", value: true);
				}
				string monument = GetMonument(sourceEntity);
				if (monument != null)
				{
					eventRecord.AddField("monument", monument);
				}
			}
			if (sourceEntityPrefab != null)
			{
				eventRecord.AddField("entity_prefab", sourceEntityPrefab);
			}
			if ((Object)(object)tool != (Object)null)
			{
				eventRecord.AddField("tool", (BaseNetworkable)tool);
			}
			if (safezone)
			{
				eventRecord.AddField("safezone", value: true);
			}
			if ((Object)(object)workbench != (Object)null)
			{
				eventRecord.AddField("workbench", (BaseNetworkable)workbench);
			}
			if (sourceEntity is GrowableEntity plant)
			{
				eventRecord.AddField("genes", GetGenesAsString(plant));
			}
			if (sourceItem != null)
			{
				eventRecord.AddField("source_item", sourceItem.info.shortname);
			}
			if (targetItem != null)
			{
				eventRecord.AddField("target_item", targetItem);
			}
			if (steamId != 0L)
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(steamId);
				eventRecord.AddField("player_userid", userWipeId);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSkinChanged(BasePlayer player, RepairBench repairBench, Item item, ulong workshopId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
				.AddField("item", item)
				.AddField("new_skin", workshopId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntitySkinChanged(BasePlayer player, BaseNetworkable entity, int newSkin)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", entity)
				.AddField("new_skin", newSkin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemRepaired(BasePlayer player, BaseEntity repairBench, Item itemToRepair, float conditionBefore, float maxConditionBefore)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
				.AddField("item", itemToRepair)
				.AddField("old_condition", conditionBefore)
				.AddField("old_max_condition", maxConditionBefore)
				.AddField("max_condition", itemToRepair.maxConditionNormalized));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityRepaired(BasePlayer player, BaseEntity entity, float healthBefore, float healthAfter)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("healing", healthAfter - healthBefore)
				.AddField("health_before", healthBefore)
				.AddField("health_after", healthAfter));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockUpgraded(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade, uint targetColor, ulong targetSkin)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("block_upgrade").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock)
				.AddField("old_grade", (int)buildingBlock.grade)
				.AddField("new_grade", (int)targetGrade)
				.AddField("color", targetColor)
				.AddField("biome", GetBiome(((Component)buildingBlock).transform.position))
				.AddField("skin_old", buildingBlock.skinID)
				.AddField("skin", targetSkin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockDemolished(BasePlayer player, StabilityEntity buildingBlock)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("block_demolish").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerInitializedWipeId(ulong userId, string wipeId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_wipe_id_set").AddField("user_id", userId).AddField("player_wipe_id", wipeId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFreeUnderwaterCrate(BasePlayer player, FreeableLootContainer freeableLootContainer)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("crate_untied").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)freeableLootContainer));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnVehiclePurchased(BasePlayer player, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("vehicle_purchase").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vehicle)
				.AddField("price", (BaseNetworkable)vehicle));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMissionComplete(BasePlayer player, BaseMission mission, BaseMission.MissionFailReason? failReason = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("mission_complete").AddField("player", (BaseNetworkable)player).AddField("mission", mission.shortname)
				.AddField("mission_succeed", value: true);
			if (failReason.HasValue)
			{
				eventRecord.AddField("mission_succeed", value: false).AddField("fail_reason", failReason.Value.ToString());
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnGamblingResult(BasePlayer player, BaseEntity entity, int scrapPaid, int scrapRecieved, Guid? gambleGroupId = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("gambing").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("scrap_input", scrapPaid)
				.AddField("scrap_output", scrapRecieved);
			if (gambleGroupId.HasValue)
			{
				eventRecord.AddField("gamble_grouping", gambleGroupId.Value);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerPinged(BasePlayer player, BasePlayer.PingType type, bool wasViaWheel)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("pingType", (int)type)
				.AddField("viaWheel", wasViaWheel));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBagUnclaimed(BasePlayer player, SleepingBag bag)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("bag_unclaim").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)bag));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSteamAuth(ulong userId, ulong ownerUserId, string authResponse)
	{
		try
		{
			SubmitPoint(EventRecord.New("steam_auth").AddField("user", userId).AddField("owner", ownerUserId)
				.AddField("response", authResponse)
				.AddField("server_port", Net.sv.port)
				.AddField("network_mode", Net.sv.ProtocolId)
				.AddField("player_count", BasePlayer.activePlayerList.Count)
				.AddField("max_players", ConVar.Server.maxplayers)
				.AddField("hostname", ConVar.Server.hostname));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockColorChanged(BasePlayer player, BuildingBlock block, uint oldColor, uint newColor)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)block)
				.AddField("color_old", oldColor)
				.AddField("color_new", newColor)
				.AddField("biome", GetBiome(((Component)block).transform.position)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBurstModeToggled(BasePlayer player, BaseProjectile gun, bool state)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("burst_toggle").AddField("player", (BaseNetworkable)player).AddField("weapon", (BaseNetworkable)gun)
				.AddField("enabled", state));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnParachuteUsed(BasePlayer player, float distanceTravelled, float deployHeight, float timeInAir)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("parachute_used").AddField("player", (BaseNetworkable)player).AddField("distanceTravelled", distanceTravelled)
				.AddField("deployHeight", deployHeight)
				.AddField("timeInAir", timeInAir));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialStarted(BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_started").AddField("player", (BaseNetworkable)player));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialCompleted(BasePlayer player, float timeElapsed)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_completed").AddField("player", (BaseNetworkable)player).AddLegacyTimespan("duration", TimeSpan.FromSeconds(timeElapsed)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialQuit(BasePlayer player, string activeMissionName)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_quit").AddField("player", (BaseNetworkable)player).AddField("activeMissionName", activeMissionName));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBaseInteract(BasePlayer player, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("base_interaction").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerDeath(BasePlayer player, BasePlayer killer)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_death").AddField("player", (BaseNetworkable)player).AddField("killer", (BaseNetworkable)killer));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCarShredded(MagnetLiftable car, List<Item> produced)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("car_shredded").AddField("player", (BaseNetworkable)car.associatedPlayer).AddField("car", (BaseNetworkable)car.GetBaseEntity());
			foreach (Item item in produced)
			{
				eventRecord.AddField("item_" + item.info.shortname, item);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerTick(BasePlayer player)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		if (GameplayTickAnalyticsConVar)
		{
			if (TickLogging.tickUploader.NeedsCreation())
			{
				TickLogging.tickUploader = AzureAnalyticsUploader.Create("player_ticks", TimeSpan.FromSeconds(TickLogging.tick_uploader_lifetime), AnalyticsDocumentMode.CSV);
			}
			TickLogging.tickUploader.Append(EventRecord.New("player_tick").AddField("player_userid", player.WipeId).AddField("modelstate", (player.modelStateTick ?? player.modelState).flags)
				.AddField("heldentity", ((Object)(object)player.GetHeldEntity() != (Object)null) ? player.GetHeldEntity().ShortPrefabName : "")
				.AddField("pitch", player.tickViewAngles.x)
				.AddField("yaw", player.tickViewAngles.y)
				.AddField("pos_x", ((Component)player).transform.position.x)
				.AddField("pos_y", ((Component)player).transform.position.y)
				.AddField("pos_z", ((Component)player).transform.position.z)
				.AddField("eye_pos_x", player.eyes.position.x)
				.AddField("eye_pos_y", player.eyes.position.y)
				.AddField("eye_pos_z", player.eyes.position.z)
				.AddField("mouse_delta_x", player.tickMouseDelta.x)
				.AddField("mouse_delta_y", player.tickMouseDelta.y)
				.AddField("mouse_delta_z", player.tickMouseDelta.z)
				.AddField("parented", player.HasParent())
				.AddField("mounted", player.isMounted)
				.AddField("admin", player.IsAdmin || player.IsDeveloper)
				.AddField("Timestamp", DateTime.UtcNow));
		}
	}

	public static void OnWallpaperPlaced(BasePlayer player, BuildingBlock buildingBlock, ulong skinID, int side, bool reskin)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("wallpaper_placed").AddField("player", (BaseNetworkable)player).AddField("buildingBlock", (BaseNetworkable)buildingBlock)
				.AddField("skin", skinID)
				.AddField("side", side)
				.AddField("reskin", reskin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStartFish(BasePlayer player, Item lure, Vector3 targetPos)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_start").AddField("player", (BaseNetworkable)player).AddField("lure", lure)
				.AddField("target_pos", targetPos));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFailedFish(BasePlayer player, BaseFishingRod.FailReason reason)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_failed").AddField("player", (BaseNetworkable)player).AddField("fail_reason", (int)reason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCaughtFish(BasePlayer player, Item item)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_caught").AddField("player", (BaseNetworkable)player).AddField("item", item));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static string GetGenesAsString(GrowableEntity plant)
	{
		int key = GrowableGeneEncoding.EncodeGenesToInt(plant.Genes);
		if (!geneCache.TryGetValue(key, out var value))
		{
			return string.Join("", from x in plant.Genes.Genes
				group x by x.GetDisplayCharacter() into x
				orderby x.Key
				select x.Count() + x.Key);
		}
		return value;
	}

	private static string GetMonument(BaseEntity entity)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return null;
		}
		SpawnGroup spawnGroup = null;
		if (entity is BaseCorpse baseCorpse)
		{
			spawnGroup = baseCorpse.spawnGroup;
		}
		if ((Object)(object)spawnGroup == (Object)null)
		{
			SpawnPointInstance component = ((Component)entity).GetComponent<SpawnPointInstance>();
			if ((Object)(object)component != (Object)null)
			{
				spawnGroup = component.parentSpawnPointUser as SpawnGroup;
			}
		}
		if ((Object)(object)spawnGroup != (Object)null)
		{
			if (!string.IsNullOrEmpty(spawnGroup.category))
			{
				return spawnGroup.category;
			}
			if ((Object)(object)spawnGroup.Monument != (Object)null)
			{
				return ((Object)spawnGroup.Monument).name;
			}
		}
		MonumentInfo monumentInfo = TerrainMeta.Path.FindMonumentWithBoundsOverlap(((Component)entity).transform.position);
		if ((Object)(object)monumentInfo != (Object)null)
		{
			return ((Object)monumentInfo).name;
		}
		return null;
	}

	private static string GetBiome(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected I4, but got Unknown
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Invalid comparison between Unknown and I4
		string result = null;
		Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
		switch (val - 1)
		{
		default:
			if ((int)val == 8)
			{
				result = "arctic";
			}
			break;
		case 0:
			result = "arid";
			break;
		case 1:
			result = "grass";
			break;
		case 3:
			result = "tundra";
			break;
		case 2:
			break;
		}
		return result;
	}

	private static bool IsOcean(Vector3 position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.TopologyMap.GetTopology(position) == 128;
	}

	private static IEnumerator AggregateLoop()
	{
		int loop = 0;
		while (!Application.isQuitting)
		{
			yield return CoroutineEx.waitForSecondsRealtime(60f);
			if (GameplayAnalytics)
			{
				yield return TryCatch(AggregatePlayers(blueprints: false, positions: true));
				if (loop % 60 == 0)
				{
					PushServerInfo();
					yield return TryCatch(AggregateEntitiesAndItems());
					yield return TryCatch(AggregatePlayers(blueprints: true));
					yield return TryCatch(AggregateTeams());
					Dictionary<PendingItemsKey, PendingItemsData> dict = pendingItems;
					pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();
					yield return PushPendingItemsLoopAsync(dict);
				}
				loop++;
			}
		}
	}

	private static IEnumerator TryCatch(IEnumerator coroutine)
	{
		while (true)
		{
			try
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				break;
			}
			yield return coroutine.Current;
		}
	}

	private static IEnumerator AggregateEntitiesAndItems()
	{
		List<BaseNetworkable> entityQueue = new List<BaseNetworkable>();
		entityQueue.Clear();
		int totalCount = BaseNetworkable.serverEntities.Count;
		entityQueue.AddRange(BaseNetworkable.serverEntities);
		Dictionary<string, int> itemDict = new Dictionary<string, int>();
		Dictionary<EntityKey, int> entityDict = new Dictionary<EntityKey, int>();
		yield return null;
		Debug.Log((object)"Starting to aggregate entities & items...");
		DateTime startTime = DateTime.UtcNow;
		Stopwatch watch = Stopwatch.StartNew();
		foreach (BaseNetworkable entity in entityQueue)
		{
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
			if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
			{
				continue;
			}
			EntityKey entityKey = default(EntityKey);
			entityKey.PrefabId = entity.prefabID;
			EntityKey key = entityKey;
			if (entity is BuildingBlock buildingBlock)
			{
				key.Grade = (int)(buildingBlock.grade + 1);
			}
			entityDict.TryGetValue(key, out var value);
			entityDict[key] = value + 1;
			if (!(entity is LootContainer) && !(entity is BasePlayer { IsNpc: not false }) && !(entity is NPCPlayer))
			{
				if (entity is BasePlayer basePlayer2)
				{
					AddItemsToDict(basePlayer2.inventory.containerMain, itemDict);
					AddItemsToDict(basePlayer2.inventory.containerBelt, itemDict);
					AddItemsToDict(basePlayer2.inventory.containerWear, itemDict);
				}
				else if (entity is IItemContainerEntity itemContainerEntity)
				{
					AddItemsToDict(itemContainerEntity.inventory, itemDict);
				}
				else if (entity is DroppedItemContainer { inventory: not null } droppedItemContainer)
				{
					AddItemsToDict(droppedItemContainer.inventory, itemDict);
				}
			}
		}
		Debug.Log((object)$"Took {Math.Round(DateTime.UtcNow.Subtract(startTime).TotalSeconds, 1)}s to aggregate {totalCount} entities & items...");
		_ = DateTime.UtcNow;
		SubmitPoint(EventRecord.New("entity_sum").AddObject("counts", entityDict.Select(delegate(KeyValuePair<EntityKey, int> x)
		{
			EntitySumItem result = default(EntitySumItem);
			result.PrefabId = x.Key.PrefabId;
			result.Grade = x.Key.Grade;
			result.Count = x.Value;
			return result;
		})));
		yield return null;
		SubmitPoint(EventRecord.New("item_sum").AddObject("counts", itemDict));
		yield return null;
	}

	private static void AddItemsToDict(ItemContainer container, Dictionary<string, int> dict)
	{
		if (container == null || container.itemList == null)
		{
			return;
		}
		foreach (Item item in container.itemList)
		{
			string shortname = item.info.shortname;
			dict.TryGetValue(shortname, out var value);
			dict[shortname] = value + item.amount;
			if (item.contents != null)
			{
				AddItemsToDict(item.contents, dict);
			}
		}
	}

	private static IEnumerator PushPendingItemsLoopAsync(Dictionary<PendingItemsKey, PendingItemsData> dict)
	{
		Stopwatch watch = Stopwatch.StartNew();
		foreach (PendingItemsData value in dict.Values)
		{
			try
			{
				LogResource(value.Key.Consumed ? ResourceMode.Consumed : ResourceMode.Produced, value.category, value.Key.Item, value.amount, null, null, safezone: false, null, 0uL, value.Key.Entity);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			PendingItemsData pendingItemsData = value;
			Pool.Free<PendingItemsData>(ref pendingItemsData);
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		dict.Clear();
	}

	public static void AddPendingItems(BaseEntity entity, string itemName, int amount, string category, bool consumed = true, bool perEntity = false)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		PendingItemsKey pendingItemsKey = default(PendingItemsKey);
		pendingItemsKey.Entity = entity.ShortPrefabName;
		pendingItemsKey.Category = category;
		pendingItemsKey.Item = itemName;
		pendingItemsKey.Consumed = consumed;
		pendingItemsKey.EntityId = (NetworkableId)(perEntity ? entity.net.ID : default(NetworkableId));
		PendingItemsKey key = pendingItemsKey;
		if (!pendingItems.TryGetValue(key, out var value))
		{
			value = Pool.Get<PendingItemsData>();
			value.Key = key;
			value.category = category;
			pendingItems[key] = value;
		}
		value.amount += amount;
	}

	private static IEnumerator AggregatePlayers(bool blueprints = false, bool positions = false)
	{
		Stopwatch watch = Stopwatch.StartNew();
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		list.AddRange((IEnumerable<BasePlayer>)BasePlayer.activePlayerList);
		Dictionary<int, int> playerBps = (blueprints ? new Dictionary<int, int>() : null);
		List<PlayerAggregate> playerPositions = (positions ? Pool.Get<List<PlayerAggregate>>() : null);
		foreach (BasePlayer item in list)
		{
			if ((Object)(object)item == (Object)null || item.IsDestroyed)
			{
				continue;
			}
			if (blueprints)
			{
				foreach (int unlockedItem in item.PersistantPlayerInfo.unlockedItems)
				{
					playerBps.TryGetValue(unlockedItem, out var value);
					playerBps[unlockedItem] = value + 1;
				}
			}
			if (positions)
			{
				PlayerAggregate playerAggregate = Pool.Get<PlayerAggregate>();
				playerAggregate.UserId = item.WipeId;
				playerAggregate.Position = ((Component)item).transform.position;
				Quaternion bodyRotation = item.eyes.bodyRotation;
				playerAggregate.Direction = ((Quaternion)(ref bodyRotation)).eulerAngles;
				foreach (Item item2 in item.inventory.containerBelt.itemList)
				{
					playerAggregate.Hotbar.Add(item2.info.shortname);
				}
				foreach (Item item3 in item.inventory.containerWear.itemList)
				{
					playerAggregate.Worn.Add(item3.info.shortname);
				}
				playerAggregate.ActiveItem = item.GetActiveItem()?.info.shortname;
				playerPositions.Add(playerAggregate);
			}
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		if (blueprints)
		{
			SubmitPoint(EventRecord.New("blueprint_aggregate_online").AddObject("blueprints", playerBps.Select((KeyValuePair<int, int> x) => new
			{
				Key = ItemManager.FindItemDefinition(x.Key).shortname,
				value = x.Value
			})));
		}
		if (!positions)
		{
			yield break;
		}
		SubmitPoint(EventRecord.New("player_positions").AddObject("positions", playerPositions).AddObject("player_count", playerPositions.Count));
		foreach (PlayerAggregate item4 in playerPositions)
		{
			PlayerAggregate current5 = item4;
			Pool.Free<PlayerAggregate>(ref current5);
		}
		Pool.Free<PlayerAggregate>(ref playerPositions, false);
	}

	private static IEnumerator AggregateTeams()
	{
		yield return null;
		HashSet<ulong> teamIds = new HashSet<ulong>();
		int inTeam = 0;
		int notInTeam = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((Object)(object)current != (Object)null && !current.IsDestroyed && current.currentTeam != 0L)
				{
					teamIds.Add(current.currentTeam);
					inTeam++;
				}
				else
				{
					notInTeam++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		yield return null;
		Stopwatch watch = Stopwatch.StartNew();
		List<TeamInfo> teams = Pool.Get<List<TeamInfo>>();
		foreach (ulong item in teamIds)
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(item);
			if (playerTeam == null || !((playerTeam.members != null) & (playerTeam.members.Count > 0)))
			{
				continue;
			}
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			teams.Add(teamInfo);
			foreach (ulong member in playerTeam.members)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed && basePlayer.IsConnected && !basePlayer.IsSleeping())
				{
					teamInfo.online.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
				else
				{
					teamInfo.offline.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
			}
			teamInfo.member_count = teamInfo.online.Count + teamInfo.offline.Count;
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		SubmitPoint(EventRecord.New("online_teams").AddObject("teams", teams).AddField("users_in_team", inTeam)
			.AddField("users_not_in_team", notInTeam));
		foreach (TeamInfo item2 in teams)
		{
			TeamInfo current4 = item2;
			Pool.Free<TeamInfo>(ref current4);
		}
		Pool.Free<TeamInfo>(ref teams, false);
	}
}


public enum ResourceMode
{
	Produced,
	Consumed
}


private static class EventIds
{
	public const string EntityBuilt = "entity_built";

	public const string EntityPickup = "entity_pickup";

	public const string EntityDamage = "entity_damage";

	public const string PlayerRespawn = "player_respawn";

	public const string ExplosiveLaunched = "explosive_launch";

	public const string Explosion = "explosion";

	public const string ItemEvent = "item_event";

	public const string EntitySum = "entity_sum";

	public const string ItemSum = "item_sum";

	public const string ItemDespawn = "item_despawn";

	public const string ItemDropped = "item_drop";

	public const string ItemPickup = "item_pickup";

	public const string AntihackViolation = "antihack_violation";

	public const string AntihackViolationDetailed = "antihack_violation_detailed";

	public const string PlayerConnect = "player_connect";

	public const string PlayerDisconnect = "player_disconnect";

	public const string ConsumableUsed = "consumeable_used";

	public const string MedUsed = "med_used";

	public const string ResearchStarted = "research_start";

	public const string BlueprintLearned = "blueprint_learned";

	public const string TeamChanged = "team_change";

	public const string EntityAuthChange = "auth_change";

	public const string VendingOrderChanged = "vending_changed";

	public const string VendingSale = "vending_sale";

	public const string ChatMessage = "chat";

	public const string BlockUpgrade = "block_upgrade";

	public const string BlockDemolish = "block_demolish";

	public const string ItemRepair = "item_repair";

	public const string EntityRepair = "entity_repair";

	public const string ItemSkinned = "item_skinned";

	public const string EntitySkinned = "entity_skinned";

	public const string ItemAggregate = "item_aggregate";

	public const string CodelockChanged = "code_change";

	public const string CodelockEntered = "code_enter";

	public const string SleepingBagAssign = "sleeping_bag_assign";

	public const string FallDamage = "fall_damage";

	public const string PlayerWipeIdSet = "player_wipe_id_set";

	public const string ServerInfo = "server_info";

	public const string UnderwaterCrateUntied = "crate_untied";

	public const string VehiclePurchased = "vehicle_purchase";

	public const string NPCVendor = "npc_vendor";

	public const string BlueprintsOnline = "blueprint_aggregate_online";

	public const string PlayerPositions = "player_positions";

	public const string ProjectileInvalid = "projectile_invalid";

	public const string ItemDefinitions = "item_definitions";

	public const string KeycardSwiped = "keycard_swiped";

	public const string EntitySpawned = "entity_spawned";

	public const string EntityKilled = "entity_killed";

	public const string HackableCrateStarted = "hackable_crate_started";

	public const string HackableCrateEnded = "hackable_crate_ended";

	public const string StashHidden = "stash_hidden";

	public const string StashRevealed = "stash_reveal";

	public const string EntityManifest = "entity_manifest";

	public const string LootEntity = "loot_entity";

	public const string OnlineTeams = "online_teams";

	public const string Gambling = "gambing";

	public const string BuildingBlockColor = "building_block_color";

	public const string MissionComplete = "mission_complete";

	public const string PlayerPinged = "player_pinged";

	public const string BagUnclaim = "bag_unclaim";

	public const string SteamAuth = "steam_auth";

	public const string ParachuteUsed = "parachute_used";

	public const string MountEntity = "mount";

	public const string DismountEntity = "dismount";

	public const string BurstToggle = "burst_toggle";

	public const string TutorialStarted = "tutorial_started";

	public const string TutorialCompleted = "tutorial_completed";

	public const string TutorialQuit = "tutorial_quit";

	public const string BaseInteraction = "base_interaction";

	public const string PlayerDeath = "player_death";

	public const string CarShredded = "car_shredded";

	public const string PlayerTick = "player_tick";

	public const string WallpaperPlaced = "wallpaper_placed";

	public const string StartFish = "fishing_start";

	public const string FailedFish = "fishing_failed";

	public const string CaughtFish = "fishing_caught";
}


private struct SimpleItemAmount
{
	public string ItemName;

	public int Amount;

	public ulong Skin;

	public float Condition;

	public SimpleItemAmount(Item item)
	{
		ItemName = item.info.shortname;
		Amount = item.amount;
		Skin = item.skin;
		Condition = item.conditionNormalized;
	}
}


using System;

private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
{
	public ulong UserId;

	public int ProjectileId;

	public FiredProjectileKey(ulong userId, int projectileId)
	{
		UserId = userId;
		ProjectileId = projectileId;
	}

	public bool Equals(FiredProjectileKey other)
	{
		if (other.UserId == UserId)
		{
			return other.ProjectileId == ProjectileId;
		}
		return false;
	}
}


private class PendingFiredProjectile : IPooled
{
	public EventRecord Record;

	public BasePlayer.FiredProjectile FiredProjectile;

	public bool Hit;

	public void EnterPool()
	{
		Hit = false;
		Record = null;
		FiredProjectile = null;
	}

	public void LeavePool()
	{
	}
}


[JsonModel]
private struct EntitySumItem
{
	public uint PrefabId;

	public int Count;

	public int Grade;
}


using System;

private struct EntityKey : IEquatable<EntityKey>
{
	public uint PrefabId;

	public int Grade;

	public bool Equals(EntityKey other)
	{
		if (PrefabId == other.PrefabId)
		{
			return Grade == other.Grade;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
	}
}


private class PendingItemsData : IPooled
{
	public PendingItemsKey Key;

	public int amount;

	public string category;

	public void EnterPool()
	{
		Key = default(PendingItemsKey);
		amount = 0;
		category = null;
	}

	public void LeavePool()
	{
	}
}


using System;

private struct PendingItemsKey : IEquatable<PendingItemsKey>
{
	public string Item;

	public bool Consumed;

	public string Entity;

	public string Category;

	public NetworkableId EntityId;

	public bool Equals(PendingItemsKey other)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
		{
			return Category == other.Category;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
	}
}


using System.Collections.Generic;
using UnityEngine;

[JsonModel]
private class PlayerAggregate : IPooled
{
	public string UserId;

	public Vector3 Position;

	public Vector3 Direction;

	public List<string> Hotbar = new List<string>();

	public List<string> Worn = new List<string>();

	public string ActiveItem;

	public void EnterPool()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		UserId = null;
		Position = default(Vector3);
		Direction = default(Vector3);
		Hotbar.Clear();
		Worn.Clear();
		ActiveItem = null;
	}

	public void LeavePool()
	{
	}
}


using System.Collections.Generic;

[JsonModel]
private class TeamInfo : IPooled
{
	public List<string> online = new List<string>();

	public List<string> offline = new List<string>();

	public int member_count;

	public void EnterPool()
	{
		online.Clear();
		offline.Clear();
		member_count = 0;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using Cysharp.Text;
using Network;
using Rust;
using Steamworks;
using UnityEngine;

public class AzureWebInterface
{
	public static readonly AzureWebInterface client = new AzureWebInterface(isClient: true);

	public static readonly AzureWebInterface server = new AzureWebInterface(isClient: false);

	private AzureAnalyticsUploader GameplayBulkUploader;

	public bool IsClient;

	public int MaxRetries = 1;

	public int FlushSize = 1000;

	public TimeSpan FlushDelay = TimeSpan.FromSeconds(30.0);

	private DateTime nextFlush;

	private ConcurrentQueue<EventRecord> uploadQueue = new ConcurrentQueue<EventRecord>();

	private HttpClient HttpClient = new HttpClient();

	private static readonly MediaTypeHeaderValue JsonContentType = new MediaTypeHeaderValue("application/json")
	{
		CharSet = Encoding.UTF8.WebName
	};

	public int PendingCount => uploadQueue.Count;

	public AzureWebInterface(bool isClient)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		IsClient = isClient;
		Task.Run((Func<Task?>)UploadSchedulingThread);
	}

	public void EnqueueEvent(EventRecord point)
	{
		if (!IsClient && !string.IsNullOrEmpty(GetContainerUrl()))
		{
			if (GameplayBulkUploader.NeedsCreation())
			{
				GameplayBulkUploader = AzureAnalyticsUploader.Create("gameplay_events", TimeSpan.FromMinutes(5.0));
				GameplayBulkUploader.UseJsonDataObject = true;
			}
			GameplayBulkUploader.Append(point);
		}
		else
		{
			point.MarkSubmitted();
			uploadQueue.Enqueue(point);
		}
	}

	private async Task UploadSchedulingThread()
	{
		while (!Application.isQuitting)
		{
			try
			{
				DateTime utcNow = DateTime.UtcNow;
				if (uploadQueue.IsEmpty || (uploadQueue.Count < FlushSize && nextFlush > utcNow))
				{
					await Task.Delay(1000);
					continue;
				}
				nextFlush = utcNow.Add(FlushDelay);
				List<EventRecord> list = Pool.Get<List<EventRecord>>();
				EventRecord result;
				while (uploadQueue.TryDequeue(out result))
				{
					list.Add(result);
				}
				Task.Run(async delegate
				{
					await UploadAsync(list);
				});
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				await Task.Delay(1000);
			}
		}
	}

	private void SerializeEvents(List<EventRecord> records, MemoryStream stream)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Utf8ValueStringBuilder writer = ZString.CreateUtf8StringBuilder();
		try
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("[");
			foreach (EventRecord record in records)
			{
				if (num > 0)
				{
					((Utf8ValueStringBuilder)(ref writer)).Append(',');
				}
				record.SerializeAsJson(ref writer);
				num++;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("]");
			((Utf8ValueStringBuilder)(ref writer)).WriteTo((Stream)stream);
		}
		finally
		{
			((Utf8ValueStringBuilder)(ref writer)).Dispose();
		}
	}

	private async Task UploadAsync(List<EventRecord> records)
	{
		if (!(IsClient ? (Application.Manifest?.Features?.ClientAnalytics == true) : (Application.Manifest?.Features?.ServerAnalytics == true)))
		{
			Pool.Free<EventRecord>(ref records, true);
			return;
		}
		if (records.Count == 0)
		{
			Pool.Free<EventRecord>(ref records, false);
			return;
		}
		MemoryStream stream = Pool.Get<MemoryStream>();
		stream.Position = 0L;
		stream.SetLength(0L);
		try
		{
			SerializeEvents(records, stream);
			AuthTicket ticket = null;
			for (int attempt = 0; attempt < MaxRetries; attempt++)
			{
				try
				{
					ByteArrayContent content = new ByteArrayContent(stream.GetBuffer(), 0, (int)stream.Length);
					try
					{
						((HttpContent)content).Headers.ContentType = JsonContentType;
						if (!string.IsNullOrEmpty(AnalyticsSecret))
						{
							((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsSecret);
						}
						else
						{
							((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsPublicKey);
						}
						if (!IsClient)
						{
							((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-IP", Net.sv.ip);
							((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-PORT", Net.sv.port.ToString());
						}
						(await HttpClient.PostAsync(IsClient ? ClientAnalyticsUrl : ServerAnalyticsUrl, (HttpContent)(object)content)).EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)content)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					HttpRequestException val = (HttpRequestException)(object)((ex is HttpRequestException) ? ex : null);
					if (val != null)
					{
						Debug.Log((object)("HTTP Error when uploading analytics: " + ((Exception)(object)val).Message));
					}
					else
					{
						Debug.LogException(ex);
					}
					goto IL_02ae;
				}
				break;
				IL_02ae:
				if (ticket != null)
				{
					try
					{
						ticket.Cancel();
					}
					catch (Exception ex2)
					{
						Debug.LogError((object)("Failed to cancel auth ticket in analytics: " + ex2.ToString()));
					}
				}
			}
		}
		catch (Exception ex3)
		{
			if (IsClient)
			{
				Debug.LogWarning((object)ex3.ToString());
			}
			else
			{
				Debug.LogException(ex3);
			}
		}
		finally
		{
			Pool.Free<EventRecord>(ref records, true);
			Pool.FreeUnmanaged(ref stream);
		}
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Auto)]
private struct <<UploadSchedulingThread>b__0>d : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder <>t__builder;

	public <>c__DisplayClass15_0 <>4__this;

	private TaskAwaiter <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		<>c__DisplayClass15_0 <>c__DisplayClass15_ = <>4__this;
		try
		{
			TaskAwaiter awaiter;
			if (num != 0)
			{
				awaiter = <>c__DisplayClass15_.<>4__this.UploadAsync(<>c__DisplayClass15_.list).GetAwaiter();
				if (!awaiter.IsCompleted)
				{
					num = (<>1__state = 0);
					<>u__1 = awaiter;
					<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
					return;
				}
			}
			else
			{
				awaiter = <>u__1;
				<>u__1 = default(TaskAwaiter);
				num = (<>1__state = -1);
			}
			awaiter.GetResult();
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult();
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		<>t__builder.SetStateMachine(stateMachine);
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}


using Facepunch.Rust;

public static class AzureAnalyticsUploaderEx
{
	public static bool NeedsCreation(this AzureAnalyticsUploader uploader)
	{
		return uploader?.TryFlush() ?? true;
	}
}


public enum AnalyticsDocumentMode
{
	JSON,
	CSV
}


using System;
using System.Collections.Concurrent;
using System.IO;
using System.IO.Compression;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Identity;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using ConVar;
using Cysharp.Text;
using Facepunch;
using Facepunch.Rust;
using UnityEngine;

public class AzureAnalyticsUploader : IPooled
{
	public static bool UsePooling = false;

	public static int SmallBufferSendLimit = 16384;

	public static ClientSecretCredential Credential;

	private ConcurrentQueue<EventRecord> queue = new ConcurrentQueue<EventRecord>();

	private BlobClient _blobClient;

	private Stream Stream;

	private GZipStream ZipStream;

	private Utf8ValueStringBuilder Writer;

	private bool disposed;

	private BlobOpenWriteOptions blobWriteOptions = new BlobOpenWriteOptions
	{
		HttpHeaders = new BlobHttpHeaders
		{
			ContentEncoding = "gzip"
		}
	};

	public TimeSpan LoopDelay { get; set; }

	public DateTime Expiry { get; private set; }

	public bool StrictMode { get; set; }

	public AnalyticsDocumentMode DocumentMode { get; private set; }

	public bool UseJsonDataObject { get; set; }

	public AzureAnalyticsUploader()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_002c: Expected O, but got Unknown
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Writer = ZString.CreateUtf8StringBuilder();
	}

	public void EnterPool()
	{
		disposed = true;
	}

	private void Initialize()
	{
		LoopDelay = TimeSpan.FromMilliseconds(250.0);
		Expiry = DateTime.MinValue;
		StrictMode = false;
		UseJsonDataObject = false;
		DocumentMode = AnalyticsDocumentMode.JSON;
		EmptyUploadQueue();
		_blobClient = null;
		Stream = null;
		ZipStream = null;
		disposed = false;
	}

	public void LeavePool()
	{
		Initialize();
	}

	public bool TryFlush()
	{
		if (Expiry >= DateTime.UtcNow)
		{
			return false;
		}
		disposed = true;
		return true;
	}

	public static AzureAnalyticsUploader Create(string table, TimeSpan timeout, AnalyticsDocumentMode mode = AnalyticsDocumentMode.JSON)
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Expected O, but got Unknown
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Expected O, but got Unknown
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Expected O, but got Unknown
		AzureAnalyticsUploader azureAnalyticsUploader;
		if (UsePooling)
		{
			azureAnalyticsUploader = Pool.Get<AzureAnalyticsUploader>();
		}
		else
		{
			azureAnalyticsUploader = new AzureAnalyticsUploader();
			azureAnalyticsUploader.Initialize();
		}
		azureAnalyticsUploader.Expiry = DateTime.UtcNow + timeout;
		azureAnalyticsUploader.DocumentMode = mode;
		if (string.IsNullOrEmpty(Analytics.GetContainerUrl()))
		{
			Debug.Log((object)"No analytics_bulk_container_url or analytics_bulk_connection_string set, disabling bulk uploader.");
			azureAnalyticsUploader.disposed = true;
			return azureAnalyticsUploader;
		}
		string text = ((mode == AnalyticsDocumentMode.JSON) ? ".json" : ".csv");
		string text2 = Path.Combine(table, Server.server_id, Guid.NewGuid().ToString("N") + text + ".gz");
		BlobContainerClient val;
		if (!string.IsNullOrEmpty(Analytics.BulkUploadConnectionString))
		{
			val = new BlobContainerClient(new Uri(Analytics.BulkUploadConnectionString), (BlobClientOptions)null);
		}
		else
		{
			if (string.IsNullOrEmpty(Analytics.AzureTenantId) || string.IsNullOrEmpty(Analytics.AzureClientId) || string.IsNullOrEmpty(Analytics.AzureClientSecret))
			{
				Debug.Log((object)"analytics_bulk_container_url set but missing Azure AD credentials, disabling bulk uploader.");
				azureAnalyticsUploader.disposed = true;
				return azureAnalyticsUploader;
			}
			if (Credential == null)
			{
				Credential = new ClientSecretCredential(Analytics.AzureTenantId, Analytics.AzureClientId, Analytics.AzureClientSecret);
			}
			val = new BlobContainerClient(new Uri(Analytics.BulkContainerUrl), (TokenCredential)(object)Credential, (BlobClientOptions)null);
		}
		azureAnalyticsUploader._blobClient = val.GetBlobClient(text2);
		Task.Run((Func<Task?>)azureAnalyticsUploader.UploadThread);
		return azureAnalyticsUploader;
	}

	public void Append(EventRecord record)
	{
		if (disposed)
		{
			if (StrictMode)
			{
				throw new Exception("Trying to append to a disposed uploader: make sure to dispose the uploader properly!");
			}
			record.MarkSubmitted();
			Pool.Free<EventRecord>(ref record);
		}
		else
		{
			queue.Enqueue(record);
		}
	}

	private async Task CreateBlobAsync()
	{
		CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
		cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(10.0));
		blobWriteOptions.HttpHeaders.ContentType = ((DocumentMode == AnalyticsDocumentMode.JSON) ? "application/json" : "text/csv");
		try
		{
			Stream = await _blobClient.OpenWriteAsync(true, blobWriteOptions, cancellationTokenSource.Token);
		}
		catch (RequestFailedException val)
		{
			RequestFailedException val2 = val;
			switch (val2.Status)
			{
			case 403:
				Debug.Log((object)("Access denied to container " + ((BlobBaseClient)_blobClient).BlobContainerName + ", disabling bulk uploader."));
				break;
			case 404:
				Debug.Log((object)("Container " + ((BlobBaseClient)_blobClient).BlobContainerName + " doesn't exist, disabling bulk uploader."));
				break;
			default:
				Debug.Log((object)$"Unknown error when opening Azure container, status code: {val2.Status}, disabling bulk uploader.");
				Debug.LogException((Exception)(object)val2);
				break;
			}
			EmptyUploadQueue();
			return;
		}
		ZipStream = new GZipStream(Stream, CompressionLevel.Fastest);
		((Utf8ValueStringBuilder)(ref Writer)).Clear();
	}

	private async Task UploadThread()
	{
		try
		{
			_ = 2;
			try
			{
				while (!disposed || !queue.IsEmpty)
				{
					EventRecord record;
					while (queue.TryDequeue(out record))
					{
						if (Stream == null)
						{
							await CreateBlobAsync();
							if (Stream == null)
							{
								record.MarkSubmitted();
								Pool.Free<EventRecord>(ref record);
								continue;
							}
						}
						((Utf8ValueStringBuilder)(ref Writer)).Clear();
						if (DocumentMode == AnalyticsDocumentMode.JSON)
						{
							record.SerializeAsJson(ref Writer, UseJsonDataObject);
						}
						else if (DocumentMode == AnalyticsDocumentMode.CSV)
						{
							record.SerializeAsCSV(ref Writer);
						}
						((Utf8ValueStringBuilder)(ref Writer)).AppendLine();
						if (((Utf8ValueStringBuilder)(ref Writer)).Length > SmallBufferSendLimit)
						{
							await ((Utf8ValueStringBuilder)(ref Writer)).WriteToAsync((Stream)ZipStream);
						}
						else
						{
							((Utf8ValueStringBuilder)(ref Writer)).WriteTo((Stream)ZipStream);
						}
						record.MarkSubmitted();
						Pool.Free<EventRecord>(ref record);
					}
					await Task.Delay(LoopDelay);
				}
			}
			catch (Exception ex)
			{
				disposed = true;
				Debug.LogException(ex);
				EmptyUploadQueue();
			}
		}
		finally
		{
			await DisposeStreamsAsync();
			if (UsePooling)
			{
				AzureAnalyticsUploader azureAnalyticsUploader = this;
				Pool.Free<AzureAnalyticsUploader>(ref azureAnalyticsUploader);
			}
		}
	}

	private void EmptyUploadQueue()
	{
		EventRecord result;
		while (queue.TryDequeue(out result))
		{
			result.MarkSubmitted();
			Pool.Free<EventRecord>(ref result);
		}
	}

	private async Task DisposeStreamsAsync()
	{
		if (ZipStream != null)
		{
			await ZipStream.DisposeAsync();
			ZipStream = null;
		}
		if (Stream != null)
		{
			await Stream.DisposeAsync();
			Stream = null;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using Cysharp.Text;
using Facepunch;
using Facepunch.Rust;
using Newtonsoft.Json;
using UnityEngine;

public class EventRecord : IPooled
{
	public static readonly long TicksToNS = 1000000000 / Stopwatch.Frequency;

	public DateTime Timestamp;

	[NonSerialized]
	public bool IsServer;

	public List<EventRecordField> Data = new List<EventRecordField>();

	public int TimesCreated;

	public int TimesSubmitted;

	public string EventType { get; private set; }

	public void EnterPool()
	{
		Timestamp = default(DateTime);
		EventType = null;
		IsServer = false;
		Data.Clear();
	}

	public void LeavePool()
	{
	}

	public static EventRecord CSV()
	{
		EventRecord eventRecord = Pool.Get<EventRecord>();
		eventRecord.IsServer = true;
		eventRecord.TimesCreated++;
		return eventRecord;
	}

	public static EventRecord New(string type, bool isServer = true)
	{
		EventRecord eventRecord = Pool.Get<EventRecord>();
		eventRecord.EventType = type;
		eventRecord.AddField("type", type);
		eventRecord.AddField("guid", Guid.NewGuid());
		BuildInfo current = BuildInfo.Current;
		bool num = (current.Scm.Branch != null && current.Scm.Branch == "experimental/release") || current.Scm.Branch == "release";
		bool isEditor = Application.isEditor;
		string value = ((num && !isEditor) ? "release" : (isEditor ? "editor" : "staging"));
		eventRecord.AddField("environment", value);
		eventRecord.IsServer = isServer;
		if (isServer && SaveRestore.WipeId != null)
		{
			eventRecord.AddField("wipe_id", SaveRestore.WipeId);
		}
		eventRecord.AddField("frame_count", Time.frameCount);
		eventRecord.Timestamp = DateTime.UtcNow;
		eventRecord.TimesCreated++;
		return eventRecord;
	}

	public EventRecord AddObject(string key, object data)
	{
		if (data == null)
		{
			return this;
		}
		Data.Add(new EventRecordField(key)
		{
			String = JsonConvert.SerializeObject(data),
			IsObject = true
		});
		return this;
	}

	public EventRecord SetTimestamp(DateTime timestamp)
	{
		Timestamp = timestamp;
		return this;
	}

	public EventRecord AddField(string key, DateTime time)
	{
		Data.Add(new EventRecordField(key)
		{
			DateTime = time
		});
		return this;
	}

	public EventRecord AddField(string key, bool value)
	{
		Data.Add(new EventRecordField(key)
		{
			String = (value ? "true" : "false")
		});
		return this;
	}

	public EventRecord AddField(string key, string value)
	{
		Data.Add(new EventRecordField(key)
		{
			String = value
		});
		return this;
	}

	public EventRecord AddField(string key, byte value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, sbyte value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, short value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, ushort value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, int value)
	{
		return AddField(key, (long)value);
	}

	public EventRecord AddField(string key, uint value)
	{
		return AddField(key, (long)value);
	}

	public EventRecord AddField(string key, ulong value)
	{
		return AddField(key, (long)value);
	}

	[Obsolete("Char not supported, either cast to int or string", true)]
	public EventRecord AddField(string key, char value)
	{
		throw new NotImplementedException();
	}

	public EventRecord AddField(string key, float value)
	{
		return AddField(key, (double)value);
	}

	public EventRecord AddField(string key, long value)
	{
		Data.Add(new EventRecordField(key)
		{
			Number = value
		});
		return this;
	}

	public EventRecord AddField(string key, double value)
	{
		Data.Add(new EventRecordField(key)
		{
			Float = value
		});
		return this;
	}

	public EventRecord AddField(string key, TimeSpan value)
	{
		Data.Add(new EventRecordField(key)
		{
			Number = value.Ticks * TicksToNS
		});
		return this;
	}

	public EventRecord AddLegacyTimespan(string key, TimeSpan value)
	{
		Data.Add(new EventRecordField(key)
		{
			Float = value.TotalSeconds
		});
		return this;
	}

	public EventRecord AddField(string key, Guid value)
	{
		Data.Add(new EventRecordField(key)
		{
			Guid = value
		});
		return this;
	}

	public EventRecord AddField(string key, Vector3 value)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Data.Add(new EventRecordField(key)
		{
			Vector = value
		});
		return this;
	}

	public EventRecord AddField(string key, BaseNetworkable entity)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null || entity.net == null)
		{
			return this;
		}
		if (entity is BasePlayer { IsNpc: false, IsBot: false } basePlayer)
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(basePlayer.userID);
			AddField(key, "_userid", userWipeId);
			AddField(key, "_modelstate", (basePlayer.modelStateTick ?? basePlayer.modelState).flags);
			AddField(key, "_tickViewAngles", basePlayer.tickViewAngles);
			AddField(key, "_mouse_delta", basePlayer.tickMouseDelta);
			AddField(key, "_heldentity", ((Object)(object)basePlayer.GetHeldEntity() != (Object)null) ? basePlayer.GetHeldEntity().ShortPrefabName : "");
			AddField(key, "_mounted", Object.op_Implicit((Object)(object)basePlayer.GetMounted()));
			AddField(key, "_parented", basePlayer.HasParent());
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				AddField(key, "_admin", value: true);
			}
		}
		if (entity is BaseEntity { skinID: not 0uL } baseEntity)
		{
			AddField(key, "_skin", baseEntity.skinID);
		}
		if (entity is BaseProjectile baseProjectile)
		{
			Item item = baseProjectile.GetItem();
			if (item != null && (item.contents?.itemList?.Count).GetValueOrDefault() > 0)
			{
				List<string> list = Pool.Get<List<string>>();
				foreach (Item item2 in item.contents.itemList)
				{
					list.Add(item2.info.shortname);
				}
				AddObject(key + "_inventory", list);
				Pool.FreeUnmanaged<string>(ref list);
			}
		}
		if (entity is DroppedItem droppedItem && droppedItem.DroppedTime != default(DateTime) && droppedItem.DroppedTime >= DateTime.UnixEpoch)
		{
			string userWipeId2 = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(droppedItem.DroppedBy);
			AddField("dropped_at", ((DateTimeOffset)droppedItem.DroppedTime).ToUnixTimeMilliseconds());
			AddField("dropped_by", userWipeId2);
		}
		if (entity is Door door)
		{
			AddField(key, "_building_id", door.buildingID);
		}
		if (entity is CodeLock codeLock && (Object)(object)codeLock.GetParentEntity() != (Object)null && codeLock.GetParentEntity() is DecayEntity entity2)
		{
			AddField("parent", (BaseNetworkable)entity2);
		}
		if (entity is BuildingBlock buildingBlock)
		{
			AddField(key, "_grade", (int)buildingBlock.grade);
			AddField(key, "_building_id", (int)buildingBlock.buildingID);
		}
		AddField(key, "_prefab", entity.ShortPrefabName);
		AddField(key, "_pos", ((Component)entity).transform.position);
		Quaternion rotation = ((Component)entity).transform.rotation;
		AddField(key, "_rot", ((Quaternion)(ref rotation)).eulerAngles);
		AddField(key, "_id", entity.net.ID.Value);
		return this;
	}

	public EventRecord AddField(string key, Item item)
	{
		if (item == null)
		{
			return this;
		}
		AddField(key, "_name", item.info.shortname);
		AddField(key, "_amount", item.amount);
		AddField(key, "_skin", item.skin);
		AddField(key, "_condition", item.conditionNormalized);
		return this;
	}

	public void MarkSubmitted()
	{
		TimesSubmitted++;
		if (TimesCreated != TimesSubmitted)
		{
			Debug.LogError((object)$"EventRecord pooling error: event has been submitted ({TimesSubmitted}) a different amount of times than it was created ({TimesCreated})");
		}
	}

	public void Submit()
	{
		if (IsServer)
		{
			Analytics.AzureWebInterface.server.EnqueueEvent(this);
		}
	}

	public void SerializeAsCSV(ref Utf8ValueStringBuilder writer)
	{
		if (Data.Count == 0)
		{
			return;
		}
		bool flag = false;
		foreach (EventRecordField datum in Data)
		{
			if (flag)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(',');
			}
			else
			{
				flag = true;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append('"');
			datum.Serialize(ref writer, AnalyticsDocumentMode.CSV);
			((Utf8ValueStringBuilder)(ref writer)).Append('"');
		}
	}

	public void SerializeAsJson(ref Utf8ValueStringBuilder writer, bool useDataObject = true)
	{
		((Utf8ValueStringBuilder)(ref writer)).Append("{\"Timestamp\":\"");
		((Utf8ValueStringBuilder)(ref writer)).Append(Timestamp, StandardFormats.DateTime_ISO);
		bool flag = false;
		if (useDataObject)
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("\",\"Data\":{");
		}
		else
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("\"");
			flag = true;
		}
		foreach (EventRecordField datum in Data)
		{
			if (flag)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(',');
			}
			else
			{
				flag = true;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("\"");
			((Utf8ValueStringBuilder)(ref writer)).Append(datum.Key1);
			if (datum.Key2 != null)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(datum.Key2);
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("\":");
			if (!datum.IsObject)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append('"');
			}
			datum.Serialize(ref writer, AnalyticsDocumentMode.JSON);
			if (!datum.IsObject)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append("\"");
			}
		}
		if (useDataObject)
		{
			((Utf8ValueStringBuilder)(ref writer)).Append('}');
		}
		((Utf8ValueStringBuilder)(ref writer)).Append('}');
	}

	public EventRecord AddField(byte value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(short value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(ushort value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(int value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(uint value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(ulong value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(float value)
	{
		return AddField((double)value);
	}

	[Obsolete("Char not supported, either cast to int or string")]
	public EventRecord AddField(char value)
	{
		throw new NotImplementedException();
	}

	public EventRecord AddField(long value)
	{
		Data.Add(new EventRecordField
		{
			Number = value
		});
		return this;
	}

	public EventRecord AddField(double value)
	{
		Data.Add(new EventRecordField
		{
			Float = value
		});
		return this;
	}

	public EventRecord AddField(string value)
	{
		Data.Add(new EventRecordField
		{
			String = value
		});
		return this;
	}

	public EventRecord AddField(bool value)
	{
		Data.Add(new EventRecordField
		{
			String = (value ? "true" : "false")
		});
		return this;
	}

	public EventRecord AddField(DateTime value)
	{
		Data.Add(new EventRecordField
		{
			DateTime = value
		});
		return this;
	}

	public EventRecord AddField(TimeSpan value)
	{
		Data.Add(new EventRecordField
		{
			Number = value.Ticks * TicksToNS
		});
		return this;
	}

	public EventRecord AddField(Guid value)
	{
		Data.Add(new EventRecordField
		{
			Guid = value
		});
		return this;
	}

	public EventRecord AddField(Vector3 vector)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Data.Add(new EventRecordField
		{
			Vector = vector
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, byte value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, short value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, ushort value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, int value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, uint value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, ulong value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, float value)
	{
		return AddField(key1, key2, (double)value);
	}

	[Obsolete("Char not supported, either cast to int or string")]
	public EventRecord AddField(string key1, string key2, char value)
	{
		throw new NotImplementedException();
	}

	public EventRecord AddField(string key1, string key2, long value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Number = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, double value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Float = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, string value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			String = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, bool value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			String = (value ? "true" : "false")
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, DateTime value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			DateTime = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, TimeSpan value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Number = value.Ticks * TicksToNS
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, Guid value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Guid = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, Vector3 vector)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Data.Add(new EventRecordField(key1, key2)
		{
			Vector = vector
		});
		return this;
	}
}


using System;
using System.Buffers;
using Cysharp.Text;
using Facepunch.Rust;
using UnityEngine;

public struct EventRecordField
{
	public string Key1;

	public string Key2;

	public string String;

	public long? Number;

	public double? Float;

	public Vector3? Vector;

	public Guid? Guid;

	public DateTime DateTime;

	public bool IsObject;

	public EventRecordField(string key1)
	{
		Key1 = key1;
		Key2 = null;
		String = null;
		Number = null;
		Float = null;
		Vector = null;
		Guid = null;
		IsObject = false;
		DateTime = default(DateTime);
	}

	public EventRecordField(string key1, string key2)
	{
		Key1 = key1;
		Key2 = key2;
		String = null;
		Number = null;
		Float = null;
		Vector = null;
		Guid = null;
		IsObject = false;
		DateTime = default(DateTime);
	}

	public void Serialize(ref Utf8ValueStringBuilder writer, AnalyticsDocumentMode format)
	{
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		if (String != null)
		{
			if (IsObject)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(String);
				return;
			}
			string @string = String;
			int length = String.Length;
			for (int i = 0; i < length; i++)
			{
				char c = @string[i];
				if (c == '\\' && format == AnalyticsDocumentMode.JSON)
				{
					((Utf8ValueStringBuilder)(ref writer)).Append("\\\\");
					continue;
				}
				switch (c)
				{
				case '"':
					if (format == AnalyticsDocumentMode.JSON)
					{
						((Utf8ValueStringBuilder)(ref writer)).Append("\\\"");
					}
					else
					{
						((Utf8ValueStringBuilder)(ref writer)).Append("\"\"");
					}
					break;
				case '\n':
					((Utf8ValueStringBuilder)(ref writer)).Append("\\n");
					break;
				case '\r':
					((Utf8ValueStringBuilder)(ref writer)).Append("\\r");
					break;
				case '\t':
					((Utf8ValueStringBuilder)(ref writer)).Append("\\t");
					break;
				default:
					((Utf8ValueStringBuilder)(ref writer)).Append(c);
					break;
				}
			}
		}
		else if (Float.HasValue)
		{
			Span<char> destination = stackalloc char[128];
			Float.Value.TryFormat(destination, out var charsWritten);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination.Slice(0, charsWritten));
		}
		else if (Number.HasValue)
		{
			((Utf8ValueStringBuilder)(ref writer)).Append(Number.Value);
		}
		else if (Guid.HasValue)
		{
			StandardFormat standardFormat = new StandardFormat('N');
			((Utf8ValueStringBuilder)(ref writer)).Append(Guid.Value, standardFormat);
		}
		else if (Vector.HasValue)
		{
			Span<char> destination2 = stackalloc char[128];
			((Utf8ValueStringBuilder)(ref writer)).Append('(');
			Vector3 value = Vector.Value;
			value.x.TryFormat(destination2, out var charsWritten2);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination2.Slice(0, charsWritten2));
			((Utf8ValueStringBuilder)(ref writer)).Append(',');
			value.y.TryFormat(destination2, out charsWritten2);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination2.Slice(0, charsWritten2));
			((Utf8ValueStringBuilder)(ref writer)).Append(',');
			value.z.TryFormat(destination2, out charsWritten2);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination2.Slice(0, charsWritten2));
			((Utf8ValueStringBuilder)(ref writer)).Append(')');
		}
		else if (DateTime != default(DateTime))
		{
			((Utf8ValueStringBuilder)(ref writer)).Append(DateTime, StandardFormats.DateTime_ISO);
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Epic.OnlineServices.Version;
using Facepunch;
using Facepunch.Ping;
using Facepunch.Rust;
using Network;
using UnityEngine;

public class PerformanceLogging
{
	private struct LagSpike
	{
		public int FrameIndex;

		public TimeSpan Time;

		public bool WasGC;
	}

	private struct GarbageCollect
	{
		public int FrameIndex;

		public TimeSpan Time;
	}

	private class PerformancePool
	{
		public List<TimeSpan> Frametimes;

		public List<int> Ping;
	}

	[JsonModel]
	private struct PluginInfo
	{
		public string Name;

		public string Author;

		public string Version;
	}

	[JsonModel]
	private struct ProcessInfo
	{
		public string Name;

		public long WorkingSet;
	}

	public static PerformanceLogging server = new PerformanceLogging(client: false);

	public static PerformanceLogging client = new PerformanceLogging(client: true);

	private readonly TimeSpan ClientInterval = TimeSpan.FromMinutes(10.0);

	private readonly TimeSpan ServerInterval = TimeSpan.FromMinutes(1.0);

	private readonly TimeSpan PublicServerInterval = TimeSpan.FromHours(1.0);

	private readonly TimeSpan PingInterval = TimeSpan.FromSeconds(5.0);

	private List<TimeSpan> Frametimes = new List<TimeSpan>();

	private List<int> PingHistory = new List<int>();

	private List<LagSpike> lagSpikes = new List<LagSpike>();

	private List<GarbageCollect> garbageCollections = new List<GarbageCollect>();

	private Dictionary<string, int> pendingTimings = new Dictionary<string, int>();

	private bool isClient;

	private Stopwatch frameWatch = new Stopwatch();

	private DateTime nextPingTime;

	private DateTime nextFlushTime;

	private DateTime connectedTime;

	private int serverIndex;

	private Guid totalSessionId = Guid.NewGuid();

	private Guid sessionId;

	private int lastFrameGC;

	private Type oxideType;

	private bool hasOxideType;

	public PerformanceLogging(bool client)
	{
		isClient = client;
	}

	private TimeSpan GetLagSpikeThreshold()
	{
		if (!isClient)
		{
			return TimeSpan.FromMilliseconds(200.0);
		}
		return TimeSpan.FromMilliseconds(100.0);
	}

	public void OnFrame()
	{
		if (!isClient && !Analytics.ServerPerformanceConVar)
		{
			ResetMeasurements();
			return;
		}
		TimeSpan elapsed = frameWatch.Elapsed;
		Frametimes.Add(elapsed);
		frameWatch.Restart();
		DateTime utcNow = DateTime.UtcNow;
		int num = System.GC.CollectionCount(0);
		bool flag = lastFrameGC != num;
		lastFrameGC = num;
		if (flag)
		{
			garbageCollections.Add(new GarbageCollect
			{
				FrameIndex = Frametimes.Count - 1,
				Time = elapsed
			});
		}
		if (elapsed > GetLagSpikeThreshold())
		{
			lagSpikes.Add(new LagSpike
			{
				FrameIndex = Frametimes.Count - 1,
				Time = elapsed,
				WasGC = flag
			});
		}
		if (utcNow > nextFlushTime)
		{
			try
			{
				FlushMainThread();
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Failed to flush analytics: " + ex));
			}
		}
	}

	private Dictionary<string, string> FindModifiedConvars()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		Command[] all = Index.All;
		foreach (Command val in all)
		{
			if (val.DefaultValue != null && val.GetOveride != null)
			{
				string text = val.GetOveride();
				if (text != val.DefaultValue)
				{
					dictionary[val.FullName] = text;
				}
			}
		}
		return dictionary;
	}

	public void FlushMainThread()
	{
		nextFlushTime = DateTime.UtcNow.Add(GetFlushInterval());
		if (!isClient && (BasePlayer.activePlayerList.Count == 0 || !Analytics.ServerPerformanceConVar))
		{
			ResetMeasurements();
			return;
		}
		Stopwatch stopwatch = Stopwatch.StartNew();
		EventRecord record = EventRecord.New(isClient ? "client_performance" : "server_performance", !isClient);
		record.AddObject("modified_convars", FindModifiedConvars());
		record.AddField("command_line", CommandLine.Full);
		record.AddField("lag_spike_count", lagSpikes.Count).AddLegacyTimespan("lag_spike_threshold", GetLagSpikeThreshold()).AddField("gc_count", garbageCollections.Count)
			.AddField("ram_managed", System.GC.GetTotalMemory(forceFullCollection: false))
			.AddField("ram_total", SystemInfoEx.systemMemoryUsed)
			.AddField("total_session_id", totalSessionId.ToString("N"))
			.AddField("uptime", (int)Time.realtimeSinceStartup)
			.AddField("map_url", World.Url)
			.AddField("world_size", World.Size)
			.AddField("world_seed", World.Seed)
			.AddField("active_scene", LevelManager.CurrentLevelName);
		if (pendingTimings.Count > 0)
		{
			record.AddObject("load_times", pendingTimings);
			pendingTimings.Clear();
		}
		IPingEstimateResults estimateToAllRegions = PingEstimater.GetEstimateToAllRegions();
		if (estimateToAllRegions != null)
		{
			record.AddObject("ping_regions", estimateToAllRegions.GetAllRegions());
		}
		if (!isClient && !isClient)
		{
			int value = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)3) : 0);
			int value2 = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)1) : 0);
			record.AddField("is_official", Server.official && Server.stats).AddField("bot_count", BasePlayer.bots.Count).AddField("player_count", BasePlayer.activePlayerList.Count)
				.AddField("max_players", Server.maxplayers)
				.AddField("ent_count", BaseNetworkable.serverEntities.Count)
				.AddField("hostname", Server.hostname)
				.AddField("net_in", value)
				.AddField("net_out", value2);
		}
		if (!isClient)
		{
			try
			{
				if (!hasOxideType)
				{
					oxideType = Type.GetType("Oxide.Core.Interface,Oxide.Core");
					hasOxideType = true;
				}
				if (oxideType != null)
				{
					record.AddField("is_oxide", value: true);
					object obj = oxideType.GetProperty("Oxide", BindingFlags.Static | BindingFlags.Public)?.GetValue(null);
					if (obj != null)
					{
						object obj2 = obj.GetType().GetProperty("RootPluginManager", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)?.GetValue(obj);
						if (obj2 != null)
						{
							List<PluginInfo> list = new List<PluginInfo>();
							foreach (object item in obj2.GetType().GetMethod("GetPlugins")?.Invoke(obj2, null) as IEnumerable)
							{
								if (item != null)
								{
									string name = item.GetType().GetProperty("Name")?.GetValue(item) as string;
									string author = item.GetType().GetProperty("Author")?.GetValue(item) as string;
									string version = item.GetType().GetProperty("Version")?.GetValue(item)?.ToString();
									list.Add(new PluginInfo
									{
										Name = name,
										Author = author,
										Version = version
									});
								}
							}
							record.AddObject("oxide_plugins", list);
							record.AddField("oxide_plugin_count", list.Count);
						}
					}
				}
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Failed to get oxide when flushing server performance: {arg}");
			}
			try
			{
				List<ProcessInfo> list2 = new List<ProcessInfo>();
				Process[] processes = Process.GetProcesses();
				Process currentProcess = Process.GetCurrentProcess();
				Process[] array = processes;
				foreach (Process process in array)
				{
					try
					{
						if (currentProcess.Id != process.Id && process.ProcessName.Contains("RustDedicated"))
						{
							list2.Add(new ProcessInfo
							{
								Name = process.ProcessName,
								WorkingSet = process.WorkingSet64
							});
						}
					}
					catch (Exception ex)
					{
						if (!(ex is InvalidOperationException))
						{
							Debug.LogWarning((object)$"Failed to get memory from process when flushing performance info: {ex}");
							list2.Add(new ProcessInfo
							{
								Name = process.ProcessName,
								WorkingSet = -1L
							});
						}
					}
				}
				record.AddObject("other_servers", list2);
				record.AddField("other_server_count", list2.Count);
			}
			catch (Exception arg2)
			{
				Debug.LogError((object)$"Failed to log processes when flushing performance info: {arg2}");
			}
		}
		if (!isClient)
		{
			IEnumerable<HarmonyModInfo> harmonyMods = HarmonyLoader.GetHarmonyMods();
			record.AddObject("harmony_mods", harmonyMods);
			record.AddField("harmony_mod_count", harmonyMods.Count());
		}
		string value3;
		using (SHA256 sHA = SHA256.Create())
		{
			value3 = Convert.ToBase64String(sHA.ComputeHash(Encoding.UTF8.GetBytes(SystemInfo.deviceUniqueIdentifier)));
		}
		Dictionary<string, string> data = new Dictionary<string, string>
		{
			["device_name"] = SystemInfo.deviceName,
			["device_hash"] = value3,
			["gpu_name"] = SystemInfo.graphicsDeviceName,
			["gpu_ram"] = SystemInfo.graphicsMemorySize.ToString(),
			["gpu_vendor"] = SystemInfo.graphicsDeviceVendor,
			["gpu_version"] = SystemInfo.graphicsDeviceVersion,
			["gpu_shader_level"] = SystemInfo.graphicsShaderLevel.ToString(),
			["gpu_max_buffer_size"] = SystemInfo.maxGraphicsBufferSize.ToString(),
			["gpu_device_version"] = SystemInfo.graphicsDeviceVersion.ToString(),
			["cpu_cores"] = SystemInfo.processorCount.ToString(),
			["max_compute_work_size"] = SystemInfo.maxComputeWorkGroupSize.ToString(),
			["max_compute_work_size_x"] = SystemInfo.maxComputeWorkGroupSizeX.ToString(),
			["max_compute_work_size_y"] = SystemInfo.maxComputeWorkGroupSizeY.ToString(),
			["max_compute_work_size_z"] = SystemInfo.maxComputeWorkGroupSizeZ.ToString(),
			["cpu_frequency"] = SystemInfo.processorFrequency.ToString(),
			["gpu_max_texture_size"] = SystemInfo.maxTextureSize.ToString(),
			["cpu_name"] = SystemInfo.processorType.Trim(),
			["system_memory"] = SystemInfo.systemMemorySize.ToString(),
			["os"] = SystemInfo.operatingSystem,
			["supports_compute_shaders"] = SystemInfo.supportsComputeShaders.ToString(),
			["supports_async_compute"] = SystemInfo.supportsAsyncCompute.ToString(),
			["supports_async_gpu_readback"] = SystemInfo.supportsAsyncGPUReadback.ToString(),
			["supports_3d_textures"] = SystemInfo.supports3DTextures.ToString(),
			["supports_instancing"] = SystemInfo.supportsInstancing.ToString()
		};
		Dictionary<string, string> obj3 = new Dictionary<string, string> { ["unity"] = Application.unityVersion ?? "editor" };
		BuildInfo current2 = BuildInfo.Current;
		obj3["changeset"] = ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor";
		BuildInfo current3 = BuildInfo.Current;
		obj3["branch"] = ((current3 != null) ? current3.Scm.Branch : null) ?? "editor";
		obj3["network_version"] = 2585.ToString();
		Dictionary<string, string> dictionary = obj3;
		dictionary["eos_sdk"] = ((object)VersionInterface.GetVersion())?.ToString() ?? "disabled";
		record.AddObject("hardware", data).AddObject("application", dictionary);
		stopwatch.Stop();
		record.AddField("flush_ms", stopwatch.ElapsedMilliseconds);
		List<TimeSpan> frametimes = Frametimes;
		List<int> ping = PingHistory;
		Task.Run(async delegate
		{
			try
			{
				await ProcessPerformanceData(record, frametimes, ping);
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
		});
		ResetMeasurements();
	}

	private TimeSpan GetFlushInterval()
	{
		if (!isClient)
		{
			if (Analytics.Azure.GameplayAnalytics)
			{
				return ServerInterval;
			}
			return PublicServerInterval;
		}
		return TimeSpan.FromHours(1.0);
	}

	private void ResetMeasurements()
	{
		nextFlushTime = DateTime.UtcNow.Add(GetFlushInterval());
		if (Frametimes.Count != 0)
		{
			Frametimes = Pool.Get<List<TimeSpan>>();
			PingHistory = Pool.Get<List<int>>();
			lagSpikes.Clear();
			garbageCollections.Clear();
		}
	}

	private Task ProcessPerformanceData(EventRecord record, List<TimeSpan> frametimes, List<int> ping)
	{
		if (frametimes.Count <= 1)
		{
			return Task.CompletedTask;
		}
		List<TimeSpan> list = Pool.Get<List<TimeSpan>>();
		list.Clear();
		list.AddRange(frametimes);
		list.Sort();
		int count = frametimes.Count;
		Mathf.Max(1, frametimes.Count / 100);
		Mathf.Max(1, frametimes.Count / 1000);
		TimeSpan value = default(TimeSpan);
		for (int i = 0; i < count; i++)
		{
			TimeSpan timeSpan = list[i];
			value += timeSpan;
		}
		double frametime_average = value.TotalMilliseconds / (double)count;
		double value2 = Math.Sqrt(list.Sum((TimeSpan x) => Math.Pow(x.TotalMilliseconds - frametime_average, 2.0)) / (double)list.Count - 1.0);
		record.AddLegacyTimespan("total_time", value).AddField("frames", count).AddField("frametime_average", value.TotalSeconds / (double)count)
			.AddLegacyTimespan("frametime_99_9", list[Mathf.Clamp(count - count / 1000, 0, count - 1)])
			.AddLegacyTimespan("frametime_99", list[Mathf.Clamp(count - count / 100, 0, count - 1)])
			.AddLegacyTimespan("frametime_90", list[Mathf.Clamp(count - count / 10, 0, count - 1)])
			.AddLegacyTimespan("frametime_75", list[Mathf.Clamp(count - count / 4, 0, count - 1)])
			.AddLegacyTimespan("frametime_50", list[count / 2])
			.AddLegacyTimespan("frametime_25", list[count / 4])
			.AddLegacyTimespan("frametime_10", list[count / 10])
			.AddLegacyTimespan("frametime_1", list[count / 100])
			.AddLegacyTimespan("frametime_0_1", list[count / 1000])
			.AddField("frametime_std_dev", value2)
			.AddField("gc_generations", System.GC.MaxGeneration)
			.AddField("gc_total", System.GC.CollectionCount(System.GC.MaxGeneration));
		if (isClient)
		{
			record.AddField("ping_average", (ping.Count != 0) ? ((int)ping.Average()) : 0).AddField("ping_count", ping.Count);
		}
		record.Submit();
		Pool.FreeUnmanaged<TimeSpan>(ref list);
		Pool.FreeUnmanaged<TimeSpan>(ref frametimes);
		Pool.FreeUnmanaged<int>(ref ping);
		return Task.CompletedTask;
	}

	public void SetTiming(string category, TimeSpan elapsed)
	{
		pendingTimings[category] = (int)elapsed.TotalMilliseconds;
	}
}


using System;

private struct LagSpike
{
	public int FrameIndex;

	public TimeSpan Time;

	public bool WasGC;
}


using System;

private struct GarbageCollect
{
	public int FrameIndex;

	public TimeSpan Time;
}


using System;
using System.Collections.Generic;

private class PerformancePool
{
	public List<TimeSpan> Frametimes;

	public List<int> Ping;
}


[JsonModel]
private struct PluginInfo
{
	public string Name;

	public string Author;

	public string Version;
}


[JsonModel]
private struct ProcessInfo
{
	public string Name;

	public long WorkingSet;
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Auto)]
private struct <<FlushMainThread>b__0>d : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder <>t__builder;

	public <>c__DisplayClass31_0 <>4__this;

	private TaskAwaiter <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		<>c__DisplayClass31_0 <>c__DisplayClass31_ = <>4__this;
		try
		{
			try
			{
				TaskAwaiter awaiter;
				if (num != 0)
				{
					awaiter = <>c__DisplayClass31_.<>4__this.ProcessPerformanceData(<>c__DisplayClass31_.record, <>c__DisplayClass31_.frametimes, <>c__DisplayClass31_.ping).GetAwaiter();
					if (!awaiter.IsCompleted)
					{
						num = (<>1__state = 0);
						<>u__1 = awaiter;
						<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
						return;
					}
				}
				else
				{
					awaiter = <>u__1;
					<>u__1 = default(TaskAwaiter);
					num = (<>1__state = -1);
				}
				awaiter.GetResult();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult();
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		<>t__builder.SetStateMachine(stateMachine);
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}


using Facepunch.Rust;

public class TickLogging
{
	public static AzureAnalyticsUploader tickUploader;

	[Help("time (in seconds) before the tick uploader is disposed and recreated")]
	[ServerVar]
	public static int tick_uploader_lifetime = 60;
}


using System.Net;
using ConVar;

public static class HttpManager
{
	public static void UpdateMaxConnections()
	{
		ServicePointManager.DefaultConnectionLimit = Server.http_connection_limit;
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Rust;
using UnityEngine;

public static class EntityProfiler
{
	public class EntityCounter
	{
		public string Name;

		public int count;

		public int spawned;

		public int killed;

		public bool queued;

		public EntityCounter(string name)
		{
			Name = name;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Reset()
		{
			spawned = 0;
			killed = 0;
			queued = false;
		}
	}

	public static int mode = 0;

	public static TimeSpan aggregateEntityCountDelay = TimeSpan.FromSeconds(300.0);

	public static int spawned;

	public static int killed;

	public static Dictionary<uint, EntityCounter> counts = new Dictionary<uint, EntityCounter>();

	public static List<EntityCounter> list = new List<EntityCounter>();

	private static DateTime aggregateEntityCountCooldown;

	public static void OnSpawned(BaseNetworkable entity)
	{
		if (!counts.TryGetValue(entity.prefabID, out var value))
		{
			value = new EntityCounter(entity.ShortPrefabName);
			counts[entity.prefabID] = value;
		}
		if (!value.queued)
		{
			list.Add(value);
			value.queued = true;
		}
		value.spawned++;
		value.count++;
	}

	public static void OnKilled(BaseNetworkable entity)
	{
		if (!counts.TryGetValue(entity.prefabID, out var value))
		{
			value = new EntityCounter(entity.ShortPrefabName);
			counts[entity.prefabID] = value;
		}
		if (!value.queued)
		{
			list.Add(value);
			value.queued = true;
		}
		value.killed++;
		value.count--;
	}

	public static void Reset()
	{
		killed = 0;
		spawned = 0;
		foreach (EntityCounter item in list)
		{
			item.Reset();
		}
		list.Clear();
	}

	public static void TrySerializeEntityAggregates(int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader)
	{
		if (mode < 3 || Application.isLoadingSave || aggregateEntityCountCooldown > DateTime.UtcNow)
		{
			return;
		}
		aggregateEntityCountCooldown = DateTime.UtcNow + aggregateEntityCountDelay;
		foreach (EntityCounter value in counts.Values)
		{
			EventRecord eventRecord = EventRecord.CSV();
			eventRecord.AddField("", timestamp).AddField("", ConVar.Server.server_id).AddField("", frameIndex)
				.AddField("", value.Name)
				.AddField("", value.count);
			uploader.Append(eventRecord);
		}
	}

	public static void Serialize(EventRecord record, int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader)
	{
		if (mode == 0)
		{
			return;
		}
		try
		{
			record.AddField("entities_spawned", spawned);
			record.AddField("entities_killed", killed);
			if (mode < 3)
			{
				return;
			}
			foreach (EntityCounter item in list)
			{
				EventRecord eventRecord = EventRecord.CSV();
				eventRecord.AddField("", timestamp).AddField("", ConVar.Server.server_id).AddField("", frameIndex)
					.AddField("", item.Name)
					.AddField("", item.spawned)
					.AddField("", item.killed);
				uploader.Append(eventRecord);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


using System.Runtime.CompilerServices;

public class EntityCounter
{
	public string Name;

	public int count;

	public int spawned;

	public int killed;

	public bool queued;

	public EntityCounter(string name)
	{
		Name = name;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Reset()
	{
		spawned = 0;
		killed = 0;
		queued = false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using UnityEngine;

public static class LagSpikeProfiler
{
	public static bool enabled = false;

	private static List<EventRecord> pendingEvents = new List<EventRecord>();

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		try
		{
			if (!enabled)
			{
				return;
			}
			foreach (EventRecord pendingEvent in pendingEvents)
			{
				pendingEvent.Timestamp = timestamp;
				pendingEvent.AddField("frame_index", frameIndex);
				uploader.Append(pendingEvent);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize lag spikes: " + ex.Message));
		}
	}

	public static void Reset()
	{
		pendingEvents.Clear();
	}

	private static void AddPendingRecord(EventRecord record)
	{
		pendingEvents.Add(record);
		if (pendingEvents.Count > 5000)
		{
			Pool.Free<EventRecord>(ref record);
		}
	}

	public static void RPC(TimeSpan time, Message packet, BaseEntity entity, uint rpcId)
	{
		if (enabled)
		{
			string value = StringPool.Get(rpcId);
			AddPendingRecord(CreateRecord(time, "rpc").AddField("entity", (BaseNetworkable)entity).AddField("rpc", value).AddField("connection_user", ((packet == null) ? ((ulong?)null) : packet.connection?.userid).GetValueOrDefault()));
		}
	}

	public static void ConsoleCommand(TimeSpan time, Message packet, string command)
	{
		if (enabled)
		{
			string value = StringExtensions.Truncate(command, 4096, (string)null);
			AddPendingRecord(CreateRecord(time, "console_command").AddField("command", value).AddField("command_length", command.Length).AddField("connection_user", ((packet == null) ? ((ulong?)null) : packet.connection?.userid).GetValueOrDefault()));
		}
	}

	public static void RconCommand(TimeSpan time, string command)
	{
		if (enabled)
		{
			string value = StringExtensions.Truncate(command, 4096, (string)null);
			AddPendingRecord(CreateRecord(time, "console_command").AddField("command", value).AddField("command_length", command.Length));
		}
	}

	private static EventRecord CreateRecord(TimeSpan duration, string reason)
	{
		return EventRecord.New("lag_spike").AddField("duration", duration).AddField("reason", reason)
			.AddField("server_id", Server.server_id);
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Network;
using Unity.Profiling;
using Unity.Profiling.LowLevel;
using Unity.Profiling.LowLevel.Unsafe;
using UnityEngine;

[Factory("profile")]
public static class RuntimeProfiler
{
	private static class ProfilerCategories
	{
		public static readonly ProfilerCategory VSync = new ProfilerCategory("VSync");

		public static readonly ProfilerCategory PlayerLoop = new ProfilerCategory("PlayerLoop");
	}

	private static int profilingPreset = 0;

	private static int _profilingInterval = 60;

	private static bool _init = false;

	private static Stopwatch serializationTimer = new Stopwatch();

	private static AzureAnalyticsUploader frameProfilingUploader;

	private static AzureAnalyticsUploader entityProfilingUploader;

	private static AzureAnalyticsUploader entityAggregateUploader;

	private static AzureAnalyticsUploader invokeDetailsUploader;

	private static AzureAnalyticsUploader methodUploader;

	private static AzureAnalyticsUploader objectWorkQueueUploader;

	private static AzureAnalyticsUploader packetUploader;

	private static AzureAnalyticsUploader lagSpikeUploader;

	private static AzureAnalyticsUploader rconUploader;

	private static AzureAnalyticsUploader raknetUploader;

	private static AzureAnalyticsUploader poolUploader;

	public static TimeSpan ServerMgr_Update;

	public static TimeSpan Net_Cycle;

	public static TimeSpan Physics_SyncTransforms;

	public static TimeSpan Companion_Tick;

	public static TimeSpan BasePlayer_ServerCycle;

	private static DateTime nextPoolFlush;

	private static readonly ProfilerRecorderOptions PhysicsRecorderOptions = (ProfilerRecorderOptions)8;

	private static readonly List<RustProfilerRecorder> recorders = new List<RustProfilerRecorder>
	{
		new RustProfilerRecorder("cpu_total", ProfilerCategory.Scripts, "CPU Total Frame Time", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("main_thread", ProfilerCategory.Scripts, "CPU Main Thread Frame Time", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("gc_collect_time", ProfilerCategory.Memory, "GC.Collect", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("player_loop", ProfilerCategories.PlayerLoop, "PlayerLoop", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("wait_for_target_fps", ProfilerCategories.VSync, "WaitForTargetFPS", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("ram_app_resident", ProfilerCategory.Memory, "App Resident Memory", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("ram_total_used", ProfilerCategory.Memory, "Total Used Memory", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("ram_gc_used", ProfilerCategory.Memory, "GC Used Memory", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("gc_alloc_bytes", ProfilerCategory.Memory, "GC Allocated In Frame", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("gc_alloc_count", ProfilerCategory.Memory, "GC Allocation In Frame Count", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("active_dynamic_bodies", ProfilerCategory.Physics, "ctive Dynamic Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("active_kinematic_bodies", ProfilerCategory.Physics, "Active Kinematic Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("static_colliders", ProfilerCategory.Physics, "Static Colliders", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("dynamic_bodies", ProfilerCategory.Physics, "Dynamic Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("articulation_bodies", ProfilerCategory.Physics, "Articulation Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("active_constraints", ProfilerCategory.Physics, "Active Constraints", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("overlaps", ProfilerCategory.Physics, "Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("discreet_overlaps", ProfilerCategory.Physics, "Discreet Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("continuous_overlaps", ProfilerCategory.Physics, "Continuous Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("modified_overlaps", ProfilerCategory.Physics, "Modified Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("trigger_overlaps", ProfilerCategory.Physics, "Trigger Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("colliders_synced", ProfilerCategory.Physics, "Colliders Synced", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("rigidbodies_synced", ProfilerCategory.Physics, "Rigidbodies Synced", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("physics_queries", ProfilerCategory.Physics, "Physics Queries", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("broadphase_adds_removes", ProfilerCategory.Physics, "Broadphase Adds/Removes", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("broadphase_adds", ProfilerCategory.Physics, "Broadphase Adds", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("broadphase_removes", ProfilerCategory.Physics, "Broadphase Removes", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("narrowphase_touches", ProfilerCategory.Physics, "Narrowphase Touches", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("narrowphase_new_touches", ProfilerCategory.Physics, "Narrowphase New Touches", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("narrowphase_lost_touches", ProfilerCategory.Physics, "Narrowphase Lost Touches", 1, PhysicsRecorderOptions)
	};

	private static Stopwatch invokeExecutionResetTimer = new Stopwatch();

	[ServerVar]
	public static int rpc_lagspike_threshold
	{
		get
		{
			return (int)RpcWarningThreshold.TotalMilliseconds;
		}
		set
		{
			RpcWarningThreshold = TimeSpan.FromMilliseconds(value);
		}
	}

	[ServerVar]
	public static int command_lagspike_threshold
	{
		get
		{
			return (int)ConsoleCommandWarningThreshold.TotalMilliseconds;
		}
		set
		{
			ConsoleCommandWarningThreshold = TimeSpan.FromMilliseconds(value);
		}
	}

	[ServerVar]
	public static int rcon_lagspike_threshold
	{
		get
		{
			return (int)RconCommandWarningThreshold.TotalMilliseconds;
		}
		set
		{
			RconCommandWarningThreshold = TimeSpan.FromMilliseconds(value);
		}
	}

	public static TimeSpan RpcWarningThreshold { get; private set; } = TimeSpan.FromMilliseconds(40.0);

	public static TimeSpan ConsoleCommandWarningThreshold { get; private set; } = TimeSpan.FromMilliseconds(40.0);

	public static TimeSpan RconCommandWarningThreshold { get; private set; } = TimeSpan.FromMilliseconds(40.0);

	[ServerVar(Saved = true, Help = "0 = off, 1 = basic, 2 = everything. This will reset all profiling convars, however they can be modified afterwards")]
	public static int runtime_profiling
	{
		get
		{
			return profilingPreset;
		}
		set
		{
			profilingPreset = Mathf.Max(0, value);
			OnProfilingPresetChanged();
		}
	}

	[ServerVar(Saved = true, Help = "Enable to allow runtime profiling to persist across restarts")]
	public static bool runtime_profiling_persist { get; set; } = false;

	[ServerVar(Help = "Record inbound RPC & ConsoleCommands that cause lag spikes")]
	public static bool profiling_lagspikes
	{
		get
		{
			return LagSpikeProfiler.enabled;
		}
		set
		{
			LagSpikeProfiler.enabled = value;
		}
	}

	[ServerVar(Help = "Record type of packets inbound/outbound per frame")]
	public static bool profiling_packets
	{
		get
		{
			return PacketProfiler.enabled;
		}
		set
		{
			PacketProfiler.enabled = value;
		}
	}

	[ServerVar(Help = "0 = off, 1 = stats per frame, 2 = stats per method")]
	public static int profiling_invokes
	{
		get
		{
			return InvokeProfiler.update.mode;
		}
		set
		{
			InvokeProfiler.update.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "0 = off, 1 = stats per frame, 2 = stats per method")]
	public static int profiling_fixed_invokes
	{
		get
		{
			return InvokeProfiler.fixedUpdate.mode;
		}
		set
		{
			InvokeProfiler.fixedUpdate.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "0 = off, 1 = spawn/kill, 2 = spawn/kill per entity, 3 = count every '5 min'")]
	public static int profiling_entities
	{
		get
		{
			return EntityProfiler.mode;
		}
		set
		{
			EntityProfiler.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "How frequently to count all entities across the server")]
	public static int profiling_entity_count_interval
	{
		get
		{
			return (int)EntityProfiler.aggregateEntityCountDelay.TotalSeconds;
		}
		set
		{
			EntityProfiler.aggregateEntityCountDelay = TimeSpan.FromSeconds(Mathf.Max(60, value));
		}
	}

	[ServerVar(Help = "Record execution time of ObjectWorkQueues per frame")]
	public static bool profiling_work_queue
	{
		get
		{
			return WorkQueueProfiler.enabled;
		}
		set
		{
			WorkQueueProfiler.enabled = value;
		}
	}

	[ServerVar(Help = "0 = off, 1 = count per frame, 2 = connection attempts, 3 = messages")]
	public static int profiling_rcon
	{
		get
		{
			return RconProfiler.mode;
		}
		set
		{
			RconProfiler.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "Clamp the length of logged RCON messages to prevent the profiler from being flooded with large messages")]
	public static int profiling_rcon_message_length
	{
		get
		{
			return RconProfiler.ClampedMessageLength;
		}
		set
		{
			RconProfiler.ClampedMessageLength = Mathf.Max(64, value);
		}
	}

	[ServerVar]
	public static int runtime_profiling_interval
	{
		get
		{
			return _profilingInterval;
		}
		set
		{
			_profilingInterval = Mathf.Clamp(value, 60, 1800);
		}
	}

	[ServerVar(Help = "Should analytics bulk uploaders use pooling")]
	public static bool runtime_profiling_uploader_pooling
	{
		get
		{
			return AzureAnalyticsUploader.UsePooling;
		}
		set
		{
			AzureAnalyticsUploader.UsePooling = value;
		}
	}

	[ServerVar(Help = "Raknet statistics, 0 = off, 2 = per connection")]
	public static int profiling_ping
	{
		get
		{
			return PlayerNetworkingProfiler.level;
		}
		set
		{
			PlayerNetworkingProfiler.level = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "0 = off, 1 = flush every 5 minutes")]
	public static int runtime_profiling_pooling { get; set; }

	[ServerVar(Help = "How often to flush raknet stats per second")]
	public static float profiling_ping_interval
	{
		get
		{
			return (float)PlayerNetworkingProfiler.MinFlushInterval.TotalSeconds;
		}
		set
		{
			PlayerNetworkingProfiler.MinFlushInterval = TimeSpan.FromSeconds(value);
		}
	}

	[ServerVar]
	public static int profiling_ping_per_frame
	{
		get
		{
			return PlayerNetworkingProfiler.ConnectionsPerFrame;
		}
		set
		{
			PlayerNetworkingProfiler.ConnectionsPerFrame = Mathf.Max(1, value);
		}
	}

	[ServerVar(Help = "How often to flush pooling stats in seconds")]
	public static int runtime_profiling_pool_flush_interval { get; set; } = 300;

	[ClientVar(ClientAdmin = true)]
	[ServerVar]
	public static void dump_profile_recorders(Arg arg)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		List<ProfilerRecorderHandle> list = new List<ProfilerRecorderHandle>();
		ProfilerRecorderHandle.GetAvailable(list);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Name,Category,UnitType,Flags");
		foreach (ProfilerRecorderHandle item in list)
		{
			ProfilerRecorderDescription description = ProfilerRecorderHandle.GetDescription(item);
			StringBuilder stringBuilder2 = stringBuilder.Append(((ProfilerRecorderDescription)(ref description)).Name).Append(",");
			ProfilerCategory category = ((ProfilerRecorderDescription)(ref description)).Category;
			StringBuilder stringBuilder3 = stringBuilder2.Append(((object)(ProfilerCategory)(ref category)/*cast due to .constrained prefix*/).ToString()).Append(",");
			ProfilerMarkerDataUnit unitType = ((ProfilerRecorderDescription)(ref description)).UnitType;
			StringBuilder stringBuilder4 = stringBuilder3.Append(((object)(ProfilerMarkerDataUnit)(ref unitType)/*cast due to .constrained prefix*/).ToString()).Append(",");
			MarkerFlags flags = ((ProfilerRecorderDescription)(ref description)).Flags;
			stringBuilder4.Append(((object)(MarkerFlags)(ref flags)/*cast due to .constrained prefix*/).ToString()).AppendLine();
		}
		string contents = stringBuilder.ToString();
		File.WriteAllText("profiler_recorders.csv", contents);
		arg.ReplyWith($"Successfully dumped '{list.Count}' markers");
	}

	public static void Disable()
	{
		runtime_profiling = 0;
	}

	private static void Start()
	{
		ResetAllMeasurements();
	}

	private static void OnProfilingPresetChanged()
	{
		profiling_lagspikes = false;
		profiling_packets = false;
		profiling_invokes = 0;
		profiling_fixed_invokes = 0;
		profiling_entities = 0;
		profiling_work_queue = false;
		profiling_rcon = 0;
		if (profilingPreset >= 1)
		{
			profiling_entities = 1;
			profiling_lagspikes = true;
			profiling_rcon = 1;
			runtime_profiling_pooling = 1;
		}
		if (profilingPreset >= 2)
		{
			profiling_packets = true;
			profiling_invokes = 2;
			profiling_fixed_invokes = 2;
			profiling_entities = 3;
			profiling_work_queue = true;
			profiling_rcon = 3;
			profiling_ping = 2;
		}
	}

	public static void Update()
	{
		if (!Bootstrap.bootstrapInitRun)
		{
			return;
		}
		if (runtime_profiling == 0)
		{
			_init = false;
		}
		else if (!string.IsNullOrEmpty(Analytics.BulkUploadConnectionString) || !string.IsNullOrEmpty(Analytics.BulkContainerUrl))
		{
			if (!_init)
			{
				Start();
				_init = true;
			}
			EnsureUploadersCreated();
			CollectLastFrameStats();
		}
	}

	private static void EnsureUploadersCreated()
	{
		if (frameProfilingUploader.NeedsCreation())
		{
			frameProfilingUploader = AzureAnalyticsUploader.Create("frame_profiling", TimeSpan.FromSeconds(runtime_profiling_interval));
		}
		if (entityProfilingUploader.NeedsCreation())
		{
			entityProfilingUploader = AzureAnalyticsUploader.Create("entity_profiling", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (entityAggregateUploader.NeedsCreation())
		{
			entityAggregateUploader = AzureAnalyticsUploader.Create("entity_aggregates", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (invokeDetailsUploader.NeedsCreation())
		{
			invokeDetailsUploader = AzureAnalyticsUploader.Create("invoke_breakdown", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (methodUploader.NeedsCreation())
		{
			methodUploader = AzureAnalyticsUploader.Create("unity_methods", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (objectWorkQueueUploader.NeedsCreation())
		{
			objectWorkQueueUploader = AzureAnalyticsUploader.Create("object_work_queue", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (packetUploader.NeedsCreation())
		{
			packetUploader = AzureAnalyticsUploader.Create("packets_per_type", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (lagSpikeUploader.NeedsCreation())
		{
			lagSpikeUploader = AzureAnalyticsUploader.Create("lag_spikes", TimeSpan.FromSeconds(runtime_profiling_interval));
			lagSpikeUploader.UseJsonDataObject = true;
		}
		if (rconUploader.NeedsCreation())
		{
			rconUploader = AzureAnalyticsUploader.Create("rcon_profiling", TimeSpan.FromSeconds(runtime_profiling_interval));
		}
		if (raknetUploader.NeedsCreation())
		{
			raknetUploader = AzureAnalyticsUploader.Create("raknet", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (poolUploader.NeedsCreation())
		{
			poolUploader = AzureAnalyticsUploader.Create("pool_profiling", TimeSpan.FromSeconds(runtime_profiling_interval));
			poolUploader.UseJsonDataObject = true;
		}
	}

	private static void CollectLastFrameStats()
	{
		WriteFrameData(Time.frameCount - 1);
	}

	private static void WriteFrameData(int frameIndex)
	{
		serializationTimer.Restart();
		RconProfilerStats currentStats = RconProfiler.GetCurrentStats(true);
		DateTime utcNow = DateTime.UtcNow;
		EventRecord eventRecord = EventRecord.New("frame_profiling").AddField("frame_index", frameIndex);
		eventRecord.Timestamp = utcNow;
		LagSpikeProfiler.Serialize(lagSpikeUploader, frameIndex, utcNow);
		SerializeCommon(eventRecord, currentStats);
		SerializeNetworking(eventRecord, frameIndex, utcNow);
		SerializeInvokes(eventRecord);
		SerializeInvokeExecutionTime(InvokeProfiler.update, invokeDetailsUploader, frameIndex, utcNow);
		SerializeInvokeExecutionTime(InvokeProfiler.fixedUpdate, invokeDetailsUploader, frameIndex, utcNow);
		SerializeProfilingSamples(eventRecord);
		EntityProfiler.Serialize(eventRecord, frameIndex, utcNow, entityProfilingUploader);
		EntityProfiler.TrySerializeEntityAggregates(frameIndex, utcNow, entityAggregateUploader);
		WorkQueueProfiler.Serialize(objectWorkQueueUploader, frameIndex, utcNow);
		PlayerNetworkingProfiler.Serialize(raknetUploader, frameIndex, utcNow);
		SerializeRconEvents(rconUploader, frameIndex, utcNow, currentStats);
		SerializeMemoryPool(poolUploader, frameIndex, utcNow);
		ResetAllMeasurements();
		Pool.Free<RconProfilerStats>(ref currentStats);
		eventRecord.AddField("serialization_time", serializationTimer.Elapsed);
		frameProfilingUploader.Append(eventRecord);
	}

	private static void ResetAllMeasurements()
	{
		LagSpikeProfiler.Reset();
		PacketProfiler.Reset();
		InvokeProfiler update = InvokeProfiler.update;
		if (update != null)
		{
			update.Reset();
		}
		InvokeProfiler fixedUpdate = InvokeProfiler.fixedUpdate;
		if (fixedUpdate != null)
		{
			fixedUpdate.Reset();
		}
		EntityProfiler.Reset();
		WorkQueueProfiler.Reset();
		EntityProfiler.Reset();
		RconProfiler.Reset();
	}

	private static void SerializeCommon(EventRecord record, RconProfilerStats rconStats)
	{
		try
		{
			string hostname = Server.hostname;
			PerformanceSamplePoint lastFrame = PerformanceMetrics.LastFrame;
			record.AddField("server_id", Server.server_id).AddField("hostname", hostname).AddField("unity_time", Time.time)
				.AddField("unity_realtime", Time.realtimeSinceStartup)
				.AddField("garbage_collects", System.GC.CollectionCount(0))
				.AddField("ram_get_total_memory", System.GC.GetTotalMemory(forceFullCollection: false))
				.AddField("players_connected", BasePlayer.activePlayerList.Count)
				.AddField("players_sleeping", BasePlayer.sleepingPlayerList.Count)
				.AddField("connection_count", Net.sv.connections.Count)
				.AddField("entity_count", BaseNetworkable.serverEntities.Count)
				.AddField("servermgr_update", ServerMgr_Update)
				.AddField("net_cycle", Net_Cycle)
				.AddField("physics_sync_time", Physics_SyncTransforms)
				.AddField("companion_tick", Companion_Tick)
				.AddField("baseplayer_tick", BasePlayer_ServerCycle)
				.AddField("fixed_update_scripts", lastFrame.FixedUpdate)
				.AddField("update_scripts", lastFrame.Update)
				.AddField("late_update_scripts", lastFrame.LateUpdate)
				.AddField("physics_update", lastFrame.PhysicsUpdate)
				.AddField("rcon_execution_time", RconProfiler.ExecutionTime)
				.AddField("rcon_new_connections", rconStats.NewConnectionCount)
				.AddField("rcon_failed_connections", rconStats.FailedConnectionCount)
				.AddField("rcon_connection_count", rconStats.ConnectionCount)
				.AddField("rcon_message_count", rconStats.MessageCount)
				.AddField("rcon_messages_length", rconStats.MessageLengthSum)
				.AddField("rcon_errors", rconStats.ErrorCount);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize common data: " + ex.Message));
		}
	}

	private static void SerializeNetworking(EventRecord frameRecord, int frameIndex, DateTime timestamp)
	{
		if (!PacketProfiler.enabled)
		{
			return;
		}
		try
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			for (int i = 0; i < 27; i++)
			{
				int num6 = PacketProfiler.inboundCount[i];
				int num7 = PacketProfiler.inboundBytes[i];
				int num8 = PacketProfiler.outboundCount[i];
				int num9 = PacketProfiler.outboundSum[i];
				int num10 = PacketProfiler.outboundBytes[i];
				num += num6;
				num2 += num7;
				num3 += num8;
				num4 += num9;
				num5 += num10;
				if (num6 > 0 || num8 > 0)
				{
					EventRecord eventRecord = EventRecord.CSV();
					eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", AnalyticsKeys.MessageType[i])
						.AddField("", num6)
						.AddField("", num7)
						.AddField("", num8)
						.AddField("", num9)
						.AddField("", num10)
						.AddField("", Server.server_id);
					packetUploader.Append(eventRecord);
				}
			}
			frameRecord.AddField("inbound_count_total", num);
			frameRecord.AddField("inbound_bytes_total", num2);
			frameRecord.AddField("outbound_count_total", num3);
			frameRecord.AddField("outbound_sum_total", num4);
			frameRecord.AddField("outbound_bytes_total", num5);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize networking data: " + ex.Message));
		}
	}

	private static void SerializeInvokes(EventRecord record)
	{
		try
		{
			if (InvokeProfiler.update.mode != 0)
			{
				record.AddField("invokes_elapsed_time", InvokeProfiler.update.elapsedTime).AddField("invokes_executed", InvokeProfiler.update.executedCount).AddField("invokes_count", InvokeProfiler.update.tickCount)
					.AddField("invokes_added", InvokeProfiler.update.addCount)
					.AddField("invokes_removed", InvokeProfiler.update.deletedCount);
			}
			if (InvokeProfiler.fixedUpdate.mode != 0)
			{
				record.AddField("invokes_fixed_elapsed_time", InvokeProfiler.fixedUpdate.elapsedTime).AddField("invokes_fixed_executed", InvokeProfiler.fixedUpdate.executedCount).AddField("invokes_fixed_count", InvokeProfiler.fixedUpdate.tickCount)
					.AddField("invokes_fixed_added", InvokeProfiler.fixedUpdate.addCount)
					.AddField("invokes_fixed_removed", InvokeProfiler.fixedUpdate.deletedCount);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize invoke data: " + ex.Message));
		}
	}

	private static void SerializeInvokeExecutionTime(InvokeProfiler profiler, AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, bool reset = true)
	{
		if (profiler.mode < 2)
		{
			return;
		}
		try
		{
			invokeExecutionResetTimer.Restart();
			foreach (InvokeTrackingData trackingData in profiler.trackingDataList)
			{
				if (trackingData.Calls != 0)
				{
					EventRecord eventRecord = EventRecord.CSV();
					eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", profiler.Name)
						.AddField("", trackingData.TypeName)
						.AddField("", trackingData.Key.MethodName)
						.AddField("", trackingData.ExecutionTime)
						.AddField("", trackingData.Calls)
						.AddField("", Server.server_id);
					uploader.Append(eventRecord);
					if (reset)
					{
						trackingData.Reset();
					}
				}
			}
			invokeExecutionResetTimer.Stop();
			EventRecord eventRecord2 = EventRecord.CSV();
			eventRecord2.AddField("", frameIndex).AddField("", timestamp).AddField("", "Update")
				.AddField("", "RuntimeProfiler")
				.AddField("", "Invoke_Execution_Serialization")
				.AddField("", invokeExecutionResetTimer.Elapsed)
				.AddField("", 1)
				.AddField("", Server.server_id);
			uploader.Append(eventRecord2);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize '" + profiler.Name + "' invoke execution time: " + ex.Message));
		}
	}

	private static void SerializeProfilingSamples(EventRecord record)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			foreach (RustProfilerRecorder recorder2 in recorders)
			{
				string columnName = recorder2.ColumnName;
				ProfilerRecorder recorder = recorder2.Recorder;
				record.AddField(columnName, ((ProfilerRecorder)(ref recorder)).LastValue);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize profiling samples: " + ex.Message));
		}
	}

	private static void SerializeRconEvents(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, RconProfilerStats rconStats)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		foreach (RconConnectionAttempt connectionAttempt in rconStats.ConnectionAttempts)
		{
			EventRecord record = CreatePoint("rcon_connection_attempt", frameIndex, timestamp).AddField("ip", connectionAttempt.IP).AddField("port", connectionAttempt.Port).AddField("connection_id", connectionAttempt.ConnectionId)
				.AddField("password", connectionAttempt.PasswordAttempt)
				.AddField("success", connectionAttempt.Success);
			uploader.Append(record);
		}
		foreach (RconMessageStats message in rconStats.Messages)
		{
			EventRecord record2 = CreatePoint("rcon_message", frameIndex, timestamp).AddField("ip", message.IP).AddField("port", message.Port).AddField("connection_id", message.ConnectionId)
				.AddField("message", message.Message)
				.AddField("message_length", message.MessageLength);
			uploader.Append(record2);
		}
		foreach (RconDisconnects disconnect in rconStats.Disconnects)
		{
			EventRecord record3 = CreatePoint("rcon_disconnect", frameIndex, timestamp).AddField("ip", disconnect.IP).AddField("port", disconnect.Port).AddField("connection_id", disconnect.ConnectionId);
			uploader.Append(record3);
		}
	}

	private static void SerializeMemoryPool(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (runtime_profiling_pooling == 0 || !(timestamp > nextPoolFlush))
		{
			return;
		}
		nextPoolFlush = timestamp.AddSeconds(runtime_profiling_pool_flush_interval);
		foreach (KeyValuePair<Type, IPoolCollection> item in Pool.Directory)
		{
			IPoolCollection value = item.Value;
			string name = TypeNameCache.GetName(item.Key);
			EventRecord record = CreatePoint("pool_facepunch", frameIndex, timestamp).AddField("type_name", name).AddField("capacity", value.ItemsCapacity).AddField("stack", value.ItemsInStack)
				.AddField("used", value.ItemsInUse)
				.AddField("created", value.ItemsCreated)
				.AddField("taken", value.ItemsTaken)
				.AddField("spilled", value.ItemsSpilled)
				.AddField("max_used", value.MaxItemsInUse);
			uploader.Append(record);
		}
		ArrayPool<byte> arrayPool = BaseNetwork.ArrayPool;
		ConcurrentQueue<byte[]>[] buffer = arrayPool.GetBuffer();
		for (int i = 0; i < buffer.Length; i++)
		{
			ConcurrentQueue<byte[]> concurrentQueue = buffer[i];
			EventRecord record2 = CreatePoint("pool_networking", frameIndex, timestamp).AddField("size", arrayPool.IndexToSize(i)).AddField("amount", concurrentQueue.Count);
			uploader.Append(record2);
		}
	}

	private static EventRecord CreatePoint(string type, int frameIndex, DateTime timestamp)
	{
		return EventRecord.New(type).AddField("frame_index", frameIndex).SetTimestamp(timestamp)
			.AddField("server_id", Server.server_id);
	}
}


using Unity.Profiling;

private static class ProfilerCategories
{
	public static readonly ProfilerCategory VSync = new ProfilerCategory("VSync");

	public static readonly ProfilerCategory PlayerLoop = new ProfilerCategory("PlayerLoop");
}


using Unity.Profiling;

public struct RustProfilerRecorder
{
	public string ColumnName;

	public ProfilerRecorder Recorder;

	public RustProfilerRecorder(string column, ProfilerCategory category, string sample, int sampleCount = 1, ProfilerRecorderOptions options = 24)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		ColumnName = column;
		Recorder = ProfilerRecorder.StartNew(category, sample, sampleCount, options);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Unity.Profiling;
using Unity.Profiling.LowLevel.Unsafe;
using UnityEngine;

public static class UnityProfiler
{
	private struct RecorderInfo
	{
		public string MethodName;

		public ProfilerRecorder Recorder;
	}

	private static List<RecorderInfo> ActiveRecorders = new List<RecorderInfo>();

	private static bool _enabled;

	public static bool enabled
	{
		get
		{
			return _enabled;
		}
		set
		{
			SetEnabled(value);
		}
	}

	private static void SetEnabled(bool state)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Invalid comparison between Unknown and I4
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		_enabled = state;
		Unload();
		if (!state)
		{
			return;
		}
		List<ProfilerRecorderHandle> list = new List<ProfilerRecorderHandle>();
		ProfilerRecorderHandle.GetAvailable(list);
		foreach (ProfilerRecorderDescription item2 in list.Select((ProfilerRecorderHandle x) => ProfilerRecorderHandle.GetDescription(x)).ToList())
		{
			ProfilerRecorderDescription current = item2;
			if ((int)((ProfilerRecorderDescription)(ref current)).UnitType == 1 && ProfilerCategory.op_Implicit(((ProfilerRecorderDescription)(ref current)).Category) == ProfilerCategory.op_Implicit(ProfilerCategory.Scripts))
			{
				ProfilerRecorder recorder = ProfilerRecorder.StartNew(((ProfilerRecorderDescription)(ref current)).Category, ((ProfilerRecorderDescription)(ref current)).Name, 2, (ProfilerRecorderOptions)24);
				RecorderInfo recorderInfo = default(RecorderInfo);
				recorderInfo.MethodName = ((ProfilerRecorderDescription)(ref current)).Name;
				recorderInfo.Recorder = recorder;
				RecorderInfo item = recorderInfo;
				ActiveRecorders.Add(item);
			}
		}
	}

	public static void Unload()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		foreach (RecorderInfo activeRecorder in ActiveRecorders)
		{
			ProfilerRecorder recorder = activeRecorder.Recorder;
			((ProfilerRecorder)(ref recorder)).Dispose();
		}
		ActiveRecorders.Clear();
	}

	public static void Serialize(AzureAnalyticsUploader uploader, DateTime timestamp, int frameIndex)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (!enabled)
		{
			return;
		}
		try
		{
			foreach (RecorderInfo activeRecorder in ActiveRecorders)
			{
				ProfilerRecorder recorder = activeRecorder.Recorder;
				if (((ProfilerRecorder)(ref recorder)).LastValue != 0L)
				{
					EventRecord eventRecord = EventRecord.CSV();
					EventRecord eventRecord2 = eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", activeRecorder.MethodName);
					recorder = activeRecorder.Recorder;
					eventRecord2.AddField("", ((ProfilerRecorder)(ref recorder)).LastValue).AddField("", Server.server_id);
					uploader.Append(eventRecord);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize profiler data: " + ex.Message));
		}
	}
}


using Unity.Profiling;

private struct RecorderInfo
{
	public string MethodName;

	public ProfilerRecorder Recorder;
}


using System;
using ConVar;
using Facepunch.Rust;
using UnityEngine;

public static class WorkQueueProfiler
{
	public static bool enabled;

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (!enabled)
		{
			return;
		}
		try
		{
			foreach (ObjectWorkQueue item in ObjectWorkQueue.All)
			{
				if (item.LastProcessedCount != 0)
				{
					EventRecord eventRecord = EventRecord.CSV();
					eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", item.Name)
						.AddField("", item.LastQueueLength)
						.AddField("", item.LastExecutionTime)
						.AddField("", item.LastProcessedCount)
						.AddField("", Server.server_id);
					uploader.Append(eventRecord);
				}
			}
			foreach (PersistentObjectWorkQueue item2 in PersistentObjectWorkQueue.All)
			{
				if (item2.ListLength != 0)
				{
					EventRecord eventRecord2 = EventRecord.CSV();
					eventRecord2.AddField("", frameIndex).AddField("", timestamp).AddField("", item2.Name)
						.AddField("", item2.ListLength)
						.AddField("", item2.LastExecutionTime)
						.AddField("", item2.LastProcessedCount)
						.AddField("", Server.server_id);
					uploader.Append(eventRecord2);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize work queues: " + ex.Message));
		}
	}

	public static void Reset()
	{
	}
}


using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;

[Factory("ai")]
public class AI : ConsoleSystem
{
	[ReplicatedVar(Saved = true)]
	public static bool allowdesigning = true;

	public const float showCommandsRefreshInterval = 0.1f;

	[ServerVar]
	public static bool think = true;

	[ServerVar]
	public static bool navthink = true;

	[ServerVar]
	public static bool ignoreplayers = false;

	[ServerVar]
	public static bool effectaiweapons = false;

	[ServerVar]
	public static bool groups = true;

	[ServerVar]
	public static bool spliceupdates = true;

	[ServerVar]
	public static bool setdestinationsamplenavmesh = true;

	[ServerVar]
	public static bool usecalculatepath = true;

	[ServerVar]
	public static bool usesetdestinationfallback = true;

	[ServerVar]
	public static bool npcswimming = true;

	[ServerVar]
	public static bool accuratevisiondistance = true;

	[ServerVar]
	public static bool move = true;

	[ServerVar]
	public static bool usegrid = true;

	[ServerVar]
	public static bool sleepwake = true;

	[ServerVar]
	public static float sensetime = 1f;

	[ServerVar]
	public static float frametime = 5f;

	[ServerVar]
	public static int ocean_patrol_path_iterations = 100000;

	[ServerVar(Help = "If npc_enable is set to false then npcs won't spawn. (default: true)")]
	public static bool npc_enable = true;

	[ServerVar(Help = "npc_max_population_military_tunnels defines the size of the npc population at military tunnels. (default: 3)")]
	public static int npc_max_population_military_tunnels = 3;

	[ServerVar(Help = "npc_spawn_per_tick_max_military_tunnels defines how many can maximum spawn at once at military tunnels. (default: 1)")]
	public static int npc_spawn_per_tick_max_military_tunnels = 1;

	[ServerVar(Help = "npc_spawn_per_tick_min_military_tunnels defineshow many will minimum spawn at once at military tunnels. (default: 1)")]
	public static int npc_spawn_per_tick_min_military_tunnels = 1;

	[ServerVar(Help = "npc_respawn_delay_max_military_tunnels defines the maximum delay between spawn ticks at military tunnels. (default: 1920)")]
	public static float npc_respawn_delay_max_military_tunnels = 1920f;

	[ServerVar(Help = "npc_respawn_delay_min_military_tunnels defines the minimum delay between spawn ticks at military tunnels. (default: 480)")]
	public static float npc_respawn_delay_min_military_tunnels = 480f;

	[ServerVar(Help = "npc_valid_aim_cone defines how close their aim needs to be on target in order to fire. (default: 0.8)")]
	public static float npc_valid_aim_cone = 0.8f;

	[ServerVar(Help = "npc_valid_mounted_aim_cone defines how close their aim needs to be on target in order to fire while mounted. (default: 0.92)")]
	public static float npc_valid_mounted_aim_cone = 0.92f;

	[ServerVar(Help = "npc_cover_compromised_cooldown defines how long a cover point is marked as compromised before it's cleared again for selection. (default: 10)")]
	public static float npc_cover_compromised_cooldown = 10f;

	[ServerVar(Help = "If npc_cover_use_path_distance is set to true then npcs will look at the distance between the cover point and their target using the path between the two, rather than the straight-line distance.")]
	public static bool npc_cover_use_path_distance = true;

	[ServerVar(Help = "npc_cover_path_vs_straight_dist_max_diff defines what the maximum difference between straight-line distance and path distance can be when evaluating cover points. (default: 2)")]
	public static float npc_cover_path_vs_straight_dist_max_diff = 2f;

	[ServerVar(Help = "npc_door_trigger_size defines the size of the trigger box on doors that opens the door as npcs walk close to it (default: 1.5)")]
	public static float npc_door_trigger_size = 1.5f;

	[ServerVar(Help = "npc_patrol_point_cooldown defines the cooldown time on a patrol point until it's available again (default: 5)")]
	public static float npc_patrol_point_cooldown = 5f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the walk state, and should be a number between 0 and 1. (Default: 0.18)")]
	public static float npc_speed_walk = 0.18f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the run state, and should be a number between 0 and 1. (Default: 0.4)")]
	public static float npc_speed_run = 0.4f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the sprint state, and should be a number between 0 and 1. (Default: 1.0)")]
	public static float npc_speed_sprint = 1f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the crouched walk state, and should be a number between 0 and 1. (Default: 0.1)")]
	public static float npc_speed_crouch_walk = 0.1f;

	[ServerVar(Help = "npc_speed_crouch_run define the speed of an npc when in the crouched run state, and should be a number between 0 and 1. (Default: 0.25)")]
	public static float npc_speed_crouch_run = 0.25f;

	[ServerVar(Help = "npc_alertness_drain_rate define the rate at which we drain the alertness level of an NPC when there are no enemies in sight. (Default: 0.01)")]
	public static float npc_alertness_drain_rate = 0.01f;

	[ServerVar(Help = "npc_alertness_zero_detection_mod define the threshold of visibility required to detect an enemy when alertness is zero. (Default: 0.5)")]
	public static float npc_alertness_zero_detection_mod = 0.5f;

	[ServerVar(Help = "defines the chance for scientists to spawn at NPC junkpiles. (Default: 0.1)")]
	public static float npc_junkpilespawn_chance = 0.07f;

	[ServerVar(Help = "npc_junkpile_dist_aggro_gate define at what range (or closer) a junkpile scientist will get aggressive. (Default: 8)")]
	public static float npc_junkpile_dist_aggro_gate = 8f;

	[ServerVar(Help = "npc_max_junkpile_count define how many npcs can spawn into the world at junkpiles at the same time (does not include monuments) (Default: 30)")]
	public static int npc_max_junkpile_count = 30;

	[ServerVar(Help = "If npc_families_no_hurt is true, npcs of the same family won't be able to hurt each other. (default: true)")]
	public static bool npc_families_no_hurt = true;

	[ServerVar(Help = "If npc_ignore_chairs is true, npcs won't care about seeking out and sitting in chairs. (default: true)")]
	public static bool npc_ignore_chairs = true;

	[ServerVar(Help = "The rate at which we tick the sensory system. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 5)")]
	public static float npc_sensory_system_tick_rate_multiplier = 5f;

	[ServerVar(Help = "The rate at which we gather information about available cover points. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 20)")]
	public static float npc_cover_info_tick_rate_multiplier = 20f;

	[ServerVar(Help = "The rate at which we tick the reasoning system. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 1)")]
	public static float npc_reasoning_system_tick_rate_multiplier = 1f;

	[ServerVar]
	public static bool npc_check_spawner_is_on_navmesh = true;

	[ServerVar(Help = "If animal_ignore_food is true, animals will not sense food sources or interact with them (server optimization). (default: true)")]
	public static bool animal_ignore_food = true;

	[ServerVar(Help = "The modifier by which a silencer reduce the noise that a gun makes when shot. (Default: 0.15)")]
	public static float npc_gun_noise_silencer_modifier = 0.15f;

	[ServerVar(Help = "If nav_carve_use_building_optimization is true, we attempt to reduce the amount of navmesh carves for a building. (default: false)")]
	public static bool nav_carve_use_building_optimization = false;

	[ServerVar(Help = "The minimum number of building blocks a building needs to consist of for this optimization to be applied. (default: 25)")]
	public static int nav_carve_min_building_blocks_to_apply_optimization = 25;

	[ServerVar(Help = "The minimum size we allow a carving volume to be. (default: 2)")]
	public static float nav_carve_min_base_size = 2f;

	[ServerVar(Help = "The size multiplier applied to the size of the carve volume. The smaller the value, the tighter the skirt around foundation edges, but too small and animals can attack through walls. (default: 4)")]
	public static float nav_carve_size_multiplier = 4f;

	[ServerVar(Help = "The height of the carve volume. (default: 2)")]
	public static float nav_carve_height = 2f;

	[ServerVar(Help = "If npc_only_hurt_active_target_in_safezone is true, npcs won't any player other than their actively targeted player when in a safe zone. (default: true)")]
	public static bool npc_only_hurt_active_target_in_safezone = true;

	[ServerVar(Help = "If npc_use_new_aim_system is true, npcs will miss on purpose on occasion, where the old system would randomize aim cone. (default: true)")]
	public static bool npc_use_new_aim_system = true;

	[ServerVar(Help = "If npc_use_thrown_weapons is true, npcs will throw grenades, etc. This is an experimental feature. (default: true)")]
	public static bool npc_use_thrown_weapons = true;

	[ServerVar(Help = "This is multiplied with the max roam range stat of an NPC to determine how far from its spawn point the NPC is allowed to roam. (default: 3)")]
	public static float npc_max_roam_multiplier = 3f;

	[ServerVar(Help = "This is multiplied with the current alertness (0-10) to decide how long it will take for the NPC to deliberately miss again. (default: 0.33)")]
	public static float npc_alertness_to_aim_modifier = 0.5f;

	[ServerVar(Help = "The time it takes for the NPC to deliberately miss to the time the NPC tries to hit its target. (default: 1.5)")]
	public static float npc_deliberate_miss_to_hit_alignment_time = 1.5f;

	[ServerVar(Help = "The offset with which the NPC will maximum miss the target. (default: 1.25)")]
	public static float npc_deliberate_miss_offset_multiplier = 1.25f;

	[ServerVar(Help = "The percentage away from a maximum miss the randomizer is allowed to travel when shooting to deliberately hit the target (we don't want perfect hits with every shot). (default: 0.85f)")]
	public static float npc_deliberate_hit_randomizer = 0.85f;

	[ServerVar(Help = "Baseline damage modifier for the new HTN Player NPCs to nerf their damage compared to the old NPCs. (default: 1.15f)")]
	public static float npc_htn_player_base_damage_modifier = 1.15f;

	[ServerVar(Help = "Spawn NPCs on the Cargo Ship. (default: true)")]
	public static bool npc_spawn_on_cargo_ship = true;

	[ServerVar(Help = "Spawn NPCs on junkpiles (default: true)")]
	public static bool npc_spawn_on_junkpile = true;

	[ServerVar(Help = "Do any kind of scientists spawn on the map (default: true)")]
	public static bool scientist_spawners_enabled = true;

	[ServerVar(Help = "npc_htn_player_frustration_threshold defines where the frustration threshold for NPCs go, where they have the opportunity to change to a more aggressive tactic. (default: 3)")]
	public static int npc_htn_player_frustration_threshold = 3;

	[ServerVar]
	public static bool logIssues = false;

	[ServerVar]
	public static float tickrate = 5f;

	[ServerVar]
	public static void showState(Arg arg)
	{
		arg.Player()?.ToggleShowFSMStateDebugInfo();
	}

	[ServerVar]
	public static void sleepwakestats(Arg args)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			if (!((Object)(object)zone == (Object)null) && zone.ShouldSleepAI)
			{
				num++;
				if (zone.Sleeping)
				{
					num2++;
					num3 += zone.SleepingCount;
				}
			}
		}
		args.ReplyWith("Sleeping AIZs: " + num2 + " / " + num + ". Total sleeping ents: " + num3);
	}

	[ServerVar]
	public static void wakesleepingai(Arg args)
	{
		int num = 0;
		int num2 = 0;
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			if (!((Object)(object)zone == (Object)null) && zone.ShouldSleepAI && zone.Sleeping)
			{
				num++;
				num2 += zone.SleepingCount;
				zone.WakeAI();
			}
		}
		args.ReplyWith("Woke " + num + " sleeping AIZs containing " + num2 + " sleeping entities.");
	}

	[ServerVar]
	public static void brainstats(Arg args)
	{
		int num = BaseEntity.Util.FindAll<BaseNPC2>().Length;
		int num2 = AnimalBrain.Count + ScientistBrain.Count + PetBrain.Count;
		args.ReplyWith($"Animal: {AnimalBrain.Count}. Scientist: {ScientistBrain.Count}. Pet: {PetBrain.Count}. NPC2:{num}. Total: {num2}");
	}

	[ServerVar]
	public static void aizonestats(Arg args)
	{
		args.ReplyWith("AIInformationZone count: " + AIInformationZone.zones.Count);
	}

	[ServerVar]
	public static void killscientists(Arg args)
	{
		ScientistNPC[] array = BaseEntity.Util.FindAll<ScientistNPC>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
		TunnelDweller[] array2 = BaseEntity.Util.FindAll<TunnelDweller>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].Kill();
		}
	}

	[ServerVar]
	public static void killanimals(Arg args)
	{
		BaseAnimalNPC[] array = BaseEntity.Util.FindAll<BaseAnimalNPC>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
		BaseNPC2[] array2 = BaseEntity.Util.FindAll<BaseNPC2>();
		foreach (BaseNPC2 baseNPC in array2)
		{
			if (baseNPC.IsAnimal)
			{
				baseNPC.Kill();
			}
		}
	}

	[ServerVar(Help = "Add a player (or command user if no player is specified) to the AIs ignore list.")]
	public static void addignoreplayer(Arg args)
	{
		BasePlayer basePlayer = null;
		basePlayer = (args.HasArgs(1) ? args.GetPlayerOrSleeper(0) : args.Player());
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null || basePlayer.net.connection == null)
		{
			args.ReplyWith("Player not found.");
		}
		else
		{
			SimpleAIMemory.AddIgnorePlayer(basePlayer);
		}
	}

	[ServerVar(Help = "Remove a player (or command user if no player is specified) from the AIs ignore list.")]
	public static void removeignoreplayer(Arg args)
	{
		BasePlayer basePlayer = null;
		basePlayer = (args.HasArgs(1) ? args.GetPlayerOrSleeper(0) : args.Player());
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null || basePlayer.net.connection == null)
		{
			args.ReplyWith("Player not found.");
		}
		else
		{
			SimpleAIMemory.RemoveIgnorePlayer(basePlayer);
		}
	}

	[ServerVar(Help = "Remove all players from the AIs ignore list.")]
	public static void clearignoredplayers(Arg args)
	{
		SimpleAIMemory.ClearIgnoredPlayers();
	}

	[ServerVar(Help = "Print a lost of all the players in the AI ignore list.")]
	public static void printignoredplayers(Arg args)
	{
		args.ReplyWith(SimpleAIMemory.GetIgnoredPlayers());
	}

	public static float TickDelta()
	{
		return 1f / tickrate;
	}

	[ServerVar]
	public static void selectNPCLookatServer(Arg args)
	{
	}
}


[Factory("animation")]
public class Animation : ConsoleSystem
{
	public static float defaultFadeDuration = 0.25f;
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Newtonsoft.Json;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Scripting;

[Factory("global")]
public class Admin : ConsoleSystem
{
	private enum ChangeGradeMode
	{
		Upgrade,
		Downgrade
	}

	[Preserve]
	[JsonModel]
	public struct PlayerInfo
	{
		public string SteamID;

		public string OwnerSteamID;

		public string DisplayName;

		public int Ping;

		public string Address;

		public int ConnectedSeconds;

		public float VoiationLevel;

		public float CurrentLevel;

		public float UnspentXp;

		public float Health;
	}

	[JsonModel]
	[Preserve]
	public struct ServerInfoOutput
	{
		public string Hostname;

		public int MaxPlayers;

		public int Players;

		public int Queued;

		public int Joining;

		public int ReservedSlots;

		public int EntityCount;

		public string GameTime;

		public int Uptime;

		public string Map;

		public float Framerate;

		public int Memory;

		public int MemoryUsageSystem;

		public int Collections;

		public int NetworkIn;

		public int NetworkOut;

		public bool Restarting;

		public string SaveCreatedTime;

		public int Version;

		public string Protocol;
	}

	[Preserve]
	[JsonModel]
	public struct ServerConvarInfo
	{
		public string FullName;

		public string Value;

		public string Help;
	}

	[Preserve]
	[JsonModel]
	public struct ServerUGCInfo
	{
		public ulong entityId;

		public uint[] crcs;

		public UGCType contentType;

		public uint entityPrefabID;

		public string shortPrefabName;

		public ulong[] playerIds;

		public string contentString;

		public ServerUGCInfo(IUGCBrowserEntity fromEntity)
		{
			entityId = fromEntity.UgcEntity.net.ID.Value;
			crcs = fromEntity.GetContentCRCs;
			contentType = fromEntity.ContentType;
			entityPrefabID = fromEntity.UgcEntity.prefabID;
			shortPrefabName = fromEntity.UgcEntity.ShortPrefabName;
			playerIds = fromEntity.EditingHistory.ToArray();
			contentString = fromEntity.ContentString;
		}
	}

	private struct EntityAssociation
	{
		public BaseEntity TargetEntity;

		public EntityAssociationType AssociationType;
	}

	private enum EntityAssociationType
	{
		Owner,
		Auth,
		LockGuest
	}

	[ReplicatedVar(Help = "Controls whether the in-game admin UI is displayed to admins")]
	public static bool allowAdminUI = true;

	[ServerVar(Help = "Print out currently connected clients")]
	public static void status(Arg arg)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Expected O, but got Unknown
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (@string == "--json")
		{
			@string = arg.GetString(1, "");
		}
		bool flag = arg.HasArg("--json", false);
		string text = string.Empty;
		if (!flag && @string.Length == 0)
		{
			text = text + "hostname: " + ConVar.Server.hostname + "\n";
			text = text + "version : " + 2585 + " secure (secure mode enabled, connected to Steam3)\n";
			text = text + "map     : " + ConVar.Server.level + "\n";
			text += $"players : {((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Count()} ({ConVar.Server.maxplayers} max) ({SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued} queued) ({SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining} joining)\n\n";
		}
		TextTable val = new TextTable();
		val.AddColumn("id");
		val.AddColumn("name");
		val.AddColumn("ping");
		val.AddColumn("connected");
		val.AddColumn("addr");
		val.AddColumn("owner");
		val.AddColumn("violation");
		val.AddColumn("kicks");
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				try
				{
					if (!current.IsValid())
					{
						continue;
					}
					string userIDString = current.UserIDString;
					if (current.net.connection == null)
					{
						val.AddRow(new string[2] { userIDString, "NO CONNECTION" });
						continue;
					}
					string text2 = current.net.connection.ownerid.ToString();
					string text3 = StringExtensions.QuoteSafe(current.displayName);
					string text4 = Net.sv.GetAveragePing(current.net.connection).ToString();
					string text5 = current.net.connection.ipaddress;
					string text6 = current.violationLevel.ToString("0.0");
					string text7 = current.GetAntiHackKicks().ToString();
					if (!arg.IsAdmin && !arg.IsRcon)
					{
						text5 = "xx.xxx.xx.xxx";
					}
					string text8 = current.net.connection.GetSecondsConnected() + "s";
					if (@string.Length <= 0 || StringEx.Contains(text3, @string, CompareOptions.IgnoreCase) || userIDString.Contains(@string) || text2.Contains(@string) || text5.Contains(@string))
					{
						val.AddRow(new string[8]
						{
							userIDString,
							text3,
							text4,
							text8,
							text5,
							(text2 == userIDString) ? string.Empty : text2,
							text6,
							text7
						});
					}
				}
				catch (Exception ex)
				{
					val.AddRow(new string[2]
					{
						current.UserIDString,
						StringExtensions.QuoteSafe(ex.Message)
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (flag)
		{
			arg.ReplyWith(val.ToJson(true));
		}
		else
		{
			arg.ReplyWith(text + ((object)val).ToString());
		}
	}

	[ServerVar(Help = "Print out stats of currently connected clients")]
	public static void stats(Arg arg)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		TextTable table = new TextTable();
		table.AddColumn("id");
		table.AddColumn("name");
		table.AddColumn("time");
		table.AddColumn("kills");
		table.AddColumn("deaths");
		table.AddColumn("suicides");
		table.AddColumn("player");
		table.AddColumn("building");
		table.AddColumn("entity");
		Action<ulong, string> action = delegate(ulong id, string name)
		{
			ServerStatistics.Storage storage = ServerStatistics.Get(id);
			string text = TimeSpan.FromSeconds(storage.Get("time")).ToShortString();
			string text2 = storage.Get("kill_player").ToString();
			string text3 = (storage.Get("deaths") - storage.Get("death_suicide")).ToString();
			string text4 = storage.Get("death_suicide").ToString();
			string text5 = storage.Get("hit_player_direct_los").ToString();
			string text6 = storage.Get("hit_player_indirect_los").ToString();
			string text7 = storage.Get("hit_building_direct_los").ToString();
			string text8 = storage.Get("hit_building_indirect_los").ToString();
			string text9 = storage.Get("hit_entity_direct_los").ToString();
			string text10 = storage.Get("hit_entity_indirect_los").ToString();
			table.AddRow(new string[9]
			{
				id.ToString(),
				name,
				text,
				text2,
				text3,
				text4,
				text5 + " / " + text6,
				text7 + " / " + text8,
				text9 + " / " + text10
			});
		};
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt == 0L)
		{
			string @string = arg.GetString(0, "");
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					try
					{
						if (current.IsValid())
						{
							string text11 = StringExtensions.QuoteSafe(current.displayName);
							if (@string.Length <= 0 || StringEx.Contains(text11, @string, CompareOptions.IgnoreCase))
							{
								action(current.userID, text11);
							}
						}
					}
					catch (Exception ex)
					{
						table.AddRow(new string[2]
						{
							current.UserIDString,
							StringExtensions.QuoteSafe(ex.Message)
						});
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		else
		{
			string arg2 = "N/A";
			BasePlayer basePlayer = BasePlayer.FindByID(uInt);
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				arg2 = StringExtensions.QuoteSafe(basePlayer.displayName);
			}
			action(uInt, arg2);
		}
		arg.ReplyWith(arg.HasArg("--json", false) ? table.ToJson(true) : ((object)table).ToString());
	}

	[ServerVar(Help = "upgrade_radius 'grade' 'radius'")]
	public static void upgrade_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'upgrade_radius {grade} {radius}'");
		}
		else
		{
			SkinRadiusInternal(arg, changeAnyGrade: true);
		}
	}

	[ServerVar(Help = "<grade>")]
	public static void upgrade_looking(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'upgrade_looking {grade}'");
		}
		else
		{
			SkinRaycastInternal(arg, changeAnyGrade: true);
		}
	}

	[ServerVar(Help = "skin_radius 'skin' 'radius'")]
	public static void skin_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'skin_radius {skin} {radius}'");
		}
		else
		{
			SkinRadiusInternal(arg, changeAnyGrade: false);
		}
	}

	[ServerVar(Help = "<skin>")]
	public static void skin_looking(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'skin_looking <skin>'");
		}
		else
		{
			SkinRaycastInternal(arg, changeAnyGrade: false);
		}
	}

	[ServerVar(Help = "add_wallpaper_radius 'wallpaper' 'radius'")]
	public static void add_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'add_wallpaper_radius {skin} {radius}'");
		}
		else
		{
			wallpaper_radius_internal(arg, addIfMissing: true);
		}
	}

	[ServerVar(Help = "change_wallpaper_radius 'wallpaper' 'radius'")]
	public static void change_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'change_wallpaper_radius {skin} {radius}'");
		}
		else
		{
			wallpaper_radius_internal(arg, addIfMissing: false);
		}
	}

	[ServerVar(Help = "clear_wallpaper_radius 'radius'")]
	public static void clear_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'clear_wallpaper_radius {radius}'");
			return;
		}
		RunInRadius(arg.GetFloat(0, 0f), arg.Player(), delegate(BuildingBlock block)
		{
			if (block.HasWallpaper())
			{
				block.RemoveWallpaper(0);
				block.RemoveWallpaper(1);
			}
		});
	}

	public static BuildingGrade FindBuildingSkin(string name, out string error)
	{
		BuildingGrade buildingGrade = null;
		error = null;
		IEnumerable<BuildingGrade> source = from x in PrefabAttribute.server.FindAll<ConstructionGrade>(2194854973u)
			select x.gradeBase;
		switch (name)
		{
		case "twig":
		case "0":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "twigs");
			break;
		case "wood":
		case "1":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "wood");
			break;
		case "stone":
		case "2":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "stone");
			break;
		case "metal":
		case "sheetmetal":
		case "3":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "metal");
			break;
		case "hqm":
		case "armored":
		case "armoured":
		case "4":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "toptier");
			break;
		case "adobe":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "adobe");
			break;
		case "shipping":
		case "shippingcontainer":
		case "container":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "shipping_container");
			break;
		case "brutal":
		case "brutalist":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "brutalist");
			break;
		case "brick":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "brick");
			break;
		case "frontier":
		case "legacy":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "frontier");
			break;
		case "gingerbread":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "gingerbread");
			break;
		default:
			error = "Valid skins are:\ntwig\nwood | frontier | gingerbread\nstone | adobe | brick | brutalist\nmetal | shipping\nhqm";
			return null;
		}
		if ((Object)(object)buildingGrade == (Object)null)
		{
			error = "Unable to find skin object for '" + name + "'";
		}
		return buildingGrade;
	}

	private static IEnumerable<BuildingBlock> SearchRadius(Vector3 position, float radius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BuildingBlock> list = new List<BuildingBlock>();
		Vis.Entities(position, radius, list, 2097152, (QueryTriggerInteraction)2);
		return list;
	}

	private static IEnumerable<BuildingBlock> SearchLookingAt(Vector3 position, Vector3 direction, float maxDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = GamePhysics.RaycastEntity(GamePhysics.Realm.Server, new Ray(position, direction), maxDistance, 10485760, (QueryTriggerInteraction)1) as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return Array.Empty<BuildingBlock>();
		}
		return (IEnumerable<BuildingBlock>)(buildingBlock.GetBuilding()?.buildingBlocks);
	}

	private static void SkinRadiusInternal(Arg arg, bool changeAnyGrade)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		IEnumerable<BuildingBlock> blocks = SearchRadius(((Component)arg.Player()).transform.position, arg.GetFloat(1, 0f));
		ApplySkinInternal(arg, changeAnyGrade, blocks);
	}

	private static void SkinRaycastInternal(Arg arg, bool changeAnyGrade)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		IEnumerable<BuildingBlock> blocks = SearchLookingAt(basePlayer.eyes.position, basePlayer.eyes.BodyForward(), 100f);
		ApplySkinInternal(arg, changeAnyGrade, blocks);
	}

	private static void ApplySkinInternal(Arg arg, bool changeAnyGrade, IEnumerable<BuildingBlock> blocks)
	{
		if ((Object)(object)arg.Player() == (Object)null)
		{
			arg.ReplyWith("This must be called from the client");
			return;
		}
		arg.GetFloat(1, 0f);
		string @string = arg.GetString(0, "");
		string error;
		BuildingGrade buildingGrade = FindBuildingSkin(@string, out error);
		if ((Object)(object)buildingGrade == (Object)null)
		{
			arg.ReplyWith(error);
			return;
		}
		if (!buildingGrade.enabledInStandalone)
		{
			arg.ReplyWith("Skin " + @string + " is not enabled in standalone yet");
			return;
		}
		if (blocks == null || blocks.Count() == 0)
		{
			arg.ReplyWith("No building blocks found");
			return;
		}
		foreach (BuildingBlock block in blocks)
		{
			if (block.grade == buildingGrade.type || changeAnyGrade)
			{
				block.ChangeGradeAndSkin(buildingGrade.type, buildingGrade.skin);
			}
		}
	}

	private static void wallpaper_radius_internal(Arg arg, bool addIfMissing)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("This must be called from the client");
			return;
		}
		float @float = arg.GetFloat(1, 0f);
		string @string = arg.GetString(0, "");
		int skinIdParsed = -1;
		if (!int.TryParse(@string, out skinIdParsed))
		{
			skinIdParsed = -1;
		}
		bool flag = false;
		ItemSkinDirectory.Skin[] skins = WallpaperPlanner.WallpaperItemDef.skins;
		for (int i = 0; i < skins.Length; i++)
		{
			ItemSkinDirectory.Skin skin = skins[i];
			if (skinIdParsed != -1 && skin.id == skinIdParsed)
			{
				flag = true;
				break;
			}
			if (skinIdParsed == -1 && (skin.invItem.displayName.english.Contains(@string, StringComparison.InvariantCultureIgnoreCase) || ((Object)skin.invItem).name.Contains(@string, StringComparison.InvariantCultureIgnoreCase)))
			{
				flag = true;
				skinIdParsed = skin.id;
				break;
			}
		}
		if (skinIdParsed == 0)
		{
			flag = true;
		}
		if (!flag && skinIdParsed != -1)
		{
			arg.ReplyWith("Invalid skin");
			return;
		}
		RunInRadius(@float, basePlayer, delegate(BuildingBlock block)
		{
			bool flag2 = block.HasWallpaper();
			if (addIfMissing && !flag2)
			{
				flag2 = false;
				Socket_Base[] array = PrefabAttribute.server.FindAll<Socket_Base>(block.prefabID);
				for (int j = 0; j < array.Length; j++)
				{
					if (array[j] is Socket_Specific_Female socket_Specific_Female && socket_Specific_Female.socketName.Contains("wallpaper"))
					{
						flag2 = true;
						break;
					}
				}
			}
			if (block.HasWallpaper() || flag2)
			{
				if (skinIdParsed == -1)
				{
					int id = WallpaperPlanner.WallpaperItemDef.skins.GetRandom().id;
					block.SetWallpaper((ulong)id);
					block.SetWallpaper((ulong)id, 1);
				}
				else
				{
					block.SetWallpaper((ulong)skinIdParsed);
					block.SetWallpaper((ulong)skinIdParsed, 1);
				}
				block.CheckWallpaper();
			}
		});
	}

	[ServerVar]
	public static void killplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
		}
	}

	[ServerVar]
	public static void killallplayers(Arg arg)
	{
		BasePlayer[] array = BaseEntity.Util.FindAll<BasePlayer>();
		int num = 0;
		BasePlayer[] array2 = array;
		foreach (BasePlayer basePlayer in array2)
		{
			if (!basePlayer.IsNpc)
			{
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
				num++;
			}
		}
		arg.ReplyWith($"Killed {num} players");
	}

	[ServerVar]
	public static void injureplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			Global.InjurePlayer(basePlayer);
		}
	}

	[ServerVar]
	public static void recoverplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			Global.RecoverPlayer(basePlayer);
		}
	}

	[ServerVar]
	public static void kick(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		string @string = arg.GetString(1, "no reason given");
		arg.ReplyWith("Kicked: " + player.displayName);
		Chat.Broadcast("Kicking " + player.displayName + " (" + @string + ")", "SERVER", "#eee", 0uL);
		player.Kick("Kicked: " + arg.GetString(1, "No Reason Given"), reserveSlot: false);
	}

	[ServerVar]
	public static void skick(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		string @string = arg.GetString(1, "no reason given");
		arg.ReplyWith("Kicked: " + player.displayName);
		Chat.ChatEntry ce = default(Chat.ChatEntry);
		ce.Channel = Chat.ChatChannel.Server;
		ce.Message = "(SILENT) Kicking " + player.displayName + " (" + @string + ")";
		ce.UserId = "0";
		ce.Username = "SERVER";
		ce.Color = "#eee";
		ce.Time = Epoch.Current;
		Chat.Record(ce);
		player.Kick("Kicked: " + arg.GetString(1, "No Reason Given"), reserveSlot: false);
	}

	[ServerVar]
	public static void kickall(Arg arg)
	{
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Kicked: " + arg.GetString(0, "No Reason Given"));
		}
	}

	[ServerVar(Help = "ban <player> <reason> [optional duration]")]
	public static void ban(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(player.userID);
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {player.userID.Get()} is already banned");
			return;
		}
		string @string = arg.GetString(1, "No Reason Given");
		if (TryGetBanExpiry(arg, 2, out var expiry, out var durationSuffix))
		{
			ServerUsers.Set(player.userID, ServerUsers.UserGroup.Banned, player.displayName, @string, expiry);
			string text = "";
			if (player.IsConnected && player.net.connection.ownerid != 0L && player.net.connection.ownerid != player.net.connection.userid)
			{
				text += $" and also banned ownerid {player.net.connection.ownerid}";
				ServerUsers.Set(player.net.connection.ownerid, ServerUsers.UserGroup.Banned, player.displayName, arg.GetString(1, $"Family share owner of {player.net.connection.userid}"), -1L);
			}
			ServerUsers.Save();
			arg.ReplyWith($"Kickbanned User{durationSuffix}: {player.userID.Get()} - {player.displayName}{text}");
			Chat.Broadcast("Kickbanning " + player.displayName + durationSuffix + " (" + @string + ")", "SERVER", "#eee", 0uL);
			Net.sv.Kick(player.net.connection, "Banned" + durationSuffix + ": " + @string, false);
		}
	}

	[ServerVar]
	public static void moderatorid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			arg.ReplyWith("User " + uInt + " is already a Moderator");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.Moderator, @string, string2, -1L);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: true);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Added moderator " + @string + ", steamid " + uInt);
	}

	[ServerVar]
	public static void ownerid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		if (arg.Connection != null && arg.Connection.authLevel < 2)
		{
			arg.ReplyWith("Moderators cannot run ownerid");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			arg.ReplyWith("User " + uInt + " is already an Owner");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.Owner, @string, string2, -1L);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: true);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Added owner " + @string + ", steamid " + uInt);
	}

	[ServerVar]
	public static void removemoderator(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Moderator)
		{
			arg.ReplyWith("User " + uInt + " isn't a moderator");
			return;
		}
		ServerUsers.Remove(uInt);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: false);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Removed Moderator: " + uInt);
	}

	[ServerVar]
	public static void removeowner(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Owner)
		{
			arg.ReplyWith("User " + uInt + " isn't an owner");
			return;
		}
		ServerUsers.Remove(uInt);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: false);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Removed Owner: " + uInt);
	}

	[ServerVar(Help = "banid <steamid> <username> <reason> [optional duration]")]
	public static void banid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string text = arg.GetString(1, "unnamed");
		string @string = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith("User " + uInt + " is already banned");
		}
		else
		{
			if (!TryGetBanExpiry(arg, 3, out var expiry, out var durationSuffix))
			{
				return;
			}
			string text2 = "";
			BasePlayer basePlayer = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
			{
				text = basePlayer.displayName;
				if (basePlayer.IsConnected && basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
				{
					text2 += $" and also banned ownerid {basePlayer.net.connection.ownerid}";
					ServerUsers.Set(basePlayer.net.connection.ownerid, ServerUsers.UserGroup.Banned, basePlayer.displayName, arg.GetString(1, $"Family share owner of {basePlayer.net.connection.userid}"), expiry);
				}
				Chat.Broadcast("Kickbanning " + basePlayer.displayName + durationSuffix + " (" + @string + ")", "SERVER", "#eee", 0uL);
				Net.sv.Kick(basePlayer.net.connection, "Banned" + durationSuffix + ": " + @string, false);
			}
			ServerUsers.Set(uInt, ServerUsers.UserGroup.Banned, text, @string, expiry);
			arg.ReplyWith($"Banned User{durationSuffix}: {uInt} - \"{text}\" for \"{@string}\"{text2}");
		}
	}

	private static bool TryGetBanExpiry(Arg arg, int n, out long expiry, out string durationSuffix)
	{
		expiry = arg.GetTimestamp(n, -1L);
		durationSuffix = null;
		int current = Epoch.Current;
		if (expiry > 0 && expiry <= current)
		{
			arg.ReplyWith("Expiry time is in the past");
			return false;
		}
		durationSuffix = ((expiry > 0) ? (" for " + NumberExtensions.FormatSecondsLong(expiry - current)) : "");
		return true;
	}

	[ServerVar]
	public static void unban(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith($"This doesn't appear to be a 64bit steamid: {uInt}");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {uInt} isn't banned");
			return;
		}
		ServerUsers.Remove(uInt);
		arg.ReplyWith("Unbanned User: " + uInt);
	}

	[ServerVar]
	public static void skipqueue(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
		}
		else
		{
			SingletonComponent<ServerMgr>.Instance.connectionQueue.SkipQueue(uInt);
		}
	}

	[ServerVar(Help = "Adds skip queue permissions to a SteamID")]
	public static void skipqueueid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && (user.group == ServerUsers.UserGroup.Owner || user.group == ServerUsers.UserGroup.Moderator || user.group == ServerUsers.UserGroup.SkipQueue))
		{
			arg.ReplyWith($"User {uInt} will already skip the queue ({user.group})");
			return;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {uInt} is banned");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.SkipQueue, @string, string2, -1L);
		arg.ReplyWith($"Added skip queue permission for {@string} ({uInt})");
	}

	[ServerVar(Help = "Removes skip queue permission from a SteamID")]
	public static void removeskipqueue(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && (user.group == ServerUsers.UserGroup.Owner || user.group == ServerUsers.UserGroup.Moderator))
		{
			arg.ReplyWith($"User is a {user.group}, cannot remove skip queue permission with this command");
			return;
		}
		if (user == null || user.group != ServerUsers.UserGroup.SkipQueue)
		{
			arg.ReplyWith("User does not have skip queue permission");
			return;
		}
		ServerUsers.Remove(uInt);
		arg.ReplyWith("Removed skip queue permission: " + uInt);
	}

	[ServerVar(Help = "Print out currently connected clients etc")]
	public static void players(Arg arg)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Expected O, but got Unknown
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = new TextTable(!flag);
		val.ResizeColumns(5);
		val.AddColumn("id");
		val.AddColumn("name");
		val.AddColumn("ping");
		val.AddColumn("updt");
		val.AddColumn("dist");
		val.ResizeRows(BasePlayer.activePlayerList.Count);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				string userIDString = current.UserIDString;
				val.AddValue(userIDString);
				string text = current.displayName;
				if (text.Length >= 14)
				{
					text = text.Substring(0, 14) + "..";
				}
				val.AddValue(text);
				int averagePing = Net.sv.GetAveragePing(current.net.connection);
				val.AddValue(averagePing);
				int queuedUpdateCount = current.GetQueuedUpdateCount(BasePlayer.NetworkQueue.Update);
				val.AddValue(queuedUpdateCount);
				int queuedUpdateCount2 = current.GetQueuedUpdateCount(BasePlayer.NetworkQueue.UpdateDistance);
				val.AddValue(queuedUpdateCount2);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(flag ? val.ToJson(false) : ((object)val).ToString());
	}

	[ServerVar(Help = "Sends a message in chat")]
	public static void say(Arg arg)
	{
		Chat.Broadcast(arg.FullString, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "Show user info for players on server.")]
	public static void users(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				text = text + current.userID.Get() + ":\"" + current.displayName + "\"\n";
				num++;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		text = text + num + "users\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server.")]
	public static void sleepingusers(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				text += $"{current.userID.Get()}:{current.displayName}\n";
				num++;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		text += $"{num} sleeping users\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for sleeping players on server in range of the player.")]
	public static void sleepingusersinrange(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer fromPlayer = arg.Player();
		if ((Object)(object)fromPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(0, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)fromPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)fromPlayer) < basePlayer.Distance2D((BaseEntity)fromPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)fromPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} sleeping users within {range}m\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server in range of the player.")]
	public static void usersinrange(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer fromPlayer = arg.Player();
		if ((Object)(object)fromPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(0, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)fromPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)fromPlayer) < basePlayer.Distance2D((BaseEntity)fromPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)fromPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} users within {range}m\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server in range of the supplied player (eg. Jim 50)")]
	public static void usersinrangeofplayer(Arg arg)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer targetPlayer = arg.GetPlayerOrSleeper(0);
		if ((Object)(object)targetPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(1, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)targetPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)targetPlayer) < basePlayer.Distance2D((BaseEntity)targetPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)targetPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} users within {range}m of {targetPlayer.displayName}\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "List of banned users (sourceds compat)")]
	public static void banlist(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListString());
	}

	[ServerVar(Help = "List of banned users - shows reasons and usernames")]
	public static void banlistex(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListStringEx());
	}

	[ServerVar(Help = "List of banned users, by ID (sourceds compat)")]
	public static void listid(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListString(bHeader: true));
	}

	[ServerVar]
	public static void mute(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			playerOrSleeper.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, b: true);
		}
	}

	[ServerVar]
	public static void unmute(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			playerOrSleeper.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, b: false);
		}
	}

	[ServerVar(Help = "Print a list of currently muted players")]
	public static void mutelist(Arg arg)
	{
		var enumerable = from x in BasePlayer.allPlayerList
			where x.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute)
			select new
			{
				SteamId = x.UserIDString,
				Name = x.displayName
			};
		arg.ReplyWith((object)enumerable);
	}

	[ServerVar]
	public static void clientperf(Arg arg)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "legacy");
		int @int = arg.GetInt(1, Random.Range(int.MinValue, int.MaxValue));
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				current.ClientRPC(RpcTarget.Player("GetPerformanceReport", current), @string, @int);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void clientperf_frametime(Arg arg)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		ClientFrametimeRequest clientFrametimeRequest = new ClientFrametimeRequest
		{
			request_id = arg.GetInt(0, Random.Range(int.MinValue, int.MaxValue)),
			start_frame = arg.GetInt(1, 0),
			max_frames = arg.GetInt(2, 1000)
		};
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				current.ClientRPC(RpcTarget.Player("GetPerformanceReport_Frametime", current), JsonConvert.SerializeObject((object)clientFrametimeRequest));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Get information about all the cars in the world")]
	public static void carstats(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		HashSet<ModularCar> allCarsList = ModularCar.allCarsList;
		TextTable val = new TextTable();
		val.AddColumn("id");
		val.AddColumn("sockets");
		val.AddColumn("modules");
		val.AddColumn("complete");
		val.AddColumn("engine");
		val.AddColumn("health");
		val.AddColumn("location");
		int count = allCarsList.Count;
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		foreach (ModularCar item in allCarsList)
		{
			string text = ((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString();
			string text2 = item.TotalSockets.ToString();
			string text3 = item.NumAttachedModules.ToString();
			string text4;
			if (item.IsComplete())
			{
				text4 = "Complete";
				num++;
			}
			else
			{
				text4 = "Partial";
			}
			string text5;
			if (item.HasAnyWorkingEngines())
			{
				text5 = "Working";
				num2++;
			}
			else
			{
				text5 = "Broken";
			}
			string text6 = ((item.TotalMaxHealth() != 0f) ? $"{item.TotalHealth() / item.TotalMaxHealth():0%}" : "0");
			string text7;
			if (item.IsOutside())
			{
				text7 = "Outside";
			}
			else
			{
				text7 = "Inside";
				num3++;
			}
			val.AddRow(new string[7] { text, text2, text3, text4, text5, text6, text7 });
		}
		string text8 = "";
		text8 = ((count != 1) ? (text8 + $"\nThe world contains {count} modular cars.") : (text8 + "\nThe world contains 1 modular car."));
		text8 = ((num != 1) ? (text8 + $"\n{num} ({(float)num / (float)count:0%}) are in a completed state.") : (text8 + $"\n1 ({1f / (float)count:0%}) is in a completed state."));
		text8 = ((num2 != 1) ? (text8 + $"\n{num2} ({(float)num2 / (float)count:0%}) are driveable.") : (text8 + $"\n1 ({1f / (float)count:0%}) is driveable."));
		arg.ReplyWith(string.Concat(str1: (num3 != 1) ? (text8 + $"\n{num3} ({(float)num3 / (float)count:0%}) are sheltered indoors.") : (text8 + $"\n1 ({1f / (float)count:0%}) is sheltered indoors."), str0: ((object)val).ToString()));
	}

	[ServerVar]
	public static string teaminfo(Arg arg)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Expected O, but got Unknown
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			return "Player not found";
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(num);
		if (playerTeam == null)
		{
			return "Player is not in a team";
		}
		TextTable val = new TextTable();
		val.AddColumn("steamID");
		val.AddColumn("username");
		val.AddColumn("online");
		val.AddColumn("leader");
		foreach (ulong memberId in playerTeam.members)
		{
			bool flag = ((IEnumerable<Connection>)Net.sv.connections).FirstOrDefault((Func<Connection, bool>)((Connection c) => c.connected && c.userid == memberId)) != null;
			val.AddRow(new string[4]
			{
				memberId.ToString(),
				GetPlayerName(memberId),
				flag ? "x" : "",
				(memberId == playerTeam.teamLeader) ? "x" : ""
			});
		}
		if (!arg.HasArg("--json", false))
		{
			return $"ID: {playerTeam.teamID}\n\n{val}";
		}
		return val.ToJson(true);
	}

	[ServerVar]
	public static void authradius(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'authradius {radius} [user]'");
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		list.Add(arg.GetPlayer(1) ?? arg.Player());
		SetAuthInRadius(list[0], list, @float, auth: true);
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void authradius_multi(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'authradius {radius} [user, user, ...]'");
		}
		else
		{
			SetAuthInRadius(arg.Player(), arg.GetPlayerArgs(1), @float, auth: true);
		}
	}

	[ServerVar]
	public static void authradius_radius(Arg arg)
	{
		run_authradius_radius(arg, authFlag: true);
	}

	[ServerVar]
	public static void deauthradius_radius(Arg arg)
	{
		run_authradius_radius(arg, authFlag: false);
	}

	private static void run_authradius_radius(Arg arg, bool authFlag)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, -1f);
		float float2 = arg.GetFloat(1, -1f);
		if (@float < 0f || float2 < 0f)
		{
			arg.ReplyWith("Format is 'authradius_radius {playerRadius, authRadius }'");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer2 = list[num];
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				list.RemoveAt(num);
			}
			else if (basePlayer2.isClient || Vector3.Distance(((Component)basePlayer2).transform.position, ((Component)basePlayer).transform.position) > @float)
			{
				list.Remove(basePlayer2);
			}
		}
		SetAuthInRadius(basePlayer, list, float2, authFlag);
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void deauthradius(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'deauthradius {radius} [user]'");
			return;
		}
		List<BasePlayer> list = new List<BasePlayer>();
		list.Add(arg.GetPlayer(1) ?? arg.Player());
		SetAuthInRadius(list[0], list, @float, auth: false);
	}

	[ServerVar]
	public static void deauthradius_multi(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'deauthradius {radius} [user, user, ...]'");
		}
		else
		{
			SetAuthInRadius(arg.Player(), arg.GetPlayerArgs(1), @float, auth: false);
		}
	}

	private static void SetAuthInRadius(BasePlayer radiusTargetPlayer, List<BasePlayer> players, float radius, bool auth)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (players == null)
		{
			return;
		}
		if (players.Count == 0)
		{
			players.Add(radiusTargetPlayer);
		}
		List<BaseEntity> list = new List<BaseEntity>();
		Vis.Entities(((Component)radiusTargetPlayer).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BaseEntity item in list)
		{
			if (!item.isServer)
			{
				continue;
			}
			bool flag = true;
			foreach (BasePlayer player in players)
			{
				bool flag2 = SetUserAuthorized(item, player.userID, auth);
				if (!flag2)
				{
					flag2 = SetUserAuthorized(item.GetSlot(BaseEntity.Slot.Lock), player.userID, auth);
				}
				if (flag)
				{
					num += (flag2 ? 1 : 0);
					flag = false;
				}
			}
		}
		Debug.Log((object)("Set auth: " + auth + " on " + players.Count + " players, for " + num + " entities."));
	}

	private static bool SetUserAuthorized(BaseEntity entity, ulong userId, bool state)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Expected O, but got Unknown
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Expected O, but got Unknown
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (entity is CodeLock codeLock)
		{
			if (state)
			{
				codeLock.whitelistPlayers.Add(userId);
			}
			else
			{
				codeLock.whitelistPlayers.Remove(userId);
				codeLock.guestPlayers.Remove(userId);
			}
			codeLock.SendNetworkUpdate();
		}
		else if (entity is AutoTurret autoTurret)
		{
			if (state)
			{
				autoTurret.authorizedPlayers.Add(new PlayerNameID
				{
					ShouldPool = false,
					userid = userId,
					username = ""
				});
			}
			else
			{
				autoTurret.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == userId);
			}
			autoTurret.SendNetworkUpdate();
		}
		else if (entity is BuildingPrivlidge buildingPrivlidge)
		{
			if (state)
			{
				buildingPrivlidge.authorizedPlayers.Add(new PlayerNameID
				{
					ShouldPool = false,
					userid = userId,
					username = ""
				});
			}
			else
			{
				buildingPrivlidge.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == userId);
			}
			if (entity.GetSlot(BaseEntity.Slot.Lock).IsValid())
			{
				SetUserAuthorized(entity.GetSlot(BaseEntity.Slot.Lock), userId, state);
			}
			buildingPrivlidge.SendNetworkUpdate();
		}
		else
		{
			if (!(entity is ModularCar modularCar))
			{
				return false;
			}
			if (state)
			{
				modularCar.CarLock.TryAddPlayer(userId);
			}
			else
			{
				modularCar.CarLock.TryRemovePlayer(userId);
			}
			modularCar.SendNetworkUpdate();
		}
		return true;
	}

	[ServerVar]
	public static void entid(Arg arg)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(arg.GetEntityID(1)) as BaseEntity;
		if ((Object)(object)baseEntity == (Object)null || baseEntity is BasePlayer)
		{
			return;
		}
		string @string = arg.GetString(0, "");
		if ((Object)(object)arg.Player() != (Object)null)
		{
			Debug.Log((object)("[ENTCMD] " + arg.Player().displayName + "/" + arg.Player().userID.Get() + " used *" + @string + "* on ent: " + ((Object)baseEntity).name));
		}
		switch (@string)
		{
		case "kill":
			baseEntity.AdminKill();
			return;
		case "lock":
			baseEntity.SetFlag(BaseEntity.Flags.Locked, b: true);
			return;
		case "unlock":
			baseEntity.SetFlag(BaseEntity.Flags.Locked, b: false);
			return;
		case "debug":
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, b: true);
			return;
		case "undebug":
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, b: false);
			return;
		case "who":
			arg.ReplyWith(baseEntity.Admin_Who());
			return;
		case "auth":
			arg.ReplyWith(AuthList(baseEntity));
			return;
		case "upgrade":
			arg.ReplyWith(ChangeGrade(baseEntity, arg.GetInt(2, 1), 0, BuildingGrade.Enum.None, 0uL, arg.GetFloat(3, 0f)));
			return;
		case "downgrade":
			arg.ReplyWith(ChangeGrade(baseEntity, 0, arg.GetInt(2, 1), BuildingGrade.Enum.None, 0uL, arg.GetFloat(3, 0f)));
			return;
		case "setgrade":
		{
			string error;
			BuildingGrade buildingGrade = FindBuildingSkin(arg.GetString(2, ""), out error);
			arg.ReplyWith(ChangeGrade(baseEntity, 0, 0, buildingGrade.type, buildingGrade.skin, arg.GetFloat(3, 0f)));
			return;
		}
		case "repair":
			RunInRadius(arg.GetFloat(2, 0f), baseEntity, delegate(BaseCombatEntity entity)
			{
				if (entity.repair.enabled)
				{
					entity.SetHealth(entity.MaxHealth());
				}
			});
			break;
		}
		arg.ReplyWith("Unknown command");
	}

	private static string AuthList(BaseEntity ent)
	{
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Expected O, but got Unknown
		List<PlayerNameID> list;
		if (!(ent is BuildingPrivlidge buildingPrivlidge))
		{
			if (!(ent is AutoTurret autoTurret))
			{
				if (!(ent is CodeLock codeLock))
				{
					if (ent is BaseVehicleModule vehicleModule)
					{
						return CodeLockAuthList(vehicleModule);
					}
					return "Entity has no auth list";
				}
				return CodeLockAuthList(codeLock);
			}
			list = new List<PlayerNameID>();
			foreach (PlayerNameID authorizedPlayer in autoTurret.authorizedPlayers)
			{
				list.Add(authorizedPlayer);
			}
		}
		else
		{
			list = new List<PlayerNameID>();
			foreach (PlayerNameID authorizedPlayer2 in buildingPrivlidge.authorizedPlayers)
			{
				list.Add(authorizedPlayer2);
			}
		}
		if (list == null || list.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = new TextTable();
		val.AddColumn("steamID");
		val.AddColumn("username");
		foreach (PlayerNameID item in list)
		{
			val.AddRow(new string[2]
			{
				item.userid.ToString(),
				GetPlayerName(item.userid)
			});
		}
		return ((object)val).ToString();
	}

	private static string CodeLockAuthList(CodeLock codeLock)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Expected O, but got Unknown
		if (codeLock.whitelistPlayers.Count == 0 && codeLock.guestPlayers.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = new TextTable();
		val.AddColumn("steamID");
		val.AddColumn("username");
		val.AddColumn("isGuest");
		foreach (ulong whitelistPlayer in codeLock.whitelistPlayers)
		{
			val.AddRow(new string[3]
			{
				whitelistPlayer.ToString(),
				GetPlayerName(whitelistPlayer),
				""
			});
		}
		foreach (ulong guestPlayer in codeLock.guestPlayers)
		{
			val.AddRow(new string[3]
			{
				guestPlayer.ToString(),
				GetPlayerName(guestPlayer),
				"x"
			});
		}
		return ((object)val).ToString();
	}

	private static string CodeLockAuthList(BaseVehicleModule vehicleModule)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Expected O, but got Unknown
		if (!vehicleModule.IsOnAVehicle)
		{
			return "Nobody is authed to this entity";
		}
		ModularCar modularCar = vehicleModule.Vehicle as ModularCar;
		if ((Object)(object)modularCar == (Object)null || !modularCar.IsLockable || modularCar.CarLock.WhitelistPlayers.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = new TextTable();
		val.AddColumn("steamID");
		val.AddColumn("username");
		foreach (ulong whitelistPlayer in modularCar.CarLock.WhitelistPlayers)
		{
			val.AddRow(new string[2]
			{
				whitelistPlayer.ToString(),
				GetPlayerName(whitelistPlayer)
			});
		}
		return ((object)val).ToString();
	}

	public static string GetPlayerName(ulong steamId)
	{
		BasePlayer basePlayer = BasePlayer.allPlayerList.FirstOrDefault((BasePlayer p) => (ulong)p.userID == steamId);
		string text;
		if (!((Object)(object)basePlayer != (Object)null))
		{
			text = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(steamId);
			if (text == null)
			{
				return "[unknown]";
			}
		}
		else
		{
			text = basePlayer.displayName;
		}
		return text;
	}

	public static string ChangeGrade(BaseEntity entity, int increaseBy = 0, int decreaseBy = 0, BuildingGrade.Enum targetGrade = BuildingGrade.Enum.None, ulong skin = 0uL, float radius = 0f)
	{
		if ((Object)(object)(entity as BuildingBlock) == (Object)null)
		{
			return $"'{entity}' is not a building block";
		}
		RunInRadius(radius, entity, delegate(BuildingBlock block)
		{
			BuildingGrade.Enum grade = block.grade;
			if (targetGrade > BuildingGrade.Enum.None && targetGrade < BuildingGrade.Enum.Count)
			{
				grade = targetGrade;
			}
			else
			{
				grade = (BuildingGrade.Enum)Mathf.Min((int)(grade + increaseBy), 4);
				grade = (BuildingGrade.Enum)Mathf.Max((int)(grade - decreaseBy), 0);
			}
			if (grade != block.grade)
			{
				block.ChangeGradeAndSkin(targetGrade, skin);
			}
		});
		int count = Pool.Get<List<BuildingBlock>>().Count;
		return $"Upgraded/downgraded '{count}' building block(s)";
	}

	private static bool RunInRadius<T>(float radius, BaseEntity initial, Action<T> callback, Func<T, bool> filter = null, int layerMask = 2097152) where T : BaseEntity
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		List<T> list = Pool.Get<List<T>>();
		radius = Mathf.Clamp(radius, 0f, 200f);
		if (radius > 0f)
		{
			Vis.Entities(((Component)initial).transform.position, radius, list, layerMask, (QueryTriggerInteraction)2);
		}
		else if (initial is T item)
		{
			list.Add(item);
		}
		foreach (T item2 in list)
		{
			try
			{
				callback(item2);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Exception while running callback in radius: {arg}");
				Pool.FreeUnmanaged<T>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<T>(ref list);
		return true;
	}

	[ServerVar(Help = "Get a list of players")]
	public static PlayerInfo[] playerlist()
	{
		return ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Select(delegate(BasePlayer x)
		{
			PlayerInfo result = default(PlayerInfo);
			result.SteamID = x.UserIDString;
			result.OwnerSteamID = x.OwnerID.ToString();
			result.DisplayName = x.displayName;
			result.Ping = Net.sv.GetAveragePing(x.net.connection);
			result.Address = x.net.connection.ipaddress;
			result.ConnectedSeconds = (int)x.net.connection.GetSecondsConnected();
			result.VoiationLevel = x.violationLevel;
			result.Health = x.Health();
			return result;
		}).ToArray();
	}

	[ServerVar(Help = "List of banned users")]
	public static ServerUsers.User[] Bans()
	{
		return ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToArray();
	}

	[ServerVar(Help = "Get a list of information about the server")]
	public static ServerInfoOutput ServerInfo()
	{
		ServerInfoOutput result = default(ServerInfoOutput);
		result.Hostname = ConVar.Server.hostname;
		result.MaxPlayers = ConVar.Server.maxplayers;
		result.Players = BasePlayer.activePlayerList.Count;
		result.Queued = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		result.Joining = SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining;
		result.ReservedSlots = SingletonComponent<ServerMgr>.Instance.connectionQueue.ReservedCount;
		result.EntityCount = BaseNetworkable.serverEntities.Count;
		result.GameTime = (((Object)(object)TOD_Sky.Instance != (Object)null) ? TOD_Sky.Instance.Cycle.DateTime.ToString() : DateTime.UtcNow.ToString());
		result.Uptime = (int)Time.realtimeSinceStartup;
		result.Map = ConVar.Server.level;
		result.Framerate = Performance.report.frameRate;
		result.Memory = (int)Performance.report.memoryAllocations;
		result.MemoryUsageSystem = (int)Performance.report.memoryUsageSystem;
		result.Collections = (int)Performance.report.memoryCollections;
		result.NetworkIn = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)3) : 0);
		result.NetworkOut = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)1) : 0);
		result.Restarting = SingletonComponent<ServerMgr>.Instance.Restarting;
		result.SaveCreatedTime = SaveRestore.SaveCreatedTime.ToString();
		result.Version = 2585;
		result.Protocol = Protocol.printable;
		return result;
	}

	[ServerVar(Help = "Get information about this build")]
	public static BuildInfo BuildInfo()
	{
		return BuildInfo.Current;
	}

	[ServerVar]
	public static void AdminUI_FullRefresh(Arg arg)
	{
		AdminUI_RequestPlayerList(arg);
		AdminUI_RequestServerInfo(arg);
		AdminUI_RequestServerConvars(arg);
		AdminUI_RequestUGCList(arg);
	}

	[ServerVar]
	public static void AdminUI_RequestPlayerList(Arg arg)
	{
		if (allowAdminUI)
		{
			ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceivePlayerList", JsonConvert.SerializeObject((object)playerlist()));
		}
	}

	[ServerVar]
	public static void AdminUI_RequestServerInfo(Arg arg)
	{
		if (allowAdminUI)
		{
			ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveServerInfo", JsonConvert.SerializeObject((object)ServerInfo()));
		}
	}

	[ServerVar]
	public static void AdminUI_RequestServerConvars(Arg arg)
	{
		if (!allowAdminUI)
		{
			return;
		}
		List<ServerConvarInfo> list = Pool.Get<List<ServerConvarInfo>>();
		Command[] all = Index.All;
		foreach (Command val in all)
		{
			if (val.Server && val.Variable && val.ServerAdmin && val.ShowInAdminUI)
			{
				list.Add(new ServerConvarInfo
				{
					FullName = val.FullName,
					Value = val.GetOveride?.Invoke(),
					Help = val.Description
				});
			}
		}
		ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveCommands", JsonConvert.SerializeObject((object)list));
		Pool.FreeUnmanaged<ServerConvarInfo>(ref list);
	}

	[ServerVar]
	public static void AdminUI_RequestUGCList(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!allowAdminUI)
		{
			return;
		}
		List<ServerUGCInfo> list = Pool.Get<List<ServerUGCInfo>>();
		uint[] array = null;
		ulong[] array2 = null;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				array = null;
				array2 = null;
				UGCType uGCType = UGCType.ImageJpg;
				string text = string.Empty;
				if (((Component)current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
				{
					if ((Object)(object)iUGCBrowserEntity.UgcEntity == (Object)null)
					{
						continue;
					}
					array = iUGCBrowserEntity.GetContentCRCs;
					array2 = iUGCBrowserEntity.EditingHistory.ToArray();
					uGCType = iUGCBrowserEntity.ContentType;
					text = iUGCBrowserEntity.ContentString;
				}
				bool flag = false;
				if (array != null)
				{
					uint[] array3 = array;
					for (int i = 0; i < array3.Length; i++)
					{
						if (array3[i] != 0)
						{
							flag = true;
							break;
						}
					}
				}
				if (uGCType == UGCType.PatternBoomer)
				{
					flag = true;
				}
				if (uGCType == UGCType.VendingMachine && !string.IsNullOrEmpty(text))
				{
					flag = true;
				}
				if (flag)
				{
					list.Add(new ServerUGCInfo
					{
						entityId = current.net.ID.Value,
						crcs = array,
						contentType = uGCType,
						entityPrefabID = current.prefabID,
						shortPrefabName = current.ShortPrefabName,
						playerIds = array2,
						contentString = text
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveUGCList", JsonConvert.SerializeObject((object)list));
		Pool.FreeUnmanaged<ServerUGCInfo>(ref list);
	}

	[ServerVar]
	public static void AdminUI_RequestUGCContent(Arg arg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (allowAdminUI && !((Object)(object)arg.Player() == (Object)null))
		{
			uint uInt = arg.GetUInt(0, 0u);
			NetworkableId entityID = arg.GetEntityID(1);
			FileStorage.Type @int = (FileStorage.Type)arg.GetInt(2, 0);
			uint uInt2 = arg.GetUInt(3, 0u);
			byte[] array = FileStorage.server.Get(uInt, @int, entityID, uInt2);
			if (array != null)
			{
				SendInfo val = default(SendInfo);
				((SendInfo)(ref val))..ctor(arg.Connection);
				val.channel = 2;
				val.method = (SendMethod)0;
				SendInfo sendInfo = val;
				arg.Player().ClientRPC(RpcTarget.SendInfo("AdminReceivedUGC", sendInfo), uInt, (uint)array.Length, array, uInt2, (byte)@int);
			}
		}
	}

	[ServerVar]
	public static void AdminUI_DeleteUGCContent(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!allowAdminUI)
		{
			return;
		}
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			FileStorage.server.RemoveAllByEntity(entityID);
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			if (((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
			{
				iUGCBrowserEntity.ClearContent();
			}
		}
	}

	[ServerVar]
	public static void AdminUI_RequestFireworkPattern(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (allowAdminUI)
		{
			NetworkableId entityID = arg.GetEntityID(0);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
			if ((Object)(object)baseNetworkable != (Object)null && baseNetworkable is PatternFirework patternFirework)
			{
				SendInfo val = default(SendInfo);
				((SendInfo)(ref val))..ctor(arg.Connection);
				val.channel = 2;
				val.method = (SendMethod)0;
				SendInfo sendInfo = val;
				arg.Player().ClientRPC<NetworkableId, byte[]>(RpcTarget.SendInfo("AdminReceivedPatternFirework", sendInfo), entityID, patternFirework.Design.ToProtoBytes());
			}
		}
	}

	[ServerVar]
	public static void clearugcentity(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
		if ((Object)(object)baseNetworkable != (Object)null && ((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
		{
			iUGCBrowserEntity.ClearContent();
			arg.ReplyWith($"Cleared content on {baseNetworkable.ShortPrefabName}/{entityID}");
		}
		else
		{
			arg.ReplyWith($"Could not find UGC entity with id {entityID}");
		}
	}

	[ServerVar]
	public static void clearugcentitiesinrange(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		float @float = arg.GetFloat(1, 0f);
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (((Component)current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && Vector3.Distance(((Component)current).transform.position, vector) <= @float)
				{
					iUGCBrowserEntity.ClearContent();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num} UGC entities within {@float}m of {vector}");
	}

	[ServerVar]
	public static void clearVendingMachineNamesContaining(Arg arg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				if (((Component)enumerator.Current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && iUGCBrowserEntity.ContentType == UGCType.VendingMachine && StringEx.Contains(iUGCBrowserEntity.ContentString, @string, CompareOptions.IgnoreCase | CompareOptions.IgnoreSymbols))
				{
					iUGCBrowserEntity.ClearContent();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num} vending machines containing {@string}");
	}

	[ServerVar]
	public static void clearUGCByPlayer(Arg arg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong num = (((Object)(object)playerOrSleeper == (Object)null) ? arg.GetULong(0, 0uL) : playerOrSleeper.userID.Get());
		int num2 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				if (((Component)enumerator.Current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && iUGCBrowserEntity.EditingHistory.Contains(num))
				{
					iUGCBrowserEntity.ClearContent();
					num2++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num2} UGC entities modified by {(((Object)(object)playerOrSleeper != (Object)null) ? playerOrSleeper.displayName : ((object)num))}");
	}

	[ServerVar]
	public static void getugcinfo(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
		if ((Object)(object)baseNetworkable != (Object)null && ((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && (Object)(object)iUGCBrowserEntity.UgcEntity != (Object)null)
		{
			ServerUGCInfo serverUGCInfo = new ServerUGCInfo(iUGCBrowserEntity);
			arg.ReplyWith(JsonConvert.SerializeObject((object)serverUGCInfo));
		}
		else
		{
			arg.ReplyWith($"Invalid entity id: {entityID}");
		}
	}

	[ServerVar(Help = "Returns all entities that the provided player is authed to (TC's, locks, etc), supports --json")]
	public static void authcount(Arg arg)
	{
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Expected O, but got Unknown
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			arg.ReplyWith("Please provide a valid player, unable to find '" + arg.GetString(0, "") + "'");
			return;
		}
		string playerName = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(num);
		string text = arg.GetString(1, "");
		if (text == "--json")
		{
			text = string.Empty;
		}
		List<EntityAssociation> list = Pool.Get<List<EntityAssociation>>();
		FindEntityAssociationsForPlayer(num, useOwnerId: false, useAuth: true, text, list);
		TextTable val = new TextTable();
		val.AddColumns(new string[4] { "Prefab name", "Position", "ID", "Type" });
		foreach (EntityAssociation item in list)
		{
			string[] obj = new string[4]
			{
				item.TargetEntity.ShortPrefabName,
				null,
				null,
				null
			};
			Vector3 position = ((Component)item.TargetEntity).transform.position;
			obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[2] = ((object)(NetworkableId)(ref item.TargetEntity.net.ID)/*cast due to .constrained prefix*/).ToString();
			obj[3] = item.AssociationType.ToString();
			val.AddRow(obj);
		}
		Pool.FreeUnmanaged<EntityAssociation>(ref list);
		if (arg.HasArg("--json", false))
		{
			arg.ReplyWith(val.ToJson(true));
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Found entities " + playerName + " is authed to");
		stringBuilder.AppendLine(((object)val).ToString());
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(Help = "Returns all entities that the provided player has placed, supports --json")]
	public static void entcount(Arg arg)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Expected O, but got Unknown
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		ulong uLong = arg.GetULong(0, 0uL);
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(uLong))
		{
			arg.ReplyWith($"Please provide a valid player, unable to find '{uLong}'");
			return;
		}
		string playerName = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(uLong);
		string text = arg.GetString(1, "");
		if (text == "--json")
		{
			text = string.Empty;
		}
		List<EntityAssociation> list = Pool.Get<List<EntityAssociation>>();
		FindEntityAssociationsForPlayer(uLong, useOwnerId: true, useAuth: false, text, list);
		TextTable val = new TextTable();
		val.AddColumns(new string[3] { "Prefab name", "Position", "ID" });
		foreach (EntityAssociation item in list)
		{
			string[] obj = new string[3]
			{
				item.TargetEntity.ShortPrefabName,
				null,
				null
			};
			Vector3 position = ((Component)item.TargetEntity).transform.position;
			obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
			obj[2] = ((object)(NetworkableId)(ref item.TargetEntity.net.ID)/*cast due to .constrained prefix*/).ToString();
			val.AddRow(obj);
		}
		Pool.FreeUnmanaged<EntityAssociation>(ref list);
		if (arg.HasArg("--json", false))
		{
			arg.ReplyWith(val.ToJson(true));
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Found entities associated with " + playerName);
		stringBuilder.AppendLine(((object)val).ToString());
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void FindEntityAssociationsForPlayer(ulong steamId, bool useOwnerId, bool useAuth, string filter, List<EntityAssociation> results)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		results.Clear();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				EntityAssociationType entityAssociationType = EntityAssociationType.Owner;
				if (!(current is BaseEntity baseEntity))
				{
					continue;
				}
				bool flag = false;
				if (useOwnerId && baseEntity.OwnerID == steamId)
				{
					flag = true;
				}
				if (useAuth && !flag)
				{
					if (!flag && baseEntity is BuildingPrivlidge buildingPrivlidge && buildingPrivlidge.IsAuthed(steamId))
					{
						flag = true;
					}
					if (!flag && baseEntity is KeyLock keyLock && keyLock.OwnerID == steamId)
					{
						flag = true;
					}
					else if (baseEntity is CodeLock codeLock)
					{
						if (codeLock.whitelistPlayers.Contains(steamId))
						{
							flag = true;
						}
						else if (codeLock.guestPlayers.Contains(steamId))
						{
							flag = true;
							entityAssociationType = EntityAssociationType.LockGuest;
						}
					}
					if (!flag && baseEntity is ModularCar { IsLockable: not false } modularCar && modularCar.CarLock.HasLockPermission(steamId))
					{
						flag = true;
					}
					if (flag && entityAssociationType == EntityAssociationType.Owner)
					{
						entityAssociationType = EntityAssociationType.Auth;
					}
				}
				if (flag && !string.IsNullOrEmpty(filter) && !StringEx.Contains(current.ShortPrefabName, filter, CompareOptions.IgnoreCase))
				{
					flag = false;
				}
				if (flag)
				{
					results.Add(new EntityAssociation
					{
						TargetEntity = baseEntity,
						AssociationType = entityAssociationType
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


private enum ChangeGradeMode
{
	Upgrade,
	Downgrade
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct PlayerInfo
{
	public string SteamID;

	public string OwnerSteamID;

	public string DisplayName;

	public int Ping;

	public string Address;

	public int ConnectedSeconds;

	public float VoiationLevel;

	public float CurrentLevel;

	public float UnspentXp;

	public float Health;
}


using UnityEngine.Scripting;

[JsonModel]
[Preserve]
public struct ServerInfoOutput
{
	public string Hostname;

	public int MaxPlayers;

	public int Players;

	public int Queued;

	public int Joining;

	public int ReservedSlots;

	public int EntityCount;

	public string GameTime;

	public int Uptime;

	public string Map;

	public float Framerate;

	public int Memory;

	public int MemoryUsageSystem;

	public int Collections;

	public int NetworkIn;

	public int NetworkOut;

	public bool Restarting;

	public string SaveCreatedTime;

	public int Version;

	public string Protocol;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct ServerConvarInfo
{
	public string FullName;

	public string Value;

	public string Help;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct ServerUGCInfo
{
	public ulong entityId;

	public uint[] crcs;

	public UGCType contentType;

	public uint entityPrefabID;

	public string shortPrefabName;

	public ulong[] playerIds;

	public string contentString;

	public ServerUGCInfo(IUGCBrowserEntity fromEntity)
	{
		entityId = fromEntity.UgcEntity.net.ID.Value;
		crcs = fromEntity.GetContentCRCs;
		contentType = fromEntity.ContentType;
		entityPrefabID = fromEntity.UgcEntity.prefabID;
		shortPrefabName = fromEntity.UgcEntity.ShortPrefabName;
		playerIds = fromEntity.EditingHistory.ToArray();
		contentString = fromEntity.ContentString;
	}
}


private struct EntityAssociation
{
	public BaseEntity TargetEntity;

	public EntityAssociationType AssociationType;
}


private enum EntityAssociationType
{
	Owner,
	Auth,
	LockGuest
}


[Factory("antihack")]
public class AntiHack : ConsoleSystem
{
	[ReplicatedVar(Default = "0.22")]
	[Help("collider margin when checking for noclipping on dismount")]
	public static float noclip_margin_dismount = 0.22f;

	[ReplicatedVar(Default = "0.01")]
	[Help("collider backtracking when checking for noclipping")]
	public static float noclip_backtracking = 0.01f;

	[ServerVar]
	[Help("report violations to the anti cheat backend")]
	public static bool reporting = false;

	[ServerVar]
	[Help("are admins allowed to use their admin cheat")]
	public static bool admincheat = true;

	[ServerVar]
	[Help("use antihack to verify object placement by players")]
	public static bool objectplacement = true;

	[ServerVar]
	[Help("use antihack to verify model state sent by players")]
	public static bool modelstate = true;

	[ServerVar]
	[Help("whether or not to force the position on the client")]
	public static bool forceposition = true;

	[ServerVar]
	[Help("0 == allow RPCs from stalled players, 1 == ignore RPCs from currently stalled players, 2 == ignore RPCs from recently stalled players")]
	public static int rpcstallmode = 1;

	[Help("time in seconds before player is no longer treated as wasStalled")]
	[ServerVar]
	public static float rpcstallfade = 2.5f;

	[ServerVar]
	[Help("time in seconds we can receive no ticks for before player is considered stalling")]
	public static float rpcstallthreshold = 0.8f;

	[ServerVar]
	[Help("0 == users, 1 == admins, 2 == developers")]
	public static int userlevel = 2;

	[ServerVar]
	[Help("0 == no enforcement, 1 == kick, 2 == ban (DISABLED)")]
	public static int enforcementlevel = 1;

	[ServerVar]
	[Help("max allowed client desync, lower value = more false positives")]
	public static float maxdesync = 0.8f;

	[ServerVar]
	[Help("max allowed client tick interval delta time, lower value = more false positives")]
	public static float maxdeltatime = 1f;

	[ServerVar]
	[Help("for how many seconds to keep a tick history to use for distance checks")]
	public static float tickhistorytime = 0.5f;

	[ServerVar]
	[Help("how much forgiveness to add when checking the distance from the player tick history")]
	public static float tickhistoryforgiveness = 0.1f;

	[ServerVar]
	[Help("the rate at which violation values go back down")]
	public static float relaxationrate = 0.1f;

	[ServerVar]
	[Help("the time before violation values go back down")]
	public static float relaxationpause = 10f;

	[ServerVar]
	[Help("violation value above this results in enforcement")]
	public static float maxviolation = 100f;

	[ServerVar]
	[Help("0 == disabled, 1 == enabled")]
	public static int terrain_protection = 1;

	[ServerVar]
	[Help("how many slices to subdivide players into for the terrain check")]
	public static int terrain_timeslice = 64;

	[Help("how far to penetrate the terrain before violating")]
	[ServerVar]
	public static float terrain_padding = 0.3f;

	[ServerVar]
	[Help("violation penalty to hand out when terrain is detected")]
	public static float terrain_penalty = 100f;

	[ServerVar]
	[Help("whether or not to kill the player when terrain is detected")]
	public static bool terrain_kill = true;

	[ServerVar]
	[Help("whether or not to check for player inside geometry like rocks as well as base terrain")]
	public static bool terrain_check_geometry = false;

	[ServerVar]
	[Help("0 == disabled, 1 == ray, 2 == sphere, 3 == curve")]
	public static int noclip_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when noclip is detected")]
	public static bool noclip_reject = true;

	[Help("violation penalty to hand out when noclip is detected")]
	[ServerVar]
	public static float noclip_penalty = 0f;

	[ServerVar]
	[Help("collider margin when checking for noclipping")]
	public static float noclip_margin = 0.09f;

	[Help("movement curve step size, lower value = less false positives")]
	[ServerVar]
	public static float noclip_stepsize = 0.1f;

	[ServerVar]
	[Help("movement curve max steps, lower value = more false positives")]
	public static int noclip_maxsteps = 15;

	[Help("0 == disabled, 1 == simple, 2 == advanced, 3 == vertical swim protection")]
	[ServerVar]
	public static int speedhack_protection = 3;

	[Help("whether or not to reject movement when speedhack is detected")]
	[ServerVar]
	public static bool speedhack_reject = true;

	[ServerVar]
	[Help("violation penalty to hand out when speedhack is detected")]
	public static float speedhack_penalty = 0f;

	[Help("speed threshold to assume speedhacking, lower value = more false positives")]
	[ServerVar]
	public static float speedhack_forgiveness = 2f;

	[Help("speed threshold to assume speedhacking, lower value = more false positives")]
	[ServerVar]
	public static float speedhack_forgiveness_inertia = 10f;

	[ServerVar]
	[Help("speed forgiveness when moving down slopes, lower value = more false positives")]
	public static float speedhack_slopespeed = 10f;

	[Help("0 == disabled, 1 == client, 2 == capsule, 3 == curve")]
	[ServerVar]
	public static int flyhack_protection = 3;

	[Help("whether or not to reject movement when flyhack is detected")]
	[ServerVar]
	public static bool flyhack_reject = true;

	[Help("violation penalty to hand out when flyhack is detected")]
	[ServerVar]
	public static float flyhack_penalty = 100f;

	[ServerVar]
	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	public static float flyhack_forgiveness_vertical = 1f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_vertical_inertia = 7f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_horizontal = 1.5f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_horizontal_inertia = 10f;

	[ServerVar]
	[Help("collider downwards extrusion when checking for flyhacking")]
	public static float flyhack_extrusion = 2f;

	[Help("collider margin when checking for flyhacking")]
	[ServerVar]
	public static float flyhack_margin = 0.1f;

	[ServerVar]
	[Help("movement curve step size, lower value = less false positives")]
	public static float flyhack_stepsize = 0.1f;

	[ServerVar]
	[Help("movement curve max steps, lower value = more false positives")]
	public static int flyhack_maxsteps = 15;

	[ServerVar]
	[Help("Optimizes checks by using cached water info. Originally off")]
	public static bool flyhack_usecachedstate = true;

	[ServerVar]
	[Help("serverside fall damage, requires flyhack_protection >= 2 for proper functionality")]
	public static bool serverside_fall_damage = false;

	[Help("0 == disabled, 1 == speed, 2 == speed + entity, 3 == speed + entity + LOS, 4 == speed + entity + LOS + trajectory, 5 == speed + entity + LOS + trajectory + update, 6 == speed + entity + LOS + trajectory + tickhistory")]
	[ServerVar]
	public static int projectile_protection = 6;

	[ServerVar]
	[Help("violation penalty to hand out when projectile hack is detected")]
	public static float projectile_penalty = 0f;

	[ServerVar]
	[Help("projectile speed forgiveness in percent, lower value = more false positives")]
	public static float projectile_forgiveness = 0.5f;

	[ServerVar]
	[Help("projectile server frames to include in delay, lower value = more false positives")]
	public static float projectile_serverframes = 2f;

	[ServerVar]
	[Help("projectile client frames to include in delay, lower value = more false positives")]
	public static float projectile_clientframes = 2f;

	[ServerVar]
	[Help("projectile trajectory forgiveness, lower value = more false positives")]
	public static float projectile_trajectory = 2f;

	[ServerVar]
	[Help("projectile trajectory forgiveness for projectile updates, lower value = more false positives")]
	public static float projectile_trajectory_update = 0.02f;

	[ServerVar]
	[Help("projectile penetration angle change, lower value = more false positives")]
	public static float projectile_anglechange = 60f;

	[ServerVar]
	[Help("projectile penetration velocity change, lower value = more false positives")]
	public static float projectile_velocitychange = 1.1f;

	[ServerVar]
	[Help("projectile desync forgiveness, lower value = more false positives")]
	public static float projectile_desync = 1f;

	[ServerVar]
	[Help("projectile backtracking when checking for LOS")]
	public static float projectile_backtracking = 0.01f;

	[ServerVar]
	[Help("line of sight directional forgiveness when checking eye or center position")]
	public static float projectile_losforgiveness = 0.2f;

	[ServerVar]
	[Help("how often a projectile is allowed to penetrate something before its damage is ignored")]
	public static int projectile_damagedepth = 2;

	[ServerVar]
	[Help("how often a projectile is allowed to penetrate something before its impact spawn is ignored")]
	public static int projectile_impactspawndepth = 1;

	[ServerVar]
	[Help("whether or not to include terrain in the projectile LOS checks")]
	public static bool projectile_terraincheck = true;

	[Help("whether or not to include vehicles in the projectile LOS checks")]
	[ServerVar]
	public static bool projectile_vehiclecheck = true;

	[Help("whether or not to compensate for the client / server vehicle position offset")]
	[ServerVar]
	public static bool projectile_positionoffset = true;

	[ServerVar]
	[Help("minimum distance before we verify client projectile distance mismatch, lower value = more false positives")]
	public static float projectile_distance_forgiveness_minimum = 25f;

	[Help("maximum number of projectile updates to allow before rejecting damage")]
	[ServerVar]
	public static int projectile_update_limit = 4;

	[ServerVar]
	[Help("0 == disabled, 1 == initiator, 2 == initiator + target, 3 == initiator + target + LOS, 4 == initiator + target + LOS + tickhistory")]
	public static int melee_protection = 4;

	[ServerVar]
	[Help("violation penalty to hand out when melee hack is detected")]
	public static float melee_penalty = 0f;

	[ServerVar]
	[Help("melee distance forgiveness in percent, lower value = more false positives")]
	public static float melee_forgiveness = 0.5f;

	[ServerVar]
	[Help("melee server frames to include in delay, lower value = more false positives")]
	public static float melee_serverframes = 2f;

	[ServerVar]
	[Help("melee client frames to include in delay, lower value = more false positives")]
	public static float melee_clientframes = 2f;

	[ServerVar]
	[Help("melee backtracking when checking for LOS")]
	public static float melee_backtracking = 0.01f;

	[ServerVar]
	[Help("line of sight directional forgiveness when checking eye or center position")]
	public static float melee_losforgiveness = 0.2f;

	[Help("whether or not to include terrain in the melee LOS checks")]
	[ServerVar]
	public static bool melee_terraincheck = true;

	[ServerVar]
	[Help("whether or not to include vehicles in the melee LOS checks")]
	public static bool melee_vehiclecheck = true;

	[ServerVar]
	[Help("0 == disabled, 1 == distance, 2 == distance + LOS, 3 = distance + LOS + altitude, 4 = distance + LOS + altitude + noclip, 5 = distance + LOS + altitude + noclip + history")]
	public static int eye_protection = 4;

	[ServerVar]
	[Help("violation penalty to hand out when eye hack is detected")]
	public static float eye_penalty = 0f;

	[Help("eye distance forgiveness, lower value = more false positives")]
	[ServerVar]
	public static float eye_forgiveness = 0.4f;

	[ServerVar]
	[Help("eye distance forgiveness for parented or mounted players, lower value = more false positives")]
	public static float eye_distance_parented_mounted_forgiveness = 2f;

	[ServerVar]
	[Help("eye server frames to include in delay, lower value = more false positives")]
	public static float eye_serverframes = 2f;

	[ServerVar]
	[Help("eye client frames to include in delay, lower value = more false positives")]
	public static float eye_clientframes = 2f;

	[Help("whether or not to include terrain in the eye LOS checks")]
	[ServerVar]
	public static bool eye_terraincheck = true;

	[Help("whether or not to include vehicles in the eye LOS checks")]
	[ServerVar]
	public static bool eye_vehiclecheck = true;

	[ServerVar]
	[Help("distance at which to start testing eye noclipping")]
	public static float eye_noclip_cutoff = 0.06f;

	[ServerVar]
	[Help("collider margin when checking for noclipping")]
	public static float eye_noclip_margin = 0.25f;

	[ServerVar]
	[Help("collider backtracking when checking for noclipping")]
	public static float eye_noclip_backtracking = 0.01f;

	[ServerVar]
	[Help("line of sight sphere cast radius, 0 == raycast")]
	public static float eye_losradius = 0.18f;

	[Help("violation penalty to hand out when eye history mismatch is detected")]
	[ServerVar]
	public static float eye_history_penalty = 100f;

	[ServerVar]
	[Help("how much forgiveness to add when checking the distance between player tick history and player eye history")]
	public static float eye_history_forgiveness = 0.1f;

	[ServerVar]
	[Help("maximum distance an impact effect can be from the entities bounds")]
	public static float impact_effect_distance_forgiveness = 0.45f;

	[ServerVar]
	[Help("line of sight sphere cast radius, 0 == raycast")]
	public static float build_losradius = 0.01f;

	[ServerVar]
	[Help("line of sight sphere cast radius, 0 == raycast")]
	public static float build_losradius_sleepingbag = 0.3f;

	[Help("whether or not to include terrain in the build LOS checks")]
	[ServerVar]
	public static bool build_terraincheck = true;

	[Help("whether or not to include vehicles in the build LOS checks")]
	[ServerVar]
	public static bool build_vehiclecheck = true;

	[Help("whether or not to check for building being done on the wrong side of something (e.g. inside rocks). 0 = Disabled, 1 = Info only, 2 = Enabled")]
	[ServerVar]
	public static int build_inside_check = 2;

	[ServerVar]
	[Help("the maximum distance we check for for inside mesh")]
	public static float mesh_inside_check_distance = 50f;

	[ServerVar]
	[Help("use the older, simpler is inside check. has several loopholes that aren't properly catered to")]
	public static bool use_legacy_mesh_inside_check = true;

	[ServerVar]
	[Help("whether or not to ensure players are always networked to server administrators")]
	public static bool server_occlusion_admin_bypass = false;

	[ServerVar]
	[Help("number of blocked grids permitted before line-of-sight fails")]
	public static int server_occlusion_blocked_grid_threshold = 0;

	[ServerVar]
	[Help("number of neighbour checks permitted before line-of-sight fails")]
	public static int server_occlusion_neighbour_threshold = 2;

	[Help("whether to use server occlusion caching")]
	[ServerVar]
	public static bool server_occlusion_caching = true;

	[ServerVar]
	[Help("whether to save sub grid for map to a file on first time init, faster subsequent server launching")]
	public static bool server_occlusion_save_grid = true;

	[ServerVar]
	[Help("whether to use neighbour threshold limitations")]
	public static bool server_occlusion_use_neighbour_thresholds = false;

	[ServerVar]
	[Help("whether or not to skip the line-of-sight process, this will effectively disable server occlusion")]
	public static bool server_occlusion_disable_los = false;

	[ServerVar]
	[Help("How far a player is allowed to move in a single tick")]
	public static float tick_max_distance = 1.1f;

	[Help("How far a player is allowed to move in a single tick when falling")]
	[ServerVar]
	public static float tick_max_distance_falling = 4f;

	[Help("How far a player is allowed to move in a single tick when parented")]
	[ServerVar]
	public static float tick_max_distance_parented = 3f;

	[Help("Whether or not to enable additional tick validation measures")]
	[ServerVar]
	public static bool tick_buffer_preventions = true;

	[Help("How many seconds worth of ticks can be sent before server tick finalizing before we revert to noclip_protection 2")]
	[ServerVar]
	public static float tick_buffer_noclip_threshold = 2f;

	[ServerVar]
	[Help("How many seconds worth of ticks can be sent before server tick finalizing before we reject movement")]
	public static float tick_buffer_reject_threshold = 3f;

	[ServerVar]
	[Help("How long it should take for a server to process a frame before we decide to skip additional tick validation measures")]
	public static float tick_buffer_server_lag_threshold = 0.3f;

	[Help("How far a player is allowed to move in forgiveness scenarios")]
	[ServerVar]
	public static float tick_distance_forgiveness = 5f;

	[ServerVar]
	[Help("How long, in seconds, can the clients progress timer deviate from the servers")]
	public static float rpc_timer_forgiveness = 1f;

	[ServerVar]
	[Help("0 == silent, 1 == print max violation, 2 == print nonzero violation, 3 == print any violation except noclip, 4 == print any violation")]
	public static int debuglevel = 1;
}


using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch.Extend;
using Steamworks;
using UnityEngine;

[Factory("app")]
public class App : ConsoleSystem
{
	[ServerVar]
	public static string listenip = "";

	[ServerVar]
	public static int port;

	[ServerVar]
	public static string publicip = "";

	[ServerVar(Help = "Disables updating entirely - emergency use only")]
	public static bool update = true;

	[ServerVar(Help = "Enables sending push notifications")]
	public static bool notifications = true;

	[ServerVar(Help = "Max number of queued messages - set to 0 to disable message processing")]
	public static int queuelimit = 100;

	[ReplicatedVar(Default = "")]
	public static string serverid = "";

	[ServerVar(Help = "Cooldown time before alarms can send another notification (in seconds)")]
	public static float alarmcooldown = 30f;

	[ServerVar]
	public static int maxconnections = 500;

	[ServerVar]
	public static int maxconnectionsperip = 5;

	[ServerVar]
	public static int maxmessagesize = 1048576;

	[ServerUserVar]
	public static async void pair(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Dictionary<string, string> playerPairingData = Util.GetPlayerPairingData(basePlayer);
			NotificationSendResult notificationSendResult = await Util.SendPairNotification("server", basePlayer, StringExtensions.Truncate(ConVar.Server.hostname, 128, (string)null), "Tap to pair with this server.", playerPairingData);
			arg.ReplyWith((notificationSendResult == NotificationSendResult.Sent) ? "Sent pairing notification." : notificationSendResult.ToErrorMessage().english);
		}
	}

	[ServerUserVar]
	public static void regeneratetoken(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			SingletonComponent<ServerMgr>.Instance.persistance.RegenerateAppToken(basePlayer.userID);
			arg.ReplyWith("Regenerated Rust+ token");
		}
	}

	[ServerVar]
	public static void info(Arg arg)
	{
		if (!CompanionServer.Server.IsEnabled)
		{
			arg.ReplyWith("Companion server is not enabled");
			return;
		}
		Listener listener = CompanionServer.Server.Listener;
		arg.ReplyWith($"Server ID: {serverid}\nListening on: {listener.Address}:{listener.Port}\nApp connects to: {GetPublicIP()}:{port}");
	}

	[ServerVar(Help = "Retry initializing the Rust+ companion server if it previously failed")]
	public static void retry_initialize(Arg arg)
	{
		if (CompanionServer.Server.IsEnabled)
		{
			arg.ReplyWith("Companion server is already initialized!");
			return;
		}
		if (port < 0)
		{
			arg.ReplyWith("Companion server port is invalid, cannot initialize companion server");
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.rustPlus)
		{
			arg.ReplyWith("Companion server is disabled by gamemode, cannot initialize companion server");
			return;
		}
		arg.ReplyWith("Trying to initialize companion server...");
		CompanionServer.Server.Initialize();
	}

	[ServerVar]
	public static void resetlimiter(Arg arg)
	{
		CompanionServer.Server.Listener?.Limiter?.Clear();
	}

	[ServerVar]
	public static void connections(Arg arg)
	{
		string text = CompanionServer.Server.Listener?.Limiter?.ToString() ?? "Not available";
		arg.ReplyWith(text);
	}

	[ServerVar]
	public static void appban(Arg arg)
	{
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			arg.ReplyWith("Usage: app.appban <steamID64>");
			return;
		}
		string text = (SingletonComponent<ServerMgr>.Instance.persistance.SetAppTokenLocked(uLong, locked: true) ? $"Banned {uLong} from using the companion app" : $"{uLong} is already banned from using the companion app");
		arg.ReplyWith(text);
	}

	[ServerVar]
	public static void appunban(Arg arg)
	{
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			arg.ReplyWith("Usage: app.appunban <steamID64>");
			return;
		}
		string text = (SingletonComponent<ServerMgr>.Instance.persistance.SetAppTokenLocked(uLong, locked: false) ? $"Unbanned {uLong}, they can use the companion app again" : $"{uLong} is not banned from using the companion app");
		arg.ReplyWith(text);
	}

	public static IPAddress GetListenIP()
	{
		if (!string.IsNullOrWhiteSpace(listenip))
		{
			if (!IPAddress.TryParse(listenip, out IPAddress address) || address.AddressFamily != AddressFamily.InterNetwork)
			{
				Debug.LogError((object)("Invalid app.listenip: " + listenip));
				return IPAddress.Any;
			}
			return address;
		}
		return IPAddress.Any;
	}

	public static async ValueTask<string> GetPublicIPAsync()
	{
		Stopwatch timer = null;
		string publicIP;
		while (true)
		{
			bool num = timer != null && timer.Elapsed.TotalMinutes > 2.0;
			publicIP = GetPublicIP();
			if (num || (!string.IsNullOrWhiteSpace(publicIP) && publicIP != "0.0.0.0"))
			{
				break;
			}
			if (timer == null)
			{
				timer = Stopwatch.StartNew();
			}
			await Task.Delay(10000);
		}
		return publicIP;
	}

	public static string GetPublicIP()
	{
		if (!string.IsNullOrWhiteSpace(publicip) && IPAddress.TryParse(publicip, out IPAddress address) && address.AddressFamily == AddressFamily.InterNetwork)
		{
			return publicip;
		}
		return SteamServer.PublicIp.ToString();
	}
}


using System;
using UnityEngine;

[Factory("audio")]
public class Audio : ConsoleSystem
{
	[ClientVar(Help = "Volume", Saved = true)]
	public static float master = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float musicvolume = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float musicvolumemenu = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float game = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float voices = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float instruments = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float voiceProps = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float eventAudio = 1f;

	[ClientVar(Help = "Ambience System")]
	public static bool ambience = true;

	[ClientVar(Help = "Max ms per frame to spend updating sounds")]
	public static float framebudget = 0.3f;

	[ClientVar]
	public static float minupdatefraction = 0.1f;

	[ClientVar(Help = "Use more advanced sound occlusion", Saved = true)]
	public static bool advancedocclusion = false;

	[ClientVar(Help = "Use higher quality sound fades on some sounds")]
	public static bool hqsoundfade = false;

	[ClientVar(Saved = false)]
	public static bool debugVoiceLimiting = false;

	[ClientVar]
	public static bool enableSoundPooling = false;

	[ClientVar(Help = "Volume", Saved = true)]
	public static int speakers
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)AudioSettings.speakerMode;
		}
		set
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			value = Mathf.Clamp(value, 2, 7);
			if (!Application.isEditor)
			{
				AudioConfiguration configuration = AudioSettings.GetConfiguration();
				configuration.speakerMode = (AudioSpeakerMode)value;
				TimeWarning val = TimeWarning.New("Audio Settings Reset", 250);
				try
				{
					AudioSettings.Reset(configuration);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
		}
	}

	[ClientVar]
	public static void printSounds(Arg arg)
	{
	}

	[ClientVar(ClientAdmin = true, Help = "print active engine sound info")]
	public static void printEngineSounds(Arg arg)
	{
	}
}


[Factory("batching")]
public class Batching : ConsoleSystem
{
	[ClientVar]
	public static bool renderers = true;

	[ClientVar]
	public static bool renderer_threading = true;

	[ClientVar]
	public static int renderer_capacity = 30000;

	[ClientVar]
	public static int renderer_vertices = 1000;

	[ClientVar]
	public static int renderer_submeshes = 1;

	[ClientVar]
	[ServerVar]
	public static int verbose = 0;
}


using UnityEngine;

[Factory("bradley")]
public class Bradley : ConsoleSystem
{
	[ServerVar]
	public static float respawnDelayMinutes = 60f;

	[ServerVar]
	public static float respawnDelayVariance = 1f;

	[ServerVar]
	public static bool enabled = true;

	[ServerVar]
	public static void quickrespawn(Arg arg)
	{
		if (!Object.op_Implicit((Object)(object)arg.Player()))
		{
			return;
		}
		BradleySpawner singleton = BradleySpawner.singleton;
		if ((Object)(object)singleton == (Object)null)
		{
			Debug.LogWarning((object)"No Spawner");
			return;
		}
		if (Object.op_Implicit((Object)(object)singleton.spawned))
		{
			singleton.spawned.Kill();
		}
		singleton.spawned = null;
		singleton.DoRespawn();
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using CircularBuffer;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;

[Factory("chat")]
public class Chat : ConsoleSystem
{
	public enum ChatChannel
	{
		Global = 0,
		Team = 1,
		Server = 2,
		Cards = 3,
		Local = 4,
		Clan = 5,
		ExternalDM = 6,
		MaxValue = 6
	}

	public struct ChatEntry
	{
		public ChatChannel Channel { get; set; }

		public string Message { get; set; }

		public string UserId { get; set; }

		public string Username { get; set; }

		public string Color { get; set; }

		public int Time { get; set; }
	}

	[ServerVar]
	public static float localChatRange = 100f;

	[ReplicatedVar]
	public static bool globalchat = true;

	[ReplicatedVar]
	public static bool localchat = false;

	private const float textVolumeBoost = 0.2f;

	[ReplicatedVar]
	public static bool hideChatInTutorial = true;

	[ClientVar]
	[ServerVar]
	public static bool enabled = true;

	[ServerVar(Help = "Number of messages to keep in memory for chat history")]
	public static int historysize = 1000;

	public static CircularBuffer<ChatEntry> History = new CircularBuffer<ChatEntry>(historysize);

	[ServerVar]
	public static bool serverlog = true;

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", (object)message, (object)username, (object)color, (object)userid) == null)
		{
			string text = StringEx.EscapeRichText(username, false);
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=" + color + ">" + text + "</color> " + message);
			ChatEntry ce = default(ChatEntry);
			ce.Channel = ChatChannel.Server;
			ce.Message = message;
			ce.UserId = userid.ToString();
			ce.Username = username;
			ce.Color = color;
			ce.Time = Epoch.Current;
			Record(ce);
		}
	}

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (globalchat)
		{
			sayImpl(ChatChannel.Global, arg);
		}
	}

	[ServerUserVar]
	public static void localsay(Arg arg)
	{
		if (localchat)
		{
			sayImpl(ChatChannel.Local, arg);
		}
	}

	[ServerUserVar]
	public static void teamsay(Arg arg)
	{
		sayImpl(ChatChannel.Team, arg);
	}

	[ServerUserVar]
	public static void cardgamesay(Arg arg)
	{
		sayImpl(ChatChannel.Cards, arg);
	}

	[ServerUserVar]
	public static void clansay(Arg arg)
	{
		sayImpl(ChatChannel.Clan, arg);
	}

	private static void sayImpl(ChatChannel targetChannel, Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer player = arg.Player();
		if (!Object.op_Implicit((Object)(object)player) || (hideChatInTutorial && player.IsInTutorial) || player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!player.IsAdmin && !player.IsDeveloper)
		{
			if (player.NextChatTime == 0f)
			{
				player.NextChatTime = Time.realtimeSinceStartup - 30f;
			}
			if (player.NextChatTime > Time.realtimeSinceStartup)
			{
				player.NextChatTime += 2f;
				float num = player.NextChatTime - Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(player.net.connection, "chat.add", 2, 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					player.Kick("Chatting too fast");
				}
				return;
			}
		}
		string @string = arg.GetString(0, "text");
		ValueTask<bool> valueTask = sayAs(targetChannel, player.userID, player.displayName, @string, player);
		Analytics.Azure.OnChatMessage(player, @string, (int)targetChannel);
		player.NextChatTime = Time.realtimeSinceStartup + 1.5f;
		if (valueTask.IsCompletedSuccessfully)
		{
			if (!valueTask.Result)
			{
				player.NextChatTime = Time.realtimeSinceStartup;
			}
			return;
		}
		Task<bool> task = valueTask.AsTask();
		task.GetAwaiter().OnCompleted(delegate
		{
			try
			{
				if (!task.Result)
				{
					player.NextChatTime = Time.realtimeSinceStartup;
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex);
			}
		});
	}

	internal static string GetNameColor(ulong userId, BasePlayer player = null)
	{
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = (((Object)(object)player != (Object)null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string result = "#5af";
		if (flag)
		{
			result = "#af5";
		}
		if (num)
		{
			result = "#fa5";
		}
		return result;
	}

	internal static async ValueTask<bool> sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!Object.op_Implicit((Object)(object)player))
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if ((Object)(object)player != (Object)null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		if ((ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string strChatText = message.Replace("\n", "").Replace("\r", "").Trim();
		if (strChatText.Length > 128)
		{
			strChatText = strChatText.Substring(0, 128);
		}
		if (strChatText.Length <= 0)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnPlayerChat", (object)userId, (object)username, (object)strChatText, (object)targetChannel, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (strChatText.StartsWith("/") || strChatText.StartsWith("\\"))
		{
			return false;
		}
		strChatText = StringEx.EscapeRichText(strChatText, false);
		if (ConVar.Server.emojiOwnershipCheck)
		{
			List<(TmProEmojiRedirector.EmojiSub, int)> list = Pool.Get<List<(TmProEmojiRedirector.EmojiSub, int)>>();
			TmProEmojiRedirector.FindEmojiSubstitutions(strChatText, RustEmojiLibrary.Instance, list, richText: false, isServer: true);
			bool flag = true;
			foreach (var item in list)
			{
				if (!item.Item1.targetEmojiResult.CanBeUsedBy(player))
				{
					flag = false;
					break;
				}
			}
			Pool.FreeUnmanaged<(TmProEmojiRedirector.EmojiSub, int)>(ref list);
			if (!flag)
			{
				Debug.Log((object)"player tried to use emoji they don't own, reject!");
				return false;
			}
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, "[" + targetChannel.ToString() + "] " + username + ": ", ConsoleColor.DarkGreen, strChatText);
			string text = ((object)player)?.ToString() ?? $"{username}[{userId}]";
			switch (targetChannel)
			{
			case ChatChannel.Team:
				DebugEx.Log((object)("[TEAM CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			case ChatChannel.Cards:
				DebugEx.Log((object)("[CARDS CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			case ChatChannel.Clan:
				DebugEx.Log((object)("[CLAN CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			default:
				DebugEx.Log((object)("[CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			}
		}
		string strName = StringEx.EscapeRichText(username, false);
		string nameColor = GetNameColor(userId, player);
		ChatEntry ce = default(ChatEntry);
		ce.Channel = targetChannel;
		ce.Message = strChatText;
		ce.UserId = (((Object)(object)player != (Object)null) ? player.UserIDString : userId.ToString());
		ce.Username = username;
		ce.Color = nameColor;
		ce.Time = Epoch.Current;
		Record(ce);
		switch (targetChannel)
		{
		case ChatChannel.Cards:
		{
			if ((Object)(object)player == (Object)null)
			{
				return false;
			}
			if (!player.isMounted)
			{
				return false;
			}
			BaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;
			if ((Object)(object)baseCardGameEntity == (Object)null || !(baseCardGameEntity.GameController?.IsAtTable(player) ?? false))
			{
				return false;
			}
			List<Connection> list2 = Pool.Get<List<Connection>>();
			baseCardGameEntity.GameController?.GetConnectionsInGame(list2);
			if (list2.Count > 0)
			{
				ConsoleNetwork.SendClientCommand(list2, "chat.add2", 3, userId, strChatText, strName, nameColor, 1f);
			}
			Pool.FreeUnmanaged<Connection>(ref list2);
			return true;
		}
		case ChatChannel.Global:
			ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, strChatText, strName, nameColor, 1f);
			return true;
		case ChatChannel.Local:
		{
			if (!((Object)(object)player != (Object)null))
			{
				break;
			}
			float num = localChatRange * localChatRange;
			Enumerator<BasePlayer> enumerator2 = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BasePlayer current = enumerator2.Current;
					Vector3 val3 = ((Component)current).transform.position - ((Component)player).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (!(sqrMagnitude > num))
					{
						ConsoleNetwork.SendClientCommand(current.net.connection, "chat.add2", 4, userId, strChatText, strName, nameColor, Mathf.Clamp01(sqrMagnitude / num + 0.2f));
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			return true;
		}
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, strChatText, strName, nameColor, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, strName, strChatText, nameColor);
			return true;
		}
		case ChatChannel.Clan:
		{
			ClanManager serverInstance = ClanManager.ServerInstance;
			if ((Object)(object)serverInstance == (Object)null)
			{
				return false;
			}
			if ((Object)(object)player != (Object)null && player.clanId == 0L)
			{
				return false;
			}
			try
			{
				ClanValueResult<IClan> val = ((!((Object)(object)player != (Object)null) || player.clanId == 0L) ? (await serverInstance.Backend.GetByMember(userId)) : (await serverInstance.Backend.Get(player.clanId)));
				ClanValueResult<IClan> val2 = val;
				if (!val2.IsSuccess)
				{
					return false;
				}
				if ((int)(await val2.Value.SendChatMessage(strName, strChatText, userId)) != 1)
				{
					return false;
				}
				return true;
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex);
				return false;
			}
		}
		}
		return false;
	}

	[Help("Return the last x lines of the console. Default is 200")]
	[ServerVar]
	public static IEnumerable<ChatEntry> tail(Arg arg)
	{
		int @int = arg.GetInt(0, 200);
		int num = History.Size - @int;
		if (num < 0)
		{
			num = 0;
		}
		return ((IEnumerable<ChatEntry>)History).Skip(num);
	}

	[Help("Search the console for a particular string")]
	[ServerVar]
	public static IEnumerable<ChatEntry> search(Arg arg)
	{
		string search = arg.GetString(0, (string)null);
		if (search == null)
		{
			return Enumerable.Empty<ChatEntry>();
		}
		return ((IEnumerable<ChatEntry>)History).Where((ChatEntry x) => x.Message.Length < 4096 && StringEx.Contains(x.Message, search, CompareOptions.IgnoreCase));
	}

	public static void Record(ChatEntry ce)
	{
		int num = Mathf.Max(historysize, 10);
		if (History.Capacity != num)
		{
			CircularBuffer<ChatEntry> val = new CircularBuffer<ChatEntry>(num);
			foreach (ChatEntry item in History)
			{
				val.PushBack(item);
			}
			History = val;
		}
		History.PushBack(ce);
		RCon.Broadcast(RCon.LogType.Chat, ce);
	}
}


public enum ChatChannel
{
	Global = 0,
	Team = 1,
	Server = 2,
	Cards = 3,
	Local = 4,
	Clan = 5,
	ExternalDM = 6,
	MaxValue = 6
}


public struct ChatEntry
{
	public ChatChannel Channel { get; set; }

	public string Message { get; set; }

	public string UserId { get; set; }

	public string Username { get; set; }

	public string Color { get; set; }

	public int Time { get; set; }
}


using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Facepunch.Extend;
using UnityEngine;

[Factory("clan")]
public class Clan : ConsoleSystem
{
	[ReplicatedVar(Help = "If enabled then players will need to be near a Clan Table to make changes to clans", Default = "true")]
	public static bool editsRequireClanTable = true;

	[ServerVar(Help = "Enables the clan system if set to true (must be set at boot, requires restart)")]
	public static bool enabled = false;

	[ServerVar(Help = "Maximum number of members each clan can have (local backend only!)")]
	public static int maxMemberCount = 100;

	[ServerVar(Help = "How much score players earn for killing a player in another clan")]
	public static int scoreForKillingPlayerInOtherClan = 10;

	[ServerVar(Help = "How much score players earn for being killed by a player in another clan (this value should be negative)")]
	public static int scoreForKilledByPlayerInOtherClan = -10;

	[ServerVar(Help = "How much score players earn for killing unarmed players (this value should be negative)")]
	public static int scoreForKillingUnarmedPlayer = -10;

	[ServerVar(Help = "How much score players earn for destroying other player's tool cupboards")]
	public static int scoreForDestroyingToolCupboards = 10;

	[ServerVar(Help = "How much score players earn for hacking crates")]
	public static int scoreForHackingCrates = 5;

	[ServerVar(Help = "How much score players earn for opening hacked crates")]
	public static int scoreForOpeningHackedCrates = 5;

	[ServerVar(Help = "How much score players earn for destroying bradley")]
	public static int scoreForDestroyingBradley = 10;

	[ServerVar(Help = "How much score players earn for running the excavator")]
	public static int scoreForRunningExcavator = 10;

	[ServerVar(Help = "How much score players earn for reaching cargo ship")]
	public static int scoreForReachingCargoShip = 10;

	[ServerVar(Help = "How much score players earn for looting an elite crate")]
	public static int scoreForLootingEliteCrate = 10;

	[ServerVar(Help = "Prints info about a clan given its ID")]
	public static void Info(Arg arg)
	{
		if ((Object)(object)ClanManager.ServerInstance == (Object)null)
		{
			arg.ReplyWith("ClanManager is null!");
			return;
		}
		long clanId = arg.GetLong(0, 0L);
		if (clanId == 0L)
		{
			BasePlayer basePlayer = arg.Player();
			if ((Object)(object)basePlayer == (Object)null)
			{
				arg.ReplyWith("Usage: clan.info <clanID>");
			}
			else
			{
				SendClanInfoPlayer(basePlayer);
			}
		}
		else
		{
			SendClanInfoConsole(clanId);
		}
		static string FormatClan(IClan clan)
		{
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Expected O, but got Unknown
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"Clan ID: {clan.ClanId}");
			stringBuilder.AppendLine("Name: " + clan.Name);
			stringBuilder.AppendLine("MoTD: " + clan.Motd);
			stringBuilder.AppendLine("Members:");
			TextTable val3 = new TextTable();
			val3.AddColumns(new string[4] { "steamID", "username", "online", "role" });
			foreach (ClanMember member in clan.Members)
			{
				ClanRole? val4 = List.TryFindWith<ClanRole, int>((IReadOnlyCollection<ClanRole>)clan.Roles, (Func<ClanRole, int>)((ClanRole r) => r.RoleId), member.RoleId, (IEqualityComparer<int>)null);
				string text = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member.SteamId) ?? "[unknown]";
				bool flag = (NexusServer.Started ? NexusServer.IsOnline(member.SteamId) : ServerPlayers.IsOnline(member.SteamId));
				string[] array = new string[4];
				ulong steamId = member.SteamId;
				array[0] = steamId.ToString();
				array[1] = text;
				array[2] = (flag ? "x" : "");
				array[3] = val4?.Name ?? "[null]";
				val3.AddRow(array);
			}
			stringBuilder.Append(val3);
			return stringBuilder.ToString();
		}
		static async void SendClanInfoConsole(long id)
		{
			try
			{
				IClan val5 = await GetClanByID(id);
				if (val5 != null)
				{
					Debug.Log((object)FormatClan(val5));
				}
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
		}
		async void SendClanInfoPlayer(BasePlayer player)
		{
			_ = 1;
			try
			{
				IClan val = ((clanId != 0L) ? (await GetClanByID(clanId)) : (await GetPlayerClan(player)));
				IClan val2 = val;
				if (val2 != null)
				{
					string msg = FormatClan(val2);
					player.ConsoleMessage(msg);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				player.ConsoleMessage(ex.ToString());
			}
		}
	}

	private static async ValueTask<IClan> GetPlayerClan(BasePlayer player)
	{
		ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.GetByMember((ulong)player.userID);
		if (!val.IsSuccess)
		{
			string msg = (((int)val.Result == 3) ? "You're not in a clan!" : "Failed to find your clan!");
			player.ConsoleMessage(msg);
			return null;
		}
		return val.Value;
	}

	private static async ValueTask<IClan> GetClanByID(long clanId, BasePlayer player = null)
	{
		ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.Get(clanId);
		if (!val.IsSuccess)
		{
			string text = (((int)val.Result == 4) ? $"Clan with ID {clanId} was not found!" : $"Failed to get the clan with ID {clanId} ({val.Result})!");
			if ((Object)(object)player != (Object)null)
			{
				player.ConsoleMessage(text);
			}
			else
			{
				Debug.Log((object)text);
			}
			return null;
		}
		return val.Value;
	}

	public static int GetScoreForEvent(ClanScoreEventType eventType)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected I4, but got Unknown
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		return (eventType - -1) switch
		{
			1 => 1, 
			2 => scoreForKillingPlayerInOtherClan, 
			3 => scoreForKilledByPlayerInOtherClan, 
			4 => scoreForKillingUnarmedPlayer, 
			5 => scoreForDestroyingToolCupboards, 
			6 => scoreForHackingCrates, 
			7 => scoreForOpeningHackedCrates, 
			8 => scoreForDestroyingBradley, 
			9 => scoreForRunningExcavator, 
			10 => scoreForReachingCargoShip, 
			11 => scoreForLootingEliteCrate, 
			0 => 0, 
			_ => Unknown(eventType), 
		};
		static int Unknown(ClanScoreEventType type)
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			Debug.LogError((object)$"Unhandled score event type: {type}");
			return 0;
		}
	}
}


[Factory("client")]
public class Client : ConsoleSystem
{
}


using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using UnityEngine;

[Factory("console")]
public class Console : ConsoleSystem
{
	[ServerVar]
	[Help("Return the last x lines of the console. Default is 200")]
	public static IEnumerable<Output.Entry> tail(Arg arg)
	{
		int @int = arg.GetInt(0, 200);
		int num = Output.HistoryOutput.Count - @int;
		if (num < 0)
		{
			num = 0;
		}
		return Output.HistoryOutput.Skip(num);
	}

	[ServerVar]
	[Help("Search the console for a particular string")]
	public static IEnumerable<Output.Entry> search(Arg arg)
	{
		string search = arg.GetString(0, (string)null);
		if (search == null)
		{
			return Enumerable.Empty<Output.Entry>();
		}
		return Output.HistoryOutput.Where((Output.Entry x) => x.Message.Length < 4096 && StringEx.Contains(x.Message, search, CompareOptions.IgnoreCase));
	}
}


[Factory("construct")]
public class Construct : ConsoleSystem
{
	[ServerVar]
	[Help("How many minutes before a placed frame gets destroyed")]
	public static float frameminutes = 30f;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Factory("copypaste")]
public class CopyPaste : ConsoleSystem
{
	private class EntityWrapper
	{
		public BaseEntity Entity;

		public Entity Protobuf;

		public Vector3 Position;

		public Quaternion Rotation;

		public bool HasParent;
	}

	public class PasteOptions
	{
		public const string Argument_NPCs = "--npcs";

		public const string Argument_Resources = "--resources";

		public const string Argument_Vehicles = "--vehicles";

		public const string Argument_Deployables = "--deployables";

		public const string Argument_FoundationsOnly = "--foundations-only";

		public const string Argument_BuildingBlocksOnly = "--building-only";

		public const string Argument_SnapToTerrain = "--autosnap-terrain";

		public const string Argument_PastePlayers = "--players";

		public bool Resources;

		public bool NPCs;

		public bool Vehicles;

		public bool Deployables;

		public bool FoundationsOnly;

		public bool BuildingBlocksOnly;

		public bool SnapToTerrain;

		public bool Players;

		public Vector3 Origin;

		public Quaternion PlayerRotation;

		public Vector3 HeightOffset;

		public PasteOptions(Arg arg)
		{
			Resources = arg.HasArg("--resources", true);
			NPCs = arg.HasArg("--npcs", true);
			Vehicles = arg.HasArg("--vehicles", true);
			Deployables = arg.HasArg("--deployables", true);
			FoundationsOnly = arg.HasArg("--foundations-only", true);
			BuildingBlocksOnly = arg.HasArg("--building-only", true);
			SnapToTerrain = arg.HasArg("--autosnap-terrain", true);
			Players = arg.HasArg("--players", true);
		}

		public PasteOptions(PasteRequest request)
		{
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			Resources = request.resources;
			NPCs = request.npcs;
			Vehicles = request.vehicles;
			Deployables = request.deployables;
			FoundationsOnly = request.foundationsOnly;
			BuildingBlocksOnly = request.buildingBlocksOnly;
			SnapToTerrain = request.snapToTerrain;
			Players = request.players;
			Origin = request.origin;
			PlayerRotation = Quaternion.Euler(request.playerRotation);
			HeightOffset = request.heightOffset;
		}
	}

	private const string ClipboardFileName = "clipboard";

	private const string OverwriteFlag = "--overwrite";

	private static CopyPasteHistoryManager playerHistory = new CopyPasteHistoryManager();

	private static void PrintPasteNames(StringBuilder builder, string directory)
	{
		if (!Directory.Exists(directory))
		{
			builder.AppendLine("No pastes found");
			return;
		}
		string[] files = Directory.GetFiles(directory, "*.data");
		builder.AppendLine($"Found {files.Length} pastes");
		foreach (string item in files.OrderBy((string x) => x))
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(item);
			builder.AppendLine(fileNameWithoutExtension);
		}
	}

	private static void CopyEntities(BasePlayer player, List<BaseEntity> entities, string name, Vector3 originPos, Quaternion originRot)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OrderEntitiesForSave(entities);
		CopyPasteEntityInfo val = Pool.Get<CopyPasteEntityInfo>();
		try
		{
			val.entities = Pool.Get<List<Entity>>();
			Transform transform = new GameObject("Align").transform;
			transform.position = originPos;
			transform.rotation = originRot;
			foreach (BaseEntity entity in entities)
			{
				if (!entity.isClient && entity.enableSaving)
				{
					BaseEntity baseEntity = entity.parentEntity.Get(serverside: true);
					if ((Object)(object)baseEntity != (Object)null && (!entities.Contains(baseEntity) || !baseEntity.enableSaving))
					{
						Debug.LogWarning((object)("Skipping " + entity.ShortPrefabName + " as it is parented to an entity not included in the copy (it would become orphaned)"));
					}
					else
					{
						SaveEntity(entity, val, baseEntity, transform);
					}
				}
			}
			Object.Destroy((Object)(object)((Component)transform).gameObject);
			CopyPasteEntity.ServerInstance?.ClientRPC<string, CopyPasteEntityInfo>(RpcTarget.Player("RecievePaste", player), name, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static List<BaseEntity> PasteEntitiesInternal(CopyPasteEntityInfo toLoad, PasteOptions options)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0520: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_05af: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_060e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0610: Unknown result type (might be due to invalid IL or missing references)
		//IL_0649: Unknown result type (might be due to invalid IL or missing references)
		//IL_064e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0650: Unknown result type (might be due to invalid IL or missing references)
		//IL_0655: Unknown result type (might be due to invalid IL or missing references)
		//IL_0685: Unknown result type (might be due to invalid IL or missing references)
		//IL_068a: Unknown result type (might be due to invalid IL or missing references)
		//IL_068c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0691: Unknown result type (might be due to invalid IL or missing references)
		toLoad = toLoad.Copy();
		Transform transform = new GameObject("Align").transform;
		transform.position = options.Origin;
		transform.rotation = options.PlayerRotation;
		List<EntityWrapper> list = new List<EntityWrapper>();
		Dictionary<ulong, ulong> remapping = new Dictionary<ulong, ulong>();
		Dictionary<uint, uint> dictionary = new Dictionary<uint, uint>();
		foreach (Entity entity in toLoad.entities)
		{
			entity.InspectUids((UidInspector<ulong>)UpdateWithNewUid);
			EntityWrapper item = new EntityWrapper
			{
				Protobuf = entity,
				HasParent = (entity.parent != null && entity.parent.uid != default(NetworkableId))
			};
			list.Add(item);
			if (entity.decayEntity != null)
			{
				if (!dictionary.TryGetValue(entity.decayEntity.buildingID, out var value))
				{
					value = BuildingManager.server.NewBuildingID();
					dictionary.Add(entity.decayEntity.buildingID, value);
				}
				entity.decayEntity.buildingID = value;
			}
		}
		foreach (EntityWrapper item2 in list)
		{
			item2.Position = item2.Protobuf.baseEntity.pos;
			item2.Rotation = Quaternion.Euler(item2.Protobuf.baseEntity.rot);
			if (!item2.HasParent)
			{
				item2.Protobuf.baseEntity.pos = transform.TransformPoint(item2.Protobuf.baseEntity.pos);
				BaseEntity baseEntity = item2.Protobuf.baseEntity;
				Quaternion val = transform.rotation * Quaternion.Euler(item2.Protobuf.baseEntity.rot);
				baseEntity.rot = ((Quaternion)(ref val)).eulerAngles;
			}
			if (CanPrefabBePasted(item2.Protobuf.baseNetworkable.prefabID, options))
			{
				item2.Entity = GameManager.server.CreateEntity(StringPool.Get(item2.Protobuf.baseNetworkable.prefabID), item2.Protobuf.baseEntity.pos, Quaternion.Euler(item2.Protobuf.baseEntity.rot));
				if (item2.Protobuf.basePlayer != null && item2.Protobuf.basePlayer.userid > 10000000)
				{
					ulong userid = 10000000uL + (ulong)Random.Range(1, int.MaxValue);
					item2.Protobuf.basePlayer.userid = userid;
				}
				item2.Entity.InitLoad(item2.Protobuf.baseNetworkable.uid);
				item2.Entity.PreServerLoad();
			}
		}
		list.RemoveAll((EntityWrapper x) => (Object)(object)x.Entity == (Object)null);
		Object.Destroy((Object)(object)((Component)transform).gameObject);
		for (int i = 0; i < list.Count; i++)
		{
			EntityWrapper entityWrapper = list[i];
			BaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);
			info.fromDisk = true;
			info.fromCopy = true;
			info.msg = entityWrapper.Protobuf;
			try
			{
				entityWrapper.Entity.Spawn();
				bool flag = false;
				if (!flag && entityWrapper.Protobuf.parent != null && entityWrapper.Protobuf.parent.uid != default(NetworkableId))
				{
					BaseEntity baseEntity2 = BaseNetworkable.serverEntities.Find(entityWrapper.Protobuf.parent.uid) as BaseEntity;
					if ((Object)(object)baseEntity2 == (Object)null || baseEntity2.net == null)
					{
						flag = true;
					}
				}
				if (flag)
				{
					entityWrapper.Entity.Kill();
					list.RemoveAt(i);
					i--;
				}
				else
				{
					entityWrapper.Entity.Load(info);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				entityWrapper.Entity.Kill();
			}
		}
		float num = float.MaxValue;
		float num2 = float.MinValue;
		RaycastHit val2 = default(RaycastHit);
		foreach (EntityWrapper item3 in list)
		{
			Vector3 position = ((Component)item3.Entity).transform.position;
			if (((Object)(object)item3.Entity.parentEntity.Get(serverside: true) == (Object)null && item3.Entity.ShortPrefabName == "foundation") || item3.Entity.ShortPrefabName == "foundation.triangle")
			{
				float num3 = TerrainMeta.HeightMap.GetHeight(position);
				if (Physics.Raycast(new Vector3(position.x, num3, position.z) + new Vector3(0f, 100f, 0f), Vector3.down, ref val2, 100f, 8454144))
				{
					num3 = ((RaycastHit)(ref val2)).point.y;
				}
				if (position.y > num3)
				{
					num = Mathf.Min(num, position.y - num3);
				}
				if (num3 > position.y)
				{
					num2 = Mathf.Max(num2, num3 - position.y);
				}
			}
		}
		if (!options.SnapToTerrain || (num == float.MaxValue && num2 == float.MinValue))
		{
			num2 = 0f;
			num = 0f;
		}
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(0f, (num < num2 || num2 == float.MinValue) ? (num * -1f) : num2, 0f);
		val3 += options.HeightOffset;
		if (val3 != Vector3.zero)
		{
			foreach (EntityWrapper item4 in list)
			{
				if ((Object)(object)item4.Entity.parentEntity.Get(serverside: true) == (Object)null)
				{
					Transform transform2 = ((Component)item4.Entity).transform;
					transform2.position += val3;
				}
				if (!(item4.Entity is IOEntity iOEntity))
				{
					continue;
				}
				if (iOEntity.inputs != null)
				{
					IOEntity.IOSlot[] inputs = iOEntity.inputs;
					foreach (IOEntity.IOSlot obj in inputs)
					{
						obj.originPosition += val3;
					}
				}
				if (iOEntity.outputs != null)
				{
					IOEntity.IOSlot[] inputs = iOEntity.outputs;
					foreach (IOEntity.IOSlot obj2 in inputs)
					{
						obj2.originPosition += val3;
					}
				}
			}
		}
		foreach (EntityWrapper item5 in list)
		{
			item5.Entity.PostServerLoad();
			item5.Entity.UpdateNetworkGroup();
		}
		foreach (EntityWrapper item6 in list)
		{
			item6.Entity.RefreshEntityLinks();
		}
		foreach (EntityWrapper item7 in list)
		{
			if (item7.Entity is BuildingBlock buildingBlock)
			{
				buildingBlock.UpdateSkin(force: true);
			}
		}
		return (from x in list
			select x.Entity into x
			where (Object)(object)x != (Object)null
			select x).ToList();
		void UpdateWithNewUid(UidType type, ref ulong prevUid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			if ((int)type == 3)
			{
				prevUid = 0uL;
			}
			else if (prevUid != 0L)
			{
				if (!remapping.TryGetValue(prevUid, out var value2))
				{
					value2 = Net.sv.TakeUID();
					remapping.Add(prevUid, value2);
				}
				prevUid = value2;
			}
		}
	}

	private static void SaveEntity(BaseEntity baseEntity, CopyPasteEntityInfo toSave, BaseEntity parent, Transform alignObject)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		BaseNetworkable.SaveInfo info = default(BaseNetworkable.SaveInfo);
		info.forDisk = true;
		info.msg = Pool.Get<Entity>();
		baseEntity.Save(info);
		if ((Object)(object)parent == (Object)null)
		{
			info.msg.baseEntity.pos = alignObject.InverseTransformPoint(info.msg.baseEntity.pos);
			_ = alignObject.rotation * ((Component)baseEntity).transform.rotation;
			BaseEntity baseEntity2 = info.msg.baseEntity;
			Quaternion val = Quaternion.Inverse(((Component)alignObject).transform.rotation) * ((Component)baseEntity).transform.rotation;
			baseEntity2.rot = ((Quaternion)(ref val)).eulerAngles;
		}
		toSave.entities.Add(info.msg);
	}

	private static void GetEntitiesLookingAt(Vector3 originPoint, Vector3 direction, List<BaseEntity> entityList)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		entityList.Clear();
		BuildingBlock buildingBlock = GamePhysics.RaycastEntity(GamePhysics.Realm.Server, new Ray(originPoint, direction), 100f, 2097408, (QueryTriggerInteraction)0) as BuildingBlock;
		if (!((Object)(object)buildingBlock == (Object)null))
		{
			ListHashSet<DecayEntity> val = buildingBlock.GetBuilding()?.decayEntities;
			if (val != null)
			{
				entityList.AddRange((IEnumerable<BaseEntity>)val);
			}
		}
	}

	private static void GetEntitiesInRadius(Vector3 originPoint, float radius, List<BaseEntity> entityList)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (radius <= 0f)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(originPoint, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient)
			{
				entityList.Add(item);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static void GetEntitiesInBounds(Bounds bounds, List<BaseEntity> entityList)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		OBB bounds2 = new OBB(bounds);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(bounds2, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient)
			{
				entityList.Add(item);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static bool CanPrefabBePasted(uint prefabId, PasteOptions options)
	{
		GameObject val = GameManager.server.FindPrefab(prefabId);
		if ((Object)(object)val == (Object)null)
		{
			return false;
		}
		BaseEntity component = val.GetComponent<BaseEntity>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		if (options.FoundationsOnly && component.ShortPrefabName != "foundation" && component.ShortPrefabName != "foundation.triangle")
		{
			return false;
		}
		if (options.BuildingBlocksOnly && !(component is BuildingBlock))
		{
			return false;
		}
		if (component is DecayEntity && !(component is BuildingBlock) && !options.Deployables)
		{
			return false;
		}
		if (component is BasePlayer { IsNpc: false } && !options.Players)
		{
			return false;
		}
		if (component is PointEntity || component is RelationshipManager)
		{
			return false;
		}
		if ((component is ResourceEntity || component is BushEntity) && !options.Resources)
		{
			return false;
		}
		if ((component is BaseNpc || component is BaseRidableAnimal) && !options.NPCs)
		{
			return false;
		}
		if (component is BaseVehicle && !(component is BaseRidableAnimal) && !options.Vehicles)
		{
			return false;
		}
		return true;
	}

	private static void OrderEntitiesForSave(List<BaseEntity> entities)
	{
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		list.AddRange(entities);
		entities.Clear();
		HashSet<BaseEntity> hash = new HashSet<BaseEntity>();
		foreach (BaseEntity item in list.OrderBy((BaseEntity x) => x.net.ID.Value))
		{
			AddRecursive(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		void AddRecursive(BaseEntity current)
		{
			if (hash.Add(current))
			{
				entities.Add(current);
				if (current.children != null)
				{
					foreach (BaseEntity child in current.children)
					{
						AddRecursive(child);
					}
				}
			}
		}
	}

	[ServerVar(Name = "copybox_sv")]
	public static void copybox_sv(Arg args)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Missing args: copybox_sv <name> <center> <size> <rotation>");
			return;
		}
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		Vector3 vector2 = args.GetVector3(2, default(Vector3));
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		Bounds bounds = new Bounds(vector, vector2);
		List<BaseEntity> list = Pool.GetList<BaseEntity>();
		GetEntitiesInBounds(bounds, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeList<BaseEntity>(ref list);
	}

	public static List<BaseEntity> PasteEntities(CopyPasteEntityInfo data, PasteOptions options, ulong steamId)
	{
		List<BaseEntity> list;
		try
		{
			Application.isLoadingSave = true;
			Application.isLoading = true;
			list = PasteEntitiesInternal(data, options);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return new List<BaseEntity>();
		}
		finally
		{
			Application.isLoadingSave = false;
			Application.isLoading = false;
		}
		playerHistory.AddToHistory(steamId, list);
		return list;
	}

	[ServerVar]
	public static void undopaste_sv(Arg args)
	{
		ulong steamId = args.Player()?.userID ?? ((EncryptedValue<ulong>)0uL);
		PasteResult pasteResult = playerHistory.Undo(steamId);
		if (pasteResult == null)
		{
			args.ReplyWith("History empty");
			return;
		}
		foreach (BaseEntity entity in pasteResult.Entities)
		{
			entity.Kill();
		}
	}

	[ServerVar]
	public static void copyradius_sv(Arg args)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		float @float = args.GetFloat(2, 0f);
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		if (@float <= 0f)
		{
			args.ReplyWith("Invalid radius: must be greater than zero");
			return;
		}
		GetEntitiesInRadius(vector, @float, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	[ServerVar]
	public static void copybuilding_sv(Arg args)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		Vector3 vector2 = args.GetVector3(2, default(Vector3));
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		GetEntitiesLookingAt(vector, vector2, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	[ServerVar]
	public static void printselection_sv(Arg args)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 vector = args.GetVector3(0, default(Vector3));
		Vector3 vector2 = args.GetVector3(1, default(Vector3));
		args.GetVector3(2, default(Vector3));
		GetEntitiesInBounds(new Bounds(vector, vector2), list);
		StringBuilder stringBuilder = new StringBuilder();
		if (list.Count == 0)
		{
			stringBuilder.AppendLine("Empty");
		}
		else
		{
			foreach (BaseEntity item in list)
			{
				if (!item.isClient)
				{
					stringBuilder.AppendLine(((Object)item).name);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		args.ReplyWith(stringBuilder.ToString());
	}

	private static string GetLegacyServerDirectory()
	{
		return ConVar.Server.GetServerFolder("copypaste");
	}

	private static string GetLegacyServerPath(string name)
	{
		return GetLegacyServerDirectory() + "/" + name + ".data";
	}

	[ServerVar]
	public static void download_paste(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Missing args: download_paste <name>");
			return;
		}
		string @string = arg.GetString(0, "");
		string legacyServerPath = GetLegacyServerPath(arg.GetString(0, ""));
		if (!File.Exists(legacyServerPath))
		{
			arg.ReplyWith("Paste '" + @string + "' not found");
			return;
		}
		CopyPasteEntityInfo val = CopyPasteEntityInfo.Deserialize(File.ReadAllBytes(legacyServerPath));
		try
		{
			CopyPasteEntity.ServerInstance.ClientRPC<string, CopyPasteEntityInfo>(RpcTarget.Player("RecievePaste", arg.Connection), @string, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void list_pastes_sv(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		PrintPasteNames(stringBuilder, GetLegacyServerDirectory());
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void killbox_sv(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = args.GetVector3(0, default(Vector3));
		Vector3 vector2 = args.GetVector3(1, default(Vector3));
		PasteOptions options = new PasteOptions(args);
		Bounds bounds = new Bounds(vector, vector2);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		GetEntitiesInBounds(bounds, list);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient && CanPrefabBePasted(item.prefabID, options) && (!(item is BasePlayer entity) || entity.IsNpcPlayer()))
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static Quaternion GetPlayerRotation(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ply.eyes.BodyForward();
		val.y = 0f;
		return Quaternion.LookRotation(val, Vector3.up);
	}
}


using ProtoBuf;
using UnityEngine;

private class EntityWrapper
{
	public BaseEntity Entity;

	public Entity Protobuf;

	public Vector3 Position;

	public Quaternion Rotation;

	public bool HasParent;
}


using ProtoBuf;
using UnityEngine;

public class PasteOptions
{
	public const string Argument_NPCs = "--npcs";

	public const string Argument_Resources = "--resources";

	public const string Argument_Vehicles = "--vehicles";

	public const string Argument_Deployables = "--deployables";

	public const string Argument_FoundationsOnly = "--foundations-only";

	public const string Argument_BuildingBlocksOnly = "--building-only";

	public const string Argument_SnapToTerrain = "--autosnap-terrain";

	public const string Argument_PastePlayers = "--players";

	public bool Resources;

	public bool NPCs;

	public bool Vehicles;

	public bool Deployables;

	public bool FoundationsOnly;

	public bool BuildingBlocksOnly;

	public bool SnapToTerrain;

	public bool Players;

	public Vector3 Origin;

	public Quaternion PlayerRotation;

	public Vector3 HeightOffset;

	public PasteOptions(Arg arg)
	{
		Resources = arg.HasArg("--resources", true);
		NPCs = arg.HasArg("--npcs", true);
		Vehicles = arg.HasArg("--vehicles", true);
		Deployables = arg.HasArg("--deployables", true);
		FoundationsOnly = arg.HasArg("--foundations-only", true);
		BuildingBlocksOnly = arg.HasArg("--building-only", true);
		SnapToTerrain = arg.HasArg("--autosnap-terrain", true);
		Players = arg.HasArg("--players", true);
	}

	public PasteOptions(PasteRequest request)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		Resources = request.resources;
		NPCs = request.npcs;
		Vehicles = request.vehicles;
		Deployables = request.deployables;
		FoundationsOnly = request.foundationsOnly;
		BuildingBlocksOnly = request.buildingBlocksOnly;
		SnapToTerrain = request.snapToTerrain;
		Players = request.players;
		Origin = request.origin;
		PlayerRotation = Quaternion.Euler(request.playerRotation);
		HeightOffset = request.heightOffset;
	}
}


using System.Collections.Generic;

public class PasteResult
{
	public List<BaseEntity> Entities;

	public PasteResult(List<BaseEntity> entities)
	{
		Entities = entities;
	}
}


using System.Collections.Generic;
using System.Linq;
using ConVar;

public class CopyPasteHistoryManager
{
	public class PlayerHistory
	{
		public ulong SteamId;

		public List<PasteResult> History = new List<PasteResult>();

		public int CurrentIndex = -1;

		public PlayerHistory(ulong steamId)
		{
			SteamId = steamId;
		}
	}

	private List<PlayerHistory> playerHistory = new List<PlayerHistory>();

	public PlayerHistory GetOrCreateHistory(ulong steamId)
	{
		PlayerHistory playerHistory = this.playerHistory.FirstOrDefault((PlayerHistory x) => x.SteamId == steamId);
		if (playerHistory == null)
		{
			playerHistory = new PlayerHistory(steamId);
			this.playerHistory.Add(playerHistory);
		}
		return playerHistory;
	}

	public void AddToHistory(ulong steamId, List<BaseEntity> entities)
	{
		PlayerHistory orCreateHistory = GetOrCreateHistory(steamId);
		int num = orCreateHistory.History.Count - orCreateHistory.CurrentIndex - 1;
		if (num > 0)
		{
			orCreateHistory.History.RemoveRange(orCreateHistory.CurrentIndex + 1, num);
		}
		orCreateHistory.History.Add(new PasteResult(entities));
		orCreateHistory.CurrentIndex = orCreateHistory.History.Count - 1;
	}

	public PasteResult Undo(ulong steamId)
	{
		PlayerHistory orCreateHistory = GetOrCreateHistory(steamId);
		if (orCreateHistory.CurrentIndex < 0)
		{
			return null;
		}
		orCreateHistory.CurrentIndex--;
		return orCreateHistory.History[orCreateHistory.CurrentIndex + 1];
	}
}


using System.Collections.Generic;

public class PlayerHistory
{
	public ulong SteamId;

	public List<PasteResult> History = new List<PasteResult>();

	public int CurrentIndex = -1;

	public PlayerHistory(ulong steamId)
	{
		SteamId = steamId;
	}
}


using UnityEngine;

[Factory("craft")]
public class Craft : ConsoleSystem
{
	[ServerVar]
	public static bool instant;

	[ServerUserVar]
	public static void add(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || basePlayer.IsDead())
		{
			return;
		}
		int @int = args.GetInt(0, 0);
		int int2 = args.GetInt(1, 1);
		int num = (int)args.GetUInt64(2, 0uL);
		bool @bool = args.GetBool(3, false);
		if (int2 < 1)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(@int);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			args.ReplyWith("Item not found");
			return;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
		if (!Object.op_Implicit((Object)(object)itemBlueprint))
		{
			args.ReplyWith("Blueprint not found");
			return;
		}
		if (!itemBlueprint.userCraftable)
		{
			args.ReplyWith("Item is not craftable");
			return;
		}
		if (!basePlayer.blueprints.CanCraft(@int, num, basePlayer.userID))
		{
			num = 0;
			if (!basePlayer.blueprints.CanCraft(@int, num, basePlayer.userID))
			{
				args.ReplyWith("You can't craft this item");
				return;
			}
			args.ReplyWith("You don't have permission to use this skin, so crafting unskinned");
		}
		int num2 = int2;
		int num3 = int2;
		if (@bool)
		{
			num2 = Mathf.Min(int2, 5);
			num3 = 1;
		}
		for (int num4 = num2; num4 >= num3; num4--)
		{
			if (basePlayer.inventory.crafting.CraftItem(itemBlueprint, basePlayer, null, num4, num))
			{
				return;
			}
		}
		args.ReplyWith("Couldn't craft!");
	}

	[ServerUserVar]
	public static void canceltask(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			if (!basePlayer.inventory.crafting.CancelTask(@int))
			{
				args.ReplyWith("Couldn't cancel task!");
			}
		}
	}

	[ServerUserVar]
	public static void cancel(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			basePlayer.inventory.crafting.CancelBlueprint(@int);
		}
	}

	[ServerUserVar]
	public static void fasttracktask(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			if (!basePlayer.inventory.crafting.FastTrackTask(@int))
			{
				args.ReplyWith("Couldn't fast track task!");
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class Creative : ConsoleSystem
{
	[ReplicatedVar(Help = "Apply creative mode to the entire server", Saved = true)]
	public static bool allUsers;

	[ServerVar(Saved = true)]
	public static bool alwaysOnEnabled;

	[ReplicatedVar(Help = "Bypass the 30s repair cooldown when repairing objects", Saved = true)]
	public static bool freeRepair;

	[ReplicatedVar(Help = "Build blocks for free", Saved = true)]
	public static bool freeBuild;

	[ReplicatedVar(Help = "Bypasses all placement checks", Saved = true)]
	public static bool freePlacement;

	[ReplicatedVar(Help = "Bypasses bypassHoldToPlaceDuration when deploying items", Saved = true)]
	public static bool bypassHoldToPlaceDuration;

	[ReplicatedVar(Help = "Bypasses limits on IO length and points", Saved = true)]
	public static bool unlimitedIo;

	[ServerVar]
	public static void toggleCreativeModeUser(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		bool @bool = arg.GetBool(1, false);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Invalid player provided " + arg.GetString(0, ""));
			return;
		}
		player.SetPlayerFlag(BasePlayer.PlayerFlags.CreativeMode, @bool);
		arg.ReplyWith($"{player.displayName} creative mode: {@bool}");
	}

	[ServerVar]
	public static void toggleAlwaysOnAll(Arg arg)
	{
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInCreativeMode)
		{
			return;
		}
		bool @bool = arg.GetBool(0, false);
		BaseCombatEntity[] array = BaseEntity.Util.FindAll<BaseCombatEntity>();
		foreach (BaseCombatEntity baseCombatEntity in array)
		{
			if (!baseCombatEntity.isClient && baseCombatEntity is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
	}

	[ServerUserVar(ServerAdmin = true)]
	public static void toggleAlwaysOnRadius(Arg arg)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInCreativeMode)
		{
			return;
		}
		bool @bool = arg.GetBool(0, false);
		float radius = Mathf.Clamp(arg.GetFloat(1, 0f), 0f, 100f);
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		Vis.Entities(((Component)basePlayer).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseCombatEntity item in list)
		{
			if (!item.isClient && item is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
	}

	[ServerUserVar(ServerAdmin = true)]
	public static void toggleAlwaysOn(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsInCreativeMode)
		{
			bool @bool = arg.GetBool(0, false);
			RaycastHit hit = default(RaycastHit);
			if (Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1) && hit.GetEntity() is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
	}
}


[Factory("culling")]
public class Culling : ConsoleSystem
{
}


using System.IO;
using UnityEngine;

[Factory("data")]
public class Data : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static void export(Arg args)
	{
		string @string = args.GetString(0, "none");
		string text = Path.Combine(Application.persistentDataPath, @string + ".raw");
		switch (@string)
		{
		case "splatmap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap))
			{
				RawWriter.Write(TerrainMeta.SplatMap.ToEnumerable(), text);
			}
			break;
		case "heightmap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				RawWriter.Write(TerrainMeta.HeightMap.ToEnumerable(), text);
			}
			break;
		case "biomemap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
			{
				RawWriter.Write(TerrainMeta.BiomeMap.ToEnumerable(), text);
			}
			break;
		case "topologymap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
			{
				RawWriter.Write(TerrainMeta.TopologyMap.ToEnumerable(), text);
			}
			break;
		case "alphamap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap))
			{
				RawWriter.Write(TerrainMeta.AlphaMap.ToEnumerable(), text);
			}
			break;
		case "watermap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap))
			{
				RawWriter.Write(TerrainMeta.WaterMap.ToEnumerable(), text);
			}
			break;
		default:
			args.ReplyWith("Unknown export source: " + @string);
			return;
		}
		args.ReplyWith("Export written to " + text);
	}
}


public class DDraw
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Unity;
using Oxide.Core;
using Rust;
using Rust.Ai;
using UnityEngine;

[Factory("debug")]
public class Debugging : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static bool checktriggers = false;

	[ServerVar]
	public static bool checkparentingtriggers = true;

	[ClientVar(Saved = false, Help = "Shows some debug info for dismount attempts.")]
	[ServerVar]
	public static bool DebugDismounts = false;

	[ServerVar(Help = "Do not damage any items")]
	public static bool disablecondition = false;

	[ServerVar]
	public static int tutorial_start_cooldown = 60;

	[ServerVar]
	public static bool printMissionSpeakInfo = false;

	private static HashSet<BasePlayer> invisiblePlayers = new HashSet<BasePlayer>();

	[ClientVar]
	[ServerVar]
	public static bool callbacks = false;

	[ClientVar]
	[ServerVar]
	public static bool log
	{
		get
		{
			return Debug.unityLogger.logEnabled;
		}
		set
		{
			Debug.unityLogger.logEnabled = value;
		}
	}

	[ServerVar]
	[ClientVar(ClientAdmin = true)]
	public static void renderinfo(Arg arg)
	{
		RenderInfo.GenerateReport();
	}

	[ServerVar]
	public static void enable_player_movement(Arg arg)
	{
		if (arg.IsAdmin)
		{
			bool @bool = arg.GetBool(0, true);
			BasePlayer basePlayer = arg.Player();
			if ((Object)(object)basePlayer == (Object)null)
			{
				arg.ReplyWith("Must be called from client with player model");
				return;
			}
			basePlayer.ClientRPC(RpcTarget.Player("TogglePlayerMovement", basePlayer), @bool);
			arg.ReplyWith((@bool ? "enabled" : "disabled") + " player movement");
		}
	}

	[ServerVar]
	[ClientVar]
	public static void stall(Arg arg)
	{
		float num = Mathf.Clamp(arg.GetFloat(0, 0f), 0f, 1f);
		arg.ReplyWith("Stalling for " + num + " seconds...");
		Thread.Sleep(Mathf.RoundToInt(num * 1000f));
	}

	[ServerVar(Help = "Repair all items in inventory")]
	public static void repair_inventory(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		basePlayer.inventory.GetAllItems(list);
		foreach (Item item in list)
		{
			if (item != null)
			{
				item.maxCondition = item.info.condition.max;
				item.condition = item.maxCondition;
				item.MarkDirty();
			}
			if (item.contents == null)
			{
				continue;
			}
			foreach (Item item2 in item.contents.itemList)
			{
				item2.maxCondition = item2.info.condition.max;
				item2.condition = item2.maxCondition;
				item2.MarkDirty();
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	[ServerVar]
	public static void spawnParachuteTester(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, 50f);
		BasePlayer basePlayer = arg.Player();
		BasePlayer basePlayer2 = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", ((Component)basePlayer).transform.position + Vector3.up * @float, Quaternion.LookRotation(basePlayer.eyes.BodyForward())) as BasePlayer;
		basePlayer2.Spawn();
		basePlayer2.eyes.rotation = basePlayer.eyes.rotation;
		basePlayer2.SendNetworkUpdate();
		Inventory.copyTo(basePlayer, basePlayer2);
		if (!basePlayer2.HasValidParachuteEquipped())
		{
			basePlayer2.inventory.containerWear.GiveItem(ItemManager.CreateByName("parachute", 1, 0uL));
		}
		basePlayer2.RequestParachuteDeploy();
	}

	[ServerVar]
	public static string testTutorialCinematic(Arg arg)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInTutorial)
		{
			return "Requires a player";
		}
		TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland == (Object)null)
		{
			return "Invalid island";
		}
		Transform val = TransformEx.FindChildRecursive(((Component)currentTutorialIsland).transform, "KayakMissionPoint");
		if ((Object)(object)val == (Object)null)
		{
			return "Can't find KayakMissionPoint on island";
		}
		Kayak obj = GameManager.server.CreateEntity("assets/content/vehicles/boats/kayak/kayak.prefab", val.position, val.rotation) as Kayak;
		obj.Spawn();
		obj.WantsMount(basePlayer);
		currentTutorialIsland.StartEndingCinematic(basePlayer);
		return "Playing cinematic";
	}

	[ServerVar(Help = "If a player ends up stuck on a tutorial for any reason this will clear the island and reset the player (will also kill player)")]
	public static void clearTutorialForPlayer(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Please provide a player");
		}
		else if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.Return();
			}
			player.ClearTutorial();
			player.Hurt(99999f);
			player.ClearTutorial_PostDeath();
		}
	}

	[ServerVar]
	public static void deleteEntitiesByShortname(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		string text = arg.GetString(0, "").ToLower();
		float @float = arg.GetFloat(1, 0f);
		BasePlayer basePlayer = arg.Player();
		PooledList<BaseNetworkable> val = Pool.Get<PooledList<BaseNetworkable>>();
		try
		{
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BaseNetworkable current = enumerator.Current;
					if (current.ShortPrefabName == text && (@float == 0f || ((Object)(object)basePlayer != (Object)null && basePlayer.Distance(current as BaseEntity) <= @float)))
					{
						((List<BaseNetworkable>)(object)val).Add(current);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			Debug.Log((object)$"Deleting {((List<BaseNetworkable>)(object)val).Count} {text}...");
			foreach (BaseNetworkable item in (List<BaseNetworkable>)(object)val)
			{
				item.Kill();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void deleteEntityById(Arg arg)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < arg.Args.Length; i++)
		{
			NetworkableId entityID = arg.GetEntityID(i);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
			if ((Object)(object)baseNetworkable != (Object)null)
			{
				stringBuilder.AppendLine($"Deleting {baseNetworkable}");
				baseNetworkable.Kill();
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void printgroups(Arg arg)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Server");
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				Debug.Log((object)string.Format("{0}:{1}{2}", current.PrefabName, current.net.group.ID, current.net.group.restricted ? "/Restricted" : string.Empty));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Takes you in and out of your current network group, causing you to delete and then download all entities in your PVS again")]
	public static void flushgroup(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.net.SwitchGroup(BaseNetworkable.LimboNetworkGroup);
			basePlayer.UpdateNetworkGroup();
		}
	}

	[ServerVar(Help = "Break the current held object")]
	public static void breakheld(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		activeItem?.LoseCondition(activeItem.condition * 2f);
	}

	[ServerVar(Help = "Breaks the currently held shield")]
	public static void breakshield(Arg arg)
	{
		if (arg.Player().GetActiveShield(out var foundShield) && foundShield.GetItem() != null)
		{
			foundShield.GetItem().LoseCondition(999f);
		}
	}

	[ServerVar(Help = "Almost break the current held object")]
	public static void breakheld_almost(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		if (activeItem != null && activeItem.hasCondition)
		{
			activeItem.condition = 1f;
		}
	}

	[ServerVar(Help = "reset all puzzles")]
	public static void puzzlereset(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)arg.Player() == (Object)null))
		{
			PuzzleReset[] array = Object.FindObjectsOfType<PuzzleReset>();
			Debug.Log((object)"iterating...");
			PuzzleReset[] array2 = array;
			foreach (PuzzleReset puzzleReset in array2)
			{
				Vector3 position = ((Component)puzzleReset).transform.position;
				Debug.Log((object)("resetting puzzle at :" + ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString()));
				puzzleReset.DoReset();
				puzzleReset.ResetTimer();
			}
		}
	}

	[ServerVar(EditorOnly = true, Help = "respawn all puzzles from their prefabs")]
	public static void puzzleprefabrespawn(Arg arg)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		foreach (BaseNetworkable item in BaseNetworkable.serverEntities.Where((BaseNetworkable x) => x is IOEntity && PrefabAttribute.server.Find<Construction>(x.prefabID) == null).ToList())
		{
			item.Kill();
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			GameObject val = GameManager.server.FindPrefab(((Object)((Component)monument).gameObject).name);
			if ((Object)(object)val == (Object)null)
			{
				continue;
			}
			Dictionary<IOEntity, IOEntity> dictionary = new Dictionary<IOEntity, IOEntity>();
			IOEntity[] componentsInChildren = val.GetComponentsInChildren<IOEntity>(true);
			foreach (IOEntity iOEntity in componentsInChildren)
			{
				Quaternion rot = ((Component)monument).transform.rotation * ((Component)iOEntity).transform.rotation;
				Vector3 pos = ((Component)monument).transform.TransformPoint(((Component)iOEntity).transform.position);
				BaseEntity newEntity = GameManager.server.CreateEntity(iOEntity.PrefabName, pos, rot);
				IOEntity iOEntity2 = newEntity as IOEntity;
				if (!((Object)(object)iOEntity2 != (Object)null))
				{
					continue;
				}
				dictionary.Add(iOEntity, iOEntity2);
				DoorManipulator doorManipulator = newEntity as DoorManipulator;
				if ((Object)(object)doorManipulator != (Object)null)
				{
					List<Door> list = Pool.Get<List<Door>>();
					Vis.Entities(((Component)newEntity).transform.position, 10f, list, -1, (QueryTriggerInteraction)2);
					Door door = list.OrderBy((Door x) => x.Distance(((Component)newEntity).transform.position)).FirstOrDefault();
					if ((Object)(object)door != (Object)null)
					{
						doorManipulator.targetDoor = door;
					}
					Pool.FreeUnmanaged<Door>(ref list);
				}
				CardReader cardReader = newEntity as CardReader;
				if ((Object)(object)cardReader != (Object)null)
				{
					CardReader cardReader2 = iOEntity as CardReader;
					if ((Object)(object)cardReader2 != (Object)null)
					{
						cardReader.accessLevel = cardReader2.accessLevel;
						cardReader.accessDuration = cardReader2.accessDuration;
					}
				}
				TimerSwitch timerSwitch = newEntity as TimerSwitch;
				if ((Object)(object)timerSwitch != (Object)null)
				{
					TimerSwitch timerSwitch2 = iOEntity as TimerSwitch;
					if ((Object)(object)timerSwitch2 != (Object)null)
					{
						timerSwitch.timerLength = timerSwitch2.timerLength;
					}
				}
			}
			foreach (KeyValuePair<IOEntity, IOEntity> item2 in dictionary)
			{
				IOEntity key = item2.Key;
				IOEntity value = item2.Value;
				for (int j = 0; j < key.outputs.Length; j++)
				{
					if (!((Object)(object)key.outputs[j].connectedTo.ioEnt == (Object)null))
					{
						value.outputs[j].connectedTo.ioEnt = dictionary[key.outputs[j].connectedTo.ioEnt];
						value.outputs[j].connectedToSlot = key.outputs[j].connectedToSlot;
					}
				}
			}
			foreach (IOEntity value2 in dictionary.Values)
			{
				value2.Spawn();
			}
		}
	}

	[ServerVar(Help = "Break all the items in your inventory whose name match the passed string")]
	public static void breakitem(Arg arg)
	{
		string @string = arg.GetString(0, "");
		foreach (Item item in arg.Player().inventory.containerMain.itemList)
		{
			if (StringEx.Contains(item.info.shortname, @string, CompareOptions.IgnoreCase) && item.hasCondition)
			{
				item.LoseCondition(item.condition * 2f);
			}
		}
	}

	[ServerVar(ClientAdmin = true, Help = "Refills the vital of a target player. eg. debug.refillsvital jim - leave blank to target yourself, can take multiple players at once")]
	public static void refillvitals(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		arg.HasArg("True", true);
		arg.HasArg("False", false);
		if (arg.Args == null || arg.Args.Length == 0)
		{
			RefillPlayerVitals(basePlayer);
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < arg.Args.Length; i++)
		{
			string @string = arg.GetString(i, "");
			BasePlayer basePlayer2 = ((!(@string == basePlayer.displayName)) ? (string.IsNullOrEmpty(@string) ? null : arg.GetPlayerOrSleeperOrBot(i)) : basePlayer);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				stringBuilder.AppendLine("Could not find player '" + @string + "'");
				continue;
			}
			RefillPlayerVitals(basePlayer2);
			stringBuilder.AppendLine("Refilled '" + @string + "' vitals");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(ClientAdmin = true, Help = "Refills the vitals of all active players on the server")]
	public static void refillvitalsall(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					RefillPlayerVitals(current);
					stringBuilder.AppendLine("Refilled player '" + current.displayName + "' vitals");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (!((Object)(object)current2 == (Object)null))
				{
					RefillPlayerVitals(current2);
					stringBuilder.AppendLine("Refilled bot '" + current2.displayName + "' vitals");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void RefillPlayerVitals(BasePlayer player)
	{
		AdjustHealth(player, 1000f);
		AdjustCalories(player, 1000f);
		AdjustHydration(player, 1000f);
		AdjustRadiation(player, -10000f);
		AdjustBleeding(player, -10000f);
	}

	[ServerVar]
	public static void heal(Arg arg)
	{
		AdjustHealth(arg.Player(), arg.GetInt(0, 1));
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		int @int = arg.GetInt(0, 1);
		string @string = arg.GetString(1, string.Empty);
		HitInfo hitInfo = new HitInfo(basePlayer, basePlayer, DamageType.Bullet, @int);
		if (!string.IsNullOrEmpty(@string))
		{
			hitInfo.HitBone = StringPool.Get(@string);
		}
		basePlayer.OnAttacked(hitInfo);
	}

	[ServerVar]
	public static void eat(Arg arg)
	{
		AdjustCalories(arg.Player(), arg.GetInt(0, 1), arg.GetInt(1, 1));
	}

	[ServerVar]
	public static void drink(Arg arg)
	{
		AdjustHydration(arg.Player(), arg.GetInt(0, 1), arg.GetInt(1, 1));
	}

	[ServerVar]
	public static void sethealth(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.SetHealth(@int);
		}
	}

	[ServerVar]
	public static void setdamage(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			float damageAmount = usePlayer.health - (float)@int;
			HitInfo info = new HitInfo(basePlayer, basePlayer, DamageType.Bullet, damageAmount);
			usePlayer.OnAttacked(info);
		}
	}

	[ServerVar]
	public static void setfood(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Calories);
	}

	[ServerVar]
	public static void setwater(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Hydration);
	}

	[ServerVar]
	public static void setradiation(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Radiation);
	}

	private static void AdjustHealth(BasePlayer player, float amount, string bone = null)
	{
		player.health += amount;
	}

	private static void AdjustCalories(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.ApplyChange(MetabolismAttribute.Type.Calories, amount, time);
	}

	private static void AdjustHydration(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.ApplyChange(MetabolismAttribute.Type.Hydration, amount, time);
	}

	private static void AdjustRadiation(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.SetAttribute(MetabolismAttribute.Type.Radiation, amount);
	}

	private static void AdjustBleeding(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.SetAttribute(MetabolismAttribute.Type.Bleeding, amount);
	}

	private static void setattribute(Arg arg, MetabolismAttribute.Type type)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.metabolism.SetAttribute(type, @int);
		}
	}

	private static BasePlayer GetUsePlayer(Arg arg, int playerArgument)
	{
		BasePlayer basePlayer = null;
		if (arg.HasArgs(playerArgument + 1))
		{
			BasePlayer player = arg.GetPlayer(playerArgument);
			if (!Object.op_Implicit((Object)(object)player))
			{
				return null;
			}
			return player;
		}
		return arg.Player();
	}

	[ServerVar]
	public static void ResetSleepingBagTimers(Arg arg)
	{
		SleepingBag.ResetTimersForPlayer(arg.Player());
	}

	[ServerVar(Help = "Deducts the given number of hours from all spoilable food on the server")]
	public static void FoodSpoilingDeductTimeHours(Arg arg)
	{
		ItemModFoodSpoiling.DeductTimeFromAll(TimeSpan.FromHours(arg.GetFloat(0, 0f)));
	}

	[ServerVar(Help = "Spoils all food on the server")]
	public static void FoodSpoilingSpoilAll()
	{
		ItemModFoodSpoiling.DeductTimeFromAll(TimeSpan.MaxValue);
	}

	[ServerVar(Help = "Applies the given number of hours to all food in the players inventory")]
	public static void FoodSpoilingInventoryHours(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		PooledList<Item> spoilList = Pool.Get<PooledList<Item>>();
		try
		{
			FindSpoilableItems(basePlayer.inventory.containerMain.itemList);
			FindSpoilableItems(basePlayer.inventory.containerBelt.itemList);
			foreach (Item item in (List<Item>)(object)spoilList)
			{
				ItemModFoodSpoiling.FoodSpoilingWorkQueue.DeductTimeFromFoodItem(item, (float)@int * 60f * 60f, setDirty: true);
			}
		}
		finally
		{
			if (spoilList != null)
			{
				((IDisposable)spoilList).Dispose();
			}
		}
		void FindSpoilableItems(List<Item> items)
		{
			ItemModFoodSpoiling itemModFoodSpoiling = default(ItemModFoodSpoiling);
			foreach (Item item2 in items)
			{
				if (((Component)item2.info).TryGetComponent<ItemModFoodSpoiling>(ref itemModFoodSpoiling))
				{
					((List<Item>)(object)spoilList).Add(item2);
				}
			}
		}
	}

	[ServerVar]
	public static void ForceChickensSpawnEgg(Arg arg)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, 50f);
		if ((Object)(object)arg.Player() == (Object)null)
		{
			return;
		}
		PooledList<Chicken> val = Pool.Get<PooledList<Chicken>>();
		try
		{
			Vis.Entities(((Component)arg.Player()).transform.position, @float, (List<Chicken>)(object)val, 2048, (QueryTriggerInteraction)2);
			foreach (Chicken item in (List<Chicken>)(object)val)
			{
				if (item.isServer)
				{
					item.SpawnEgg();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void dropWorldItems(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(arg.GetString(1, ""));
		Ray val = basePlayer.eyes.HeadRay();
		Vector3 val2 = ((Ray)(ref val)).GetPoint(1f);
		if (!((Object)(object)itemDefinition == (Object)null))
		{
			for (int i = 0; i < @int; i++)
			{
				ItemManager.Create(itemDefinition, 1, 0uL).Drop(val2, Vector3.zero, Quaternion.identity);
				val2 += Vector3.up * 0.3f;
			}
		}
	}

	[ServerVar(Help = "Spawn lots of IO entities to lag the server")]
	public static void bench_io(Arg arg)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		int @int = arg.GetInt(0, 50);
		string name = arg.GetString(1, "water_catcher_small");
		List<IOEntity> list = new List<IOEntity>();
		WaterCatcher waterCatcher = null;
		Vector3 position = ((Component)arg.Player()).transform.position;
		string[] array = (from x in GameManifest.Current.entities
			where StringEx.Contains(Path.GetFileNameWithoutExtension(x), name, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (array.Length == 0)
		{
			arg.ReplyWith("Couldn't find io prefab \"" + array[0] + "\"");
			return;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(Path.GetFileNameWithoutExtension(x), name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				Debug.Log((object)$"{arg} failed to find io entity \"{name}\"");
				arg.ReplyWith("Unknown entity - could be:\n\n" + string.Join("\n", array.Select(Path.GetFileNameWithoutExtension).ToArray()));
				return;
			}
			array[0] = text;
		}
		for (int i = 0; i < @int; i++)
		{
			Vector3 pos = position + new Vector3((float)(i * 5), 0f, 0f);
			Quaternion identity = Quaternion.identity;
			BaseEntity baseEntity = GameManager.server.CreateEntity(array[0], pos, identity);
			if (!Object.op_Implicit((Object)(object)baseEntity))
			{
				continue;
			}
			baseEntity.Spawn();
			WaterCatcher component = ((Component)baseEntity).GetComponent<WaterCatcher>();
			if (Object.op_Implicit((Object)(object)component))
			{
				list.Add(component);
				if ((Object)(object)waterCatcher != (Object)null)
				{
					Connect(waterCatcher, component);
				}
				if (i == @int - 1)
				{
					Connect(component, list.First());
				}
				waterCatcher = component;
			}
		}
		static void Connect(IOEntity InputIOEnt, IOEntity OutputIOEnt)
		{
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			int num2 = 0;
			WireTool.WireColour wireColour = WireTool.WireColour.Gray;
			IOEntity.IOSlot iOSlot = InputIOEnt.inputs[num];
			IOEntity.IOSlot obj = OutputIOEnt.outputs[num2];
			iOSlot.connectedTo.Set(OutputIOEnt);
			iOSlot.connectedToSlot = num2;
			iOSlot.wireColour = wireColour;
			iOSlot.connectedTo.Init();
			obj.connectedTo.Set(InputIOEnt);
			obj.connectedToSlot = num;
			obj.wireColour = wireColour;
			obj.connectedTo.Init();
			obj.linePoints = (Vector3[])(object)new Vector3[2]
			{
				Vector3.zero,
				((Component)OutputIOEnt).transform.InverseTransformPoint(((Component)InputIOEnt).transform.TransformPoint(iOSlot.handlePosition))
			};
			OutputIOEnt.MarkDirtyForceUpdateOutputs();
			OutputIOEnt.SendNetworkUpdate();
			InputIOEnt.SendNetworkUpdate();
			OutputIOEnt.SendChangedToRoot(forceUpdate: true);
		}
	}

	[ServerVar]
	public static void completeMissionStage(Arg arg)
	{
		int @int = arg.GetInt(0, -1);
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer != (Object)null) || basePlayer.GetActiveMission() == -1)
		{
			return;
		}
		BaseMission.MissionInstance missionInstance = basePlayer.missions[basePlayer.GetActiveMission()];
		if (missionInstance == null)
		{
			return;
		}
		for (int i = 0; i < missionInstance.objectiveStatuses.Length; i++)
		{
			if (!missionInstance.objectiveStatuses[i].completed && (i == @int || (@int == -1 && !missionInstance.objectiveStatuses[i].completed)))
			{
				missionInstance.GetMission().objectives[i].objective.ObjectiveStarted(basePlayer, i, missionInstance);
				missionInstance.GetMission().objectives[i].objective.CompleteObjective(i, missionInstance, basePlayer);
				break;
			}
		}
	}

	[ServerVar]
	public static void completeMission(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer != (Object)null) || basePlayer.GetActiveMission() == -1)
		{
			return;
		}
		BaseMission.MissionInstance missionInstance = basePlayer.missions[basePlayer.GetActiveMission()];
		if (missionInstance == null)
		{
			return;
		}
		for (int i = 0; i < missionInstance.objectiveStatuses.Length; i++)
		{
			if (!missionInstance.objectiveStatuses[i].completed)
			{
				missionInstance.GetMission().objectives[i].objective.CompleteObjective(i, missionInstance, basePlayer);
			}
		}
	}

	[ServerUserVar]
	public static void startTutorial(Arg arg)
	{
		if (!ConVar.Server.tutorialEnabled)
		{
			arg.ReplyWith("Tutorial is not enabled on this server");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsInTutorial)
		{
			basePlayer.StartTutorial(triggerAnalytics: false);
		}
	}

	[ServerVar]
	public static void completeTutorial(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: false, triggerAnalytics: false);
			}
		}
	}

	[ServerUserVar(ServerAdmin = false)]
	public static void quitTutorial(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: true, triggerAnalytics: true);
			}
		}
	}

	[ServerVar]
	public static void tutorialStatus(Arg arg)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Expected O, but got Unknown
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		ListHashSet<TutorialIsland> tutorialList = TutorialIsland.GetTutorialList(isServer: true);
		TextTable val = new TextTable();
		val.AddColumns(new string[5] { "Index", "ID", "Player Name", "Duration", "IsConnected" });
		int num = 0;
		Enumerator<TutorialIsland> enumerator = tutorialList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				TutorialIsland current = enumerator.Current;
				BasePlayer basePlayer = current.ForPlayer.Get(serverside: true);
				val.AddRow(new string[5]
				{
					num++.ToString(),
					(current.net.group.ID - 1).ToString(),
					((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : "NULL",
					current.TutorialDuration.ToShortString(),
					((Object)(object)basePlayer != (Object)null) ? basePlayer.IsConnected.ToString() : "NULL"
				});
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Tutorial islands in use: {num}/{TutorialIsland.MaxTutorialIslandCount}");
		stringBuilder.AppendLine(((object)val).ToString());
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(Help = "Make admin invisibile")]
	public static void invis(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		bool @bool = arg.GetBool(0, !invisiblePlayers.Contains(basePlayer));
		if (@bool && !invisiblePlayers.Contains(basePlayer))
		{
			invisiblePlayers.Add(basePlayer);
			basePlayer.limitNetworking = true;
			basePlayer.syncPosition = false;
			basePlayer.GetHeldEntity()?.SetHeld(bHeld: false);
			basePlayer.DisablePlayerCollider();
			SimpleAIMemory.AddIgnorePlayer(basePlayer);
			BaseEntity.Query.Server.RemovePlayer(basePlayer);
			Interface.CallHook("OnPlayerVanish", (object)basePlayer);
			if (!Global.Runner.IsInvoking((Action)TickInvis))
			{
				Global.Runner.InvokeRepeating((Action)TickInvis, 0f, 0f);
			}
		}
		else if (!@bool && invisiblePlayers.Contains(basePlayer))
		{
			invisiblePlayers.Remove(basePlayer);
			basePlayer.limitNetworking = false;
			basePlayer.syncPosition = true;
			basePlayer.EnablePlayerCollider();
			SimpleAIMemory.RemoveIgnorePlayer(basePlayer);
			BaseEntity.Query.Server.RemovePlayer(basePlayer);
			BaseEntity.Query.Server.AddPlayer(basePlayer);
			Interface.CallHook("OnPlayerUnvanish", (object)basePlayer);
			if (invisiblePlayers.Count == 0)
			{
				Global.Runner.CancelInvoke((Action)TickInvis);
			}
		}
		arg.ReplyWith("Invis: " + basePlayer.limitNetworking);
	}

	private static void TickInvis()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BasePlayer> val = Pool.Get<PooledList<BasePlayer>>();
		try
		{
			foreach (BasePlayer invisiblePlayer in invisiblePlayers)
			{
				if (!invisiblePlayer.IsValid())
				{
					((List<BasePlayer>)(object)val).Add(invisiblePlayer);
				}
				else
				{
					invisiblePlayer.net.UpdateGroups(((Component)invisiblePlayer).transform.position);
				}
			}
			foreach (BasePlayer item in (List<BasePlayer>)(object)val)
			{
				invisiblePlayers.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void clearPlayerModifiers(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			int count = basePlayer.modifiers.All.Count;
			basePlayer.modifiers.RemoveAll();
			arg.ReplyWith($"Removed {count} modifiers");
		}
	}

	[ServerVar]
	public static void applyBuildingBlockRandomisation(Arg arg)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		int @int = arg.GetInt(0, 0);
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0f, out var hitInfo, 3f, 2097408, (QueryTriggerInteraction)0) && hitInfo.GetEntity() is SimpleBuildingBlock simpleBuildingBlock)
		{
			simpleBuildingBlock.SetVariant(@int);
		}
	}
}


[Factory("decay")]
public class Decay : ConsoleSystem
{
	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static bool upgrade_wood_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to stone")]
	public static bool upgrade_stone_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to metal")]
	public static bool upgrade_metal_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to hqm")]
	public static bool upgrade_hqm_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static float build_twig_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static float upgrade_wood_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to stone")]
	public static float upgrade_stone_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to metal")]
	public static float upgrade_metal_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to hqm")]
	public static float upgrade_hqm_cost_multiplier = 1f;

	[ServerVar(Help = "Maximum distance to test to see if a structure is outside, higher values are slower but accurate for huge buildings")]
	public static float outside_test_range = 50f;

	[ServerVar]
	public static float tick = 600f;

	[ServerVar]
	public static float scale = 1f;

	[ServerVar]
	public static bool debug = false;

	[ServerVar(Help = "Is upkeep enabled")]
	public static bool upkeep = true;

	[ServerVar(Help = "How many minutes does the upkeep cost last? default : 1440 (24 hours)")]
	public static float upkeep_period_minutes = 1440f;

	[ServerVar(Help = "How many minutes can the upkeep cost last after the cupboard was destroyed? default : 1440 (24 hours)")]
	public static float upkeep_grief_protection = 1440f;

	[ServerVar(Help = "Scale at which objects heal when upkeep conditions are met, default of 1 is same rate at which they decay")]
	public static float upkeep_heal_scale = 1f;

	[ServerVar(Help = "Scale at which objects decay when they are inside, default of 0.1")]
	public static float upkeep_inside_decay_scale = 0.1f;

	[ServerVar(Help = "When set to a value above 0 everything will decay with this delay")]
	public static float delay_override = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_twig = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_wood = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_stone = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_metal = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_toptier = 0f;

	[ServerVar(Help = "When set to a value above 0 everything will decay with this duration")]
	public static float duration_override = 0f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_twig = 1f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_wood = 3f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_stone = 5f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_metal = 8f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_toptier = 12f;

	[ServerVar(Help = "Between 0 and this value are considered bracket 0 and will cost bracket_0_costfraction per upkeep period to maintain")]
	public static int bracket_0_blockcount = 15;

	[ServerVar(Help = "blocks within bracket 0 will cost this fraction per upkeep period to maintain")]
	public static float bracket_0_costfraction = 0.1f;

	[ServerVar(Help = "Between bracket_0_blockcount and this value are considered bracket 1 and will cost bracket_1_costfraction per upkeep period to maintain")]
	public static int bracket_1_blockcount = 50;

	[ServerVar(Help = "blocks within bracket 1 will cost this fraction per upkeep period to maintain")]
	public static float bracket_1_costfraction = 0.15f;

	[ServerVar(Help = "Between bracket_1_blockcount and this value are considered bracket 2 and will cost bracket_2_costfraction per upkeep period to maintain")]
	public static int bracket_2_blockcount = 125;

	[ServerVar(Help = "blocks within bracket 2 will cost this fraction per upkeep period to maintain")]
	public static float bracket_2_costfraction = 0.2f;

	[ServerVar(Help = "Between bracket_2_blockcount and this value (and beyond) are considered bracket 3 and will cost bracket_3_costfraction per upkeep period to maintain")]
	public static int bracket_3_blockcount = 200;

	[ServerVar(Help = "blocks within bracket 3 will cost this fraction per upkeep period to maintain")]
	public static float bracket_3_costfraction = 0.333f;

	[ServerVar]
	public static bool use_door_upkeep_brackets = false;

	[ServerVar(Help = "Between 0 and this value are considered bracket 0 and will cost bracket_0_doorfraction per upkeep period to maintain")]
	public static int bracket_0_doorcount = 5;

	[ServerVar(Help = "blocks within bracket 0 will cost this fraction per upkeep period to maintain")]
	public static float bracket_0_doorfraction = 0.1f;

	[ServerVar(Help = "Between bracket_0_blockcount and this value are considered bracket 1 and will cost bracket_1_doorfraction per upkeep period to maintain")]
	public static int bracket_1_doorcount = 10;

	[ServerVar(Help = "blocks within bracket 1 will cost this fraction per upkeep period to maintain")]
	public static float bracket_1_doorfraction = 0.2f;

	[ServerVar(Help = "Between bracket_1_blockcount and this value are considered bracket 2 and will cost bracket_2_doorfraction per upkeep period to maintain")]
	public static int bracket_2_doorcount = 20;

	[ServerVar(Help = "blocks within bracket 2 will cost this fraction per upkeep period to maintain")]
	public static float bracket_2_doorfraction = 0.5f;

	[ServerVar(Help = "Between bracket_2_blockcount and this value (and beyond) are considered bracket 3 and will cost bracket_3_doorfraction per upkeep period to maintain")]
	public static int bracket_3_doorcount = 30;

	[ServerVar(Help = "blocks within bracket 3 will cost this fraction per upkeep period to maintain")]
	public static float bracket_3_doorfraction = 1f;

	public static float GetCostMultiplier(BuildingGrade.Enum grade)
	{
		return grade switch
		{
			BuildingGrade.Enum.Twigs => build_twig_cost_multiplier, 
			BuildingGrade.Enum.Wood => upgrade_wood_cost_multiplier, 
			BuildingGrade.Enum.Stone => upgrade_stone_cost_multiplier, 
			BuildingGrade.Enum.Metal => upgrade_metal_cost_multiplier, 
			BuildingGrade.Enum.TopTier => upgrade_hqm_cost_multiplier, 
			_ => 1f, 
		};
	}

	public static bool CanUpgradeToGrade(BuildingGrade.Enum grade)
	{
		return grade switch
		{
			BuildingGrade.Enum.Twigs => true, 
			BuildingGrade.Enum.Wood => upgrade_wood_enabled, 
			BuildingGrade.Enum.Stone => upgrade_stone_enabled, 
			BuildingGrade.Enum.Metal => upgrade_metal_enabled, 
			BuildingGrade.Enum.TopTier => upgrade_hqm_enabled, 
			_ => true, 
		};
	}
}


[Factory("decor")]
public class Decor : ConsoleSystem
{
}


