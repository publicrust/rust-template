using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;

public class AutoTurret : ContainerIOEntity, IRemoteControllable, IHostileWarningEntity
{
	public class UpdateAutoTurretScanQueue : PersistentObjectWorkQueue<AutoTurret>
	{
		protected override void RunJob(AutoTurret entity)
		{
			if (((PersistentObjectWorkQueue<AutoTurret>)this).ShouldAdd(entity))
			{
				entity.TargetScan();
			}
		}

		protected override bool ShouldAdd(AutoTurret entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	private enum YawPitchMode
	{
		Separate,
		Merged
	}

	public GameObjectRef gun_fire_effect;

	public GameObjectRef bulletEffect;

	public float bulletSpeed = 200f;

	public AmbienceEmitter ambienceEmitter;

	public bool playAmbientSounds = true;

	public GameObject assignDialog;

	public LaserBeam laserBeam;

	public BaseCombatEntity target;

	public Transform eyePos;

	public Transform muzzlePos;

	public Vector3 aimDir;

	public Transform gun_yaw;

	public Transform gun_pitch;

	public float sightRange = 30f;

	public SoundDefinition turnLoopDef;

	public SoundDefinition movementChangeDef;

	public SoundDefinition ambientLoopDef;

	public SoundDefinition focusCameraDef;

	public float focusSoundFreqMin = 2.5f;

	public float focusSoundFreqMax = 7f;

	public GameObjectRef peacekeeperToggleSound;

	public GameObjectRef onlineSound;

	public GameObjectRef offlineSound;

	public GameObjectRef targetAcquiredEffect;

	public GameObjectRef targetLostEffect;

	public GameObjectRef reloadEffect;

	public float aimCone;

	public const Flags Flag_Peacekeeper = Flags.Reserved1;

	public const Flags Flag_Equipped = Flags.Reserved3;

	public const Flags Flag_MaxAuths = Flags.Reserved4;

	public const Flags Flag_ShowAlphaCover = Flags.Reserved5;

	[NonSerialized]
	public HashSet<PlayerNameID> authorizedPlayers = new HashSet<PlayerNameID>();

	[ServerVar(Help = "How many milliseconds to spend on target scanning per frame")]
	public static float auto_turret_budget_ms = 0.5f;

	public static UpdateAutoTurretScanQueue updateAutoTurretScanQueue = new UpdateAutoTurretScanQueue();

	[Header("RC")]
	public float rcTurnSensitivity = 4f;

	public Transform RCEyes;

	public GameObjectRef IDPanelPrefab;

	public RemoteControllableControls rcControls;

	public string rcIdentifier = "";

	public TargetTrigger targetTrigger;

	public TriggerBase interferenceTrigger;

	public float maxInterference = -1f;

	public float attachedWeaponZOffsetScale = -0.5f;

	public Transform socketTransform;

	public bool authDirty;

	public double nextShotTime;

	public double nextVisCheck;

	public double lastTargetSeenTime;

	private double lastDamageEventTime;

	private double lastScanTime;

	public double nextIdleAimTime;

	public bool targetVisible = true;

	public bool booting;

	public Vector3 targetAimDir = Vector3.forward;

	public const float bulletDamage = 15f;

	public RealTimeSinceEx timeSinceLastServerTick;

	public HashSet<AutoTurret> nearbyTurrets = new HashSet<AutoTurret>();

	public static HashSet<AutoTurret> interferenceUpdateList = new HashSet<AutoTurret>();

	private const float SlowProjectileSpeedMultplier = 2f;

	private const float SlowProjectileSpeedThreshold = 100f;

	protected Transform cachedTransf;

	private YawPitchMode rotateMode;

	private Matrix4x4 toYawFromRoot;

	private Matrix4x4 toPitchFromRootOrYaw;

	private Matrix4x4 toRCEyesFromPitch;

	private Quaternion gunAimInitialYawRot;

	private Quaternion gunAimInitialPitchOrTotalRot;

	private Quaternion gunAimYawRotLS;

	private Quaternion gunAimPitchOrTotalRotLS;

	private Quaternion gunAimTotalRotWS;

	public double nextForcedAimTime;

	public Vector3 lastSentAimDir = Vector3.zero;

	public static float[] visibilityOffsets = new float[3] { 0f, 0.15f, -0.15f };

	public int peekIndex;

	[NonSerialized]
	public int numConsecutiveMisses;

	[NonSerialized]
	public int totalAmmo;

	public double nextAmmoCheckTime;

	public bool totalAmmoDirty = true;

	public float currentAmmoGravity;

	public float currentAmmoVelocity;

	public HeldEntity AttachedWeapon;

	private bool shouldUpdateOnOutOfAmmo;

	[NonSerialized]
	public int consumptionAmount = 10;

	public bool CanPing => false;

	public bool IsServer => base.isServer;

	public bool IsClient => base.isClient;

	public virtual bool RequiresMouse => true;

	public float MaxRange => 10000f;

	public RemoteControllableControls RequiredControls => rcControls;

	public int ViewerCount { get; set; }

	public CameraViewerId? ControllingViewerId { get; set; }

	public bool IsBeingControlled
	{
		get
		{
			if (ViewerCount > 0)
			{
				return ControllingViewerId.HasValue;
			}
			return false;
		}
	}

	protected override bool PreventDuplicatesInQueue
	{
		public get
		{
			return Sentry.debugPreventDuplicates;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("AutoTurret.OnRpcMessage", 0);
		try
		{
			if (rpc == 1092560690 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AddSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("AddSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1092560690u, "AddSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							AddSelfAuthorize(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in AddSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3057055788u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - AssignToFriend "));
				}
				TimeWarning val2 = TimeWarning.New("AssignToFriend", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3057055788u, "AssignToFriend", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							AssignToFriend(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in AssignToFriend");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 253307592 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ClearList "));
				}
				TimeWarning val2 = TimeWarning.New("ClearList", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(253307592u, "ClearList", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc3 = rPCMessage;
							ClearList(rpc3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in ClearList");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1500257773 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - FlipAim "));
				}
				TimeWarning val2 = TimeWarning.New("FlipAim", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1500257773u, "FlipAim", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc4 = rPCMessage;
							FlipAim(rpc4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in FlipAim");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3617985969u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RemoveSelfAuthorize "));
				}
				TimeWarning val2 = TimeWarning.New("RemoveSelfAuthorize", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3617985969u, "RemoveSelfAuthorize", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc5 = rPCMessage;
							RemoveSelfAuthorize(rpc5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RemoveSelfAuthorize");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1770263114 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_AttackAll "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_AttackAll", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1770263114u, "SERVER_AttackAll", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc6 = rPCMessage;
							SERVER_AttackAll(rpc6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in SERVER_AttackAll");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3265538831u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_Peacekeeper "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_Peacekeeper", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(3265538831u, "SERVER_Peacekeeper", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc7 = rPCMessage;
							SERVER_Peacekeeper(rpc7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex7)
					{
						Debug.LogException(ex7);
						player.Kick("RPC Error in SERVER_Peacekeeper");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1677685895 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_RequestOpenRCPanel "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_RequestOpenRCPanel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1677685895u, "SERVER_RequestOpenRCPanel", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_RequestOpenRCPanel(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogException(ex8);
						player.Kick("RPC Error in SERVER_RequestOpenRCPanel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1053317251 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_SetID "));
				}
				TimeWarning val2 = TimeWarning.New("Server_SetID", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1053317251u, "Server_SetID", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							Server_SetID(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogException(ex9);
						player.Kick("RPC Error in Server_SetID");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public bool IsOnline()
	{
		return IsOn();
	}

	public bool IsOffline()
	{
		return !IsOnline();
	}

	public override void ResetState()
	{
		base.ResetState();
	}

	public virtual Matrix4x4 GetCenterMuzzle()
	{
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Matrix4x4 localToWorldMatrix = cachedTransf.localToWorldMatrix;
			if (rotateMode == YawPitchMode.Separate)
			{
				return localToWorldMatrix * toYawFromRoot * Matrix4x4.Rotate(gunAimYawRotLS) * toPitchFromRootOrYaw * Matrix4x4.Rotate(gunAimPitchOrTotalRotLS);
			}
			return localToWorldMatrix * toPitchFromRootOrYaw * Matrix4x4.Rotate(gunAimPitchOrTotalRotLS);
		}
		return gun_pitch.localToWorldMatrix;
	}

	public float AngleToTarget(BaseCombatEntity potentialtarget, bool use2D = false)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		use2D = true;
		Matrix4x4 centerMuzzle = GetCenterMuzzle();
		Vector3 position = ((Matrix4x4)(ref centerMuzzle)).GetPosition();
		Vector3 val = AimOffset(potentialtarget);
		Vector3 zero = Vector3.zero;
		Vector3 val2;
		if (use2D)
		{
			zero = Vector3Ex.Direction2D(val, position);
		}
		else
		{
			val2 = val - position;
			zero = ((Vector3)(ref val2)).normalized;
		}
		Vector3 val3 = ((Matrix4x4)(ref centerMuzzle)).MultiplyVector(Vector3.forward);
		Vector3 val4;
		if (!use2D)
		{
			val4 = val3;
		}
		else
		{
			val2 = Vector3Ex.XZ3D(val3);
			val4 = ((Vector3)(ref val2)).normalized;
		}
		return Vector3.Angle(val4, zero);
	}

	public virtual bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		return Mathf.Abs(AngleToTarget(potentialtarget)) <= 90f;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (IsAuthed(player))
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (IsOnline())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemIsOnline, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.autoturret = Pool.Get<AutoTurret>();
		if (info.forDisk || IsAuthed(info.forConnection.userid))
		{
			info.msg.autoturret.users = Pool.Get<List<PlayerNameID>>();
			foreach (PlayerNameID authorizedPlayer in authorizedPlayers)
			{
				info.msg.autoturret.users.Add(authorizedPlayer);
			}
		}
		if (info.forDisk)
		{
			info.msg.rcEntity = Pool.Get<RCEntity>();
			info.msg.rcEntity.identifier = GetIdentifier();
		}
	}

	public override void PostSave(SaveInfo info)
	{
		base.PostSave(info);
		info.msg.autoturret.users = null;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.autoturret != null)
		{
			authorizedPlayers.Clear();
			if (info.msg.autoturret.users != null)
			{
				foreach (PlayerNameID user in info.msg.autoturret.users)
				{
					authorizedPlayers.Add(user);
				}
			}
			info.msg.autoturret.users = null;
		}
		if (info.msg.rcEntity != null)
		{
			UpdateIdentifier(info.msg.rcEntity.identifier);
		}
	}

	public Vector3 AimOffset(BaseCombatEntity aimat)
	{
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = aimat as BasePlayer;
		if (!basePlayer.IsUnityNull())
		{
			if (basePlayer.IsSleeping())
			{
				return ((Component)basePlayer).transform.position + Vector3.up * 0.1f;
			}
			if (basePlayer.IsWounded())
			{
				return ((Component)basePlayer).transform.position + Vector3.up * 0.25f;
			}
			if (basePlayer.GetActiveShield(out var foundShield) && foundShield.IsBlocking())
			{
				return ((Component)foundShield).transform.position;
			}
			if (!basePlayer.eyes.IsUnityNull())
			{
				return basePlayer.eyes.position;
			}
			return basePlayer.GetCenter();
		}
		if (!aimat.IsUnityNull())
		{
			return aimat.CenterPoint();
		}
		return Vector3.zero;
	}

	public float GetAimSpeed()
	{
		if (HasTarget())
		{
			return 5f;
		}
		return 1f;
	}

	public void UpdateAiming(float dt)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if (aimDir == Vector3.zero)
		{
			return;
		}
		float num = 5f;
		if (base.isServer && !IsBeingControlled)
		{
			num = ((!HasTarget()) ? 15f : 35f);
		}
		Quaternion val = Quaternion.LookRotation(aimDir);
		if (!base.isServer)
		{
			return;
		}
		Quaternion rotation = cachedTransf.rotation;
		if (rotateMode == YawPitchMode.Merged)
		{
			Quaternion val2 = Quaternion.Inverse(rotation * gunAimInitialPitchOrTotalRot) * val;
			if (gunAimPitchOrTotalRotLS != val2)
			{
				gunAimPitchOrTotalRotLS = Mathx.Lerp(gunAimPitchOrTotalRotLS, val2, num, dt);
			}
		}
		else if (gunAimTotalRotWS != val)
		{
			gunAimTotalRotWS = Mathx.Lerp(gunAimTotalRotWS, val, num, dt);
			Quaternion val3 = Quaternion.Inverse(rotation * gunAimInitialYawRot) * gunAimTotalRotWS;
			Vector3 eulerAngles = ((Quaternion)(ref val3)).eulerAngles;
			gunAimYawRotLS = Quaternion.Euler(0f, eulerAngles.y, 0f);
			gunAimPitchOrTotalRotLS = Quaternion.Euler(eulerAngles.x, 0f, 0f);
		}
	}

	public bool IsAuthed(ulong id)
	{
		foreach (PlayerNameID authorizedPlayer in authorizedPlayers)
		{
			if (authorizedPlayer.userid == id)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsAuthed(BasePlayer player)
	{
		return IsAuthed(player.userID);
	}

	public bool AnyAuthed()
	{
		return authorizedPlayers.Count > 0;
	}

	public virtual bool CanChangeSettings(BasePlayer player)
	{
		if (IsAuthed(player) && IsOffline())
		{
			return player.CanBuild();
		}
		return false;
	}

	bool IHostileWarningEntity.WarningEnabled(BaseEntity forEntity)
	{
		if (!IsPowered())
		{
			return false;
		}
		if (!PeacekeeperMode())
		{
			return false;
		}
		BasePlayer basePlayer = forEntity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return false;
		}
		if (IsAuthed(basePlayer))
		{
			return false;
		}
		return true;
	}

	float IHostileWarningEntity.WarningRange()
	{
		return sightRange * 2f;
	}

	public bool PeacekeeperMode()
	{
		return HasFlag(Flags.Reserved1);
	}

	public Transform GetEyes()
	{
		return RCEyes;
	}

	public float GetFovScale()
	{
		return 1f;
	}

	public BaseEntity GetEnt()
	{
		return this;
	}

	public virtual bool CanControl(ulong playerID)
	{
		object obj = Interface.CallHook("OnEntityControl", (object)this, (object)playerID);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (booting)
		{
			return false;
		}
		if (IsPowered())
		{
			return !PeacekeeperMode();
		}
		return false;
	}

	public bool InitializeControl(CameraViewerId viewerID)
	{
		ViewerCount++;
		if (!ControllingViewerId.HasValue)
		{
			ControllingViewerId = viewerID;
			SetTarget(null);
			SendAimDirImmediate();
			return true;
		}
		return false;
	}

	public void StopControl(CameraViewerId viewerID)
	{
		ViewerCount--;
		if (ControllingViewerId == viewerID)
		{
			ControllingViewerId = null;
		}
	}

	public void UserInput(InputState inputState, CameraViewerId viewerID)
	{
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		CameraViewerId? controllingViewerId = ControllingViewerId;
		if (viewerID != controllingViewerId)
		{
			return;
		}
		UpdateManualAim(inputState);
		double timeAsDouble = Time.timeAsDouble;
		if (timeAsDouble < nextShotTime)
		{
			return;
		}
		if (inputState.WasJustPressed(BUTTON.RELOAD))
		{
			Reload();
		}
		else
		{
			if (EnsureReloaded())
			{
				return;
			}
			BaseProjectile attachedWeapon = GetAttachedWeapon();
			if (inputState.IsDown(BUTTON.FIRE_PRIMARY))
			{
				if (Object.op_Implicit((Object)(object)attachedWeapon))
				{
					if (attachedWeapon is ITurretNotify turretNotify)
					{
						turretNotify.WarmupTick(wantsShoot: true);
					}
					float damageModifier = 1f;
					float speedModifier = 1f;
					ItemDefinition ammoType = attachedWeapon.primaryMagazine.ammoType;
					if (Object.op_Implicit((Object)(object)ammoType))
					{
						ItemModProjectile component = ((Component)ammoType).GetComponent<ItemModProjectile>();
						if (Object.op_Implicit((Object)(object)component) && component.projectileVelocity < 100f)
						{
							speedModifier = 2f;
						}
					}
					if (attachedWeapon.primaryMagazine.contents > 0)
					{
						FireAttachedGun(Vector3.zero, aimCone, null, damageModifier, speedModifier);
						float delay = (attachedWeapon.isSemiAuto ? (attachedWeapon.repeatDelay * 1.5f) : attachedWeapon.repeatDelay);
						delay = attachedWeapon.ScaleRepeatDelay(delay);
						nextShotTime = timeAsDouble + (double)delay;
					}
					else
					{
						nextShotTime = timeAsDouble + 5.0;
					}
				}
				else if (HasGenericFireable())
				{
					AttachedWeapon.ServerUse(1f, 1f, null);
					nextShotTime = timeAsDouble + 0.11500000208616257;
				}
				else
				{
					nextShotTime = timeAsDouble + 1.0;
				}
			}
			else if (Object.op_Implicit((Object)(object)attachedWeapon) && attachedWeapon is ITurretNotify turretNotify2)
			{
				turretNotify2.WarmupTick(wantsShoot: false);
			}
		}
	}

	public bool UpdateManualAim(InputState inputState)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		float num = (0f - inputState.current.mouseDelta.y) * rcTurnSensitivity;
		float num2 = inputState.current.mouseDelta.x * rcTurnSensitivity;
		Quaternion val = Quaternion.LookRotation(aimDir, ((Component)this).transform.up);
		Vector3 val2 = ((Quaternion)(ref val)).eulerAngles + new Vector3(num, num2, 0f);
		if (val2.x >= 0f && val2.x <= 135f)
		{
			val2.x = Mathf.Clamp(val2.x, 0f, 45f);
		}
		if (val2.x >= 225f && val2.x <= 360f)
		{
			val2.x = Mathf.Clamp(val2.x, 285f, 360f);
		}
		Vector3 val3 = Quaternion.Euler(val2) * Vector3.forward;
		bool result = !Mathf.Approximately(aimDir.x, val3.x) || !Mathf.Approximately(aimDir.y, val3.y) || !Mathf.Approximately(aimDir.z, val3.z);
		aimDir = val3;
		return result;
	}

	public override void InitShared()
	{
		base.InitShared();
		RCSetup();
	}

	public override void DestroyShared()
	{
		RCShutdown();
		base.DestroyShared();
	}

	public void RCSetup()
	{
		if (base.isServer)
		{
			RemoteControlEntity.InstallControllable(this);
		}
	}

	public void RCShutdown()
	{
		if (base.isServer)
		{
			RemoteControlEntity.RemoveControllable(this);
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	public void Server_SetID(RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)null || !CanChangeID(msg.player))
		{
			return;
		}
		string text = msg.read.String(256, false);
		if (string.IsNullOrEmpty(text) || ComputerStation.IsValidIdentifier(text))
		{
			string text2 = msg.read.String(256, false);
			if (ComputerStation.IsValidIdentifier(text2) && text == GetIdentifier() && Interface.CallHook("OnTurretIdentifierSet", (object)this, (object)msg.player, (object)text2) == null)
			{
				Debug.Log((object)"SetID success!");
				UpdateIdentifier(text2);
			}
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	public void SERVER_RequestOpenRCPanel(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && CanChangeID(player))
		{
			ClientRPC(RpcTarget.Player("CLIENT_OpenRCPanel", player), GetIdentifier());
		}
	}

	public void UpdateIdentifier(string newID, bool clientSend = false)
	{
		_ = rcIdentifier;
		if (base.isServer)
		{
			if (!RemoteControlEntity.IDInUse(newID))
			{
				rcIdentifier = newID;
			}
			SendNetworkUpdate();
		}
	}

	public string GetIdentifier()
	{
		return rcIdentifier;
	}

	public virtual bool CanChangeID(BasePlayer player)
	{
		return CanChangeSettings(player);
	}

	public override int ConsumptionAmount()
	{
		return consumptionAmount;
	}

	public void SetOnline()
	{
		SetIsOnline(online: true);
	}

	public void SetIsOnline(bool online)
	{
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if (Object.op_Implicit((Object)(object)attachedWeapon) && attachedWeapon is ITurretNotify turretNotify)
		{
			turretNotify.OnAddedRemovedToTurret(online);
		}
		if (online != IsOn() && Interface.CallHook("OnTurretToggle", (object)this) == null)
		{
			SetFlag(Flags.On, online);
			if (online)
			{
				TryRegisterForInterferenceUpdate();
			}
			else
			{
				SetFlag(Flags.OnFire, b: false);
				UpdateInterferenceOnOthers();
			}
			booting = false;
			GetAttachedWeapon()?.SetLightsOn(online);
			SendNetworkUpdate();
			if (IsOffline())
			{
				SetTarget(null);
				isLootable = true;
			}
			else
			{
				isLootable = false;
				authDirty = true;
			}
		}
	}

	public static void ProcessInterferenceQueue()
	{
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		List<AutoTurret> list = Pool.Get<List<AutoTurret>>();
		while (interferenceUpdateList.Count > 0 && Time.realtimeSinceStartupAsDouble < realtimeSinceStartupAsDouble + 0.0005)
		{
			list.Clear();
			ulong num = 0uL;
			AutoTurret autoTurret = null;
			foreach (AutoTurret interferenceUpdate in interferenceUpdateList)
			{
				if ((Object)(object)interferenceUpdate == (Object)null)
				{
					list.Add(interferenceUpdate);
				}
				else if (interferenceUpdate.net.ID.Value > num)
				{
					num = interferenceUpdate.net.ID.Value;
					autoTurret = interferenceUpdate;
				}
			}
			if ((Object)(object)autoTurret != (Object)null)
			{
				interferenceUpdateList.Remove(autoTurret);
				autoTurret.UpdateInterference();
			}
			foreach (AutoTurret item in list)
			{
				interferenceUpdateList.Remove(item);
			}
		}
		Pool.FreeUnmanaged<AutoTurret>(ref list);
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		int result = Mathf.Min(1, GetCurrentEnergy());
		switch (outputSlot)
		{
		case 0:
			if (!HasTarget())
			{
				return 0;
			}
			return result;
		case 1:
			if (totalAmmo > 50)
			{
				return 0;
			}
			return result;
		case 2:
			if (totalAmmo != 0)
			{
				return 0;
			}
			return result;
		default:
			return 0;
		}
	}

	public override void IOStateChanged(int inputAmount, int inputSlot)
	{
		base.IOStateChanged(inputAmount, inputSlot);
		if (IsPowered() && !IsOn())
		{
			InitiateStartup();
		}
		else if ((!IsPowered() && IsOn()) || booting)
		{
			InitiateShutdown();
		}
	}

	public void InitiateShutdown()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if ((!IsOffline() || booting) && Interface.CallHook("OnTurretShutdown", (object)this) == null)
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)SetOnline);
			booting = false;
			Effect.server.Run(offlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			SetIsOnline(online: false);
		}
	}

	public void InitiateStartup()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOnline() && !booting && Interface.CallHook("OnTurretStartup", (object)this) == null)
		{
			Effect.server.Run(onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
			((FacepunchBehaviour)this).Invoke((Action)SetOnline, 2f);
			booting = true;
		}
	}

	public void SetPeacekeepermode(bool isOn)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (PeacekeeperMode() != isOn)
		{
			SetFlag(Flags.Reserved1, isOn);
			Effect.server.Run(peacekeeperToggleSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero);
		}
	}

	public bool IsValidWeapon(Item item)
	{
		ItemDefinition info = item.info;
		if (item.isBroken)
		{
			return false;
		}
		ItemModEntity component = ((Component)info).GetComponent<ItemModEntity>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		HeldEntity component2 = component.entityPrefab.Get().GetComponent<HeldEntity>();
		if ((Object)(object)component2 == (Object)null)
		{
			return false;
		}
		if (!component2.IsUsableByTurret)
		{
			return false;
		}
		return true;
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		Item slot = base.inventory.GetSlot(0);
		if (IsValidWeapon(item) && targetSlot == 0)
		{
			return true;
		}
		if (item.info.category == ItemCategory.Ammunition)
		{
			ItemModProjectile component = ((Component)item.info).GetComponent<ItemModProjectile>();
			BaseProjectile attachedWeapon = GetAttachedWeapon();
			if (slot == null || (Object)(object)attachedWeapon == (Object)null || (Object)(object)component == (Object)null)
			{
				return false;
			}
			if ((attachedWeapon.primaryMagazine.definition.ammoTypes & component.ammoType) == 0)
			{
				return false;
			}
			if (targetSlot == 0)
			{
				return false;
			}
			return true;
		}
		return false;
	}

	public bool AtMaxAuthCapacity()
	{
		return HasFlag(Flags.Reserved4);
	}

	public void UpdateMaxAuthCapacity()
	{
		if (authorizedPlayers.Count >= 200)
		{
			SetFlag(Flags.Reserved4, b: true);
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		bool b = (Object)(object)activeGameMode != (Object)null && activeGameMode.limitTeamAuths && authorizedPlayers.Count >= activeGameMode.GetMaxRelationshipTeamSize();
		SetFlag(Flags.Reserved4, b);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void FlipAim(RPCMessage rpc)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOnline() && IsAuthed(rpc.player) && !booting && Interface.CallHook("OnTurretRotate", (object)this, (object)rpc.player) == null)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(-((Component)this).transform.forward, ((Component)this).transform.up);
			SendNetworkUpdate();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void AddSelfAuthorize(RPCMessage rpc)
	{
		AddSelfAuthorize(rpc.player);
	}

	public void AddSelfAuthorize(BasePlayer player)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Expected O, but got Unknown
		BasePlayer player2 = player;
		if (!IsOnline() && player2.CanBuild() && !AtMaxAuthCapacity() && Interface.CallHook("OnTurretAuthorize", (object)this, (object)player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)player2.userID);
			PlayerNameID val = new PlayerNameID();
			val.userid = player2.userID;
			val.username = player2.displayName;
			authorizedPlayers.Add(val);
			Analytics.Azure.OnEntityAuthChanged(this, player2, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", player2.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RemoveSelfAuthorize(RPCMessage rpc)
	{
		RPCMessage rpc2 = rpc;
		if (!booting && !IsOnline() && IsAuthed(rpc2.player) && Interface.CallHook("OnTurretDeauthorize", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == (ulong)rpc2.player.userID);
			authDirty = true;
			Analytics.Azure.OnEntityAuthChanged(this, rpc2.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "removed", rpc2.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void ClearList(RPCMessage rpc)
	{
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !booting && !IsOnline() && player.CanBuild() && Interface.CallHook("OnTurretClearList", (object)this, (object)rpc.player) == null)
		{
			authorizedPlayers.Clear();
			authDirty = true;
			Analytics.Azure.OnEntityAuthChanged(this, rpc.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "clear", rpc.player.userID);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void AssignToFriend(RPCMessage msg)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Expected O, but got Unknown
		if (AtMaxAuthCapacity() || (Object)(object)msg.player == (Object)null || !msg.player.CanInteract() || !CanChangeSettings(msg.player))
		{
			return;
		}
		ulong num = msg.read.UInt64();
		if (num != 0L && !IsAuthed(num) && Interface.CallHook("OnTurretAssign", (object)this, (object)num, (object)msg.player) == null)
		{
			string username = BasePlayer.SanitizePlayerNameString(msg.read.String(256, false), num);
			PlayerNameID val = new PlayerNameID();
			val.userid = num;
			val.username = username;
			Analytics.Azure.OnEntityAuthChanged(this, msg.player, authorizedPlayers.Select((PlayerNameID x) => x.userid), "added", num);
			authorizedPlayers.Add(val);
			UpdateMaxAuthCapacity();
			SendNetworkUpdate();
			Interface.CallHook("OnTurretAssigned", (object)this, (object)num, (object)msg.player);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_Peacekeeper(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player) && Interface.CallHook("OnTurretModeToggle", (object)this, (object)rpc.player) == null)
		{
			SetPeacekeepermode(isOn: true);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_AttackAll(RPCMessage rpc)
	{
		if (IsAuthed(rpc.player) && Interface.CallHook("OnTurretModeToggle", (object)this, (object)rpc.player) == null)
		{
			SetPeacekeepermode(isOn: false);
		}
	}

	public virtual float TargetScanRate()
	{
		return 1f;
	}

	public override void ServerInit()
	{
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		TargetTrigger obj = targetTrigger;
		obj.OnEntityEnterTrigger = (Action<BaseNetworkable>)Delegate.Combine(obj.OnEntityEnterTrigger, new Action<BaseNetworkable>(OnEntityEnterTrigger));
		timeSinceLastServerTick = 0.0;
		((FacepunchBehaviour)this).InvokeRepeating((Action)ServerTick, Random.Range(0f, 1f), 0.015f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SendAimDir, Random.Range(0f, 1f), 0.2f, 0.05f);
		((PersistentObjectWorkQueue<AutoTurret>)updateAutoTurretScanQueue).Add(this);
		((Component)targetTrigger).GetComponent<SphereCollider>().radius = sightRange;
		UpdateNearbyTurrets(created: true);
		cachedTransf = ((Component)this).transform;
		rotateMode = ((gun_pitch.localPosition.x == 0f && gun_pitch.localPosition.z == 0f) ? YawPitchMode.Merged : YawPitchMode.Separate);
		if (rotateMode == YawPitchMode.Merged)
		{
			toPitchFromRootOrYaw = cachedTransf.worldToLocalMatrix * gun_pitch.localToWorldMatrix;
			gunAimInitialPitchOrTotalRot = ((Matrix4x4)(ref toPitchFromRootOrYaw)).rotation;
		}
		else
		{
			toYawFromRoot = ((Component)this).transform.root.worldToLocalMatrix * gun_yaw.localToWorldMatrix;
			gunAimInitialYawRot = ((Matrix4x4)(ref toYawFromRoot)).rotation;
			toPitchFromRootOrYaw = gun_yaw.worldToLocalMatrix * gun_pitch.localToWorldMatrix;
			gunAimInitialPitchOrTotalRot = ((Matrix4x4)(ref toPitchFromRootOrYaw)).rotation;
			gunAimTotalRotWS = gun_pitch.rotation;
		}
		if (Object.op_Implicit((Object)(object)RCEyes))
		{
			toRCEyesFromPitch = gun_pitch.worldToLocalMatrix * RCEyes.localToWorldMatrix;
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		((PersistentObjectWorkQueue<AutoTurret>)updateAutoTurretScanQueue).Remove(this);
		UpdateNearbyTurrets(created: false);
	}

	public void OnEntityEnterTrigger(BaseNetworkable entity)
	{
		if (entity is BasePlayer player && !IsAuthed(player))
		{
			authDirty = true;
		}
	}

	public void SendAimDir()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (Time.realtimeSinceStartupAsDouble > nextForcedAimTime || HasTarget() || Vector3.Angle(lastSentAimDir, aimDir) > 0.03f)
		{
			SendAimDirImmediate();
		}
	}

	public void SendAimDirImmediate()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		lastSentAimDir = aimDir;
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceiveAimDir"), aimDir);
		nextForcedAimTime = Time.realtimeSinceStartupAsDouble + 2.0;
	}

	public void SetTarget(BaseCombatEntity targ)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnTurretTarget", (object)this, (object)targ) != null)
		{
			return;
		}
		if ((Object)(object)targ != (Object)(object)target || targ.IsRealNull() != target.IsRealNull())
		{
			Effect.server.Run(((Object)(object)targ == (Object)null) ? targetLostEffect.resourcePath : targetAcquiredEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
			if (outputs != null && outputs.Length != 0 && (Object)(object)outputs[0].connectedTo.Get() != (Object)null)
			{
				MarkDirtyForceUpdateOutputs();
			}
			nextShotTime += 0.10000000149011612;
			authDirty = true;
		}
		target = targ;
		if (target.IsRealNull())
		{
			targetVisible = false;
			nextVisCheck = 0.0;
		}
	}

	public virtual bool CheckPeekers()
	{
		return true;
	}

	public bool ObjectVisible(BaseCombatEntity obj)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		object obj2 = Interface.CallHook("CanBeTargeted", (object)obj, (object)this);
		if (obj2 is bool)
		{
			return (bool)obj2;
		}
		Vector3 position = ((Component)eyePos).transform.position;
		if (GamePhysics.CheckSphere(position, 0.1f, 2097152, (QueryTriggerInteraction)0))
		{
			return false;
		}
		Vector3 val = AimOffset(obj);
		float num = Vector3.Distance(val, position);
		Vector3 val2 = val - position;
		Vector3 val3 = Vector3.Cross(((Vector3)(ref val2)).normalized, Vector3.up);
		if (num > sightRange)
		{
			return false;
		}
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		for (int i = 0; (float)i < (CheckPeekers() ? 3f : 1f); i++)
		{
			val2 = val + val3 * visibilityOffsets[i] - position;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			list.Clear();
			GamePhysics.TraceAll(new Ray(position, normalized), 0f, list, num * 1.1f, 1218652417, (QueryTriggerInteraction)0);
			for (int j = 0; j < list.Count; j++)
			{
				BaseEntity entity = list[j].GetEntity();
				if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!((Object)(object)entity != (Object)null) || !((Object)(object)entity.ToPlayer() != (Object)null) || entity.EqualNetID((BaseNetworkable)obj)) && (!((Object)(object)entity != (Object)null) || !entity.EqualNetID((BaseNetworkable)this)))
				{
					if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)obj || entity.EqualNetID((BaseNetworkable)obj)))
					{
						Pool.FreeUnmanaged<RaycastHit>(ref list);
						peekIndex = i;
						return true;
					}
					if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
					{
						break;
					}
				}
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	public virtual void FireAttachedGun(Vector3 targetPos, float aimCone, BaseCombatEntity target = null, float damageModifier = 1f, float speedModifier = 1f)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if (!((Object)(object)attachedWeapon == (Object)null) && !IsOffline() && (!(attachedWeapon is ITurretNotify turretNotify) || turretNotify.CanShoot()))
		{
			Matrix4x4 val = GetCenterMuzzle();
			if (IsBeingControlled)
			{
				val *= toRCEyesFromPitch;
			}
			attachedWeapon.ServerUse(damageModifier, speedModifier, val, useBulletThickness: false);
		}
	}

	public virtual void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse = null, BaseCombatEntity target = null)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		if (IsOffline())
		{
			return;
		}
		if ((Object)(object)muzzleToUse == (Object)null)
		{
			muzzleToUse = muzzlePos;
		}
		Matrix4x4 centerMuzzle = GetCenterMuzzle();
		Vector3 val = ((Matrix4x4)(ref centerMuzzle)).MultiplyVector(Vector3.forward);
		Vector3 val2 = ((Matrix4x4)(ref centerMuzzle)).GetPosition() - val * 0.25f;
		Vector3 val3 = val;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, val3);
		targetPos = val2 + modifiedAimConeDirection * 300f;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(val2, modifiedAimConeDirection), 0f, list, 300f, 1220225809, (QueryTriggerInteraction)0);
		bool flag = false;
		for (int i = 0; i < list.Count; i++)
		{
			RaycastHit hit = list[i];
			BaseEntity entity = hit.GetEntity();
			if (((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || entity.EqualNetID((BaseNetworkable)this))) || (PeacekeeperMode() && (Object)(object)target != (Object)null && (Object)(object)entity != (Object)null && (Object)(object)((Component)entity).GetComponent<BasePlayer>() != (Object)null && !entity.EqualNetID((BaseNetworkable)target)))
			{
				continue;
			}
			BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
			if ((Object)(object)baseCombatEntity != (Object)null)
			{
				ApplyDamage(baseCombatEntity, ((RaycastHit)(ref hit)).point, modifiedAimConeDirection);
				if (baseCombatEntity.EqualNetID((BaseNetworkable)target))
				{
					flag = true;
				}
			}
			if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
			{
				targetPos = ((RaycastHit)(ref hit)).point;
				Vector3 val4 = targetPos - val2;
				val3 = ((Vector3)(ref val4)).normalized;
				break;
			}
		}
		int num = 2;
		if (!flag)
		{
			numConsecutiveMisses++;
		}
		else
		{
			numConsecutiveMisses = 0;
		}
		if ((Object)(object)target != (Object)null && targetVisible && numConsecutiveMisses > num)
		{
			ApplyDamage(target, ((Component)target).transform.position - val3 * 0.25f, val3);
			numConsecutiveMisses = 0;
		}
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_FireGun"), StringPool.Get(((Object)((Component)muzzleToUse).gameObject).name), targetPos);
		Pool.FreeUnmanaged<RaycastHit>(ref list);
	}

	public void ApplyDamage(BaseCombatEntity entity, Vector3 point, Vector3 normal)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		float num = 15f * Random.Range(0.9f, 1.1f);
		if (entity is BasePlayer && (Object)(object)entity != (Object)(object)target)
		{
			num *= 0.5f;
		}
		if (PeacekeeperMode() && (Object)(object)entity == (Object)(object)target)
		{
			target.MarkHostileFor(300f);
		}
		HitInfo info = new HitInfo(this, entity, DamageType.Bullet, num, point);
		entity.OnAttacked(info);
		if (entity is BasePlayer || entity is BaseNpc)
		{
			Effect.server.ImpactEffect(new HitInfo
			{
				HitPositionWorld = point,
				HitNormalWorld = -normal,
				HitMaterial = StringPool.Get("Flesh")
			});
		}
	}

	public void IdleTick(float dt)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if (Object.op_Implicit((Object)(object)attachedWeapon) && attachedWeapon is ITurretNotify turretNotify)
		{
			turretNotify.WarmupTick(wantsShoot: false);
		}
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		if (realtimeSinceStartupAsDouble > nextIdleAimTime)
		{
			nextIdleAimTime = realtimeSinceStartupAsDouble + (double)Random.Range(4f, 5f);
			Quaternion val = Quaternion.LookRotation(((Component)this).transform.forward, Vector3.up);
			val *= Quaternion.AngleAxis(Random.Range(-45f, 45f), Vector3.up);
			targetAimDir = val * Vector3.forward;
		}
		if (!HasTarget())
		{
			aimDir = Mathx.Lerp(aimDir, targetAimDir, 2f, dt);
		}
	}

	public virtual bool HasClipAmmo()
	{
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if ((Object)(object)attachedWeapon == (Object)null)
		{
			return false;
		}
		return attachedWeapon.primaryMagazine.contents > 0;
	}

	public virtual bool HasReserveAmmo()
	{
		return totalAmmo > 0;
	}

	public int GetTotalAmmo()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if ((Object)(object)attachedWeapon == (Object)null)
		{
			return num;
		}
		List<Item> ammos = Pool.Get<List<Item>>();
		base.inventory.FindAmmo(ammos, attachedWeapon.primaryMagazine.definition.ammoTypes);
		if (!attachedWeapon.primaryMagazine.allowAmmoSwitching)
		{
			BaseProjectile.StripAmmoToType(ref ammos, attachedWeapon.primaryMagazine.ammoType);
		}
		for (int i = 0; i < ammos.Count; i++)
		{
			num += ammos[i].amount;
		}
		Pool.Free<Item>(ref ammos, false);
		return num;
	}

	public AmmoTypes GetValidAmmoTypes()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if ((Object)(object)attachedWeapon == (Object)null)
		{
			return (AmmoTypes)2;
		}
		return attachedWeapon.primaryMagazine.definition.ammoTypes;
	}

	public ItemDefinition GetDesiredAmmo()
	{
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if ((Object)(object)attachedWeapon == (Object)null)
		{
			return null;
		}
		return attachedWeapon.primaryMagazine.ammoType;
	}

	public void Reload()
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if ((Object)(object)attachedWeapon == (Object)null)
		{
			return;
		}
		_ = attachedWeapon.primaryMagazine.ammoType;
		float turretReloadDuration = attachedWeapon.GetTurretReloadDuration();
		nextShotTime = math.max(nextShotTime, Time.timeAsDouble + (double)Mathf.Min(turretReloadDuration, 2f));
		AmmoTypes ammoTypes = attachedWeapon.primaryMagazine.definition.ammoTypes;
		if (attachedWeapon.primaryMagazine.contents > 0)
		{
			bool flag = false;
			if (base.inventory.capacity > base.inventory.itemList.Count)
			{
				flag = true;
			}
			else
			{
				int num = 0;
				foreach (Item item in base.inventory.itemList)
				{
					if ((Object)(object)item.info == (Object)(object)attachedWeapon.primaryMagazine.ammoType)
					{
						num += item.MaxStackable() - item.amount;
					}
				}
				flag = num >= attachedWeapon.primaryMagazine.contents;
			}
			if (!flag)
			{
				return;
			}
			base.inventory.AddItem(attachedWeapon.primaryMagazine.ammoType, attachedWeapon.primaryMagazine.contents, 0uL);
			attachedWeapon.SetAmmoCount(0);
		}
		List<Item> ammos = Pool.Get<List<Item>>();
		base.inventory.FindAmmo(ammos, ammoTypes);
		if (!attachedWeapon.primaryMagazine.allowAmmoSwitching)
		{
			BaseProjectile.StripAmmoToType(ref ammos, attachedWeapon.primaryMagazine.ammoType);
		}
		if (ammos.Count > 0)
		{
			Effect.server.Run(reloadEffect.resourcePath, this, StringPool.Get("WeaponAttachmentPoint"), Vector3.zero, Vector3.zero);
			totalAmmoDirty = true;
			attachedWeapon.primaryMagazine.ammoType = ammos[0].info;
			int num2 = 0;
			while (attachedWeapon.primaryMagazine.contents < attachedWeapon.primaryMagazine.capacity && num2 < ammos.Count)
			{
				if ((Object)(object)ammos[num2].info == (Object)(object)attachedWeapon.primaryMagazine.ammoType)
				{
					int num3 = attachedWeapon.primaryMagazine.capacity - attachedWeapon.primaryMagazine.contents;
					num3 = Mathf.Min(ammos[num2].amount, num3);
					ammos[num2].UseItem(num3);
					attachedWeapon.ModifyAmmoCount(num3);
				}
				num2++;
			}
		}
		ItemDefinition ammoType = attachedWeapon.primaryMagazine.ammoType;
		if (Object.op_Implicit((Object)(object)ammoType))
		{
			ItemModProjectile component = ((Component)ammoType).GetComponent<ItemModProjectile>();
			GameObject val = component.projectileObject.Get();
			if (Object.op_Implicit((Object)(object)val))
			{
				if (Object.op_Implicit((Object)(object)val.GetComponent<Projectile>()))
				{
					currentAmmoGravity = 0f;
					currentAmmoVelocity = component.GetMaxVelocity();
				}
				else
				{
					ServerProjectile component2 = val.GetComponent<ServerProjectile>();
					if (Object.op_Implicit((Object)(object)component2))
					{
						currentAmmoGravity = component2.gravityModifier;
						currentAmmoVelocity = component2.speed;
					}
				}
			}
		}
		Pool.Free<Item>(ref ammos, false);
		attachedWeapon.SendNetworkUpdate();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		totalAmmoDirty = true;
		Reload();
		UpdateNearbyTurrets(created: true);
	}

	public void UpdateTotalAmmo()
	{
		int num = totalAmmo;
		totalAmmo = GetTotalAmmo();
		if (num != totalAmmo && ((Object)(object)outputs[1].connectedTo.Get() != (Object)null || (Object)(object)outputs[2].connectedTo.Get() != (Object)null))
		{
			MarkDirtyForceUpdateOutputs();
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (Object.op_Implicit((Object)(object)((Component)item.info).GetComponent<ItemModEntity>()))
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)UpdateAttachedWeapon))
			{
				UpdateAttachedWeapon();
			}
			((FacepunchBehaviour)this).Invoke((Action)UpdateAttachedWeapon, 0.5f);
		}
	}

	public bool EnsureReloaded(bool onlyReloadIfEmpty = true)
	{
		bool flag = HasReserveAmmo();
		if (onlyReloadIfEmpty)
		{
			if (flag && !HasClipAmmo())
			{
				Reload();
				return true;
			}
		}
		else if (flag)
		{
			Reload();
			return true;
		}
		return false;
	}

	public BaseProjectile GetAttachedWeapon()
	{
		return AttachedWeapon as BaseProjectile;
	}

	public virtual bool HasFallbackWeapon()
	{
		return false;
	}

	public bool HasGenericFireable()
	{
		if ((Object)(object)AttachedWeapon != (Object)null)
		{
			return AttachedWeapon.IsInstrument();
		}
		return false;
	}

	public void UpdateAttachedWeapon()
	{
		HeldEntity heldEntity = TryAddWeaponToTurret(base.inventory.GetSlot(0), socketTransform, this, attachedWeaponZOffsetScale);
		bool flag = (Object)(object)heldEntity != (Object)null;
		SetFlag(Flags.Reserved3, flag);
		if (flag)
		{
			AttachedWeapon = heldEntity;
			totalAmmoDirty = true;
			Reload();
			UpdateTotalAmmo();
			if (IsOffline())
			{
				heldEntity.SetLightsOn(isOn: false);
			}
		}
		else
		{
			BaseProjectile attachedWeapon = GetAttachedWeapon();
			if ((Object)(object)attachedWeapon != (Object)null)
			{
				attachedWeapon.SetGenericVisible(wantsVis: false);
				attachedWeapon.SetLightsOn(isOn: false);
				if (attachedWeapon is ITurretNotify turretNotify)
				{
					turretNotify.OnAddedRemovedToTurret(added: false);
				}
			}
			AttachedWeapon = null;
		}
		bool b = false;
		if (flag)
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			b = (Object)(object)component != (Object)null && component.largeTurretWeapon;
		}
		SetFlag(Flags.Reserved5, b);
	}

	public static HeldEntity TryAddWeaponToTurret(Item weaponItem, Transform parent, BaseEntity entityParent, float zOffsetScale)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		HeldEntity heldEntity = null;
		if (weaponItem != null && (weaponItem.info.category == ItemCategory.Weapon || weaponItem.info.category == ItemCategory.Fun))
		{
			BaseEntity heldEntity2 = weaponItem.GetHeldEntity();
			if ((Object)(object)heldEntity2 != (Object)null)
			{
				HeldEntity component = ((Component)heldEntity2).GetComponent<HeldEntity>();
				if ((Object)(object)component != (Object)null && component.IsUsableByTurret)
				{
					heldEntity = component;
				}
			}
		}
		if ((Object)(object)heldEntity == (Object)null)
		{
			return null;
		}
		Transform transform = ((Component)heldEntity).transform;
		Transform muzzleTransform = heldEntity.MuzzleTransform;
		heldEntity.SetParent(null);
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		Quaternion val = transform.rotation * Quaternion.Inverse(muzzleTransform.rotation);
		heldEntity.limitNetworking = false;
		heldEntity.SetFlag(Flags.Disabled, b: false);
		heldEntity.SetParent(entityParent, StringPool.Get(((Object)parent).name));
		transform.localPosition = Vector3.zero;
		transform.localRotation = Quaternion.identity;
		transform.rotation *= val;
		Vector3 val2 = parent.InverseTransformPoint(muzzleTransform.position);
		transform.localPosition = Vector3.left * val2.x;
		float num = Vector3.Distance(muzzleTransform.position, transform.position);
		transform.localPosition += Vector3.forward * num * zOffsetScale;
		heldEntity.SetGenericVisible(wantsVis: true);
		heldEntity.SetLightsOn(isOn: true);
		if (heldEntity is ITurretNotify turretNotify)
		{
			turretNotify.OnAddedRemovedToTurret(added: true);
		}
		return heldEntity;
	}

	public override void OnDied(HitInfo info)
	{
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if ((Object)(object)attachedWeapon != (Object)null)
		{
			attachedWeapon.SetGenericVisible(wantsVis: false);
			attachedWeapon.SetLightsOn(isOn: false);
			if (attachedWeapon is ITurretNotify turretNotify)
			{
				turretNotify.OnAddedRemovedToTurret(added: false);
			}
		}
		AttachedWeapon = null;
		base.OnDied(info);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if (!IsAuthed(baseEntity))
		{
			return false;
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		UpdateTotalAmmo();
		EnsureReloaded(onlyReloadIfEmpty: false);
		UpdateTotalAmmo();
		nextShotTime = Time.timeAsDouble;
	}

	public virtual float GetMaxAngleForEngagement()
	{
		return 1f;
	}

	public void TargetTick()
	{
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		double timeAsDouble = Time.timeAsDouble;
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		if (realtimeSinceStartupAsDouble >= nextVisCheck)
		{
			nextVisCheck = realtimeSinceStartupAsDouble + (double)Random.Range(0.2f, 0.3f);
			targetVisible = ObjectVisible(target);
			if (targetVisible)
			{
				lastTargetSeenTime = realtimeSinceStartupAsDouble;
			}
		}
		EnsureReloaded();
		BaseProjectile attachedWeapon = GetAttachedWeapon();
		if (!(timeAsDouble >= nextShotTime) || !targetVisible || !(Mathf.Abs(AngleToTarget(target, currentAmmoGravity != 0f)) < GetMaxAngleForEngagement()))
		{
			return;
		}
		if (Object.op_Implicit((Object)(object)attachedWeapon))
		{
			if (attachedWeapon is ITurretNotify turretNotify)
			{
				turretNotify.WarmupTick(wantsShoot: true);
			}
			float damageModifier = 1f;
			float speedModifier = 1f;
			ItemDefinition ammoType = attachedWeapon.primaryMagazine.ammoType;
			if (Object.op_Implicit((Object)(object)ammoType))
			{
				ItemModProjectile component = ((Component)ammoType).GetComponent<ItemModProjectile>();
				if (Object.op_Implicit((Object)(object)component) && component.projectileVelocity < 100f)
				{
					speedModifier = 2f;
				}
			}
			if (attachedWeapon.primaryMagazine.contents > 0)
			{
				if (target.GetParentEntity() is TrainCar trainCar)
				{
					Vector3 worldVelocity = trainCar.GetWorldVelocity();
					float magnitude = ((Vector3)(ref worldVelocity)).magnitude;
					float num = Mathf.Pow(1f - TrainCar.TrainTurretInaccuratePerVelocity, magnitude);
					if (Random.Range(0f, 1f) > num)
					{
						damageModifier = 0f;
					}
				}
				FireAttachedGun(AimOffset(target), aimCone, PeacekeeperMode() ? target : null, damageModifier, speedModifier);
				float delay = (attachedWeapon.isSemiAuto ? (attachedWeapon.repeatDelay * 1.5f) : attachedWeapon.repeatDelay);
				delay = attachedWeapon.ScaleRepeatDelay(delay);
				nextShotTime = timeAsDouble + (double)delay;
				shouldUpdateOnOutOfAmmo = true;
			}
			else
			{
				nextShotTime = timeAsDouble + 5.0;
				if (shouldUpdateOnOutOfAmmo)
				{
					shouldUpdateOnOutOfAmmo = false;
					attachedWeapon.SendNetworkUpdate();
				}
			}
		}
		else if (HasFallbackWeapon())
		{
			FireGun(AimOffset(target), aimCone, null, target);
			nextShotTime = timeAsDouble + 0.11500000208616257;
		}
		else if (HasGenericFireable())
		{
			AttachedWeapon.ServerUse(1f, 1f, null);
			nextShotTime = timeAsDouble + 0.11500000208616257;
		}
		else
		{
			nextShotTime = timeAsDouble + 1.0;
		}
	}

	public bool HasTarget()
	{
		if ((Object)(object)target != (Object)null)
		{
			return target.IsAlive();
		}
		return false;
	}

	public void OfflineTick()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		aimDir = Vector3.up;
	}

	public virtual bool IsEntityHostile(BaseCombatEntity ent)
	{
		if (ent is ScarecrowNPC)
		{
			return true;
		}
		if (ent is BasePet basePet && (Object)(object)basePet.Brain.OwningPlayer != (Object)null)
		{
			if (!basePet.Brain.OwningPlayer.IsHostile())
			{
				return ent.IsHostile();
			}
			return true;
		}
		return ent.IsHostile();
	}

	public bool ShouldTarget(BaseCombatEntity targ)
	{
		if (targ is AutoTurret)
		{
			return false;
		}
		if (targ is RidableHorse)
		{
			return false;
		}
		if (targ is BasePet basePet && (Object)(object)basePet.Brain.OwningPlayer != (Object)null && IsAuthed(basePet.Brain.OwningPlayer))
		{
			return false;
		}
		return true;
	}

	public void ScheduleForTargetScan()
	{
		((PersistentObjectWorkQueue<AutoTurret>)updateAutoTurretScanQueue).Add(this);
	}

	public bool HasInterference()
	{
		return IsOnFire();
	}

	public void TryRegisterForInterferenceUpdate()
	{
		if (IsOn() && interferenceUpdateList.Add(this))
		{
			UpdateInterferenceOnOthers();
		}
	}

	public void UpdateInterference()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOn() || Interface.CallHook("OnInterferenceUpdate", (object)this) != null)
		{
			return;
		}
		float num = 0f;
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if (!nearbyTurret.isClient && nearbyTurret.IsValid() && ((Component)nearbyTurret).gameObject.activeSelf && !nearbyTurret.EqualNetID(net.ID) && nearbyTurret.IsOn() && !nearbyTurret.HasInterference())
			{
				num += 1f;
			}
		}
		SetFlag(Flags.OnFire, num >= (float)Sentry.maxinterference);
	}

	public void UpdateInterferenceOnOthers()
	{
		if (Interface.CallHook("OnInterferenceOthersUpdate", (object)this) != null)
		{
			return;
		}
		foreach (AutoTurret nearbyTurret in nearbyTurrets)
		{
			if ((Object)(object)nearbyTurret != (Object)null)
			{
				nearbyTurret.TryRegisterForInterferenceUpdate();
			}
		}
	}

	public void UpdateNearbyTurrets(bool created)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		List<AutoTurret> list = Pool.Get<List<AutoTurret>>();
		if (Interface.CallHook("OnNearbyTurretsScan", (object)this, (object)list, (object)created) == null)
		{
			Vis.Entities(((Component)this).transform.position, Sentry.interferenceradius, list, 256, (QueryTriggerInteraction)1);
		}
		foreach (AutoTurret item in list)
		{
			if (!((Object)(object)item == (Object)(object)this))
			{
				if (created)
				{
					nearbyTurrets.Add(item);
					item.nearbyTurrets.Add(this);
				}
				else
				{
					item.nearbyTurrets.Remove(this);
				}
			}
		}
		if (!created)
		{
			nearbyTurrets.Clear();
		}
		Pool.FreeUnmanaged<AutoTurret>(ref list);
	}

	public void TargetScan()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		if (!target.IsRealNull())
		{
			double num = realtimeSinceStartupAsDouble - lastTargetSeenTime;
			double num2 = realtimeSinceStartupAsDouble - lastDamageEventTime;
			if ((Object)(object)target == (Object)null || target.IsDead() || (num > 3.0 && num2 > 3.0) || Vector3.Distance(((Component)this).transform.position, ((Component)target).transform.position) > sightRange || (PeacekeeperMode() && !IsEntityHostile(target)))
			{
				SetTarget(null);
			}
		}
		if (HasInterference())
		{
			if (HasTarget())
			{
				SetTarget(null);
			}
		}
		else
		{
			if (HasTarget() || IsOffline() || IsBeingControlled || aimDir == Vector3.up)
			{
				return;
			}
			bool flag = targetTrigger.entityContents != null && !targetTrigger.entityContents.IsEmpty() && realtimeSinceStartupAsDouble - lastScanTime >= (double)Sentry.scantimer;
			if (!authDirty && !flag)
			{
				return;
			}
			authDirty = false;
			lastScanTime = realtimeSinceStartupAsDouble;
			if (targetTrigger.entityContents != null)
			{
				foreach (BaseEntity entityContent in targetTrigger.entityContents)
				{
					BaseCombatEntity baseCombatEntity = entityContent as BaseCombatEntity;
					if ((Object)(object)baseCombatEntity == (Object)null)
					{
						continue;
					}
					if (!Sentry.targetall)
					{
						BasePlayer basePlayer = baseCombatEntity as BasePlayer;
						if ((Object)(object)basePlayer != (Object)null && (IsAuthed(basePlayer) || Ignore(basePlayer)))
						{
							continue;
						}
					}
					if ((!PeacekeeperMode() || IsEntityHostile(baseCombatEntity)) && baseCombatEntity.IsAlive() && ShouldTarget(baseCombatEntity) && InFiringArc(baseCombatEntity) && ObjectVisible(baseCombatEntity))
					{
						SetTarget(baseCombatEntity);
						if (target != null)
						{
							break;
						}
					}
				}
			}
			if (PeacekeeperMode() && (Object)(object)target == (Object)null)
			{
				nextShotTime = Time.timeAsDouble + 1.0;
			}
		}
	}

	public virtual bool Ignore(BasePlayer player)
	{
		return false;
	}

	public void ServerTick()
	{
		if (base.isClient || base.IsDestroyed)
		{
			return;
		}
		float dt = (float)(double)timeSinceLastServerTick;
		timeSinceLastServerTick = 0.0;
		if (!IsOnline())
		{
			OfflineTick();
		}
		else if (!IsBeingControlled)
		{
			if (HasTarget())
			{
				TargetTick();
			}
			else
			{
				IdleTick(dt);
			}
		}
		UpdateFacingToTarget(dt);
		if (totalAmmoDirty && Time.timeAsDouble > nextAmmoCheckTime)
		{
			UpdateTotalAmmo();
			totalAmmoDirty = false;
			nextAmmoCheckTime = Time.timeAsDouble + 0.5;
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
		if (((IsOnline() && !HasTarget()) || !targetVisible) && !((Object)(object)(info.Initiator as AutoTurret) != (Object)null) && !((Object)(object)(info.Initiator as SamSite) != (Object)null) && !((Object)(object)(info.Initiator as GunTrap) != (Object)null))
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (!Object.op_Implicit((Object)(object)basePlayer) || !IsAuthed(basePlayer))
			{
				SetTarget(info.Initiator as BaseCombatEntity);
				lastDamageEventTime = Time.realtimeSinceStartupAsDouble;
			}
		}
	}

	public void UpdateFacingToTarget(float dt)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)target != (Object)null && targetVisible && !IsBeingControlled)
		{
			Vector3 val = AimOffset(target);
			Vector3 position = eyePos.position;
			Vector3 val3;
			if (peekIndex != 0)
			{
				Vector3 val2 = position;
				Vector3.Distance(val, val2);
				val3 = val - val2;
				Vector3 val4 = Vector3.Cross(((Vector3)(ref val3)).normalized, Vector3.up);
				val += val4 * visibilityOffsets[peekIndex];
			}
			val3 = val - position;
			Vector3 val5 = ((Vector3)(ref val3)).normalized;
			if (currentAmmoGravity != 0f)
			{
				float num = 0.2f;
				if (target is BasePlayer)
				{
					float num2 = Mathf.Clamp01(target.WaterFactor()) * 1.8f;
					if (num2 > num)
					{
						num = num2;
					}
				}
				val = ((Component)target).transform.position + Vector3.up * num;
				float angle = GetAngle(position, val, currentAmmoVelocity, currentAmmoGravity);
				Vector3 val6 = Vector3Ex.XZ3D(val) - Vector3Ex.XZ3D(position);
				val6 = ((Vector3)(ref val6)).normalized;
				val5 = Quaternion.LookRotation(val6) * Quaternion.Euler(angle, 0f, 0f) * Vector3.forward;
			}
			aimDir = val5;
		}
		UpdateAiming(dt);
	}

	public float GetAngle(Vector3 launchPosition, Vector3 targetPosition, float launchVelocity, float gravityScale)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		float num = Physics.gravity.y * gravityScale;
		float num2 = Vector3.Distance(Vector3Ex.XZ3D(launchPosition), Vector3Ex.XZ3D(targetPosition));
		float num3 = launchPosition.y - targetPosition.y;
		float num4 = Mathf.Pow(launchVelocity, 2f);
		float num5 = Mathf.Pow(launchVelocity, 4f);
		float num6 = Mathf.Atan((num4 + Mathf.Sqrt(num5 - num * (num * Mathf.Pow(num2, 2f) + 2f * num3 * num4))) / (num * num2)) * 57.29578f;
		float num7 = Mathf.Atan((num4 - Mathf.Sqrt(num5 - num * (num * Mathf.Pow(num2, 2f) + 2f * num3 * num4))) / (num * num2)) * 57.29578f;
		if (float.IsNaN(num6) && float.IsNaN(num7))
		{
			return -45f;
		}
		if (float.IsNaN(num6))
		{
			return num7;
		}
		if (!(num6 > num7))
		{
			return num7;
		}
		return num6;
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		AddSelfAuthorize(deployedBy);
	}

	public override ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifier)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return default(ItemContainerId);
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		bool num = item.info.category == ItemCategory.Weapon;
		bool flag = item.info.category == ItemCategory.Ammunition;
		if (num)
		{
			return 0;
		}
		if (flag)
		{
			for (int i = 1; i < base.inventory.capacity; i++)
			{
				if (!base.inventory.SlotTaken(item, i))
				{
					return i;
				}
			}
		}
		return -1;
	}
}


public class UpdateAutoTurretScanQueue : PersistentObjectWorkQueue<AutoTurret>
{
	protected override void RunJob(AutoTurret entity)
	{
		if (((PersistentObjectWorkQueue<AutoTurret>)this).ShouldAdd(entity))
		{
			entity.TargetScan();
		}
	}

	protected override bool ShouldAdd(AutoTurret entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


private enum YawPitchMode
{
	Separate,
	Merged
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;

public class BallistaGun : BaseVehicleSeat
{
	[Serializable]
	private struct Ammo
	{
		public ItemDefinition item;

		public GameObject go;
	}

	[Serializable]
	private struct FiringEffect
	{
		public ItemDefinition item;

		public GameObjectRef effectPrefab;
	}

	private enum AimDirection
	{
		Left,
		Right,
		Up,
		Down
	}

	[Header("Ballista")]
	[SerializeField]
	private bool isMountedOnVehicle = true;

	[SerializeField]
	private float turnSensivity = 2f;

	[SerializeField]
	private float reloadTime = 3f;

	[SerializeField]
	private float fovMultiplier = 1f;

	[SerializeField]
	private bool noHeadshots = true;

	[SerializeField]
	private CapsuleCollider playerServerCollider;

	[SerializeField]
	private BaseProjectile.Magazine magazine;

	[SerializeField]
	[Space]
	private Transform muzzle;

	[SerializeField]
	private Transform pitchTransform;

	[SerializeField]
	public Transform yawTransform;

	[SerializeField]
	public Transform mountTransform;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private GameObject ammoParent;

	public DamageRenderer damageRenderer;

	private Vector3 aimDir;

	[SerializeField]
	private Ammo[] ammoPrefabs;

	[Header("IK")]
	[SerializeField]
	public Transform leftHandTarget;

	[SerializeField]
	public Transform rightHandTarget;

	[SerializeField]
	[Header("Effects")]
	private FiringEffect[] muzzleFireEffects;

	[SerializeField]
	private SoundDefinition reloadedSound;

	[SerializeField]
	private SoundDefinition aimMovementSoundDef;

	[SerializeField]
	private AnimationCurve aimMovementGainCurve;

	private Sound aimMovementSound;

	private SoundModulation.Modulator aimMovementGainMod;

	[SerializeField]
	[Space]
	private bool runSideChecks;

	[SerializeField]
	private Transform leftGroundCheckTransform;

	[SerializeField]
	private Transform rightGroundCheckTransform;

	[SerializeField]
	private Transform[] leftSideCheckPositions;

	[SerializeField]
	private Transform[] rightSideCheckPositions;

	[SerializeField]
	private Vector3 originalLocalMountPos;

	[SerializeField]
	private bool runBoundsChecks;

	[SerializeField]
	private Bounds[] areaChecks;

	[NonSerialized]
	public Ballista ballistaOwner;

	[HideInInspector]
	public float reloadProgress;

	private bool justReloaded;

	private BasePlayer reloadingPlayer;

	private float steerInput;

	private float verticalRatio;

	private bool wasShowingLegs;

	private TimeSince lastReloadStartTime;

	private float fixedMountYRotation;

	[ClientVar(ClientAdmin = true)]
	public static bool debug;

	public const Flags Flag_Reloading = Flags.Reserved4;

	public const Flags Flag_Loaded = Flags.Reserved5;

	private readonly float progressTickRate = 0.1f;

	private RealTimeSinceEx timeSinceLastServerTick;

	private Vector3 lastSentAimDir = Vector3.zero;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BallistaGun.OnRpcMessage", 0);
		try
		{
			if (rpc == 1188838966 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_CancelReload "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_CancelReload", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(1188838966u, "SERVER_CancelReload", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(1188838966u, "SERVER_CancelReload", this, player, includeMounted: true))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(1188838966u, "SERVER_CancelReload", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(1188838966u, "SERVER_CancelReload", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SERVER_CancelReload(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SERVER_CancelReload");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 296086248 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_FireClientProjectile "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_FireClientProjectile", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(296086248u, "SERVER_FireClientProjectile", this, player, 1uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(296086248u, "SERVER_FireClientProjectile", this, player, includeMounted: true))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(296086248u, "SERVER_FireClientProjectile", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(296086248u, "SERVER_FireClientProjectile", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							SERVER_FireClientProjectile(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SERVER_FireClientProjectile");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2817383917u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_ReloadStart "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_ReloadStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2817383917u, "SERVER_ReloadStart", this, player, 3uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2817383917u, "SERVER_ReloadStart", this, player, includeMounted: true))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2817383917u, "SERVER_ReloadStart", this, player, 3f))
						{
							return true;
						}
						if (!RPC_Server.MaxDistance.Test(2817383917u, "SERVER_ReloadStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							SERVER_ReloadStart(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in SERVER_ReloadStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4118009042u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SERVER_SwitchAmmoTo "));
				}
				TimeWarning val2 = TimeWarning.New("SERVER_SwitchAmmoTo", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4118009042u, "SERVER_SwitchAmmoTo", this, player, 5uL))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							SERVER_SwitchAmmoTo(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in SERVER_SwitchAmmoTo");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	private bool HasOwner()
	{
		return (Object)(object)ballistaOwner != (Object)null;
	}

	private bool IsLoaded()
	{
		if (HasFlag(Flags.Reserved5) && magazine.contents == magazine.capacity)
		{
			return reloadProgress >= 0.94f;
		}
		return false;
	}

	private bool CanFire()
	{
		if (IsLoaded() && !HasFlag(Flags.Reserved4))
		{
			return !OwnerIsWaterlogged();
		}
		return false;
	}

	private bool CanReload()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (!IsLoaded() && TimeSince.op_Implicit(lastReloadStartTime) > 1f)
		{
			return !OwnerIsWaterlogged();
		}
		return false;
	}

	public bool OwnerIsWaterlogged()
	{
		if (HasOwner())
		{
			return ballistaOwner.IsWaterlogged();
		}
		return false;
	}

	public override void InitShared()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.InitShared();
		originalLocalMountPos = mountAnchor.localPosition;
	}

	private bool UpdateManualAim(InputState inputState)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		float y = mountAnchor.position.y;
		MoveMountAnchor();
		float num = y - mountAnchor.position.y;
		float num2 = 0f;
		if (Mathf.Abs(num) > 0.0001f)
		{
			num2 = (0f - num) * 50f;
		}
		float num3 = (0f - inputState.current.mouseDelta.y) * turnSensivity;
		float num4 = inputState.current.mouseDelta.x * turnSensivity;
		float num5 = turnSensivity * 2.5f;
		if (inputState.IsDown(BUTTON.LEFT))
		{
			num4 -= num5;
		}
		if (inputState.IsDown(BUTTON.RIGHT))
		{
			num4 += num5;
		}
		if (inputState.IsDown(BUTTON.BACKWARD))
		{
			num3 += num5;
		}
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			num3 += 0f - num5;
		}
		num3 += num2;
		if (!CanRotateInDirection(num4 > 0f))
		{
			num4 = 0f;
		}
		if (runBoundsChecks)
		{
			if (num4 != 0f && !CheckBallistaBounds((!(num4 < 0f)) ? AimDirection.Right : AimDirection.Left))
			{
				num4 = 0f;
			}
			if (num3 != 0f && !CheckBallistaBounds((num3 < 0f) ? AimDirection.Up : AimDirection.Down))
			{
				num3 = 0f;
			}
		}
		Quaternion val = Quaternion.LookRotation(aimDir, ((Component)this).transform.up);
		Vector3 val2 = ((Quaternion)(ref val)).eulerAngles + new Vector3(num3, num4, 0f);
		val2.x = ClampPitch(val2.x);
		Transform val3 = (HasOwner() ? ((Component)this).transform.parent : yawTransform);
		float y2 = val2.y;
		val = Quaternion.LookRotation(val3.forward, ((Component)this).transform.up);
		val2.y = ClampYaw(y2, ((Quaternion)(ref val)).eulerAngles.y);
		Vector3 val4 = Quaternion.Euler(val2) * Vector3.forward;
		bool result = !Mathf.Approximately(aimDir.x, val4.x) || !Mathf.Approximately(aimDir.y, val4.y) || !Mathf.Approximately(aimDir.z, val4.z);
		aimDir = val4;
		return result;
	}

	private bool CanRotateInDirection(bool rotatingLeft)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Transform checkTransform = (rotatingLeft ? leftGroundCheckTransform : rightGroundCheckTransform);
		Transform[] array = (rotatingLeft ? leftSideCheckPositions : rightSideCheckPositions);
		if (!HasGround(checkTransform))
		{
			return false;
		}
		if (runSideChecks)
		{
			Transform[] array2 = array;
			foreach (Transform val in array2)
			{
				if (HasColliderBlockingRotation(val.position, val.forward))
				{
					return false;
				}
			}
		}
		return true;
	}

	public void RotateBallista(float dt)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		if ((isMountedOnVehicle && (Object)(object)((Component)this).transform.parent == (Object)null) || aimDir == Vector3.zero)
		{
			return;
		}
		float num = 50f;
		Transform val = (isMountedOnVehicle ? ((Component)this).transform.parent : ((Component)this).transform);
		Vector3 val2 = val.InverseTransformDirection(aimDir);
		if (!(val2 == Vector3.zero))
		{
			Quaternion val3 = Quaternion.LookRotation(val2, Vector3.up);
			float num2 = ClampYaw(((Quaternion)(ref val3)).eulerAngles.y, 0f);
			float num3 = ClampPitch(((Quaternion)(ref val3)).eulerAngles.x);
			Quaternion val4 = Quaternion.Euler(0f, num2, 0f);
			Quaternion val5 = Quaternion.Euler(num3, 0f, 0f);
			Quaternion val6 = val.rotation * val4;
			if (yawTransform.rotation != val6)
			{
				yawTransform.rotation = Mathx.Lerp(yawTransform.rotation, val6, num, dt);
			}
			if (pitchTransform.localRotation != val5)
			{
				pitchTransform.localRotation = Mathx.Lerp(pitchTransform.localRotation, val5, num, dt);
			}
		}
	}

	private void UpdatePlayerModelPose()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.LookRotation(muzzle.forward, Vector3.up);
		float num = Mathf.InverseLerp(pitchClamp.y, pitchClamp.x, Mathf.DeltaAngle(0f, ((Quaternion)(ref val)).eulerAngles.x));
		verticalRatio = Mathf.Lerp(-1f, 1f, num);
	}

	private float ClampPitch(float pitch)
	{
		float num = Mathf.Clamp(Mathf.DeltaAngle(0f, pitch), pitchClamp.x, pitchClamp.y);
		if (num < 0f)
		{
			num += 360f;
		}
		return num;
	}

	private float ClampYaw(float targetYaw, float parentYaw)
	{
		float num = Mathf.DeltaAngle(parentYaw, targetYaw);
		num = Mathf.Clamp(num, yawClamp.x, yawClamp.y);
		return parentYaw + num;
	}

	private Item GetAmmoFromPlayerInventory(BasePlayer player)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		Item item = player.inventory.FindItemByItemID(magazine.ammoType.itemid);
		if (item == null && !magazine.allowAmmoSwitching)
		{
			return null;
		}
		if (item == null)
		{
			Item item2 = player.inventory.FindAmmo(magazine.definition.ammoTypes);
			if (item2 == null)
			{
				return null;
			}
			item = player.inventory.FindItemByItemID(item2.info.itemid);
			if (item == null)
			{
				return null;
			}
		}
		return item;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
	}

	private bool HasGround(Transform checkTransform)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f;
		RaycastHit val = default(RaycastHit);
		return Physics.SphereCast(checkTransform.position + Vector3.up * 0.6f, 0.1f, Vector3.down, ref val, num, 1503731969);
	}

	private bool HasColliderBlockingRotation(Vector3 origin, Vector3 direction)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.2f;
		RaycastHit val = default(RaycastHit);
		return Physics.SphereCast(origin, 0.05f, direction, ref val, num, 1503731969);
	}

	private void MoveMountAnchor()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = 2f;
		Vector3 val = mountAnchor.parent.TransformPoint(originalLocalMountPos) + Vector3.up * 0.8f;
		Vector3 down = Vector3.down;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val, 0.05f, down, ref val2, num, 1503731969))
		{
			float y = ((RaycastHit)(ref val2)).point.y;
			float y2 = mountAnchor.parent.TransformPoint(originalLocalMountPos).y;
			if (Mathf.Abs(y - y2) < 0.5f)
			{
				mountAnchor.position = ((RaycastHit)(ref val2)).point;
			}
		}
	}

	private bool CanRotate()
	{
		if (HasOwner())
		{
			return !ballistaOwner.IsStationary();
		}
		return AnyMounted();
	}

	private bool CanSeeFirePoint(BasePlayer player, float radius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = player.eyes.center;
		Vector3 position = player.eyes.position;
		Vector3 position2 = muzzle.position;
		int layerMask = 2162688;
		if (GamePhysics.LineOfSightRadius(center, position, layerMask, radius, this))
		{
			return GamePhysics.LineOfSightRadius(position, position2, layerMask, radius, this);
		}
		return false;
	}

	private bool CheckBallistaBounds(AimDirection direction)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		List<Bounds> list = Pool.Get<List<Bounds>>();
		bool num = direction == AimDirection.Up || direction == AimDirection.Down;
		Vector3 val = pitchTransform.position;
		if (num)
		{
			Vector3 val2 = ((direction == AimDirection.Up) ? pitchTransform.up : (-pitchTransform.up));
			val += ((Vector3)(ref val2)).normalized * 0.05f;
			list.Add(areaChecks[areaChecks.Length - 1]);
		}
		else
		{
			int num2 = ((direction != 0) ? 1 : 0);
			list.Add(areaChecks[num2]);
			list.Add(areaChecks[areaChecks.Length - 1]);
		}
		bool result = true;
		foreach (Bounds item in list)
		{
			if (SocketMod_AreaCheck.IsInArea(val, pitchTransform.rotation, item, LayerMask.op_Implicit(1503731969), this))
			{
				result = false;
				break;
			}
		}
		Pool.FreeUnmanaged<Bounds>(ref list);
		return result;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)ServerTick, Random.Range(0f, 1f), 0.015f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)SendAimDir, Random.Range(0f, 1f), 0.2f, 0.05f);
	}

	private void ServerTick()
	{
		if (base.isServer)
		{
			float dt = (float)(double)timeSinceLastServerTick;
			timeSinceLastServerTick = 0.0;
			if (CanRotate())
			{
				RotateBallista(dt);
			}
			if (!HasOwner() && AnyMounted() && IsSeatClipping(this))
			{
				DismountAllPlayers();
			}
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		base.PlayerServerInput(inputState, player);
		UpdateManualAim(inputState);
	}

	public override void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		base.OnParentChanging(oldParent, newParent);
		if ((Object)(object)newParent != (Object)null && aimDir == Vector3.zero)
		{
			aimDir = ((Component)newParent).transform.forward;
		}
	}

	public override void OnPlayerMounted()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerMounted();
		TogglePlayerServerCollider(active: true);
		aimDir = pitchTransform.forward;
		SendAimDirImmediate();
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		TogglePlayerServerCollider(active: false);
		if (HasFlag(Flags.Reserved4))
		{
			StopReload();
		}
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (HasGround(rightGroundCheckTransform) && HasGround(leftGroundCheckTransform))
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	private void LoadAmmo(BasePlayer player)
	{
		if (!((Object)(object)player != (Object)(object)GetMounted()) && !IsLoaded())
		{
			Item ammoFromPlayerInventory = GetAmmoFromPlayerInventory(player);
			if (ammoFromPlayerInventory != null)
			{
				SetFlag(Flags.Reserved5, b: true);
				magazine.ammoType = ammoFromPlayerInventory.info;
				magazine.contents = 1;
				ammoFromPlayerInventory.UseItem();
			}
		}
	}

	public void SendAimDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (lastSentAimDir == Vector3.zero || Vector3.Angle(lastSentAimDir, aimDir) > 0.03f)
		{
			SendAimDirImmediate();
		}
	}

	public void SendAimDirImmediate(bool force = false)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		lastSentAimDir = aimDir;
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_ReceiveAimDir"), aimDir, force);
	}

	private void ReloadProgress()
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)reloadingPlayer == (Object)null || (Object)(object)reloadingPlayer != (Object)(object)GetMounted() || reloadingPlayer.IsDead() || reloadingPlayer.IsSleeping() || Vector3Ex.Distance2D(((Component)reloadingPlayer).transform.position, ((Component)this).transform.position) > 3f)
		{
			StopReload();
			return;
		}
		reloadProgress += progressTickRate / reloadTime;
		if (reloadProgress >= 1f)
		{
			reloadProgress = 1f;
			LoadAmmo(reloadingPlayer);
			((FacepunchBehaviour)this).Invoke((Action)delegate
			{
				SendAimDirImmediate(force: true);
			}, 0.5f);
			StopReload();
		}
		else
		{
			SendNetworkUpdateImmediate();
		}
	}

	public void StopReload()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)ReloadProgress);
		reloadingPlayer = null;
		SetFlag(Flags.Reserved4, b: false);
	}

	public void TogglePlayerServerCollider(bool active)
	{
		((Collider)playerServerCollider).enabled = active;
	}

	[RPC_Server.CallsPerSecond(5uL)]
	[RPC_Server]
	private void SERVER_SwitchAmmoTo(RPCMessage msg)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null || (Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)mounted)
		{
			return;
		}
		int num = msg.read.Int32();
		if (num == magazine.ammoType.itemid)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(num);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return;
		}
		ItemModProjectile component = ((Component)itemDefinition).GetComponent<ItemModProjectile>();
		if (Object.op_Implicit((Object)(object)component) && component.IsAmmo(magazine.definition.ammoTypes))
		{
			if (magazine.contents > 0)
			{
				mounted.GiveItem(ItemManager.CreateByItemID(magazine.ammoType.itemid, magazine.contents, 0uL));
				magazine.contents = 0;
				SetFlag(Flags.Reserved5, b: false);
			}
			magazine.ammoType = itemDefinition;
			SendNetworkUpdateImmediate();
			ItemManager.DoRemoves();
			mounted.inventory.ServerUpdate(0f);
		}
	}

	[RPC_Server.CallsPerSecond(1uL)]
	[RPC_Server.FromOwner(true)]
	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void SERVER_FireClientProjectile(RPCMessage msg)
	{
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		if (!VerifyClientRPC(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if (!IsLoaded() || magazine.contents != 1 || (Object)(object)player != (Object)(object)GetMounted() || !CanFire() || player.InSafeZone() || Interface.CallHook("OnSiegeWeaponFire", (object)ballistaOwner, (object)player) != null)
			{
				return;
			}
			ItemDefinition ammoType = magazine.ammoType;
			if ((Object)(object)ammoType == (Object)null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, null, "item_missing");
				return;
			}
			ItemModProjectile component = ((Component)ammoType).GetComponent<ItemModProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				ProjectileShoot val = msg.read.Proto<ProjectileShoot>((ProjectileShoot)null);
				try
				{
					if (val.projectiles.Count != 1)
					{
						AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
						player.stats.combat.LogInvalid(player, null, "count_mismatch");
						return;
					}
					player.CleanupExpiredProjectiles();
					Guid projectileGroupId = Guid.NewGuid();
					foreach (Projectile projectile in val.projectiles)
					{
						if (player.HasFiredProjectile(projectile.projectileID))
						{
							AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
							player.stats.combat.LogInvalid(player, null, "duplicate_id");
						}
						else if (ValidateFirePos(player, projectile.startPos))
						{
							player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, null, ammoType, projectileGroupId, Vector3.zero);
							Effect effect = new Effect();
							effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
							((EffectData)effect).scale = 1f;
							effect.pooledString = component.projectileObject.resourcePath;
							((EffectData)effect).number = projectile.seed;
							EffectNetwork.Send(effect);
						}
					}
					SendAimDirImmediate(force: true);
					player.MarkHostileFor();
					SignalBroadcast(Signal.Attack, string.Empty, msg.connection);
					magazine.contents = 0;
					reloadProgress = 0f;
					SetFlag(Flags.Reserved5, b: false);
					if (HasOwner())
					{
						ballistaOwner.RefreshLastUseTime();
						ballistaOwner.OnFired();
					}
					SingletonComponent<NpcNoiseManager>.Instance.OnWeaponShot(player, null);
					return;
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "mod_missing");
		}
	}

	protected bool VerifyClientRPC(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			Debug.LogWarning((object)"Received RPC from null player");
			return false;
		}
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Owner not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "owner_missing");
			return false;
		}
		if ((Object)(object)mounted != (Object)(object)player)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player mismatch (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_mismatch");
			return false;
		}
		if (player.IsDead())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player dead (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_dead");
			return false;
		}
		if (player.IsWounded())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player down (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_down");
			return false;
		}
		if (player.IsSleeping())
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player sleeping (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "player_sleeping");
			return false;
		}
		if (player.desyncTimeRaw > ConVar.AntiHack.maxdesync)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Player stalled (" + base.ShortPrefabName + " with " + player.desyncTimeRaw + "s)");
			player.stats.combat.LogInvalid(player, null, "player_stalled");
			return false;
		}
		if ((Object)(object)magazine.ammoType == (Object)null)
		{
			AntiHack.Log(player, AntiHackType.AttackHack, "Item not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "item_missing");
			return false;
		}
		return true;
	}

	protected bool ValidateFirePos(BasePlayer player, Vector3 firePos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		bool flag = true;
		if (Vector3Ex.IsNaNOrInfinity(firePos))
		{
			string shortPrefabName = base.ShortPrefabName;
			AntiHack.Log(player, AntiHackType.EyeHack, "Contains NaN (" + shortPrefabName + ")");
			player.stats.combat.LogInvalid(player, null, "eye_nan");
			flag = false;
		}
		if (ConVar.AntiHack.eye_protection > 0)
		{
			Vector3 val;
			if (ConVar.AntiHack.eye_protection >= 1)
			{
				val = player.GetParentVelocity();
				float magnitude = ((Vector3)(ref val)).magnitude;
				val = player.GetMountVelocity();
				float num = magnitude + ((Vector3)(ref val)).magnitude + ConVar.AntiHack.eye_forgiveness;
				float num2 = Vector3.Distance(((Component)muzzle).transform.position, firePos);
				if (num2 > num)
				{
					string shortPrefabName2 = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.EyeHack, "Distance (" + shortPrefabName2 + " on attack with " + num2 + "m > " + num + "m)");
					player.stats.combat.LogInvalid(player, null, "eye_distance");
					flag = false;
				}
			}
			int num3 = 2162688;
			if (ConVar.AntiHack.eye_terraincheck)
			{
				num3 |= 0x800000;
			}
			if (ConVar.AntiHack.eye_vehiclecheck)
			{
				num3 |= 0x8000000;
			}
			if (ConVar.AntiHack.eye_protection >= 2 && !CanSeeFirePoint(player, 0.05f))
			{
				string shortPrefabName3 = base.ShortPrefabName;
				string[] obj = new string[8] { "Line of sight (", shortPrefabName3, " on attack) ", null, null, null, null, null };
				val = player.eyes.center;
				obj[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
				obj[4] = " ";
				val = player.eyes.position;
				obj[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
				obj[6] = " ";
				val = firePos;
				obj[7] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
				AntiHack.Log(player, AntiHackType.EyeHack, string.Concat(obj));
				player.stats.combat.LogInvalid(player, null, "eye_los");
				flag = false;
			}
		}
		if (!flag)
		{
			AntiHack.AddViolation(player, AntiHackType.EyeHack, ConVar.AntiHack.eye_penalty);
		}
		return flag;
	}

	protected override bool BroadcastSignalFromClientFilter(Signal signal)
	{
		return signal == Signal.Attack;
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.FromOwner(true)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(3uL)]
	private void SERVER_ReloadStart(RPCMessage msg)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		BasePlayer mounted = GetMounted();
		if (!((Object)(object)mounted == (Object)null) && !((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)mounted))
		{
			reloadingPlayer = player;
			SetFlag(Flags.Reserved4, b: true);
			ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartReloading"), reloadingPlayer.net.ID);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ReloadProgress, 0f, progressTickRate);
			if (HasOwner())
			{
				ballistaOwner.RefreshLastUseTime();
			}
		}
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server.CallsPerSecond(3uL)]
	[RPC_Server.FromOwner(true)]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void SERVER_CancelReload(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && !((Object)(object)player != (Object)(object)reloadingPlayer))
		{
			StopReload();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (CanRotate())
		{
			RotateBallista(1000f);
		}
	}

	public override void DoRepair(BasePlayer player)
	{
		if (HasParent() && HasOwner())
		{
			ballistaOwner.DoRepair(player);
		}
		else
		{
			base.DoRepair(player);
		}
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && HasOwner())
		{
			ballistaOwner.Hurt(info);
		}
		else
		{
			base.Hurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (HasParent() && HasOwner() && !ballistaOwner.IsDead())
		{
			ballistaOwner.Die();
		}
	}

	public void AdminReload(int ammo)
	{
		reloadProgress = 1f;
		StopReload();
		ItemDefinition ammoType = null;
		switch (ammo)
		{
		case 1:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.hammerhead");
			break;
		case 2:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.incendiary");
			break;
		case 3:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.piercer");
			break;
		case 4:
			ammoType = ItemManager.FindItemDefinition("ballista.bolt.pitchfork");
			break;
		}
		SetFlag(Flags.Reserved5, b: true);
		magazine.ammoType = ammoType;
		magazine.contents = 1;
		SendNetworkUpdateImmediate();
	}

	[ServerVar]
	public static void reload(Arg arg)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
		}
		else
		{
			if (!basePlayer.IsAdmin)
			{
				return;
			}
			int @int = arg.GetInt(0, 1);
			@int = Mathf.Clamp(@int, 1, 4);
			BallistaGun[] array = Util.FindAll<BallistaGun>();
			int num = 0;
			BallistaGun[] array2 = array;
			foreach (BallistaGun ballistaGun in array2)
			{
				if (ballistaGun.isServer && Vector3.Distance(((Component)ballistaGun).transform.position, ((Component)basePlayer).transform.position) <= 10f)
				{
					ballistaGun.AdminReload(@int);
					num++;
				}
			}
			arg.ReplyWith($"Reloaded {num} ballistas.");
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (!isMountedOnVehicle || HasOwner())
		{
			info.msg.ballistaGun = Pool.Get<BallistaGun>();
			info.msg.ballistaGun.magazine = magazine.Save();
			info.msg.ballistaGun.reloadProgress = reloadProgress;
			info.msg.ballistaGun.aimDir = aimDir;
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		if (info.msg.ballistaGun != null)
		{
			if (info.msg.ballistaGun.magazine != null)
			{
				magazine.Load(info.msg.ballistaGun.magazine);
			}
			if (base.isServer)
			{
				reloadProgress = info.msg.ballistaGun.reloadProgress;
				aimDir = info.msg.ballistaGun.aimDir;
			}
		}
		base.Load(info);
	}
}


using System;
using UnityEngine;

[Serializable]
private struct Ammo
{
	public ItemDefinition item;

	public GameObject go;
}


using System;

[Serializable]
private struct FiringEffect
{
	public ItemDefinition item;

	public GameObjectRef effectPrefab;
}


private enum AimDirection
{
	Left,
	Right,
	Up,
	Down
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseAIBrain : EntityComponent<BaseEntity>, IAISleepable, IAIDesign, IAIGroupable, IAIEventListener, IPet
{
	public class BasicAIState
	{
		[NonSerialized]
		public BaseAIBrain brain;

		protected float _lastStateExitTime;

		public AIState StateType { get; private set; }

		public float TimeInState { get; private set; }

		public bool AgrresiveState { get; protected set; }

		public virtual void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			TimeInState = 0f;
		}

		public virtual StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			TimeInState += delta;
			return StateStatus.Running;
		}

		public virtual void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			TimeInState = 0f;
			_lastStateExitTime = Time.time;
		}

		public virtual bool CanInterrupt()
		{
			return true;
		}

		public virtual bool CanEnter()
		{
			return true;
		}

		public virtual bool CanLeave()
		{
			return CanInterrupt();
		}

		public virtual float GetWeight()
		{
			return 0f;
		}

		public float TimeSinceState()
		{
			return Time.time - _lastStateExitTime;
		}

		public BasicAIState(AIState state)
		{
			StateType = state;
		}

		public void Reset()
		{
			TimeInState = 0f;
		}

		public bool IsInState()
		{
			if ((Object)(object)brain != (Object)null && brain.CurrentState != null)
			{
				return brain.CurrentState == this;
			}
			return false;
		}

		public virtual void DrawGizmos()
		{
		}
	}

	public class BaseAttackState : BasicAIState
	{
		private IAIAttack attack;

		public BaseAttackState()
			: base(AIState.Attack)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			attack = entity as IAIAttack;
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
				brain.Navigator.SetFacingDirectionOverride(aimDirection);
				if (attack.CanAttack(baseEntity))
				{
					StartAttacking(baseEntity);
				}
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.Stop();
			StopAttacking();
		}

		private void StopAttacking()
		{
			attack.StopAttacking();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if (attack == null)
			{
				return StateStatus.Error;
			}
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				StopAttacking();
				return StateStatus.Finished;
			}
			if (brain.Senses.ignoreSafeZonePlayers)
			{
				BasePlayer basePlayer = baseEntity as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
				{
					return StateStatus.Error;
				}
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
			{
				return StateStatus.Error;
			}
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			else
			{
				StopAttacking();
			}
			return StateStatus.Running;
		}

		private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Direction2D(target, from);
		}

		private void StartAttacking(BaseEntity entity)
		{
			attack.StartAttacking(entity);
		}
	}

	public class BaseBlindedState : BasicAIState
	{
		public BaseBlindedState()
			: base(AIState.Blinded)
		{
		}
	}

	public class BaseChaseState : BasicAIState
	{
		public BaseChaseState()
			: base(AIState.Chase)
		{
			base.AgrresiveState = true;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class BaseCooldownState : BasicAIState
	{
		public BaseCooldownState()
			: base(AIState.Cooldown)
		{
		}
	}

	public class BaseDismountedState : BasicAIState
	{
		public BaseDismountedState()
			: base(AIState.Dismounted)
		{
		}
	}

	public class BaseFleeState : BasicAIState
	{
		private float nextInterval = 2f;

		private float stopFleeDistance;

		public BaseFleeState()
			: base(AIState.Flee)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity != (Object)null)
			{
				stopFleeDistance = Random.Range(80f, 100f) + Mathf.Clamp(Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position), 0f, 50f);
			}
			FleeFrom(brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot), entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				return StateStatus.Finished;
			}
			if (Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position) >= stopFleeDistance)
			{
				return StateStatus.Finished;
			}
			if ((brain.Navigator.UpdateIntervalElapsed(nextInterval) || !brain.Navigator.Moving) && !FleeFrom(baseEntity, entity))
			{
				return StateStatus.Error;
			}
			return StateStatus.Running;
		}

		private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
		{
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)thisEntity == (Object)null || (Object)(object)fleeFromEntity == (Object)null)
			{
				return false;
			}
			nextInterval = Random.Range(3f, 6f);
			if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out var result))
			{
				return false;
			}
			bool num = brain.Navigator.SetDestination(result, BaseNavigator.NavigationSpeed.Fast);
			if (!num)
			{
				Stop();
			}
			return num;
		}
	}

	public class BaseFollowPathState : BasicAIState
	{
		private AIMovePointPath path;

		private StateStatus status;

		private AIMovePoint currentTargetPoint;

		private float currentWaitTime;

		private AIMovePointPath.PathDirection pathDirection;

		private int currentNodeIndex;

		public BaseFollowPathState()
			: base(AIState.FollowPath)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			brain.Navigator.SetBrakingEnabled(flag: false);
			path = brain.Navigator.Path;
			if ((Object)(object)path == (Object)null)
			{
				AIInformationZone forPoint = AIInformationZone.GetForPoint(entity.ServerPosition);
				if ((Object)(object)forPoint == (Object)null)
				{
					return;
				}
				path = forPoint.GetNearestPath(entity.ServerPosition);
				if ((Object)(object)path == (Object)null)
				{
					return;
				}
			}
			currentNodeIndex = path.FindNearestPointIndex(entity.ServerPosition);
			currentTargetPoint = path.FindNearestPoint(entity.ServerPosition);
			if (!((Object)(object)currentTargetPoint == (Object)null))
			{
				status = StateStatus.Running;
				currentWaitTime = 0f;
				brain.Navigator.SetDestination(((Component)currentTargetPoint).transform.position, BaseNavigator.NavigationSpeed.Slow);
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			brain.Navigator.ClearFacingDirectionOverride();
			brain.Navigator.SetBrakingEnabled(flag: true);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0070: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (!brain.Navigator.Moving)
			{
				if (currentWaitTime <= 0f && currentTargetPoint.HasLookAtPoints())
				{
					Transform randomLookAtPoint = currentTargetPoint.GetRandomLookAtPoint();
					if ((Object)(object)randomLookAtPoint != (Object)null)
					{
						brain.Navigator.SetFacingDirectionOverride(Vector3Ex.Direction2D(((Component)randomLookAtPoint).transform.position, entity.ServerPosition));
					}
				}
				if (currentTargetPoint.WaitTime > 0f)
				{
					currentWaitTime += delta;
				}
				if (currentTargetPoint.WaitTime <= 0f || currentWaitTime >= currentTargetPoint.WaitTime)
				{
					brain.Navigator.ClearFacingDirectionOverride();
					currentWaitTime = 0f;
					int num = currentNodeIndex;
					currentNodeIndex = path.GetNextPointIndex(currentNodeIndex, ref pathDirection);
					currentTargetPoint = path.GetPointAtIndex(currentNodeIndex);
					if ((!((Object)(object)currentTargetPoint != (Object)null) || currentNodeIndex != num) && ((Object)(object)currentTargetPoint == (Object)null || !brain.Navigator.SetDestination(((Component)currentTargetPoint).transform.position, BaseNavigator.NavigationSpeed.Slow)))
					{
						return StateStatus.Error;
					}
				}
			}
			else if ((Object)(object)currentTargetPoint != (Object)null)
			{
				brain.Navigator.SetDestination(((Component)currentTargetPoint).transform.position, BaseNavigator.NavigationSpeed.Slow, 1f);
			}
			return StateStatus.Running;
		}
	}

	public class BaseIdleState : BasicAIState
	{
		public BaseIdleState()
			: base(AIState.Idle)
		{
		}
	}

	public class BaseMountedState : BasicAIState
	{
		public BaseMountedState()
			: base(AIState.Mounted)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			brain.Navigator.Stop();
		}
	}

	public class BaseMoveTorwardsState : BasicAIState
	{
		public BaseMoveTorwardsState()
			: base(AIState.MoveTowards)
		{
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Stop();
				return StateStatus.Error;
			}
			FaceTarget();
			if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, brain.Navigator.MoveTowardsSpeed, 0.25f))
			{
				return StateStatus.Error;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}

		private void FaceTarget()
		{
			//IL_005e: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			if (brain.Navigator.FaceMoveTowardsTarget)
			{
				BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
				if ((Object)(object)baseEntity == (Object)null)
				{
					brain.Navigator.ClearFacingDirectionOverride();
				}
				else if (Vector3.Distance(((Component)baseEntity).transform.position, ((Component)brain).transform.position) <= 1.5f)
				{
					brain.Navigator.SetFacingDirectionEntity(baseEntity);
				}
			}
		}
	}

	public class BaseNavigateHomeState : BasicAIState
	{
		private StateStatus status;

		public BaseNavigateHomeState()
			: base(AIState.NavigateHome)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			Vector3 pos = brain.Events.Memory.Position.Get(4);
			status = StateStatus.Running;
			if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal))
			{
				status = StateStatus.Error;
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			Stop();
		}

		private void Stop()
		{
			brain.Navigator.Stop();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			if (status == StateStatus.Error)
			{
				return status;
			}
			if (!brain.Navigator.Moving)
			{
				return StateStatus.Finished;
			}
			return StateStatus.Running;
		}
	}

	public class BasePatrolState : BasicAIState
	{
		public BasePatrolState()
			: base(AIState.Patrol)
		{
		}
	}

	public class BaseRoamState : BasicAIState
	{
		private float nextRoamPositionTime = -1f;

		private float lastDestinationTime;

		public BaseRoamState()
			: base(AIState.Roam)
		{
		}

		public override float GetWeight()
		{
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			nextRoamPositionTime = -1f;
			lastDestinationTime = Time.time;
		}

		public virtual Vector3 GetDestination()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.zero;
		}

		public virtual Vector3 GetForwardDirection()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.forward;
		}

		public virtual void SetDestination(Vector3 destination)
		{
		}

		public override void DrawGizmos()
		{
			base.DrawGizmos();
			brain.PathFinder.DebugDraw();
		}

		public virtual Vector3 GetRoamAnchorPosition()
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
			{
				return brain.Events.Memory.Position.Get(4);
			}
			return ((Component)brain.GetBaseEntity()).transform.position;
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_009a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0105: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0146: Unknown result type (might be due to invalid IL or missing references)
			//IL_0128: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0139: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			bool flag = Time.time - lastDestinationTime > 25f;
			if ((Vector3.Distance(GetDestination(), ((Component)entity).transform.position) < 2f || flag) && nextRoamPositionTime == -1f)
			{
				nextRoamPositionTime = Time.time + Random.Range(5f, 10f);
			}
			if (nextRoamPositionTime != -1f && Time.time > nextRoamPositionTime)
			{
				AIMovePoint bestRoamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), entity.ServerPosition, GetForwardDirection(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
				if (Object.op_Implicit((Object)(object)bestRoamPoint))
				{
					float num = Vector3.Distance(((Component)bestRoamPoint).transform.position, ((Component)entity).transform.position) / 1.5f;
					bestRoamPoint.SetUsedBy(entity, num + 11f);
				}
				lastDestinationTime = Time.time;
				Vector3 insideUnitSphere = Random.insideUnitSphere;
				insideUnitSphere.y = 0f;
				((Vector3)(ref insideUnitSphere)).Normalize();
				Vector3 destination = (((Object)(object)bestRoamPoint == (Object)null) ? ((Component)entity).transform.position : (((Component)bestRoamPoint).transform.position + insideUnitSphere * bestRoamPoint.radius));
				SetDestination(destination);
				nextRoamPositionTime = -1f;
			}
			return StateStatus.Running;
		}
	}

	public class BaseSleepState : BasicAIState
	{
		private StateStatus status = StateStatus.Error;

		public BaseSleepState()
			: base(AIState.Sleep)
		{
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateEnter(brain, entity);
			status = StateStatus.Error;
			if (entity is IAISleep iAISleep)
			{
				iAISleep.StartSleeping();
				status = StateStatus.Running;
			}
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			base.StateLeave(brain, entity);
			if (entity is IAISleep iAISleep)
			{
				iAISleep.StopSleeping();
			}
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			base.StateThink(delta, brain, entity);
			return status;
		}
	}

	public bool SendClientCurrentState;

	public bool UseQueuedMovementUpdates;

	public bool AllowedToSleep = true;

	public AIDesignSO DefaultDesignSO;

	public List<AIDesignSO> Designs = new List<AIDesignSO>();

	public AIDesign InstanceSpecificDesign;

	public float SenseRange = 10f;

	public float AttackRangeMultiplier = 1f;

	public float TargetLostRange = 40f;

	public float VisionCone = -0.8f;

	public bool CheckVisionCone;

	public bool CheckLOS;

	public bool IgnoreNonVisionSneakers = true;

	public float IgnoreSneakersMaxDistance = 4f;

	public float IgnoreNonVisionMaxDistance = 15f;

	public float ListenRange;

	public EntityType SenseTypes;

	public bool HostileTargetsOnly;

	public bool IgnoreSafeZonePlayers;

	public int MaxGroupSize;

	public float MemoryDuration = 10f;

	public bool RefreshKnownLOS;

	public bool CanBeBlinded = true;

	public float BlindDurationMultiplier = 1f;

	public float MovementTickStartDelay = 1f;

	public AIState ClientCurrentState;

	public Vector3 mainInterestPoint;

	public bool UseAIDesign;

	public bool Pet;

	public List<IAIGroupable> groupMembers = new List<IAIGroupable>();

	[Header("Healing")]
	public bool CanUseHealingItems;

	public float HealChance = 0.5f;

	public float HealBelowHealthFraction = 0.5f;

	protected int loadedDesignIndex;

	public int currentStateContainerID = -1;

	private float lastMovementTickTime;

	public bool sleeping;

	private bool disabled;

	public Dictionary<AIState, BasicAIState> states;

	protected float thinkRate = 0.25f;

	protected float lastThinkTime;

	protected float unblindTime;

	public BasicAIState CurrentState { get; set; }

	public AIThinkMode ThinkMode { get; set; } = AIThinkMode.Interval;

	public float Age { get; set; }

	public AIBrainSenses Senses { get; set; } = new AIBrainSenses();

	public BasePathFinder PathFinder { get; set; }

	public AIEvents Events { get; set; }

	public AIDesign AIDesign { get; set; }

	public BasePlayer DesigningPlayer { get; set; }

	public BasePlayer OwningPlayer { get; set; }

	public bool IsGroupLeader { get; set; }

	public bool IsGrouped { get; set; }

	public IAIGroupable GroupLeader { get; set; }

	public BaseNavigator Navigator { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseAIBrain.OnRpcMessage", 0);
		try
		{
			if (rpc == 66191493 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestAIDesign "));
				}
				TimeWarning val2 = TimeWarning.New("RequestAIDesign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						BaseEntity.RPCMessage msg2 = rPCMessage;
						RequestAIDesign(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RequestAIDesign");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2122228512 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - StopAIDesign "));
				}
				TimeWarning val2 = TimeWarning.New("StopAIDesign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						BaseEntity.RPCMessage msg3 = rPCMessage;
						StopAIDesign(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in StopAIDesign");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 657290375 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SubmitAIDesign "));
				}
				TimeWarning val2 = TimeWarning.New("SubmitAIDesign", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						BaseEntity.RPCMessage rPCMessage = default(BaseEntity.RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						BaseEntity.RPCMessage msg4 = rPCMessage;
						SubmitAIDesign(msg4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in SubmitAIDesign");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void ForceSetAge(float age)
	{
		Age = age;
	}

	public int LoadedDesignIndex()
	{
		return loadedDesignIndex;
	}

	public void SetEnabled(bool flag)
	{
		disabled = !flag;
	}

	bool IAIDesign.CanPlayerDesignAI(BasePlayer player)
	{
		return PlayerCanDesignAI(player);
	}

	private bool PlayerCanDesignAI(BasePlayer player)
	{
		if (!AI.allowdesigning)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (!UseAIDesign)
		{
			return false;
		}
		if ((Object)(object)DesigningPlayer != (Object)null)
		{
			return false;
		}
		if (!player.IsDeveloper)
		{
			return false;
		}
		return true;
	}

	[BaseEntity.RPC_Server]
	private void RequestAIDesign(BaseEntity.RPCMessage msg)
	{
		if (UseAIDesign && !((Object)(object)msg.player == (Object)null) && AIDesign != null && PlayerCanDesignAI(msg.player))
		{
			msg.player.designingAIEntity = GetBaseEntity();
			msg.player.ClientRPC(RpcTarget.Player("StartDesigningAI", msg.player), AIDesign.ToProto(currentStateContainerID));
			DesigningPlayer = msg.player;
			SetOwningPlayer(msg.player);
		}
	}

	[BaseEntity.RPC_Server]
	private void SubmitAIDesign(BaseEntity.RPCMessage msg)
	{
		AIDesign val = msg.read.Proto<AIDesign>((AIDesign)null);
		if (!LoadAIDesign(val, msg.player, loadedDesignIndex))
		{
			return;
		}
		SaveDesign();
		if (val.scope == 2)
		{
			return;
		}
		BaseEntity baseEntity = GetBaseEntity();
		BaseEntity[] array = BaseEntity.Util.FindTargets(baseEntity.ShortPrefabName, onlyPlayers: false);
		if (array == null || array.Length == 0)
		{
			return;
		}
		BaseEntity[] array2 = array;
		foreach (BaseEntity baseEntity2 in array2)
		{
			if ((Object)(object)baseEntity2 == (Object)null || (Object)(object)baseEntity2 == (Object)(object)baseEntity)
			{
				continue;
			}
			List<EntityComponentBase> components = baseEntity2.Components;
			if (components == null)
			{
				continue;
			}
			foreach (EntityComponentBase item in components)
			{
				if (item is IAIDesign iAIDesign)
				{
					iAIDesign.LoadAIDesign(val, null);
					break;
				}
			}
		}
	}

	void IAIDesign.StopDesigning()
	{
		ClearDesigningPlayer();
	}

	void IAIDesign.LoadAIDesign(AIDesign design, BasePlayer player)
	{
		LoadAIDesign(design, player, loadedDesignIndex);
	}

	public bool LoadDefaultAIDesign()
	{
		if (loadedDesignIndex == 0)
		{
			return true;
		}
		return LoadAIDesignAtIndex(0);
	}

	public bool LoadAIDesignAtIndex(int index)
	{
		if (Designs == null)
		{
			return false;
		}
		if (index < 0 || index >= Designs.Count)
		{
			return false;
		}
		return LoadAIDesign(AIDesigns.GetByNameOrInstance(Designs[index].Filename, InstanceSpecificDesign), null, index);
	}

	public virtual void OnAIDesignLoadedAtIndex(int index)
	{
	}

	protected bool LoadAIDesign(AIDesign design, BasePlayer player, int index)
	{
		if (design == null)
		{
			Debug.LogError((object)(((Object)((Component)GetBaseEntity()).gameObject).name + " failed to load AI design!"));
			return false;
		}
		if ((Object)(object)player != (Object)null)
		{
			AIDesignScope scope = (AIDesignScope)design.scope;
			if (scope == AIDesignScope.Default && !player.IsDeveloper)
			{
				return false;
			}
			if (scope == AIDesignScope.EntityServerWide && !player.IsDeveloper && !player.IsAdmin)
			{
				return false;
			}
		}
		if (AIDesign == null)
		{
			return false;
		}
		AIDesign.Load(design, base.baseEntity);
		AIStateContainer defaultStateContainer = AIDesign.GetDefaultStateContainer();
		if (defaultStateContainer != null)
		{
			SwitchToState(defaultStateContainer.State, defaultStateContainer.ID);
		}
		loadedDesignIndex = index;
		OnAIDesignLoadedAtIndex(loadedDesignIndex);
		return true;
	}

	public void SaveDesign()
	{
		if (AIDesign == null)
		{
			return;
		}
		AIDesign val = AIDesign.ToProto(currentStateContainerID);
		string text = "cfg/ai/";
		string filename = Designs[loadedDesignIndex].Filename;
		switch (AIDesign.Scope)
		{
		case AIDesignScope.Default:
			text += filename;
			try
			{
				using (FileStream fileStream2 = File.Create(text))
				{
					ProtoStreamExtensions.WriteToStream((IProto)(object)val, (Stream)fileStream2, false, 2097152);
				}
				AIDesigns.RefreshCache(filename, val);
				break;
			}
			catch (Exception)
			{
				Debug.LogWarning((object)("Error trying to save default AI Design: " + text));
				break;
			}
		case AIDesignScope.EntityServerWide:
			filename += "_custom";
			text += filename;
			try
			{
				using (FileStream fileStream = File.Create(text))
				{
					ProtoStreamExtensions.WriteToStream((IProto)(object)val, (Stream)fileStream, false, 2097152);
				}
				AIDesigns.RefreshCache(filename, val);
				break;
			}
			catch (Exception)
			{
				Debug.LogWarning((object)("Error trying to save server-wide AI Design: " + text));
				break;
			}
		case AIDesignScope.EntityInstance:
			break;
		}
	}

	[BaseEntity.RPC_Server]
	private void StopAIDesign(BaseEntity.RPCMessage msg)
	{
		if ((Object)(object)msg.player == (Object)(object)DesigningPlayer)
		{
			ClearDesigningPlayer();
		}
	}

	private void ClearDesigningPlayer()
	{
		DesigningPlayer = null;
	}

	public void SetOwningPlayer(BasePlayer owner)
	{
		OwningPlayer = owner;
		Events.Memory.Entity.Set(OwningPlayer, 5);
		if (this != null && ((IPet)this).IsPet())
		{
			((IPet)this).SetPetOwner(owner);
			owner.Pet = this;
		}
	}

	public virtual bool ShouldServerThink()
	{
		if (ThinkMode == AIThinkMode.Interval && Time.time > lastThinkTime + thinkRate)
		{
			return true;
		}
		return false;
	}

	public virtual void DoThink()
	{
		float delta = Time.time - lastThinkTime;
		Think(delta);
	}

	public List<AIState> GetStateList()
	{
		return states.Keys.ToList();
	}

	public bool Blinded()
	{
		return Time.time < unblindTime;
	}

	public void SetBlinded(float duration)
	{
		if (!CanBeBlinded || Blinded())
		{
			return;
		}
		unblindTime = Time.time + duration;
		if (HasState(AIState.Blinded) && AIDesign != null)
		{
			BasicAIState basicAIState = states[AIState.Blinded];
			AIStateContainer firstStateContainerOfType = AIDesign.GetFirstStateContainerOfType(AIState.Blinded);
			if (basicAIState != null && firstStateContainerOfType != null)
			{
				SwitchToState(basicAIState, firstStateContainerOfType.ID);
			}
		}
	}

	public void Start()
	{
		AddStates();
		InitializeAI();
	}

	public virtual void AddStates()
	{
		states = new Dictionary<AIState, BasicAIState>();
	}

	public virtual void InitializeAI()
	{
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GetBaseEntity();
		baseEntity.HasBrain = true;
		Navigator = ((Component)this).GetComponent<BaseNavigator>();
		if (UseAIDesign)
		{
			AIDesign = new AIDesign();
			AIDesign.SetAvailableStates(GetStateList());
			if (Events == null)
			{
				Events = new AIEvents();
			}
			bool senseFriendlies = MaxGroupSize > 0;
			Senses.Init(baseEntity, this, MemoryDuration, SenseRange, TargetLostRange, VisionCone, CheckVisionCone, CheckLOS, IgnoreNonVisionSneakers, ListenRange, HostileTargetsOnly, senseFriendlies, IgnoreSafeZonePlayers, SenseTypes, RefreshKnownLOS);
			if (DefaultDesignSO == null && Designs.Count == 0)
			{
				Debug.LogWarning((object)("Brain on " + ((Object)((Component)this).gameObject).name + " is trying to load a null AI design!"));
				return;
			}
			Events.Memory.Position.Set(((Component)this).transform.position, 4);
			if (Designs.Count == 0)
			{
				Designs.Add(DefaultDesignSO);
			}
			loadedDesignIndex = 0;
			LoadAIDesign(AIDesigns.GetByNameOrInstance(Designs[loadedDesignIndex].Filename, InstanceSpecificDesign), null, loadedDesignIndex);
			AIInformationZone forPoint = AIInformationZone.GetForPoint(((Component)this).transform.position, fallBackToNearest: false);
			if ((Object)(object)forPoint != (Object)null)
			{
				forPoint.RegisterSleepableEntity(this);
			}
		}
		BaseEntity.Query.Server.AddBrain(baseEntity);
		StartMovementTick();
	}

	public BaseEntity GetBrainBaseEntity()
	{
		return GetBaseEntity();
	}

	public virtual void OnDestroy()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isQuitting)
		{
			BaseEntity.Query.Server.RemoveBrain(GetBaseEntity());
			AIInformationZone aIInformationZone = null;
			HumanNPC humanNPC = GetBaseEntity() as HumanNPC;
			if ((Object)(object)humanNPC != (Object)null)
			{
				aIInformationZone = humanNPC.VirtualInfoZone;
			}
			if ((Object)(object)aIInformationZone == (Object)null)
			{
				aIInformationZone = AIInformationZone.GetForPoint(((Component)this).transform.position);
			}
			if ((Object)(object)aIInformationZone != (Object)null)
			{
				aIInformationZone.UnregisterSleepableEntity(this);
			}
			LeaveGroup();
			StopMovementTick();
		}
	}

	private void StartMovementTick()
	{
		lastMovementTickTime = Time.realtimeSinceStartup;
		((FacepunchBehaviour)this).CancelInvoke((Action)TickMovement);
		((FacepunchBehaviour)this).InvokeRandomized((Action)TickMovement, MovementTickStartDelay, 0.1f, 0.010000001f);
	}

	private void StopMovementTick()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)TickMovement);
	}

	public void TickMovement()
	{
		if (BasePet.queuedMovementsAllowed && UseQueuedMovementUpdates && (Object)(object)Navigator != (Object)null)
		{
			if (BasePet.onlyQueueBaseNavMovements && Navigator.CurrentNavigationType != BaseNavigator.NavigationType.Base)
			{
				DoMovementTick();
				return;
			}
			BasePet basePet = GetBaseEntity() as BasePet;
			if ((Object)(object)basePet != (Object)null && !basePet.inQueue)
			{
				BasePet._movementProcessQueue.Enqueue(basePet);
				basePet.inQueue = true;
			}
		}
		else
		{
			DoMovementTick();
		}
	}

	public void DoMovementTick()
	{
		float delta = Time.realtimeSinceStartup - lastMovementTickTime;
		lastMovementTickTime = Time.realtimeSinceStartup;
		if ((Object)(object)Navigator != (Object)null)
		{
			Navigator.Think(delta);
		}
	}

	public void AddState(BasicAIState newState)
	{
		if (states.ContainsKey(newState.StateType))
		{
			Debug.LogWarning((object)("Trying to add duplicate state: " + newState.StateType.ToString() + " to " + GetBaseEntity().PrefabName));
			return;
		}
		newState.brain = this;
		newState.Reset();
		states.Add(newState.StateType, newState);
	}

	public bool HasState(AIState state)
	{
		return states.ContainsKey(state);
	}

	public bool SwitchToState(AIState newState, int stateContainerID = -1)
	{
		if (!HasState(newState))
		{
			return false;
		}
		bool num = SwitchToState(states[newState], stateContainerID);
		if (num)
		{
			OnStateChanged();
		}
		return num;
	}

	private bool SwitchToState(BasicAIState newState, int stateContainerID = -1)
	{
		if (newState == null || !newState.CanEnter())
		{
			return false;
		}
		if (CurrentState != null)
		{
			if (!CurrentState.CanLeave())
			{
				return false;
			}
			if (CurrentState == newState && !UseAIDesign)
			{
				return false;
			}
			object obj = Interface.CallHook("OnAIBrainStateSwitch", (object)this, (object)CurrentState, (object)newState);
			if (obj != null)
			{
				if (!(obj is bool))
				{
					return false;
				}
				return (bool)obj;
			}
			CurrentState.StateLeave(this, GetBaseEntity());
		}
		AddEvents(stateContainerID);
		CurrentState = newState;
		CurrentState.StateEnter(this, GetBaseEntity());
		currentStateContainerID = stateContainerID;
		Interface.CallHook("OnAIBrainStateSwitched", (object)this, (object)CurrentState);
		return true;
	}

	protected virtual void OnStateChanged()
	{
		if (SendClientCurrentState)
		{
			BaseEntity baseEntity = GetBaseEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				baseEntity.ClientRPC(RpcTarget.NetworkGroup("ClientChangeState"), (int)((CurrentState != null) ? CurrentState.StateType : AIState.None));
			}
		}
	}

	private void AddEvents(int stateContainerID)
	{
		if (UseAIDesign && AIDesign != null)
		{
			Events.Init(this, AIDesign.GetStateContainerByID(stateContainerID), base.baseEntity, Senses);
		}
	}

	public virtual void Think(float delta)
	{
		if ((Object)(object)this == (Object)null || !AI.think)
		{
			return;
		}
		lastThinkTime = Time.time;
		if (sleeping || disabled)
		{
			return;
		}
		Age += delta;
		if (UseAIDesign)
		{
			Senses.Update();
			UpdateGroup();
		}
		if (CurrentState != null)
		{
			UpdateAgressionTimer(delta);
			StateStatus stateStatus = CurrentState.StateThink(delta, this, GetBaseEntity());
			if (Events != null)
			{
				Events.Tick(delta, stateStatus);
			}
		}
		if (UseAIDesign || (CurrentState != null && !CurrentState.CanLeave()))
		{
			return;
		}
		float num = 0f;
		BasicAIState basicAIState = null;
		foreach (BasicAIState value in states.Values)
		{
			if (value != null && value.CanEnter())
			{
				float weight = value.GetWeight();
				if (weight > num)
				{
					num = weight;
					basicAIState = value;
				}
			}
		}
		if (basicAIState != CurrentState)
		{
			SwitchToState(basicAIState);
		}
	}

	private void UpdateAgressionTimer(float delta)
	{
		if (CurrentState == null)
		{
			Senses.TimeInAgressiveState = 0f;
		}
		else if (CurrentState.AgrresiveState)
		{
			Senses.TimeInAgressiveState += delta;
		}
		else
		{
			Senses.TimeInAgressiveState = 0f;
		}
	}

	bool IAISleepable.AllowedToSleep()
	{
		return AllowedToSleep;
	}

	void IAISleepable.SleepAI()
	{
		if (!sleeping)
		{
			sleeping = true;
			if ((Object)(object)Navigator != (Object)null)
			{
				Navigator.Pause();
			}
			StopMovementTick();
		}
	}

	void IAISleepable.WakeAI()
	{
		if (sleeping)
		{
			sleeping = false;
			if ((Object)(object)Navigator != (Object)null)
			{
				Navigator.Resume();
			}
			StartMovementTick();
		}
	}

	private void UpdateGroup()
	{
		if (!AI.groups || MaxGroupSize <= 0 || InGroup() || Senses.Memory.Friendlies.Count <= 0)
		{
			return;
		}
		IAIGroupable iAIGroupable = null;
		foreach (BaseEntity friendly in Senses.Memory.Friendlies)
		{
			if ((Object)(object)friendly == (Object)null)
			{
				continue;
			}
			IAIGroupable component = ((Component)friendly).GetComponent<IAIGroupable>();
			if (component != null)
			{
				if (component.InGroup() && component.AddMember(this))
				{
					break;
				}
				if (iAIGroupable == null && !component.InGroup())
				{
					iAIGroupable = component;
				}
			}
		}
		if (!InGroup() && iAIGroupable != null)
		{
			AddMember(iAIGroupable);
		}
	}

	public bool AddMember(IAIGroupable member)
	{
		if (InGroup() && !IsGroupLeader)
		{
			return GroupLeader.AddMember(member);
		}
		if (MaxGroupSize <= 0)
		{
			return false;
		}
		if (groupMembers.Contains(member))
		{
			return true;
		}
		if (groupMembers.Count + 1 >= MaxGroupSize)
		{
			return false;
		}
		groupMembers.Add(member);
		IsGrouped = true;
		IsGroupLeader = true;
		GroupLeader = this;
		BaseEntity baseEntity = GetBaseEntity();
		Events.Memory.Entity.Set(baseEntity, 6);
		member.JoinGroup(this, baseEntity);
		return true;
	}

	public void JoinGroup(IAIGroupable leader, BaseEntity leaderEntity)
	{
		Events.Memory.Entity.Set(leaderEntity, 6);
		GroupLeader = leader;
		IsGroupLeader = false;
		IsGrouped = true;
	}

	public void SetGroupRoamRootPosition(Vector3 rootPos)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (IsGroupLeader)
		{
			foreach (IAIGroupable groupMember in groupMembers)
			{
				groupMember.SetGroupRoamRootPosition(rootPos);
			}
		}
		Events.Memory.Position.Set(rootPos, 5);
	}

	public bool InGroup()
	{
		return IsGrouped;
	}

	public void LeaveGroup()
	{
		if (!InGroup())
		{
			return;
		}
		if (IsGroupLeader)
		{
			if (groupMembers.Count == 0)
			{
				return;
			}
			IAIGroupable iAIGroupable = groupMembers[0];
			if (iAIGroupable == null)
			{
				return;
			}
			RemoveMember(iAIGroupable);
			for (int num = groupMembers.Count - 1; num >= 0; num--)
			{
				IAIGroupable iAIGroupable2 = groupMembers[num];
				if (iAIGroupable2 != null && iAIGroupable2 != iAIGroupable)
				{
					RemoveMember(iAIGroupable2);
					iAIGroupable.AddMember(iAIGroupable2);
				}
			}
			groupMembers.Clear();
		}
		else if (GroupLeader != null)
		{
			GroupLeader.RemoveMember(((Component)this).GetComponent<IAIGroupable>());
		}
	}

	public void RemoveMember(IAIGroupable member)
	{
		if (member != null && IsGroupLeader && groupMembers.Contains(member))
		{
			groupMembers.Remove(member);
			member.SetUngrouped();
			if (groupMembers.Count == 0)
			{
				SetUngrouped();
			}
		}
	}

	public void SetUngrouped()
	{
		IsGrouped = false;
		IsGroupLeader = false;
		GroupLeader = null;
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		base.LoadComponent(info);
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		base.SaveComponent(info);
		if (SendClientCurrentState && CurrentState != null)
		{
			info.msg.brainComponent = Pool.Get<BrainComponent>();
			info.msg.brainComponent.currentState = (int)CurrentState.StateType;
		}
	}

	private void SendStateChangeEvent(int previousStateID, int newStateID, int sourceEventID)
	{
		if ((Object)(object)DesigningPlayer != (Object)null)
		{
			DesigningPlayer.ClientRPC(RpcTarget.Player("OnDebugAIEventTriggeredStateChange", DesigningPlayer), previousStateID, newStateID, sourceEventID);
		}
	}

	public void EventTriggeredStateChange(int newStateContainerID, int sourceEventID)
	{
		if (AIDesign != null && newStateContainerID != -1)
		{
			AIStateContainer stateContainerByID = AIDesign.GetStateContainerByID(newStateContainerID);
			int previousStateID = currentStateContainerID;
			SwitchToState(stateContainerByID.State, newStateContainerID);
			SendStateChangeEvent(previousStateID, currentStateContainerID, sourceEventID);
		}
	}

	public bool IsPet()
	{
		return Pet;
	}

	public void SetPetOwner(BasePlayer player)
	{
		BaseEntity baseEntity = (player.PetEntity = GetBaseEntity());
		baseEntity.OwnerID = player.userID;
		BasePet.ActivePetByOwnerID[player.userID] = baseEntity as BasePet;
	}

	public bool IsOwnedBy(BasePlayer player)
	{
		if ((Object)(object)OwningPlayer == (Object)null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (this == null)
		{
			return false;
		}
		return (Object)(object)OwningPlayer == (Object)(object)player;
	}

	public bool IssuePetCommand(PetCommandType cmd, int param, Ray? ray)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (ray.HasValue)
		{
			int num = 10551296;
			RaycastHit val = default(RaycastHit);
			if (Physics.Raycast(ray.Value, ref val, 75f, num))
			{
				Events.Memory.Position.Set(((RaycastHit)(ref val)).point, 6);
			}
			else
			{
				Events.Memory.Position.Set(((Component)this).transform.position, 6);
			}
		}
		switch (cmd)
		{
		case PetCommandType.LoadDesign:
			if (param < 0 || param >= Designs.Count)
			{
				return false;
			}
			LoadAIDesign(AIDesigns.GetByNameOrInstance(Designs[param].Filename, InstanceSpecificDesign), null, param);
			return true;
		case PetCommandType.SetState:
		{
			AIStateContainer stateContainerByID = AIDesign.GetStateContainerByID(param);
			if (stateContainerByID == null)
			{
				return false;
			}
			return SwitchToState(stateContainerByID.State, param);
		}
		case PetCommandType.Destroy:
			GetBaseEntity().Kill();
			return true;
		default:
			return false;
		}
	}
}


using System;
using UnityEngine;

public class BasicAIState
{
	[NonSerialized]
	public BaseAIBrain brain;

	protected float _lastStateExitTime;

	public AIState StateType { get; private set; }

	public float TimeInState { get; private set; }

	public bool AgrresiveState { get; protected set; }

	public virtual void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		TimeInState = 0f;
	}

	public virtual StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		TimeInState += delta;
		return StateStatus.Running;
	}

	public virtual void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		TimeInState = 0f;
		_lastStateExitTime = Time.time;
	}

	public virtual bool CanInterrupt()
	{
		return true;
	}

	public virtual bool CanEnter()
	{
		return true;
	}

	public virtual bool CanLeave()
	{
		return CanInterrupt();
	}

	public virtual float GetWeight()
	{
		return 0f;
	}

	public float TimeSinceState()
	{
		return Time.time - _lastStateExitTime;
	}

	public BasicAIState(AIState state)
	{
		StateType = state;
	}

	public void Reset()
	{
		TimeInState = 0f;
	}

	public bool IsInState()
	{
		if ((Object)(object)brain != (Object)null && brain.CurrentState != null)
		{
			return brain.CurrentState == this;
		}
		return false;
	}

	public virtual void DrawGizmos()
	{
	}
}


using UnityEngine;

public class BaseAttackState : BasicAIState
{
	private IAIAttack attack;

	public BaseAttackState()
		: base(AIState.Attack)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		attack = entity as IAIAttack;
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
			brain.Navigator.SetFacingDirectionOverride(aimDirection);
			if (attack.CanAttack(baseEntity))
			{
				StartAttacking(baseEntity);
			}
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.Stop();
		StopAttacking();
	}

	private void StopAttacking()
	{
		attack.StopAttacking();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if (attack == null)
		{
			return StateStatus.Error;
		}
		if ((Object)(object)baseEntity == (Object)null)
		{
			brain.Navigator.ClearFacingDirectionOverride();
			StopAttacking();
			return StateStatus.Finished;
		}
		if (brain.Senses.ignoreSafeZonePlayers)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null && basePlayer.InSafeZone())
			{
				return StateStatus.Error;
			}
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
		{
			return StateStatus.Error;
		}
		Vector3 aimDirection = GetAimDirection(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position);
		brain.Navigator.SetFacingDirectionOverride(aimDirection);
		if (attack.CanAttack(baseEntity))
		{
			StartAttacking(baseEntity);
		}
		else
		{
			StopAttacking();
		}
		return StateStatus.Running;
	}

	private static Vector3 GetAimDirection(Vector3 from, Vector3 target)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Direction2D(target, from);
	}

	private void StartAttacking(BaseEntity entity)
	{
		attack.StartAttacking(entity);
	}
}


public class BaseBlindedState : BasicAIState
{
	public BaseBlindedState()
		: base(AIState.Blinded)
	{
	}
}


using UnityEngine;

public class BaseChaseState : BasicAIState
{
	public BaseChaseState()
		: base(AIState.Chase)
	{
		base.AgrresiveState = true;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, BaseNavigator.NavigationSpeed.Fast, 0.25f))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


public class BaseCooldownState : BasicAIState
{
	public BaseCooldownState()
		: base(AIState.Cooldown)
	{
	}
}


public class BaseDismountedState : BasicAIState
{
	public BaseDismountedState()
		: base(AIState.Dismounted)
	{
	}
}


using UnityEngine;

public class BaseFleeState : BasicAIState
{
	private float nextInterval = 2f;

	private float stopFleeDistance;

	public BaseFleeState()
		: base(AIState.Flee)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity != (Object)null)
		{
			stopFleeDistance = Random.Range(80f, 100f) + Mathf.Clamp(Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position), 0f, 50f);
		}
		FleeFrom(brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot), entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return StateStatus.Finished;
		}
		if (Vector3Ex.Distance2D(((Component)brain.Navigator).transform.position, ((Component)baseEntity).transform.position) >= stopFleeDistance)
		{
			return StateStatus.Finished;
		}
		if ((brain.Navigator.UpdateIntervalElapsed(nextInterval) || !brain.Navigator.Moving) && !FleeFrom(baseEntity, entity))
		{
			return StateStatus.Error;
		}
		return StateStatus.Running;
	}

	private bool FleeFrom(BaseEntity fleeFromEntity, BaseEntity thisEntity)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)thisEntity == (Object)null || (Object)(object)fleeFromEntity == (Object)null)
		{
			return false;
		}
		nextInterval = Random.Range(3f, 6f);
		if (!brain.PathFinder.GetBestFleePosition(brain.Navigator, brain.Senses, fleeFromEntity, brain.Events.Memory.Position.Get(4), 50f, 100f, out var result))
		{
			return false;
		}
		bool num = brain.Navigator.SetDestination(result, BaseNavigator.NavigationSpeed.Fast);
		if (!num)
		{
			Stop();
		}
		return num;
	}
}


using UnityEngine;

public class BaseFollowPathState : BasicAIState
{
	private AIMovePointPath path;

	private StateStatus status;

	private AIMovePoint currentTargetPoint;

	private float currentWaitTime;

	private AIMovePointPath.PathDirection pathDirection;

	private int currentNodeIndex;

	public BaseFollowPathState()
		: base(AIState.FollowPath)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		brain.Navigator.SetBrakingEnabled(flag: false);
		path = brain.Navigator.Path;
		if ((Object)(object)path == (Object)null)
		{
			AIInformationZone forPoint = AIInformationZone.GetForPoint(entity.ServerPosition);
			if ((Object)(object)forPoint == (Object)null)
			{
				return;
			}
			path = forPoint.GetNearestPath(entity.ServerPosition);
			if ((Object)(object)path == (Object)null)
			{
				return;
			}
		}
		currentNodeIndex = path.FindNearestPointIndex(entity.ServerPosition);
		currentTargetPoint = path.FindNearestPoint(entity.ServerPosition);
		if (!((Object)(object)currentTargetPoint == (Object)null))
		{
			status = StateStatus.Running;
			currentWaitTime = 0f;
			brain.Navigator.SetDestination(((Component)currentTargetPoint).transform.position, BaseNavigator.NavigationSpeed.Slow);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.SetBrakingEnabled(flag: true);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (!brain.Navigator.Moving)
		{
			if (currentWaitTime <= 0f && currentTargetPoint.HasLookAtPoints())
			{
				Transform randomLookAtPoint = currentTargetPoint.GetRandomLookAtPoint();
				if ((Object)(object)randomLookAtPoint != (Object)null)
				{
					brain.Navigator.SetFacingDirectionOverride(Vector3Ex.Direction2D(((Component)randomLookAtPoint).transform.position, entity.ServerPosition));
				}
			}
			if (currentTargetPoint.WaitTime > 0f)
			{
				currentWaitTime += delta;
			}
			if (currentTargetPoint.WaitTime <= 0f || currentWaitTime >= currentTargetPoint.WaitTime)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				currentWaitTime = 0f;
				int num = currentNodeIndex;
				currentNodeIndex = path.GetNextPointIndex(currentNodeIndex, ref pathDirection);
				currentTargetPoint = path.GetPointAtIndex(currentNodeIndex);
				if ((!((Object)(object)currentTargetPoint != (Object)null) || currentNodeIndex != num) && ((Object)(object)currentTargetPoint == (Object)null || !brain.Navigator.SetDestination(((Component)currentTargetPoint).transform.position, BaseNavigator.NavigationSpeed.Slow)))
				{
					return StateStatus.Error;
				}
			}
		}
		else if ((Object)(object)currentTargetPoint != (Object)null)
		{
			brain.Navigator.SetDestination(((Component)currentTargetPoint).transform.position, BaseNavigator.NavigationSpeed.Slow, 1f);
		}
		return StateStatus.Running;
	}
}


public class BaseIdleState : BasicAIState
{
	public BaseIdleState()
		: base(AIState.Idle)
	{
	}
}


public class BaseMountedState : BasicAIState
{
	public BaseMountedState()
		: base(AIState.Mounted)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		brain.Navigator.Stop();
	}
}


using UnityEngine;

public class BaseMoveTorwardsState : BasicAIState
{
	public BaseMoveTorwardsState()
		: base(AIState.MoveTowards)
	{
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
		if ((Object)(object)baseEntity == (Object)null)
		{
			Stop();
			return StateStatus.Error;
		}
		FaceTarget();
		if (!brain.Navigator.SetDestination(((Component)baseEntity).transform.position, brain.Navigator.MoveTowardsSpeed, 0.25f))
		{
			return StateStatus.Error;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}

	private void FaceTarget()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (brain.Navigator.FaceMoveTowardsTarget)
		{
			BaseEntity baseEntity = brain.Events.Memory.Entity.Get(brain.Events.CurrentInputMemorySlot);
			if ((Object)(object)baseEntity == (Object)null)
			{
				brain.Navigator.ClearFacingDirectionOverride();
			}
			else if (Vector3.Distance(((Component)baseEntity).transform.position, ((Component)brain).transform.position) <= 1.5f)
			{
				brain.Navigator.SetFacingDirectionEntity(baseEntity);
			}
		}
	}
}


using UnityEngine;

public class BaseNavigateHomeState : BasicAIState
{
	private StateStatus status;

	public BaseNavigateHomeState()
		: base(AIState.NavigateHome)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		Vector3 pos = brain.Events.Memory.Position.Get(4);
		status = StateStatus.Running;
		if (!brain.Navigator.SetDestination(pos, BaseNavigator.NavigationSpeed.Normal))
		{
			status = StateStatus.Error;
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		Stop();
	}

	private void Stop()
	{
		brain.Navigator.Stop();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (!brain.Navigator.Moving)
		{
			return StateStatus.Finished;
		}
		return StateStatus.Running;
	}
}


public class BasePatrolState : BasicAIState
{
	public BasePatrolState()
		: base(AIState.Patrol)
	{
	}
}


using UnityEngine;

public class BaseRoamState : BasicAIState
{
	private float nextRoamPositionTime = -1f;

	private float lastDestinationTime;

	public BaseRoamState()
		: base(AIState.Roam)
	{
	}

	public override float GetWeight()
	{
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		nextRoamPositionTime = -1f;
		lastDestinationTime = Time.time;
	}

	public virtual Vector3 GetDestination()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual Vector3 GetForwardDirection()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.forward;
	}

	public virtual void SetDestination(Vector3 destination)
	{
	}

	public override void DrawGizmos()
	{
		base.DrawGizmos();
		brain.PathFinder.DebugDraw();
	}

	public virtual Vector3 GetRoamAnchorPosition()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return brain.Events.Memory.Position.Get(4);
		}
		return ((Component)brain.GetBaseEntity()).transform.position;
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		bool flag = Time.time - lastDestinationTime > 25f;
		if ((Vector3.Distance(GetDestination(), ((Component)entity).transform.position) < 2f || flag) && nextRoamPositionTime == -1f)
		{
			nextRoamPositionTime = Time.time + Random.Range(5f, 10f);
		}
		if (nextRoamPositionTime != -1f && Time.time > nextRoamPositionTime)
		{
			AIMovePoint bestRoamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), entity.ServerPosition, GetForwardDirection(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
			if (Object.op_Implicit((Object)(object)bestRoamPoint))
			{
				float num = Vector3.Distance(((Component)bestRoamPoint).transform.position, ((Component)entity).transform.position) / 1.5f;
				bestRoamPoint.SetUsedBy(entity, num + 11f);
			}
			lastDestinationTime = Time.time;
			Vector3 insideUnitSphere = Random.insideUnitSphere;
			insideUnitSphere.y = 0f;
			((Vector3)(ref insideUnitSphere)).Normalize();
			Vector3 destination = (((Object)(object)bestRoamPoint == (Object)null) ? ((Component)entity).transform.position : (((Component)bestRoamPoint).transform.position + insideUnitSphere * bestRoamPoint.radius));
			SetDestination(destination);
			nextRoamPositionTime = -1f;
		}
		return StateStatus.Running;
	}
}


public class BaseSleepState : BasicAIState
{
	private StateStatus status = StateStatus.Error;

	public BaseSleepState()
		: base(AIState.Sleep)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		if (entity is IAISleep iAISleep)
		{
			iAISleep.StartSleeping();
			status = StateStatus.Running;
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		if (entity is IAISleep iAISleep)
		{
			iAISleep.StopSleeping();
		}
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		return status;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.UI;

public class BaseArcadeMachine : BaseVehicle
{
	public class ScoreEntry
	{
		public ulong playerID;

		public int score;

		public string displayName;
	}

	public BaseArcadeGame arcadeGamePrefab;

	public BaseArcadeGame activeGame;

	public ArcadeNetworkTrigger networkTrigger;

	public float broadcastRadius = 8f;

	public Transform gameScreen;

	public RawImage RTImage;

	public Transform leftJoystick;

	public Transform rightJoystick;

	public SoundPlayer musicPlayer;

	public const Flags Flag_P1 = Flags.Reserved7;

	public const Flags Flag_P2 = Flags.Reserved8;

	public List<ScoreEntry> scores = new List<ScoreEntry>(10);

	private const int inputFrameRate = 60;

	private const int snapshotFrameRate = 15;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseArcadeMachine.OnRpcMessage", 0);
		try
		{
			if (rpc == 271542211 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BroadcastEntityMessage "));
				}
				TimeWarning val2 = TimeWarning.New("BroadcastEntityMessage", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(271542211u, "BroadcastEntityMessage", this, player, 7uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(271542211u, "BroadcastEntityMessage", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BroadcastEntityMessage(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BroadcastEntityMessage");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1365277306 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DestroyMessageFromHost "));
				}
				TimeWarning val2 = TimeWarning.New("DestroyMessageFromHost", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1365277306u, "DestroyMessageFromHost", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							DestroyMessageFromHost(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in DestroyMessageFromHost");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2467852388u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - GetSnapshotFromClient "));
				}
				TimeWarning val2 = TimeWarning.New("GetSnapshotFromClient", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2467852388u, "GetSnapshotFromClient", this, player, 30uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(2467852388u, "GetSnapshotFromClient", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							GetSnapshotFromClient(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in GetSnapshotFromClient");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2990871635u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RequestAddScore "));
				}
				TimeWarning val2 = TimeWarning.New("RequestAddScore", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2990871635u, "RequestAddScore", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RequestAddScore(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RequestAddScore");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public void AddScore(BasePlayer player, int score)
	{
		ScoreEntry scoreEntry = new ScoreEntry();
		scoreEntry.displayName = player.displayName;
		scoreEntry.score = score;
		scoreEntry.playerID = player.userID;
		scores.Add(scoreEntry);
		scores.Sort((ScoreEntry a, ScoreEntry b) => b.score.CompareTo(a.score));
		scores.TrimExcess();
		SendNetworkUpdate();
		Interface.CallHook("OnArcadeScoreAdded", (object)this, (object)player, (object)score);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RequestAddScore(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && PlayerIsMounted(player))
		{
			int score = msg.read.Int32();
			AddScore(player, score);
		}
	}

	public override void PlayerMounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerMounted(player, seat);
		ClientRPC(RpcTarget.Player("BeginHosting", player));
		SetFlag(Flags.Reserved7, b: true, recursive: true);
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		ClientRPC(RpcTarget.Player("EndHosting", player));
		SetFlag(Flags.Reserved7, b: false, recursive: true);
		if (!AnyMounted())
		{
			NearbyClientMessage("NoHost");
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.arcadeMachine = Pool.Get<ArcadeMachine>();
		info.msg.arcadeMachine.scores = Pool.Get<List<ScoreEntry>>();
		for (int i = 0; i < scores.Count; i++)
		{
			ScoreEntry val = Pool.Get<ScoreEntry>();
			val.displayName = scores[i].displayName;
			val.playerID = scores[i].playerID;
			val.score = scores[i].score;
			info.msg.arcadeMachine.scores.Add(val);
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.arcadeMachine != null && info.msg.arcadeMachine.scores != null)
		{
			scores.Clear();
			for (int i = 0; i < info.msg.arcadeMachine.scores.Count; i++)
			{
				ScoreEntry scoreEntry = new ScoreEntry();
				scoreEntry.displayName = info.msg.arcadeMachine.scores[i].displayName;
				scoreEntry.score = info.msg.arcadeMachine.scores[i].score;
				scoreEntry.playerID = info.msg.arcadeMachine.scores[i].playerID;
				scores.Add(scoreEntry);
			}
		}
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
	}

	public void NearbyClientMessage(string msg)
	{
		if (networkTrigger.entityContents == null)
		{
			return;
		}
		foreach (BaseEntity entityContent in networkTrigger.entityContents)
		{
			BasePlayer component = ((Component)entityContent).GetComponent<BasePlayer>();
			ClientRPC(RpcTarget.Player(msg, component));
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void DestroyMessageFromHost(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)GetDriver() != (Object)(object)player || networkTrigger.entityContents == null)
		{
			return;
		}
		uint arg = msg.read.UInt32();
		foreach (BaseEntity entityContent in networkTrigger.entityContents)
		{
			BasePlayer component = ((Component)entityContent).GetComponent<BasePlayer>();
			ClientRPC(RpcTarget.Player("DestroyEntity", component), arg);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(7uL)]
	public void BroadcastEntityMessage(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)GetDriver() != (Object)(object)player || networkTrigger.entityContents == null)
		{
			return;
		}
		uint arg = msg.read.UInt32();
		string arg2 = msg.read.String(256, false);
		foreach (BaseEntity entityContent in networkTrigger.entityContents)
		{
			BasePlayer component = ((Component)entityContent).GetComponent<BasePlayer>();
			ClientRPC(RpcTarget.Player("GetEntityMessage", component), arg, arg2);
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server.CallsPerSecond(30uL)]
	[RPC_Server]
	public void GetSnapshotFromClient(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player == (Object)null || (Object)(object)player != (Object)(object)GetDriver())
		{
			return;
		}
		ArcadeGame val = msg.read.Proto<ArcadeGame>((ArcadeGame)null);
		try
		{
			Connection sourceConnection = null;
			if (networkTrigger.entityContents == null)
			{
				return;
			}
			foreach (BaseEntity entityContent in networkTrigger.entityContents)
			{
				BasePlayer component = ((Component)entityContent).GetComponent<BasePlayer>();
				ClientRPCPlayer<ArcadeGame>(sourceConnection, component, "GetSnapshotFromServer", val);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


public class ScoreEntry
{
	public ulong playerID;

	public int score;

	public string displayName;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.CardGames;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public abstract class BaseCardGameEntity : BaseVehicle
{
	[Serializable]
	public class PlayerStorageInfo
	{
		public Transform storagePos;

		public EntityRef storageInstance;

		public CardGamePlayerStorage GetStorage()
		{
			BaseEntity baseEntity = storageInstance.Get(serverside: true);
			if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
			{
				return baseEntity as CardGamePlayerStorage;
			}
			return null;
		}
	}

	public enum CardGameOption
	{
		TexasHoldEm,
		Blackjack
	}

	[Header("Card Game")]
	[SerializeField]
	private GameObjectRef uiPrefab;

	public ItemDefinition scrapItemDef;

	[SerializeField]
	private GameObjectRef potPrefab;

	public PlayerStorageInfo[] playerStoragePoints;

	[SerializeField]
	private GameObjectRef playerStoragePrefab;

	private CardGameController _gameCont;

	public CardGameOption gameOption;

	private bool _disposed;

	public EntityRef PotInstance;

	private bool storageLinked;

	public int ScrapItemID => scrapItemDef.itemid;

	public CardGameController GameController
	{
		get
		{
			if (_gameCont == null)
			{
				_gameCont = GetGameController();
			}
			return _gameCont;
		}
	}

	protected abstract float MaxStorageInteractionDist { get; }

	protected override bool CanSwapSeats
	{
		public get
		{
			return false;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseCardGameEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 2395020190u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Editor_MakeRandomMove "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Editor_MakeRandomMove", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2395020190u, "RPC_Editor_MakeRandomMove", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							RPC_Editor_MakeRandomMove(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_Editor_MakeRandomMove");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1608700874 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Editor_SpawnTestPlayer "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Editor_SpawnTestPlayer", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1608700874u, "RPC_Editor_SpawnTestPlayer", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_Editor_SpawnTestPlayer(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_Editor_SpawnTestPlayer");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 1499640189 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_LeaveTable "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_LeaveTable", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(1499640189u, "RPC_LeaveTable", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							RPC_LeaveTable(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in RPC_LeaveTable");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 331989034 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_OpenLoot "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_OpenLoot", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(331989034u, "RPC_OpenLoot", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg5 = rPCMessage;
							RPC_OpenLoot(msg5);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex4)
					{
						Debug.LogException(ex4);
						player.Kick("RPC Error in RPC_OpenLoot");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2847205856u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_Play "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_Play", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2847205856u, "RPC_Play", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg6 = rPCMessage;
							RPC_Play(msg6);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex5)
					{
						Debug.LogException(ex5);
						player.Kick("RPC Error in RPC_Play");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2495306863u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PlayerInput "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PlayerInput", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(2495306863u, "RPC_PlayerInput", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg7 = rPCMessage;
							RPC_PlayerInput(msg7);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex6)
					{
						Debug.LogException(ex6);
						player.Kick("RPC Error in RPC_PlayerInput");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (base.isServer)
		{
			PotInstance.uid = info.msg.cardGame.potRef;
		}
	}

	private CardGameController GetGameController()
	{
		if (_disposed)
		{
			return null;
		}
		return gameOption switch
		{
			CardGameOption.TexasHoldEm => new TexasHoldEmController(this), 
			CardGameOption.Blackjack => new BlackjackController(this), 
			_ => new TexasHoldEmController(this), 
		};
	}

	public override void DestroyShared()
	{
		if (!_disposed)
		{
			_disposed = true;
			base.DestroyShared();
			GameController?.Dispose();
			_gameCont = null;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.cardGame = Pool.Get<CardGame>();
		info.msg.cardGame.potRef = PotInstance.uid;
		if (!info.forDisk && storageLinked)
		{
			GameController?.Save(info.msg.cardGame);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		int num = 0;
		int num2 = 0;
		foreach (BaseEntity child in children)
		{
			if (child is CardGamePlayerStorage cardGamePlayerStorage)
			{
				playerStoragePoints[num].storageInstance.Set(cardGamePlayerStorage);
				if (!cardGamePlayerStorage.inventory.IsEmpty())
				{
					num2++;
				}
				num++;
			}
		}
		storageLinked = true;
		bool flag = true;
		StorageContainer pot = GetPot();
		if ((Object)(object)pot == (Object)null)
		{
			flag = false;
		}
		else
		{
			int num3 = ((num2 > 0) ? num2 : playerStoragePoints.Length);
			int iAmount = Mathf.CeilToInt((float)(pot.inventory.GetAmount(ScrapItemID, onlyUsableAmounts: true) / num3));
			PlayerStorageInfo[] array = playerStoragePoints;
			for (int i = 0; i < array.Length; i++)
			{
				CardGamePlayerStorage cardGamePlayerStorage2 = array[i].storageInstance.Get(base.isServer) as CardGamePlayerStorage;
				if (!cardGamePlayerStorage2.IsValid() || (cardGamePlayerStorage2.inventory.IsEmpty() && num2 != 0))
				{
					continue;
				}
				List<Item> list = Pool.Get<List<Item>>();
				if (pot.inventory.Take(list, ScrapItemID, iAmount) > 0)
				{
					foreach (Item item in list)
					{
						if (!item.MoveToContainer(cardGamePlayerStorage2.inventory, -1, allowStack: true, ignoreStackLimit: true))
						{
							item.Remove();
						}
					}
				}
				Pool.Free<Item>(ref list, false);
			}
		}
		if (flag)
		{
			PlayerStorageInfo[] array = playerStoragePoints;
			for (int i = 0; i < array.Length; i++)
			{
				if (!array[i].storageInstance.IsValid(base.isServer))
				{
					flag = false;
					break;
				}
			}
		}
		if (!flag)
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": Card game storage didn't load in. Destroying the card game (and parent entity if there is one)."));
			BaseEntity baseEntity = GetParentEntity();
			if ((Object)(object)baseEntity != (Object)null)
			{
				((FacepunchBehaviour)baseEntity).Invoke((Action)baseEntity.KillMessage, 0f);
			}
			else
			{
				((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0f);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		GameController?.OnTableDestroyed();
		PlayerStorageInfo[] array = playerStoragePoints;
		for (int i = 0; i < array.Length; i++)
		{
			CardGamePlayerStorage storage = array[i].GetStorage();
			if ((Object)(object)storage != (Object)null)
			{
				storage.DropItems();
			}
		}
		StorageContainer pot = GetPot();
		if ((Object)(object)pot != (Object)null)
		{
			pot.DropItems();
		}
		base.DoServerDestroy();
	}

	public override void PrePlayerDismount(BasePlayer player, BaseMountable seat)
	{
		base.PrePlayerDismount(player, seat);
		if (!Application.isLoadingSave)
		{
			CardGamePlayerStorage playerStorage = GetPlayerStorage(player.userID);
			if ((Object)(object)playerStorage != (Object)null)
			{
				playerStorage.inventory.GetSlot(0)?.MoveToContainer(player.inventory.containerMain);
			}
		}
	}

	public override void PlayerDismounted(BasePlayer player, BaseMountable seat)
	{
		base.PlayerDismounted(player, seat);
		GameController?.LeaveTable(player.userID);
	}

	public StorageContainer GetPot()
	{
		BaseEntity baseEntity = PotInstance.Get(serverside: true);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as StorageContainer;
		}
		return null;
	}

	public BasePlayer IDToPlayer(ulong id)
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null && (Object)(object)mountPoint.mountable.GetMounted() != (Object)null && (ulong)mountPoint.mountable.GetMounted().userID == id)
			{
				return mountPoint.mountable.GetMounted();
			}
		}
		return null;
	}

	public virtual void PlayerStorageChanged()
	{
		GameController?.PlayerStorageChanged();
	}

	public CardGamePlayerStorage GetPlayerStorage(int storageIndex)
	{
		return playerStoragePoints[storageIndex].GetStorage();
	}

	public CardGamePlayerStorage GetPlayerStorage(ulong playerID)
	{
		int mountPointIndex = GetMountPointIndex(playerID);
		if (mountPointIndex < 0)
		{
			return null;
		}
		return playerStoragePoints[mountPointIndex].GetStorage();
	}

	public int GetMountPointIndex(ulong playerID)
	{
		int num = -1;
		for (int i = 0; i < mountPoints.Count; i++)
		{
			BaseMountable mountable = mountPoints[i].mountable;
			if ((Object)(object)mountable != (Object)null)
			{
				BasePlayer mounted = mountable.GetMounted();
				if ((Object)(object)mounted != (Object)null && (ulong)mounted.userID == playerID)
				{
					num = i;
				}
			}
		}
		if (num < 0)
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Couldn't find mount point for this player."));
		}
		return num;
	}

	public override void SpawnSubEntities()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(potPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		StorageContainer storageContainer = baseEntity as StorageContainer;
		if ((Object)(object)storageContainer != (Object)null)
		{
			storageContainer.SetParent(this);
			storageContainer.Spawn();
			PotInstance.Set(baseEntity);
		}
		else
		{
			Debug.LogError((object)(((object)this).GetType().Name + ": Spawned prefab is not a StorageContainer as expected."));
		}
		PlayerStorageInfo[] array = playerStoragePoints;
		foreach (PlayerStorageInfo playerStorageInfo in array)
		{
			baseEntity = GameManager.server.CreateEntity(playerStoragePrefab.resourcePath, playerStorageInfo.storagePos.localPosition, playerStorageInfo.storagePos.localRotation);
			CardGamePlayerStorage cardGamePlayerStorage = baseEntity as CardGamePlayerStorage;
			if ((Object)(object)cardGamePlayerStorage != (Object)null)
			{
				cardGamePlayerStorage.SetCardTable(this);
				cardGamePlayerStorage.SetParent(this);
				cardGamePlayerStorage.Spawn();
				playerStorageInfo.storageInstance.Set(baseEntity);
				storageLinked = true;
			}
			else
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": Spawned prefab is not a CardTablePlayerStorage as expected."));
			}
		}
		base.SpawnSubEntities();
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_PlayerInput(RPCMessage msg)
	{
		GameController?.ReceivedInputFromPlayer(msg.player, msg.read.Int32(), countAsAction: true, msg.read.Int32());
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_LeaveTable(RPCMessage msg)
	{
		GameController?.LeaveTable(msg.player.userID);
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	private void RPC_OpenLoot(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player != (Object)null && PlayerIsMounted(player))
		{
			GetPlayerStorage(player.userID).PlayerOpenLoot(player);
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_Editor_SpawnTestPlayer(RPCMessage msg)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isEditor || GameController == null)
		{
			return;
		}
		int num = GameController.MaxPlayersAtTable();
		if (GameController.NumPlayersAllowedToPlay() >= num || NumMounted() >= num)
		{
			return;
		}
		Debug.Log((object)"Adding test NPC for card game");
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", ((Component)this).transform.position, Quaternion.identity);
		baseEntity.Spawn();
		BasePlayer basePlayer = (BasePlayer)baseEntity;
		AttemptMount(basePlayer, doMountChecks: false);
		GameController.JoinTable(basePlayer);
		if (GameController.TryGetCardPlayerData(basePlayer, out var cardPlayer))
		{
			int scrapAmount = cardPlayer.GetScrapAmount();
			if (scrapAmount < 400)
			{
				StorageContainer storage = cardPlayer.GetStorage();
				if ((Object)(object)storage != (Object)null)
				{
					storage.inventory.AddItem(scrapItemDef, 400 - scrapAmount, 0uL);
				}
				else
				{
					Debug.LogError((object)"Couldn't get storage for NPC.");
				}
			}
		}
		else
		{
			Debug.Log((object)"Couldn't find player data for NPC. No scrap given.");
		}
	}

	[RPC_Server.IsVisible(3f)]
	[RPC_Server]
	public void RPC_Editor_MakeRandomMove(RPCMessage msg)
	{
		if (Application.isEditor)
		{
			GameController?.EditorMakeRandomMove();
		}
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	private void RPC_Play(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if ((Object)(object)player != (Object)null && PlayerIsMounted(player))
		{
			GameController.JoinTable(player);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class PlayerStorageInfo
{
	public Transform storagePos;

	public EntityRef storageInstance;

	public CardGamePlayerStorage GetStorage()
	{
		BaseEntity baseEntity = storageInstance.Get(serverside: true);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as CardGamePlayerStorage;
		}
		return null;
	}
}


public enum CardGameOption
{
	TexasHoldEm,
	Blackjack
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseCombatEntity : BaseEntity
{
	public enum LifeState
	{
		Alive,
		Dead
	}

	[Serializable]
	public enum Faction
	{
		Default,
		Player,
		Bandit,
		Scientist,
		Horror
	}

	[Serializable]
	public struct Pickup
	{
		public bool enabled;

		[ItemSelector]
		public ItemDefinition itemTarget;

		public int itemCount;

		[Tooltip("Should we set the condition of the item based on the health of the picked up entity")]
		public bool setConditionFromHealth;

		[Tooltip("How much to reduce the item condition when picking up")]
		public float subtractCondition;

		[Tooltip("Must have building access to pick up")]
		public bool requireBuildingPrivilege;

		[Tooltip("Must have hammer equipped to pick up")]
		public bool requireHammer;

		[Tooltip("Inventory Must be empty (if applicable) to be picked up")]
		public bool requireEmptyInv;

		[Tooltip("If set, pickup will take this long in seconds")]
		public float overridePickupTime;
	}

	public static class PickupErrors
	{
		public static readonly Phrase ItemMustBeEmpty = new Phrase("pickuperror_itemmustbeempty", "{0} must be empty");

		public static readonly Phrase ItemInventoryMustBeEmpty = new Phrase("pickuperror_iteminventorymustbeempty", "{0} inventory must be empty");

		public static readonly Phrase ItemIsBeingUsed = new Phrase("pickuperrors_itemisbeingused", "{0} is being used");

		public static readonly Phrase ItemHasCloser = new Phrase("pickuperrors_itemhascloser", "{0} has closer");

		public static readonly Phrase ItemHasLock = new Phrase("pickuperrors_itemhaslock", "{0} has lock");

		public static readonly Phrase ItemHasStorageAdaptor = new Phrase("pickuperrors_itemhasstorageadaptor", "{0} has storage adaptor");

		public static readonly Phrase ItemHasStorageMonitor = new Phrase("pickuperrors_itemhasstorageadaptor", "{0} has storage monitor");

		public static readonly Phrase ItemHasDecoration = new Phrase("pickuperrors_itemhasdecoration", "{0} has decoration");

		public static readonly Phrase ItemHasAttachment = new Phrase("pickuperrors_itemhasattachment", "{0} has attachment");

		public static readonly Phrase ItemIsOnline = new Phrase("pickuperrors_itemisonline", "{0} is online");

		public static readonly Phrase ItemIsArmed = new Phrase("pickuperrors_itemisarmed", "{0} is armed");

		public static readonly Phrase ItemIsOccupied = new Phrase("pickuperror_itemisoccupied", "{0} is occupied");

		public static Phrase FormattedPhrase(Phrase format, Phrase arg0)
		{
			return Phrase.op_Implicit(string.Format(format.translated, arg0.translated));
		}
	}

	[Serializable]
	public struct Repair
	{
		public bool enabled;

		[ItemSelector]
		public ItemDefinition itemTarget;

		[ItemSelector]
		public ItemDefinition ignoreForRepair;

		public GameObjectRef repairEffect;

		public GameObjectRef repairFullEffect;

		public GameObjectRef repairFailedEffect;
	}

	public enum ActionVolume
	{
		Quiet,
		Normal,
		Loud
	}

	[Header("Deployable Corpse")]
	[InspectorName("Spawn Corpse")]
	public bool spawnDeployableCorpseOnDeath;

	[InspectorName("Corpse Prefab")]
	public GameObjectRef deployableCorpsePrefab;

	[Header("BaseCombatEntity")]
	public SkeletonProperties skeletonProperties;

	public ProtectionProperties baseProtection;

	public float startHealth;

	public Pickup pickup;

	public Repair repair;

	public bool ShowHealthInfo = true;

	[ReadOnly]
	public LifeState lifestate;

	public bool sendsHitNotification;

	public bool sendsMeleeHitNotification = true;

	public bool markAttackerHostile = true;

	public float _health;

	public float _maxHealth = 100f;

	public Faction faction;

	[NonSerialized]
	public float lastAttackedTime = float.NegativeInfinity;

	[NonSerialized]
	public float lastDealtDamageTime = float.NegativeInfinity;

	public int lastNotifyFrame;

	protected (Phrase format, Phrase arg0) pickupErrorToFormat;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	private const float MAX_HEALTH_REPAIR = 50f;

	public static readonly Phrase RecentlyDamagedError = new Phrase("error_recentlydamaged", "Recently damaged, repairable in {0} seconds");

	public static readonly Phrase NotDamagedError = new Phrase("error_notdamaged", "Not damaged");

	[NonSerialized]
	public DamageType lastDamage;

	[NonSerialized]
	public BaseEntity lastAttacker;

	[NonSerialized]
	public BaseEntity lastDealtDamageTo;

	[NonSerialized]
	public bool ResetLifeStateOnSpawn = true;

	public DirectionProperties[] propDirection;

	public float unHostileTime;

	public float lastNoiseTime;

	public Vector3 LastAttackedDir { get; set; }

	public float SecondsSinceAttacked => Time.time - lastAttackedTime;

	public float SecondsSinceDealtDamage => Time.time - lastDealtDamageTime;

	public float healthFraction => Health() / MaxHealth();

	public float health
	{
		get
		{
			return _health;
		}
		set
		{
			float num = _health;
			_health = Mathf.Clamp(value, 0f, MaxHealth());
			if (base.isServer && _health != num)
			{
				OnHealthChanged(num, _health);
			}
		}
	}

	public float TimeSinceLastNoise => Time.time - lastNoiseTime;

	public ActionVolume LastNoiseVolume { get; private set; }

	public Vector3 LastNoisePosition { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseCombatEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 1191093595 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_PickupStart "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_PickupStart", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(1191093595u, "RPC_PickupStart", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_PickupStart(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_PickupStart");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual void TryDropCorpse(HitInfo info)
	{
		if (ShouldDropDeployableCorpse(info))
		{
			DropDeployableCorpse(base.OwnerID);
		}
	}

	public virtual bool ShouldDropDeployableCorpse(HitInfo info)
	{
		if (info == null)
		{
			return ShouldDropDeployableCorpse(null, DamageType.Generic);
		}
		return ShouldDropDeployableCorpse(info.InitiatorPlayer, info.damageTypes.GetMajorityDamageType());
	}

	public virtual bool ShouldDropDeployableCorpse(BaseEntity lastAttackerEnt, DamageType damageType)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (!StorageContainer.dropCorpseOnDeath)
		{
			return false;
		}
		if (!spawnDeployableCorpseOnDeath)
		{
			return false;
		}
		if (damageType == DamageType.Decay)
		{
			return false;
		}
		if ((Object)(object)lastAttackerEnt != (Object)null && lastAttackerEnt is BasePlayer basePlayer && ((ulong)basePlayer.userID == base.OwnerID || basePlayer.IsBuildingAuthed(((Component)this).transform.position, ((Component)this).transform.rotation, bounds)))
		{
			return false;
		}
		foreach (EntityComponentBase component in base.Components)
		{
			if (component is GroundWatch groundWatch)
			{
				if (!groundWatch.cachedGround.IsRealNull())
				{
					if (groundWatch.cachedGround.lastDamage == DamageType.Decay)
					{
						return false;
					}
					BasePlayer basePlayer2 = groundWatch.cachedGround.lastAttacker?.ToPlayer();
					if ((Object)(object)basePlayer2 != (Object)null && ((ulong)basePlayer2.userID == base.OwnerID || basePlayer2.IsBuildingAuthed(((Component)this).transform.position, ((Component)this).transform.rotation, bounds)))
					{
						return false;
					}
					break;
				}
				break;
			}
		}
		return true;
	}

	public void DropDeployableCorpse(ulong owner)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!deployableCorpsePrefab.isValid)
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(deployableCorpsePrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		if (HasParent())
		{
			baseEntity.SetParent(GetParentEntity(), worldPositionStays: true);
		}
		baseEntity.OwnerID = owner;
		baseEntity.skinID = skinID;
		baseEntity?.Spawn();
		if (baseEntity is ContainerCorpse containerCorpse)
		{
			BaseLock baseLock = GetSlot(Slot.Lock) as BaseLock;
			if ((Object)(object)baseLock != (Object)null)
			{
				containerCorpse.SaveLock(baseLock);
			}
			containerCorpse.timePlaced = GetNetworkTime();
		}
		OnDeployableCorpseSpawned(baseEntity);
	}

	public virtual void OnDeployableCorpseSpawned(BaseEntity corpse)
	{
	}

	public override void AdminKill()
	{
		TryDropCorpse(null);
		base.AdminKill();
	}

	public virtual bool IsDead()
	{
		return lifestate == LifeState.Dead;
	}

	public virtual bool IsAlive()
	{
		return lifestate == LifeState.Alive;
	}

	public Faction GetFaction()
	{
		return faction;
	}

	public virtual bool IsFriendly(BaseCombatEntity other)
	{
		return false;
	}

	public override void ResetState()
	{
		base.ResetState();
		health = MaxHealth();
		if (base.isServer)
		{
			lastAttackedTime = float.NegativeInfinity;
			lastDealtDamageTime = float.NegativeInfinity;
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer)
		{
			UpdateSurroundings();
		}
	}

	public virtual float GetThreatLevel()
	{
		return 0f;
	}

	public override float PenetrationResistance(HitInfo info)
	{
		if (!Object.op_Implicit((Object)(object)baseProtection))
		{
			return 100f;
		}
		return baseProtection.density;
	}

	public virtual void ScaleDamage(HitInfo info)
	{
		if (info.UseProtection && (Object)(object)baseProtection != (Object)null)
		{
			baseProtection.Scale(info.damageTypes);
		}
	}

	public HitArea SkeletonLookup(uint boneID)
	{
		if ((Object)(object)skeletonProperties == (Object)null)
		{
			return (HitArea)(-1);
		}
		return skeletonProperties.FindBone(boneID)?.area ?? ((HitArea)(-1));
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseCombat = Pool.Get<BaseCombat>();
		info.msg.baseCombat.state = (int)lifestate;
		info.msg.baseCombat.health = Health();
		info.msg.baseCombat.maxHealth = MaxHealth();
		if (ItemOwnership.IsValid())
		{
			info.msg.ownership = Pool.Get<ItemOwnershipAmount>();
			info.msg.ownership.username = ItemOwnership.username;
			info.msg.ownership.reason = ItemOwnership.reason;
			info.msg.ownership.amount = ItemOwnership.amount;
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (Health() > MaxHealth())
		{
			health = MaxHealth();
		}
		if (float.IsNaN(Health()))
		{
			health = MaxHealth();
		}
	}

	public void SetJustAttacked()
	{
		lastAttackedTime = Time.time;
	}

	public override void Load(LoadInfo info)
	{
		if (base.isServer)
		{
			lifestate = LifeState.Alive;
		}
		if (info.msg.baseCombat != null)
		{
			lifestate = (LifeState)info.msg.baseCombat.state;
			_health = info.msg.baseCombat.health;
			if (info.msg.baseCombat.maxHealth != 0f && !info.fromDisk)
			{
				_maxHealth = info.msg.baseCombat.maxHealth;
			}
		}
		base.Load(info);
		if (info.msg.ownership != null)
		{
			ItemOwnership = new ItemOwnershipShare
			{
				username = info.msg.ownership.username,
				reason = info.msg.ownership.reason,
				amount = info.msg.ownership.amount
			};
		}
	}

	public override float Health()
	{
		return _health;
	}

	public override float MaxHealth()
	{
		return _maxHealth;
	}

	public virtual float StartHealth()
	{
		return startHealth;
	}

	public virtual float StartMaxHealth()
	{
		return StartHealth();
	}

	public void SetMaxHealth(float newMax)
	{
		_maxHealth = newMax;
		_health = Mathf.Min(_health, newMax);
		SendNetworkUpdate();
	}

	public void DoHitNotify(HitInfo info)
	{
		TimeWarning val = TimeWarning.New("DoHitNotify", 0);
		try
		{
			if (sendsHitNotification && !((Object)(object)info.Initiator == (Object)null) && info.Initiator is BasePlayer && !((Object)(object)this == (Object)(object)info.Initiator) && (!info.isHeadshot || !(info.HitEntity is BasePlayer)) && Time.frameCount != lastNotifyFrame)
			{
				lastNotifyFrame = Time.frameCount;
				bool flag = info.Weapon is BaseMelee;
				if (base.isServer && (!flag || sendsMeleeHitNotification))
				{
					bool arg = info.Initiator.net.connection == info.Predicted;
					ClientRPC(RpcTarget.PlayerAndSpectators("HitNotify", info.Initiator as BasePlayer), arg);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool OnAttacked(float amount, DamageType type, BaseEntity attacker = null, bool ignoreShield = true)
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (!ignoreShield && attacker.IsValid() && this.ToNonNpcPlayer(out var player) && player.GetActiveShield(out var foundShield) && foundShield.IsBlocking())
		{
			Vector3 val = Vector3Ex.NormalizeXZ(((Component)attacker).transform.position - ((Component)attacker).transform.forward * 1f - ((Component)this).transform.position);
			Vector3 val2 = Vector3Ex.NormalizeXZ(player.eyes.BodyForward());
			if (Vector3.Dot(val, val2) > 0f)
			{
				HitInfo hitInfo = Pool.Get<HitInfo>();
				hitInfo.Init(attacker, foundShield, type, amount, ((Component)this).transform.position);
				foundShield.OnAttacked(hitInfo);
				Pool.Free<HitInfo>(ref hitInfo);
				return false;
			}
		}
		HitInfo hitInfo2 = Pool.Get<HitInfo>();
		hitInfo2.Init(attacker, this, type, amount, ((Component)this).transform.position);
		OnAttacked(hitInfo2);
		Pool.Free<HitInfo>(ref hitInfo2);
		return true;
	}

	public override void OnAttacked(HitInfo info)
	{
		TimeWarning val = TimeWarning.New("BaseCombatEntity.OnAttacked", 0);
		try
		{
			if (!IsDead())
			{
				DoHitNotify(info);
			}
			if (base.isServer)
			{
				Hurt(info);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		base.OnAttacked(info);
	}

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		if (fromItem != null && fromItem.HasItemOwnership())
		{
			ItemOwnership = fromItem.TakeOwnershipShare();
		}
		else if ((Object)(object)deployedBy != (Object)null)
		{
			ItemOwnership = new ItemOwnershipShare
			{
				username = deployedBy.displayName,
				amount = 1
			};
		}
	}

	protected virtual int GetPickupCount()
	{
		return pickup.itemCount;
	}

	protected virtual bool ShouldDisplayPickupOption(BasePlayer player)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		bool flag = pickup.enabled && (!pickup.requireBuildingPrivilege || player.CanBuild()) && (!pickup.requireHammer || player.IsHoldingEntity<Hammer>()) && (Object)(object)player != (Object)null && !player.IsInTutorial;
		if (flag)
		{
			PickupVolume[] volumes = PrefabAttribute.server.FindAll<PickupVolume>(prefabID);
			if (PickupVolume.Check(((Component)this).transform.position, ((Component)this).transform.rotation, volumes, this))
			{
				flag = false;
			}
		}
		return flag;
	}

	protected virtual bool CanCompletePickup(BasePlayer player)
	{
		object obj = Interface.CallHook("CanPickupEntity", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public virtual void OnPickedUp(Item createdItem, BasePlayer player)
	{
		Interface.CallHook("OnEntityPickedUp", (object)this, (object)createdItem, (object)player);
	}

	public virtual void OnPickedUpPreItemMove(Item createdItem, BasePlayer player)
	{
	}

	[RPC_Server.MaxDistance(3f)]
	[RPC_Server]
	private void RPC_PickupStart(RPCMessage rpc)
	{
		pickupErrorToFormat = (format: null, arg0: null);
		if (!rpc.player.CanInteract() || !ShouldDisplayPickupOption(rpc.player))
		{
			return;
		}
		if (!CanCompletePickup(rpc.player))
		{
			if (pickupErrorToFormat.format == null || pickupErrorToFormat.arg0 == null)
			{
				Debug.LogWarning((object)(((object)rpc.player).ToString() + " failed to pickup " + ((Object)this).name + " but no valid error reason was given"), (Object)(object)this);
				return;
			}
			string token = pickupErrorToFormat.format.token;
			string token2 = pickupErrorToFormat.arg0.token;
			ClientRPC(RpcTarget.Player("Client_ShowFormattedErrorToast", rpc.player), token, token2);
			return;
		}
		Item item = ItemManager.Create(pickup.itemTarget, GetPickupCount(), skinID);
		if (ItemOwnership.IsValid())
		{
			item.SetItemOwnership(ItemOwnership);
		}
		else
		{
			item.SetItemOwnership(rpc.player, ItemOwnershipPhrases.PickedUp);
		}
		if (pickup.setConditionFromHealth && item.hasCondition)
		{
			item.conditionNormalized = Mathf.Clamp01(healthFraction - pickup.subtractCondition);
		}
		OnPickedUpPreItemMove(item, rpc.player);
		rpc.player.GiveItem(item, GiveItemReason.PickedUp);
		OnPickedUp(item, rpc.player);
		Analytics.Azure.OnEntityPickedUp(rpc.player, this);
		Kill();
	}

	public virtual List<ItemAmount> BuildCost()
	{
		if ((Object)(object)repair.itemTarget == (Object)null)
		{
			return null;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(repair.itemTarget);
		if ((Object)(object)itemBlueprint == (Object)null)
		{
			return null;
		}
		return itemBlueprint.GetIngredients();
	}

	public virtual float RepairCostFraction()
	{
		return 0.5f;
	}

	public List<ItemAmount> RepairCost(float healthMissingFraction)
	{
		List<ItemAmount> list = BuildCost();
		if (list == null)
		{
			return null;
		}
		List<ItemAmount> list2 = new List<ItemAmount>();
		foreach (ItemAmount item in list)
		{
			if (!((Object)(object)repair.ignoreForRepair != (Object)null) || item.itemDef.itemid != repair.ignoreForRepair.itemid)
			{
				list2.Add(new ItemAmount(item.itemDef, Mathf.Max(Mathf.RoundToInt(item.amount * RepairCostFraction() * healthMissingFraction), 1)));
			}
		}
		RepairBench.StripComponentRepairCost(list2, RepairCostFraction() * healthMissingFraction);
		return list2;
	}

	public virtual void OnRepair()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(repair.repairEffect.isValid ? repair.repairEffect.resourcePath : "assets/bundled/prefabs/fx/build/repair.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

	public virtual void OnRepairFinished(BasePlayer player)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(repair.repairFullEffect.isValid ? repair.repairFullEffect.resourcePath : "assets/bundled/prefabs/fx/build/repair_full.prefab", this, 0u, Vector3.zero, Vector3.zero);
	}

	public virtual void OnRepairFailed(BasePlayer player, Phrase reason, params string[] args)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(repair.repairFailedEffect.isValid ? repair.repairFailedEffect.resourcePath : "assets/bundled/prefabs/fx/build/repair_failed.prefab", this, 0u, Vector3.zero, Vector3.zero);
		if ((Object)(object)player != (Object)null && !string.IsNullOrEmpty(reason.token))
		{
			player.ShowToast(GameTip.Styles.Error, reason, overlay: false, args);
		}
	}

	public virtual void OnRepairFailedResources(BasePlayer player, List<ItemAmount> requirements)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(repair.repairFailedEffect.isValid ? repair.repairFailedEffect.resourcePath : "assets/bundled/prefabs/fx/build/repair_failed.prefab", this, 0u, Vector3.zero, Vector3.zero);
		if ((Object)(object)player != (Object)null)
		{
			ItemAmountList val = ItemAmount.SerialiseList(requirements);
			try
			{
				player.ClientRPC(RpcTarget.Player("Client_OnRepairFailedResources", player), val);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public virtual void DoRepair(BasePlayer player)
	{
		BasePlayer player2 = player;
		if (!repair.enabled || Interface.CallHook("OnStructureRepair", (object)this, (object)player) != null)
		{
			return;
		}
		float num = GetDamageRepairCooldown();
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num = 0f;
		}
		if (SecondsSinceAttacked <= num)
		{
			OnRepairFailed(player2, RecentlyDamagedError, (num - SecondsSinceAttacked).ToString("N0"));
			return;
		}
		float num2 = MaxHealth() - Health();
		float num3 = num2 / MaxHealth();
		if (num2 <= 0f || num3 <= 0f)
		{
			OnRepairFailed(player2, NotDamagedError);
			return;
		}
		List<ItemAmount> list = RepairCost(num3);
		if (list == null)
		{
			return;
		}
		float num4 = list.Sum((ItemAmount x) => x.amount);
		float healthBefore = health;
		if (player2.IsInCreativeMode && Creative.freeRepair)
		{
			num4 = 0f;
		}
		if (num4 > 0f)
		{
			float num5 = list.Min((ItemAmount x) => Mathf.Clamp01((float)player2.inventory.GetAmount(x.itemid) / x.amount));
			if (float.IsNaN(num5))
			{
				num5 = 0f;
			}
			num5 = Mathf.Min(num5, 50f / num2);
			if (num5 <= 0f)
			{
				OnRepairFailedResources(player2, list);
				return;
			}
			int num6 = 0;
			foreach (ItemAmount item in list)
			{
				int amount = Mathf.CeilToInt(num5 * item.amount);
				int num7 = player2.inventory.Take(null, item.itemid, amount);
				Analytics.Azure.LogResource(Analytics.Azure.ResourceMode.Consumed, "repair_entity", item.itemDef.shortname, num7, this, null, safezone: false, null, player2.userID);
				if (num7 > 0)
				{
					num6 += num7;
					player2.Command("note.inv", item.itemid, num7 * -1);
				}
			}
			float num8 = (float)num6 / num4;
			health += num2 * num8;
			SendNetworkUpdate();
		}
		else
		{
			health += num2;
			SendNetworkUpdate();
		}
		Analytics.Azure.OnEntityRepaired(player2, this, healthBefore, health);
		if (Health() >= MaxHealth())
		{
			OnRepairFinished(player2);
		}
		else
		{
			OnRepair();
		}
	}

	public virtual float GetDamageRepairCooldown()
	{
		return 30f;
	}

	public virtual void InitializeHealth(float newhealth, float newmax)
	{
		_maxHealth = newmax;
		_health = newhealth;
		lifestate = LifeState.Alive;
	}

	public override void ServerInit()
	{
		propDirection = PrefabAttribute.server.FindAll<DirectionProperties>(prefabID);
		if (ResetLifeStateOnSpawn)
		{
			InitializeHealth(StartHealth(), StartMaxHealth());
			lifestate = LifeState.Alive;
		}
		base.ServerInit();
	}

	public virtual void OnHealthChanged(float oldvalue, float newvalue)
	{
	}

	public void Hurt(float amount)
	{
		Hurt(Mathf.Abs(amount), DamageType.Generic);
	}

	public void Hurt(float amount, DamageType type, BaseEntity attacker = null, bool useProtection = true)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Hurt", 0);
		try
		{
			HitInfo hitInfo = Pool.Get<HitInfo>();
			hitInfo.Init(attacker, this, type, amount, ((Component)this).transform.position);
			hitInfo.UseProtection = useProtection;
			Hurt(hitInfo);
			Pool.Free<HitInfo>(ref hitInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Hurt(HitInfo info)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(base.isServer, "This should be called serverside only");
		if (IsDead() || IsTransferProtected())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("Hurt( HitInfo )", 50);
		try
		{
			float num = health;
			ScaleDamage(info);
			if (info.PointStart != Vector3.zero)
			{
				for (int i = 0; i < propDirection.Length; i++)
				{
					if (!((Object)(object)propDirection[i].extraProtection == (Object)null) && !propDirection[i].IsWeakspot(((Component)this).transform, info))
					{
						propDirection[i].extraProtection.Scale(info.damageTypes);
					}
				}
			}
			info.damageTypes.Scale(DamageType.Arrow, ConVar.Server.arrowdamage);
			info.damageTypes.Scale(DamageType.Bullet, ConVar.Server.bulletdamage);
			info.damageTypes.Scale(DamageType.Slash, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Blunt, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Stab, ConVar.Server.meleedamage);
			info.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);
			if (!(this is BasePlayer))
			{
				info.damageTypes.Scale(DamageType.Fun_Water, 0f);
			}
			if (Interface.CallHook("IOnBaseCombatEntityHurt", (object)this, (object)info) != null)
			{
				return;
			}
			DebugHurt(info);
			float num2 = info.damageTypes.Total();
			health = num - num2;
			SendNetworkUpdate();
			LogEntry(RustLog.EntryType.Combat, 2, "hurt {0}/{1} - {2} health left", info.damageTypes.GetMajorityDamageType(), num2, health.ToString("0"));
			lastDamage = info.damageTypes.GetMajorityDamageType();
			lastAttacker = info.Initiator;
			if ((Object)(object)lastAttacker != (Object)null)
			{
				BaseCombatEntity baseCombatEntity = lastAttacker as BaseCombatEntity;
				if ((Object)(object)baseCombatEntity != (Object)null)
				{
					baseCombatEntity.lastDealtDamageTime = Time.time;
					baseCombatEntity.lastDealtDamageTo = this;
				}
				if (this.IsValid() && lastAttacker is BasePlayer basePlayer)
				{
					basePlayer.ProcessMissionEvent(BaseMission.MissionEventType.HURT_ENTITY, net.ID, num2);
				}
			}
			BaseCombatEntity baseCombatEntity2 = lastAttacker as BaseCombatEntity;
			if (markAttackerHostile && (Object)(object)baseCombatEntity2 != (Object)null && (Object)(object)baseCombatEntity2 != (Object)(object)this)
			{
				baseCombatEntity2.MarkHostileFor();
			}
			if (lastDamage.IsConsideredAnAttack())
			{
				SetJustAttacked();
				if ((Object)(object)lastAttacker != (Object)null)
				{
					Vector3 val2 = ((Component)lastAttacker).transform.position - ((Component)this).transform.position;
					LastAttackedDir = ((Vector3)(ref val2)).normalized;
				}
			}
			bool flag = Health() <= 0f;
			Analytics.Azure.OnEntityTakeDamage(info, flag);
			if (flag)
			{
				Die(info);
			}
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if (Object.op_Implicit((Object)(object)initiatorPlayer))
			{
				if (IsDead())
				{
					initiatorPlayer.stats.combat.LogAttack(info, "killed", num);
				}
				else
				{
					initiatorPlayer.stats.combat.LogAttack(info, "", num);
				}
			}
			if (base.Components == null)
			{
				return;
			}
			for (int j = 0; j < base.Components.Count; j++)
			{
				if (!((Object)(object)base.Components[j] == (Object)null))
				{
					base.Components[j].Hurt(info);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool IsHostile()
	{
		object obj = Interface.CallHook("CanEntityBeHostile", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return unHostileTime > Time.realtimeSinceStartup;
	}

	public virtual void MarkHostileFor(float duration = 60f)
	{
		if (Interface.CallHook("OnEntityMarkHostile", (object)this, (object)duration) == null)
		{
			float num = Time.realtimeSinceStartup + duration;
			unHostileTime = Mathf.Max(unHostileTime, num);
		}
	}

	private void DebugHurt(HitInfo info)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		if (!ConVar.Vis.damage)
		{
			return;
		}
		if (info.PointStart != info.PointEnd)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.arrow", 60, Color.cyan, info.PointStart, info.PointEnd, 0.1f);
			ConsoleNetwork.BroadcastToAllClients("ddraw.sphere", 60, Color.cyan, info.HitPositionWorld, 0.01f);
		}
		string text = "";
		for (int i = 0; i < info.damageTypes.types.Length; i++)
		{
			float num = info.damageTypes.types[i];
			if (num != 0f)
			{
				string[] obj = new string[5] { text, " ", null, null, null };
				DamageType damageType = (DamageType)i;
				obj[2] = damageType.ToString().PadRight(10);
				obj[3] = num.ToString("0.00");
				obj[4] = "\n";
				text = string.Concat(obj);
			}
		}
		string text2 = "<color=lightblue>Damage:</color>".PadRight(10) + info.damageTypes.Total().ToString("0.00") + "\n<color=lightblue>Health:</color>".PadRight(10) + health.ToString("0.00") + " / " + ((health - info.damageTypes.Total() <= 0f) ? "<color=red>" : "<color=green>") + (health - info.damageTypes.Total()).ToString("0.00") + "</color>" + "\n<color=lightblue>HitEnt:</color>".PadRight(10) + ((object)this)?.ToString() + "\n<color=lightblue>HitBone:</color>".PadRight(10) + info.boneName + "\n<color=lightblue>Attacker:</color>".PadRight(10) + ((object)info.Initiator)?.ToString() + "\n<color=lightblue>WeaponPrefab:</color>".PadRight(10) + ((object)info.WeaponPrefab)?.ToString() + "\n<color=lightblue>Damages:</color>\n" + text;
		ConsoleNetwork.BroadcastToAllClients("ddraw.text", 60, Color.white, info.HitPositionWorld, text2);
	}

	public void SetHealth(float hp)
	{
		if (health != hp)
		{
			health = hp;
			SendNetworkUpdate();
		}
	}

	public virtual void Heal(float amount)
	{
		LogEntry(RustLog.EntryType.Combat, 2, "healed {0}", amount);
		health = _health + amount;
		SendNetworkUpdate();
	}

	public virtual void OnDied(HitInfo info)
	{
		bool flag = true;
		if (base.Components != null)
		{
			for (int i = 0; i < base.Components.Count; i++)
			{
				if (!((Object)(object)base.Components[i] == (Object)null) && !base.Components[i].OnDied(info) && flag)
				{
					flag = false;
				}
			}
		}
		if (flag)
		{
			Kill(DestroyMode.Gib);
		}
	}

	public virtual void Die(HitInfo info = null)
	{
		if (IsDead())
		{
			return;
		}
		LogEntry(RustLog.EntryType.Combat, 2, "died");
		health = 0f;
		lifestate = LifeState.Dead;
		Interface.CallHook("OnEntityDeath", (object)this, (object)info);
		if (info != null && Object.op_Implicit((Object)(object)info.InitiatorPlayer))
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			if ((Object)(object)initiatorPlayer != (Object)null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)
			{
				initiatorPlayer.ProcessMissionEvent(BaseMission.MissionEventType.KILL_ENTITY, prefabID, 1f);
			}
		}
		TimeWarning val = TimeWarning.New("OnDied", 0);
		try
		{
			TryDropCorpse(info);
			OnDied(info);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void DieInstantly()
	{
		if (!IsDead())
		{
			LogEntry(RustLog.EntryType.Combat, 2, "died");
			health = 0f;
			lifestate = LifeState.Dead;
			TryDropCorpse(null);
			OnDied(null);
		}
	}

	public void UpdateSurroundings()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GetParentEntity();
		OBB val;
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 worldVelocity = baseEntity.GetWorldVelocity();
			if (((Vector3)(ref worldVelocity)).sqrMagnitude > 5f)
			{
				val = WorldSpaceBounds();
				StabilityEntity.UpdateSurroundingsQueue.NotifyNeighbours(((OBB)(ref val)).ToBounds());
				return;
			}
		}
		StabilityEntity.UpdateSurroundingsQueue updateSurroundingsQueue = StabilityEntity.updateSurroundingsQueue;
		val = WorldSpaceBounds();
		((ObjectWorkQueue<Bounds>)updateSurroundingsQueue).Add(((OBB)(ref val)).ToBounds());
	}

	public void MakeNoise(Vector3 position, ActionVolume loudness)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		LastNoisePosition = position;
		LastNoiseVolume = loudness;
		lastNoiseTime = Time.time;
	}

	public bool CanLastNoiseBeHeard(Vector3 listenPosition, float listenRange)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		if (listenRange <= 0f)
		{
			return false;
		}
		return Vector3.Distance(listenPosition, LastNoisePosition) <= listenRange;
	}
}


public enum LifeState
{
	Alive,
	Dead
}


using System;

[Serializable]
public enum Faction
{
	Default,
	Player,
	Bandit,
	Scientist,
	Horror
}


using System;
using UnityEngine;

[Serializable]
public struct Pickup
{
	public bool enabled;

	[ItemSelector]
	public ItemDefinition itemTarget;

	public int itemCount;

	[Tooltip("Should we set the condition of the item based on the health of the picked up entity")]
	public bool setConditionFromHealth;

	[Tooltip("How much to reduce the item condition when picking up")]
	public float subtractCondition;

	[Tooltip("Must have building access to pick up")]
	public bool requireBuildingPrivilege;

	[Tooltip("Must have hammer equipped to pick up")]
	public bool requireHammer;

	[Tooltip("Inventory Must be empty (if applicable) to be picked up")]
	public bool requireEmptyInv;

	[Tooltip("If set, pickup will take this long in seconds")]
	public float overridePickupTime;
}


public static class PickupErrors
{
	public static readonly Phrase ItemMustBeEmpty = new Phrase("pickuperror_itemmustbeempty", "{0} must be empty");

	public static readonly Phrase ItemInventoryMustBeEmpty = new Phrase("pickuperror_iteminventorymustbeempty", "{0} inventory must be empty");

	public static readonly Phrase ItemIsBeingUsed = new Phrase("pickuperrors_itemisbeingused", "{0} is being used");

	public static readonly Phrase ItemHasCloser = new Phrase("pickuperrors_itemhascloser", "{0} has closer");

	public static readonly Phrase ItemHasLock = new Phrase("pickuperrors_itemhaslock", "{0} has lock");

	public static readonly Phrase ItemHasStorageAdaptor = new Phrase("pickuperrors_itemhasstorageadaptor", "{0} has storage adaptor");

	public static readonly Phrase ItemHasStorageMonitor = new Phrase("pickuperrors_itemhasstorageadaptor", "{0} has storage monitor");

	public static readonly Phrase ItemHasDecoration = new Phrase("pickuperrors_itemhasdecoration", "{0} has decoration");

	public static readonly Phrase ItemHasAttachment = new Phrase("pickuperrors_itemhasattachment", "{0} has attachment");

	public static readonly Phrase ItemIsOnline = new Phrase("pickuperrors_itemisonline", "{0} is online");

	public static readonly Phrase ItemIsArmed = new Phrase("pickuperrors_itemisarmed", "{0} is armed");

	public static readonly Phrase ItemIsOccupied = new Phrase("pickuperror_itemisoccupied", "{0} is occupied");

	public static Phrase FormattedPhrase(Phrase format, Phrase arg0)
	{
		return Phrase.op_Implicit(string.Format(format.translated, arg0.translated));
	}
}


using System;

[Serializable]
public struct Repair
{
	public bool enabled;

	[ItemSelector]
	public ItemDefinition itemTarget;

	[ItemSelector]
	public ItemDefinition ignoreForRepair;

	public GameObjectRef repairEffect;

	public GameObjectRef repairFullEffect;

	public GameObjectRef repairFailedEffect;
}


public enum ActionVolume
{
	Quiet,
	Normal,
	Loud
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;

public class BaseDiggableEntity : BaseCombatEntity
{
	public bool RequiresShovel;

	public Vector3 DropOffset;

	public Vector3 DropVelocity;

	public int RequiredDigCount = 3;

	public bool DestroyOnDug = true;

	[Header("Loot")]
	public List<DiggableEntityLoot> LootLists = new List<DiggableEntityLoot>();

	public int digsRemaining;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseDiggableEntity.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		digsRemaining = RequiredDigCount;
		_maxHealth = RequiredDigCount;
	}

	public override void Hurt(HitInfo info)
	{
		if (!((Object)(object)info.InitiatorPlayer == (Object)null) && (!RequiresShovel || (!((Object)(object)info.Weapon == (Object)null) && info.Weapon is Shovel)) && info.damageTypes.IsMeleeType())
		{
			Dig(info.InitiatorPlayer);
		}
	}

	public virtual void Dig(BasePlayer player)
	{
		if (Interface.CallHook("OnPlayerDig", (object)player, (object)this) != null)
		{
			return;
		}
		if (digsRemaining == RequiredDigCount)
		{
			OnFirstDig(player);
		}
		ClientRPC(RpcTarget.NetworkGroup("RPC_OnDig"), RequiredDigCount - digsRemaining, RequiredDigCount);
		digsRemaining--;
		base.health = digsRemaining;
		SendNetworkUpdate();
		OnSingleDig(player);
		if (digsRemaining <= 0)
		{
			OnFullyDug(player);
			if (DestroyOnDug)
			{
				Kill();
			}
		}
	}

	public virtual void OnFirstDig(BasePlayer player)
	{
	}

	public virtual void OnSingleDig(BasePlayer player)
	{
	}

	public virtual void OnFullyDug(BasePlayer player)
	{
		SpawnItem(player);
	}

	public BaseEntity SpawnItem(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		DiggableEntityLoot.ItemEntry? item = GetItem(((Component)this).transform.position);
		if (!item.HasValue || !item.HasValue)
		{
			return null;
		}
		Item item2 = ItemManager.Create(item.Value.Item, Random.Range(item.Value.Min, item.Value.Max + 1), item.Value.Skin);
		if (item.Value.Owner.HasValue)
		{
			ItemOwnershipShare value = item.Value.Owner.Value;
			item2.AddItemOwnership(value.username, value.reason, value.amount);
		}
		item2.AddItemOwnership(player, ItemOwnershipPhrases.MetalDetector);
		if (item.Value.Condition.HasValue)
		{
			item2.condition = item.Value.Condition.Value;
		}
		DroppedItem droppedItem = null;
		if (item2 != null)
		{
			if (item2.hasCondition && !item.Value.Condition.HasValue)
			{
				item2.condition = Random.Range(item2.info.condition.foundCondition.fractionMin, item2.info.condition.foundCondition.fractionMax) * item2.info.condition.max;
			}
			droppedItem = item2.Drop(((Component)this).transform.position + DropOffset, DropVelocity) as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.NeverCombine = true;
				droppedItem.SetAngularVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(-1f, 1f), Random.Range(-1f, 1f)) * 720f);
			}
			if (item.Value.UID.HasValue)
			{
				BuriedItems.Instance.UnregisterItem(item.Value.UID.Value);
			}
		}
		return droppedItem;
	}

	private DiggableEntityLoot.ItemEntry? GetItem(Vector3 digWorldPos)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		if (LootLists == null)
		{
			return null;
		}
		List<DiggableEntityLoot.ItemEntry> list = Pool.Get<List<DiggableEntityLoot.ItemEntry>>();
		list.Clear();
		foreach (DiggableEntityLoot lootList in LootLists)
		{
			if (lootList.VerifyLootListForWorldPosition(digWorldPos))
			{
				list.AddRange(lootList.GetItems());
			}
		}
		if (Object.op_Implicit((Object)(object)BuriedItems.Instance))
		{
			BuriedItems.Instance.AddItems(list, digWorldPos);
		}
		DiggableEntityLoot.ItemEntry? result = null;
		if (list.Count != 0)
		{
			int num = list.Sum((DiggableEntityLoot.ItemEntry x) => x.Weight);
			int num2 = Random.Range(0, num);
			for (int i = 0; i < list.Count; i++)
			{
				result = list[i];
				if (result.HasValue)
				{
					num -= result.Value.Weight;
					if (num2 >= num)
					{
						break;
					}
				}
			}
		}
		Pool.FreeUnmanaged<DiggableEntityLoot.ItemEntry>(ref list);
		return result;
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Workshop;
using Spatial;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.SceneManagement;

public class BaseEntity : BaseNetworkable, IOnParentSpawning, IPrefabPreProcess
{
	public class Menu : Attribute
	{
		[Serializable]
		public struct Option
		{
			public Phrase name;

			public Phrase description;

			public Sprite icon;

			public int order;

			public bool usableWhileWounded;
		}

		public class Description : Attribute
		{
			public string token;

			public string english;

			public Description(string t, string e)
			{
				token = t;
				english = e;
			}
		}

		public class Icon : Attribute
		{
			public string icon;

			public Icon(string i)
			{
				icon = i;
			}
		}

		public class ShowIf : Attribute
		{
			public string functionName;

			public ShowIf(string testFunc)
			{
				functionName = testFunc;
			}
		}

		public class DisabledIf : Attribute
		{
			public string functionName;

			public DisabledIf(string testFunc)
			{
				functionName = testFunc;
			}
		}

		public class Priority : Attribute
		{
			public string functionName;

			public Priority(string priorityFunc)
			{
				functionName = priorityFunc;
			}
		}

		public class UsableWhileWounded : Attribute
		{
		}

		public string TitleToken;

		public string TitleEnglish;

		public string UseVariable;

		public int Order;

		public string ProxyFunction;

		public float Time;

		public string OnStart;

		public string OnProgress;

		public bool LongUseOnly;

		public bool PrioritizeIfNotWhitelisted;

		public bool PrioritizeIfUnlocked;

		public Menu()
		{
		}

		public Menu(string menuTitleToken, string menuTitleEnglish)
		{
			TitleToken = menuTitleToken;
			TitleEnglish = menuTitleEnglish;
		}
	}

	[Serializable]
	public struct MovementModify
	{
		public float drag;
	}

	public enum GiveItemReason
	{
		Generic,
		ResourceHarvested,
		PickedUp,
		Crafted
	}

	[Flags]
	public enum Flags
	{
		Placeholder = 1,
		On = 2,
		OnFire = 4,
		Open = 8,
		Locked = 0x10,
		Debugging = 0x20,
		Disabled = 0x40,
		Reserved1 = 0x80,
		Reserved2 = 0x100,
		Reserved3 = 0x200,
		Reserved4 = 0x400,
		Reserved5 = 0x800,
		Broken = 0x1000,
		Busy = 0x2000,
		Reserved6 = 0x4000,
		Reserved7 = 0x8000,
		Reserved8 = 0x10000,
		Reserved9 = 0x20000,
		Reserved10 = 0x40000,
		Reserved11 = 0x80000,
		InUse = 0x100000,
		Reserved12 = 0x200000,
		Reserved13 = 0x400000,
		Unused23 = 0x800000,
		Protected = 0x1000000,
		Transferring = 0x2000000,
		Reserved14 = 0x4000000,
		Reserved15 = 0x8000000,
		Reserved16 = 0x10000000,
		Reserved17 = 0x20000000,
		Reserved18 = 0x40000000,
		Reserved19 = int.MinValue
	}

	private readonly struct QueuedFileRequest : IEquatable<QueuedFileRequest>
	{
		public readonly BaseEntity Entity;

		public readonly FileStorage.Type Type;

		public readonly uint Part;

		public readonly uint Crc;

		public readonly uint ResponseFunction;

		public readonly bool? RespondIfNotFound;

		public QueuedFileRequest(BaseEntity entity, FileStorage.Type type, uint part, uint crc, uint responseFunction, bool? respondIfNotFound)
		{
			Entity = entity;
			Type = type;
			Part = part;
			Crc = crc;
			ResponseFunction = responseFunction;
			RespondIfNotFound = respondIfNotFound;
		}

		public bool Equals(QueuedFileRequest other)
		{
			if (object.Equals(Entity, other.Entity) && Type == other.Type && Part == other.Part && Crc == other.Crc && ResponseFunction == other.ResponseFunction)
			{
				return RespondIfNotFound == other.RespondIfNotFound;
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is QueuedFileRequest other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (int)(((((((((uint)((((Object)(object)Entity != (Object)null) ? ((object)Entity).GetHashCode() : 0) * 397) ^ (uint)Type) * 397) ^ Part) * 397) ^ Crc) * 397) ^ ResponseFunction) * 397) ^ RespondIfNotFound.GetHashCode();
		}
	}

	private readonly struct PendingFileRequest : IEquatable<PendingFileRequest>
	{
		public readonly FileStorage.Type Type;

		public readonly uint NumId;

		public readonly uint Crc;

		public readonly IServerFileReceiver Receiver;

		public readonly float Time;

		public PendingFileRequest(FileStorage.Type type, uint numId, uint crc, IServerFileReceiver receiver)
		{
			Type = type;
			NumId = numId;
			Crc = crc;
			Receiver = receiver;
			Time = Time.realtimeSinceStartup;
		}

		public bool Equals(PendingFileRequest other)
		{
			if (Type == other.Type && NumId == other.NumId && Crc == other.Crc)
			{
				return object.Equals(Receiver, other.Receiver);
			}
			return false;
		}

		public override bool Equals(object obj)
		{
			if (obj is PendingFileRequest other)
			{
				return Equals(other);
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (int)(((((uint)((int)Type * 397) ^ NumId) * 397) ^ Crc) * 397) ^ ((Receiver != null) ? Receiver.GetHashCode() : 0);
		}
	}

	public static class Query
	{
		public enum DistanceCheckType
		{
			None,
			OnlyCenter,
			Bounds
		}

		public class EntityTree
		{
			public Grid<BaseEntity> Grid;

			public Grid<BasePlayer> PlayerGrid;

			public Grid<BaseEntity> BrainGrid;

			public EntityTree(float worldSize)
			{
				Grid = new Grid<BaseEntity>(32, worldSize);
				PlayerGrid = new Grid<BasePlayer>(32, worldSize);
				BrainGrid = new Grid<BaseEntity>(32, worldSize);
			}

			public void Add(BaseEntity ent)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				Vector3 position = ((Component)ent).transform.position;
				Grid.Add(ent, position.x, position.z);
			}

			public void AddPlayer(BasePlayer player)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				Vector3 position = ((Component)player).transform.position;
				PlayerGrid.Add(player, position.x, position.z);
			}

			public void AddBrain(BaseEntity entity)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				Vector3 position = ((Component)entity).transform.position;
				BrainGrid.Add(entity, position.x, position.z);
			}

			public void Remove(BaseEntity ent, bool isPlayer = false)
			{
				Grid.Remove(ent);
				if (isPlayer)
				{
					BasePlayer basePlayer = ent as BasePlayer;
					if ((Object)(object)basePlayer != (Object)null)
					{
						PlayerGrid.Remove(basePlayer);
					}
				}
			}

			public void RemovePlayer(BasePlayer player)
			{
				PlayerGrid.Remove(player);
			}

			public void RemoveBrain(BaseEntity entity)
			{
				if (!((Object)(object)entity == (Object)null))
				{
					BrainGrid.Remove(entity);
				}
			}

			public void Move(BaseEntity ent)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				Vector3 position = ((Component)ent).transform.position;
				Grid.Move(ent, position.x, position.z);
				BasePlayer basePlayer = ent as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null)
				{
					MovePlayer(basePlayer);
				}
				if (ent.HasBrain)
				{
					MoveBrain(ent);
				}
			}

			public void MovePlayer(BasePlayer player)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				Vector3 position = ((Component)player).transform.position;
				PlayerGrid.Move(player, position.x, position.z);
			}

			public void MoveBrain(BaseEntity entity)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0013: Unknown result type (might be due to invalid IL or missing references)
				//IL_0019: Unknown result type (might be due to invalid IL or missing references)
				Vector3 position = ((Component)entity).transform.position;
				BrainGrid.Move(entity, position.x, position.z);
			}

			public void GetInSphere<T>(Vector3 position, float distance, List<T> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter) where T : BaseEntity
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("GetInSphereList", 0);
				try
				{
					Grid.Query<T>(position.x, position.z, distance, results);
					if (distanceCheckType != 0)
					{
						NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}

			public int GetInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				int broadCount = Grid.Query(position.x, position.z, distance, results, filter);
				return NarrowPhaseReduce(position, distance, results, broadCount);
			}

			public int GetInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				return Grid.Query(position.x, position.z, distance, results, filter);
			}

			public void GetPlayersInSphere(Vector3 position, float distance, List<BasePlayer> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter, bool includeHumanoidNpcs = false)
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("GetPlayersInSphereList", 0);
				try
				{
					PlayerGrid.Query<BasePlayer>(position.x, position.z, distance, results);
					if (!includeHumanoidNpcs)
					{
						for (int num = results.Count - 1; num >= 0; num--)
						{
							if (results[num].IsNpc)
							{
								results.RemoveAt(num);
							}
						}
					}
					if (distanceCheckType != 0)
					{
						NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}

			public int GetPlayersInSphere(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				int broadCount = PlayerGrid.Query(position.x, position.z, distance, results, filter);
				return NarrowPhaseReduce(position, distance, results, broadCount);
			}

			public int GetPlayersInSphereFast(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				return PlayerGrid.Query(position.x, position.z, distance, results, filter);
			}

			public void GetBrainsInSphere<T>(Vector3 position, float distance, List<T> results, bool filterPastDistance = true) where T : BaseEntity
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				//IL_0029: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("GetBrainsInSphereList", 0);
				try
				{
					BrainGrid.Query<T>(position.x, position.z, distance, results);
					if (filterPastDistance)
					{
						NarrowPhaseReduce(position, distance, results);
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}

			public int GetBrainsInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				int broadCount = BrainGrid.Query(position.x, position.z, distance, results, filter);
				return NarrowPhaseReduce(position, distance, results, broadCount);
			}

			public int GetBrainsInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
			{
				//IL_0006: Unknown result type (might be due to invalid IL or missing references)
				//IL_000c: Unknown result type (might be due to invalid IL or missing references)
				return BrainGrid.Query(position.x, position.z, distance, results, filter);
			}

			public void GetPlayersAndBrainsInSphere(Vector3 position, float distance, List<BaseEntity> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter)
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0018: Unknown result type (might be due to invalid IL or missing references)
				//IL_002b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0031: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("GetPlayersAndBrainsInSphereList", 0);
				try
				{
					PlayerGrid.Query<BaseEntity>(position.x, position.z, distance, results);
					BrainGrid.Query<BaseEntity>(position.x, position.z, distance, results);
					if (distanceCheckType != 0)
					{
						NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}

			private int NarrowPhaseReduce<T>(Vector3 position, float radius, T[] results, int broadCount) where T : BaseEntity
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				//IL_0028: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_002d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				//IL_0033: Unknown result type (might be due to invalid IL or missing references)
				//IL_0038: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("NarrowPhaseReduce", 0);
				try
				{
					int num = broadCount;
					float num2 = radius * radius;
					for (int i = 0; i < num; i++)
					{
						OBB val2 = results[i].WorldSpaceBounds();
						Vector3 val3 = ((OBB)(ref val2)).ClosestPoint(position) - position;
						if (((Vector3)(ref val3)).sqrMagnitude > num2)
						{
							results[i] = results[num - 1];
							num--;
							i--;
						}
					}
					return num;
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}

			private static void NarrowPhaseReduce<T>(Vector3 position, float radius, List<T> results, bool onlyConsiderCenter = true) where T : BaseEntity
			{
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0031: Unknown result type (might be due to invalid IL or missing references)
				//IL_0035: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_004d: Unknown result type (might be due to invalid IL or missing references)
				//IL_004e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0053: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("NarrowPhaseReduceList", 0);
				try
				{
					float num = radius * radius;
					for (int num2 = results.Count - 1; num2 >= 0; num2--)
					{
						T val2 = results[num2];
						Vector3 val4;
						if (!onlyConsiderCenter)
						{
							OBB val3 = val2.WorldSpaceBounds();
							val4 = ((OBB)(ref val3)).ClosestPoint(position);
						}
						else
						{
							val4 = ((Component)val2).transform.position;
						}
						Vector3 val5 = val4 - position;
						if (((Vector3)(ref val5)).sqrMagnitude > num)
						{
							results.RemoveAt(num2);
						}
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}

			private static bool IsEntityInRadius<T>(Vector3 position, float radiusSq, T entity) where T : BaseEntity
			{
				//IL_0012: Unknown result type (might be due to invalid IL or missing references)
				//IL_0017: Unknown result type (might be due to invalid IL or missing references)
				//IL_001a: Unknown result type (might be due to invalid IL or missing references)
				//IL_001b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0020: Unknown result type (might be due to invalid IL or missing references)
				//IL_0021: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				TimeWarning val = TimeWarning.New("IsEntityInRadius", 0);
				try
				{
					OBB val2 = entity.WorldSpaceBounds();
					Vector3 val3 = ((OBB)(ref val2)).ClosestPoint(position) - position;
					return ((Vector3)(ref val3)).sqrMagnitude < radiusSq;
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
		}

		public static EntityTree Server;
	}

	public class RPC_Shared : Attribute
	{
	}

	public struct RPCMessage
	{
		public Connection connection;

		public BasePlayer player;

		public NetRead read;
	}

	public class RPC_Server : RPC_Shared
	{
		public abstract class Conditional : Attribute
		{
			public virtual string GetArgs()
			{
				return null;
			}
		}

		public class MaxDistance : Conditional
		{
			private float maximumDistance;

			public bool CheckParent { get; set; }

			public MaxDistance(float maxDist)
			{
				maximumDistance = maxDist;
			}

			public override string GetArgs()
			{
				return maximumDistance.ToString("0.00f") + (CheckParent ? ", true" : "");
			}

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)
			{
				//IL_004d: Unknown result type (might be due to invalid IL or missing references)
				//IL_007d: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityDistanceCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)maximumDistance, (object)checkParent);
				if (obj is bool)
				{
					return (bool)obj;
				}
				bool flag = ent.Distance(player.eyes.position) <= maximumDistance;
				if (checkParent && !flag)
				{
					BaseEntity parentEntity = ent.GetParentEntity();
					flag = (Object)(object)parentEntity != (Object)null && parentEntity.Distance(player.eyes.position) <= maximumDistance;
				}
				return flag;
			}
		}

		public class IsVisible : Conditional
		{
			private float maximumDistance;

			public IsVisible(float maxDist)
			{
				maximumDistance = maxDist;
			}

			public override string GetArgs()
			{
				return maximumDistance.ToString("0.00f");
			}

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
			{
				//IL_0045: Unknown result type (might be due to invalid IL or missing references)
				//IL_0050: Unknown result type (might be due to invalid IL or missing references)
				//IL_0069: Unknown result type (might be due to invalid IL or missing references)
				//IL_0083: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityVisibilityCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)maximumDistance);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))
				{
					if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
					{
						return ent.IsVisible(player.eyes.position, maximumDistance);
					}
					return true;
				}
				return false;
			}
		}

		public class FromOwner : Conditional
		{
			private bool includeMounted;

			public FromOwner(bool includeMounted = false)
			{
				this.includeMounted = includeMounted;
			}

			public override string GetArgs()
			{
				return includeMounted.ToString().ToLower();
			}

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, bool includeMounted)
			{
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0065: Unknown result type (might be due to invalid IL or missing references)
				//IL_0079: Unknown result type (might be due to invalid IL or missing references)
				//IL_0084: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
				//IL_011f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0130: Unknown result type (might be due to invalid IL or missing references)
				//IL_0135: Unknown result type (might be due to invalid IL or missing references)
				//IL_0150: Unknown result type (might be due to invalid IL or missing references)
				//IL_0155: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityFromOwnerCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)includeMounted);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					BaseEntity parentEntity = ent.GetParentEntity();
					if ((Object)(object)parentEntity != (Object)null && parentEntity.parentEntity.uid == player.net.ID)
					{
						return true;
					}
					if (includeMounted)
					{
						BaseMountable baseMountable = ent as BaseMountable;
						if ((Object)(object)baseMountable == (Object)null)
						{
							baseMountable = ent.parentEntity.Get(serverside: true) as BaseMountable;
						}
						if ((Object)(object)baseMountable != (Object)null)
						{
							NetworkableId? val = baseMountable.GetMounted()?.net?.ID;
							NetworkableId iD = player.net.ID;
							if (val.HasValue && (!val.HasValue || val.GetValueOrDefault() == iD))
							{
								return true;
							}
						}
					}
					return false;
				}
				return true;
			}
		}

		public class IsActiveItem : Conditional
		{
			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
			{
				//IL_0050: Unknown result type (might be due to invalid IL or missing references)
				//IL_005b: Unknown result type (might be due to invalid IL or missing references)
				//IL_006f: Unknown result type (might be due to invalid IL or missing references)
				//IL_007a: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
				{
					return false;
				}
				if (ent.net == null || player.net == null)
				{
					return false;
				}
				object obj = Interface.CallHook("OnEntityActiveCheck", (object)ent, (object)player, (object)id, (object)debugName);
				if (obj is bool)
				{
					return (bool)obj;
				}
				if (ent.net.ID == player.net.ID)
				{
					return true;
				}
				if (ent.parentEntity.uid != player.net.ID)
				{
					return false;
				}
				Item activeItem = player.GetActiveItem();
				if (activeItem == null)
				{
					return false;
				}
				if ((Object)(object)activeItem.GetHeldEntity() != (Object)(object)ent)
				{
					return false;
				}
				return true;
			}
		}

		public class CallsPerSecond : Conditional
		{
			private ulong callsPerSecond;

			public CallsPerSecond(ulong limit)
			{
				callsPerSecond = limit;
			}

			public override string GetArgs()
			{
				return callsPerSecond.ToString();
			}

			public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, ulong callsPerSecond)
			{
				if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
				{
					return false;
				}
				return player.rpcHistory.TryIncrement(id, callsPerSecond);
			}
		}
	}

	public enum Signal
	{
		Attack,
		Alt_Attack,
		DryFire,
		Reload,
		Deploy,
		Flinch_Head,
		Flinch_Chest,
		Flinch_Stomach,
		Flinch_RearHead,
		Flinch_RearTorso,
		Throw,
		Relax,
		Gesture,
		PhysImpact,
		Eat,
		Startled,
		Admire
	}

	public enum Slot
	{
		Lock,
		FireMod,
		UpperModifier,
		MiddleModifier,
		LowerModifier,
		CenterDecoration,
		LowerCenterDecoration,
		StorageMonitor,
		Count
	}

	[Flags]
	public enum TraitFlag
	{
		None = 0,
		Alive = 1,
		Animal = 2,
		Human = 4,
		Interesting = 8,
		Food = 0x10,
		Meat = 0x20,
		Water = 0x20
	}

	public static class Util
	{
		public static BaseEntity[] FindTargets(string strFilter, bool onlyPlayers)
		{
			return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
				{
					if (x is BasePlayer)
					{
						BasePlayer basePlayer = x as BasePlayer;
						if (string.IsNullOrEmpty(strFilter))
						{
							return true;
						}
						if (strFilter == "!alive" && basePlayer.IsAlive())
						{
							return true;
						}
						if (strFilter == "!sleeping" && basePlayer.IsSleeping())
						{
							return true;
						}
						if (strFilter[0] != '!' && !StringEx.Contains(basePlayer.displayName, strFilter, CompareOptions.IgnoreCase) && !basePlayer.UserIDString.Contains(strFilter))
						{
							return false;
						}
						return true;
					}
					if (onlyPlayers)
					{
						return false;
					}
					if (string.IsNullOrEmpty(strFilter))
					{
						return false;
					}
					return x.ShortPrefabName.Contains(strFilter) ? true : false;
				})
				select x as BaseEntity).ToArray();
		}

		public static BaseEntity[] FindTargetsOwnedBy(ulong ownedBy, string strFilter)
		{
			bool hasFilter = !string.IsNullOrEmpty(strFilter);
			return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
				{
					if (x is BaseEntity baseEntity)
					{
						if (baseEntity.OwnerID != ownedBy)
						{
							return false;
						}
						if (!hasFilter || baseEntity.ShortPrefabName.Contains(strFilter))
						{
							return true;
						}
					}
					return false;
				})
				select x as BaseEntity).ToArray();
		}

		public static BaseEntity[] FindTargetsAuthedTo(ulong authId, string strFilter)
		{
			bool hasFilter = !string.IsNullOrEmpty(strFilter);
			return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
				{
					if (x is BuildingPrivlidge buildingPrivlidge)
					{
						if (!buildingPrivlidge.IsAuthed(authId))
						{
							return false;
						}
						if (!hasFilter || x.ShortPrefabName.Contains(strFilter))
						{
							return true;
						}
					}
					else if (x is AutoTurret autoTurret)
					{
						if (!autoTurret.IsAuthed(authId))
						{
							return false;
						}
						if (!hasFilter || x.ShortPrefabName.Contains(strFilter))
						{
							return true;
						}
					}
					else if (x is CodeLock codeLock)
					{
						if (!codeLock.whitelistPlayers.Contains(authId))
						{
							return false;
						}
						if (!hasFilter || x.ShortPrefabName.Contains(strFilter))
						{
							return true;
						}
					}
					return false;
				})
				select x as BaseEntity).ToArray();
		}

		public static T[] FindAll<T>() where T : BaseEntity
		{
			return BaseNetworkable.serverEntities.OfType<T>().ToArray();
		}
	}

	[Header("BaseEntity")]
	public Bounds bounds;

	public GameObjectRef impactEffect;

	public bool enableSaving = true;

	public bool syncPosition;

	public Model model;

	public Flags flags;

	[NonSerialized]
	public uint parentBone;

	[NonSerialized]
	public ulong skinID;

	private List<EntityComponentBase> _components;

	[HideInInspector]
	public bool HasBrain;

	private float nextHeightCheckTime;

	private bool cachedUnderground;

	[NonSerialized]
	public string _name;

	private static Queue<BaseEntity> globalBroadcastQueue = new Queue<BaseEntity>();

	private static uint globalBroadcastProtocol = 0u;

	private uint broadcastProtocol;

	public List<EntityLink> links = new List<EntityLink>();

	private bool linkedToNeighbours;

	private TimeUntil _transferProtectionRemaining;

	private Action _disableTransferProtectionAction;

	private float cachedBuildingPrivilegeTime;

	private BuildingPrivlidge cachedBuildingPrivilege;

	public const string RpcClientDeprecationNotice = "Use ClientRPC( RpcTarget ) overloads";

	public Spawnable _spawnable;

	protected static ExactArrayPool<byte> _autosaveBufferPool = new ExactArrayPool<byte>();

	protected byte[] _autosaveBuffer;

	public static HashSet<BaseEntity> saveList = new HashSet<BaseEntity>();

	[NonSerialized]
	public BaseEntity creatorEntity;

	private bool couldSaveOriginally;

	public int ticksSinceStopped;

	public bool isCallingUpdateNetworkGroup;

	private EntityRef[] entitySlots = new EntityRef[8];

	private const float SYNC_VAR_QUEUE_UPDATE_INTERVAL = 0.0333f;

	private const int SYNC_VAR_QUEUE_MAX_SIZE = 32;

	private uint _serverSyncVarQueue;

	private Action _sendPackedSyncVarQueueAction;

	public List<TriggerBase> triggers;

	protected bool isVisible = true;

	protected bool isAnimatorVisible = true;

	protected bool isShadowVisible = true;

	protected OccludeeSphere localOccludee = new OccludeeSphere(-1);

	public virtual float RealisticMass => 100f;

	public List<EntityComponentBase> Components
	{
		get
		{
			if (_components == null)
			{
				_components = new List<EntityComponentBase>();
				((Component)this).GetComponentsInChildren<EntityComponentBase>(true, _components);
			}
			return _components;
		}
	}

	public virtual bool IsNpc => false;

	public ulong OwnerID { get; set; }

	protected float TransferProtectionRemaining => TimeUntil.op_Implicit(_transferProtectionRemaining);

	protected Action DisableTransferProtectionAction => _disableTransferProtectionAction ?? (_disableTransferProtectionAction = DisableTransferProtection);

	public virtual bool ShouldTransferAssociatedFiles => false;

	public virtual float PositionTickRate => 0.1f;

	public virtual bool PositionTickFixedTime => false;

	public virtual Vector3 ServerPosition
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)this).transform.localPosition;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!(((Component)this).transform.localPosition == value))
			{
				((Component)this).transform.localPosition = value;
				((Component)this).transform.hasChanged = true;
			}
		}
	}

	public virtual Quaternion ServerRotation
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return ((Component)this).transform.localRotation;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			if (!(((Component)this).transform.localRotation == value))
			{
				((Component)this).transform.localRotation = value;
				((Component)this).transform.hasChanged = true;
			}
		}
	}

	public float radiationLevel
	{
		get
		{
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			if (triggers == null)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerRadiation triggerRadiation = triggers[i] as TriggerRadiation;
				if (!((Object)(object)triggerRadiation == (Object)null))
				{
					Vector3 val = GetNetworkPosition();
					BaseEntity baseEntity = GetParentEntity();
					if ((Object)(object)baseEntity != (Object)null)
					{
						val = ((Component)baseEntity).transform.TransformPoint(val);
					}
					num = Mathf.Max(num, triggerRadiation.GetRadiation(val, RadiationProtection()));
				}
			}
			return num;
		}
	}

	public float currentTemperature
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			float num = Climate.GetTemperature(((Component)this).transform.position);
			if (triggers == null)
			{
				return num;
			}
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerTemperature triggerTemperature = triggers[i] as TriggerTemperature;
				if (!((Object)(object)triggerTemperature == (Object)null))
				{
					num = triggerTemperature.WorkoutTemperature(((Component)this).transform.position, num);
				}
			}
			return num;
		}
	}

	public float currentEnvironmentalWetness
	{
		get
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			if (triggers == null)
			{
				return 0f;
			}
			float num = 0f;
			Vector3 networkPosition = GetNetworkPosition();
			foreach (TriggerBase trigger in triggers)
			{
				if (trigger is TriggerWetness triggerWetness)
				{
					num += triggerWetness.WorkoutWetness(networkPosition);
				}
			}
			return Mathf.Clamp01(num);
		}
	}

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public virtual TraitFlag Traits => TraitFlag.None;

	public float Weight { get; protected set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 1552640099 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - BroadcastSignalFromClient "));
				}
				TimeWarning val2 = TimeWarning.New("BroadcastSignalFromClient", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(1552640099u, "BroadcastSignalFromClient", this, player, includeMounted: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							BroadcastSignalFromClient(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in BroadcastSignalFromClient");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3645147041u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_RequestFile "));
				}
				TimeWarning val2 = TimeWarning.New("SV_RequestFile", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						SV_RequestFile(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in SV_RequestFile");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		throw new NotImplementedException();
	}

	protected void ReceiveCollisionMessages(bool b)
	{
		if (b)
		{
			TransformEx.GetOrAddComponent<EntityCollisionMessage>(((Component)this).gameObject.transform);
		}
		else
		{
			((Component)this).gameObject.transform.RemoveComponent<EntityCollisionMessage>();
		}
	}

	public virtual BasePlayer ToPlayer()
	{
		return null;
	}

	public override void InitShared()
	{
		base.InitShared();
		InitEntityLinks();
		if (Components == null)
		{
			return;
		}
		for (int i = 0; i < Components.Count; i++)
		{
			if (!((Object)(object)Components[i] == (Object)null))
			{
				Components[i].InitShared();
			}
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		FreeEntityLinks();
		StopSyncVars();
		if (_autosaveBuffer != null)
		{
			_autosaveBufferPool.Return(_autosaveBuffer);
		}
		if (Components == null)
		{
			return;
		}
		for (int i = 0; i < Components.Count; i++)
		{
			if (!((Object)(object)Components[i] == (Object)null))
			{
				Components[i].DestroyShared();
			}
		}
	}

	public override void ResetState()
	{
		base.ResetState();
		parentBone = 0u;
		OwnerID = 0uL;
		flags = (Flags)0;
		parentEntity = default(EntityRef);
		ResetSyncVars();
		if (base.isServer)
		{
			_spawnable = null;
		}
		if (Components == null)
		{
			return;
		}
		for (int i = 0; i < Components.Count; i++)
		{
			if (!((Object)(object)Components[i] == (Object)null))
			{
				Components[i].ResetState();
			}
		}
	}

	public virtual float InheritedVelocityScale()
	{
		return 0f;
	}

	public virtual bool InheritedVelocityDirection()
	{
		return true;
	}

	public virtual Vector3 GetInheritedProjectileVelocity(Vector3 direction)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = parentEntity.Get(base.isServer);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return Vector3.zero;
		}
		if (baseEntity.InheritedVelocityDirection())
		{
			return GetParentVelocity() * baseEntity.InheritedVelocityScale();
		}
		return Mathf.Max(Vector3.Dot(GetParentVelocity() * baseEntity.InheritedVelocityScale(), direction), 0f) * direction;
	}

	public virtual Vector3 GetInheritedThrowVelocity(Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetParentVelocity();
	}

	public virtual Vector3 GetInheritedDropVelocity()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = parentEntity.Get(base.isServer);
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return Vector3.zero;
		}
		return baseEntity.GetWorldVelocity();
	}

	public Vector3 GetParentVelocity()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = parentEntity.Get(base.isServer);
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return Vector3.zero;
		}
		return baseEntity.GetWorldVelocity() + (baseEntity.GetAngularVelocity() * ((Component)this).transform.localPosition - ((Component)this).transform.localPosition);
	}

	public Vector3 GetWorldVelocity()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = parentEntity.Get(base.isServer);
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return GetLocalVelocity();
		}
		return baseEntity.GetWorldVelocity() + (baseEntity.GetAngularVelocity() * ((Component)this).transform.localPosition - ((Component)this).transform.localPosition) + ((Component)baseEntity).transform.TransformDirection(GetLocalVelocity());
	}

	public Vector3 GetLocalVelocity()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			return GetLocalVelocityServer();
		}
		return Vector3.zero;
	}

	public Quaternion GetAngularVelocity()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			return GetAngularVelocityServer();
		}
		return Quaternion.identity;
	}

	public virtual OBB WorldSpaceBounds()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, bounds);
	}

	public Vector3 PivotPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public Vector3 CenterPoint()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return WorldSpaceBounds().position;
	}

	public Vector3 ClosestPoint(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		OBB val = WorldSpaceBounds();
		return ((OBB)(ref val)).ClosestPoint(position);
	}

	public virtual Vector3 TriggerPoint()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return CenterPoint();
	}

	public float Distance(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ClosestPoint(position) - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ClosestPoint(position) - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public float Distance(BaseEntity other)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Distance(((Component)other).transform.position);
	}

	public float SqrDistance(BaseEntity other)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return SqrDistance(((Component)other).transform.position);
	}

	public float Distance2D(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Magnitude2D(ClosestPoint(position) - position);
	}

	public float SqrDistance2D(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.SqrMagnitude2D(ClosestPoint(position) - position);
	}

	public float Distance2D(BaseEntity other)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Distance(((Component)other).transform.position);
	}

	public float SqrDistance2D(BaseEntity other)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return SqrDistance(((Component)other).transform.position);
	}

	public bool IsVisible(Ray ray, int layerMask, float maxDistance)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).origin))
		{
			return false;
		}
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).direction))
		{
			return false;
		}
		if (((Ray)(ref ray)).direction == Vector3.zero)
		{
			return false;
		}
		OBB val = WorldSpaceBounds();
		RaycastHit val2 = default(RaycastHit);
		if (!((OBB)(ref val)).Trace(ray, ref val2, maxDistance))
		{
			return false;
		}
		if (GamePhysics.Trace(ray, 0f, out var hitInfo, maxDistance, layerMask, (QueryTriggerInteraction)0))
		{
			BaseEntity entity = hitInfo.GetEntity();
			if ((Object)(object)entity == (Object)(object)this)
			{
				return true;
			}
			if ((Object)(object)entity != (Object)null && Object.op_Implicit((Object)(object)GetParentEntity()) && GetParentEntity().EqualNetID((BaseNetworkable)entity) && hitInfo.IsOnLayer((Layer)13))
			{
				return true;
			}
			if (((RaycastHit)(ref hitInfo)).distance <= ((RaycastHit)(ref val2)).distance)
			{
				return false;
			}
		}
		return true;
	}

	public bool IsVisibleSpecificLayers(Vector3 position, Vector3 target, int layerMask, float maxDistance = float.PositiveInfinity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = target - position;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude < Mathf.Epsilon)
		{
			return true;
		}
		Vector3 val2 = val / magnitude;
		Vector3 val3 = val2 * Mathf.Min(magnitude, 0.01f);
		return IsVisible(new Ray(position + val3, val2), layerMask, maxDistance);
	}

	public bool IsVisible(Vector3 position, Vector3 target, float maxDistance = float.PositiveInfinity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = target - position;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude < Mathf.Epsilon)
		{
			return true;
		}
		Vector3 val2 = val / magnitude;
		Vector3 val3 = val2 * Mathf.Min(magnitude, 0.01f);
		maxDistance = Mathf.Min(maxDistance, magnitude + 0.2f);
		return IsVisible(new Ray(position + val3, val2), 1218519041, maxDistance);
	}

	public bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 target = CenterPoint();
		if (IsVisible(position, target, maxDistance))
		{
			return true;
		}
		Vector3 target2 = ClosestPoint(position);
		if (IsVisible(position, target2, maxDistance))
		{
			return true;
		}
		return false;
	}

	public bool IsVisibleAndCanSee(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = CenterPoint();
		if (IsVisible(position, val) && CanSee(val, position))
		{
			return true;
		}
		Vector3 val2 = ClosestPoint(position);
		if (IsVisible(position, val2) && CanSee(val2, position))
		{
			return true;
		}
		return false;
	}

	public bool IsVisibleAndCanSeeLegacy(Vector3 position, float maxDistance = float.PositiveInfinity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = CenterPoint();
		if (IsVisible(position, val, maxDistance) && IsVisible(val, position, maxDistance))
		{
			return true;
		}
		Vector3 val2 = ClosestPoint(position);
		if (IsVisible(position, val2, maxDistance) && IsVisible(val2, position, maxDistance))
		{
			return true;
		}
		return false;
	}

	public bool CanSee(Vector3 fromPos, Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.LineOfSight(fromPos, targetPos, 1218519041, this);
	}

	public bool IsOlderThan(BaseEntity other)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)other == (Object)null)
		{
			return true;
		}
		? val = ((??)net?.ID) ?? default(NetworkableId);
		NetworkableId val2 = (NetworkableId)(((??)other.net?.ID) ?? default(NetworkableId));
		return ((NetworkableId)val).Value < val2.Value;
	}

	public virtual bool IsOutside()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		OBB val = WorldSpaceBounds();
		return IsOutside(val.position);
	}

	public bool IsOutside(Vector3 position)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		Vector3 val = position + Vector3.up * 100f;
		val.y = Mathf.Max(val.y, TerrainMeta.HeightMap.GetHeight(val) + 1f);
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Linecast(val, position, ref val2, 161546513, (QueryTriggerInteraction)1))
		{
			BaseEntity baseEntity = ((RaycastHit)(ref val2)).collider.ToBaseEntity();
			if ((Object)(object)baseEntity == (Object)null || !baseEntity.HasEntityInParents(this))
			{
				result = false;
			}
		}
		return result;
	}

	public bool IsUnderground(bool cached = true)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (!cached || Time.realtimeSinceStartup > nextHeightCheckTime)
		{
			cachedUnderground = EnvironmentManager.Check(((Component)this).transform.position, EnvironmentType.Underground);
			nextHeightCheckTime = Time.realtimeSinceStartup + 5f;
		}
		return cachedUnderground;
	}

	public virtual float WaterFactor()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		OBB val = WorldSpaceBounds();
		return WaterLevel.Factor(((OBB)(ref val)).ToBounds(), waves: true, volumes: true, this);
	}

	public virtual float AirFactor()
	{
		if (!(WaterFactor() > 0.85f))
		{
			return 1f;
		}
		return 0f;
	}

	public bool WaterTestFromVolumes(Vector3 pos, out WaterLevel.WaterInfo info)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (triggers == null)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		for (int i = 0; i < triggers.Count; i++)
		{
			if (triggers[i] is WaterVolume waterVolume && waterVolume.Test(pos, out info))
			{
				return true;
			}
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool IsInWaterVolume(Vector3 pos, out bool natural)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		natural = false;
		if (triggers == null)
		{
			return false;
		}
		for (int i = 0; i < triggers.Count; i++)
		{
			if (triggers[i] is WaterVolume waterVolume && waterVolume.Test(pos, out var _))
			{
				natural = waterVolume.naturalSource;
				return true;
			}
		}
		return false;
	}

	public bool WaterTestFromVolumes(Bounds bounds, out WaterLevel.WaterInfo info)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (triggers == null)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		for (int i = 0; i < triggers.Count; i++)
		{
			if (triggers[i] is WaterVolume waterVolume && waterVolume.Test(bounds, out info))
			{
				return true;
			}
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public bool WaterTestFromVolumes(Vector3 start, Vector3 end, float radius, out WaterLevel.WaterInfo info)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (triggers == null)
		{
			info = default(WaterLevel.WaterInfo);
			return false;
		}
		for (int i = 0; i < triggers.Count; i++)
		{
			if (triggers[i] is WaterVolume waterVolume && waterVolume.Test(start, end, radius, out info))
			{
				return true;
			}
		}
		info = default(WaterLevel.WaterInfo);
		return false;
	}

	public static void WaterTestFromVolumes(ReadOnlySpan<BaseEntity> entities, ReadOnlySpan<Vector3> starts, ReadOnlySpan<Vector3> ends, ReadOnlySpan<float> radii, Span<WaterLevel.WaterInfo> results)
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < entities.Length; i++)
		{
			BaseEntity baseEntity = entities[i];
			ref WaterLevel.WaterInfo reference = ref results[i];
			if (baseEntity.triggers == null || baseEntity.triggers.Count == 0)
			{
				reference.isValid = false;
				continue;
			}
			Vector3 start = starts[i];
			Vector3 end = ends[i];
			float radius = radii[i];
			for (int j = 0; j < baseEntity.triggers.Count && (!(baseEntity.triggers[j] is WaterVolume waterVolume) || !waterVolume.Test(start, end, radius, out reference)); j++)
			{
			}
		}
	}

	public static void WaterTestFromVolumesIndirect(ReadOnlySpan<BaseEntity> entities, ReadOnlySpan<Vector3> starts, ReadOnlySpan<Vector3> ends, ReadOnlySpan<float> radii, ReadOnlySpan<int> indices, Span<WaterLevel.WaterInfo> results)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < indices.Length; i++)
		{
			int index = indices[i];
			BaseEntity baseEntity = entities[index];
			ref WaterLevel.WaterInfo reference = ref results[index];
			if (baseEntity.triggers == null || baseEntity.triggers.Count == 0)
			{
				reference.isValid = false;
				continue;
			}
			Vector3 start = starts[index];
			Vector3 end = ends[index];
			float radius = radii[index];
			for (int j = 0; j < baseEntity.triggers.Count && (!(baseEntity.triggers[j] is WaterVolume waterVolume) || !waterVolume.Test(start, end, radius, out reference)); j++)
			{
			}
		}
	}

	public virtual bool BlocksWaterFor(BasePlayer player)
	{
		return false;
	}

	public virtual float Health()
	{
		return 0f;
	}

	public virtual float MaxHealth()
	{
		return 0f;
	}

	public virtual float MaxVelocity()
	{
		return 0f;
	}

	public virtual float BoundsPadding()
	{
		return 0.1f;
	}

	public virtual float PenetrationResistance(HitInfo info)
	{
		return 100f;
	}

	public virtual GameObjectRef GetImpactEffect(HitInfo info)
	{
		return impactEffect;
	}

	public virtual void OnAttacked(HitInfo info)
	{
	}

	public virtual Item GetItem()
	{
		return null;
	}

	public virtual Item GetItem(ItemId itemId)
	{
		return null;
	}

	public virtual void GiveItem(Item item, GiveItemReason reason = GiveItemReason.Generic)
	{
		item.Remove();
	}

	public virtual bool CanBeLooted(BasePlayer player)
	{
		return !IsTransferring();
	}

	public virtual BaseEntity GetEntity()
	{
		return this;
	}

	public override string ToString()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (_name == null)
		{
			if (base.isServer)
			{
				if (net == null)
				{
					return base.ShortPrefabName;
				}
				_name = $"{base.ShortPrefabName}[{net.ID}]";
			}
			else
			{
				_name = base.ShortPrefabName;
			}
		}
		return _name;
	}

	public virtual string Categorize()
	{
		return "entity";
	}

	public void Log(string str)
	{
		if (base.isClient)
		{
			Debug.Log((object)("<color=#ffa>[" + ((object)this).ToString() + "] " + str + "</color>"), (Object)(object)((Component)this).gameObject);
		}
		else
		{
			Debug.Log((object)("<color=#aff>[" + ((object)this).ToString() + "] " + str + "</color>"), (Object)(object)((Component)this).gameObject);
		}
	}

	public void SetModel(Model mdl)
	{
		if (!((Object)(object)model == (Object)(object)mdl))
		{
			model = mdl;
		}
	}

	public Model GetModel()
	{
		return model;
	}

	public virtual Transform[] GetBones()
	{
		if (Object.op_Implicit((Object)(object)model))
		{
			return model.GetBones();
		}
		return null;
	}

	public virtual Transform FindBone(string strName)
	{
		if (Object.op_Implicit((Object)(object)model))
		{
			return model.FindBone(strName);
		}
		return ((Component)this).transform;
	}

	public virtual uint FindBoneID(Transform boneTransform)
	{
		if (Object.op_Implicit((Object)(object)model))
		{
			return model.FindBoneID(boneTransform);
		}
		return StringPool.closest;
	}

	public virtual Transform FindClosestBone(Vector3 worldPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)model))
		{
			return model.FindClosestBone(worldPos);
		}
		return ((Component)this).transform;
	}

	public virtual bool ShouldBlockProjectiles()
	{
		return true;
	}

	public virtual bool ShouldInheritNetworkGroup()
	{
		return true;
	}

	public virtual bool SupportsChildDeployables()
	{
		return false;
	}

	public virtual bool ForceDeployableSetParent()
	{
		return false;
	}

	public virtual bool ShouldUseCastNoClipChecks()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vector3 worldVelocity = GetWorldVelocity();
		return ((Vector3)(ref worldVelocity)).magnitude > 0f;
	}

	public bool IsOnMovingObject()
	{
		if (syncPosition)
		{
			return true;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return false;
		}
		return baseEntity.IsOnMovingObject();
	}

	public void BroadcastEntityMessage(string msg, float radius = 20f, int layerMask = 1218652417)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(((Component)this).transform.position, radius, list, layerMask, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (item.isServer)
			{
				item.OnEntityMessage(this, msg);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public virtual void OnEntityMessage(BaseEntity from, string msg)
	{
	}

	public T AddComponent<T>() where T : EntityComponentBase
	{
		T val = ((Component)this).gameObject.AddComponent<T>();
		_components.Add(val);
		return val;
	}

	public virtual void DebugServer(int rep, float time)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		DebugText(((Component)this).transform.position + Vector3.up * 1f, $"{net?.ID.Value ?? 0}: {((Object)this).name}\n{DebugText()}", Color.white, time);
	}

	public virtual string DebugText()
	{
		return "";
	}

	public void OnDebugStart()
	{
		EntityDebug entityDebug = ((Component)this).gameObject.GetComponent<EntityDebug>();
		if ((Object)(object)entityDebug == (Object)null)
		{
			entityDebug = ((Component)this).gameObject.AddComponent<EntityDebug>();
		}
		((Behaviour)entityDebug).enabled = true;
	}

	protected void DebugText(Vector3 pos, string str, Color color, float time)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			ConsoleNetwork.BroadcastToAllClients("ddraw.text", time, color, pos, str);
		}
	}

	public bool HasFlag(Flags f)
	{
		return (flags & f) == f;
	}

	public bool HasAny(Flags f)
	{
		return (flags & f) > (Flags)0;
	}

	public bool ParentHasFlag(Flags f)
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return false;
		}
		return baseEntity.HasFlag(f);
	}

	public void SetFlag(Flags f, bool b, bool recursive = false, bool networkupdate = true)
	{
		Flags flags = this.flags;
		if (b)
		{
			if (HasFlag(f))
			{
				return;
			}
			this.flags |= f;
		}
		else
		{
			if (!HasFlag(f))
			{
				return;
			}
			this.flags &= ~f;
		}
		OnFlagsChanged(flags, this.flags);
		if (networkupdate)
		{
			SendNetworkUpdate();
			if (flags != this.flags)
			{
				GlobalNetworkHandler.server?.TrySendNetworkUpdate(this);
			}
		}
		else
		{
			InvalidateNetworkCache();
		}
		if (recursive && children != null)
		{
			for (int i = 0; i < children.Count; i++)
			{
				children[i].SetFlag(f, b, recursive: true);
			}
		}
	}

	public bool IsOn()
	{
		return HasFlag(Flags.On);
	}

	public bool IsOpen()
	{
		return HasFlag(Flags.Open);
	}

	public bool IsOnFire()
	{
		return HasFlag(Flags.OnFire);
	}

	public bool IsLocked()
	{
		return HasFlag(Flags.Locked);
	}

	public override bool IsDebugging()
	{
		return HasFlag(Flags.Debugging);
	}

	public bool IsDisabled()
	{
		if (!HasFlag(Flags.Disabled))
		{
			return ParentHasFlag(Flags.Disabled);
		}
		return true;
	}

	public bool IsBroken()
	{
		return HasFlag(Flags.Broken);
	}

	public bool IsBusy()
	{
		return HasFlag(Flags.Busy);
	}

	public bool IsTransferProtected()
	{
		return HasFlag(Flags.Protected);
	}

	public bool IsTransferring()
	{
		return HasFlag(Flags.Transferring);
	}

	public override string GetLogColor()
	{
		if (base.isServer)
		{
			return "cyan";
		}
		return "yellow";
	}

	public virtual void OnFlagsChanged(Flags old, Flags next)
	{
		if (IsDebugging() && (old & Flags.Debugging) != (next & Flags.Debugging))
		{
			OnDebugStart();
		}
		if (base.isServer)
		{
			if (next.HasFlag(Flags.OnFire) && !old.HasFlag(Flags.OnFire))
			{
				SingletonComponent<NpcFireManager>.Instance.Add(this);
			}
			else if (!next.HasFlag(Flags.OnFire) && old.HasFlag(Flags.OnFire))
			{
				SingletonComponent<NpcFireManager>.Instance.Remove(this);
			}
		}
	}

	public void SendNetworkUpdate_Flags()
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || Application.isLoadingSave || base.IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate_Flags", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate_Flags");
			if (Interface.CallHook("OnEntityFlagsNetworkUpdate", (object)this) == null)
			{
				List<Connection> subscribers = GetSubscribers();
				if (subscribers != null && subscribers.Count > 0)
				{
					SendDemoTransientEntity();
					NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
					obj.PacketID((Type)23);
					obj.EntityID(net.ID);
					obj.Int32((int)flags);
					SendInfo val2 = default(SendInfo);
					((SendInfo)(ref val2))..ctor(subscribers);
					obj.Send(val2);
				}
				((Component)this).gameObject.SendOnSendNetworkUpdate(this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool IsOccupied(Socket_Base socket)
	{
		return FindLink(socket)?.IsOccupied() ?? false;
	}

	public bool IsOccupied(string socketName)
	{
		return FindLink(socketName)?.IsOccupied() ?? false;
	}

	public EntityLink FindLink(Socket_Base socket)
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			if (entityLinks[i].socket == socket)
			{
				return entityLinks[i];
			}
		}
		return null;
	}

	public EntityLink FindLink(string socketName)
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			if (entityLinks[i].socket.socketName == socketName)
			{
				return entityLinks[i];
			}
		}
		return null;
	}

	public EntityLink FindLink(string[] socketNames)
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			for (int j = 0; j < socketNames.Length; j++)
			{
				if (entityLinks[i].socket.socketName == socketNames[j])
				{
					return entityLinks[i];
				}
			}
		}
		return null;
	}

	public T FindLinkedEntity<T>() where T : BaseEntity
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				EntityLink entityLink2 = entityLink.connections[j];
				if (entityLink2.owner is T)
				{
					return entityLink2.owner as T;
				}
			}
		}
		return null;
	}

	public void EntityLinkMessage<T>(Action<T> action) where T : BaseEntity
	{
		List<EntityLink> entityLinks = GetEntityLinks();
		for (int i = 0; i < entityLinks.Count; i++)
		{
			EntityLink entityLink = entityLinks[i];
			for (int j = 0; j < entityLink.connections.Count; j++)
			{
				EntityLink entityLink2 = entityLink.connections[j];
				if (entityLink2.owner is T)
				{
					action(entityLink2.owner as T);
				}
			}
		}
	}

	public void EntityLinkBroadcast<T, S>(Action<T> action, Func<S, bool> canTraverseSocket) where T : BaseEntity where S : Socket_Base
	{
		globalBroadcastProtocol++;
		globalBroadcastQueue.Clear();
		broadcastProtocol = globalBroadcastProtocol;
		globalBroadcastQueue.Enqueue(this);
		if (this is T)
		{
			action(this as T);
		}
		while (globalBroadcastQueue.Count > 0)
		{
			List<EntityLink> entityLinks = globalBroadcastQueue.Dequeue().GetEntityLinks();
			for (int i = 0; i < entityLinks.Count; i++)
			{
				EntityLink entityLink = entityLinks[i];
				if (!(entityLink.socket is S) || !canTraverseSocket(entityLink.socket as S))
				{
					continue;
				}
				for (int j = 0; j < entityLink.connections.Count; j++)
				{
					BaseEntity owner = entityLink.connections[j].owner;
					if (owner.broadcastProtocol != globalBroadcastProtocol)
					{
						owner.broadcastProtocol = globalBroadcastProtocol;
						globalBroadcastQueue.Enqueue(owner);
						if (owner is T)
						{
							action(owner as T);
						}
					}
				}
			}
		}
	}

	public void EntityLinkBroadcast<T>(Action<T> action) where T : BaseEntity
	{
		globalBroadcastProtocol++;
		globalBroadcastQueue.Clear();
		broadcastProtocol = globalBroadcastProtocol;
		globalBroadcastQueue.Enqueue(this);
		if (this is T)
		{
			action(this as T);
		}
		while (globalBroadcastQueue.Count > 0)
		{
			List<EntityLink> entityLinks = globalBroadcastQueue.Dequeue().GetEntityLinks();
			for (int i = 0; i < entityLinks.Count; i++)
			{
				EntityLink entityLink = entityLinks[i];
				for (int j = 0; j < entityLink.connections.Count; j++)
				{
					BaseEntity owner = entityLink.connections[j].owner;
					if (owner.broadcastProtocol != globalBroadcastProtocol)
					{
						owner.broadcastProtocol = globalBroadcastProtocol;
						globalBroadcastQueue.Enqueue(owner);
						if (owner is T)
						{
							action(owner as T);
						}
					}
				}
			}
		}
	}

	public void EntityLinkBroadcast()
	{
		globalBroadcastProtocol++;
		globalBroadcastQueue.Clear();
		broadcastProtocol = globalBroadcastProtocol;
		globalBroadcastQueue.Enqueue(this);
		while (globalBroadcastQueue.Count > 0)
		{
			List<EntityLink> entityLinks = globalBroadcastQueue.Dequeue().GetEntityLinks();
			for (int i = 0; i < entityLinks.Count; i++)
			{
				EntityLink entityLink = entityLinks[i];
				for (int j = 0; j < entityLink.connections.Count; j++)
				{
					BaseEntity owner = entityLink.connections[j].owner;
					if (owner.broadcastProtocol != globalBroadcastProtocol)
					{
						owner.broadcastProtocol = globalBroadcastProtocol;
						globalBroadcastQueue.Enqueue(owner);
					}
				}
			}
		}
	}

	public bool ReceivedEntityLinkBroadcast()
	{
		return broadcastProtocol == globalBroadcastProtocol;
	}

	public List<EntityLink> GetEntityLinks(bool linkToNeighbours = true)
	{
		if (Application.isLoadingSave)
		{
			return links;
		}
		if (!linkedToNeighbours && linkToNeighbours)
		{
			LinkToNeighbours();
		}
		return links;
	}

	private void LinkToEntity(BaseEntity other)
	{
		if ((Object)(object)this == (Object)(object)other || links.Count == 0 || other.links.Count == 0)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("LinkToEntity", 0);
		try
		{
			for (int i = 0; i < links.Count; i++)
			{
				EntityLink entityLink = links[i];
				for (int j = 0; j < other.links.Count; j++)
				{
					EntityLink entityLink2 = other.links[j];
					if (entityLink.CanConnect(entityLink2))
					{
						if (!entityLink.Contains(entityLink2))
						{
							entityLink.Add(entityLink2);
						}
						if (!entityLink2.Contains(entityLink))
						{
							entityLink2.Add(entityLink);
						}
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void LinkToNeighbours()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (links.Count == 0)
		{
			return;
		}
		linkedToNeighbours = true;
		TimeWarning val = TimeWarning.New("LinkToNeighbours", 0);
		try
		{
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			OBB val2 = WorldSpaceBounds();
			Vis.Entities(val2.position, ((Vector3)(ref val2.extents)).magnitude + 1f, list, -1, (QueryTriggerInteraction)2);
			for (int i = 0; i < list.Count; i++)
			{
				BaseEntity baseEntity = list[i];
				if (baseEntity.isServer == base.isServer)
				{
					LinkToEntity(baseEntity);
				}
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void InitEntityLinks()
	{
		TimeWarning val = TimeWarning.New("InitEntityLinks", 0);
		try
		{
			if (base.isServer)
			{
				links.AddLinks(this, PrefabAttribute.server.FindAll<Socket_Base>(prefabID));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FreeEntityLinks()
	{
		TimeWarning val = TimeWarning.New("FreeEntityLinks", 0);
		try
		{
			links.FreeLinks();
			linkedToNeighbours = false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RefreshEntityLinks()
	{
		TimeWarning val = TimeWarning.New("RefreshEntityLinks", 0);
		try
		{
			links.ClearLinks();
			LinkToNeighbours();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[RPC_Server]
	public void SV_RequestFile(RPCMessage msg)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		uint num = msg.read.UInt32();
		FileStorage.Type type = (FileStorage.Type)msg.read.UInt8();
		string funcName = StringPool.Get(msg.read.UInt32());
		uint num2 = ((msg.read.Unread > 0) ? msg.read.UInt32() : 0u);
		bool flag = msg.read.Unread > 0 && msg.read.Bit();
		byte[] array = FileStorage.server.Get(num, type, net.ID, num2);
		if (array == null)
		{
			if (!flag)
			{
				return;
			}
			array = Array.Empty<byte>();
		}
		SendInfo val = default(SendInfo);
		((SendInfo)(ref val))..ctor(msg.connection);
		val.channel = 2;
		val.method = (SendMethod)0;
		SendInfo sendInfo = val;
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo), num, (uint)array.Length, array, num2, (byte)type);
	}

	public virtual void EnableTransferProtection()
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		if (!IsTransferProtected())
		{
			SetFlag(Flags.Protected, b: true);
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null)
			{
				List<Connection> list = Pool.Get<List<Connection>>();
				foreach (Connection item in subscribers)
				{
					if (!ShouldNetworkTo(item.player as BasePlayer))
					{
						list.Add(item);
					}
				}
				OnNetworkSubscribersLeave(list);
				Pool.FreeUnmanaged<Connection>(ref list);
			}
			float protectionDuration = Nexus.protectionDuration;
			_transferProtectionRemaining = TimeUntil.op_Implicit(protectionDuration);
			((FacepunchBehaviour)this).Invoke(DisableTransferProtectionAction, protectionDuration);
		}
		foreach (BaseEntity child in children)
		{
			child.EnableTransferProtection();
		}
	}

	public virtual void DisableTransferProtection()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsTransferProtected())
		{
			baseEntity.DisableTransferProtection();
		}
		if (IsTransferProtected())
		{
			SetFlag(Flags.Protected, b: false);
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null)
			{
				OnNetworkSubscribersEnter(subscribers);
			}
			_transferProtectionRemaining = TimeUntil.op_Implicit(0f);
			((FacepunchBehaviour)this).CancelInvoke(DisableTransferProtectionAction);
		}
		foreach (BaseEntity child in children)
		{
			child.DisableTransferProtection();
		}
	}

	public void SetParent(BaseEntity entity, bool worldPositionStays = false, bool sendImmediate = false)
	{
		SetParent(entity, 0u, worldPositionStays, sendImmediate);
	}

	public void SetParent(BaseEntity entity, string strBone, bool worldPositionStays = false, bool sendImmediate = false)
	{
		SetParent(entity, (!string.IsNullOrEmpty(strBone)) ? StringPool.Get(strBone) : 0u, worldPositionStays, sendImmediate);
	}

	public bool HasChild(BaseEntity c)
	{
		if ((Object)(object)c == (Object)(object)this)
		{
			return true;
		}
		BaseEntity baseEntity = c.GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return HasChild(baseEntity);
		}
		return false;
	}

	public void SetParent(BaseEntity entity, uint boneID, bool worldPositionStays = false, bool sendImmediate = false)
	{
		if ((Object)(object)entity != (Object)null)
		{
			if ((Object)(object)entity == (Object)(object)this)
			{
				Debug.LogError((object)("Trying to parent to self " + (object)this), (Object)(object)((Component)this).gameObject);
				return;
			}
			if (HasChild(entity))
			{
				Debug.LogError((object)("Trying to parent to child " + (object)this), (Object)(object)((Component)this).gameObject);
				return;
			}
		}
		LogEntry(RustLog.EntryType.Hierarchy, 2, "SetParent {0} {1}", entity, boneID);
		BaseEntity baseEntity = GetParentEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.RemoveChild(this);
		}
		if (base.limitNetworking && (Object)(object)baseEntity != (Object)null && (Object)(object)baseEntity != (Object)(object)entity)
		{
			BasePlayer basePlayer = baseEntity as BasePlayer;
			if (basePlayer.IsValid())
			{
				DestroyOnClient(basePlayer.net.connection);
			}
		}
		if ((Object)(object)entity == (Object)null)
		{
			OnParentChanging(baseEntity, null);
			parentEntity.Set(null);
			((Component)this).transform.SetParent((Transform)null, worldPositionStays);
			parentBone = 0u;
			UpdateNetworkGroup();
			if (sendImmediate)
			{
				SendNetworkUpdateImmediate();
				SendChildrenNetworkUpdateImmediate();
			}
			else
			{
				SendNetworkUpdate();
				SendChildrenNetworkUpdate();
			}
			return;
		}
		Debug.Assert(entity.isServer, "SetParent - child should be a SERVER entity");
		Debug.Assert(entity.net != null, "Setting parent to entity that hasn't spawned yet! (net is null)");
		Debug.Assert(((NetworkableId)(ref entity.net.ID)).IsValid, "Setting parent to entity that hasn't spawned yet! (id = 0)");
		entity.AddChild(this);
		OnParentChanging(baseEntity, entity);
		parentEntity.Set(entity);
		if (boneID != 0 && boneID != StringPool.closest)
		{
			((Component)this).transform.SetParent(entity.FindBone(StringPool.Get(boneID)), worldPositionStays);
		}
		else
		{
			((Component)this).transform.SetParent(((Component)entity).transform, worldPositionStays);
		}
		parentBone = boneID;
		UpdateNetworkGroup();
		if (sendImmediate)
		{
			SendNetworkUpdateImmediate();
			SendChildrenNetworkUpdateImmediate();
		}
		else
		{
			SendNetworkUpdate();
			SendChildrenNetworkUpdate();
		}
	}

	public void DestroyOnClient(Connection connection)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (children != null)
		{
			foreach (BaseEntity child in children)
			{
				child.DestroyOnClient(connection);
			}
		}
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)0);
			obj.Send(new SendInfo(connection));
			LogEntry(RustLog.EntryType.Network, 2, "EntityDestroy");
		}
	}

	public void SendChildrenNetworkUpdate()
	{
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.UpdateNetworkGroup();
			child.SendNetworkUpdate();
		}
	}

	public void SendChildrenNetworkUpdateImmediate()
	{
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.UpdateNetworkGroup();
			child.SendNetworkUpdateImmediate();
		}
	}

	public virtual void SwitchParent(BaseEntity ent)
	{
		Log("SwitchParent Missed " + (object)ent);
	}

	public virtual void OnParentChanging(BaseEntity oldParent, BaseEntity newParent)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (!Object.op_Implicit((Object)(object)component) || component.isKinematic)
		{
			return;
		}
		if ((Object)(object)oldParent != (Object)null)
		{
			Rigidbody component2 = ((Component)oldParent).GetComponent<Rigidbody>();
			if ((Object)(object)component2 == (Object)null || component2.isKinematic)
			{
				component.velocity += oldParent.GetWorldVelocity();
			}
		}
		if ((Object)(object)newParent != (Object)null)
		{
			Rigidbody component3 = ((Component)newParent).GetComponent<Rigidbody>();
			if ((Object)(object)component3 == (Object)null || component3.isKinematic)
			{
				component.velocity -= newParent.GetWorldVelocity();
			}
		}
	}

	protected bool PrivilegeCacheDefaultValue()
	{
		return base.isClient;
	}

	public virtual EntityPrivilege GetEntityBuildingPrivilege()
	{
		return null;
	}

	public virtual BuildingPrivlidge GetBuildingPrivilege()
	{
		return GetNearestBuildingPrivilege(PrivilegeCacheDefaultValue());
	}

	public virtual BuildingPrivlidge GetBuildingPrivilege(bool cached, float cacheDuration = 1f)
	{
		return GetNearestBuildingPrivilege(cached, cacheDuration);
	}

	public BuildingPrivlidge GetNearestBuildingPrivilege()
	{
		return GetBuildingPrivilege(PrivilegeCacheDefaultValue());
	}

	public BuildingPrivlidge GetNearestBuildingPrivilege(bool cached, float cacheDuration = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GetBuildingPrivilege(WorldSpaceBounds(), cached, cacheDuration);
	}

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetBuildingPrivilege(obb, PrivilegeCacheDefaultValue());
	}

	public BuildingPrivlidge GetBuildingPrivilege(OBB obb, bool cached, float cacheDuration = 1f, BuildingPrivlidge exclude = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnBuildingPrivilege", (object)this, (object)obb, (object)cached, (object)cacheDuration, (object)exclude);
		if (obj is BuildingPrivlidge)
		{
			return (BuildingPrivlidge)obj;
		}
		if (cached && cachedBuildingPrivilegeTime != 0f && Time.time - cachedBuildingPrivilegeTime < cacheDuration)
		{
			return cachedBuildingPrivilege;
		}
		BuildingBlock other = null;
		BuildingPrivlidge buildingPrivlidge = null;
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(obb.position, 16f + ((Vector3)(ref obb.extents)).magnitude, list, 2097152, (QueryTriggerInteraction)2);
		uint num = (((Object)(object)exclude != (Object)null) ? exclude.buildingID : 0u);
		for (int i = 0; i < list.Count; i++)
		{
			BuildingBlock buildingBlock = list[i];
			if (buildingBlock.isServer != base.isServer || !buildingBlock.IsOlderThan(other) || ((OBB)(ref obb)).Distance(buildingBlock.WorldSpaceBounds()) > 16f)
			{
				continue;
			}
			BuildingManager.Building building = buildingBlock.GetBuilding();
			if (building != null && (num == 0 || num != building.ID))
			{
				BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
				if (!((Object)(object)dominatingBuildingPrivilege == (Object)null))
				{
					other = buildingBlock;
					buildingPrivlidge = dominatingBuildingPrivilege;
				}
			}
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		cachedBuildingPrivilegeTime = Time.time;
		cachedBuildingPrivilege = buildingPrivlidge;
		return cachedBuildingPrivilege;
	}

	public void SV_RPCMessage(uint nameID, Message message)
	{
		Assert.IsTrue(base.isServer, "Should be server!");
		BasePlayer basePlayer = message.Player();
		if (!basePlayer.IsValid())
		{
			if (Global.developer > 0)
			{
				Debug.Log((object)("SV_RPCMessage: From invalid player " + (object)basePlayer));
			}
			return;
		}
		if (ConVar.AntiHack.rpcstallmode > 0 && basePlayer.isStalled)
		{
			if (Global.developer > 0)
			{
				Debug.Log((object)("SV_RPCMessage: player is stalled " + (object)basePlayer));
			}
			return;
		}
		if (ConVar.AntiHack.rpcstallmode > 1 && basePlayer.wasStalled)
		{
			if (Global.developer > 0)
			{
				Debug.Log((object)("SV_RPCMessage: player was stalled " + (object)basePlayer));
			}
			return;
		}
		(byte[], int) buffer = message.read.GetBuffer();
		if (OnRpcMessage(basePlayer, nameID, message))
		{
			if (!basePlayer.IsRealNull())
			{
				Analytics.Azure.OnServerRPC(basePlayer, nameID, buffer.Item1, buffer.Item2);
			}
			return;
		}
		for (int i = 0; i < Components.Count; i++)
		{
			if (Components[i].OnRpcMessage(basePlayer, nameID, message))
			{
				if (!basePlayer.IsRealNull())
				{
					Analytics.Azure.OnServerRPC(basePlayer, nameID, buffer.Item1, buffer.Item2);
				}
				break;
			}
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCPlayer<T1, T2, T3, T4, T5>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2, arg3, arg4, arg5);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCPlayer<T1, T2, T3, T4>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2, arg3, arg4);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCPlayer<T1, T2, T3>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2, T3 arg3)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2, arg3);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCPlayer<T1, T2>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1, T2 arg2)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1, arg2);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCPlayer<T1>(Connection sourceConnection, BasePlayer player, string funcName, T1 arg1)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName, arg1);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCPlayer(Connection sourceConnection, BasePlayer player, string funcName)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && player.net.connection != null)
		{
			ClientRPCEx(new SendInfo(player.net.connection), sourceConnection, funcName);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPC<T1, T2, T3, T4, T5>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2, arg3, arg4, arg5);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPC<T1, T2, T3, T4>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2, arg3, arg4);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPC<T1, T2, T3>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2, arg3);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPC<T1, T2>(Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1, arg2);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPC<T1>(Connection sourceConnection, string funcName, T1 arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName, arg1);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPC(Connection sourceConnection, string funcName)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null && net.group != null)
		{
			ClientRPCEx(new SendInfo(net.group.subscribers), sourceConnection, funcName);
		}
	}

	public void ClientRPC(RpcTarget target)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1>(RpcTarget target, T1 arg1)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1, T2>(RpcTarget target, T1 arg1, T2 arg2)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCWrite(write, arg2);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1, T2, T3>(RpcTarget target, T1 arg1, T2 arg2, T3 arg3)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCWrite(write, arg2);
			ClientRPCWrite(write, arg3);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1, T2, T3, T4>(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCWrite(write, arg2);
			ClientRPCWrite(write, arg3);
			ClientRPCWrite(write, arg4);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1, T2, T3, T4, T5>(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCWrite(write, arg2);
			ClientRPCWrite(write, arg3);
			ClientRPCWrite(write, arg4);
			ClientRPCWrite(write, arg5);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1, T2, T3, T4, T5, T6>(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCWrite(write, arg2);
			ClientRPCWrite(write, arg3);
			ClientRPCWrite(write, arg4);
			ClientRPCWrite(write, arg5);
			ClientRPCWrite(write, arg6);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC<T1, T2, T3, T4, T5, T6, T7>(RpcTarget target, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite write = ClientRPCStart(target.Function);
			ClientRPCWrite(write, arg1);
			ClientRPCWrite(write, arg2);
			ClientRPCWrite(write, arg3);
			ClientRPCWrite(write, arg4);
			ClientRPCWrite(write, arg5);
			ClientRPCWrite(write, arg6);
			ClientRPCWrite(write, arg7);
			ClientRPCSend(write, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, MemoryStream stream)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			TimeWarning val2 = TimeWarning.New("Copy Buffer", 0);
			try
			{
				((Stream)(object)val).Write(stream.GetBuffer(), 0, (int)stream.Length);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void GetRpcTargetNetworkGroup(ref RpcTarget target)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (target.ToNetworkGroup)
		{
			target.Connections = new SendInfo(net.group.subscribers);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private void FreeRPCTarget(RpcTarget target)
	{
		if (target.UsingPooledConnections)
		{
			Pool.FreeUnmanaged<Connection>(ref target.Connections.connections);
		}
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCEx<T1, T2, T3, T4, T5>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo), arg1, arg2, arg3, arg4, arg5);
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCEx<T1, T2, T3, T4>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo), arg1, arg2, arg3, arg4);
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCEx<T1, T2, T3>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2, T3 arg3)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo), arg1, arg2, arg3);
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCEx<T1, T2>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1, T2 arg2)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo), arg1, arg2);
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCEx<T1>(SendInfo sendInfo, Connection sourceConnection, string funcName, T1 arg1)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo), arg1);
	}

	[Obsolete("Use ClientRPC( RpcTarget ) overloads")]
	public void ClientRPCEx(SendInfo sendInfo, Connection sourceConnection, string funcName)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.SendInfo(funcName, sendInfo));
	}

	protected NetWrite ClientRPCStart(string funcName)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		SendDemoTransientEntity();
		NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
		obj.PacketID((Type)9);
		obj.EntityID(net.ID);
		obj.UInt32(StringPool.Get(funcName));
		return obj;
	}

	private void ClientRPCWrite<T>(NetWrite write, T arg)
	{
		write.WriteObject(arg);
	}

	protected void ClientRPCSend(NetWrite write, SendInfo sendInfo)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		write.Send(sendInfo);
	}

	public void ClientRPCPlayerList<T1>(Connection sourceConnection, BasePlayer player, string funcName, List<T1> list)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		if (!((BaseNetwork)Net.sv).IsConnected() || net == null || player.net.connection == null)
		{
			return;
		}
		NetWrite write = ClientRPCStart(funcName);
		ClientRPCWrite(write, list.Count);
		foreach (T1 item in list)
		{
			ClientRPCWrite(write, item);
		}
		SendInfo sendInfo = default(SendInfo);
		((SendInfo)(ref sendInfo))..ctor(player.net.connection);
		sendInfo.priority = (Priority)0;
		ClientRPCSend(write, sendInfo);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0465: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		BaseEntity baseEntity = parentEntity.Get(base.isServer);
		info.msg.baseEntity = Pool.Get<BaseEntity>();
		Quaternion val;
		if (info.forDisk)
		{
			if (this is BasePlayer)
			{
				if ((Object)(object)baseEntity == (Object)null || baseEntity.enableSaving)
				{
					info.msg.baseEntity.pos = ((Component)this).transform.localPosition;
					BaseEntity baseEntity2 = info.msg.baseEntity;
					val = ((Component)this).transform.localRotation;
					baseEntity2.rot = ((Quaternion)(ref val)).eulerAngles;
				}
				else
				{
					info.msg.baseEntity.pos = ((Component)this).transform.position;
					BaseEntity baseEntity3 = info.msg.baseEntity;
					val = ((Component)this).transform.rotation;
					baseEntity3.rot = ((Quaternion)(ref val)).eulerAngles;
				}
			}
			else
			{
				info.msg.baseEntity.pos = ((Component)this).transform.localPosition;
				BaseEntity baseEntity4 = info.msg.baseEntity;
				val = ((Component)this).transform.localRotation;
				baseEntity4.rot = ((Quaternion)(ref val)).eulerAngles;
			}
		}
		else
		{
			info.msg.baseEntity.pos = GetNetworkPosition();
			BaseEntity baseEntity5 = info.msg.baseEntity;
			val = GetNetworkRotation();
			baseEntity5.rot = ((Quaternion)(ref val)).eulerAngles;
			info.msg.baseEntity.time = GetNetworkTime();
		}
		info.msg.baseEntity.flags = (int)flags;
		info.msg.baseEntity.skinid = skinID;
		if (info.forDisk && this is BasePlayer)
		{
			if ((Object)(object)baseEntity != (Object)null && baseEntity.enableSaving)
			{
				info.msg.parent = Pool.Get<ParentInfo>();
				info.msg.parent.uid = parentEntity.uid;
				info.msg.parent.bone = parentBone;
			}
		}
		else if ((Object)(object)baseEntity != (Object)null)
		{
			info.msg.parent = Pool.Get<ParentInfo>();
			info.msg.parent.uid = parentEntity.uid;
			info.msg.parent.bone = parentBone;
		}
		if (HasAnySlot())
		{
			info.msg.entitySlots = Pool.Get<EntitySlots>();
			info.msg.entitySlots.slotLock = entitySlots[0].uid;
			info.msg.entitySlots.slotFireMod = entitySlots[1].uid;
			info.msg.entitySlots.slotUpperModification = entitySlots[2].uid;
			info.msg.entitySlots.centerDecoration = entitySlots[5].uid;
			info.msg.entitySlots.lowerCenterDecoration = entitySlots[6].uid;
			info.msg.entitySlots.storageMonitor = entitySlots[7].uid;
		}
		if (info.forDisk && Object.op_Implicit((Object)(object)_spawnable))
		{
			_spawnable.Save(info);
		}
		if (info.msg.baseEntity != null)
		{
			AutoSaveSyncVars(info);
		}
		if (OwnerID != 0L && (info.forDisk || ShouldNetworkOwnerInfo()))
		{
			info.msg.ownerInfo = Pool.Get<OwnerInfo>();
			if (info.forDisk)
			{
				info.msg.ownerInfo.steamid = OwnerID;
			}
			else
			{
				info.msg.ownerInfo.steamid = ((OwnerID == info.forConnection.userid) ? info.forConnection.userid : 0);
			}
		}
		if (Components != null)
		{
			for (int i = 0; i < Components.Count; i++)
			{
				if (!((Object)(object)Components[i] == (Object)null))
				{
					Components[i].SaveComponent(info);
				}
			}
		}
		if (info.forTransfer && ShouldTransferAssociatedFiles)
		{
			info.msg.associatedFiles = Pool.Get<AssociatedFiles>();
			info.msg.associatedFiles.files = Pool.Get<List<AssociatedFile>>();
			info.msg.associatedFiles.files.AddRange(FileStorage.server.QueryAllByEntity(net.ID));
		}
	}

	public override bool CanUseNetworkCache(Connection connection)
	{
		if (ShouldNetworkOwnerInfo())
		{
			return false;
		}
		return base.CanUseNetworkCache(connection);
	}

	public virtual bool ShouldNetworkOwnerInfo()
	{
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseEntity != null)
		{
			BaseEntity baseEntity = info.msg.baseEntity;
			Flags old = flags;
			if (base.isServer)
			{
				baseEntity.flags &= -33554433;
			}
			flags = (Flags)baseEntity.flags;
			OnFlagsChanged(old, flags);
			OnSkinChanged(skinID, info.msg.baseEntity.skinid);
			if (info.fromDisk)
			{
				if (Vector3Ex.IsNaNOrInfinity(baseEntity.pos))
				{
					string? text = ((object)this).ToString();
					Vector3 pos = baseEntity.pos;
					Debug.LogWarning((object)(text + " has broken position - " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
					baseEntity.pos = Vector3.zero;
				}
				((Component)this).transform.localPosition = baseEntity.pos;
				((Component)this).transform.localRotation = Quaternion.Euler(baseEntity.rot);
			}
		}
		if (info.msg.entitySlots != null)
		{
			entitySlots[0].uid = info.msg.entitySlots.slotLock;
			entitySlots[1].uid = info.msg.entitySlots.slotFireMod;
			entitySlots[2].uid = info.msg.entitySlots.slotUpperModification;
			entitySlots[5].uid = info.msg.entitySlots.centerDecoration;
			entitySlots[6].uid = info.msg.entitySlots.lowerCenterDecoration;
			entitySlots[7].uid = info.msg.entitySlots.storageMonitor;
		}
		else
		{
			for (int i = 0; i < entitySlots.Length; i++)
			{
				entitySlots[i] = default(EntityRef);
			}
		}
		if (info.msg.parent != null)
		{
			if (base.isServer)
			{
				BaseEntity entity = BaseNetworkable.serverEntities.Find(info.msg.parent.uid) as BaseEntity;
				SetParent(entity, info.msg.parent.bone);
			}
			parentEntity.uid = info.msg.parent.uid;
			parentBone = info.msg.parent.bone;
		}
		else
		{
			parentEntity.uid = default(NetworkableId);
			parentBone = 0u;
		}
		if (info.msg.ownerInfo != null)
		{
			OwnerID = info.msg.ownerInfo.steamid;
		}
		if (Object.op_Implicit((Object)(object)_spawnable))
		{
			_spawnable.Load(info);
		}
		if (info.fromTransfer && ShouldTransferAssociatedFiles && info.msg.associatedFiles != null && info.msg.associatedFiles.files != null)
		{
			foreach (AssociatedFile file in info.msg.associatedFiles.files)
			{
				if (FileStorage.server.Store(file.data, (FileStorage.Type)file.type, net.ID, file.numID) != file.crc)
				{
					Debug.LogWarning((object)"Associated file has a different CRC after transfer!");
				}
			}
		}
		if (info.fromDisk && info.msg.baseEntity != null && IsTransferProtected())
		{
			float num = ((info.msg.baseEntity.protection > 0f) ? info.msg.baseEntity.protection : Nexus.protectionDuration);
			_transferProtectionRemaining = TimeUntil.op_Implicit(num);
			((FacepunchBehaviour)this).Invoke(DisableTransferProtectionAction, num);
		}
		if (info.msg.baseEntity != null)
		{
			AutoLoadSyncVars(info);
		}
		if (Components == null)
		{
			return;
		}
		for (int j = 0; j < Components.Count; j++)
		{
			if (!((Object)(object)Components[j] == (Object)null))
			{
				Components[j].LoadComponent(info);
			}
		}
	}

	public virtual void SetCreatorEntity(BaseEntity newCreatorEntity)
	{
		creatorEntity = newCreatorEntity;
	}

	public virtual Vector3 GetLocalVelocityServer()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	public virtual Quaternion GetAngularVelocityServer()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.identity;
	}

	public void EnableGlobalBroadcast(bool wants)
	{
		if (globalBroadcast != wants)
		{
			globalBroadcast = wants;
			UpdateNetworkGroup();
		}
	}

	public void EnableSaving(bool wants)
	{
		if (enableSaving != wants)
		{
			enableSaving = wants;
			if (enableSaving)
			{
				saveList.Add(this);
			}
			else
			{
				saveList.Remove(this);
			}
		}
	}

	public void RestoreCanSave()
	{
		EnableSaving(couldSaveOriginally);
	}

	public override void ServerInit()
	{
		_spawnable = ((Component)this).GetComponent<Spawnable>();
		base.ServerInit();
		if (!base.isServer)
		{
			return;
		}
		couldSaveOriginally = enableSaving;
		if (enableSaving)
		{
			saveList.Add(this);
		}
		if (flags != 0)
		{
			OnFlagsChanged((Flags)0, flags);
		}
		if (syncPosition && PositionTickRate >= 0f)
		{
			if (PositionTickFixedTime)
			{
				((FacepunchBehaviour)this).InvokeRepeatingFixedTime((Action)NetworkPositionTick);
			}
			else
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)NetworkPositionTick, PositionTickRate, PositionTickRate - PositionTickRate * 0.05f, PositionTickRate * 0.05f);
			}
		}
		Query.Server.Add(this);
		if (this is SamSite.ISamSiteTarget item)
		{
			SamSite.ISamSiteTarget.serverList.Add(item);
		}
	}

	public virtual void OnPlaced(BasePlayer player)
	{
	}

	protected virtual bool ShouldUpdateNetworkGroup()
	{
		return syncPosition;
	}

	protected virtual bool ShouldUpdateNetworkPosition()
	{
		return syncPosition;
	}

	public void NetworkPositionTick()
	{
		if (!((Component)this).transform.hasChanged)
		{
			if (ticksSinceStopped >= 6)
			{
				return;
			}
			ticksSinceStopped++;
		}
		else
		{
			ticksSinceStopped = 0;
		}
		TransformChanged();
		((Component)this).transform.hasChanged = false;
	}

	public void TransformChanged()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		if (Query.Server != null)
		{
			Query.Server.Move(this);
		}
		SingletonComponent<NpcFoodManager>.Instance.Move(this);
		SingletonComponent<NpcFireManager>.Instance.Move(this);
		SingletonComponent<SmokeGrenadeManager>.Instance.Move(this);
		if (net == null)
		{
			return;
		}
		InvalidateNetworkCache();
		if (!globalBroadcast && !ValidBounds.Test(this, ((Component)this).transform.position))
		{
			OnInvalidPosition();
			return;
		}
		TryScheduleUpdateNetworkGroup();
		if (ShouldUpdateNetworkPosition())
		{
			SendNetworkUpdate_Position();
			OnPositionalNetworkUpdate();
		}
	}

	protected void TryScheduleUpdateNetworkGroup()
	{
		if (ShouldUpdateNetworkGroup() && !isCallingUpdateNetworkGroup)
		{
			((FacepunchBehaviour)this).Invoke((Action)UpdateNetworkGroup, 5f);
			isCallingUpdateNetworkGroup = true;
		}
	}

	public virtual void OnPositionalNetworkUpdate()
	{
	}

	public override void Spawn()
	{
		base.Spawn();
		if (base.isServer)
		{
			((Component)this).gameObject.BroadcastOnParentSpawning();
		}
		for (int i = 0; i < entitySlots.Length; i++)
		{
			entitySlots[i] = default(EntityRef);
		}
	}

	public void OnParentSpawning()
	{
		if (net != null || base.IsDestroyed)
		{
			return;
		}
		if (Application.isLoadingSave)
		{
			Object.Destroy((Object)(object)((Component)this).gameObject);
			return;
		}
		if (GameManager.server.preProcessed.NeedsProcessing(((Component)this).gameObject, PreProcessPrefabOptions.Default_NoResetPosition))
		{
			GameManager.server.preProcessed.ProcessObject(null, ((Component)this).gameObject, PreProcessPrefabOptions.Default_NoResetPosition);
		}
		BaseEntity baseEntity = (((Object)(object)((Component)this).transform.parent != (Object)null) ? ((Component)((Component)this).transform.parent).GetComponentInParent<BaseEntity>() : null);
		Spawn();
		if ((Object)(object)baseEntity != (Object)null)
		{
			SetParent(baseEntity, worldPositionStays: true);
		}
	}

	public void SpawnAsMapEntity()
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		if (net == null && !base.IsDestroyed && (Object)(object)(((Object)(object)((Component)this).transform.parent != (Object)null) ? ((Component)((Component)this).transform.parent).GetComponentInParent<BaseEntity>() : null) == (Object)null)
		{
			if (GameManager.server.preProcessed.NeedsProcessing(((Component)this).gameObject, PreProcessPrefabOptions.Default_NoResetPosition))
			{
				GameManager.server.preProcessed.ProcessObject(null, ((Component)this).gameObject, PreProcessPrefabOptions.Default_NoResetPosition);
			}
			((Component)this).transform.parent = null;
			SceneManager.MoveGameObjectToScene(((Component)this).gameObject, Rust.Server.EntityScene);
			((Component)this).gameObject.SetActive(true);
			Spawn();
		}
	}

	public virtual void PostMapEntitySpawn()
	{
	}

	internal override void DoServerDestroy()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)NetworkPositionTick);
		if (enableSaving)
		{
			saveList.Remove(this);
		}
		enableSaving = couldSaveOriginally;
		RemoveFromTriggers();
		if (children != null)
		{
			BaseEntity[] array = children.ToArray();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].OnParentRemoved();
			}
		}
		SetParent(null, worldPositionStays: true);
		Query.Server.Remove(this);
		SingletonComponent<NpcFireManager>.Instance.Remove(this);
		if (this is SamSite.ISamSiteTarget item)
		{
			SamSite.ISamSiteTarget.serverList.Remove(item);
		}
		base.DoServerDestroy();
	}

	internal virtual void OnParentRemoved()
	{
		Kill();
	}

	public virtual void OnInvalidPosition()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[5]
		{
			"Invalid Position: ",
			((object)this)?.ToString(),
			" ",
			null,
			null
		};
		Vector3 position = ((Component)this).transform.position;
		obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
		obj[4] = " (destroying)";
		Debug.Log((object)string.Concat(obj));
		Kill();
	}

	public BaseCorpse DropCorpse(string strCorpsePrefab, BasePlayer.PlayerFlags playerFlagsOnDeath = (BasePlayer.PlayerFlags)0, ModelState modelState = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		return DropCorpse(strCorpsePrefab, ((Component)this).transform.position, ((Component)this).transform.rotation, playerFlagsOnDeath, modelState);
	}

	public BaseCorpse DropCorpse(string strCorpsePrefab, Vector3 posOnDeath, Quaternion rotOnDeath, BasePlayer.PlayerFlags playerFlagsOnDeath = (BasePlayer.PlayerFlags)0, ModelState modelState = null)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(base.isServer, "DropCorpse called on client!");
		if (!ConVar.Server.corpses)
		{
			return null;
		}
		if (string.IsNullOrEmpty(strCorpsePrefab))
		{
			return null;
		}
		BaseCorpse baseCorpse = GameManager.server.CreateEntity(strCorpsePrefab) as BaseCorpse;
		if ((Object)(object)baseCorpse == (Object)null)
		{
			Debug.LogWarning((object)("Error creating corpse: " + ((object)((Component)this).gameObject)?.ToString() + " - " + strCorpsePrefab));
			return null;
		}
		baseCorpse.ServerInitCorpse(this, posOnDeath, rotOnDeath, playerFlagsOnDeath, modelState);
		return baseCorpse;
	}

	public override void UpdateNetworkGroup()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(base.isServer, "UpdateNetworkGroup called on clientside entity!");
		isCallingUpdateNetworkGroup = false;
		if (net == null || Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateNetworkGroup", 0);
		try
		{
			if (globalBroadcast)
			{
				if (net.SwitchGroup(BaseNetworkable.GlobalNetworkGroup))
				{
					SendNetworkGroupChange();
				}
			}
			else if (ShouldInheritNetworkGroup() && parentEntity.IsSet())
			{
				BaseEntity baseEntity = GetParentEntity();
				if (!baseEntity.IsValid())
				{
					if (!Application.isLoadingSave)
					{
						NetworkableId uid = parentEntity.uid;
						Debug.LogWarning((object)("UpdateNetworkGroup: Missing parent entity " + ((object)(NetworkableId)(ref uid)/*cast due to .constrained prefix*/).ToString()));
						((FacepunchBehaviour)this).Invoke((Action)UpdateNetworkGroup, 2f);
						isCallingUpdateNetworkGroup = true;
					}
				}
				else if ((Object)(object)baseEntity != (Object)null)
				{
					if (net.SwitchGroup(baseEntity.net.group))
					{
						SendNetworkGroupChange();
					}
				}
				else
				{
					Debug.LogWarning((object)(((object)((Component)this).gameObject)?.ToString() + ": has parent id - but couldn't find parent! " + parentEntity));
				}
			}
			else if (base.limitNetworking && !(this is BasePlayer))
			{
				if (net.SwitchGroup(BaseNetworkable.LimboNetworkGroup))
				{
					SendNetworkGroupChange();
				}
			}
			else
			{
				base.UpdateNetworkGroup();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Eat(BaseNpc baseNpc, float timeSpent)
	{
		baseNpc.AddCalories(100f);
	}

	public virtual void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
	}

	public override bool ShouldNetworkTo(BasePlayer player)
	{
		if ((Object)(object)player == (Object)(object)this)
		{
			return true;
		}
		if (IsTransferProtected())
		{
			return false;
		}
		BaseEntity baseEntity = GetParentEntity();
		if (base.limitNetworking)
		{
			if ((Object)(object)baseEntity == (Object)null)
			{
				return false;
			}
			if ((Object)(object)baseEntity != (Object)(object)player)
			{
				return false;
			}
		}
		if (ShouldInheritNetworkGroup() && (Object)(object)baseEntity != (Object)null)
		{
			return baseEntity.ShouldNetworkTo(player);
		}
		return base.ShouldNetworkTo(player);
	}

	public virtual void AttackerInfo(DeathInfo info)
	{
		info.attackerName = base.ShortPrefabName;
		info.attackerSteamID = 0uL;
		info.inflictorName = "";
	}

	public virtual void Push(Vector3 velocity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SetVelocity(velocity);
	}

	public virtual void ApplyInheritedVelocity(Vector3 velocity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.velocity = Vector3.Lerp(component.velocity, velocity, 10f * Time.fixedDeltaTime);
			component.angularVelocity *= Mathf.Clamp01(1f - 10f * Time.fixedDeltaTime);
			component.AddForce(-Physics.gravity * Mathf.Clamp01(0.9f), (ForceMode)5);
		}
	}

	public virtual void SetVelocity(Vector3 velocity)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.velocity = velocity;
		}
	}

	public virtual void SetAngularVelocity(Vector3 velocity)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.angularVelocity = velocity;
		}
	}

	public virtual Vector3 GetDropPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public virtual Vector3 GetDropVelocity()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetInheritedDropVelocity() + Vector3.up;
	}

	public virtual bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		return true;
	}

	public virtual string Admin_Who()
	{
		return $"Owner ID: {OwnerID}";
	}

	public virtual bool BuoyancyWake()
	{
		return false;
	}

	public virtual bool BuoyancySleep(bool inWater)
	{
		return false;
	}

	public virtual float RadiationProtection()
	{
		return 0f;
	}

	public virtual float RadiationExposureFraction()
	{
		return 1f;
	}

	[RPC_Server.FromOwner(true)]
	[RPC_Server]
	private void BroadcastSignalFromClient(RPCMessage msg)
	{
		uint num = StringPool.Get("BroadcastSignalFromClient");
		if (num == 0)
		{
			return;
		}
		BasePlayer player = msg.player;
		if (!((Object)(object)player == (Object)null) && player.rpcHistory.TryIncrement(num, (ulong)ConVar.Server.maxpacketspersecond_rpc_signal))
		{
			Signal signal = (Signal)msg.read.Int32();
			string arg = msg.read.String(256, false);
			if (!BroadcastSignalFromClientFilter(signal))
			{
				SignalBroadcast(signal, arg, msg.connection);
				OnReceivedSignalServer(signal, arg);
			}
		}
	}

	protected virtual bool BroadcastSignalFromClientFilter(Signal signal)
	{
		return false;
	}

	protected virtual void OnReceivedSignalServer(Signal signal, string arg)
	{
		SingletonComponent<NpcFireManager>.Instance.OnReceivedSignalServer(this, signal, arg);
	}

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", (object)this, (object)sourceConnection) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServerEx", this, (SendMethod)2, (Priority)0), (int)signal, arg, sourceConnection?.userid ?? 0);
		}
	}

	public void SignalBroadcast(Signal signal, Connection sourceConnection = null)
	{
		if (net != null && net.group != null && !base.limitNetworking && Interface.CallHook("OnSignalBroadcast", (object)this) == null)
		{
			ClientRPC(RpcTarget.NetworkGroup("SignalFromServer", this, (SendMethod)2, (Priority)0), (int)signal, sourceConnection?.userid ?? 0);
		}
	}

	private bool IsEffectVisibleTo(BasePlayer player)
	{
		if (IsUnderground())
		{
			return player.IsUnderground();
		}
		return true;
	}

	public void SignalBroadcast(Signal signal, string arg, Connection sourceConnection, string fallbackEffect, float maxDistance = 0f)
	{
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		bool flag = maxDistance > 0f;
		if ((!flag || !ConVar.Server.long_distance_sounds) && !ServerOcclusion.OcclusionEnabled)
		{
			SignalBroadcast(signal, arg, sourceConnection);
		}
		else
		{
			if (net == null || net.group == null)
			{
				return;
			}
			PooledHashSet<ulong> val = Pool.Get<PooledHashSet<ulong>>();
			try
			{
				PooledList<Connection> val2 = Pool.Get<PooledList<Connection>>();
				try
				{
					PooledList<Connection> val3 = Pool.Get<PooledList<Connection>>();
					try
					{
						foreach (Connection subscriber in net.group.subscribers)
						{
							if (subscriber.player is BasePlayer basePlayer && !((Object)(object)basePlayer == (Object)null))
							{
								((HashSet<ulong>)(object)val).Add(basePlayer.userID.Get());
								if (ShouldNetworkTo(basePlayer))
								{
									((List<Connection>)(object)val2).Add(subscriber);
								}
								else if (IsEffectVisibleTo(basePlayer))
								{
									((List<Connection>)(object)val3).Add(subscriber);
								}
							}
						}
						if (flag)
						{
							TimeWarning val4 = TimeWarning.New("BaseEntity.Signal.LongDistanceSound", 0);
							try
							{
								foreach (Connection item in BaseNetworkable.GetConnectionsWithin(((Component)this).transform.position, maxDistance))
								{
									if (item.player is BasePlayer basePlayer2 && !((Object)(object)basePlayer2 == (Object)null) && !((HashSet<ulong>)(object)val).Contains(basePlayer2.userID.Get()) && IsEffectVisibleTo(basePlayer2))
									{
										((List<Connection>)(object)val3).Add(item);
									}
								}
							}
							finally
							{
								((IDisposable)val4)?.Dispose();
							}
						}
						if (((List<Connection>)(object)val2).Count > 0)
						{
							ClientRPC(RpcTarget.Players("SignalFromServerEx", (List<Connection>)(object)val2, (SendMethod)2, (Priority)0), (int)signal, arg, sourceConnection?.userid ?? 0);
						}
						if (((List<Connection>)(object)val3).Count > 0)
						{
							Effect.server.Run(fallbackEffect, ((Component)this).transform.position, ((Component)this).transform.up, sourceConnection, broadcast: false, (List<Connection>)(object)val3);
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	protected virtual void OnSkinChanged(ulong oldSkinID, ulong newSkinID)
	{
		if (oldSkinID != newSkinID)
		{
			skinID = newSkinID;
		}
	}

	protected virtual void OnSkinPreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (clientside && Skinnable.All != null && (Object)(object)Skinnable.FindForEntity(name) != (Object)null)
		{
			WorkshopSkin.Prepare(rootObj);
			MaterialReplacement.Prepare(rootObj);
		}
	}

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		OnSkinPreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
	}

	public bool HasAnySlot()
	{
		for (int i = 0; i < entitySlots.Length; i++)
		{
			if (entitySlots[i].IsValid(base.isServer))
			{
				return true;
			}
		}
		return false;
	}

	public BaseEntity GetSlot(Slot slot)
	{
		return entitySlots[(int)slot].Get(base.isServer);
	}

	public BaseLock GetLock()
	{
		return GetSlot(Slot.Lock) as BaseLock;
	}

	public string GetSlotAnchorName(Slot slot)
	{
		return slot.ToString().ToLower();
	}

	public void SetSlot(Slot slot, BaseEntity ent)
	{
		entitySlots[(int)slot].Set(ent);
		SendNetworkUpdate();
	}

	public EntityRef[] GetSlots()
	{
		return entitySlots;
	}

	public void SetSlots(EntityRef[] newSlots)
	{
		entitySlots = newSlots;
	}

	public virtual bool HasSlot(Slot slot)
	{
		return false;
	}

	protected void QueueSyncVar(byte nameID)
	{
		if (base.isServer)
		{
			if (nameID >= 32)
			{
				Debug.LogError((object)$"nameID {nameID} is out of bitmask range (must be 0-{31})");
				return;
			}
			WarmupSyncVars();
			_serverSyncVarQueue |= (uint)(1 << (int)nameID);
		}
	}

	private void SendPackedSyncVarQueue()
	{
		SV_PackedSyncVarSendQueue();
	}

	private void SyncVarNetSend(NetWrite write, SendInfo sendInfo)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		write.Send(sendInfo);
	}

	public void WarmupSyncVars()
	{
		if (_sendPackedSyncVarQueueAction == null)
		{
			_sendPackedSyncVarQueueAction = SendPackedSyncVarQueue;
		}
		if (!((FacepunchBehaviour)this).IsInvoking(_sendPackedSyncVarQueueAction))
		{
			((FacepunchBehaviour)this).Invoke(_sendPackedSyncVarQueueAction, 0.0333f);
		}
	}

	public void StopSyncVars()
	{
		if (((FacepunchBehaviour)this).IsInvoking(_sendPackedSyncVarQueueAction))
		{
			((FacepunchBehaviour)this).CancelInvoke(_sendPackedSyncVarQueueAction);
		}
	}

	protected NetWrite SV_PackedSyncVarNetStart()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PackedSyncVar", 0);
		try
		{
			NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
			TimeWarning val3 = TimeWarning.New("Headers", 0);
			try
			{
				val2.PacketID((Type)28);
				val2.EntityID(net.ID);
				val2.UInt32(_serverSyncVarQueue);
				return val2;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void SV_PackedSyncVarSendQueue()
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (_serverSyncVarQueue == 0 || Net.sv == null || !((BaseNetwork)Net.sv).IsConnected() || net == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PackedSyncVarQueue", 0);
		try
		{
			SendDemoTransientEntity();
			NetWrite val2 = SV_PackedSyncVarNetStart();
			for (byte b = 0; b < 32; b++)
			{
				if ((_serverSyncVarQueue & (uint)(1 << (int)b)) != 0)
				{
					WriteSyncVar(b, val2);
					HandleCache(b);
				}
			}
			_serverSyncVarQueue = 0u;
			SyncVarNetSend(val2, new SendInfo(net.group.subscribers));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private NetWrite SV_SyncVarNetStart(byte nameID)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SyncVar", 0);
		try
		{
			SendDemoTransientEntity();
			NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
			TimeWarning val3 = TimeWarning.New("Headers", 0);
			try
			{
				val2.PacketID((Type)27);
				val2.EntityID(net.ID);
				val2.UInt8(nameID);
				return val2;
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void SV_SyncVarSend(byte nameID)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv != null && ((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			NetWrite val = SV_SyncVarNetStart(nameID);
			WriteSyncVar(nameID, val);
			HandleCache(nameID);
			SyncVarNetSend(val, new SendInfo(net.group.subscribers));
		}
	}

	protected void SyncVarNetWrite<T>(NetWrite write, T arg)
	{
		TimeWarning val = TimeWarning.New("Objects", 0);
		try
		{
			write.WriteObject(arg);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void HandleCache(byte nameID)
	{
		if (ShouldInvalidateCache(nameID))
		{
			InvalidateNetworkCache();
		}
	}

	public bool HasTrait(TraitFlag f)
	{
		return (Traits & f) == f;
	}

	public bool HasAnyTrait(TraitFlag f)
	{
		return (Traits & f) != 0;
	}

	public virtual bool EnterTrigger(TriggerBase trigger)
	{
		if (triggers == null)
		{
			triggers = Pool.Get<List<TriggerBase>>();
		}
		triggers.Add(trigger);
		return true;
	}

	public virtual void LeaveTrigger(TriggerBase trigger)
	{
		if (triggers != null)
		{
			triggers.Remove(trigger);
			if (triggers.Count == 0)
			{
				Pool.FreeUnmanaged<TriggerBase>(ref triggers);
			}
		}
	}

	public void RemoveFromTriggers()
	{
		if (triggers == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("RemoveFromTriggers", 0);
		try
		{
			List<TriggerBase> list = List.ShallowClonePooled<TriggerBase>(triggers);
			foreach (TriggerBase item in list)
			{
				if (Object.op_Implicit((Object)(object)item))
				{
					item.RemoveEntity(this);
				}
			}
			Pool.FreeUnmanaged<TriggerBase>(ref list);
			if (triggers != null && triggers.Count == 0)
			{
				Pool.FreeUnmanaged<TriggerBase>(ref triggers);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public T FindTrigger<T>() where T : TriggerBase
	{
		if (triggers == null)
		{
			return null;
		}
		foreach (TriggerBase trigger in triggers)
		{
			if (!((Object)(object)(trigger as T) == (Object)null))
			{
				return trigger as T;
			}
		}
		return null;
	}

	public bool FindTrigger<T>(out T result) where T : TriggerBase
	{
		result = FindTrigger<T>();
		return (Object)(object)result != (Object)null;
	}

	private void ForceUpdateTriggersAction()
	{
		if (!base.IsDestroyed)
		{
			ForceUpdateTriggers(enter: false, exit: true, invoke: false);
		}
	}

	public void ForceUpdateTriggers(bool enter = true, bool exit = true, bool invoke = true)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		List<TriggerBase> list = Pool.Get<List<TriggerBase>>();
		List<TriggerBase> list2 = Pool.Get<List<TriggerBase>>();
		if (triggers != null)
		{
			list.AddRange(triggers);
		}
		Collider componentInChildren = ((Component)this).GetComponentInChildren<Collider>();
		if (componentInChildren is CapsuleCollider)
		{
			CapsuleCollider val = (CapsuleCollider)(object)((componentInChildren is CapsuleCollider) ? componentInChildren : null);
			Vector3 point = ((Component)this).transform.position + new Vector3(0f, val.radius, 0f);
			Vector3 point2 = ((Component)this).transform.position + new Vector3(0f, val.height - val.radius, 0f);
			GamePhysics.OverlapCapsule<TriggerBase>(point, point2, val.radius, list2, 262144, (QueryTriggerInteraction)2);
		}
		else if (componentInChildren is BoxCollider)
		{
			BoxCollider val2 = (BoxCollider)(object)((componentInChildren is BoxCollider) ? componentInChildren : null);
			GamePhysics.OverlapOBB<TriggerBase>(new OBB(((Component)this).transform.position, ((Component)this).transform.lossyScale, ((Component)this).transform.rotation, new Bounds(val2.center, val2.size)), list2, 262144, (QueryTriggerInteraction)2);
		}
		else if (componentInChildren is SphereCollider)
		{
			SphereCollider val3 = (SphereCollider)(object)((componentInChildren is SphereCollider) ? componentInChildren : null);
			GamePhysics.OverlapSphere<TriggerBase>(((Component)this).transform.TransformPoint(val3.center), val3.radius, list2, 262144, (QueryTriggerInteraction)2);
		}
		else
		{
			list2.AddRange(list);
		}
		if (exit)
		{
			foreach (TriggerBase item in list)
			{
				if (!list2.Contains(item))
				{
					item.OnTriggerExit(componentInChildren);
				}
			}
		}
		if (enter)
		{
			foreach (TriggerBase item2 in list2)
			{
				if (!list.Contains(item2))
				{
					item2.OnTriggerEnter(componentInChildren);
				}
			}
		}
		Pool.FreeUnmanaged<TriggerBase>(ref list);
		Pool.FreeUnmanaged<TriggerBase>(ref list2);
		if (invoke)
		{
			((FacepunchBehaviour)this).Invoke((Action)ForceUpdateTriggersAction, Time.time - Time.fixedTime + Time.fixedDeltaTime * 1.5f);
		}
	}

	public virtual bool InHostileWarningZone()
	{
		if (triggers == null)
		{
			return false;
		}
		for (int i = 0; i < triggers.Count; i++)
		{
			TriggerHostileWarningZone triggerHostileWarningZone = triggers[i] as TriggerHostileWarningZone;
			if (!((Object)(object)triggerHostileWarningZone == (Object)null) && triggerHostileWarningZone.WarningEnabled(this))
			{
				return true;
			}
		}
		return false;
	}

	public virtual bool InSafeZone()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.safeZone)
		{
			return false;
		}
		float num = 0f;
		Vector3 position = ((Component)this).transform.position;
		if (triggers != null)
		{
			for (int i = 0; i < triggers.Count; i++)
			{
				TriggerSafeZone triggerSafeZone = triggers[i] as TriggerSafeZone;
				if (!((Object)(object)triggerSafeZone == (Object)null))
				{
					float safeLevel = triggerSafeZone.GetSafeLevel(position);
					if (safeLevel > num)
					{
						num = safeLevel;
					}
				}
			}
		}
		return num > 0f;
	}

	public TriggerParent FindSuitableParent()
	{
		if (triggers == null)
		{
			return null;
		}
		foreach (TriggerBase trigger in triggers)
		{
			if (trigger is TriggerParent triggerParent && triggerParent.ShouldParent(this, bypassOtherTriggerCheck: true))
			{
				return triggerParent;
			}
		}
		return null;
	}

	public void ClientRPC(RpcTarget target, byte arg1, bool arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt8(arg1);
			val.Bool(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, NetworkableId arg1, NetworkableId arg2)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.EntityID(arg1);
			val.EntityID(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, string arg1)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.String(arg1, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ChickenCoopStatusUpdate arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ChickenCoopStatusUpdate>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, int arg2, float arg3, float arg4)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Int32(arg2);
			val.Float(arg3);
			val.Float(arg4);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, NetworkableId arg1)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.EntityID(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, SellOrderContainer arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<SellOrderContainer>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, VendingMachineLongTermStats arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<VendingMachineLongTermStats>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, VendingMachinePurchaseHistoryMessage arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Proto<VendingMachinePurchaseHistoryMessage>(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, bool arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Bool(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, sbyte arg1, sbyte arg2, sbyte arg3)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int8(arg1);
			val.Int8(arg2);
			val.Int8(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, string arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.String(arg2, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ulong arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt64(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, EntityIdList arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<EntityIdList>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, int arg2, bool arg3)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Int32(arg2);
			val.Bool(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, string arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.String(arg2, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, string arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.String(arg2, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, bool arg1, Vector3 arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Bool(arg1);
			val.Vector3(ref arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, float arg2, Vector3 arg3, float arg4, float arg5)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.Float(arg2);
			val.Vector3(ref arg3);
			val.Float(arg4);
			val.Float(arg5);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, int arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Int32(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, NetworkableId arg2)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.EntityID(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, WireReconnectMessage arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<WireReconnectMessage>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, bool arg1, ulong arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Bool(arg1);
			val.UInt64(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, Vector3 arg2)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.Vector3(ref arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, string arg2)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.String(arg2, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, string arg1, int arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.String(arg1, false);
			val.Int32(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, uint arg2, byte[] arg3, uint arg4, byte arg5)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.UInt32(arg2);
			val.Bytes(arg3);
			val.UInt32(arg4);
			val.UInt8(arg5);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, NetworkableId arg1, byte[] arg2)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.EntityID(arg1);
			val.Bytes(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, string arg1, CopyPasteEntityInfo arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.String(arg1, false);
			val.Proto<CopyPasteEntityInfo>(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, AIDesign arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<AIDesign>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, int arg2, int arg3)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Int32(arg2);
			val.Int32(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, NetworkableId arg1, uint arg2, uint arg3, int arg4, int arg5)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.EntityID(arg1);
			val.UInt32(arg2);
			val.UInt32(arg3);
			val.Int32(arg4);
			val.Int32(arg5);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, byte[] arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Bytes(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, PhoneDirectory arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<PhoneDirectory>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, uint arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.UInt32(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, string arg1, string arg2)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.String(arg1, false);
			val.String(arg2, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ItemAmountList arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ItemAmountList>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, string arg2, ulong arg3)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.String(arg2, false);
			val.UInt64(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, ulong arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.UInt64(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, float arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Float(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, float arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.Float(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, ItemId arg2)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.ItemID(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, float arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.Float(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, int arg1, int arg2, int arg3, float arg4)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int32(arg1);
			val.Int32(arg2);
			val.Int32(arg3);
			val.Float(arg4);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, bool arg1, bool arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Bool(arg1);
			val.Bool(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ulong arg1, int arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt64(arg1);
			val.Int32(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, byte[] arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.Bytes(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, GlobalEntityCollection arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<GlobalEntityCollection>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, GrowableEntity arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<GrowableEntity>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, Vector3 arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.Vector3(ref arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, RoundResults arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<RoundResults>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, CardList arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<CardList>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, NetworkableId arg1, Vector3 arg2, Vector3 arg3)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.EntityID(arg1);
			val.Vector3(ref arg2);
			val.Vector3(ref arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, PlayerModifiers arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<PlayerModifiers>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, NetworkableId arg2)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.EntityID(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, byte[] arg2, string arg3, uint arg4, int arg5)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.Bytes(arg2);
			val.String(arg3, false);
			val.UInt32(arg4);
			val.Int32(arg5);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, PlayerTeam arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<PlayerTeam>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, string arg1, ulong arg2, ulong arg3)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.String(arg1, false);
			val.UInt64(arg2);
			val.UInt64(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, MapNote arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<MapNote>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, MapNoteList arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<MapNoteList>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ModelState arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ModelState>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, ulong arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.UInt64(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, uint arg1, NetworkableId arg2)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt32(arg1);
			val.EntityID(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, RespawnInformation arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<RespawnInformation>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, int arg2, int arg3)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.Int32(arg2);
			val.Int32(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, SpectateTeamInfo arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<SpectateTeamInfo>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, float arg2, float arg3)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.Float(arg2);
			val.Float(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, NetworkableId arg1, string arg2, string arg3)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.EntityID(arg1);
			val.String(arg2, false);
			val.String(arg3, false);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, UpdateItemContainer arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<UpdateItemContainer>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, PlayerUpdateLoot arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<PlayerUpdateLoot>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, PlayerMetabolism arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<PlayerMetabolism>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Vector3 arg1, bool arg2)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Vector3(ref arg1);
			val.Bool(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, float arg2, byte arg3, float arg4, byte arg5, float arg6)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.Float(arg2);
			val.UInt8(arg3);
			val.Float(arg4);
			val.UInt8(arg5);
			val.Float(arg6);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, float arg2, byte arg3, float arg4, float arg5, float arg6)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.Float(arg2);
			val.UInt8(arg3);
			val.Float(arg4);
			val.Float(arg5);
			val.Float(arg6);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, float arg2, byte arg3, float arg4, float arg5)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.Float(arg2);
			val.UInt8(arg3);
			val.Float(arg4);
			val.Float(arg5);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ushort arg1, byte arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.UInt16(arg1);
			val.UInt8(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, short arg1, int arg2, int arg3)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int16(arg1);
			val.Int32(arg2);
			val.Int32(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, short arg1, short arg2)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int16(arg1);
			val.Int16(arg2);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, float arg2, byte arg3, byte arg4, byte arg5)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.Float(arg2);
			val.UInt8(arg3);
			val.UInt8(arg4);
			val.UInt8(arg5);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, byte arg2, float arg3, byte arg4)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.UInt8(arg2);
			val.Float(arg3);
			val.UInt8(arg4);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, byte arg2, float arg3, float arg4)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.UInt8(arg2);
			val.Float(arg3);
			val.Float(arg4);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, float arg1, byte arg2, int arg3, float arg4)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Float(arg1);
			val.UInt8(arg2);
			val.Int32(arg3);
			val.Float(arg4);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, sbyte arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int8(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, UpdateItem arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<UpdateItem>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, IndustrialConveyorTransfer arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<IndustrialConveyorTransfer>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ItemFilterList arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ItemFilterList>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ClanActionResult arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ClanActionResult>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ClanLog arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ClanLog>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, ClanInvitations arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<ClanInvitations>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, long arg1, string arg2, int arg3, Color32 arg4)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int64(arg1);
			val.String(arg2, false);
			val.Int32(arg3);
			val.Color32(ref arg4);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, long arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Int64(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, string arg1, int arg2, bool arg3)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.String(arg1, false);
			val.Int32(arg2);
			val.Bool(arg3);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Tree arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<Tree>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, TreeList arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<TreeList>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, PlayerRelationships arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<PlayerRelationships>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}

	public void ClientRPC(RpcTarget target, Ragdoll arg1)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected() && net != null)
		{
			GetRpcTargetNetworkGroup(ref target);
			NetWrite val = ClientRPCStart(target.Function);
			val.Proto<Ragdoll>(arg1);
			ClientRPCSend(val, target.Connections);
			FreeRPCTarget(target);
		}
	}
}


using System;
using UnityEngine;

public class Menu : Attribute
{
	[Serializable]
	public struct Option
	{
		public Phrase name;

		public Phrase description;

		public Sprite icon;

		public int order;

		public bool usableWhileWounded;
	}

	public class Description : Attribute
	{
		public string token;

		public string english;

		public Description(string t, string e)
		{
			token = t;
			english = e;
		}
	}

	public class Icon : Attribute
	{
		public string icon;

		public Icon(string i)
		{
			icon = i;
		}
	}

	public class ShowIf : Attribute
	{
		public string functionName;

		public ShowIf(string testFunc)
		{
			functionName = testFunc;
		}
	}

	public class DisabledIf : Attribute
	{
		public string functionName;

		public DisabledIf(string testFunc)
		{
			functionName = testFunc;
		}
	}

	public class Priority : Attribute
	{
		public string functionName;

		public Priority(string priorityFunc)
		{
			functionName = priorityFunc;
		}
	}

	public class UsableWhileWounded : Attribute
	{
	}

	public string TitleToken;

	public string TitleEnglish;

	public string UseVariable;

	public int Order;

	public string ProxyFunction;

	public float Time;

	public string OnStart;

	public string OnProgress;

	public bool LongUseOnly;

	public bool PrioritizeIfNotWhitelisted;

	public bool PrioritizeIfUnlocked;

	public Menu()
	{
	}

	public Menu(string menuTitleToken, string menuTitleEnglish)
	{
		TitleToken = menuTitleToken;
		TitleEnglish = menuTitleEnglish;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Option
{
	public Phrase name;

	public Phrase description;

	public Sprite icon;

	public int order;

	public bool usableWhileWounded;
}


using System;

public class Description : Attribute
{
	public string token;

	public string english;

	public Description(string t, string e)
	{
		token = t;
		english = e;
	}
}


using System;

public class Icon : Attribute
{
	public string icon;

	public Icon(string i)
	{
		icon = i;
	}
}


using System;

public class ShowIf : Attribute
{
	public string functionName;

	public ShowIf(string testFunc)
	{
		functionName = testFunc;
	}
}


using System;

public class DisabledIf : Attribute
{
	public string functionName;

	public DisabledIf(string testFunc)
	{
		functionName = testFunc;
	}
}


using System;

public class Priority : Attribute
{
	public string functionName;

	public Priority(string priorityFunc)
	{
		functionName = priorityFunc;
	}
}


using System;

public class UsableWhileWounded : Attribute
{
}


using System;

[Serializable]
public struct MovementModify
{
	public float drag;
}


public enum GiveItemReason
{
	Generic,
	ResourceHarvested,
	PickedUp,
	Crafted
}


using System;

[Flags]
public enum Flags
{
	Placeholder = 1,
	On = 2,
	OnFire = 4,
	Open = 8,
	Locked = 0x10,
	Debugging = 0x20,
	Disabled = 0x40,
	Reserved1 = 0x80,
	Reserved2 = 0x100,
	Reserved3 = 0x200,
	Reserved4 = 0x400,
	Reserved5 = 0x800,
	Broken = 0x1000,
	Busy = 0x2000,
	Reserved6 = 0x4000,
	Reserved7 = 0x8000,
	Reserved8 = 0x10000,
	Reserved9 = 0x20000,
	Reserved10 = 0x40000,
	Reserved11 = 0x80000,
	InUse = 0x100000,
	Reserved12 = 0x200000,
	Reserved13 = 0x400000,
	Unused23 = 0x800000,
	Protected = 0x1000000,
	Transferring = 0x2000000,
	Reserved14 = 0x4000000,
	Reserved15 = 0x8000000,
	Reserved16 = 0x10000000,
	Reserved17 = 0x20000000,
	Reserved18 = 0x40000000,
	Reserved19 = int.MinValue
}


using System;
using UnityEngine;

private readonly struct QueuedFileRequest : IEquatable<QueuedFileRequest>
{
	public readonly BaseEntity Entity;

	public readonly FileStorage.Type Type;

	public readonly uint Part;

	public readonly uint Crc;

	public readonly uint ResponseFunction;

	public readonly bool? RespondIfNotFound;

	public QueuedFileRequest(BaseEntity entity, FileStorage.Type type, uint part, uint crc, uint responseFunction, bool? respondIfNotFound)
	{
		Entity = entity;
		Type = type;
		Part = part;
		Crc = crc;
		ResponseFunction = responseFunction;
		RespondIfNotFound = respondIfNotFound;
	}

	public bool Equals(QueuedFileRequest other)
	{
		if (object.Equals(Entity, other.Entity) && Type == other.Type && Part == other.Part && Crc == other.Crc && ResponseFunction == other.ResponseFunction)
		{
			return RespondIfNotFound == other.RespondIfNotFound;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is QueuedFileRequest other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (int)(((((((((uint)((((Object)(object)Entity != (Object)null) ? ((object)Entity).GetHashCode() : 0) * 397) ^ (uint)Type) * 397) ^ Part) * 397) ^ Crc) * 397) ^ ResponseFunction) * 397) ^ RespondIfNotFound.GetHashCode();
	}
}


using System;
using UnityEngine;

private readonly struct PendingFileRequest : IEquatable<PendingFileRequest>
{
	public readonly FileStorage.Type Type;

	public readonly uint NumId;

	public readonly uint Crc;

	public readonly IServerFileReceiver Receiver;

	public readonly float Time;

	public PendingFileRequest(FileStorage.Type type, uint numId, uint crc, IServerFileReceiver receiver)
	{
		Type = type;
		NumId = numId;
		Crc = crc;
		Receiver = receiver;
		Time = Time.realtimeSinceStartup;
	}

	public bool Equals(PendingFileRequest other)
	{
		if (Type == other.Type && NumId == other.NumId && Crc == other.Crc)
		{
			return object.Equals(Receiver, other.Receiver);
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is PendingFileRequest other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (int)(((((uint)((int)Type * 397) ^ NumId) * 397) ^ Crc) * 397) ^ ((Receiver != null) ? Receiver.GetHashCode() : 0);
	}
}


using System;
using System.Collections.Generic;
using Spatial;
using UnityEngine;

public static class Query
{
	public enum DistanceCheckType
	{
		None,
		OnlyCenter,
		Bounds
	}

	public class EntityTree
	{
		public Grid<BaseEntity> Grid;

		public Grid<BasePlayer> PlayerGrid;

		public Grid<BaseEntity> BrainGrid;

		public EntityTree(float worldSize)
		{
			Grid = new Grid<BaseEntity>(32, worldSize);
			PlayerGrid = new Grid<BasePlayer>(32, worldSize);
			BrainGrid = new Grid<BaseEntity>(32, worldSize);
		}

		public void Add(BaseEntity ent)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position = ((Component)ent).transform.position;
			Grid.Add(ent, position.x, position.z);
		}

		public void AddPlayer(BasePlayer player)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position = ((Component)player).transform.position;
			PlayerGrid.Add(player, position.x, position.z);
		}

		public void AddBrain(BaseEntity entity)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position = ((Component)entity).transform.position;
			BrainGrid.Add(entity, position.x, position.z);
		}

		public void Remove(BaseEntity ent, bool isPlayer = false)
		{
			Grid.Remove(ent);
			if (isPlayer)
			{
				BasePlayer basePlayer = ent as BasePlayer;
				if ((Object)(object)basePlayer != (Object)null)
				{
					PlayerGrid.Remove(basePlayer);
				}
			}
		}

		public void RemovePlayer(BasePlayer player)
		{
			PlayerGrid.Remove(player);
		}

		public void RemoveBrain(BaseEntity entity)
		{
			if (!((Object)(object)entity == (Object)null))
			{
				BrainGrid.Remove(entity);
			}
		}

		public void Move(BaseEntity ent)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position = ((Component)ent).transform.position;
			Grid.Move(ent, position.x, position.z);
			BasePlayer basePlayer = ent as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null)
			{
				MovePlayer(basePlayer);
			}
			if (ent.HasBrain)
			{
				MoveBrain(ent);
			}
		}

		public void MovePlayer(BasePlayer player)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position = ((Component)player).transform.position;
			PlayerGrid.Move(player, position.x, position.z);
		}

		public void MoveBrain(BaseEntity entity)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			Vector3 position = ((Component)entity).transform.position;
			BrainGrid.Move(entity, position.x, position.z);
		}

		public void GetInSphere<T>(Vector3 position, float distance, List<T> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter) where T : BaseEntity
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("GetInSphereList", 0);
			try
			{
				Grid.Query<T>(position.x, position.z, distance, results);
				if (distanceCheckType != 0)
				{
					NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public int GetInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			int broadCount = Grid.Query(position.x, position.z, distance, results, filter);
			return NarrowPhaseReduce(position, distance, results, broadCount);
		}

		public int GetInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return Grid.Query(position.x, position.z, distance, results, filter);
		}

		public void GetPlayersInSphere(Vector3 position, float distance, List<BasePlayer> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter, bool includeHumanoidNpcs = false)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("GetPlayersInSphereList", 0);
			try
			{
				PlayerGrid.Query<BasePlayer>(position.x, position.z, distance, results);
				if (!includeHumanoidNpcs)
				{
					for (int num = results.Count - 1; num >= 0; num--)
					{
						if (results[num].IsNpc)
						{
							results.RemoveAt(num);
						}
					}
				}
				if (distanceCheckType != 0)
				{
					NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public int GetPlayersInSphere(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			int broadCount = PlayerGrid.Query(position.x, position.z, distance, results, filter);
			return NarrowPhaseReduce(position, distance, results, broadCount);
		}

		public int GetPlayersInSphereFast(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return PlayerGrid.Query(position.x, position.z, distance, results, filter);
		}

		public void GetBrainsInSphere<T>(Vector3 position, float distance, List<T> results, bool filterPastDistance = true) where T : BaseEntity
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("GetBrainsInSphereList", 0);
			try
			{
				BrainGrid.Query<T>(position.x, position.z, distance, results);
				if (filterPastDistance)
				{
					NarrowPhaseReduce(position, distance, results);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		public int GetBrainsInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			int broadCount = BrainGrid.Query(position.x, position.z, distance, results, filter);
			return NarrowPhaseReduce(position, distance, results, broadCount);
		}

		public int GetBrainsInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return BrainGrid.Query(position.x, position.z, distance, results, filter);
		}

		public void GetPlayersAndBrainsInSphere(Vector3 position, float distance, List<BaseEntity> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("GetPlayersAndBrainsInSphereList", 0);
			try
			{
				PlayerGrid.Query<BaseEntity>(position.x, position.z, distance, results);
				BrainGrid.Query<BaseEntity>(position.x, position.z, distance, results);
				if (distanceCheckType != 0)
				{
					NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		private int NarrowPhaseReduce<T>(Vector3 position, float radius, T[] results, int broadCount) where T : BaseEntity
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("NarrowPhaseReduce", 0);
			try
			{
				int num = broadCount;
				float num2 = radius * radius;
				for (int i = 0; i < num; i++)
				{
					OBB val2 = results[i].WorldSpaceBounds();
					Vector3 val3 = ((OBB)(ref val2)).ClosestPoint(position) - position;
					if (((Vector3)(ref val3)).sqrMagnitude > num2)
					{
						results[i] = results[num - 1];
						num--;
						i--;
					}
				}
				return num;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		private static void NarrowPhaseReduce<T>(Vector3 position, float radius, List<T> results, bool onlyConsiderCenter = true) where T : BaseEntity
		{
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("NarrowPhaseReduceList", 0);
			try
			{
				float num = radius * radius;
				for (int num2 = results.Count - 1; num2 >= 0; num2--)
				{
					T val2 = results[num2];
					Vector3 val4;
					if (!onlyConsiderCenter)
					{
						OBB val3 = val2.WorldSpaceBounds();
						val4 = ((OBB)(ref val3)).ClosestPoint(position);
					}
					else
					{
						val4 = ((Component)val2).transform.position;
					}
					Vector3 val5 = val4 - position;
					if (((Vector3)(ref val5)).sqrMagnitude > num)
					{
						results.RemoveAt(num2);
					}
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}

		private static bool IsEntityInRadius<T>(Vector3 position, float radiusSq, T entity) where T : BaseEntity
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			TimeWarning val = TimeWarning.New("IsEntityInRadius", 0);
			try
			{
				OBB val2 = entity.WorldSpaceBounds();
				Vector3 val3 = ((OBB)(ref val2)).ClosestPoint(position) - position;
				return ((Vector3)(ref val3)).sqrMagnitude < radiusSq;
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static EntityTree Server;
}


public enum DistanceCheckType
{
	None,
	OnlyCenter,
	Bounds
}


using System;
using System.Collections.Generic;
using Spatial;
using UnityEngine;

public class EntityTree
{
	public Grid<BaseEntity> Grid;

	public Grid<BasePlayer> PlayerGrid;

	public Grid<BaseEntity> BrainGrid;

	public EntityTree(float worldSize)
	{
		Grid = new Grid<BaseEntity>(32, worldSize);
		PlayerGrid = new Grid<BasePlayer>(32, worldSize);
		BrainGrid = new Grid<BaseEntity>(32, worldSize);
	}

	public void Add(BaseEntity ent)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)ent).transform.position;
		Grid.Add(ent, position.x, position.z);
	}

	public void AddPlayer(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)player).transform.position;
		PlayerGrid.Add(player, position.x, position.z);
	}

	public void AddBrain(BaseEntity entity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)entity).transform.position;
		BrainGrid.Add(entity, position.x, position.z);
	}

	public void Remove(BaseEntity ent, bool isPlayer = false)
	{
		Grid.Remove(ent);
		if (isPlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			if ((Object)(object)basePlayer != (Object)null)
			{
				PlayerGrid.Remove(basePlayer);
			}
		}
	}

	public void RemovePlayer(BasePlayer player)
	{
		PlayerGrid.Remove(player);
	}

	public void RemoveBrain(BaseEntity entity)
	{
		if (!((Object)(object)entity == (Object)null))
		{
			BrainGrid.Remove(entity);
		}
	}

	public void Move(BaseEntity ent)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)ent).transform.position;
		Grid.Move(ent, position.x, position.z);
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			MovePlayer(basePlayer);
		}
		if (ent.HasBrain)
		{
			MoveBrain(ent);
		}
	}

	public void MovePlayer(BasePlayer player)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)player).transform.position;
		PlayerGrid.Move(player, position.x, position.z);
	}

	public void MoveBrain(BaseEntity entity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)entity).transform.position;
		BrainGrid.Move(entity, position.x, position.z);
	}

	public void GetInSphere<T>(Vector3 position, float distance, List<T> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter) where T : BaseEntity
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetInSphereList", 0);
		try
		{
			Grid.Query<T>(position.x, position.z, distance, results);
			if (distanceCheckType != 0)
			{
				NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int GetInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		int broadCount = Grid.Query(position.x, position.z, distance, results, filter);
		return NarrowPhaseReduce(position, distance, results, broadCount);
	}

	public int GetInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Grid.Query(position.x, position.z, distance, results, filter);
	}

	public void GetPlayersInSphere(Vector3 position, float distance, List<BasePlayer> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter, bool includeHumanoidNpcs = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPlayersInSphereList", 0);
		try
		{
			PlayerGrid.Query<BasePlayer>(position.x, position.z, distance, results);
			if (!includeHumanoidNpcs)
			{
				for (int num = results.Count - 1; num >= 0; num--)
				{
					if (results[num].IsNpc)
					{
						results.RemoveAt(num);
					}
				}
			}
			if (distanceCheckType != 0)
			{
				NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int GetPlayersInSphere(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		int broadCount = PlayerGrid.Query(position.x, position.z, distance, results, filter);
		return NarrowPhaseReduce(position, distance, results, broadCount);
	}

	public int GetPlayersInSphereFast(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return PlayerGrid.Query(position.x, position.z, distance, results, filter);
	}

	public void GetBrainsInSphere<T>(Vector3 position, float distance, List<T> results, bool filterPastDistance = true) where T : BaseEntity
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetBrainsInSphereList", 0);
		try
		{
			BrainGrid.Query<T>(position.x, position.z, distance, results);
			if (filterPastDistance)
			{
				NarrowPhaseReduce(position, distance, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int GetBrainsInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		int broadCount = BrainGrid.Query(position.x, position.z, distance, results, filter);
		return NarrowPhaseReduce(position, distance, results, broadCount);
	}

	public int GetBrainsInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return BrainGrid.Query(position.x, position.z, distance, results, filter);
	}

	public void GetPlayersAndBrainsInSphere(Vector3 position, float distance, List<BaseEntity> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPlayersAndBrainsInSphereList", 0);
		try
		{
			PlayerGrid.Query<BaseEntity>(position.x, position.z, distance, results);
			BrainGrid.Query<BaseEntity>(position.x, position.z, distance, results);
			if (distanceCheckType != 0)
			{
				NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private int NarrowPhaseReduce<T>(Vector3 position, float radius, T[] results, int broadCount) where T : BaseEntity
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NarrowPhaseReduce", 0);
		try
		{
			int num = broadCount;
			float num2 = radius * radius;
			for (int i = 0; i < num; i++)
			{
				OBB val2 = results[i].WorldSpaceBounds();
				Vector3 val3 = ((OBB)(ref val2)).ClosestPoint(position) - position;
				if (((Vector3)(ref val3)).sqrMagnitude > num2)
				{
					results[i] = results[num - 1];
					num--;
					i--;
				}
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void NarrowPhaseReduce<T>(Vector3 position, float radius, List<T> results, bool onlyConsiderCenter = true) where T : BaseEntity
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("NarrowPhaseReduceList", 0);
		try
		{
			float num = radius * radius;
			for (int num2 = results.Count - 1; num2 >= 0; num2--)
			{
				T val2 = results[num2];
				Vector3 val4;
				if (!onlyConsiderCenter)
				{
					OBB val3 = val2.WorldSpaceBounds();
					val4 = ((OBB)(ref val3)).ClosestPoint(position);
				}
				else
				{
					val4 = ((Component)val2).transform.position;
				}
				Vector3 val5 = val4 - position;
				if (((Vector3)(ref val5)).sqrMagnitude > num)
				{
					results.RemoveAt(num2);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static bool IsEntityInRadius<T>(Vector3 position, float radiusSq, T entity) where T : BaseEntity
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsEntityInRadius", 0);
		try
		{
			OBB val2 = entity.WorldSpaceBounds();
			Vector3 val3 = ((OBB)(ref val2)).ClosestPoint(position) - position;
			return ((Vector3)(ref val3)).sqrMagnitude < radiusSq;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;

public class RPC_Shared : Attribute
{
}


using Network;

public struct RPCMessage
{
	public Connection connection;

	public BasePlayer player;

	public NetRead read;
}


using System;
using Oxide.Core;
using UnityEngine;

public class RPC_Server : RPC_Shared
{
	public abstract class Conditional : Attribute
	{
		public virtual string GetArgs()
		{
			return null;
		}
	}

	public class MaxDistance : Conditional
	{
		private float maximumDistance;

		public bool CheckParent { get; set; }

		public MaxDistance(float maxDist)
		{
			maximumDistance = maxDist;
		}

		public override string GetArgs()
		{
			return maximumDistance.ToString("0.00f") + (CheckParent ? ", true" : "");
		}

		public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)
		{
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
			{
				return false;
			}
			object obj = Interface.CallHook("OnEntityDistanceCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)maximumDistance, (object)checkParent);
			if (obj is bool)
			{
				return (bool)obj;
			}
			bool flag = ent.Distance(player.eyes.position) <= maximumDistance;
			if (checkParent && !flag)
			{
				BaseEntity parentEntity = ent.GetParentEntity();
				flag = (Object)(object)parentEntity != (Object)null && parentEntity.Distance(player.eyes.position) <= maximumDistance;
			}
			return flag;
		}
	}

	public class IsVisible : Conditional
	{
		private float maximumDistance;

		public IsVisible(float maxDist)
		{
			maximumDistance = maxDist;
		}

		public override string GetArgs()
		{
			return maximumDistance.ToString("0.00f");
		}

		public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
		{
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
			{
				return false;
			}
			object obj = Interface.CallHook("OnEntityVisibilityCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)maximumDistance);
			if (obj is bool)
			{
				return (bool)obj;
			}
			if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))
			{
				if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
				{
					return ent.IsVisible(player.eyes.position, maximumDistance);
				}
				return true;
			}
			return false;
		}
	}

	public class FromOwner : Conditional
	{
		private bool includeMounted;

		public FromOwner(bool includeMounted = false)
		{
			this.includeMounted = includeMounted;
		}

		public override string GetArgs()
		{
			return includeMounted.ToString().ToLower();
		}

		public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, bool includeMounted)
		{
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_011f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0130: Unknown result type (might be due to invalid IL or missing references)
			//IL_0135: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
			{
				return false;
			}
			if (ent.net == null || player.net == null)
			{
				return false;
			}
			object obj = Interface.CallHook("OnEntityFromOwnerCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)includeMounted);
			if (obj is bool)
			{
				return (bool)obj;
			}
			if (ent.net.ID == player.net.ID)
			{
				return true;
			}
			if (ent.parentEntity.uid != player.net.ID)
			{
				BaseEntity parentEntity = ent.GetParentEntity();
				if ((Object)(object)parentEntity != (Object)null && parentEntity.parentEntity.uid == player.net.ID)
				{
					return true;
				}
				if (includeMounted)
				{
					BaseMountable baseMountable = ent as BaseMountable;
					if ((Object)(object)baseMountable == (Object)null)
					{
						baseMountable = ent.parentEntity.Get(serverside: true) as BaseMountable;
					}
					if ((Object)(object)baseMountable != (Object)null)
					{
						NetworkableId? val = baseMountable.GetMounted()?.net?.ID;
						NetworkableId iD = player.net.ID;
						if (val.HasValue && (!val.HasValue || val.GetValueOrDefault() == iD))
						{
							return true;
						}
					}
				}
				return false;
			}
			return true;
		}
	}

	public class IsActiveItem : Conditional
	{
		public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
		{
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
			{
				return false;
			}
			if (ent.net == null || player.net == null)
			{
				return false;
			}
			object obj = Interface.CallHook("OnEntityActiveCheck", (object)ent, (object)player, (object)id, (object)debugName);
			if (obj is bool)
			{
				return (bool)obj;
			}
			if (ent.net.ID == player.net.ID)
			{
				return true;
			}
			if (ent.parentEntity.uid != player.net.ID)
			{
				return false;
			}
			Item activeItem = player.GetActiveItem();
			if (activeItem == null)
			{
				return false;
			}
			if ((Object)(object)activeItem.GetHeldEntity() != (Object)(object)ent)
			{
				return false;
			}
			return true;
		}
	}

	public class CallsPerSecond : Conditional
	{
		private ulong callsPerSecond;

		public CallsPerSecond(ulong limit)
		{
			callsPerSecond = limit;
		}

		public override string GetArgs()
		{
			return callsPerSecond.ToString();
		}

		public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, ulong callsPerSecond)
		{
			if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
			{
				return false;
			}
			return player.rpcHistory.TryIncrement(id, callsPerSecond);
		}
	}
}


using System;

public abstract class Conditional : Attribute
{
	public virtual string GetArgs()
	{
		return null;
	}
}


using Oxide.Core;
using UnityEngine;

public class MaxDistance : Conditional
{
	private float maximumDistance;

	public bool CheckParent { get; set; }

	public MaxDistance(float maxDist)
	{
		maximumDistance = maxDist;
	}

	public override string GetArgs()
	{
		return maximumDistance.ToString("0.00f") + (CheckParent ? ", true" : "");
	}

	public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance, bool checkParent = false)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnEntityDistanceCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)maximumDistance, (object)checkParent);
		if (obj is bool)
		{
			return (bool)obj;
		}
		bool flag = ent.Distance(player.eyes.position) <= maximumDistance;
		if (checkParent && !flag)
		{
			BaseEntity parentEntity = ent.GetParentEntity();
			flag = (Object)(object)parentEntity != (Object)null && parentEntity.Distance(player.eyes.position) <= maximumDistance;
		}
		return flag;
	}
}


using Oxide.Core;
using UnityEngine;

public class IsVisible : Conditional
{
	private float maximumDistance;

	public IsVisible(float maxDist)
	{
		maximumDistance = maxDist;
	}

	public override string GetArgs()
	{
		return maximumDistance.ToString("0.00f");
	}

	public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, float maximumDistance)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnEntityVisibilityCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)maximumDistance);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041))
		{
			if (!ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance))
			{
				return ent.IsVisible(player.eyes.position, maximumDistance);
			}
			return true;
		}
		return false;
	}
}


using Oxide.Core;
using UnityEngine;

public class FromOwner : Conditional
{
	private bool includeMounted;

	public FromOwner(bool includeMounted = false)
	{
		this.includeMounted = includeMounted;
	}

	public override string GetArgs()
	{
		return includeMounted.ToString().ToLower();
	}

	public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, bool includeMounted)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
		{
			return false;
		}
		if (ent.net == null || player.net == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnEntityFromOwnerCheck", (object)ent, (object)player, (object)id, (object)debugName, (object)includeMounted);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ent.net.ID == player.net.ID)
		{
			return true;
		}
		if (ent.parentEntity.uid != player.net.ID)
		{
			BaseEntity parentEntity = ent.GetParentEntity();
			if ((Object)(object)parentEntity != (Object)null && parentEntity.parentEntity.uid == player.net.ID)
			{
				return true;
			}
			if (includeMounted)
			{
				BaseMountable baseMountable = ent as BaseMountable;
				if ((Object)(object)baseMountable == (Object)null)
				{
					baseMountable = ent.parentEntity.Get(serverside: true) as BaseMountable;
				}
				if ((Object)(object)baseMountable != (Object)null)
				{
					NetworkableId? val = baseMountable.GetMounted()?.net?.ID;
					NetworkableId iD = player.net.ID;
					if (val.HasValue && (!val.HasValue || val.GetValueOrDefault() == iD))
					{
						return true;
					}
				}
			}
			return false;
		}
		return true;
	}
}


using Oxide.Core;
using UnityEngine;

public class IsActiveItem : Conditional
{
	public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
		{
			return false;
		}
		if (ent.net == null || player.net == null)
		{
			return false;
		}
		object obj = Interface.CallHook("OnEntityActiveCheck", (object)ent, (object)player, (object)id, (object)debugName);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (ent.net.ID == player.net.ID)
		{
			return true;
		}
		if (ent.parentEntity.uid != player.net.ID)
		{
			return false;
		}
		Item activeItem = player.GetActiveItem();
		if (activeItem == null)
		{
			return false;
		}
		if ((Object)(object)activeItem.GetHeldEntity() != (Object)(object)ent)
		{
			return false;
		}
		return true;
	}
}


using UnityEngine;

public class CallsPerSecond : Conditional
{
	private ulong callsPerSecond;

	public CallsPerSecond(ulong limit)
	{
		callsPerSecond = limit;
	}

	public override string GetArgs()
	{
		return callsPerSecond.ToString();
	}

	public static bool Test(uint id, string debugName, BaseEntity ent, BasePlayer player, ulong callsPerSecond)
	{
		if ((Object)(object)ent == (Object)null || (Object)(object)player == (Object)null)
		{
			return false;
		}
		return player.rpcHistory.TryIncrement(id, callsPerSecond);
	}
}


public enum Signal
{
	Attack,
	Alt_Attack,
	DryFire,
	Reload,
	Deploy,
	Flinch_Head,
	Flinch_Chest,
	Flinch_Stomach,
	Flinch_RearHead,
	Flinch_RearTorso,
	Throw,
	Relax,
	Gesture,
	PhysImpact,
	Eat,
	Startled,
	Admire
}


public enum Slot
{
	Lock,
	FireMod,
	UpperModifier,
	MiddleModifier,
	LowerModifier,
	CenterDecoration,
	LowerCenterDecoration,
	StorageMonitor,
	Count
}


using System;

[Flags]
public enum TraitFlag
{
	None = 0,
	Alive = 1,
	Animal = 2,
	Human = 4,
	Interesting = 8,
	Food = 0x10,
	Meat = 0x20,
	Water = 0x20
}


using System.Globalization;
using System.Linq;
using UnityEngine;

public static class Util
{
	public static BaseEntity[] FindTargets(string strFilter, bool onlyPlayers)
	{
		return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
			{
				if (x is BasePlayer)
				{
					BasePlayer basePlayer = x as BasePlayer;
					if (string.IsNullOrEmpty(strFilter))
					{
						return true;
					}
					if (strFilter == "!alive" && basePlayer.IsAlive())
					{
						return true;
					}
					if (strFilter == "!sleeping" && basePlayer.IsSleeping())
					{
						return true;
					}
					if (strFilter[0] != '!' && !StringEx.Contains(basePlayer.displayName, strFilter, CompareOptions.IgnoreCase) && !basePlayer.UserIDString.Contains(strFilter))
					{
						return false;
					}
					return true;
				}
				if (onlyPlayers)
				{
					return false;
				}
				if (string.IsNullOrEmpty(strFilter))
				{
					return false;
				}
				return x.ShortPrefabName.Contains(strFilter) ? true : false;
			})
			select x as BaseEntity).ToArray();
	}

	public static BaseEntity[] FindTargetsOwnedBy(ulong ownedBy, string strFilter)
	{
		bool hasFilter = !string.IsNullOrEmpty(strFilter);
		return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
			{
				if (x is BaseEntity baseEntity)
				{
					if (baseEntity.OwnerID != ownedBy)
					{
						return false;
					}
					if (!hasFilter || baseEntity.ShortPrefabName.Contains(strFilter))
					{
						return true;
					}
				}
				return false;
			})
			select x as BaseEntity).ToArray();
	}

	public static BaseEntity[] FindTargetsAuthedTo(ulong authId, string strFilter)
	{
		bool hasFilter = !string.IsNullOrEmpty(strFilter);
		return (from x in BaseNetworkable.serverEntities.Where(delegate(BaseNetworkable x)
			{
				if (x is BuildingPrivlidge buildingPrivlidge)
				{
					if (!buildingPrivlidge.IsAuthed(authId))
					{
						return false;
					}
					if (!hasFilter || x.ShortPrefabName.Contains(strFilter))
					{
						return true;
					}
				}
				else if (x is AutoTurret autoTurret)
				{
					if (!autoTurret.IsAuthed(authId))
					{
						return false;
					}
					if (!hasFilter || x.ShortPrefabName.Contains(strFilter))
					{
						return true;
					}
				}
				else if (x is CodeLock codeLock)
				{
					if (!codeLock.whitelistPlayers.Contains(authId))
					{
						return false;
					}
					if (!hasFilter || x.ShortPrefabName.Contains(strFilter))
					{
						return true;
					}
				}
				return false;
			})
			select x as BaseEntity).ToArray();
	}

	public static T[] FindAll<T>() where T : BaseEntity
	{
		return BaseNetworkable.serverEntities.OfType<T>().ToArray();
	}
}


using System;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseFishingRod : HeldEntity
{
	public enum CatchState
	{
		None,
		Aiming,
		Waiting,
		Catching,
		Caught
	}

	[Flags]
	public enum FishState
	{
		PullingLeft = 1,
		PullingRight = 2,
		PullingBack = 4
	}

	public enum FailReason
	{
		UserRequested,
		BadAngle,
		TensionBreak,
		Unequipped,
		TimeOut,
		Success,
		NoWaterFound,
		Obstructed,
		NoLure,
		TooShallow,
		TooClose,
		TooFarAway,
		PlayerMoved
	}

	public class UpdateFishingRod : ObjectWorkQueue<BaseFishingRod>
	{
		protected override void RunJob(BaseFishingRod entity)
		{
			if (((ObjectWorkQueue<BaseFishingRod>)this).ShouldAdd(entity))
			{
				entity.CatchProcessBudgeted();
			}
		}

		protected override bool ShouldAdd(BaseFishingRod entity)
		{
			if (base.ShouldAdd(entity))
			{
				return entity.IsValid();
			}
			return false;
		}
	}

	public GameObjectRef FishingBobberRef;

	public float FishCatchDistance = 0.5f;

	public LineRenderer ReelLineRenderer;

	public Transform LineRendererWorldStartPos;

	private FishState currentFishState;

	private EntityRef<FishingBobber> currentBobber;

	public float ConditionLossOnSuccess = 0.02f;

	public float ConditionLossOnFail = 0.04f;

	public float GlobalStrainSpeedMultiplier = 1f;

	public float MaxCastDistance = 10f;

	public const Flags Straining = Flags.Reserved1;

	public ItemModFishable ForceFish;

	public static Flags PullingLeftFlag = Flags.Reserved6;

	public static Flags PullingRightFlag = Flags.Reserved7;

	public static Flags ReelingInFlag = Flags.Reserved8;

	public GameObjectRef BobberPreview;

	public SoundDefinition onLineSoundDef;

	public SoundDefinition strainSoundDef;

	public AnimationCurve strainGainCurve;

	public SoundDefinition tensionBreakSoundDef;

	public static UpdateFishingRod updateFishingRodQueue = new UpdateFishingRod();

	private TimeUntil nextFishStateChange;

	private TimeSince fishCatchDuration;

	private float strainTimer;

	private const float strainMax = 6f;

	private TimeSince lastStrainUpdate;

	private TimeUntil catchTime;

	private TimeSince lastSightCheck;

	private Vector3 playerStartPosition;

	private WaterBody surfaceBody;

	private ItemDefinition lureUsed;

	private ItemDefinition currentFishTarget;

	private ItemModFishable fishableModifier;

	private ItemModFishable lastFish;

	private bool inQueue;

	[ServerVar]
	public static bool ForceSuccess = false;

	[ServerVar]
	public static bool ForceFail = false;

	[ServerVar]
	public static bool ImmediateHook = false;

	public CatchState CurrentState { get; private set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseFishingRod.OnRpcMessage", 0);
		try
		{
			if (rpc == 4237324865u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_Cancel "));
				}
				TimeWarning val2 = TimeWarning.New("Server_Cancel", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4237324865u, "Server_Cancel", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_Cancel(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_Cancel");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4238539495u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestCast "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestCast", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4238539495u, "Server_RequestCast", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							Server_RequestCast(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in Server_RequestCast");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void Load(LoadInfo info)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if ((!base.isServer || !info.fromDisk) && info.msg.simpleUID != null)
		{
			currentBobber.uid = info.msg.simpleUID.uid;
		}
	}

	public override bool BlocksGestures()
	{
		return CurrentState != CatchState.None;
	}

	private bool AllowPullInDirection(Vector3 worldDirection, Vector3 bobberPosition)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = Vector3Ex.WithY(bobberPosition, position.y);
		Vector3 val2 = val - position;
		return Vector3.Dot(worldDirection, ((Vector3)(ref val2)).normalized) < 0f;
	}

	private bool EvaluateFishingPosition(ref Vector3 pos, BasePlayer ply, out FailReason reason, out WaterBody waterBody)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit hitInfo;
		bool num = GamePhysics.Trace(new Ray(pos + Vector3.up, Vector3.down), 0f, out hitInfo, 1.5f, 16, (QueryTriggerInteraction)0);
		if (num)
		{
			waterBody = hitInfo.GetWaterBody();
			pos.y = ((RaycastHit)(ref hitInfo)).point.y;
		}
		else
		{
			waterBody = null;
		}
		if (!num)
		{
			reason = FailReason.NoWaterFound;
			return false;
		}
		if (Vector3.Distance(Vector3Ex.WithY(((Component)ply).transform.position, pos.y), pos) < 5f)
		{
			reason = FailReason.TooClose;
			return false;
		}
		if (!GamePhysics.LineOfSight(ply.eyes.position, pos, 1218652417))
		{
			reason = FailReason.Obstructed;
			return false;
		}
		Vector3 p = pos + Vector3.up * 2f;
		if (!GamePhysics.LineOfSight(ply.eyes.position, p, 1218652417))
		{
			reason = FailReason.Obstructed;
			return false;
		}
		Vector3 position = ((Component)ply).transform.position;
		position.y = pos.y;
		float num2 = Vector3.Distance(pos, position);
		Vector3 val = pos;
		Vector3 val2 = position - pos;
		Vector3 p2 = val + ((Vector3)(ref val2)).normalized * (num2 - FishCatchDistance);
		if (!GamePhysics.LineOfSight(pos, p2, 1218652417))
		{
			reason = FailReason.Obstructed;
			return false;
		}
		if (WaterLevel.GetOverallWaterDepth(Vector3.Lerp(pos, Vector3Ex.WithY(((Component)ply).transform.position, pos.y), 0.95f), waves: true, volumes: true) < 0.1f && ply.eyes.position.y > 0f)
		{
			reason = FailReason.TooShallow;
			return false;
		}
		if (WaterLevel.GetOverallWaterDepth(pos, waves: true, volumes: true) < 0.3f && ply.eyes.position.y > 0f)
		{
			reason = FailReason.TooShallow;
			return false;
		}
		Vector3 p3 = Vector3.MoveTowards(Vector3Ex.WithY(((Component)ply).transform.position, pos.y), pos, 1f);
		if (!GamePhysics.LineOfSight(ply.eyes.position, p3, 1218652417))
		{
			reason = FailReason.Obstructed;
			return false;
		}
		if (GamePhysics.CheckSphere(pos, 0.25f, 153092352, (QueryTriggerInteraction)0))
		{
			reason = FailReason.Obstructed;
			return false;
		}
		reason = FailReason.Success;
		return true;
	}

	private Item GetCurrentLure()
	{
		if (GetItem() == null)
		{
			return null;
		}
		if (GetItem().contents == null)
		{
			return null;
		}
		return GetItem().contents.GetSlot(0);
	}

	private bool HasReelInInput(InputState state)
	{
		if (!state.IsDown(BUTTON.BACKWARD))
		{
			return state.IsDown(BUTTON.FIRE_PRIMARY);
		}
		return true;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void Server_RequestCast(RPCMessage msg)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = msg.read.Vector3();
		BasePlayer ownerPlayer = GetOwnerPlayer();
		Item currentLure = GetCurrentLure();
		if (currentLure == null)
		{
			FailedCast(FailReason.NoLure);
			return;
		}
		if (!EvaluateFishingPosition(ref pos, ownerPlayer, out var reason, out surfaceBody))
		{
			FailedCast(reason);
			return;
		}
		ItemModCompostable itemModCompostable = (ItemModCompostable)Interface.CallHook("CanCastFishingRod", (object)ownerPlayer, (object)this, (object)currentLure, (object)pos);
		if (!(itemModCompostable is bool) || (bool)(object)itemModCompostable)
		{
			FishingBobber component = ((Component)base.gameManager.CreateEntity(FishingBobberRef.resourcePath, ((Component)this).transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, GetOwnerPlayer().ServerRotation)).GetComponent<FishingBobber>();
			((Component)component).transform.forward = GetOwnerPlayer().eyes.BodyForward();
			component.Spawn();
			component.InitialiseBobber(ownerPlayer, surfaceBody, pos, 150f);
			int usedLureAmount = 0;
			if (FishLookup.Instance != null)
			{
				currentFishTarget = FishLookup.Instance.GetFish(((Component)component).transform.position, surfaceBody, currentLure, out fishableModifier, lastFish, out usedLureAmount);
			}
			lureUsed = currentLure.info;
			currentLure.UseItem(usedLureAmount);
			lastFish = fishableModifier;
			currentBobber.Set(component);
			ClientRPC(RpcTarget.NetworkGroup("Client_ReceiveCastPoint"), component.net.ID);
			ownerPlayer.SignalBroadcast(Signal.Attack);
			catchTime = TimeUntil.op_Implicit(ImmediateHook ? 0f : Random.Range(10f, 20f));
			catchTime = TimeUntil.op_Implicit(TimeUntil.op_Implicit(catchTime) * fishableModifier.CatchWaitTimeMultiplier);
			float num = (((Component)lureUsed).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f);
			num = Mathx.RemapValClamped(num, 0f, 20f, 1f, 10f);
			catchTime = TimeUntil.op_Implicit(Mathf.Clamp(TimeUntil.op_Implicit(catchTime) - num, 3f, 20f));
			playerStartPosition = ((Component)ownerPlayer).transform.position;
			SetFlag(Flags.Busy, b: true);
			CurrentState = CatchState.Waiting;
			((FacepunchBehaviour)this).InvokeRepeating((Action)CatchProcess, 0f, 0f);
			inQueue = false;
			BasePlayer ownerPlayer2 = GetOwnerPlayer();
			if ((Object)(object)ownerPlayer2 != (Object)null)
			{
				Analytics.Azure.OnStartFish(ownerPlayer2, currentLure, pos);
			}
			Interface.CallHook("OnFishingRodCast", (object)this, (object)ownerPlayer, (object)currentLure);
		}
	}

	private void FailedCast(FailReason reason)
	{
		CurrentState = CatchState.None;
		ClientRPC(RpcTarget.NetworkGroup("Client_ResetLine"), (int)reason);
	}

	private void CatchProcess()
	{
		if (!inQueue)
		{
			inQueue = true;
			((ObjectWorkQueue<BaseFishingRod>)updateFishingRodQueue).Add(this);
		}
	}

	private void CatchProcessBudgeted()
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0519: Unknown result type (might be due to invalid IL or missing references)
		//IL_0552: Unknown result type (might be due to invalid IL or missing references)
		//IL_0557: Unknown result type (might be due to invalid IL or missing references)
		inQueue = false;
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || ownerPlayer.IsSleeping() || ownerPlayer.IsWounded() || ownerPlayer.IsDead() || (Object)(object)fishingBobber == (Object)null)
		{
			Server_Cancel(FailReason.UserRequested);
			return;
		}
		Vector3 position = ((Component)ownerPlayer).transform.position;
		Vector3 val = Vector3Ex.WithY(((Component)fishingBobber).transform.position, 0f) - Vector3Ex.WithY(position, 0f);
		float num = Vector3.Angle(((Vector3)(ref val)).normalized, Vector3Ex.WithY(ownerPlayer.eyes.HeadForward(), 0f));
		float num2 = Vector3.Distance(position, Vector3Ex.WithY(((Component)fishingBobber).transform.position, position.y));
		if (num > ((num2 > 1.2f) ? 60f : 180f))
		{
			Server_Cancel(FailReason.BadAngle);
			return;
		}
		if (num2 > 1.2f && TimeSince.op_Implicit(lastSightCheck) > 0.4f)
		{
			if (!GamePhysics.LineOfSight(ownerPlayer.eyes.position, ((Component)fishingBobber).transform.position, 1084293377))
			{
				Server_Cancel(FailReason.Obstructed);
				return;
			}
			lastSightCheck = TimeSince.op_Implicit(0f);
		}
		if (Vector3.Distance(position, ((Component)fishingBobber).transform.position) > MaxCastDistance * 2f)
		{
			Server_Cancel(FailReason.TooFarAway);
			return;
		}
		if (Vector3.Distance(playerStartPosition, position) > 1f)
		{
			Server_Cancel(FailReason.PlayerMoved);
			return;
		}
		if (CurrentState == CatchState.Waiting)
		{
			if (TimeUntil.op_Implicit(catchTime) < 0f)
			{
				ClientRPC(RpcTarget.NetworkGroup("Client_HookedSomething"));
				CurrentState = CatchState.Catching;
				fishingBobber.SetFlag(Flags.Reserved1, b: true);
				nextFishStateChange = TimeUntil.op_Implicit(0f);
				fishCatchDuration = TimeSince.op_Implicit(0f);
				strainTimer = 0f;
			}
			return;
		}
		FishState fishState = currentFishState;
		if (TimeUntil.op_Implicit(nextFishStateChange) < 0f)
		{
			float num3 = Mathx.RemapValClamped(fishingBobber.TireAmount, 0f, 20f, 0f, 1f);
			if (currentFishState != 0)
			{
				currentFishState = (FishState)0;
				nextFishStateChange = TimeUntil.op_Implicit(Random.Range(2f, 4f) * (num3 + 1f));
			}
			else
			{
				nextFishStateChange = TimeUntil.op_Implicit(Random.Range(3f, 7f) * (1f - num3));
				if (Random.Range(0, 100) < 50)
				{
					currentFishState = FishState.PullingLeft;
				}
				else
				{
					currentFishState = FishState.PullingRight;
				}
				if (Random.Range(0, 100) > 60 && Vector3.Distance(((Component)fishingBobber).transform.position, ((Component)ownerPlayer).transform.position) < MaxCastDistance - 2f)
				{
					currentFishState |= FishState.PullingBack;
				}
			}
		}
		if (TimeSince.op_Implicit(fishCatchDuration) > 120f)
		{
			Server_Cancel(FailReason.TimeOut);
			return;
		}
		bool flag = ownerPlayer.serverInput.IsDown(BUTTON.RIGHT);
		bool flag2 = ownerPlayer.serverInput.IsDown(BUTTON.LEFT);
		bool flag3 = HasReelInInput(ownerPlayer.serverInput);
		if (flag2 && flag)
		{
			flag2 = (flag = false);
		}
		UpdateFlags(flag2, flag, flag3);
		if (CurrentState == CatchState.Waiting)
		{
			flag = (flag2 = (flag3 = false));
		}
		if (flag2 && !AllowPullInDirection(-ownerPlayer.eyes.HeadRight(), ((Component)fishingBobber).transform.position))
		{
			flag2 = false;
		}
		if (flag && !AllowPullInDirection(ownerPlayer.eyes.HeadRight(), ((Component)fishingBobber).transform.position))
		{
			flag = false;
		}
		float value = ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f);
		fishingBobber.ServerMovementUpdate(flag2, flag, flag3, ref currentFishState, position, fishableModifier, value);
		bool flag4 = false;
		float num4 = 0f;
		if (flag3 || flag2 || flag)
		{
			flag4 = true;
			num4 = 0.5f;
		}
		if (currentFishState != 0 && flag4)
		{
			if (currentFishState.Contains(FishState.PullingBack) && flag3)
			{
				num4 = 1.5f;
			}
			else if ((currentFishState.Contains(FishState.PullingLeft) || currentFishState.Contains(FishState.PullingRight)) && flag3)
			{
				num4 = 1.2f;
			}
			else if (currentFishState.Contains(FishState.PullingLeft) && flag)
			{
				num4 = 0.8f;
			}
			else if (currentFishState.Contains(FishState.PullingRight) && flag2)
			{
				num4 = 0.8f;
			}
		}
		if (flag3 && currentFishState != 0)
		{
			num4 += 1f;
		}
		num4 *= fishableModifier.StrainModifier * GlobalStrainSpeedMultiplier;
		num4 -= ownerPlayer.modifiers.GetValue(Modifier.ModifierType.FishingBoost, 1f) - 1f;
		if (flag4)
		{
			strainTimer += Time.deltaTime * num4;
		}
		else
		{
			strainTimer = Mathf.MoveTowards(strainTimer, 0f, Time.deltaTime * 1.5f);
		}
		float num5 = strainTimer / 6f;
		SetFlag(Flags.Reserved1, flag4 && num5 > 0.25f);
		if (TimeSince.op_Implicit(lastStrainUpdate) > 0.4f || fishState != currentFishState)
		{
			ClientRPC(RpcTarget.NetworkGroup("Client_UpdateFishState"), (int)currentFishState, num5);
			lastStrainUpdate = TimeSince.op_Implicit(0f);
		}
		if (strainTimer > 7f || ForceFail)
		{
			Server_Cancel(FailReason.TensionBreak);
		}
		else
		{
			if (!(num2 <= FishCatchDistance) && !ForceSuccess)
			{
				return;
			}
			CurrentState = CatchState.Caught;
			if ((Object)(object)currentFishTarget != (Object)null)
			{
				Item item = ItemManager.Create(currentFishTarget, 1, 0uL);
				item.SetItemOwnership(ownerPlayer, ItemOwnershipPhrases.Fishing);
				object obj = Interface.CallHook("CanCatchFish", (object)ownerPlayer, (object)this, (object)item);
				if (obj is bool && !(bool)obj)
				{
					return;
				}
				object obj2 = Interface.CallHook("OnFishCatch", (object)item, (object)this, (object)ownerPlayer);
				if (obj2 is Item && obj2 as Item != item)
				{
					item.Remove();
					item = (Item)obj2;
				}
				ownerPlayer.GiveItem(item, GiveItemReason.Crafted);
				if (currentFishTarget.shortname == "skull.human")
				{
					item.name = RandomUsernames.Get(Random.Range(0, 1000));
				}
				if (GameInfo.HasAchievements && !string.IsNullOrEmpty(fishableModifier.SteamStatName))
				{
					ownerPlayer.stats.Add(fishableModifier.SteamStatName, 1);
					ownerPlayer.stats.Save(forceSteamSave: true);
					FishLookup.Instance.CheckCatchAllAchievement(ownerPlayer);
				}
				Analytics.Azure.OnCaughtFish(ownerPlayer, item);
			}
			ClientRPC(RpcTarget.NetworkGroup("Client_OnCaughtFish"), currentFishTarget.itemid);
			ownerPlayer.SignalBroadcast(Signal.Alt_Attack);
			((FacepunchBehaviour)this).Invoke((Action)ResetLine, 6f);
			fishingBobber.Kill();
			currentBobber.Set(null);
			((FacepunchBehaviour)this).CancelInvoke((Action)CatchProcess);
			Interface.CallHook("OnFishCaught", (object)currentFishTarget, (object)this, (object)ownerPlayer);
		}
	}

	private void ResetLine()
	{
		Server_Cancel(FailReason.Success);
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void Server_Cancel(RPCMessage msg)
	{
		if (CurrentState != CatchState.Caught)
		{
			Server_Cancel(FailReason.UserRequested);
		}
	}

	private void Server_Cancel(FailReason reason)
	{
		if (GetItem() != null)
		{
			GetItem().LoseCondition((reason == FailReason.Success) ? ConditionLossOnSuccess : ConditionLossOnFail);
		}
		SetFlag(Flags.Busy, b: false);
		UpdateFlags();
		((FacepunchBehaviour)this).CancelInvoke((Action)CatchProcess);
		CurrentState = CatchState.None;
		SetFlag(Flags.Reserved1, b: false);
		FishingBobber fishingBobber = currentBobber.Get(serverside: true);
		if ((Object)(object)fishingBobber != (Object)null)
		{
			fishingBobber.Kill();
			currentBobber.Set(null);
		}
		ClientRPC(RpcTarget.NetworkGroup("Client_ResetLine"), (int)reason);
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer != (Object)null)
		{
			Analytics.Azure.OnFailedFish(ownerPlayer, reason);
		}
		Interface.CallHook("OnFishingStopped", (object)this, (object)reason);
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (CurrentState != 0)
		{
			Server_Cancel(FailReason.Unequipped);
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (currentBobber.IsSet && info.msg.simpleUID == null)
		{
			info.msg.simpleUID = Pool.Get<SimpleUID>();
			info.msg.simpleUID.uid = currentBobber.uid;
		}
	}

	private void UpdateFlags(bool inputLeft = false, bool inputRight = false, bool back = false)
	{
		SetFlag(PullingLeftFlag, CurrentState == CatchState.Catching && inputLeft);
		SetFlag(PullingRightFlag, CurrentState == CatchState.Catching && inputRight);
		SetFlag(ReelingInFlag, CurrentState == CatchState.Catching && back);
	}
}


public enum CatchState
{
	None,
	Aiming,
	Waiting,
	Catching,
	Caught
}


using System;

[Flags]
public enum FishState
{
	PullingLeft = 1,
	PullingRight = 2,
	PullingBack = 4
}


public enum FailReason
{
	UserRequested,
	BadAngle,
	TensionBreak,
	Unequipped,
	TimeOut,
	Success,
	NoWaterFound,
	Obstructed,
	NoLure,
	TooShallow,
	TooClose,
	TooFarAway,
	PlayerMoved
}


public class UpdateFishingRod : ObjectWorkQueue<BaseFishingRod>
{
	protected override void RunJob(BaseFishingRod entity)
	{
		if (((ObjectWorkQueue<BaseFishingRod>)this).ShouldAdd(entity))
		{
			entity.CatchProcessBudgeted();
		}
	}

	protected override bool ShouldAdd(BaseFishingRod entity)
	{
		if (base.ShouldAdd(entity))
		{
			return entity.IsValid();
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using CompanionServer;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

[Serializable]
public class BaseGameMode : BaseEntity
{
	public struct ResearchCostResult
	{
		public float? Scale;

		public int? Amount;
	}

	[Serializable]
	public class GameModeTeam
	{
		public string name;

		public PlayerInventoryProperties[] teamloadouts;
	}

	[Serializable]
	public struct ItemRestriction
	{
		public ItemDefinition Definition;

		public EraRestriction Restriction;
	}

	[Serializable]
	public struct LootTypeModifier
	{
		public ItemDefinition.LootDistributionModifierType LootType;

		public int Modifier;
	}

	[Serializable]
	public struct CraftingCostMultiplier
	{
		public ItemDefinition.LootDistributionModifierType LootType;

		[Range(0f, 20f)]
		public float Multiplier;

		[Tooltip("Will override the Multiplier if set")]
		public CraftingCostConVar ConVarToUse;
	}

	public enum CraftingCostConVar
	{
		None,
		HardcoreFirearmAmmunition
	}

	private GameMode gameModeScores;

	public string[] scoreColumns;

	[Header("Vanilla")]
	public bool globalChat = true;

	public bool localChat;

	public bool teamSystem = true;

	public bool safeZone = true;

	public bool ingameMap = true;

	public bool compass = true;

	public bool contactSystem = true;

	public bool crawling = true;

	public bool rustPlus = true;

	public bool wipeBpsOnProtocol;

	public int maximumSleepingBags = -1;

	public bool returnValidCombatlog = true;

	public bool missionSystem = true;

	public bool mlrs = true;

	public const Flags Flag_Warmup = Flags.Reserved1;

	public const Flags Flag_GameOver = Flags.Reserved2;

	public const Flags Flag_WaitingForPlayers = Flags.Reserved3;

	[Header("Changelog")]
	public Phrase[] addedFeatures;

	public Phrase[] removedFeatures;

	public Phrase[] changedFeatures;

	public List<string> convars = new List<string>();

	public string shortname = "vanilla";

	public float matchDuration = -1f;

	public float warmupDuration = 10f;

	public float timeBetweenMatches = 10f;

	public int minPlayersToStart = 1;

	public bool useCustomSpawns = true;

	public string victoryScoreName = "kills";

	public string teamScoreName = "kills";

	public int numScoreForVictory = 10;

	public string gamemodeTitle;

	public SoundDefinition[] warmupMusics;

	public SoundDefinition[] lossMusics;

	public SoundDefinition[] winMusics;

	[NonSerialized]
	private float warmupStartTime;

	[NonSerialized]
	private float matchStartTime = -1f;

	[NonSerialized]
	private float matchEndTime;

	public List<string> gameModeTags;

	public BasePlayer.CameraMode deathCameraMode = BasePlayer.CameraMode.Eyes;

	public bool permanent = true;

	public bool limitTeamAuths;

	public bool allowSleeping = true;

	public bool allowWounding = true;

	public bool allowBleeding = true;

	public bool allowTemperature = true;

	public bool quickRespawn;

	public bool quickDeploy;

	public float respawnDelayOverride = 5f;

	public float startHealthOverride;

	public float autoHealDelay;

	public float autoHealDuration = 1f;

	public float corpseRemovalTimeOverride;

	public bool canRepairIfCraftingBanned;

	public bool hasKillFeed;

	[Header("Map")]
	public bool allowPings = true;

	public bool fogOfWar;

	public float fogOfWarRevealSize = 256f;

	public bool mapMarkers = true;

	public bool hidePlayerOnMap;

	public bool hideMapPlayerDirectionIndicator;

	public bool hideUndergroundOnMap;

	public BaseMission[] blockedMissions = new BaseMission[0];

	public TechTreeData[] allowedTechTrees = new TechTreeData[0];

	public static BaseGameMode svActiveGameMode = null;

	public static List<BaseGameMode> svGameModeManifest = new List<BaseGameMode>();

	[NonSerialized]
	private GameObject[] allspawns;

	[NonSerialized]
	private GameModeSpawnGroup[] gameModeSpawnGroups;

	public PlayerInventoryProperties[] loadouts;

	[Tooltip("Use steamID to always pick the same loadout per player")]
	public bool useStaticLoadoutPerPlayer;

	public bool topUpMagazines;

	public bool sendKillNotifications;

	public GameModeTeam[] teams;

	public ItemRestriction[] Restrictions;

	public LootTypeModifier[] LootDistributionModifiers = new LootTypeModifier[0];

	public CraftingCostMultiplier[] CraftingCostModifiers = new CraftingCostMultiplier[0];

	private static bool isResetting = false;

	public static event Action<BaseGameMode> GameModeChanged;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseGameMode.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public GameMode GetGameScores()
	{
		return gameModeScores;
	}

	public int ScoreColumnIndex(string scoreName)
	{
		for (int i = 0; i < scoreColumns.Length; i++)
		{
			if (scoreColumns[i] == scoreName)
			{
				return i;
			}
		}
		return -1;
	}

	public void InitScores()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Expected O, but got Unknown
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Expected O, but got Unknown
		gameModeScores = new GameMode();
		gameModeScores.scoreColumns = new List<ScoreColumn>();
		gameModeScores.playerScores = new List<PlayerScore>();
		gameModeScores.teams = new List<TeamInfo>();
		GameModeTeam[] array = teams;
		for (int i = 0; i < array.Length; i++)
		{
			_ = array[i];
			TeamInfo val = new TeamInfo();
			val.score = 0;
			val.ShouldPool = false;
			gameModeScores.teams.Add(val);
		}
		string[] array2 = scoreColumns;
		foreach (string name in array2)
		{
			ScoreColumn val2 = new ScoreColumn();
			val2.name = name;
			val2.ShouldPool = false;
			gameModeScores.scoreColumns.Add(val2);
		}
		gameModeScores.ShouldPool = false;
	}

	public void CopyGameModeScores(GameMode from, GameMode to)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Expected O, but got Unknown
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Expected O, but got Unknown
		to.teams.Clear();
		to.scoreColumns.Clear();
		to.playerScores.Clear();
		foreach (TeamInfo team in from.teams)
		{
			TeamInfo val = new TeamInfo();
			val.score = team.score;
			to.teams.Add(val);
		}
		foreach (ScoreColumn scoreColumn in from.scoreColumns)
		{
			ScoreColumn val2 = new ScoreColumn();
			val2.name = scoreColumn.name;
			to.scoreColumns.Add(val2);
		}
		foreach (PlayerScore playerScore in from.playerScores)
		{
			PlayerScore val3 = new PlayerScore();
			val3.playerName = playerScore.playerName;
			val3.userid = playerScore.userid;
			val3.team = playerScore.team;
			val3.scores = new List<int>();
			foreach (int score in playerScore.scores)
			{
				val3.scores.Add(score);
			}
			to.playerScores.Add(val3);
		}
	}

	public PlayerScore GetPlayerScoreForPlayer(BasePlayer player)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Expected O, but got Unknown
		PlayerScore val = null;
		foreach (PlayerScore playerScore in gameModeScores.playerScores)
		{
			if (playerScore.userid == (ulong)player.userID)
			{
				val = playerScore;
				break;
			}
		}
		if (val == null)
		{
			val = new PlayerScore();
			val.ShouldPool = false;
			val.playerName = player.displayName;
			val.userid = player.userID;
			val.scores = new List<int>();
			string[] array = scoreColumns;
			for (int i = 0; i < array.Length; i++)
			{
				_ = array[i];
				val.scores.Add(0);
			}
			gameModeScores.playerScores.Add(val);
		}
		return val;
	}

	public int GetScoreIndexByName(string name)
	{
		for (int i = 0; i < scoreColumns.Length; i++)
		{
			if (scoreColumns[i] == name)
			{
				return i;
			}
		}
		Debug.LogWarning((object)("No score colum named : " + name + "returning default"));
		return 0;
	}

	public virtual bool IsDraw()
	{
		if (IsTeamGame())
		{
			int num = -1;
			int num2 = 1000000;
			for (int i = 0; i < teams.Length; i++)
			{
				int teamScore = GetTeamScore(i);
				if (teamScore < num2)
				{
					num2 = teamScore;
				}
				if (teamScore > num)
				{
					num = teamScore;
				}
			}
			if (num == num2)
			{
				return true;
			}
			return false;
		}
		int num3 = -1;
		int num4 = 0;
		int num5 = ScoreColumnIndex(victoryScoreName);
		if (num5 != -1)
		{
			for (int j = 0; j < gameModeScores.playerScores.Count; j++)
			{
				PlayerScore val = gameModeScores.playerScores[j];
				if (val.scores[num5] > num3)
				{
					num3 = val.scores[num5];
					num4 = 1;
				}
				else if (val.scores[num5] == num3)
				{
					num4++;
				}
			}
		}
		if (num3 != 0)
		{
			return num4 > 1;
		}
		return true;
	}

	public virtual string GetWinnerName()
	{
		int num = -1;
		int num2 = -1;
		if (IsTeamGame())
		{
			for (int i = 0; i < teams.Length; i++)
			{
				int teamScore = GetTeamScore(i);
				if (teamScore > num)
				{
					num = teamScore;
					num2 = i;
				}
			}
			if (num2 == -1)
			{
				return "NO ONE";
			}
			return teams[num2].name;
		}
		int num3 = ScoreColumnIndex(victoryScoreName);
		if (num3 != -1)
		{
			for (int j = 0; j < gameModeScores.playerScores.Count; j++)
			{
				PlayerScore val = gameModeScores.playerScores[j];
				if (val.scores[num3] > num)
				{
					num = val.scores[num3];
					num2 = j;
				}
			}
		}
		if (num2 != -1)
		{
			return gameModeScores.playerScores[num2].playerName;
		}
		return "";
	}

	public virtual int GetPlayerTeamPosition(BasePlayer player)
	{
		return 0;
	}

	public virtual int GetPlayerRank(BasePlayer player)
	{
		int num = ScoreColumnIndex(victoryScoreName);
		if (num == -1)
		{
			return 10;
		}
		int num2 = GetPlayerScoreForPlayer(player).scores[num];
		int num3 = 0;
		foreach (PlayerScore playerScore in gameModeScores.playerScores)
		{
			if (playerScore.scores[num] > num2 && playerScore.userid != (ulong)player.userID)
			{
				num3++;
			}
		}
		return num3 + 1;
	}

	public int GetWinningTeamIndex()
	{
		int num = -1;
		int num2 = -1;
		if (IsTeamGame())
		{
			for (int i = 0; i < teams.Length; i++)
			{
				int teamScore = GetTeamScore(i);
				if (teamScore > num)
				{
					num = teamScore;
					num2 = i;
				}
			}
			if (num2 == -1)
			{
				return -1;
			}
			return num2;
		}
		return -1;
	}

	public virtual bool DidPlayerWin(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (IsDraw())
		{
			return false;
		}
		if (IsTeamGame())
		{
			PlayerScore playerScoreForPlayer = GetPlayerScoreForPlayer(player);
			if (playerScoreForPlayer.team == -1)
			{
				return false;
			}
			return playerScoreForPlayer.team == GetWinningTeamIndex();
		}
		return GetPlayerRank(player) == 1;
	}

	public bool IsTeamGame()
	{
		return teams.Length > 1;
	}

	public bool KeepScores()
	{
		return scoreColumns.Length != 0;
	}

	public void ModifyTeamScore(int teamIndex, int modifyAmount)
	{
		if (KeepScores())
		{
			TeamInfo obj = gameModeScores.teams[teamIndex];
			obj.score += modifyAmount;
			SendNetworkUpdate();
			CheckGameConditions();
		}
	}

	public void SetTeamScore(int teamIndex, int score)
	{
		gameModeScores.teams[teamIndex].score = score;
		SendNetworkUpdate();
	}

	public virtual void ResetPlayerScores(BasePlayer player)
	{
		if (!base.isClient)
		{
			for (int i = 0; i < scoreColumns.Length; i++)
			{
				SetPlayerGameScore(player, i, 0);
			}
		}
	}

	public void ModifyPlayerGameScore(BasePlayer player, string scoreName, int modifyAmount)
	{
		if (KeepScores())
		{
			int scoreIndexByName = GetScoreIndexByName(scoreName);
			ModifyPlayerGameScore(player, scoreIndexByName, modifyAmount);
		}
	}

	public void ModifyPlayerGameScore(BasePlayer player, int scoreIndex, int modifyAmount)
	{
		if (KeepScores())
		{
			GetPlayerScoreForPlayer(player);
			int playerGameScore = GetPlayerGameScore(player, scoreIndex);
			if (IsTeamGame() && player.gamemodeteam >= 0 && scoreIndex == GetScoreIndexByName(teamScoreName))
			{
				gameModeScores.teams[player.gamemodeteam].score = gameModeScores.teams[player.gamemodeteam].score + modifyAmount;
			}
			SetPlayerGameScore(player, scoreIndex, playerGameScore + modifyAmount);
		}
	}

	public int GetPlayerGameScore(BasePlayer player, int scoreIndex)
	{
		return GetPlayerScoreForPlayer(player).scores[scoreIndex];
	}

	public void SetPlayerTeam(BasePlayer player, int newTeam)
	{
		player.gamemodeteam = newTeam;
		GetPlayerScoreForPlayer(player).team = newTeam;
		SendNetworkUpdate();
	}

	public void SetPlayerGameScore(BasePlayer player, int scoreIndex, int scoreValue)
	{
		if (!base.isClient && KeepScores())
		{
			GetPlayerScoreForPlayer(player).scores[scoreIndex] = scoreValue;
			SendNetworkUpdate();
			CheckGameConditions();
		}
	}

	public int GetMaxBeds(BasePlayer player)
	{
		return maximumSleepingBags;
	}

	protected virtual void SetupTags()
	{
		gameModeTags.Add("missions-" + (missionSystem ? "enabled" : "disabled"));
		gameModeTags.Add("mlrs-" + (mlrs ? "enabled" : "disabled"));
		gameModeTags.Add("map-" + (ingameMap ? "enabled" : "disabled"));
	}

	public virtual ResearchCostResult GetScrapCostForResearch(ItemDefinition item, ResearchTable.ResearchType researchType)
	{
		return default(ResearchCostResult);
	}

	public virtual float? EvaluateSleepingBagReset(SleepingBag bag, Vector3 position, SleepingBag.SleepingBagResetReason reason)
	{
		return null;
	}

	private void DeleteEntities()
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<ServerMgr>.Instance == (Object)null || !SingletonComponent<ServerMgr>.Instance.runFrameUpdate)
		{
			((FacepunchBehaviour)this).Invoke((Action)DeleteEntities, 5f);
			return;
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.IsSafeZone && !safeZone)
			{
				List<BaseEntity> list = new List<BaseEntity>();
				Vis.Entities(new OBB(((Component)monument).transform, monument.Bounds), list, -1, (QueryTriggerInteraction)2);
				foreach (BaseEntity item in list)
				{
					if (item is HumanNPC || item is NPCAutoTurret || item is Marketplace)
					{
						item.Kill();
					}
					else if (!missionSystem && item is NPCSimpleMissionProvider)
					{
						item.Kill();
					}
				}
				NPCSpawner[] componentsInChildren = ((Component)monument).GetComponentsInChildren<NPCSpawner>();
				for (int i = 0; i < componentsInChildren.Length; i++)
				{
					componentsInChildren[i].isSpawnerActive = false;
				}
			}
			if (mlrs)
			{
				continue;
			}
			IndividualSpawner[] componentsInChildren2 = ((Component)monument).GetComponentsInChildren<IndividualSpawner>();
			foreach (IndividualSpawner individualSpawner in componentsInChildren2)
			{
				if (individualSpawner.entityPrefab.isValid && individualSpawner.entityPrefab.GetEntity() is MLRS)
				{
					individualSpawner.isSpawnerActive = false;
				}
			}
		}
		BaseNetworkable[] array = BaseNetworkable.serverEntities.ToArray();
		foreach (BaseNetworkable baseNetworkable in array)
		{
			if (!mlrs && baseNetworkable is MLRS)
			{
				baseNetworkable.Kill();
			}
			if (!missionSystem && baseNetworkable is NPCMissionProvider)
			{
				baseNetworkable.Kill();
			}
		}
		if (mlrs)
		{
			return;
		}
		for (int j = 0; j < SingletonComponent<SpawnHandler>.Instance.SpawnIndividuals.Count; j++)
		{
			SpawnIndividual spawnIndividual = SingletonComponent<SpawnHandler>.Instance.SpawnIndividuals[j];
			GameObject val = GameManager.server.FindPrefab(spawnIndividual.PrefabID);
			if ((Object)(object)val != (Object)null && (Object)(object)val.GetComponent<MLRS>() != (Object)null)
			{
				SingletonComponent<SpawnHandler>.Instance.SpawnIndividuals.RemoveAt(j);
				j--;
			}
		}
	}

	protected void OnCreated_Vanilla()
	{
		if (Application.isServerStarted && rustPlus != CompanionServer.Server.IsEnabled)
		{
			if (rustPlus)
			{
				CompanionServer.Server.Initialize();
			}
			else
			{
				CompanionServer.Server.Shutdown();
			}
		}
		if (!teamSystem)
		{
			RelationshipManager.maxTeamSize = 0;
		}
		if (maximumSleepingBags != -1)
		{
			ConVar.Server.max_sleeping_bags = maximumSleepingBags;
		}
		ConVar.Server.crawlingenabled = crawling;
		DeleteEntities();
		if (wipeBpsOnProtocol)
		{
			SingletonComponent<ServerMgr>.Instance.persistance.Dispose();
			SingletonComponent<ServerMgr>.Instance.persistance = new UserPersistance(ConVar.Server.rootFolder);
			BasePlayer[] array = Object.FindObjectsOfType<BasePlayer>();
			for (int i = 0; i < array.Length; i++)
			{
				array[i].InvalidateCachedPeristantPlayer();
			}
		}
		RelationshipManager.contacts = contactSystem;
		Chat.globalchat = globalChat;
		Chat.localchat = localChat;
	}

	public bool HasAnyGameModeTag(string[] tags)
	{
		for (int i = 0; i < gameModeTags.Count; i++)
		{
			for (int j = 0; j < tags.Length; j++)
			{
				if (tags[j] == gameModeTags[i])
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool HasGameModeTag(string tag)
	{
		for (int i = 0; i < gameModeTags.Count; i++)
		{
			if (gameModeTags[i] == tag)
			{
				return true;
			}
		}
		return false;
	}

	public bool AllowsSleeping()
	{
		return allowSleeping;
	}

	public bool HasLoadouts()
	{
		if (loadouts.Length == 0)
		{
			if (IsTeamGame())
			{
				return teams[0].teamloadouts.Length != 0;
			}
			return false;
		}
		return true;
	}

	public int GetNumTeams()
	{
		if (teams.Length > 1)
		{
			return teams.Length;
		}
		return 1;
	}

	public int GetTeamScore(int teamIndex)
	{
		return gameModeScores.teams[teamIndex].score;
	}

	public static void CreateGameMode(string overrideMode = "")
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		BaseGameMode activeGameMode = GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			activeGameMode.ShutdownGame();
			activeGameMode.Kill();
			SetActiveGameMode(null, serverside: true);
		}
		string text = ConVar.Server.gamemode;
		Debug.Log((object)("Gamemode Convar :" + text));
		if (!string.IsNullOrEmpty(overrideMode))
		{
			text = overrideMode;
		}
		if (string.IsNullOrEmpty(text))
		{
			Debug.Log((object)"No Gamemode.");
			if (BaseGameMode.GameModeChanged != null)
			{
				BaseGameMode.GameModeChanged(null);
			}
		}
		else
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/gamemodes/" + text + ".prefab", Vector3.zero, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
			else
			{
				Debug.Log((object)("Failed to create gamemode : " + text));
			}
		}
	}

	public static void SetActiveGameMode(BaseGameMode newActive, bool serverside)
	{
		if (Object.op_Implicit((Object)(object)newActive))
		{
			newActive.InitScores();
		}
		if (BaseGameMode.GameModeChanged != null)
		{
			BaseGameMode.GameModeChanged(newActive);
		}
		if (serverside)
		{
			svActiveGameMode = newActive;
		}
	}

	public static uint GetActiveGameModeId(bool serverside)
	{
		if (!((Object)(object)svActiveGameMode != (Object)null))
		{
			return 0u;
		}
		return svActiveGameMode.prefabID;
	}

	public static BaseGameMode GetActiveGameMode(bool serverside)
	{
		return svActiveGameMode;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.gameMode != null)
		{
			CopyGameModeScores(info.msg.gameMode, gameModeScores);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.gameMode = Pool.Get<GameMode>();
		info.msg.gameMode.scoreColumns = Pool.Get<List<ScoreColumn>>();
		info.msg.gameMode.playerScores = Pool.Get<List<PlayerScore>>();
		info.msg.gameMode.teams = Pool.Get<List<TeamInfo>>();
		CopyGameModeScores(gameModeScores, info.msg.gameMode);
		info.msg.gameMode.ShouldPool = true;
	}

	public virtual float CorpseRemovalTime(BaseCorpse corpse)
	{
		return ConVar.Server.corpsedespawn;
	}

	public virtual bool InWarmup()
	{
		return HasFlag(Flags.Reserved1);
	}

	public virtual bool IsWaitingForPlayers()
	{
		return HasFlag(Flags.Reserved3);
	}

	public virtual bool IsMatchOver()
	{
		return HasFlag(Flags.Reserved2);
	}

	public virtual bool IsMatchActive()
	{
		if (!InWarmup() && !IsWaitingForPlayers() && !IsMatchOver())
		{
			return matchStartTime != -1f;
		}
		return false;
	}

	public override void InitShared()
	{
		base.InitShared();
		if ((Object)(object)GetActiveGameMode(base.isServer) != (Object)null && (Object)(object)GetActiveGameMode(base.isServer) != (Object)(object)this)
		{
			Debug.LogError((object)("Already an active game mode! was : " + ((Object)GetActiveGameMode(base.isServer)).name));
			Object.Destroy((Object)(object)((Component)GetActiveGameMode(base.isServer)).gameObject);
		}
		SetupTags();
		SetActiveGameMode(this, base.isServer);
		OnCreated();
	}

	public override void DestroyShared()
	{
		if ((Object)(object)GetActiveGameMode(base.isServer) == (Object)(object)this)
		{
			SetActiveGameMode(null, base.isServer);
		}
		base.DestroyShared();
	}

	protected virtual void OnCreated()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OnCreated_Vanilla();
		if (base.isServer)
		{
			ApplyConVars();
			gameModeSpawnGroups = Object.FindObjectsOfType<GameModeSpawnGroup>();
			UnassignAllPlayers();
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					AutoAssignTeam(current);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			InstallSpawnpoints();
			ResetMatch();
		}
		Debug.Log((object)("Game created! type was : " + ((Object)this).name));
	}

	public void ApplyConVars()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		foreach (string convar in convars)
		{
			try
			{
				ConsoleSystem.Run(Option.Server, convar.ToLower(), Array.Empty<object>());
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Failed to run ConVar '" + convar + "' for gamemode"));
				Debug.LogException(ex);
			}
		}
		ConVar.Server.mapenabled = ingameMap;
		ConVar.Server.hideplayeronmap = hidePlayerOnMap;
		ConVar.Server.hideplayermapdirection = hideMapPlayerDirectionIndicator;
		ConVar.Server.fogofwar = fogOfWar;
		ConVar.Server.fogofwarrevealsize = (int)fogOfWarRevealSize;
		ConVar.Server.compassenabled = compass;
	}

	protected virtual void OnMatchBegin()
	{
		matchStartTime = Time.realtimeSinceStartup;
		SetFlag(Flags.Reserved3, b: false);
		SetFlag(Flags.Reserved1, b: false);
		SetFlag(Flags.Reserved2, b: false);
	}

	public virtual void ResetMatch()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (IsWaitingForPlayers())
		{
			return;
		}
		isResetting = true;
		SetFlag(Flags.Reserved1, b: true, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved2, b: false);
		ResetTeamScores();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				ResetPlayerScores(current);
				current.Hurt(100000f, DamageType.Suicide, null, useProtection: false);
				current.Respawn();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		GameModeSpawnGroup[] array = gameModeSpawnGroups;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].ResetSpawnGroup();
		}
		matchStartTime = -1f;
		((FacepunchBehaviour)this).Invoke((Action)OnMatchBegin, warmupDuration);
		isResetting = false;
	}

	public virtual void ResetTeamScores()
	{
		for (int i = 0; i < teams.Length; i++)
		{
			SetTeamScore(i, 0);
		}
	}

	public virtual void ShutdownGame()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		ResetTeamScores();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				SetPlayerTeam(current, -1);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	private void Update()
	{
		if (!base.isClient)
		{
			OnThink(Time.deltaTime);
		}
	}

	protected virtual void OnThink(float delta)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (matchStartTime != -1f)
		{
			float num = Time.realtimeSinceStartup - matchStartTime;
			if (IsMatchActive() && matchDuration > 0f && num >= matchDuration)
			{
				OnMatchEnd();
			}
		}
		int num2 = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (autoHealDelay > 0f && current.healthFraction < 1f && current.IsAlive() && !current.IsWounded() && current.SecondsSinceAttacked >= autoHealDelay)
				{
					current.Heal(current.MaxHealth() * delta / autoHealDuration);
				}
				if (current.IsConnected)
				{
					num2++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (num2 < minPlayersToStart && !IsWaitingForPlayers())
		{
			if (IsMatchActive())
			{
				OnMatchEnd();
				return;
			}
			SetFlag(Flags.Reserved3, b: true);
			SetFlag(Flags.Reserved2, b: false);
			SetFlag(Flags.Reserved1, b: false);
		}
		else if (IsWaitingForPlayers() && num2 >= minPlayersToStart)
		{
			SetFlag(Flags.Reserved3, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)ResetMatch);
			ResetMatch();
		}
	}

	public virtual void OnMatchEnd()
	{
		matchEndTime = Time.time;
		Debug.Log((object)"Match over!");
		SetFlag(Flags.Reserved2, b: true);
		((FacepunchBehaviour)this).Invoke((Action)ResetMatch, timeBetweenMatches);
	}

	public virtual void OnNewPlayer(BasePlayer player, bool shouldSpawnNow)
	{
		if (shouldSpawnNow)
		{
			player.Respawn();
			if (!AllowsSleeping())
			{
				player.EndSleeping();
				player.SendNetworkUpdateImmediate();
			}
			PostPlayerRespawn(player);
		}
	}

	public void PostPlayerRespawn(BasePlayer player)
	{
		if (startHealthOverride > 0f)
		{
			player.SetMaxHealth(startHealthOverride);
			player.health = startHealthOverride;
		}
	}

	public virtual void OnPlayerConnected(BasePlayer player)
	{
		AutoAssignTeam(player);
		ResetPlayerScores(player);
	}

	public virtual void UnassignAllPlayers()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				SetPlayerTeam(current, -1);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public void AutoAssignTeam(BasePlayer player)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		int newTeam = 0;
		int[] array = new int[teams.Length];
		int num = Random.Range(0, teams.Length);
		int num2 = 0;
		if (teams.Length > 1)
		{
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if (current.gamemodeteam >= 0 && current.gamemodeteam < teams.Length)
					{
						array[current.gamemodeteam]++;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i] < num2)
				{
					num = i;
				}
			}
			newTeam = num;
		}
		SetPlayerTeam(player, newTeam);
	}

	public virtual void OnPlayerDisconnected(BasePlayer player)
	{
		if (gameModeScores == null || base.isClient)
		{
			return;
		}
		PlayerScore val = null;
		foreach (PlayerScore playerScore in gameModeScores.playerScores)
		{
			if (playerScore.userid == (ulong)player.userID)
			{
				val = playerScore;
				break;
			}
		}
		if (val != null)
		{
			gameModeScores.playerScores.Remove(val);
		}
	}

	public virtual void OnPlayerWounded(BasePlayer instigator, BasePlayer victim, HitInfo info)
	{
	}

	public virtual void OnPlayerRevived(BasePlayer instigator, BasePlayer victim)
	{
	}

	public virtual void OnPlayerHurt(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo = null)
	{
		if (!allowBleeding && victim.metabolism.bleeding.value != 0f)
		{
			victim.metabolism.bleeding.value = 0f;
			victim.metabolism.SendChangesToClient();
		}
	}

	public virtual void OnPlayerDeath(BasePlayer instigator, BasePlayer victim, HitInfo deathInfo = null)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		if (!IsMatchActive())
		{
			return;
		}
		if ((Object)(object)victim != (Object)null && victim.IsConnected && !victim.IsNpc)
		{
			ModifyPlayerGameScore(victim, "deaths", 1);
		}
		bool flag = IsTeamGame() && (Object)(object)instigator != (Object)null && (Object)(object)victim != (Object)null && instigator.gamemodeteam == victim.gamemodeteam;
		if ((Object)(object)instigator != (Object)null && (Object)(object)victim != (Object)(object)instigator && !flag && !instigator.IsNpc)
		{
			ModifyPlayerGameScore(instigator, "kills", 1);
		}
		if ((Object)(object)instigator != (Object)null && instigator.IsConnected && !instigator.IsNpc && (Object)(object)instigator != (Object)(object)victim)
		{
			ClientRPC(RpcTarget.Player("RPC_ScoreSplash", instigator), victim.displayName, 100, arg3: true);
		}
		if (hasKillFeed && (Object)(object)instigator != (Object)null && (Object)(object)victim != (Object)null && (Object)(object)deathInfo.Weapon != (Object)null && deathInfo.Weapon.GetItem() != null)
		{
			string text = Vector3.Distance(((Component)instigator).transform.position, ((Component)victim).transform.position).ToString("N0") + "m";
			string text2 = " with a " + deathInfo.Weapon.GetItem().info.displayName.translated + " from " + text;
			string msg = "You Killed " + victim.displayName + text2;
			string msg2 = instigator.displayName + " Killed You" + text2;
			string msg3 = instigator.displayName + " Killed" + victim.displayName + text2;
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					if ((Object)(object)current == (Object)(object)instigator)
					{
						current.ChatMessage(msg);
					}
					else if ((Object)(object)current == (Object)(object)victim)
					{
						current.ChatMessage(msg2);
					}
					else if (BasePlayer.activePlayerList.Count <= 5)
					{
						current.ChatMessage(msg3);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		CheckGameConditions(force: true);
	}

	public virtual bool CanPlayerRespawn(BasePlayer player)
	{
		if (IsMatchOver() && !IsWaitingForPlayers())
		{
			return isResetting;
		}
		return true;
	}

	public virtual void OnPlayerRespawn(BasePlayer player)
	{
		if (!AllowsSleeping())
		{
			player.EndSleeping();
			player.MarkRespawn(respawnDelayOverride);
			SendNetworkUpdateImmediate();
		}
		PostPlayerRespawn(player);
	}

	public virtual void CheckGameConditions(bool force = false)
	{
		if (!IsMatchActive())
		{
			return;
		}
		if (IsTeamGame())
		{
			for (int i = 0; i < teams.Length; i++)
			{
				if (GetTeamScore(i) >= numScoreForVictory)
				{
					OnMatchEnd();
				}
			}
			return;
		}
		int num = ScoreColumnIndex(victoryScoreName);
		if (num == -1)
		{
			return;
		}
		foreach (PlayerScore playerScore in gameModeScores.playerScores)
		{
			if (playerScore.scores[num] >= numScoreForVictory)
			{
				OnMatchEnd();
			}
		}
	}

	public virtual void LoadoutPlayer(BasePlayer player)
	{
		PlayerInventoryProperties playerInventoryProperties;
		if (!IsTeamGame())
		{
			playerInventoryProperties = ((!useStaticLoadoutPerPlayer) ? loadouts[Random.Range(0, loadouts.Length)] : loadouts[SeedRandom.Range((uint)(ulong)player.userID, 0, loadouts.Length)]);
		}
		else
		{
			if (player.gamemodeteam == -1)
			{
				Debug.LogWarning((object)"Player loading out without team assigned, auto assigning!");
				AutoAssignTeam(player);
			}
			playerInventoryProperties = teams[player.gamemodeteam].teamloadouts[SeedRandom.Range((uint)(ulong)player.userID, 0, teams[player.gamemodeteam].teamloadouts.Length)];
		}
		if (Object.op_Implicit((Object)(object)playerInventoryProperties))
		{
			playerInventoryProperties.GiveToPlayer(player);
		}
		else
		{
			player.inventory.GiveItem(ItemManager.CreateByName("hazmatsuit", 1, 0uL), player.inventory.containerWear);
		}
		if (!topUpMagazines)
		{
			return;
		}
		foreach (Item item in player.inventory.containerBelt.itemList)
		{
			BaseEntity heldEntity = item.GetHeldEntity();
			if ((Object)(object)heldEntity != (Object)null)
			{
				BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
				if ((Object)(object)component != (Object)null)
				{
					component.TopUpAmmo();
				}
			}
		}
	}

	public virtual void InstallSpawnpoints()
	{
		allspawns = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (allspawns != null)
		{
			Debug.Log((object)("Installed : " + allspawns.Length + "spawn points."));
		}
	}

	public virtual BasePlayer.SpawnPoint GetPlayerSpawn(BasePlayer forPlayer)
	{
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (allspawns == null)
		{
			InstallSpawnpoints();
		}
		float num = 0f;
		int num2 = Random.Range(0, allspawns.Length);
		if (allspawns.Length != 0 && (Object)(object)forPlayer != (Object)null)
		{
			for (int i = 0; i < allspawns.Length; i++)
			{
				GameObject val = allspawns[i];
				float num3 = 0f;
				for (int j = 0; j < BasePlayer.activePlayerList.Count; j++)
				{
					BasePlayer basePlayer = BasePlayer.activePlayerList[j];
					if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsAlive() && !((Object)(object)basePlayer == (Object)(object)forPlayer))
					{
						float num4 = Vector3.Distance(((Component)basePlayer).transform.position, val.transform.position);
						num3 -= 100f * (1f - Mathf.InverseLerp(8f, 16f, num4));
						if (!IsTeamGame() || basePlayer.gamemodeteam != forPlayer.gamemodeteam)
						{
							num3 += 100f * Mathf.InverseLerp(16f, 32f, num4);
						}
					}
				}
				float num5 = Vector3.Distance((forPlayer.ServerCurrentDeathNote == null) ? allspawns[Random.Range(0, allspawns.Length)].transform.position : forPlayer.ServerCurrentDeathNote.worldPosition, val.transform.position);
				float num6 = Mathf.InverseLerp(8f, 25f, num5);
				num3 *= num6;
				if (num3 > num)
				{
					num2 = i;
					num = num3;
				}
			}
		}
		GameObject val2 = allspawns[num2];
		return new BasePlayer.SpawnPoint
		{
			pos = val2.transform.position,
			rot = val2.transform.rotation
		};
	}

	public virtual int GetMaxRelationshipTeamSize()
	{
		return RelationshipManager.maxTeamSize;
	}

	public virtual PooledList<SleepingBag> FindSleepingBagsForPlayer(ulong playerID, bool ignoreTimers)
	{
		return SleepingBag.FindForPlayer(playerID, ignoreTimers);
	}

	public virtual bool CanMoveItemsFrom(PlayerInventory inv, BaseEntity source, Item item)
	{
		return true;
	}

	public bool HasBlockedMission(BaseMission mission)
	{
		BaseMission[] array = blockedMissions;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].id == mission.id)
			{
				return true;
			}
		}
		return false;
	}

	public int GetLootWeightModifier(ItemDefinition forDefinition)
	{
		if ((Object)(object)forDefinition == (Object)null)
		{
			return 0;
		}
		int num = 0;
		LootTypeModifier[] lootDistributionModifiers = LootDistributionModifiers;
		for (int i = 0; i < lootDistributionModifiers.Length; i++)
		{
			LootTypeModifier lootTypeModifier = lootDistributionModifiers[i];
			if ((lootTypeModifier.LootType & forDefinition.lootDistributionType) != 0)
			{
				num += lootTypeModifier.Modifier;
			}
		}
		return num;
	}

	public float GetCraftingCostModifier(ItemDefinition forDefinition)
	{
		if ((Object)(object)forDefinition == (Object)null)
		{
			return 1f;
		}
		CraftingCostMultiplier[] craftingCostModifiers = CraftingCostModifiers;
		for (int i = 0; i < craftingCostModifiers.Length; i++)
		{
			CraftingCostMultiplier craftingCostMultiplier = craftingCostModifiers[i];
			if ((craftingCostMultiplier.LootType & forDefinition.lootDistributionType) != 0)
			{
				if (craftingCostMultiplier.ConVarToUse != 0)
				{
					return GetCraftingCostConVar(craftingCostMultiplier.ConVarToUse);
				}
				return craftingCostMultiplier.Multiplier;
			}
		}
		return 1f;
	}

	protected virtual float GetCraftingCostConVar(CraftingCostConVar conVar)
	{
		return 1f;
	}

	public bool IsAllowed(ItemDefinition item, EraRestriction restriction)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		ItemRestriction[] restrictions = Restrictions;
		for (int i = 0; i < restrictions.Length; i++)
		{
			ItemRestriction itemRestriction = restrictions[i];
			if ((Object)(object)itemRestriction.Definition == (Object)(object)item && (int)restriction != 0 && (int)itemRestriction.Restriction != 0 && (itemRestriction.Restriction & restriction) == 0)
			{
				return false;
			}
		}
		return true;
	}

	public bool IsAllowed(TechTreeData techTree)
	{
		if (allowedTechTrees == null || allowedTechTrees.Length == 0)
		{
			return !techTree.RequireGameMode;
		}
		TechTreeData[] array = allowedTechTrees;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i] == (Object)(object)techTree)
			{
				return true;
			}
		}
		return false;
	}
}


public struct ResearchCostResult
{
	public float? Scale;

	public int? Amount;
}


using System;

[Serializable]
public class GameModeTeam
{
	public string name;

	public PlayerInventoryProperties[] teamloadouts;
}


using System;
using Rust;

[Serializable]
public struct ItemRestriction
{
	public ItemDefinition Definition;

	public EraRestriction Restriction;
}


using System;

[Serializable]
public struct LootTypeModifier
{
	public ItemDefinition.LootDistributionModifierType LootType;

	public int Modifier;
}


using System;
using UnityEngine;

[Serializable]
public struct CraftingCostMultiplier
{
	public ItemDefinition.LootDistributionModifierType LootType;

	[Range(0f, 20f)]
	public float Multiplier;

	[Tooltip("Will override the Multiplier if set")]
	public CraftingCostConVar ConVarToUse;
}


public enum CraftingCostConVar
{
	None,
	HardcoreFirearmAmmunition
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseLauncher : BaseProjectile
{
	public float initialSpeedMultiplier = 1f;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseLauncher.OnRpcMessage", 0);
		try
		{
			if (rpc == 853319324 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_Launch "));
				}
				TimeWarning val2 = TimeWarning.New("SV_Launch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(853319324u, "SV_Launch", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_Launch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SV_Launch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override bool ForceSendMagazine(SaveInfo saveInfo)
	{
		return true;
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile component = ((Component)primaryMagazine.ammoType).GetComponent<ItemModProjectile>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return;
		}
		if (primaryMagazine.contents <= 0)
		{
			SignalBroadcast(Signal.DryFire);
			StartAttackCooldown(1f);
			return;
		}
		if (!Object.op_Implicit((Object)(object)component.projectileObject.Get().GetComponent<ServerProjectile>()))
		{
			base.ServerUse(damageModifier, speedModifier, originOverride, useBulletThickness);
			return;
		}
		ModifyAmmoCount(-1);
		if (primaryMagazine.contents < 0)
		{
			SetAmmoCount(0);
		}
		Vector3 val = ((Component)MuzzlePoint).transform.forward;
		Vector3 position = ((Component)MuzzlePoint).transform.position;
		float num = GetAimCone() + component.projectileSpread;
		if (num > 0f)
		{
			val = AimConeUtil.GetModifiedAimConeDirection(num, val);
		}
		float num2 = 1f;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(position, val, ref val2, num2, 1237003025))
		{
			num2 = ((RaycastHit)(ref val2)).distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, position + val * num2);
		if (!((Object)(object)baseEntity == (Object)null))
		{
			BasePlayer ownerPlayer = GetOwnerPlayer();
			bool flag = (Object)(object)ownerPlayer != (Object)null && ownerPlayer.IsNpc;
			ServerProjectile component2 = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component2))
			{
				component2.InitializeVelocity(val * component2.speed * initialSpeedMultiplier);
			}
			((Component)baseEntity).SendMessage("SetDamageScale", (object)(flag ? npcDamageScale : turretDamageScale));
			baseEntity.Spawn();
			StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
			SignalBroadcast(Signal.Attack, string.Empty);
			GetOwnerItem()?.LoseCondition(Random.Range(1f, 2f));
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void SV_Launch(RPCMessage msg)
	{
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		if (reloadFinished && HasReloadCooldown())
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Reloading (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "reload_cooldown");
			return;
		}
		reloadStarted = false;
		reloadFinished = false;
		if (!base.UsingInfiniteAmmoCheat)
		{
			if (primaryMagazine.contents <= 0)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Magazine empty (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "magazine_empty");
				return;
			}
			ModifyAmmoCount(-1);
		}
		SignalBroadcast(Signal.Attack, string.Empty, player.net.connection);
		Vector3 val = msg.read.Vector3();
		Vector3 val2 = msg.read.Vector3();
		Vector3 val3 = ((Vector3)(ref val2)).normalized;
		bool num = msg.read.Bit();
		BaseEntity mounted = player.GetParentEntity();
		if ((Object)(object)mounted == (Object)null)
		{
			mounted = player.GetMounted();
		}
		if (num)
		{
			if ((Object)(object)mounted != (Object)null)
			{
				val = ((Component)mounted).transform.TransformPoint(val);
				val3 = ((Component)mounted).transform.TransformDirection(val3);
			}
			else
			{
				val = player.eyes.position;
				val3 = player.eyes.BodyForward();
			}
		}
		if (!ValidateEyePos(player, val))
		{
			return;
		}
		ItemModProjectile component = ((Component)primaryMagazine.ammoType).GetComponent<ItemModProjectile>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
			return;
		}
		float num2 = GetAimCone() + component.projectileSpread;
		if (num2 > 0f)
		{
			val3 = AimConeUtil.GetModifiedAimConeDirection(num2, val3);
		}
		float num3 = 1f;
		RaycastHit val4 = default(RaycastHit);
		if (Physics.Raycast(val, val3, ref val4, num3, 1237003025))
		{
			num3 = ((RaycastHit)(ref val4)).distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.projectileObject.resourcePath, val + val3 * num3);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.creatorEntity = player;
		ServerProjectile component2 = ((Component)baseEntity).GetComponent<ServerProjectile>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.InitializeVelocity(GetInheritedVelocity(player, val3) + val3 * component2.speed * initialSpeedMultiplier);
		}
		baseEntity.Spawn();
		ProjectileLaunched_Server(component2);
		Analytics.Azure.OnExplosiveLaunched(player, baseEntity, this);
		Interface.CallHook("OnRocketLaunched", (object)player, (object)baseEntity);
		StartAttackCooldown(ScaleRepeatDelay(repeatDelay));
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null)
		{
			if (!base.UsingInfiniteAmmoCheat)
			{
				ownerItem.LoseCondition(Random.Range(1f, 2f));
			}
			BaseMountable mounted2 = player.GetMounted();
			if ((Object)(object)mounted2 != (Object)null)
			{
				mounted2.OnWeaponFired(this);
			}
		}
	}

	public virtual void ProjectileLaunched_Server(ServerProjectile justLaunched)
	{
	}
}


using System;
using ConVar;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseLiquidVessel : AttackEntity
{
	[Header("Liquid Vessel")]
	public GameObjectRef thrownWaterObject;

	public GameObjectRef ThrowEffect3P;

	public SoundDefinition throwSound3P;

	public GameObjectRef fillFromContainer;

	public GameObjectRef fillFromWorld;

	public SoundDefinition fillFromContainerStartSoundDef;

	public SoundDefinition fillFromContainerSoundDef;

	public SoundDefinition fillFromWorldStartSoundDef;

	public SoundDefinition fillFromWorldSoundDef;

	public bool hasLid;

	public float throwScale = 10f;

	public bool canDrinkFrom;

	public bool updateVMWater;

	public float minThrowFrac;

	public bool useThrowAnim;

	public float fillMlPerSec = 500f;

	public static Phrase DifferentLiquidType = new Phrase("fill_different_liquid_type", "You can't mix different liquids");

	private float lastFillTime;

	private TimeSince timeSinceLastToast;

	private float nextFreeTime;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseLiquidVessel.OnRpcMessage", 0);
		try
		{
			if (rpc == 4013436649u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - DoDrink "));
				}
				TimeWarning val2 = TimeWarning.New("DoDrink", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4013436649u, "DoDrink", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							DoDrink(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in DoDrink");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 2781345828u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SendFilling "));
				}
				TimeWarning val2 = TimeWarning.New("SendFilling", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg3 = rPCMessage;
						SendFilling(msg3);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex2)
				{
					Debug.LogException(ex2);
					player.Kick("RPC Error in SendFilling");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3038767821u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - ThrowContents "));
				}
				TimeWarning val2 = TimeWarning.New("ThrowContents", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg4 = rPCMessage;
						ThrowContents(msg4);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex3)
				{
					Debug.LogException(ex3);
					player.Kick("RPC Error in ThrowContents");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)FillCheck, 1f, 1f);
	}

	public override void OnHeldChanged()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		base.OnHeldChanged();
		if (IsDisabled())
		{
			StopFilling();
		}
		if (!hasLid)
		{
			DoThrow(((Component)this).transform.position, Vector3.zero);
			Item item = GetItem();
			if (item != null && item.contents != null)
			{
				item.contents.SetLocked(IsDisabled());
				SendNetworkUpdateImmediate();
			}
		}
	}

	public void SetFilling(bool isFilling)
	{
		SetFlag(Flags.Open, isFilling);
		if (isFilling)
		{
			StartFilling();
		}
		else
		{
			StopFilling();
		}
		OnSetFilling(isFilling);
	}

	public virtual void OnSetFilling(bool flag)
	{
	}

	public void StartFilling()
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.realtimeSinceStartup - lastFillTime;
		StopFilling();
		((FacepunchBehaviour)this).InvokeRepeating((Action)FillCheck, 0f, 0.3f);
		if (num > 0.2f)
		{
			LiquidContainer facingLiquidContainer = GetFacingLiquidContainer();
			if ((Object)(object)facingLiquidContainer != (Object)null && facingLiquidContainer.GetLiquidItem() != null)
			{
				if (fillFromContainer.isValid)
				{
					Effect.server.Run(fillFromContainer.resourcePath, ((Component)facingLiquidContainer).transform.position, Vector3.up);
				}
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartFillingSoundsContainer"));
			}
			else if (CanFillFromWorld())
			{
				if (fillFromWorld.isValid)
				{
					Effect.server.Run(fillFromWorld.resourcePath, GetOwnerPlayer(), 0u, Vector3.zero, Vector3.up);
				}
				ClientRPC(RpcTarget.NetworkGroup("CLIENT_StartFillingSoundsWorld"));
			}
		}
		lastFillTime = Time.realtimeSinceStartup;
	}

	public void StopFilling()
	{
		ClientRPC(RpcTarget.NetworkGroup("CLIENT_StopFillingSounds"));
		((FacepunchBehaviour)this).CancelInvoke((Action)FillCheck);
	}

	public void FillCheck()
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return;
		}
		float num = (Time.realtimeSinceStartup - lastFillTime) * fillMlPerSec;
		Vector3 pos = ((Component)ownerPlayer).transform.position - new Vector3(0f, 1f, 0f);
		LiquidContainer facingLiquidContainer = GetFacingLiquidContainer();
		if (Interface.CallHook("OnLiquidVesselFill", (object)this, (object)ownerPlayer, (object)facingLiquidContainer) != null)
		{
			return;
		}
		if ((Object)(object)facingLiquidContainer == (Object)null && CanFillFromWorld())
		{
			Item contents = GetContents();
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(pos);
			if (contents != null && contents.info.itemid != itemDefinition.itemid)
			{
				if (TimeSince.op_Implicit(timeSinceLastToast) > 5f)
				{
					Debug.Log((object)"pushing toast");
					timeSinceLastToast = TimeSince.op_Implicit(0f);
					ownerPlayer.ShowToast(GameTip.Styles.Red_Normal, DifferentLiquidType, false);
				}
				return;
			}
			AddLiquid(itemDefinition, Mathf.FloorToInt(num));
		}
		else if ((Object)(object)facingLiquidContainer != (Object)null && facingLiquidContainer.HasLiquidItem())
		{
			int num2 = Mathf.CeilToInt((1f - HeldFraction()) * (float)MaxHoldable());
			if (num2 > 0)
			{
				GetContents();
				Item liquidItem = facingLiquidContainer.GetLiquidItem();
				int num3 = Mathf.Min(Mathf.CeilToInt(num), Mathf.Min(liquidItem.amount, num2));
				AddLiquid(liquidItem.info, num3);
				liquidItem.UseItem(num3);
				facingLiquidContainer.OpenTap(2f);
			}
		}
		lastFillTime = Time.realtimeSinceStartup;
	}

	public void LoseWater(int amount)
	{
		if (!base.UsingInfiniteAmmoCheat)
		{
			Item contents = GetContents();
			if (contents != null)
			{
				contents.UseItem(amount);
				contents.MarkDirty();
				SendNetworkUpdateImmediate();
			}
		}
	}

	public void AddLiquid(ItemDefinition liquidType, int amount)
	{
		if (amount <= 0)
		{
			return;
		}
		Item item = GetItem();
		Item item2 = item.contents.GetSlot(0);
		ItemModContainer component = ((Component)item.info).GetComponent<ItemModContainer>();
		if (item2 == null)
		{
			Item item3 = ItemManager.Create(liquidType, amount, 0uL);
			item3?.MoveToContainer(item.contents);
			item.contents?.onItemAddedToStack?.Invoke(item3, amount);
			return;
		}
		int num = Mathf.Clamp(item2.amount + amount, 0, component.maxStackSize);
		ItemDefinition itemDefinition = WaterResource.Merge(item2.info, liquidType);
		if ((Object)(object)itemDefinition != (Object)(object)item2.info)
		{
			item2.Remove();
			item2 = ItemManager.Create(itemDefinition, num, 0uL);
			item2.MoveToContainer(item.contents);
		}
		else
		{
			item2.amount = num;
		}
		item.contents?.onItemAddedToStack?.Invoke(item2, amount);
		item2.MarkDirty();
		SendNetworkUpdateImmediate();
	}

	public Item GetContents()
	{
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return null;
		}
		Item slot = item.contents.GetSlot(0);
		if (slot == null)
		{
			return null;
		}
		return slot;
	}

	public int AmountHeld()
	{
		return GetContents()?.amount ?? 0;
	}

	public float HeldFraction()
	{
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return 0f;
		}
		return (float)AmountHeld() / (float)MaxHoldable();
	}

	public int MaxHoldable()
	{
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return 1;
		}
		return ((Component)GetItem().info).GetComponent<ItemModContainer>().maxStackSize;
	}

	public bool CanDrink()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (!ownerPlayer.metabolism.CanConsume())
		{
			return false;
		}
		if (!canDrinkFrom)
		{
			return false;
		}
		Item item = GetItem();
		if (item == null)
		{
			return false;
		}
		if (item.contents == null)
		{
			return false;
		}
		if (item.contents.itemList == null)
		{
			return false;
		}
		if (item.contents.itemList.Count == 0)
		{
			return false;
		}
		return true;
	}

	private bool IsWeaponBusy()
	{
		return Time.realtimeSinceStartup < nextFreeTime;
	}

	private void SetBusyFor(float dur)
	{
		nextFreeTime = Time.realtimeSinceStartup + dur;
	}

	private void ClearBusy()
	{
		nextFreeTime = Time.realtimeSinceStartup - 1f;
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void DoDrink(RPCMessage msg)
	{
		if (!msg.player.CanInteract())
		{
			return;
		}
		Item item = GetItem();
		if (item == null || item.contents == null || !msg.player.metabolism.CanConsume())
		{
			return;
		}
		foreach (Item item2 in item.contents.itemList)
		{
			ItemModConsume component = ((Component)item2.info).GetComponent<ItemModConsume>();
			if (!((Object)(object)component == (Object)null) && component.CanDoAction(item2, msg.player))
			{
				component.DoAction(item2, msg.player);
				item.contents?.onItemRemovedFromStack?.Invoke(item2, 0);
				break;
			}
		}
	}

	[RPC_Server]
	private void ThrowContents(RPCMessage msg)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null))
		{
			DoThrow(ownerPlayer.eyes.position + ownerPlayer.eyes.BodyForward() * 1f, ownerPlayer.estimatedVelocity + ownerPlayer.eyes.BodyForward() * throwScale);
			Effect.server.Run(ThrowEffect3P.resourcePath, ((Component)ownerPlayer).transform.position, ownerPlayer.eyes.BodyForward(), ownerPlayer.net.connection);
		}
	}

	public void DoThrow(Vector3 pos, Vector3 velocity)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return;
		}
		Item item = GetItem();
		if (item == null || item.contents == null)
		{
			return;
		}
		Item slot = item.contents.GetSlot(0);
		if (slot != null && slot.amount > 0)
		{
			Ray ray = default(Ray);
			((Ray)(ref ray))..ctor(ownerPlayer.eyes.position, ownerPlayer.eyes.BodyForward());
			float num = 1f;
			if (GamePhysics.Trace(ray, 0f, out var hitInfo, num, 1084293377, (QueryTriggerInteraction)0))
			{
				num = Mathf.Clamp01(((RaycastHit)(ref hitInfo)).distance - 0.1f);
			}
			Vector3 point = ((Ray)(ref ray)).GetPoint(num);
			WaterBall waterBall = GameManager.server.CreateEntity(thrownWaterObject.resourcePath, point, Quaternion.identity) as WaterBall;
			if (Object.op_Implicit((Object)(object)waterBall))
			{
				waterBall.liquidType = slot.info;
				waterBall.waterAmount = slot.amount;
				((Component)waterBall).transform.position = point;
				waterBall.SetVelocity(velocity);
				waterBall.Spawn();
			}
			slot.UseItem(slot.amount);
			item.contents?.onItemAddedRemoved?.Invoke(slot, arg2: false);
			slot.MarkDirty();
			SendNetworkUpdateImmediate();
		}
	}

	[RPC_Server]
	private void SendFilling(RPCMessage msg)
	{
		bool filling = msg.read.Bit();
		SetFilling(filling);
	}

	public bool CanFillFromWorld()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer))
		{
			return false;
		}
		if (ownerPlayer.IsInWaterVolume(((Component)this).transform.position, out var natural) && !natural)
		{
			return false;
		}
		return ownerPlayer.WaterFactor() >= 0.05f;
	}

	public bool CanThrow()
	{
		return HeldFraction() > minThrowFrac;
	}

	public LiquidContainer GetFacingLiquidContainer()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!Object.op_Implicit((Object)(object)ownerPlayer) || (Object)(object)ownerPlayer.eyes == (Object)null)
		{
			return null;
		}
		RaycastHit hit = default(RaycastHit);
		if (Physics.Raycast(ownerPlayer.eyes.HeadRay(), ref hit, 2f, 1237003025))
		{
			BaseEntity entity = hit.GetEntity();
			if (Object.op_Implicit((Object)(object)entity) && !((Component)((RaycastHit)(ref hit)).collider).gameObject.CompareTag("Not Player Usable") && !((Component)((RaycastHit)(ref hit)).collider).gameObject.CompareTag("Usable Primary"))
			{
				entity = entity.ToServer<BaseEntity>();
				return ((Component)entity).GetComponent<LiquidContainer>();
			}
		}
		return null;
	}
}


using System;
using ConVar;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseLock : BaseEntity
{
	[ItemSelector]
	public ItemDefinition itemType;

	public bool CanRemove = true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseLock.OnRpcMessage", 0);
		try
		{
			if (rpc == 3572556655u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_TakeLock "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_TakeLock", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(3572556655u, "RPC_TakeLock", this, player, 3f, checkParent: true))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_TakeLock(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_TakeLock");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool GetPlayerLockPermission(BasePlayer player)
	{
		return OnTryToOpen(player);
	}

	public virtual bool OnTryToOpen(BasePlayer player)
	{
		return !IsLocked();
	}

	public virtual bool OnTryToClose(BasePlayer player)
	{
		return true;
	}

	public virtual bool HasLockPermission(BasePlayer player)
	{
		return true;
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f, CheckParent = true)]
	public void RPC_TakeLock(RPCMessage rpc)
	{
		if (rpc.player.CanInteract() && CanRemove && Interface.CallHook("CanPickupLock", (object)rpc.player, (object)this) == null && !IsLocked())
		{
			Item item = ItemManager.Create(itemType, 1, skinID);
			if (item != null)
			{
				rpc.player.GiveItem(item);
			}
			Analytics.Azure.OnEntityPickedUp(rpc.player, this);
			BaseEntity baseEntity = GetParentEntity();
			if ((Object)(object)baseEntity != (Object)null && (Object)(object)baseEntity.GetSlot(Slot.Lock) == (Object)(object)this)
			{
				baseEntity.SetSlot(Slot.Lock, null);
			}
			Kill();
		}
	}

	public override float BoundsPadding()
	{
		return 2f;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseMelee : AttackEntity
{
	[Serializable]
	public class MaterialFX
	{
		public string materialName;

		public GameObjectRef fx;
	}

	[Header("Melee")]
	public DamageProperties damageProperties;

	public List<DamageTypeEntry> damageTypes;

	public List<DamageTypeEntry> deployableDamageOverrides;

	public float maxDistance = 1.5f;

	public float attackRadius = 0.3f;

	public bool isAutomatic = true;

	public bool blockSprintOnAttack = true;

	public bool canUntieCrates;

	public bool longResourceForgiveness;

	[Header("Effects")]
	public GameObjectRef strikeFX;

	public bool useStandardHitEffects = true;

	[Header("NPCUsage")]
	public float aiStrikeDelay = 0.2f;

	public GameObjectRef swingEffect;

	public List<MaterialFX> materialStrikeFX = new List<MaterialFX>();

	[Header("Other")]
	[Range(0f, 1f)]
	public float heartStress = 0.5f;

	public ResourceDispenser.GatherProperties gathering;

	[Header("Throwing")]
	public bool canThrowAsProjectile;

	public bool canThrowAsEntity;

	public bool canAiHearIt;

	public bool canScareAiWhenAimed;

	public bool onlyThrowAsProjectile;

	public bool ThrowFullStack = true;

	public bool canThrowCheck
	{
		get
		{
			if (!canThrowAsProjectile)
			{
				return canThrowAsEntity;
			}
			return true;
		}
	}

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseMelee.OnRpcMessage", 0);
		try
		{
			if (rpc == 2215098782u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CLEntityThrow "));
				}
				TimeWarning val2 = TimeWarning.New("CLEntityThrow", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(2215098782u, "CLEntityThrow", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(2215098782u, "CLEntityThrow", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							CLEntityThrow(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in CLEntityThrow");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 3168282921u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - CLProject "));
				}
				TimeWarning val2 = TimeWarning.New("CLProject", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.FromOwner.Test(3168282921u, "CLProject", this, player, includeMounted: false))
						{
							return true;
						}
						if (!RPC_Server.IsActiveItem.Test(3168282921u, "CLProject", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							CLProject(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in CLProject");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4088326849u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - PlayerAttack "));
				}
				TimeWarning val2 = TimeWarning.New("PlayerAttack", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsActiveItem.Test(4088326849u, "PlayerAttack", this, player))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg4 = rPCMessage;
							PlayerAttack(msg4);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex3)
					{
						Debug.LogException(ex3);
						player.Kick("RPC Error in PlayerAttack");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void GetAttackStats(HitInfo info)
	{
		List<DamageTypeEntry> entries = damageTypes;
		if (deployableDamageOverrides != null && deployableDamageOverrides.Count > 0 && info.HitEntity is DecayEntity && !(info.HitEntity is BuildingBlock) && !(info.HitEntity is BasePlayer) && !(info.HitEntity is Door) && !(info.HitEntity is SimpleBuildingBlock) && !(info.HitEntity is LootContainer))
		{
			entries = deployableDamageOverrides;
		}
		info.damageTypes.Add(entries);
		info.CanGather = gathering.Any();
	}

	public virtual void DoAttackShared(HitInfo info)
	{
		if (Interface.CallHook("OnPlayerAttack", (object)GetOwnerPlayer(), (object)info) != null)
		{
			return;
		}
		GetAttackStats(info);
		if ((Object)(object)info.HitEntity != (Object)null)
		{
			TimeWarning val = TimeWarning.New("OnAttacked", 50);
			try
			{
				info.HitEntity.OnAttacked(info);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (info.DoHitEffects && base.isServer)
		{
			TimeWarning val = TimeWarning.New("ImpactEffect", 20);
			try
			{
				Effect.server.ImpactEffect(info);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			if (!base.IsDestroyed)
			{
				SingletonComponent<NpcNoiseManager>.Instance.OnMeleeHit(this, info);
			}
		}
		if (base.isServer && !base.IsDestroyed)
		{
			TimeWarning val = TimeWarning.New("UpdateItemCondition", 50);
			try
			{
				UpdateItemCondition(info);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			StartAttackCooldown(repeatDelay);
		}
	}

	public ResourceDispenser.GatherPropertyEntry GetGatherInfoFromIndex(ResourceDispenser.GatherType index)
	{
		return gathering.GetFromIndex(index);
	}

	public virtual bool CanHit(HitTest info)
	{
		return true;
	}

	public float TotalDamage()
	{
		float num = 0f;
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			if (!(damageType.amount <= 0f))
			{
				num += damageType.amount;
			}
		}
		return num;
	}

	public bool IsItemBroken()
	{
		return GetOwnerItem()?.isBroken ?? true;
	}

	public void LoseCondition(float amount)
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem != null && !base.UsingInfiniteAmmoCheat)
		{
			ownerItem.LoseCondition(amount);
		}
	}

	public virtual float GetConditionLoss()
	{
		return 1f;
	}

	public void UpdateItemCondition(HitInfo info)
	{
		Item ownerItem = GetOwnerItem();
		if (ownerItem == null || !ownerItem.hasCondition || info == null || !info.DidHit || info.DidGather)
		{
			return;
		}
		float conditionLoss = GetConditionLoss();
		float num = 0f;
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			if (!(damageType.amount <= 0f))
			{
				num += Mathf.Clamp(damageType.amount - info.damageTypes.Get(damageType.type), 0f, damageType.amount);
			}
		}
		conditionLoss += num * 0.2f;
		if (!base.UsingInfiniteAmmoCheat)
		{
			ownerItem.LoseCondition(conditionLoss);
		}
	}

	[RPC_Server]
	[RPC_Server.IsActiveItem]
	public void PlayerAttack(RPCMessage msg)
	{
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0583: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_0494: Unknown result type (might be due to invalid IL or missing references)
		//IL_0653: Unknown result type (might be due to invalid IL or missing references)
		//IL_0658: Unknown result type (might be due to invalid IL or missing references)
		//IL_0660: Unknown result type (might be due to invalid IL or missing references)
		//IL_0665: Unknown result type (might be due to invalid IL or missing references)
		//IL_0668: Unknown result type (might be due to invalid IL or missing references)
		//IL_066d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0670: Unknown result type (might be due to invalid IL or missing references)
		//IL_0675: Unknown result type (might be due to invalid IL or missing references)
		//IL_0677: Unknown result type (might be due to invalid IL or missing references)
		//IL_0679: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_067d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0682: Unknown result type (might be due to invalid IL or missing references)
		//IL_0686: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_069a: Unknown result type (might be due to invalid IL or missing references)
		//IL_069d: Unknown result type (might be due to invalid IL or missing references)
		//IL_069f: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0721: Unknown result type (might be due to invalid IL or missing references)
		//IL_0723: Unknown result type (might be due to invalid IL or missing references)
		//IL_0725: Unknown result type (might be due to invalid IL or missing references)
		//IL_072a: Unknown result type (might be due to invalid IL or missing references)
		//IL_072c: Unknown result type (might be due to invalid IL or missing references)
		//IL_072e: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06de: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0701: Unknown result type (might be due to invalid IL or missing references)
		//IL_0703: Unknown result type (might be due to invalid IL or missing references)
		//IL_0705: Unknown result type (might be due to invalid IL or missing references)
		//IL_0707: Unknown result type (might be due to invalid IL or missing references)
		//IL_070c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0710: Unknown result type (might be due to invalid IL or missing references)
		//IL_071a: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08db: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_073d: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0741: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_0748: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0910: Unknown result type (might be due to invalid IL or missing references)
		//IL_0912: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075b: Unknown result type (might be due to invalid IL or missing references)
		//IL_075d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0762: Unknown result type (might be due to invalid IL or missing references)
		//IL_076e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0770: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0376: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_092c: Unknown result type (might be due to invalid IL or missing references)
		//IL_092e: Unknown result type (might be due to invalid IL or missing references)
		//IL_077c: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_099e: Unknown result type (might be due to invalid IL or missing references)
		//IL_09a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_09ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_09f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0941: Unknown result type (might be due to invalid IL or missing references)
		//IL_0943: Unknown result type (might be due to invalid IL or missing references)
		//IL_0819: Unknown result type (might be due to invalid IL or missing references)
		//IL_081b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0835: Unknown result type (might be due to invalid IL or missing references)
		//IL_0837: Unknown result type (might be due to invalid IL or missing references)
		//IL_0852: Unknown result type (might be due to invalid IL or missing references)
		//IL_0854: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_0872: Unknown result type (might be due to invalid IL or missing references)
		//IL_088e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0890: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerAttack", 50);
		try
		{
			PlayerAttack val2 = msg.read.Proto<PlayerAttack>((PlayerAttack)null);
			try
			{
				if (val2 == null)
				{
					return;
				}
				HitInfo hitInfo = Pool.Get<HitInfo>();
				hitInfo.LoadFromAttack(val2.attack, serverSide: true);
				hitInfo.Initiator = player;
				hitInfo.Weapon = this;
				hitInfo.WeaponPrefab = this;
				hitInfo.Predicted = msg.connection;
				hitInfo.damageProperties = damageProperties;
				if (Interface.CallHook("OnMeleeAttack", (object)player, (object)hitInfo) != null)
				{
					return;
				}
				if (hitInfo.IsNaNOrInfinity())
				{
					string shortPrefabName = base.ShortPrefabName;
					AntiHack.Log(player, AntiHackType.MeleeHack, "Contains NaN (" + shortPrefabName + ")");
					player.stats.combat.LogInvalid(hitInfo, "melee_nan");
					return;
				}
				BaseEntity hitEntity = hitInfo.HitEntity;
				BasePlayer basePlayer = hitInfo.HitEntity as BasePlayer;
				bool flag = (Object)(object)basePlayer != (Object)null;
				bool flag2 = flag && basePlayer.IsSleeping();
				bool flag3 = flag && basePlayer.IsWounded();
				bool flag4 = flag && basePlayer.isMounted;
				bool flag5 = flag && basePlayer.HasParent();
				bool flag6 = (Object)(object)hitEntity != (Object)null;
				bool flag7 = flag6 && hitEntity.IsNpc;
				bool flag8;
				int num5;
				Vector3 val3;
				Vector3 center;
				Vector3 position;
				Vector3 pointStart;
				Vector3 hitPositionWorld;
				Vector3 val5;
				int num18;
				if (ConVar.AntiHack.melee_protection > 0)
				{
					flag8 = true;
					float num = 1f + ConVar.AntiHack.melee_forgiveness;
					float melee_clientframes = ConVar.AntiHack.melee_clientframes;
					float melee_serverframes = ConVar.AntiHack.melee_serverframes;
					float num2 = melee_clientframes / 60f;
					float num3 = melee_serverframes * Mathx.Max(Time.deltaTime, Time.smoothDeltaTime, Time.fixedDeltaTime);
					float num4 = (player.desyncTimeClamped + num2 + num3) * num;
					num5 = 1075904512;
					if (ConVar.AntiHack.melee_terraincheck)
					{
						num5 |= 0x800000;
					}
					if (ConVar.AntiHack.melee_vehiclecheck)
					{
						num5 |= 0x8000000;
					}
					if (flag && hitInfo.boneArea == (HitArea)(-1))
					{
						string shortPrefabName2 = base.ShortPrefabName;
						string shortPrefabName3 = basePlayer.ShortPrefabName;
						AntiHack.Log(player, AntiHackType.MeleeHack, "Bone is invalid  (" + shortPrefabName2 + " on " + shortPrefabName3 + " bone " + hitInfo.HitBone + ")");
						player.stats.combat.LogInvalid(hitInfo, "melee_bone");
						flag8 = false;
					}
					if (ConVar.AntiHack.melee_protection >= 2)
					{
						if (flag6)
						{
							float num6 = hitEntity.MaxVelocity();
							val3 = hitEntity.GetParentVelocity();
							float num7 = num6 + ((Vector3)(ref val3)).magnitude;
							float num8 = hitEntity.BoundsPadding() + num4 * num7;
							float num9 = hitEntity.Distance(hitInfo.HitPositionWorld);
							if (num9 > num8)
							{
								string shortPrefabName4 = base.ShortPrefabName;
								string shortPrefabName5 = hitEntity.ShortPrefabName;
								AntiHack.Log(player, AntiHackType.MeleeHack, "Entity too far away (" + shortPrefabName4 + " on " + shortPrefabName5 + " with " + num9 + "m > " + num8 + "m in " + num4 + "s)");
								player.stats.combat.LogInvalid(hitInfo, "melee_target");
								flag8 = false;
							}
						}
						if (ConVar.AntiHack.melee_protection >= 4 && flag8 && flag && !flag7 && !flag2 && !flag3 && !flag4 && !flag5)
						{
							val3 = basePlayer.GetParentVelocity();
							float magnitude = ((Vector3)(ref val3)).magnitude;
							float num10 = basePlayer.BoundsPadding() + num4 * magnitude + ConVar.AntiHack.tickhistoryforgiveness;
							float num11 = basePlayer.tickHistory.Distance(basePlayer, hitInfo.HitPositionWorld);
							if (num11 > num10)
							{
								string shortPrefabName6 = base.ShortPrefabName;
								string shortPrefabName7 = basePlayer.ShortPrefabName;
								AntiHack.Log(player, AntiHackType.MeleeHack, "Player too far away (" + shortPrefabName6 + " on " + shortPrefabName7 + " with " + num11 + "m > " + num10 + "m in " + num4 + "s)");
								player.stats.combat.LogInvalid(hitInfo, "player_distance");
								flag8 = false;
							}
						}
					}
					if (ConVar.AntiHack.melee_protection >= 1)
					{
						if (ConVar.AntiHack.melee_protection >= 4)
						{
							val3 = player.GetParentVelocity();
							float magnitude2 = ((Vector3)(ref val3)).magnitude;
							float num12 = player.BoundsPadding() + num4 * magnitude2 + num * maxDistance;
							float num13 = player.tickHistory.Distance(player, hitInfo.HitPositionWorld);
							if (num13 > num12)
							{
								string shortPrefabName8 = base.ShortPrefabName;
								string text = (flag6 ? hitEntity.ShortPrefabName : "world");
								AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName8 + " on " + text + " with " + num13 + "m > " + num12 + "m in " + num4 + "s)");
								player.stats.combat.LogInvalid(hitInfo, "melee_initiator");
								flag8 = false;
							}
						}
						else
						{
							float num14 = player.MaxVelocity();
							val3 = player.GetParentVelocity();
							float num15 = num14 + ((Vector3)(ref val3)).magnitude;
							float num16 = player.BoundsPadding() + num4 * num15 + num * maxDistance;
							float num17 = player.Distance(hitInfo.HitPositionWorld);
							if (num17 > num16)
							{
								string shortPrefabName9 = base.ShortPrefabName;
								string text2 = (flag6 ? hitEntity.ShortPrefabName : "world");
								AntiHack.Log(player, AntiHackType.MeleeHack, "Initiator too far away (" + shortPrefabName9 + " on " + text2 + " with " + num17 + "m > " + num16 + "m in " + num4 + "s)");
								player.stats.combat.LogInvalid(hitInfo, "melee_initiator");
								flag8 = false;
							}
						}
					}
					if (ConVar.AntiHack.melee_protection >= 3)
					{
						if (flag6)
						{
							center = player.eyes.center;
							position = player.eyes.position;
							pointStart = hitInfo.PointStart;
							hitPositionWorld = hitInfo.HitPositionWorld;
							Vector3 val4 = hitPositionWorld;
							val3 = hitPositionWorld - pointStart;
							hitPositionWorld = val4 - ((Vector3)(ref val3)).normalized * 0.001f;
							val5 = hitInfo.PositionOnRay(hitPositionWorld);
							Vector3 val6 = Vector3.zero;
							Vector3 val7 = Vector3.zero;
							Vector3 val8 = Vector3.zero;
							if (ConVar.AntiHack.melee_backtracking > 0f)
							{
								val3 = position - center;
								val6 = ((Vector3)(ref val3)).normalized * ConVar.AntiHack.melee_backtracking;
								val3 = pointStart - position;
								val7 = ((Vector3)(ref val3)).normalized * ConVar.AntiHack.melee_backtracking;
								val3 = val5 - pointStart;
								val8 = ((Vector3)(ref val3)).normalized * ConVar.AntiHack.melee_backtracking;
							}
							if (GamePhysics.LineOfSight(center - val6, position + val6, num5) && GamePhysics.LineOfSight(position - val7, pointStart + val7, num5) && GamePhysics.LineOfSight(pointStart - val8, val5, num5) && GamePhysics.LineOfSight(val5, hitPositionWorld, num5))
							{
								num18 = (GamePhysics.LineOfSight(position, hitPositionWorld, num5) ? 1 : 0);
								if (num18 != 0)
								{
									player.stats.Add("hit_" + hitEntity.Categorize() + "_direct_los", 1, Stats.Server);
									goto IL_07d6;
								}
							}
							else
							{
								num18 = 0;
							}
							player.stats.Add("hit_" + hitEntity.Categorize() + "_indirect_los", 1, Stats.Server);
							goto IL_07d6;
						}
						goto IL_08c4;
					}
					goto IL_0a2b;
				}
				goto IL_0a3e;
				IL_08c4:
				if (flag8 && flag && !flag7)
				{
					Vector3 hitPositionWorld2 = hitInfo.HitPositionWorld;
					Vector3 position2 = basePlayer.eyes.position;
					Vector3 val9 = basePlayer.CenterPoint();
					float melee_losforgiveness = ConVar.AntiHack.melee_losforgiveness;
					bool flag9 = GamePhysics.LineOfSight(hitPositionWorld2, position2, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(position2, hitPositionWorld2, num5, melee_losforgiveness, 0f);
					if (!flag9)
					{
						flag9 = GamePhysics.LineOfSight(hitPositionWorld2, val9, num5, 0f, melee_losforgiveness) && GamePhysics.LineOfSight(val9, hitPositionWorld2, num5, melee_losforgiveness, 0f);
					}
					if (!flag9)
					{
						string shortPrefabName10 = base.ShortPrefabName;
						string shortPrefabName11 = basePlayer.ShortPrefabName;
						string[] obj = new string[12]
						{
							"Line of sight (", shortPrefabName10, " on ", shortPrefabName11, ") ", null, null, null, null, null,
							null, null
						};
						val3 = hitPositionWorld2;
						obj[5] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
						obj[6] = " ";
						val3 = position2;
						obj[7] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
						obj[8] = " or ";
						val3 = hitPositionWorld2;
						obj[9] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
						obj[10] = " ";
						val3 = val9;
						obj[11] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
						AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj));
						player.stats.combat.LogInvalid(hitInfo, "melee_los");
						flag8 = false;
					}
				}
				goto IL_0a2b;
				IL_0a2b:
				if (!flag8)
				{
					AntiHack.AddViolation(player, AntiHackType.MeleeHack, ConVar.AntiHack.melee_penalty);
					return;
				}
				goto IL_0a3e;
				IL_07d6:
				if (num18 == 0)
				{
					string shortPrefabName12 = base.ShortPrefabName;
					string shortPrefabName13 = hitEntity.ShortPrefabName;
					string[] obj2 = new string[14]
					{
						"Line of sight (", shortPrefabName12, " on ", shortPrefabName13, ") ", null, null, null, null, null,
						null, null, null, null
					};
					val3 = center;
					obj2[5] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
					obj2[6] = " ";
					val3 = position;
					obj2[7] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
					obj2[8] = " ";
					val3 = pointStart;
					obj2[9] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
					obj2[10] = " ";
					val3 = val5;
					obj2[11] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
					obj2[12] = " ";
					val3 = hitPositionWorld;
					obj2[13] = ((object)(Vector3)(ref val3)/*cast due to .constrained prefix*/).ToString();
					AntiHack.Log(player, AntiHackType.MeleeHack, string.Concat(obj2));
					player.stats.combat.LogInvalid(hitInfo, "melee_los");
					flag8 = false;
				}
				goto IL_08c4;
				IL_0a3e:
				player.metabolism.UseHeart(heartStress * 0.2f);
				TimeWarning val10 = TimeWarning.New("DoAttackShared", 50);
				try
				{
					DoAttackShared(hitInfo);
				}
				finally
				{
					((IDisposable)val10)?.Dispose();
				}
				Pool.Free<HitInfo>(ref hitInfo);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override bool CanBeUsedInWater()
	{
		return true;
	}

	public virtual string GetStrikeEffectPath(string materialName)
	{
		for (int i = 0; i < materialStrikeFX.Count; i++)
		{
			if (materialStrikeFX[i].materialName == materialName && materialStrikeFX[i].fx.isValid)
			{
				return materialStrikeFX[i].fx.resourcePath;
			}
		}
		return strikeFX.resourcePath;
	}

	public override void ServerUse(float damageModifier = 1f, float speedModifier = 1f, Matrix4x4? originOverride = null, bool useBulletThickness = true)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || HasAttackCooldown())
		{
			return;
		}
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null))
		{
			StartAttackCooldown(repeatDelay * 2f);
			ownerPlayer.SignalBroadcast(Signal.Attack, string.Empty);
			if (swingEffect.isValid)
			{
				Effect.server.Run(swingEffect.resourcePath, ((Component)this).transform.position, Vector3.forward, ownerPlayer.net.connection);
			}
			if (((FacepunchBehaviour)this).IsInvoking((Action)ServerUse_Strike))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ServerUse_Strike);
			}
			((FacepunchBehaviour)this).Invoke((Action)ServerUse_Strike, aiStrikeDelay);
		}
	}

	public virtual void ServerUse_OnHit(HitInfo info)
	{
	}

	public void ServerUse_Strike()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return;
		}
		Vector3 position = ownerPlayer.eyes.position;
		Vector3 val = ownerPlayer.eyes.BodyForward();
		for (int i = 0; i < 2; i++)
		{
			List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
			GamePhysics.TraceAll(new Ray(position - val * ((i == 0) ? 0f : 0.2f), val), (i == 0) ? 0f : attackRadius, list, effectiveRange + 0.2f, 1220225809, (QueryTriggerInteraction)0);
			bool flag = false;
			for (int j = 0; j < list.Count; j++)
			{
				RaycastHit hit = list[j];
				BaseEntity entity = hit.GetEntity();
				if ((Object)(object)entity == (Object)null || ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)ownerPlayer || entity.EqualNetID((BaseNetworkable)ownerPlayer))) || ((Object)(object)entity != (Object)null && entity.isClient) || entity.Categorize() == ownerPlayer.Categorize())
				{
					continue;
				}
				float num = 0f;
				foreach (DamageTypeEntry damageType in damageTypes)
				{
					num += damageType.amount;
				}
				entity.OnAttacked(new HitInfo(ownerPlayer, entity, DamageType.Slash, num * npcDamageScale));
				HitInfo hitInfo = Pool.Get<HitInfo>();
				hitInfo.HitEntity = entity;
				hitInfo.HitPositionWorld = ((RaycastHit)(ref hit)).point;
				hitInfo.HitNormalWorld = -val;
				if (entity is BaseNpc || entity is BasePlayer)
				{
					hitInfo.HitMaterial = StringPool.Get("Flesh");
				}
				else
				{
					hitInfo.HitMaterial = StringPool.Get(((Object)(object)hit.GetCollider().sharedMaterial != (Object)null) ? hit.GetCollider().sharedMaterial.GetName() : "generic");
				}
				ServerUse_OnHit(hitInfo);
				Effect.server.ImpactEffect(hitInfo);
				Pool.Free<HitInfo>(ref hitInfo);
				flag = true;
				if (!((Object)(object)entity != (Object)null) || entity.ShouldBlockProjectiles())
				{
					break;
				}
			}
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			if (flag)
			{
				break;
			}
		}
	}

	public override Vector3 GetInheritedVelocity(BasePlayer player, Vector3 direction)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return player.GetInheritedThrowVelocity(direction);
	}

	[RPC_Server.IsActiveItem]
	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	private void CLEntityThrow(RPCMessage msg)
	{
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if ((Object)(object)player == (Object)null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsEntity)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "item_missing");
				return;
			}
			ItemModEntityThrow component = ((Component)item.info).GetComponent<ItemModEntityThrow>();
			if ((Object)(object)component == (Object)null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "mod_missing");
				return;
			}
			Vector3 val = msg.read.Vector3();
			Vector3 val2 = msg.read.Vector3();
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			if (msg.player.isMounted || msg.player.HasParent())
			{
				val = msg.player.eyes.position;
			}
			else if (!ValidateEyePos(msg.player, val))
			{
				return;
			}
			BaseEntity baseEntity = GameManager.server.CreateEntity(component.entityPrefab.resourcePath, val, Quaternion.LookRotation(normalized));
			if ((Object)(object)baseEntity == (Object)null)
			{
				return;
			}
			baseEntity.SetCreatorEntity(player);
			baseEntity.skinID = skinID;
			baseEntity.OwnerID = player.userID;
			baseEntity.SetVelocity(GetInheritedVelocity(msg.player, normalized) + normalized * component.throwVelocity + msg.player.estimatedVelocity * 0.5f);
			baseEntity.Spawn();
			if (component.consumeOnThrow)
			{
				if (ThrowFullStack)
				{
					item.SetParent(null);
				}
				else
				{
					item.UseItem();
					if (item.amount == 0)
					{
						item.SetParent(null);
					}
				}
			}
			SingletonComponent<NpcNoiseManager>.Instance.OnWeaponThrown(player, this, canAiHearIt);
			OnEntityThrow(baseEntity);
		}
	}

	protected virtual void OnEntityThrow(BaseEntity ent)
	{
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.IsActiveItem]
	private void CLProject(RPCMessage msg)
	{
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = msg.player;
		if (!VerifyClientAttack(player))
		{
			SendNetworkUpdate();
		}
		else
		{
			if ((Object)(object)player == (Object)null || player.IsHeadUnderwater())
			{
				return;
			}
			if (!canThrowAsProjectile)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Not throwable (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "not_throwable");
				return;
			}
			Item item = GetItem();
			if (item == null)
			{
				AntiHack.Log(player, AntiHackType.ProjectileHack, "Item not found (" + base.ShortPrefabName + ")");
				player.stats.combat.LogInvalid(player, this, "item_missing");
				return;
			}
			ItemModProjectile component = ((Component)item.info).GetComponent<ItemModProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				ProjectileShoot val = msg.read.Proto<ProjectileShoot>((ProjectileShoot)null);
				try
				{
					if (val.projectiles.Count != 1)
					{
						AntiHack.Log(player, AntiHackType.ProjectileHack, "Projectile count mismatch (" + base.ShortPrefabName + ")");
						player.stats.combat.LogInvalid(player, this, "count_mismatch");
						return;
					}
					player.CleanupExpiredProjectiles();
					Guid projectileGroupId = Guid.NewGuid();
					foreach (Projectile projectile in val.projectiles)
					{
						if (player.HasFiredProjectile(projectile.projectileID))
						{
							AntiHack.Log(player, AntiHackType.ProjectileHack, "Duplicate ID (" + projectile.projectileID + ")");
							player.stats.combat.LogInvalid(player, this, "duplicate_id");
							continue;
						}
						Vector3 positionOffset = Vector3.zero;
						if (ConVar.AntiHack.projectile_positionoffset && (player.isMounted || player.HasParent()))
						{
							if (!ValidateEyePos(player, projectile.startPos, checkLineOfSight: false))
							{
								continue;
							}
							Vector3 position = player.eyes.position;
							positionOffset = position - projectile.startPos;
							projectile.startPos = position;
						}
						else if (!ValidateEyePos(player, projectile.startPos))
						{
							continue;
						}
						Item pickupItem = (ThrowFullStack ? item : ItemManager.CreateByItemID(item.info.itemid, 1, 0uL));
						player.NoteFiredProjectile(projectile.projectileID, projectile.startPos, projectile.startVel, this, item.info, projectileGroupId, positionOffset, pickupItem);
						Effect effect = new Effect();
						effect.Init(Effect.Type.Projectile, projectile.startPos, projectile.startVel, msg.connection);
						((EffectData)effect).scale = 1f;
						effect.pooledString = component.projectileObject.resourcePath;
						((EffectData)effect).number = projectile.seed;
						EffectNetwork.Send(effect);
					}
					if (ThrowFullStack)
					{
						item.SetParent(null);
					}
					else
					{
						item.UseItem();
						if (item.amount == 0)
						{
							item.SetParent(null);
						}
					}
					Interface.CallHook("OnMeleeThrown", (object)player, (object)item);
					SingletonComponent<NpcNoiseManager>.Instance.OnWeaponThrown(player, this, canAiHearIt);
					return;
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			AntiHack.Log(player, AntiHackType.ProjectileHack, "Item mod not found (" + base.ShortPrefabName + ")");
			player.stats.combat.LogInvalid(player, this, "mod_missing");
		}
	}
}


using System;

[Serializable]
public class MaterialFX
{
	public string materialName;

	public GameObjectRef fx;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;
using UnityEngine.Assertions;

public class BaseMetalDetector : HeldEntity
{
	public enum DetectState
	{
		LongRange,
		SweetSpot
	}

	public DetectState State;

	public float LongRangeDetectionRange = 20f;

	public float SweetSpotDetectionRange = 0.2f;

	public SoundDefinition BeepSoundEffect;

	[ServerVar]
	public static float NearestDistanceTick = 0.25f;

	[ServerVar]
	public static float DetectLongRangeTick = 1f;

	[ServerVar]
	public static float DetectMinMovementDistance = 1f;

	private List<IMetalDetectable> inRangeSources = new List<IMetalDetectable>();

	public IMetalDetectable nearestSource;

	private float nearestSourceDistanceSqr;

	private Vector3 lastDetectPlayerPos;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseMetalDetector.OnRpcMessage", 0);
		try
		{
			if (rpc == 2192859691u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_RequestFlag "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_RequestFlag", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(2192859691u, "RPC_RequestFlag", this, player, 2uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(2192859691u, "RPC_RequestFlag", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage rpc2 = rPCMessage;
							RPC_RequestFlag(rpc2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in RPC_RequestFlag");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 50929187 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SV_SetSweetspotScanning "));
				}
				TimeWarning val2 = TimeWarning.New("SV_SetSweetspotScanning", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(50929187u, "SV_SetSweetspotScanning", this, player, 6uL))
						{
							return true;
						}
						if (!RPC_Server.FromOwner.Test(50929187u, "SV_SetSweetspotScanning", this, player, includeMounted: false))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SV_SetSweetspotScanning(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in SV_SetSweetspotScanning");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void OnHeldChanged()
	{
		base.OnHeldChanged();
		if (IsDeployed())
		{
			StartDetecting();
		}
		else
		{
			StopDetecting();
		}
	}

	private void StartDetecting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		lastDetectPlayerPos = Vector3.zero;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DetectLongRange))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)DetectLongRange, 0f, DetectLongRangeTick);
			((FacepunchBehaviour)this).InvokeRepeating((Action)SendNearestDistance, 0f, NearestDistanceTick);
		}
	}

	private void StopDetecting()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)DetectLongRange);
		((FacepunchBehaviour)this).CancelInvoke((Action)SendNearestDistance);
		ClearSources();
	}

	private void SendNearestDistance()
	{
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if (!((Object)(object)ownerPlayer == (Object)null))
		{
			float distanceToCenterOrNearestSubSource = GetDistanceToCenterOrNearestSubSource(nearestSource);
			ClientRPC(RpcTarget.Player("CL_UpdateNearest", ownerPlayer), distanceToCenterOrNearestSubSource, (nearestSource != null) ? nearestSource.GetRadius() : 1f);
		}
	}

	private float GetDistanceToCenterOrNearestSubSource(IMetalDetectable source)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (source == null)
		{
			return float.PositiveInfinity;
		}
		Vector3 detectionPoint = GetDetectionPoint();
		return Vector3.Distance(source.GetNearestPosition(detectionPoint), detectionPoint);
	}

	private void ProcessDetectedSources()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)GetOwnerPlayer() == (Object)null)
		{
			nearestSource = null;
		}
		nearestSourceDistanceSqr = float.PositiveInfinity;
		IMetalDetectable metalDetectable = null;
		Vector3 detectionPoint = GetDetectionPoint();
		foreach (IMetalDetectable inRangeSource in inRangeSources)
		{
			if (inRangeSource == null)
			{
				continue;
			}
			foreach (Vector3 scanLocation in inRangeSource.GetScanLocations())
			{
				float num = Vector3.SqrMagnitude(scanLocation - detectionPoint);
				if (num < nearestSourceDistanceSqr)
				{
					nearestSourceDistanceSqr = num;
					metalDetectable = inRangeSource;
				}
			}
		}
		nearestSource = metalDetectable;
	}

	private void DetectLongRange()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null || (Object)(object)ownerPlayer.GetHeldEntity() != (Object)(object)this)
		{
			StopDetecting();
			return;
		}
		if (Vector3.SqrMagnitude(((Component)ownerPlayer).transform.position - lastDetectPlayerPos) < DetectMinMovementDistance)
		{
			ProcessDetectedSources();
			return;
		}
		DetectSources(ownerPlayer);
		ProcessDetectedSources();
	}

	private void DetectSources(BasePlayer player)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		lastDetectPlayerPos = ((Component)player).transform.position;
		List<IMetalDetectable> list = Pool.Get<List<IMetalDetectable>>();
		if (!player.InSafeZone())
		{
			Vis.Entities(((Component)this).transform.position, LongRangeDetectionRange + 5f, list, 512, (QueryTriggerInteraction)1);
		}
		inRangeSources.Clear();
		inRangeSources.AddRange(list);
		Pool.FreeUnmanaged<IMetalDetectable>(ref list);
	}

	private void ClearSources()
	{
		nearestSource = null;
		inRangeSources.Clear();
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(2uL)]
	private void RPC_RequestFlag(RPCMessage rpc)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = rpc.player;
		if (!((Object)(object)player == (Object)null) && !player.InSafeZone() && nearestSource != null)
		{
			Vector3 val = rpc.read.Vector3();
			Interface.CallHook("OnMetalDetectorFlagRequest", (object)this, (object)val, (object)player);
			if (nearestSource.VerifyScanPosition(((Component)player).transform.position, val, out var spotPos))
			{
				nearestSource.Detected(spotPos);
			}
		}
	}

	[RPC_Server.FromOwner(false)]
	[RPC_Server]
	[RPC_Server.CallsPerSecond(6uL)]
	public void SV_SetSweetspotScanning(RPCMessage msg)
	{
		if (!((Object)(object)msg.player == (Object)null) && !((Object)(object)msg.player != (Object)(object)GetOwnerPlayer()))
		{
			bool b = msg.read.Bit();
			SetFlag(Flags.On, b);
		}
	}

	public Vector3 GetDetectionPoint()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return ((Component)this).transform.position;
		}
		Vector3 val = ((Component)ownerPlayer).transform.position + ownerPlayer.eyes.MovementForward() * 0.3f;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(val + Vector3.up * 0.5f, Vector3.down, ref val2, 1.5f, 8388608))
		{
			return ((RaycastHit)(ref val2)).point;
		}
		return val;
	}

	public float GetSweetSpotDistancePercent(float distance, float sourceSpawnRadius)
	{
		if (State != DetectState.SweetSpot)
		{
			return 0f;
		}
		if (distance > sourceSpawnRadius)
		{
			return 0f;
		}
		return Mathf.Clamp01(1f - distance / sourceSpawnRadius);
	}
}


public enum DetectState
{
	LongRange,
	SweetSpot
}


using System;
using System.Collections.Generic;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

[ResetStaticFields]
public class BaseMountable : BaseCombatEntity
{
	public enum ClippingCheckLocation
	{
		HeadOnly,
		WholeBody
	}

	public enum DismountConvarType
	{
		Misc,
		Boating,
		Flying,
		GroundVehicle,
		Horse
	}

	public enum MountStatType
	{
		None,
		Boating,
		Flying,
		Driving
	}

	public enum MountGestureType
	{
		None,
		UpperBody
	}

	public static Phrase dismountPhrase = new Phrase("dismount", "Dismount");

	[Header("Base Mountable")]
	[Header("View")]
	public Transform eyePositionOverride;

	public Transform eyeCenterOverride;

	public bool overrideEyesRotation;

	public Vector2 pitchClamp = new Vector2(-80f, 50f);

	public Vector2 yawClamp = new Vector2(-80f, 80f);

	public bool canWieldItems = true;

	public bool relativeViewAngles = true;

	public bool disableLegsWhenMounted;

	[Header("Mounting")]
	public bool AllowForceMountWhenRestrained;

	[Tooltip("Allow players to mount other mountables/ladders from this vehicle")]
	public bool mountChaining = true;

	public Transform mountAnchor;

	public float mountLOSVertOffset = 0.5f;

	public float mountedAnimationSpeed;

	public PlayerModel.MountPoses mountPose;

	public float maxMountDistance = 1.5f;

	public Transform[] dismountPositions;

	public bool checkPlayerLosOnMount;

	public bool disableMeshCullingForPlayers;

	public bool allowHeadLook;

	public bool ignoreVehicleParent;

	public bool legacyDismount;

	public ItemModWearable wearWhileMounted;

	public bool modifiesPlayerCollider;

	public BasePlayer.CapsuleColliderInfo customPlayerCollider;

	public float clippingCheckRadius = 0.4f;

	public bool clippingAndVisChecks;

	public ClippingCheckLocation clippingChecksLocation;

	public SoundDefinition mountSoundDef;

	public SoundDefinition swapSoundDef;

	public SoundDefinition dismountSoundDef;

	public DismountConvarType dismountHoldType;

	public MountStatType mountTimeStatType;

	public MountGestureType allowedGestures;

	public bool canDrinkWhileMounted = true;

	public bool allowSleeperMounting;

	[Help("Set this to true if the mountable is enclosed so it doesn't move inside cars and such")]
	public bool animateClothInLocalSpace = true;

	[SerializeField]
	private bool protectsFromAnimals = true;

	[Header("Camera")]
	public BasePlayer.CameraMode MountedCameraMode;

	[Header("Rigidbody (Optional)")]
	public Rigidbody rigidBody;

	public bool wantsBoundaryRepelCheck;

	[FormerlySerializedAs("needsVehicleTick")]
	public bool isMobile;

	public float SideLeanAmount = 0.2f;

	public const float playerHeight = 1.8f;

	public const float playerRadius = 0.5f;

	public BasePlayer _mounted;

	public static ListHashSet<BaseMountable> AllMountables = new ListHashSet<BaseMountable>();

	public static ListHashSet<BaseMountable> Mounted = new ListHashSet<BaseMountable>();

	public const float MOUNTABLE_TICK_RATE = 0.05f;

	public bool ProtectsFromAnimals
	{
		get
		{
			if ((Object)(object)((Component)this).transform.parent != (Object)null && ((Object)(object)((Component)((Component)this).transform.parent).GetComponent<BaseMountable>()).Is<BaseMountable>(out BaseMountable entAsT))
			{
				return entAsT.ProtectsFromAnimals;
			}
			return protectsFromAnimals;
		}
	}

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public virtual bool IsSummerDlcVehicle => false;

	protected virtual bool BypassClothingMountBlocks => false;

	public virtual bool BlocksDoors => true;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseMountable.OnRpcMessage", 0);
		try
		{
			if (rpc == 1735799362 && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_WantsDismount "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_WantsDismount", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Call", 0);
					try
					{
						RPCMessage rPCMessage = default(RPCMessage);
						rPCMessage.connection = msg.connection;
						rPCMessage.player = player;
						rPCMessage.read = msg.read;
						RPCMessage msg2 = rPCMessage;
						RPC_WantsDismount(msg2);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					Debug.LogException(ex);
					player.Kick("RPC Error in RPC_WantsDismount");
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
			if (rpc == 4014300952u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - RPC_WantsMount "));
				}
				TimeWarning val2 = TimeWarning.New("RPC_WantsMount", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.IsVisible.Test(4014300952u, "RPC_WantsMount", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg3 = rPCMessage;
							RPC_WantsMount(msg3);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex2)
					{
						Debug.LogException(ex2);
						player.Kick("RPC Error in RPC_WantsMount");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public virtual bool CanHoldItems()
	{
		return canWieldItems;
	}

	public virtual BasePlayer.CameraMode GetMountedCameraMode()
	{
		return MountedCameraMode;
	}

	public virtual bool DirectlyMountable()
	{
		return true;
	}

	public virtual Transform GetEyeOverride()
	{
		if ((Object)(object)eyePositionOverride != (Object)null)
		{
			return eyePositionOverride;
		}
		return ((Component)this).transform;
	}

	public virtual bool ModifiesThirdPersonCamera()
	{
		return false;
	}

	public virtual Vector2 GetPitchClamp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return pitchClamp;
	}

	public virtual Vector2 GetYawClamp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return yawClamp;
	}

	public virtual bool AnyMounted()
	{
		return IsBusy();
	}

	public bool IsMounted()
	{
		return AnyMounted();
	}

	public virtual Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public virtual Quaternion EyeRotationForPlayer(BasePlayer player)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this || !overrideEyesRotation)
		{
			return Quaternion.identity;
		}
		return GetEyeOverride().rotation;
	}

	public virtual Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return ((Component)eyeCenterOverride).transform.position;
	}

	public virtual float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		OBB val = player.WorldSpaceBounds();
		Bounds val2 = ((OBB)(ref val)).ToBounds();
		if (((Bounds)(ref val2)).size == Vector3.zero)
		{
			((Bounds)(ref val2)).size = new Vector3(0.1f, 0.1f, 0.1f);
		}
		info = WaterLevel.GetWaterInfo(val2, waves: true, volumes: true, this);
		return WaterLevel.Factor(in info, val2);
	}

	public override float MaxVelocity()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			return baseEntity.MaxVelocity();
		}
		return base.MaxVelocity();
	}

	public virtual bool PlayerIsMounted(BasePlayer player)
	{
		if (player.IsValid())
		{
			return (Object)(object)player.GetMounted() == (Object)(object)this;
		}
		return false;
	}

	public virtual BaseVehicle VehicleParent()
	{
		if (ignoreVehicleParent)
		{
			return null;
		}
		return GetParentEntity() as BaseVehicle;
	}

	public virtual bool HasValidDismountPosition(BasePlayer player)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.HasValidDismountPosition(player);
		}
		Transform[] array = dismountPositions;
		foreach (Transform val in array)
		{
			if (ValidDismountPosition(player, ((Component)val).transform.position))
			{
				return true;
			}
		}
		return false;
	}

	public virtual bool ValidDismountPosition(BasePlayer player, Vector3 disPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		bool debugDismounts = Debugging.DebugDismounts;
		Vector3 dismountCheckStart = GetDismountCheckStart(player);
		if (debugDismounts)
		{
			Debug.Log((object)$"ValidDismountPosition debug: Checking dismount point {disPos} from {dismountCheckStart}.");
		}
		Vector3 val = disPos + new Vector3(0f, 0.5f, 0f);
		Vector3 val2 = disPos + new Vector3(0f, 1.3f, 0f);
		if (!Physics.CheckCapsule(val, val2, 0.5f, 1537286401))
		{
			Vector3 position = disPos + ((Component)this).transform.up * 0.5f;
			if (IsVisibleAndCanSee(position))
			{
				Vector3 newPos = disPos + BasePlayer.NoClipOffset();
				if (debugDismounts)
				{
					Debug.Log((object)$"ValidDismountPosition debug: Dismount point {disPos} is visible.");
				}
				if (legacyDismount || !AntiHack.TestNoClipping(player, dismountCheckStart, newPos, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin_dismount), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: false, this))
				{
					if (debugDismounts)
					{
						Debug.Log((object)$"<color=green>ValidDismountPosition debug: Dismount point {disPos} is valid</color>.");
					}
					return true;
				}
			}
		}
		if (debugDismounts && debugDismounts)
		{
			Debug.Log((object)$"<color=red>ValidDismountPosition debug: Dismount point {disPos} is invalid</color>.");
		}
		return false;
	}

	protected override bool ShouldDisplayPickupOption(BasePlayer player)
	{
		if (!AnyMounted())
		{
			return base.ShouldDisplayPickupOption(player);
		}
		return false;
	}

	public virtual BasePlayer GetMounted()
	{
		return _mounted;
	}

	public virtual void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
	}

	public virtual void LightToggle(BasePlayer player)
	{
	}

	public virtual void OnWeaponFired(BaseProjectile weapon)
	{
	}

	public virtual bool CanSwapToThis(BasePlayer player)
	{
		object obj = Interface.CallHook("CanSwapToSeat", (object)player, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public override void OnDied(HitInfo info)
	{
		DismountAllPlayers();
		base.OnDied(info);
	}

	[RPC_Server]
	[RPC_Server.IsVisible(3f)]
	public void RPC_WantsMount(RPCMessage msg)
	{
		WantsMount(msg.player);
	}

	public void WantsMount(BasePlayer player)
	{
		if (!player.IsValid() || !player.CanInteract() || Interface.CallHook("OnPlayerWantsMount", (object)player, (object)this) != null)
		{
			return;
		}
		if (!DirectlyMountable())
		{
			BaseVehicle baseVehicle = VehicleParent();
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.WantsMount(player);
				return;
			}
		}
		AttemptMount(player);
	}

	public virtual void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mounted != (Object)null || IsDead() || !player.CanMountMountablesNow() || IsTransferring() || IsSeatClipping(this) || ClothingBlocksMounting(player))
		{
			return;
		}
		if (doMountChecks)
		{
			RaycastHit hit = default(RaycastHit);
			if (checkPlayerLosOnMount && Physics.Linecast(player.eyes.position, mountAnchor.position + ((Component)this).transform.up * mountLOSVertOffset, ref hit, 1218652417))
			{
				bool flag = false;
				BaseEntity entity = hit.GetEntity();
				if ((Object)(object)entity != (Object)null && ((Object)(object)entity == (Object)(object)this || (Object)(object)entity == (Object)(object)VehicleParent()))
				{
					flag = true;
				}
				if (!flag)
				{
					return;
				}
			}
			if (!HasValidDismountPosition(player))
			{
				return;
			}
		}
		MountPlayer(player);
	}

	public virtual bool AttemptDismount(BasePlayer player)
	{
		if ((Object)(object)player != (Object)(object)_mounted)
		{
			return false;
		}
		if (IsTransferring())
		{
			return false;
		}
		if (!AllowPlayerInstigatedDismount(player))
		{
			return false;
		}
		if ((Object)(object)VehicleParent() != (Object)null && !VehicleParent().AllowPlayerInstigatedDismount(player))
		{
			return false;
		}
		DismountPlayer(player);
		return true;
	}

	public virtual bool AllowPlayerInstigatedDismount(BasePlayer player)
	{
		return true;
	}

	[RPC_Server]
	public void RPC_WantsDismount(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		if (!HasValidDismountPosition(player))
		{
			Interface.CallHook("OnPlayerDismountFailed", (object)player, (object)this);
		}
		else if (Interface.CallHook("OnPlayerWantsDismount", (object)player, (object)this) == null && (!((Object)(object)player != (Object)null) || !player.IsRestrained))
		{
			AttemptDismount(player);
		}
	}

	public void MountPlayer(BasePlayer player)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)_mounted != (Object)null) && !((Object)(object)mountAnchor == (Object)null) && Interface.CallHook("CanMountEntity", (object)player, (object)this) == null)
		{
			player.EnsureDismounted();
			_mounted = player;
			Transform val = mountAnchor;
			player.SetMounted(this);
			player.MovePosition(val.position);
			((Component)player).transform.rotation = val.rotation;
			player.ServerRotation = val.rotation;
			Quaternion rotation = val.rotation;
			player.OverrideViewAngles(((Quaternion)(ref rotation)).eulerAngles);
			_mounted.eyes.NetworkUpdate(val.rotation);
			player.SendNetworkUpdateImmediate();
			Analytics.Azure.OnMountEntity(player, this, VehicleParent());
			OnPlayerMounted();
			Interface.CallHook("OnEntityMounted", (object)this, (object)player);
			if (allowedGestures == MountGestureType.None && player.InGesture)
			{
				player.Server_CancelGesture();
			}
			else if (allowedGestures == MountGestureType.UpperBody && player.InGesture && player.CurrentGestureIsFullBody)
			{
				player.Server_CancelGesture();
			}
			if (this.IsValid() && player.IsValid())
			{
				player.ProcessMissionEvent(BaseMission.MissionEventType.MOUNT_ENTITY, net.ID, 1f);
			}
		}
	}

	public virtual void OnPlayerMounted()
	{
		if ((Object)(object)_mounted != (Object)null)
		{
			Mounted.TryAdd(this);
		}
		UpdateMountFlags();
	}

	public virtual void OnPlayerDismounted(BasePlayer player)
	{
		Mounted.Remove(this);
		UpdateMountFlags();
	}

	public virtual void UpdateMountFlags()
	{
		SetFlag(Flags.Busy, (Object)(object)_mounted != (Object)null);
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.UpdateMountFlags();
		}
	}

	public virtual void DismountAllPlayers()
	{
		if (Object.op_Implicit((Object)(object)_mounted))
		{
			DismountPlayer(_mounted);
		}
	}

	public void DismountPlayer(BasePlayer player, bool lite = false)
	{
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)_mounted == (Object)null || (Object)(object)_mounted != (Object)(object)player || Interface.CallHook("CanDismountEntity", (object)player, (object)this) != null)
		{
			return;
		}
		BaseVehicle baseVehicle = VehicleParent();
		if (lite)
		{
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			_mounted.DismountObject();
			_mounted = null;
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			Interface.CallHook("OnEntityDismounted", (object)this, (object)player);
			return;
		}
		if (!GetDismountPosition(player, out var res) || Distance(res) > 10f)
		{
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PrePlayerDismount(player, this);
			}
			res = ((Component)player).transform.position;
			_mounted.DismountObject();
			_mounted.MovePosition(res);
			((Component)_mounted).transform.rotation = Quaternion.identity;
			_mounted.ClientRPC(RpcTarget.Player("ForcePositionTo", _mounted), res);
			BasePlayer mounted = _mounted;
			_mounted = null;
			Debug.LogWarning((object)("Killing player due to invalid dismount point :" + player.displayName + " / " + player.userID.Get() + " on obj : " + ((Object)((Component)this).gameObject).name));
			mounted.Hurt(1000f, DamageType.Suicide, mounted, useProtection: false);
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PlayerDismounted(player, this);
			}
			OnPlayerDismounted(player);
			return;
		}
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.PrePlayerDismount(player, this);
		}
		if (AntiHack.TestNoClipping(_mounted, res, res, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out var _, vehicleLayer: true))
		{
			_mounted.PauseVehicleNoClipDetection(5f);
		}
		_mounted.DismountObject();
		((Component)_mounted).transform.rotation = Quaternion.LookRotation(Vector3.forward, Vector3.up);
		_mounted.OverrideViewAngles(Vector3.zero);
		_mounted.MovePosition(res);
		_mounted.SendNetworkUpdateImmediate();
		_mounted.SendModelState(force: true);
		_mounted = null;
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.PlayerDismounted(player, this);
		}
		if (Object.op_Implicit((Object)(object)player.GetParentEntity()))
		{
			BaseEntity baseEntity = player.GetParentEntity();
			player.ClientRPC(RpcTarget.Player("ForcePositionToParentOffset", player), ((Component)baseEntity).transform.InverseTransformPoint(res), baseEntity.net.ID);
		}
		else
		{
			player.ClientRPC(RpcTarget.Player("ForcePositionTo", player), res);
			player.ClientRPC(RpcTarget.NetworkGroup("ForceResetRotation", player));
		}
		Analytics.Azure.OnDismountEntity(player, this, baseVehicle);
		Interface.CallHook("OnEntityDismounted", (object)this, (object)player);
		OnPlayerDismounted(player);
	}

	public virtual bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null && baseVehicle.IsVehicleMountPoint(this))
		{
			return baseVehicle.GetDismountPosition(player, out res);
		}
		int num = 0;
		Transform[] array = dismountPositions;
		foreach (Transform val in array)
		{
			if (ValidDismountPosition(player, ((Component)val).transform.position))
			{
				res = ((Component)val).transform.position;
				return true;
			}
			num++;
		}
		if (!silent)
		{
			Debug.LogWarning((object)("Failed to find dismount position for player :" + player.displayName + " / " + player.userID.Get() + " on obj : " + ((Object)((Component)this).gameObject).name));
		}
		res = ((Component)player).transform.position;
		return false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (isMobile && !(this is BaseVehicleMountPoint { RequiresVehicleFixedUpdateOnSeat: false }))
		{
			AllMountables.Add(this);
		}
	}

	internal override void DoServerDestroy()
	{
		DismountAllPlayers();
		AllMountables.Remove(this);
		base.DoServerDestroy();
	}

	public static void FixedUpdateCycle()
	{
		for (int num = AllMountables.Count - 1; num >= 0; num--)
		{
			BaseMountable baseMountable = AllMountables[num];
			if ((Object)(object)baseMountable == (Object)null)
			{
				AllMountables.RemoveAt(num);
			}
			else if (baseMountable.isSpawned)
			{
				baseMountable.VehicleFixedUpdate();
			}
		}
		for (int num2 = AllMountables.Count - 1; num2 >= 0; num2--)
		{
			BaseMountable baseMountable2 = AllMountables[num2];
			if ((Object)(object)baseMountable2 == (Object)null)
			{
				AllMountables.RemoveAt(num2);
			}
			else if (baseMountable2.isSpawned)
			{
				baseMountable2.PostVehicleFixedUpdate();
			}
		}
	}

	public static void PlayerSyncCycle()
	{
		for (int num = Mounted.Count - 1; num >= 0; num--)
		{
			BaseMountable baseMountable = Mounted[num];
			if ((Object)(object)baseMountable == (Object)null || (Object)(object)baseMountable.GetMounted() == (Object)null)
			{
				Mounted.RemoveAt(num);
			}
			else if (baseMountable.isSpawned)
			{
				baseMountable.MountedPlayerSync();
			}
		}
	}

	public virtual void VehicleFixedUpdate()
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseMountable.VehicleFixedUpdate", 0);
		try
		{
			if (!wantsBoundaryRepelCheck || !((Object)(object)rigidBody != (Object)null) || rigidBody.IsSleeping() || rigidBody.isKinematic)
			{
				return;
			}
			float num = ValidBounds.TestDist(this, ((Component)this).transform.position) - 25f;
			if (num < 0f)
			{
				num = 0f;
			}
			if (!(num < 100f))
			{
				return;
			}
			Vector3 position = ((Component)this).transform.position;
			Vector3 normalized = ((Vector3)(ref position)).normalized;
			float num2 = Vector3.Dot(rigidBody.velocity, normalized);
			if (num2 > 0f)
			{
				float num3 = 1f - num / 100f;
				Rigidbody obj = rigidBody;
				obj.velocity -= normalized * num2 * (num3 * num3);
				if (num < 25f)
				{
					float num4 = 1f - num / 25f;
					rigidBody.AddForce(-normalized * 20f * num4, (ForceMode)5);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void PostVehicleFixedUpdate()
	{
	}

	public virtual void MountedPlayerSync()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		((Component)_mounted).transform.rotation = ((Component)mountAnchor).transform.rotation;
		_mounted.ServerRotation = ((Component)mountAnchor).transform.rotation;
		_mounted.MovePosition(((Component)mountAnchor).transform.position);
	}

	public virtual void PlayerServerInput(InputState inputState, BasePlayer player)
	{
	}

	public virtual float GetComfort()
	{
		return 0f;
	}

	public virtual void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
	}

	public bool TryFireProjectile(StorageContainer ammoStorage, AmmoTypes ammoType, Vector3 firingPos, Vector3 firingDir, BasePlayer shooter, float launchOffset, float minSpeed, out ServerProjectile projectile)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		projectile = null;
		if ((Object)(object)ammoStorage == (Object)null)
		{
			return false;
		}
		ItemContainer inventory = ammoStorage.inventory;
		if (inventory == null)
		{
			return false;
		}
		return TryFireProjectile(inventory, ammoType, firingPos, firingDir, shooter, launchOffset, minSpeed, out projectile);
	}

	public virtual void FilterServerProjectileAmmo(List<Item> ammoList)
	{
	}

	public bool TryFireProjectile(ItemContainer ammoContainer, AmmoTypes ammoType, Vector3 firingPos, Vector3 firingDir, BasePlayer shooter, float launchOffset, float minSpeed, out ServerProjectile projectile)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		projectile = null;
		if (ammoContainer == null)
		{
			return false;
		}
		bool result = false;
		List<Item> list = Pool.Get<List<Item>>();
		ammoContainer.FindAmmo(list, ammoType);
		FilterServerProjectileAmmo(list);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			if (list[num].amount <= 0)
			{
				list.RemoveAt(num);
			}
		}
		if (list.Count > 0)
		{
			Item ammoItem = list[list.Count - 1];
			result = FireProjectile(ammoItem, firingPos, firingDir, shooter, launchOffset, minSpeed, out projectile);
		}
		Pool.Free<Item>(ref list, false);
		return result;
	}

	public bool FireProjectile(Item ammoItem, Vector3 firingPos, Vector3 firingDir, BasePlayer shooter, float launchOffset, float minSpeed, out ServerProjectile projectile)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		ItemModProjectile component = ((Component)ammoItem.info).GetComponent<ItemModProjectile>();
		if (FireProjectile(component.projectileObject, firingPos, firingDir, shooter, launchOffset, minSpeed, out projectile))
		{
			ammoItem.UseItem();
			return true;
		}
		return false;
	}

	public bool FireProjectile(GameObjectRef projectilePrefab, Vector3 firingPos, Vector3 firingDir, BasePlayer shooter, float launchOffset, float minSpeed, out ServerProjectile projectile)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(firingPos, firingDir, ref val, launchOffset, 1237003025))
		{
			launchOffset = ((RaycastHit)(ref val)).distance - 0.1f;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(projectilePrefab.resourcePath, firingPos + firingDir * launchOffset);
		projectile = ((Component)baseEntity).GetComponent<ServerProjectile>();
		Vector3 val2 = projectile.initialVelocity + firingDir * projectile.speed;
		if (minSpeed > 0f)
		{
			float num = Vector3.Dot(val2, firingDir) - minSpeed;
			if (num < 0f)
			{
				val2 += firingDir * (0f - num);
			}
		}
		projectile.InitializeVelocity(val2);
		if (shooter.IsValid())
		{
			baseEntity.creatorEntity = shooter;
			baseEntity.OwnerID = shooter.userID;
		}
		baseEntity.Spawn();
		Analytics.Azure.OnExplosiveLaunched(shooter, baseEntity, this);
		return true;
	}

	public override void DisableTransferProtection()
	{
		base.DisableTransferProtection();
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null && mounted.IsTransferProtected())
		{
			mounted.DisableTransferProtection();
		}
	}

	protected virtual int GetClipCheckMask()
	{
		return 1210122497;
	}

	public virtual bool IsSeatClipping(BaseMountable mountable)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!clippingAndVisChecks)
		{
			return false;
		}
		if ((Object)(object)mountable == (Object)null)
		{
			return false;
		}
		int clipCheckMask = GetClipCheckMask();
		Vector3 position = ((Component)mountable.eyePositionOverride).transform.position;
		Vector3 position2 = ((Component)mountable).transform.position;
		Vector3 val = position - position2;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		float num = clippingCheckRadius;
		if (mountable.modifiesPlayerCollider)
		{
			num = Mathf.Min(num, mountable.customPlayerCollider.radius);
		}
		Vector3 startPos = position - normalized * (num - 0.2f);
		return IsSeatClipping(mountable, startPos, num, clipCheckMask, position2, normalized);
	}

	public virtual Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.zero;
	}

	protected virtual bool IsSeatClipping(BaseMountable mountable, Vector3 startPos, float radius, int mask, Vector3 seatPos, Vector3 direction)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (clippingChecksLocation == ClippingCheckLocation.HeadOnly)
		{
			return GamePhysics.CheckSphere(startPos, radius, mask, (QueryTriggerInteraction)1);
		}
		Vector3 end = seatPos + direction * (radius + 0.05f);
		return GamePhysics.CheckCapsule(startPos, end, radius, mask, (QueryTriggerInteraction)1);
	}

	public virtual bool IsInstrument()
	{
		return false;
	}

	public Vector3 GetDismountCheckStart(BasePlayer player)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = GetMountedPosition() + BasePlayer.NoClipOffset();
		Vector3 val2 = (((Object)(object)mountAnchor == (Object)null) ? ((Component)this).transform.forward : ((Component)mountAnchor).transform.forward);
		Vector3 val3 = (((Object)(object)mountAnchor == (Object)null) ? ((Component)this).transform.up : ((Component)mountAnchor).transform.up);
		if (mountPose == PlayerModel.MountPoses.Chair)
		{
			val += -val2 * 0.32f;
			val += val3 * 0.25f;
		}
		else if (mountPose == PlayerModel.MountPoses.SitGeneric)
		{
			val += -val2 * 0.26f;
			val += val3 * 0.25f;
		}
		else if (mountPose == PlayerModel.MountPoses.SitGeneric)
		{
			val += -val2 * 0.26f;
		}
		return val;
	}

	public virtual Vector3 GetMountedPosition()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)mountAnchor == (Object)null)
		{
			return ((Component)this).transform.position;
		}
		return ((Component)mountAnchor).transform.position;
	}

	public virtual float GetSpeed()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (!isMobile)
		{
			return 0f;
		}
		return Vector3.Dot(GetLocalVelocity(), ((Component)this).transform.forward);
	}

	public bool CanPlayerSeeMountPoint(Ray ray, BasePlayer player, float maxDistance)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)mountAnchor == (Object)null)
		{
			return false;
		}
		RaycastHit hit = default(RaycastHit);
		if (Physics.SphereCast(ray, 0.25f, ref hit, maxDistance, 1218652417))
		{
			BaseEntity entity = hit.GetEntity();
			if ((Object)(object)entity != (Object)null)
			{
				if ((Object)(object)entity == (Object)(object)this || EqualNetID((BaseNetworkable)entity))
				{
					return true;
				}
				if (entity is BasePlayer basePlayer)
				{
					BaseMountable mounted = basePlayer.GetMounted();
					if ((Object)(object)mounted == (Object)(object)this)
					{
						return true;
					}
					if ((Object)(object)mounted != (Object)null && (Object)(object)mounted.VehicleParent() == (Object)(object)this)
					{
						return true;
					}
				}
				BaseEntity baseEntity = entity.GetParentEntity();
				if (hit.IsOnLayer((Layer)13) && ((Object)(object)baseEntity == (Object)(object)this || EqualNetID((BaseNetworkable)baseEntity)))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool NearMountPoint(BasePlayer player)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)mountAnchor == (Object)null)
		{
			return false;
		}
		if (Vector3.Distance(((Component)player).transform.position, mountAnchor.position) <= maxMountDistance)
		{
			return CanPlayerSeeMountPoint(player.eyes.HeadRay(), player, 2f);
		}
		return false;
	}

	protected bool ClothingBlocksMounting(BasePlayer player)
	{
		if (BypassClothingMountBlocks)
		{
			return false;
		}
		foreach (Item item in player.inventory.containerWear.itemList)
		{
			if ((Object)(object)item.info.ItemModWearable != (Object)null && item.info.ItemModWearable.preventsMounting)
			{
				return true;
			}
		}
		return false;
	}

	public static Vector3 ConvertVector(Vector3 vec)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 3; i++)
		{
			if (((Vector3)(ref vec))[i] > 180f)
			{
				ref Vector3 reference = ref vec;
				int num = i;
				((Vector3)(ref reference))[num] = ((Vector3)(ref reference))[num] - 360f;
			}
			else if (((Vector3)(ref vec))[i] < -180f)
			{
				ref Vector3 reference = ref vec;
				int num = i;
				((Vector3)(ref reference))[num] = ((Vector3)(ref reference))[num] + 360f;
			}
		}
		return vec;
	}
}


public enum ClippingCheckLocation
{
	HeadOnly,
	WholeBody
}


public enum DismountConvarType
{
	Misc,
	Boating,
	Flying,
	GroundVehicle,
	Horse
}


public enum MountStatType
{
	None,
	Boating,
	Flying,
	Driving
}


public enum MountGestureType
{
	None,
	UpperBody
}


using System;
using System.Collections;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;
using UnityEngine.Assertions;

public class BaseNpc : BaseCombatEntity
{
	public enum Behaviour
	{
		Idle,
		Wander,
		Attack,
		Flee,
		Eat,
		Sleep,
		RetreatingToCover
	}

	[Flags]
	public enum AiFlags
	{
		Sitting = 2,
		Chasing = 4,
		Sleeping = 8
	}

	public enum Facts
	{
		HasEnemy,
		EnemyRange,
		CanTargetEnemies,
		Health,
		Speed,
		IsTired,
		IsSleeping,
		IsAttackReady,
		IsRoamReady,
		IsAggro,
		WantsToFlee,
		IsHungry,
		FoodRange,
		AttackedLately,
		LoudNoiseNearby,
		CanTargetFood,
		IsMoving,
		IsFleeing,
		IsEating,
		IsAfraid,
		AfraidRange,
		IsUnderHealthThreshold,
		CanNotMove,
		PathToTargetStatus
	}

	public enum EnemyRangeEnum : byte
	{
		AttackRange,
		AggroRange,
		AwareRange,
		OutOfRange
	}

	public enum FoodRangeEnum : byte
	{
		EatRange,
		AwareRange,
		OutOfRange
	}

	public enum AfraidRangeEnum : byte
	{
		InAfraidRange,
		OutOfRange
	}

	public enum HealthEnum : byte
	{
		Fine,
		Medium,
		Low
	}

	public enum SpeedEnum : byte
	{
		StandStill,
		Walk,
		Run
	}

	[Serializable]
	public struct AiStatistics
	{
		public enum FamilyEnum
		{
			Bear,
			Wolf,
			Deer,
			Boar,
			Chicken,
			Horse,
			Zombie,
			Scientist,
			Murderer,
			Player
		}

		[Range(0f, 1f)]
		[Tooltip("Ai will be less likely to fight animals that are larger than them, and more likely to flee from them.")]
		public float Size;

		[Tooltip("How fast we can move")]
		public float Speed;

		[Tooltip("How fast can we accelerate")]
		public float Acceleration;

		[Tooltip("How fast can we turn around")]
		public float TurnSpeed;

		[Tooltip("Determines things like how near we'll allow other species to get")]
		[Range(0f, 1f)]
		public float Tolerance;

		[Tooltip("How far this NPC can see")]
		public float VisionRange;

		[Tooltip("Our vision cone for dot product - a value of -1 means we can see all around us, 0 = only infront ")]
		public float VisionCone;

		[Tooltip("NPCs use distance visibility to basically make closer enemies easier to detect than enemies further away")]
		public AnimationCurve DistanceVisibility;

		[Tooltip("How likely are we to be offensive without being threatened")]
		public float Hostility;

		[Tooltip("How likely are we to defend ourselves when attacked")]
		public float Defensiveness;

		[Tooltip("The range at which we will engage targets")]
		public float AggressionRange;

		[Tooltip("The range at which an aggrified npc will disengage it's current target")]
		public float DeaggroRange;

		[Tooltip("For how long will we chase a target until we give up")]
		public float DeaggroChaseTime;

		[Tooltip("When we deaggro, how long do we wait until we can aggro again.")]
		public float DeaggroCooldown;

		[Tooltip("The threshold of our health fraction where there's a chance that we want to flee")]
		public float HealthThresholdForFleeing;

		[Tooltip("The chance that we will flee when our health threshold is triggered")]
		public float HealthThresholdFleeChance;

		[Tooltip("When we flee, what is the minimum distance we should flee?")]
		public float MinFleeRange;

		[Tooltip("When we flee, what is the maximum distance we should flee?")]
		public float MaxFleeRange;

		[Tooltip("When we flee, what is the maximum time that can pass until we stop?")]
		public float MaxFleeTime;

		[Tooltip("At what range we are afraid of a target that is in our Is Afraid Of list.")]
		public float AfraidRange;

		[Tooltip("The family this npc belong to. Npcs in the same family will not attack each other.")]
		public FamilyEnum Family;

		[Tooltip("List of the types of Npc that we are afraid of.")]
		public FamilyEnum[] IsAfraidOf;

		[Tooltip("The minimum distance this npc will wander when idle.")]
		public float MinRoamRange;

		[Tooltip("The maximum distance this npc will wander when idle.")]
		public float MaxRoamRange;

		[Tooltip("The minimum amount of time between each time we seek a new roam destination (when idle)")]
		public float MinRoamDelay;

		[Tooltip("The maximum amount of time between each time we seek a new roam destination (when idle)")]
		public float MaxRoamDelay;

		[Tooltip("If an npc is mobile, they are allowed to move when idle.")]
		public bool IsMobile;

		[Tooltip("In the range between min and max roam delay, we evaluate the random value through this curve")]
		public AnimationCurve RoamDelayDistribution;

		[Tooltip("For how long do we remember that someone attacked us")]
		public float AttackedMemoryTime;

		[Tooltip("How long should we block movement to make the wakeup animation not look whack?")]
		public float WakeupBlockMoveTime;

		[Tooltip("The maximum water depth this npc willingly will walk into.")]
		public float MaxWaterDepth;

		[Tooltip("The water depth at which they will start swimming.")]
		public float WaterLevelNeck;

		public float WaterLevelNeckOffset;

		[Tooltip("The range we consider using close range weapons.")]
		public float CloseRange;

		[Tooltip("The range we consider using medium range weapons.")]
		public float MediumRange;

		[Tooltip("The range we consider using long range weapons.")]
		public float LongRange;

		[Tooltip("How long can we be out of range of our spawn point before we time out and make our way back home (when idle).")]
		public float OutOfRangeOfSpawnPointTimeout;

		[Tooltip("If this is set to true, then a target must hold special markers (like IsHostile) for the target to be considered for aggressive action.")]
		public bool OnlyAggroMarkedTargets;
	}

	public int agentTypeIndex;

	public bool NewAI;

	public bool LegacyNavigation = true;

	public bool canSwim = true;

	private Vector3 stepDirection;

	private float maxFleeTime;

	private float fleeHealthThresholdPercentage = 1f;

	private float blockEnemyTargetingTimeout = float.NegativeInfinity;

	private float blockFoodTargetingTimeout = float.NegativeInfinity;

	private float aggroTimeout = float.NegativeInfinity;

	private float lastAggroChanceResult;

	private float lastAggroChanceCalcTime;

	private const float aggroChanceRecalcTimeout = 5f;

	private float eatTimeout = float.NegativeInfinity;

	private float wakeUpBlockMoveTimeout = float.NegativeInfinity;

	private BaseEntity blockTargetingThisEnemy;

	[NonSerialized]
	public float waterDepth;

	[NonSerialized]
	public bool swimming;

	[NonSerialized]
	public bool wasSwimming;

	private static readonly AnimationCurve speedFractionResponse = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	private bool _traversingNavMeshLink;

	private OffMeshLinkData _currentNavMeshLink;

	private string _currentNavMeshLinkName;

	private float _currentNavMeshLinkTraversalTime;

	private float _currentNavMeshLinkTraversalTimeDelta;

	private Quaternion _currentNavMeshLinkOrientation;

	private Vector3 _currentNavMeshLinkEndPos;

	public float nextAttackTime;

	[InspectorFlags]
	[SerializeField]
	public Enum topologyPreference = (Enum)96;

	[NonSerialized]
	public Transform ChaseTransform;

	[Header("BaseNpc")]
	public GameObjectRef CorpsePrefab;

	public AiStatistics Stats;

	public Vector3 AttackOffset;

	public float AttackDamage = 20f;

	public DamageType AttackDamageType = DamageType.Bite;

	public float MinimumTargetHealthFraction;

	[Tooltip("Stamina to use per attack")]
	public float AttackCost = 0.1f;

	[Tooltip("How often can we attack")]
	public float AttackRate = 1f;

	[Tooltip("Maximum Distance for an attack")]
	public float AttackRange = 1f;

	public NavMeshAgent NavAgent;

	public LayerMask movementMask = LayerMask.op_Implicit(1503731969);

	public float stuckDuration;

	public float lastStuckTime;

	public float idleDuration;

	private bool _isDormant;

	private float lastSetDestinationTime;

	[NonSerialized]
	public StateTimer BusyTimer;

	[NonSerialized]
	public float Sleep;

	[NonSerialized]
	public VitalLevel Stamina;

	[NonSerialized]
	public VitalLevel Energy;

	[NonSerialized]
	public VitalLevel Hydration;

	[InspectorFlags]
	public AiFlags aiFlags;

	[NonSerialized]
	public byte[] CurrentFacts = new byte[Enum.GetValues(typeof(Facts)).Length];

	[Header("NPC Senses")]
	public int ForgetUnseenEntityTime = 10;

	public float SensesTickRate = 0.5f;

	[NonSerialized]
	public BaseEntity[] SensesResults = new BaseEntity[64];

	private float lastTickTime;

	public float playerTargetDecisionStartTime;

	private float animalTargetDecisionStartTime;

	private bool isAlreadyCheckingPathPending;

	private int numPathPendingAttempts;

	private float accumPathPendingDelay;

	public const float TickRate = 0.1f;

	private Vector3 lastStuckPos;

	private float nextFlinchTime;

	public int AgentTypeIndex
	{
		get
		{
			return agentTypeIndex;
		}
		set
		{
			agentTypeIndex = value;
		}
	}

	public bool IsStuck { get; set; }

	public bool AgencyUpdateRequired { get; set; }

	public bool IsOnOffmeshLinkAndReachedNewCoord { get; set; }

	public float GetAttackRate => AttackRate;

	public override bool IsNpc => true;

	public bool IsDormant
	{
		get
		{
			return _isDormant;
		}
		set
		{
			_isDormant = value;
			if (_isDormant)
			{
				StopMoving();
				Pause();
			}
			else if ((Object)(object)GetNavAgent == (Object)null || AiManager.nav_disable)
			{
				IsDormant = true;
			}
			else
			{
				Resume();
			}
		}
	}

	public float SecondsSinceLastSetDestination => Time.time - lastSetDestinationTime;

	public float LastSetDestinationTime => lastSetDestinationTime;

	public Vector3 Destination
	{
		get
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (IsNavRunning())
			{
				return GetNavAgent.destination;
			}
			return Entity.ServerPosition;
		}
		set
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			if (IsNavRunning())
			{
				GetNavAgent.destination = value;
				lastSetDestinationTime = Time.time;
			}
		}
	}

	public bool IsStopped
	{
		get
		{
			if (IsNavRunning())
			{
				return GetNavAgent.isStopped;
			}
			return true;
		}
		set
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			if (IsNavRunning())
			{
				if (value)
				{
					GetNavAgent.destination = ServerPosition;
				}
				GetNavAgent.isStopped = value;
			}
		}
	}

	public bool AutoBraking
	{
		get
		{
			if (IsNavRunning())
			{
				return GetNavAgent.autoBraking;
			}
			return false;
		}
		set
		{
			if (IsNavRunning())
			{
				GetNavAgent.autoBraking = value;
			}
		}
	}

	public bool HasPath
	{
		get
		{
			if (IsNavRunning())
			{
				return GetNavAgent.hasPath;
			}
			return false;
		}
	}

	public BaseEntity AttackTarget { get; set; }

	public Memory.SeenInfo AttackTargetMemory { get; set; }

	public BaseEntity FoodTarget { get; set; }

	public BaseCombatEntity CombatTarget => AttackTarget as BaseCombatEntity;

	public Vector3 SpawnPosition { get; set; }

	public float AttackTargetVisibleFor => 0f;

	public float TimeAtDestination => 0f;

	public BaseCombatEntity Entity => this;

	public NavMeshAgent GetNavAgent
	{
		get
		{
			if (base.isClient)
			{
				return null;
			}
			if ((Object)(object)NavAgent == (Object)null)
			{
				NavAgent = ((Component)this).GetComponent<NavMeshAgent>();
				if ((Object)(object)NavAgent == (Object)null)
				{
					Debug.LogErrorFormat("{0} has no nav agent!", new object[1] { ((Object)this).name });
				}
			}
			return NavAgent;
		}
	}

	public AiStatistics GetStats => Stats;

	public float GetAttackRange => AttackRange;

	public Vector3 GetAttackOffset => AttackOffset;

	public float GetStamina => Stamina.Level;

	public float GetEnergy => Energy.Level;

	public float GetAttackCost => AttackCost;

	public float GetSleep => Sleep;

	public Vector3 CurrentAimAngles => ((Component)this).transform.forward;

	public float GetStuckDuration => stuckDuration;

	public float GetLastStuckTime => lastStuckTime;

	public Vector3 AttackPosition => ServerPosition + ((Component)this).transform.TransformDirection(AttackOffset);

	public Vector3 CrouchedAttackPosition => AttackPosition;

	public float currentBehaviorDuration => 0f;

	public Behaviour CurrentBehaviour { get; set; }

	public bool IsSitting
	{
		get
		{
			return HasAiFlag(AiFlags.Sitting);
		}
		set
		{
			SetAiFlag(AiFlags.Sitting, value);
		}
	}

	public bool IsChasing
	{
		get
		{
			return HasAiFlag(AiFlags.Chasing);
		}
		set
		{
			SetAiFlag(AiFlags.Chasing, value);
		}
	}

	public bool IsSleeping
	{
		get
		{
			return HasAiFlag(AiFlags.Sleeping);
		}
		set
		{
			SetAiFlag(AiFlags.Sleeping, value);
		}
	}

	public float TargetSpeed { get; set; }

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseNpc.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override string DebugText()
	{
		return string.Concat(string.Concat(string.Concat(base.DebugText() + $"\nBehaviour: {CurrentBehaviour}", $"\nAttackTarget: {AttackTarget}"), $"\nFoodTarget: {FoodTarget}"), $"\nSleep: {Sleep:0.00}");
	}

	public void TickAi()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.think)
		{
			return;
		}
		if ((Object)(object)TerrainMeta.WaterMap != (Object)null)
		{
			wasSwimming = swimming;
			if (canSwim)
			{
				waterDepth = WaterLevel.GetWaterDepth(ServerPosition, waves: false, volumes: false);
				swimming = waterDepth > Stats.WaterLevelNeck * 0.25f;
			}
			else
			{
				swimming = false;
			}
		}
		else
		{
			wasSwimming = false;
			swimming = false;
			waterDepth = 0f;
		}
		TimeWarning val = TimeWarning.New("TickNavigation", 0);
		try
		{
			TickNavigation();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		if (AiManager.ai_dormant && !((Behaviour)GetNavAgent).enabled && CurrentBehaviour != Behaviour.Sleep && !NewAI)
		{
			return;
		}
		val = TimeWarning.New("TickMetabolism", 0);
		try
		{
			TickSleep();
			TickMetabolism();
			TickSpeed();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void TickSpeed()
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		if (!LegacyNavigation)
		{
			return;
		}
		float speed = Stats.Speed;
		if (NewAI)
		{
			speed = (swimming ? ToSpeed(SpeedEnum.Walk) : TargetSpeed);
			speed *= 0.5f + base.healthFraction * 0.5f;
			NavAgent.speed = Mathf.Lerp(NavAgent.speed, speed, 0.5f);
			NavAgent.angularSpeed = Stats.TurnSpeed;
			NavAgent.acceleration = Stats.Acceleration;
			return;
		}
		speed *= 0.5f + base.healthFraction * 0.5f;
		if (CurrentBehaviour == Behaviour.Idle)
		{
			speed *= 0.2f;
		}
		if (CurrentBehaviour == Behaviour.Eat)
		{
			speed *= 0.3f;
		}
		float num = Mathf.Min(NavAgent.speed / Stats.Speed, 1f);
		num = speedFractionResponse.Evaluate(num);
		Vector3 forward = ((Component)this).transform.forward;
		Vector3 val = NavAgent.nextPosition - ServerPosition;
		float num2 = 1f - 0.9f * Vector3.Angle(forward, ((Vector3)(ref val)).normalized) / 180f * num * num;
		speed *= num2;
		NavAgent.speed = Mathf.Lerp(NavAgent.speed, speed, 0.5f);
		NavAgent.angularSpeed = Stats.TurnSpeed * (1.1f - num);
		NavAgent.acceleration = Stats.Acceleration;
	}

	protected virtual void TickMetabolism()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.00016666666f;
		if (CurrentBehaviour == Behaviour.Sleep)
		{
			num *= 0.01f;
		}
		Vector3 desiredVelocity = NavAgent.desiredVelocity;
		if (((Vector3)(ref desiredVelocity)).sqrMagnitude > 0.1f)
		{
			num *= 2f;
		}
		Energy.Add(num * 0.1f * -1f);
		if (Stamina.TimeSinceUsed > 5f)
		{
			float num2 = 1f / 15f;
			Stamina.Add(0.1f * num2);
		}
		_ = base.SecondsSinceAttacked;
		_ = 60f;
	}

	public virtual bool WantsToEat(BaseEntity best)
	{
		object obj = Interface.CallHook("CanNpcEat", (object)this, (object)best);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!best.HasTrait(TraitFlag.Food))
		{
			return false;
		}
		if (best.HasTrait(TraitFlag.Alive))
		{
			return false;
		}
		return true;
	}

	public virtual float FearLevel(BaseEntity ent)
	{
		float num = 0f;
		BaseNpc baseNpc = ent as BaseNpc;
		if ((Object)(object)baseNpc != (Object)null && baseNpc.Stats.Size > Stats.Size)
		{
			if (baseNpc.WantsToAttack(this) > 0.25f)
			{
				num += 0.2f;
			}
			if ((Object)(object)baseNpc.AttackTarget == (Object)(object)this)
			{
				num += 0.3f;
			}
			if (baseNpc.CurrentBehaviour == Behaviour.Attack)
			{
				num *= 1.5f;
			}
			if (baseNpc.CurrentBehaviour == Behaviour.Sleep)
			{
				num *= 0.1f;
			}
		}
		if ((Object)(object)(ent as BasePlayer) != (Object)null)
		{
			num += 1f;
		}
		return num;
	}

	public virtual float HateLevel(BaseEntity ent)
	{
		return 0f;
	}

	protected virtual void TickSleep()
	{
		if (CurrentBehaviour == Behaviour.Sleep)
		{
			IsSleeping = true;
			Sleep += 0.00033333336f;
		}
		else
		{
			IsSleeping = false;
			Sleep -= 2.7777778E-05f;
		}
		Sleep = Mathf.Clamp01(Sleep);
	}

	public void TickNavigationWater()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		if (!LegacyNavigation || !AI.move || !IsNavRunning())
		{
			return;
		}
		if (IsDormant || !syncPosition)
		{
			StopMoving();
			return;
		}
		Vector3 moveToPosition = ((Component)this).transform.position;
		stepDirection = Vector3.zero;
		if (Object.op_Implicit((Object)(object)ChaseTransform))
		{
			TickChase();
		}
		if (NavAgent.isOnOffMeshLink)
		{
			HandleNavMeshLinkTraversal(0.1f, ref moveToPosition);
		}
		else if (NavAgent.hasPath)
		{
			TickFollowPath(ref moveToPosition);
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			moveToPosition.y = 0f - Stats.WaterLevelNeck;
			UpdatePositionAndRotation(moveToPosition);
			TickIdle();
			TickStuck();
		}
	}

	public void TickNavigation()
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (!LegacyNavigation || !AI.move || !IsNavRunning())
		{
			return;
		}
		if (IsDormant || !syncPosition)
		{
			StopMoving();
			return;
		}
		Vector3 moveToPosition = ((Component)this).transform.position;
		stepDirection = Vector3.zero;
		if (Object.op_Implicit((Object)(object)ChaseTransform))
		{
			TickChase();
		}
		if (NavAgent.isOnOffMeshLink)
		{
			HandleNavMeshLinkTraversal(0.1f, ref moveToPosition);
		}
		else if (NavAgent.hasPath)
		{
			TickFollowPath(ref moveToPosition);
		}
		if (ValidateNextPosition(ref moveToPosition))
		{
			UpdatePositionAndRotation(moveToPosition);
			TickIdle();
			TickStuck();
		}
	}

	private void TickChase()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ChaseTransform.position;
		Vector3 val2 = ((Component)this).transform.position - val;
		if ((double)((Vector3)(ref val2)).magnitude < 5.0)
		{
			val += ((Vector3)(ref val2)).normalized * AttackOffset.z;
		}
		Vector3 val3 = NavAgent.destination - val;
		if (((Vector3)(ref val3)).sqrMagnitude > 0.010000001f)
		{
			NavAgent.SetDestination(val);
		}
	}

	private void HandleNavMeshLinkTraversal(float delta, ref Vector3 moveToPosition)
	{
		if (_traversingNavMeshLink || HandleNavMeshLinkTraversalStart(delta))
		{
			HandleNavMeshLinkTraversalTick(delta, ref moveToPosition);
			if (!IsNavMeshLinkTraversalComplete(delta, ref moveToPosition))
			{
				_currentNavMeshLinkTraversalTimeDelta += delta;
			}
		}
	}

	private bool HandleNavMeshLinkTraversalStart(float delta)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		OffMeshLinkData currentOffMeshLinkData = NavAgent.currentOffMeshLinkData;
		if (!((OffMeshLinkData)(ref currentOffMeshLinkData)).valid || !((OffMeshLinkData)(ref currentOffMeshLinkData)).activated || (Object)(object)((OffMeshLinkData)(ref currentOffMeshLinkData)).offMeshLink == (Object)null)
		{
			return false;
		}
		Vector3 val = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		Vector3 desiredVelocity = NavAgent.desiredVelocity;
		desiredVelocity.y = 0f;
		if (Vector3.Dot(desiredVelocity, normalized) < 0.1f)
		{
			CompleteNavMeshLink();
			return false;
		}
		_currentNavMeshLink = currentOffMeshLinkData;
		OffMeshLinkType linkType = ((OffMeshLinkData)(ref _currentNavMeshLink)).linkType;
		_currentNavMeshLinkName = ((object)(OffMeshLinkType)(ref linkType)/*cast due to .constrained prefix*/).ToString();
		if (((OffMeshLinkData)(ref currentOffMeshLinkData)).offMeshLink.biDirectional)
		{
			val = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos - ServerPosition;
			if (((Vector3)(ref val)).sqrMagnitude < 0.05f)
			{
				_currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos;
				_currentNavMeshLinkOrientation = Quaternion.LookRotation(((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos + Vector3.up * (((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos.y - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos.y) - ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos);
			}
			else
			{
				_currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos;
				_currentNavMeshLinkOrientation = Quaternion.LookRotation(((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos + Vector3.up * (((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos.y - ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos.y) - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos);
			}
		}
		else
		{
			_currentNavMeshLinkEndPos = ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos;
			_currentNavMeshLinkOrientation = Quaternion.LookRotation(((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos + Vector3.up * (((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos.y - ((OffMeshLinkData)(ref currentOffMeshLinkData)).endPos.y) - ((OffMeshLinkData)(ref currentOffMeshLinkData)).startPos);
		}
		_traversingNavMeshLink = true;
		NavAgent.ActivateCurrentOffMeshLink(false);
		NavAgent.obstacleAvoidanceType = (ObstacleAvoidanceType)0;
		float num = Mathf.Max(NavAgent.speed, 2.8f);
		Vector3 val2 = ((OffMeshLinkData)(ref _currentNavMeshLink)).startPos - ((OffMeshLinkData)(ref _currentNavMeshLink)).endPos;
		float magnitude = ((Vector3)(ref val2)).magnitude;
		_currentNavMeshLinkTraversalTime = magnitude / num;
		_currentNavMeshLinkTraversalTimeDelta = 0f;
		if (!(_currentNavMeshLinkName == "OpenDoorLink") && !(_currentNavMeshLinkName == "JumpRockLink"))
		{
			_ = _currentNavMeshLinkName == "JumpFoundationLink";
		}
		return true;
	}

	private void HandleNavMeshLinkTraversalTick(float delta, ref Vector3 moveToPosition)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (_currentNavMeshLinkName == "OpenDoorLink")
		{
			moveToPosition = Vector3.Lerp(((OffMeshLinkData)(ref _currentNavMeshLink)).startPos, ((OffMeshLinkData)(ref _currentNavMeshLink)).endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
		else if (_currentNavMeshLinkName == "JumpRockLink")
		{
			moveToPosition = Vector3.Lerp(((OffMeshLinkData)(ref _currentNavMeshLink)).startPos, ((OffMeshLinkData)(ref _currentNavMeshLink)).endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
		else if (_currentNavMeshLinkName == "JumpFoundationLink")
		{
			moveToPosition = Vector3.Lerp(((OffMeshLinkData)(ref _currentNavMeshLink)).startPos, ((OffMeshLinkData)(ref _currentNavMeshLink)).endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
		else
		{
			moveToPosition = Vector3.Lerp(((OffMeshLinkData)(ref _currentNavMeshLink)).startPos, ((OffMeshLinkData)(ref _currentNavMeshLink)).endPos, _currentNavMeshLinkTraversalTimeDelta);
		}
	}

	private bool IsNavMeshLinkTraversalComplete(float delta, ref Vector3 moveToPosition)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (_currentNavMeshLinkTraversalTimeDelta >= _currentNavMeshLinkTraversalTime)
		{
			moveToPosition = ((OffMeshLinkData)(ref _currentNavMeshLink)).endPos;
			_traversingNavMeshLink = false;
			_currentNavMeshLink = default(OffMeshLinkData);
			_currentNavMeshLinkTraversalTime = 0f;
			_currentNavMeshLinkTraversalTimeDelta = 0f;
			_currentNavMeshLinkName = string.Empty;
			_currentNavMeshLinkOrientation = Quaternion.identity;
			CompleteNavMeshLink();
			return true;
		}
		return false;
	}

	private void CompleteNavMeshLink()
	{
		NavAgent.ActivateCurrentOffMeshLink(true);
		NavAgent.CompleteOffMeshLink();
		NavAgent.isStopped = false;
		NavAgent.obstacleAvoidanceType = (ObstacleAvoidanceType)4;
	}

	private void TickFollowPath(ref Vector3 moveToPosition)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		moveToPosition = NavAgent.nextPosition;
		Vector3 desiredVelocity = NavAgent.desiredVelocity;
		stepDirection = ((Vector3)(ref desiredVelocity)).normalized;
	}

	private bool ValidateNextPosition(ref Vector3 moveToPosition)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (!ValidBounds.Test(this, moveToPosition) && (Object)(object)((Component)this).transform != (Object)null && !base.IsDestroyed)
		{
			string[] obj = new string[5]
			{
				"Invalid NavAgent Position: ",
				((object)this)?.ToString(),
				" ",
				null,
				null
			};
			Vector3 val = moveToPosition;
			obj[3] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
			obj[4] = " (destroying)";
			Debug.Log((object)string.Concat(obj));
			Kill();
			return false;
		}
		return true;
	}

	private void UpdatePositionAndRotation(Vector3 moveToPosition)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		ServerPosition = moveToPosition;
		UpdateAiRotation();
	}

	private void TickIdle()
	{
		if (CurrentBehaviour == Behaviour.Idle)
		{
			idleDuration += 0.1f;
		}
		else
		{
			idleDuration = 0f;
		}
	}

	public void TickStuck()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (IsNavRunning() && !NavAgent.isStopped)
		{
			Vector3 val = lastStuckPos - ServerPosition;
			if (((Vector3)(ref val)).sqrMagnitude < 0.0625f && AttackReady())
			{
				stuckDuration += 0.1f;
				if (stuckDuration >= 5f && Mathf.Approximately(lastStuckTime, 0f))
				{
					lastStuckTime = Time.time;
					OnBecomeStuck();
				}
				return;
			}
		}
		stuckDuration = 0f;
		lastStuckPos = ServerPosition;
		if (Time.time - lastStuckTime > 5f)
		{
			lastStuckTime = 0f;
			OnBecomeUnStuck();
		}
	}

	public void OnBecomeStuck()
	{
		IsStuck = true;
	}

	public void OnBecomeUnStuck()
	{
		IsStuck = false;
	}

	public void UpdateAiRotation()
	{
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		if (!IsNavRunning() || CurrentBehaviour == Behaviour.Sleep)
		{
			return;
		}
		if (_traversingNavMeshLink)
		{
			Vector3 val = (((Object)(object)ChaseTransform != (Object)null) ? (ChaseTransform.localPosition - ServerPosition) : ((!((Object)(object)AttackTarget != (Object)null)) ? (NavAgent.destination - ServerPosition) : (AttackTarget.ServerPosition - ServerPosition)));
			if (((Vector3)(ref val)).sqrMagnitude > 1f)
			{
				val = _currentNavMeshLinkEndPos - ServerPosition;
			}
			if (((Vector3)(ref val)).sqrMagnitude > 0.001f)
			{
				ServerRotation = _currentNavMeshLinkOrientation;
				return;
			}
		}
		else
		{
			Vector3 val2 = NavAgent.destination - ServerPosition;
			if (((Vector3)(ref val2)).sqrMagnitude > 1f)
			{
				Vector3 val3 = stepDirection;
				if (((Vector3)(ref val3)).sqrMagnitude > 0.001f)
				{
					ServerRotation = Quaternion.LookRotation(val3);
					return;
				}
			}
		}
		if (Object.op_Implicit((Object)(object)ChaseTransform) && CurrentBehaviour == Behaviour.Attack)
		{
			Vector3 val4 = ChaseTransform.localPosition - ServerPosition;
			float sqrMagnitude = ((Vector3)(ref val4)).sqrMagnitude;
			if (sqrMagnitude < 9f && sqrMagnitude > 0.001f)
			{
				ServerRotation = Quaternion.LookRotation(((Vector3)(ref val4)).normalized);
			}
		}
		else if (Object.op_Implicit((Object)(object)AttackTarget) && CurrentBehaviour == Behaviour.Attack)
		{
			Vector3 val5 = AttackTarget.ServerPosition - ServerPosition;
			float sqrMagnitude2 = ((Vector3)(ref val5)).sqrMagnitude;
			if (sqrMagnitude2 < 9f && sqrMagnitude2 > 0.001f)
			{
				ServerRotation = Quaternion.LookRotation(((Vector3)(ref val5)).normalized);
			}
		}
	}

	public bool AttackReady()
	{
		return Time.realtimeSinceStartup >= nextAttackTime;
	}

	public virtual void StartAttack()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)AttackTarget) || !AttackReady() || Interface.CallHook("OnNpcAttack", (object)this, (object)AttackTarget) != null)
		{
			return;
		}
		Vector3 val = AttackTarget.ServerPosition - ServerPosition;
		if (!(((Vector3)(ref val)).magnitude > AttackRange))
		{
			nextAttackTime = Time.realtimeSinceStartup + AttackRate;
			BaseCombatEntity combatTarget = CombatTarget;
			if (Object.op_Implicit((Object)(object)combatTarget))
			{
				combatTarget.Hurt(AttackDamage, AttackDamageType, this);
				Stamina.Use(AttackCost);
				BusyTimer.Activate(0.5f);
				SignalBroadcast(Signal.Attack);
				ClientRPC(RpcTarget.NetworkGroup("Attack"), AttackTarget.ServerPosition);
			}
		}
	}

	public void Attack(BaseCombatEntity target)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)target == (Object)null) && (!(MinimumTargetHealthFraction > 0f) || !(target.healthFraction < MinimumTargetHealthFraction)))
		{
			Vector3 val = target.ServerPosition - ServerPosition;
			if (((Vector3)(ref val)).magnitude > 0.001f)
			{
				ServerRotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
			}
			nextAttackTime = Time.realtimeSinceStartup + AttackRate;
			target.OnAttacked(AttackDamage, AttackDamageType, this, ignoreShield: false);
			Stamina.Use(AttackCost);
			SignalBroadcast(Signal.Attack);
			ClientRPC(RpcTarget.NetworkGroup("Attack"), target.ServerPosition);
		}
	}

	public virtual void Eat()
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)FoodTarget))
		{
			BusyTimer.Activate(0.5f);
			FoodTarget.Eat(this, 0.5f);
			StartEating(Random.value * 5f + 0.5f);
			ClientRPC(RpcTarget.NetworkGroup("Eat"), ((Component)FoodTarget).transform.position);
		}
	}

	public virtual void AddCalories(float amount)
	{
		Energy.Add(amount / 1000f);
	}

	public virtual void Startled()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		ClientRPC(RpcTarget.NetworkGroup("Startled"), ((Component)this).transform.position);
	}

	private bool IsAfraid()
	{
		SetFact(Facts.IsAfraid, 0);
		return false;
	}

	protected bool IsAfraidOf(AiStatistics.FamilyEnum family)
	{
		AiStatistics.FamilyEnum[] isAfraidOf = Stats.IsAfraidOf;
		foreach (AiStatistics.FamilyEnum familyEnum in isAfraidOf)
		{
			if (family == familyEnum)
			{
				return true;
			}
		}
		return false;
	}

	private bool CheckHealthThresholdToFlee()
	{
		if (base.healthFraction > Stats.HealthThresholdForFleeing)
		{
			if (Stats.HealthThresholdForFleeing < 1f)
			{
				SetFact(Facts.IsUnderHealthThreshold, 0);
				return false;
			}
			if (GetFact(Facts.HasEnemy) == 1)
			{
				SetFact(Facts.IsUnderHealthThreshold, 0);
				return false;
			}
		}
		bool flag = Random.value < Stats.HealthThresholdFleeChance;
		SetFact(Facts.IsUnderHealthThreshold, (byte)(flag ? 1u : 0u));
		return flag;
	}

	private void TickBehaviourState()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (GetFact(Facts.WantsToFlee) == 1 && IsNavRunning() && (int)NavAgent.pathStatus == 0 && Time.realtimeSinceStartup - (maxFleeTime - Stats.MaxFleeTime) > 0.5f)
		{
			TickFlee();
		}
		if (GetFact(Facts.CanTargetEnemies) == 0)
		{
			TickBlockEnemyTargeting();
		}
		if (GetFact(Facts.CanTargetFood) == 0)
		{
			TickBlockFoodTargeting();
		}
		if (GetFact(Facts.IsAggro) == 1)
		{
			TickAggro();
		}
		if (GetFact(Facts.IsEating) == 1)
		{
			TickEating();
		}
		if (GetFact(Facts.CanNotMove) == 1)
		{
			TickWakeUpBlockMove();
		}
	}

	private void WantsToFlee()
	{
		if (GetFact(Facts.WantsToFlee) != 1 && IsNavRunning())
		{
			SetFact(Facts.WantsToFlee, 1);
			maxFleeTime = Time.realtimeSinceStartup + Stats.MaxFleeTime;
		}
	}

	private void TickFlee()
	{
	}

	public bool BlockEnemyTargeting(float timeout)
	{
		if (GetFact(Facts.CanTargetEnemies) == 0)
		{
			return false;
		}
		SetFact(Facts.CanTargetEnemies, 0);
		blockEnemyTargetingTimeout = Time.realtimeSinceStartup + timeout;
		blockTargetingThisEnemy = AttackTarget;
		return true;
	}

	private void TickBlockEnemyTargeting()
	{
		if (GetFact(Facts.CanTargetEnemies) != 1 && Time.realtimeSinceStartup > blockEnemyTargetingTimeout)
		{
			SetFact(Facts.CanTargetEnemies, 1);
		}
	}

	public bool BlockFoodTargeting(float timeout)
	{
		if (GetFact(Facts.CanTargetFood) == 0)
		{
			return false;
		}
		SetFact(Facts.CanTargetFood, 0);
		blockFoodTargetingTimeout = Time.realtimeSinceStartup + timeout;
		return true;
	}

	private void TickBlockFoodTargeting()
	{
		if (GetFact(Facts.CanTargetFood) != 1 && Time.realtimeSinceStartup > blockFoodTargetingTimeout)
		{
			SetFact(Facts.CanTargetFood, 1);
		}
	}

	public bool TryAggro(EnemyRangeEnum range)
	{
		if (Mathf.Approximately(Stats.Hostility, 0f) && Mathf.Approximately(Stats.Defensiveness, 0f))
		{
			return false;
		}
		if (GetFact(Facts.IsAggro) == 0 && (range == EnemyRangeEnum.AggroRange || range == EnemyRangeEnum.AttackRange))
		{
			float num = ((range == EnemyRangeEnum.AttackRange) ? 1f : Stats.Defensiveness);
			num = Mathf.Max(num, Stats.Hostility);
			if (Time.realtimeSinceStartup > lastAggroChanceCalcTime + 5f)
			{
				lastAggroChanceResult = Random.value;
				lastAggroChanceCalcTime = Time.realtimeSinceStartup;
			}
			if (lastAggroChanceResult < num)
			{
				return StartAggro(Stats.DeaggroChaseTime);
			}
		}
		return false;
	}

	public bool StartAggro(float timeout)
	{
		if (GetFact(Facts.IsAggro) == 1)
		{
			return false;
		}
		SetFact(Facts.IsAggro, 1);
		aggroTimeout = Time.realtimeSinceStartup + timeout;
		return true;
	}

	private void TickAggro()
	{
	}

	public bool StartEating(float timeout)
	{
		if (GetFact(Facts.IsEating) == 1)
		{
			return false;
		}
		SetFact(Facts.IsEating, 1);
		eatTimeout = Time.realtimeSinceStartup + timeout;
		return true;
	}

	private void TickEating()
	{
		if (GetFact(Facts.IsEating) != 0 && Time.realtimeSinceStartup > eatTimeout)
		{
			SetFact(Facts.IsEating, 0);
		}
	}

	public bool WakeUpBlockMove(float timeout)
	{
		if (GetFact(Facts.CanNotMove) == 1)
		{
			return false;
		}
		SetFact(Facts.CanNotMove, 1);
		wakeUpBlockMoveTimeout = Time.realtimeSinceStartup + timeout;
		return true;
	}

	private void TickWakeUpBlockMove()
	{
		if (GetFact(Facts.CanNotMove) != 0 && Time.realtimeSinceStartup > wakeUpBlockMoveTimeout)
		{
			SetFact(Facts.CanNotMove, 0);
		}
	}

	private void OnFactChanged(Facts fact, byte oldValue, byte newValue)
	{
		switch (fact)
		{
		case Facts.IsSleeping:
			if (newValue > 0)
			{
				CurrentBehaviour = Behaviour.Sleep;
				SetFact(Facts.CanTargetEnemies, 0, triggerCallback: false);
				SetFact(Facts.CanTargetFood, 0);
			}
			else
			{
				CurrentBehaviour = Behaviour.Idle;
				SetFact(Facts.CanTargetEnemies, 1);
				SetFact(Facts.CanTargetFood, 1);
				WakeUpBlockMove(Stats.WakeupBlockMoveTime);
				TickSenses();
			}
			break;
		case Facts.IsAggro:
			if (newValue > 0)
			{
				CurrentBehaviour = Behaviour.Attack;
			}
			else
			{
				BlockEnemyTargeting(Stats.DeaggroCooldown);
			}
			break;
		case Facts.FoodRange:
			if (newValue == 0)
			{
				CurrentBehaviour = Behaviour.Eat;
			}
			break;
		case Facts.Speed:
			switch ((SpeedEnum)newValue)
			{
			case SpeedEnum.StandStill:
				StopMoving();
				CurrentBehaviour = Behaviour.Idle;
				break;
			case SpeedEnum.Walk:
				IsStopped = false;
				CurrentBehaviour = Behaviour.Wander;
				break;
			default:
				IsStopped = false;
				break;
			}
			break;
		case Facts.IsEating:
			if (newValue == 0)
			{
				FoodTarget = null;
			}
			break;
		case Facts.CanTargetEnemies:
			if (newValue == 1)
			{
				blockTargetingThisEnemy = null;
			}
			break;
		}
	}

	public int TopologyPreference()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected I4, but got Unknown
		return (int)topologyPreference;
	}

	public void UpdateDestination(Vector3 position)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (IsStopped)
		{
			IsStopped = false;
		}
		Vector3 val = Destination - position;
		if (((Vector3)(ref val)).sqrMagnitude > 0.010000001f)
		{
			Destination = position;
		}
		ChaseTransform = null;
	}

	public void UpdateDestination(Transform tx)
	{
		IsStopped = false;
		ChaseTransform = tx;
	}

	public void StopMoving()
	{
		IsStopped = true;
		ChaseTransform = null;
		SetFact(Facts.PathToTargetStatus, 0);
	}

	public override void ApplyInheritedVelocity(Vector3 velocity)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		ServerPosition = GetNewNavPosWithVelocity(this, velocity);
	}

	public static Vector3 GetNewNavPosWithVelocity(BaseEntity ent, Vector3 velocity)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = ent.GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			velocity = ((Component)baseEntity).transform.InverseTransformDirection(velocity);
		}
		Vector3 val = ent.ServerPosition + velocity * Time.fixedDeltaTime;
		NavMeshHit val2 = default(NavMeshHit);
		NavMesh.Raycast(ent.ServerPosition, val, ref val2, -1);
		if (!Vector3Ex.IsNaNOrInfinity(((NavMeshHit)(ref val2)).position))
		{
			return ((NavMeshHit)(ref val2)).position;
		}
		return ent.ServerPosition;
	}

	public bool IsNavRunning()
	{
		if ((Object)(object)GetNavAgent != (Object)null && ((Behaviour)GetNavAgent).enabled)
		{
			return GetNavAgent.isOnNavMesh;
		}
		return false;
	}

	public void Pause()
	{
		if ((Object)(object)GetNavAgent != (Object)null && ((Behaviour)GetNavAgent).enabled)
		{
			((Behaviour)GetNavAgent).enabled = false;
		}
	}

	public void Resume()
	{
		if (!GetNavAgent.isOnNavMesh)
		{
			((MonoBehaviour)this).StartCoroutine(TryForceToNavmesh());
		}
		else
		{
			((Behaviour)GetNavAgent).enabled = true;
		}
	}

	private IEnumerator TryForceToNavmesh()
	{
		yield return null;
		int numTries = 0;
		float waitForRetryTime = 1f;
		float maxDistanceMultiplier = 2f;
		if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance != (Object)null)
		{
			while (SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
			{
				yield return CoroutineEx.waitForSecondsRealtime(waitForRetryTime);
				waitForRetryTime += 0.5f;
			}
		}
		waitForRetryTime = 1f;
		NavMeshHit val = default(NavMeshHit);
		for (; numTries < 4; numTries++)
		{
			if (!GetNavAgent.isOnNavMesh)
			{
				if (NavMesh.SamplePosition(ServerPosition, ref val, GetNavAgent.height * maxDistanceMultiplier, GetNavAgent.areaMask))
				{
					ServerPosition = ((NavMeshHit)(ref val)).position;
					GetNavAgent.Warp(ServerPosition);
					((Behaviour)GetNavAgent).enabled = true;
					yield break;
				}
				yield return CoroutineEx.waitForSecondsRealtime(waitForRetryTime);
				maxDistanceMultiplier *= 1.5f;
				waitForRetryTime *= 1.5f;
				continue;
			}
			((Behaviour)GetNavAgent).enabled = true;
			yield break;
		}
		Debug.LogWarningFormat("Failed to spawn {0} on a valid navmesh.", new object[1] { ((Object)this).name });
		DieInstantly();
	}

	public float GetWantsToAttack(BaseEntity target)
	{
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)target);
		if (obj is float)
		{
			return (float)obj;
		}
		return WantsToAttack(target);
	}

	public bool BusyTimerActive()
	{
		return BusyTimer.IsActive;
	}

	public void SetBusyFor(float dur)
	{
		BusyTimer.Activate(dur);
	}

	internal float WantsToAttack(BaseEntity target)
	{
		if ((Object)(object)target == (Object)null)
		{
			return 0f;
		}
		if (CurrentBehaviour == Behaviour.Sleep)
		{
			return 0f;
		}
		if (!target.HasAnyTrait(TraitFlag.Animal | TraitFlag.Human))
		{
			return 0f;
		}
		if (((object)target).GetType() == ((object)this).GetType())
		{
			return 1f - Stats.Tolerance;
		}
		return 1f;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseNPC = Pool.Get<BaseNPC>();
		info.msg.baseNPC.flags = (int)aiFlags;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.baseNPC != null)
		{
			aiFlags = (AiFlags)info.msg.baseNPC.flags;
		}
	}

	public override float MaxVelocity()
	{
		return Stats.Speed;
	}

	public bool HasAiFlag(AiFlags f)
	{
		return (aiFlags & f) == f;
	}

	public void SetAiFlag(AiFlags f, bool set)
	{
		AiFlags num = aiFlags;
		if (set)
		{
			aiFlags |= f;
		}
		else
		{
			aiFlags &= ~f;
		}
		if (num != aiFlags && base.isServer)
		{
			SendNetworkUpdate();
		}
	}

	public void InitFacts()
	{
		SetFact(Facts.CanTargetEnemies, 1);
		SetFact(Facts.CanTargetFood, 1);
	}

	public byte GetFact(Facts fact)
	{
		return CurrentFacts[(int)fact];
	}

	public void SetFact(Facts fact, byte value, bool triggerCallback = true, bool onlyTriggerCallbackOnDiffValue = true)
	{
		byte b = CurrentFacts[(int)fact];
		CurrentFacts[(int)fact] = value;
		if (triggerCallback && value != b)
		{
			OnFactChanged(fact, b, value);
		}
	}

	public EnemyRangeEnum ToEnemyRangeEnum(float range)
	{
		if (range <= AttackRange)
		{
			return EnemyRangeEnum.AttackRange;
		}
		if (range <= Stats.AggressionRange)
		{
			return EnemyRangeEnum.AggroRange;
		}
		if (range >= Stats.DeaggroRange && GetFact(Facts.IsAggro) > 0)
		{
			return EnemyRangeEnum.OutOfRange;
		}
		if (range <= Stats.VisionRange)
		{
			return EnemyRangeEnum.AwareRange;
		}
		return EnemyRangeEnum.OutOfRange;
	}

	public float GetActiveAggressionRangeSqr()
	{
		if (GetFact(Facts.IsAggro) == 1)
		{
			return Stats.DeaggroRange * Stats.DeaggroRange;
		}
		return Stats.AggressionRange * Stats.AggressionRange;
	}

	public FoodRangeEnum ToFoodRangeEnum(float range)
	{
		if (range <= 0.5f)
		{
			return FoodRangeEnum.EatRange;
		}
		if (range <= Stats.VisionRange)
		{
			return FoodRangeEnum.AwareRange;
		}
		return FoodRangeEnum.OutOfRange;
	}

	public AfraidRangeEnum ToAfraidRangeEnum(float range)
	{
		if (range <= Stats.AfraidRange)
		{
			return AfraidRangeEnum.InAfraidRange;
		}
		return AfraidRangeEnum.OutOfRange;
	}

	public HealthEnum ToHealthEnum(float healthNormalized)
	{
		if (healthNormalized >= 0.75f)
		{
			return HealthEnum.Fine;
		}
		if (healthNormalized >= 0.25f)
		{
			return HealthEnum.Medium;
		}
		return HealthEnum.Low;
	}

	public byte ToIsTired(float energyNormalized)
	{
		bool flag = GetFact(Facts.IsSleeping) == 1;
		if (!flag && energyNormalized < 0.1f)
		{
			return 1;
		}
		if (flag && energyNormalized < 0.5f)
		{
			return 1;
		}
		return 0;
	}

	public SpeedEnum ToSpeedEnum(float speed)
	{
		if (speed <= 0.01f)
		{
			return SpeedEnum.StandStill;
		}
		if (speed <= 0.18f)
		{
			return SpeedEnum.Walk;
		}
		return SpeedEnum.Run;
	}

	public float ToSpeed(SpeedEnum speed)
	{
		return speed switch
		{
			SpeedEnum.StandStill => 0f, 
			SpeedEnum.Walk => 0.18f * Stats.Speed, 
			_ => Stats.Speed, 
		};
	}

	public byte GetPathStatus()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!IsNavRunning())
		{
			return 2;
		}
		return (byte)NavAgent.pathStatus;
	}

	public NavMeshPathStatus ToPathStatus(byte value)
	{
		return (NavMeshPathStatus)value;
	}

	private void TickSenses()
	{
		if (Query.Server != null && !IsDormant)
		{
			if (Time.realtimeSinceStartup > lastTickTime + SensesTickRate)
			{
				TickHearing();
				TickSmell();
				lastTickTime = Time.realtimeSinceStartup;
			}
			if (!AI.animal_ignore_food)
			{
				TickFoodAwareness();
			}
			UpdateSelfFacts();
		}
	}

	private void TickHearing()
	{
		SetFact(Facts.LoudNoiseNearby, 0);
	}

	private void TickSmell()
	{
	}

	private float DecisionMomentumPlayerTarget()
	{
		float num = Time.time - playerTargetDecisionStartTime;
		if (num > 1f)
		{
			return 0f;
		}
		return num;
	}

	private float DecisionMomentumAnimalTarget()
	{
		float num = Time.time - animalTargetDecisionStartTime;
		if (num > 1f)
		{
			return 0f;
		}
		return num;
	}

	private void TickFoodAwareness()
	{
		if (GetFact(Facts.CanTargetFood) == 0)
		{
			FoodTarget = null;
			SetFact(Facts.FoodRange, 2);
		}
		else
		{
			SelectFood();
		}
	}

	private void SelectFood()
	{
	}

	private void SelectClosestFood()
	{
	}

	private void UpdateSelfFacts()
	{
	}

	private byte IsMoving()
	{
		return (byte)((IsNavRunning() && NavAgent.hasPath && NavAgent.remainingDistance > NavAgent.stoppingDistance && !IsStuck && GetFact(Facts.Speed) != 0) ? 1u : 0u);
	}

	private static bool AiCaresAbout(BaseEntity ent)
	{
		if (ent is BasePlayer)
		{
			return true;
		}
		if (ent is BaseNpc)
		{
			return true;
		}
		if (!AI.animal_ignore_food)
		{
			if (ent is WorldItem)
			{
				return true;
			}
			if (ent is BaseCorpse)
			{
				return true;
			}
			if (ent is CollectibleEntity)
			{
				return true;
			}
		}
		return false;
	}

	private static bool WithinVisionCone(BaseNpc npc, BaseEntity other)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (Mathf.Approximately(npc.Stats.VisionCone, -1f))
		{
			return true;
		}
		Vector3 val = other.ServerPosition - npc.ServerPosition;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		if (Vector3.Dot(((Component)npc).transform.forward, normalized) < npc.Stats.VisionCone)
		{
			return false;
		}
		return true;
	}

	public void SetTargetPathStatus(float pendingDelay = 0.05f)
	{
		if (!isAlreadyCheckingPathPending)
		{
			if (NavAgent.pathPending && numPathPendingAttempts < 10)
			{
				isAlreadyCheckingPathPending = true;
				((FacepunchBehaviour)this).Invoke((Action)DelayedTargetPathStatus, pendingDelay);
			}
			else
			{
				numPathPendingAttempts = 0;
				accumPathPendingDelay = 0f;
				SetFact(Facts.PathToTargetStatus, GetPathStatus());
			}
		}
	}

	private void DelayedTargetPathStatus()
	{
		accumPathPendingDelay += 0.1f;
		isAlreadyCheckingPathPending = false;
		SetTargetPathStatus(accumPathPendingDelay);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if ((Object)(object)NavAgent == (Object)null)
		{
			NavAgent = ((Component)this).GetComponent<NavMeshAgent>();
		}
		if ((Object)(object)NavAgent != (Object)null)
		{
			NavAgent.updateRotation = false;
			NavAgent.updatePosition = false;
			if (!LegacyNavigation)
			{
				((Component)((Component)this).transform).gameObject.GetComponent<BaseNavigator>().Init(this, NavAgent);
			}
		}
		IsStuck = false;
		AgencyUpdateRequired = false;
		IsOnOffmeshLinkAndReachedNewCoord = false;
		((FacepunchBehaviour)this).InvokeRandomized((Action)TickAi, 0.1f, 0.1f, 0.0050000004f);
		Sleep = Random.Range(0.5f, 1f);
		Stamina.Level = Random.Range(0.1f, 1f);
		Energy.Level = Random.Range(0.5f, 1f);
		Hydration.Level = Random.Range(0.5f, 1f);
		if (NewAI)
		{
			InitFacts();
			fleeHealthThresholdPercentage = Stats.HealthThresholdForFleeing;
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
	}

	public override void Hurt(HitInfo info)
	{
		base.Hurt(info);
	}

	public override void OnDied(HitInfo hitInfo = null)
	{
		Assert.IsTrue(base.isServer, "OnDied called on client!");
		BaseCorpse baseCorpse = DropCorpse(CorpsePrefab.resourcePath);
		if (Object.op_Implicit((Object)(object)baseCorpse))
		{
			baseCorpse.Spawn();
			baseCorpse.TakeChildren(this);
		}
		((FacepunchBehaviour)this).Invoke((Action)base.KillMessage, 0.5f);
	}
}


public enum Behaviour
{
	Idle,
	Wander,
	Attack,
	Flee,
	Eat,
	Sleep,
	RetreatingToCover
}


using System;

[Flags]
public enum AiFlags
{
	Sitting = 2,
	Chasing = 4,
	Sleeping = 8
}


public enum Facts
{
	HasEnemy,
	EnemyRange,
	CanTargetEnemies,
	Health,
	Speed,
	IsTired,
	IsSleeping,
	IsAttackReady,
	IsRoamReady,
	IsAggro,
	WantsToFlee,
	IsHungry,
	FoodRange,
	AttackedLately,
	LoudNoiseNearby,
	CanTargetFood,
	IsMoving,
	IsFleeing,
	IsEating,
	IsAfraid,
	AfraidRange,
	IsUnderHealthThreshold,
	CanNotMove,
	PathToTargetStatus
}


public enum EnemyRangeEnum : byte
{
	AttackRange,
	AggroRange,
	AwareRange,
	OutOfRange
}


public enum FoodRangeEnum : byte
{
	EatRange,
	AwareRange,
	OutOfRange
}


public enum AfraidRangeEnum : byte
{
	InAfraidRange,
	OutOfRange
}


public enum HealthEnum : byte
{
	Fine,
	Medium,
	Low
}


public enum SpeedEnum : byte
{
	StandStill,
	Walk,
	Run
}


using System;
using UnityEngine;

[Serializable]
public struct AiStatistics
{
	public enum FamilyEnum
	{
		Bear,
		Wolf,
		Deer,
		Boar,
		Chicken,
		Horse,
		Zombie,
		Scientist,
		Murderer,
		Player
	}

	[Range(0f, 1f)]
	[Tooltip("Ai will be less likely to fight animals that are larger than them, and more likely to flee from them.")]
	public float Size;

	[Tooltip("How fast we can move")]
	public float Speed;

	[Tooltip("How fast can we accelerate")]
	public float Acceleration;

	[Tooltip("How fast can we turn around")]
	public float TurnSpeed;

	[Tooltip("Determines things like how near we'll allow other species to get")]
	[Range(0f, 1f)]
	public float Tolerance;

	[Tooltip("How far this NPC can see")]
	public float VisionRange;

	[Tooltip("Our vision cone for dot product - a value of -1 means we can see all around us, 0 = only infront ")]
	public float VisionCone;

	[Tooltip("NPCs use distance visibility to basically make closer enemies easier to detect than enemies further away")]
	public AnimationCurve DistanceVisibility;

	[Tooltip("How likely are we to be offensive without being threatened")]
	public float Hostility;

	[Tooltip("How likely are we to defend ourselves when attacked")]
	public float Defensiveness;

	[Tooltip("The range at which we will engage targets")]
	public float AggressionRange;

	[Tooltip("The range at which an aggrified npc will disengage it's current target")]
	public float DeaggroRange;

	[Tooltip("For how long will we chase a target until we give up")]
	public float DeaggroChaseTime;

	[Tooltip("When we deaggro, how long do we wait until we can aggro again.")]
	public float DeaggroCooldown;

	[Tooltip("The threshold of our health fraction where there's a chance that we want to flee")]
	public float HealthThresholdForFleeing;

	[Tooltip("The chance that we will flee when our health threshold is triggered")]
	public float HealthThresholdFleeChance;

	[Tooltip("When we flee, what is the minimum distance we should flee?")]
	public float MinFleeRange;

	[Tooltip("When we flee, what is the maximum distance we should flee?")]
	public float MaxFleeRange;

	[Tooltip("When we flee, what is the maximum time that can pass until we stop?")]
	public float MaxFleeTime;

	[Tooltip("At what range we are afraid of a target that is in our Is Afraid Of list.")]
	public float AfraidRange;

	[Tooltip("The family this npc belong to. Npcs in the same family will not attack each other.")]
	public FamilyEnum Family;

	[Tooltip("List of the types of Npc that we are afraid of.")]
	public FamilyEnum[] IsAfraidOf;

	[Tooltip("The minimum distance this npc will wander when idle.")]
	public float MinRoamRange;

	[Tooltip("The maximum distance this npc will wander when idle.")]
	public float MaxRoamRange;

	[Tooltip("The minimum amount of time between each time we seek a new roam destination (when idle)")]
	public float MinRoamDelay;

	[Tooltip("The maximum amount of time between each time we seek a new roam destination (when idle)")]
	public float MaxRoamDelay;

	[Tooltip("If an npc is mobile, they are allowed to move when idle.")]
	public bool IsMobile;

	[Tooltip("In the range between min and max roam delay, we evaluate the random value through this curve")]
	public AnimationCurve RoamDelayDistribution;

	[Tooltip("For how long do we remember that someone attacked us")]
	public float AttackedMemoryTime;

	[Tooltip("How long should we block movement to make the wakeup animation not look whack?")]
	public float WakeupBlockMoveTime;

	[Tooltip("The maximum water depth this npc willingly will walk into.")]
	public float MaxWaterDepth;

	[Tooltip("The water depth at which they will start swimming.")]
	public float WaterLevelNeck;

	public float WaterLevelNeckOffset;

	[Tooltip("The range we consider using close range weapons.")]
	public float CloseRange;

	[Tooltip("The range we consider using medium range weapons.")]
	public float MediumRange;

	[Tooltip("The range we consider using long range weapons.")]
	public float LongRange;

	[Tooltip("How long can we be out of range of our spawn point before we time out and make our way back home (when idle).")]
	public float OutOfRangeOfSpawnPointTimeout;

	[Tooltip("If this is set to true, then a target must hold special markers (like IsHostile) for the target to be considered for aggressive action.")]
	public bool OnlyAggroMarkedTargets;
}


public enum FamilyEnum
{
	Bear,
	Wolf,
	Deer,
	Boar,
	Chicken,
	Horse,
	Zombie,
	Scientist,
	Murderer,
	Player
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Assertions;
using UnityEngine.Serialization;

public class BaseOven : StorageContainer, ISplashable, IIndustrialStorage, IAlwaysOn
{
	public enum TemperatureType
	{
		Normal,
		Warming,
		Cooking,
		Smelting,
		Fractioning
	}

	public enum IndustrialSlotMode
	{
		Furnace,
		LargeFurnace,
		OilRefinery,
		ElectricFurnace
	}

	public struct MinMax
	{
		public int Min;

		public int Max;

		public MinMax(int min, int max)
		{
			Min = min;
			Max = max;
		}
	}

	public enum OvenItemType
	{
		Burnable,
		Byproduct,
		MaterialInput,
		MaterialOutput
	}

	public class CookingItem
	{
		public ItemId itemInstanceID;

		public int slotIndex;

		public float cookingProgress;

		public int itemID;

		public int byproductItemID;

		public int initialStackSize;
	}

	private static Dictionary<float, HashSet<ItemDefinition>> _materialOutputCache;

	[Header("Base Oven Settings")]
	public TemperatureType temperature;

	public Menu.Option switchOnMenu;

	public Menu.Option switchOffMenu;

	public ItemAmount[] startupContents;

	public bool allowByproductCreation = true;

	public ItemDefinition fuelType;

	[FormerlySerializedAs("canModFire")]
	public bool hasFireDeploySlot;

	public bool hasOpenFlame;

	public bool disabledBySplash = true;

	public int smeltSpeed = 1;

	public int fuelSlots = 1;

	public int inputSlots = 1;

	public int outputSlots = 1;

	public IndustrialSlotMode IndustrialMode;

	public const Flags Flag_CookingPaused = Flags.Reserved8;

	public const Flags AlwaysOn = Flags.Reserved9;

	public int _activeCookingSlot = -1;

	public int _inputSlotIndex;

	public int _outputSlotIndex;

	public const float UpdateRate = 0.5f;

	private List<CookingItem> cookingItems = new List<CookingItem>();

	public bool visualFood;

	public SoundDefinition sizzlingSoundDef;

	private Sound sizzlingSound;

	public virtual bool CanRunWithNoFuel
	{
		get
		{
			if (IsAlwaysOn())
			{
				return true;
			}
			return false;
		}
	}

	public ItemContainer Container => base.inventory;

	public BaseEntity IndustrialEntity => this;

	public float cookingTemperature => temperature switch
	{
		TemperatureType.Fractioning => 1500f, 
		TemperatureType.Cooking => 200f, 
		TemperatureType.Smelting => 1000f, 
		TemperatureType.Warming => 50f, 
		_ => 15f, 
	};

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("BaseOven.OnRpcMessage", 0);
		try
		{
			if (rpc == 4167839872u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - SVSwitch "));
				}
				TimeWarning val2 = TimeWarning.New("SVSwitch", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.MaxDistance.Test(4167839872u, "SVSwitch", this, player, 3f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							SVSwitch(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in SVSwitch");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		_inputSlotIndex = fuelSlots;
		_outputSlotIndex = _inputSlotIndex + inputSlots;
		_activeCookingSlot = _inputSlotIndex;
	}

	public override void ServerInit()
	{
		inventorySlots = fuelSlots + inputSlots + outputSlots;
		base.ServerInit();
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (IsOn())
		{
			StartCooking();
		}
	}

	public override void OnInventoryFirstCreated(ItemContainer container)
	{
		base.OnInventoryFirstCreated(container);
		if (startupContents != null)
		{
			ItemAmount[] array = startupContents;
			foreach (ItemAmount itemAmount in array)
			{
				ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL).MoveToContainer(container);
			}
		}
	}

	public override void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		base.OnItemAddedOrRemoved(item, bAdded);
		if (item != null)
		{
			ItemModCookable itemModCookable = item.info.ItemModCookable;
			if ((Object)(object)itemModCookable != (Object)null)
			{
				item.cookTimeLeft = itemModCookable.cookTime;
			}
			if (item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: false);
				item.MarkDirty();
			}
			if (item.HasFlag(Item.Flag.Cooking))
			{
				item.SetFlag(Item.Flag.Cooking, b: false);
				item.MarkDirty();
			}
		}
		if (visualFood)
		{
			OnItemAddedOrRemovedVisualFood(item, bAdded);
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		if (targetSlot == -1)
		{
			return false;
		}
		if (IsOutputItem(item) && (Object)(object)item.GetEntityOwner() != (Object)(object)this)
		{
			BaseEntity entityOwner = item.GetEntityOwner();
			if ((Object)(object)entityOwner != (Object)(object)this && (Object)(object)entityOwner != (Object)null)
			{
				return false;
			}
		}
		MinMax? allowedSlots = GetAllowedSlots(item);
		if (!allowedSlots.HasValue)
		{
			return false;
		}
		if (targetSlot >= allowedSlots.Value.Min)
		{
			return targetSlot <= allowedSlots.Value.Max;
		}
		return false;
	}

	public MinMax? GetAllowedSlots(Item item)
	{
		int num = 0;
		int num2 = 0;
		if (IsBurnableItem(item))
		{
			num2 = fuelSlots;
		}
		else if (IsOutputItem(item))
		{
			num = _outputSlotIndex;
			num2 = num + outputSlots;
		}
		else
		{
			if (!IsMaterialInput(item))
			{
				return null;
			}
			num = _inputSlotIndex;
			num2 = num + inputSlots;
		}
		return new MinMax(num, num2 - 1);
	}

	public MinMax GetOutputSlotRange()
	{
		return new MinMax(_outputSlotIndex, _outputSlotIndex + outputSlots - 1);
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		MinMax? allowedSlots = GetAllowedSlots(item);
		if (!allowedSlots.HasValue)
		{
			return -1;
		}
		for (int i = allowedSlots.Value.Min; i <= allowedSlots.Value.Max; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null || (slot.CanStack(item) && slot.amount < slot.MaxStackable()))
			{
				return i;
			}
		}
		return base.GetIdealSlot(player, container, item);
	}

	public virtual void OvenFull()
	{
		StopCooking();
	}

	public int GetFuelRate()
	{
		return 1;
	}

	public int GetCharcoalRate()
	{
		return 1;
	}

	public void Cook()
	{
		if (HasFlag(Flags.Reserved8))
		{
			return;
		}
		Item item = FindBurnable();
		if (Interface.CallHook("OnOvenCook", (object)this, (object)item) != null)
		{
			return;
		}
		if (item == null && !CanRunWithNoFuel)
		{
			StopCooking();
			return;
		}
		foreach (Item item2 in base.inventory.itemList)
		{
			if (item2.position >= _inputSlotIndex && item2.position < _inputSlotIndex + inputSlots && !item2.HasFlag(Item.Flag.Cooking))
			{
				item2.SetFlag(Item.Flag.Cooking, b: true);
				item2.MarkDirty();
			}
		}
		IncreaseCookTime(0.5f * GetSmeltingSpeed());
		BaseEntity slot = GetSlot(Slot.FireMod);
		if (Object.op_Implicit((Object)(object)slot))
		{
			((Component)slot).SendMessage("Cook", (object)0.5f, (SendMessageOptions)1);
		}
		if (item != null)
		{
			ItemModBurnable itemModBurnable = item.info.ItemModBurnable;
			item.fuel -= 0.5f * (cookingTemperature / 200f);
			if (!item.HasFlag(Item.Flag.OnFire))
			{
				item.SetFlag(Item.Flag.OnFire, b: true);
				item.MarkDirty();
			}
			if (item.fuel <= 0f)
			{
				ConsumeFuel(item, itemModBurnable);
			}
		}
		OnCooked();
		Interface.CallHook("OnOvenCooked", (object)this, (object)item, (object)slot);
	}

	protected virtual void OnCooked()
	{
	}

	public void ConsumeFuel(Item fuel, ItemModBurnable burnable)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnFuelConsume", (object)this, (object)fuel, (object)burnable) != null)
		{
			return;
		}
		if (allowByproductCreation && (Object)(object)burnable.byproductItem != (Object)null && Random.Range(0f, 1f) > burnable.byproductChance)
		{
			Item item = ItemManager.Create(burnable.byproductItem, burnable.byproductAmount * GetCharcoalRate(), 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				OvenFull();
				item.Drop(base.inventory.dropPosition, base.inventory.dropVelocity);
			}
		}
		if (fuel.amount <= GetFuelRate())
		{
			fuel.Remove();
			return;
		}
		int fuelRate = GetFuelRate();
		fuel.UseItem(fuelRate);
		Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, "smelt");
		fuel.fuel = burnable.fuelAmount;
		fuel.MarkDirty();
		Interface.CallHook("OnFuelConsumed", (object)this, (object)fuel, (object)burnable);
	}

	[RPC_Server]
	[RPC_Server.MaxDistance(3f)]
	protected virtual void SVSwitch(RPCMessage msg)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		bool flag = msg.read.Bit();
		if (Interface.CallHook("OnOvenToggle", (object)this, (object)msg.player) != null || flag == IsOn() || (needsBuildingPrivilegeToUse && !msg.player.CanBuild()))
		{
			return;
		}
		if (flag)
		{
			StartCooking();
			if ((Object)(object)msg.player != (Object)null)
			{
				msg.player.ProcessMissionEvent(BaseMission.MissionEventType.STARTOVEN, new BaseMission.MissionEventPayload
				{
					UintIdentifier = prefabID,
					NetworkIdentifier = net.ID
				}, 1f);
			}
		}
		else
		{
			StopCooking();
		}
	}

	public float GetTemperature(int slot)
	{
		object obj = Interface.CallHook("OnOvenTemperature", (object)this, (object)slot);
		if (obj is float)
		{
			return (float)obj;
		}
		if (!HasFlag(Flags.On))
		{
			return 15f;
		}
		return cookingTemperature;
	}

	public void UpdateAttachmentTemperature()
	{
		BaseEntity slot = GetSlot(Slot.FireMod);
		if (Object.op_Implicit((Object)(object)slot))
		{
			((Component)slot).SendMessage("ParentTemperatureUpdate", (object)base.inventory.temperature, (SendMessageOptions)1);
		}
	}

	public virtual void StartCooking()
	{
		if (Interface.CallHook("OnOvenStart", (object)this) == null && (FindBurnable() != null || CanRunWithNoFuel))
		{
			base.inventory.temperature = cookingTemperature;
			UpdateAttachmentTemperature();
			((FacepunchBehaviour)this).InvokeRepeating((Action)Cook, 0.5f, 0.5f);
			if (visualFood)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CookVisuals, 0f, 0.05f);
			}
			SetFlag(Flags.On, b: true);
			Interface.CallHook("OnOvenStarted", (object)this);
			if (hasOpenFlame)
			{
				SingletonComponent<NpcFireManager>.Instance.Add(this);
			}
		}
	}

	public virtual void StopCooking()
	{
		UpdateAttachmentTemperature();
		if (base.inventory != null)
		{
			base.inventory.temperature = 15f;
			foreach (Item item in base.inventory.itemList)
			{
				if (item.HasFlag(Item.Flag.OnFire))
				{
					item.SetFlag(Item.Flag.OnFire, b: false);
					item.MarkDirty();
				}
				else if (item.HasFlag(Item.Flag.Cooking))
				{
					item.SetFlag(Item.Flag.Cooking, b: false);
					item.MarkDirty();
				}
			}
		}
		((FacepunchBehaviour)this).CancelInvoke((Action)Cook);
		((FacepunchBehaviour)this).CancelInvoke((Action)CookVisuals);
		SetFlag(Flags.On, b: false);
		if (hasOpenFlame)
		{
			SingletonComponent<NpcFireManager>.Instance.Remove(this);
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		if (!base.IsDestroyed && IsOn())
		{
			return disabledBySplash;
		}
		return false;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		StopCooking();
		return Mathf.Min(200, amount);
	}

	public Item FindBurnable()
	{
		object obj = Interface.CallHook("OnFindBurnable", (object)this);
		if (obj is Item)
		{
			return (Item)obj;
		}
		if (base.inventory == null)
		{
			return null;
		}
		foreach (Item item in base.inventory.itemList)
		{
			if (IsBurnableItem(item))
			{
				return item;
			}
		}
		return null;
	}

	public void IncreaseCookTime(float amount)
	{
		List<Item> list = Pool.Get<List<Item>>();
		foreach (Item item in base.inventory.itemList)
		{
			if (item.HasFlag(Item.Flag.Cooking))
			{
				list.Add(item);
			}
		}
		float delta = amount / (float)list.Count;
		foreach (Item item2 in list)
		{
			item2.OnCycle(delta);
		}
		Pool.Free<Item>(ref list, false);
	}

	public Vector2i InputSlotRange(int slotIndex)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (IndustrialMode == IndustrialSlotMode.LargeFurnace)
		{
			return new Vector2i(0, 6);
		}
		if (IndustrialMode == IndustrialSlotMode.OilRefinery)
		{
			return new Vector2i(0, 1);
		}
		if (IndustrialMode == IndustrialSlotMode.ElectricFurnace)
		{
			return new Vector2i(0, 1);
		}
		return new Vector2i(0, 2);
	}

	public Vector2i OutputSlotRange(int slotIndex)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (IndustrialMode == IndustrialSlotMode.LargeFurnace)
		{
			return new Vector2i(7, 16);
		}
		if (IndustrialMode == IndustrialSlotMode.OilRefinery)
		{
			return new Vector2i(2, 4);
		}
		if (IndustrialMode == IndustrialSlotMode.ElectricFurnace)
		{
			return new Vector2i(2, 4);
		}
		return new Vector2i(3, 5);
	}

	public void OnStorageItemTransferBegin()
	{
	}

	public void OnStorageItemTransferEnd()
	{
	}

	public float GetSmeltingSpeed()
	{
		if (base.isServer)
		{
			return smeltSpeed;
		}
		throw new Exception("No way it should be able to get here?");
	}

	public bool IsBurnableItem(Item item)
	{
		if (Object.op_Implicit((Object)(object)item.info.ItemModBurnable) && ((Object)(object)fuelType == (Object)null || (Object)(object)item.info == (Object)(object)fuelType))
		{
			return true;
		}
		return false;
	}

	public bool IsBurnableByproduct(Item item)
	{
		ItemModBurnable itemModBurnable = fuelType?.ItemModBurnable;
		if ((Object)(object)itemModBurnable == (Object)null)
		{
			return false;
		}
		return (Object)(object)item.info == (Object)(object)itemModBurnable.byproductItem;
	}

	public bool IsMaterialInput(Item item)
	{
		ItemModCookable itemModCookable = item.info.ItemModCookable;
		if ((Object)(object)itemModCookable == (Object)null || (float)itemModCookable.lowTemp > cookingTemperature || (float)itemModCookable.highTemp < cookingTemperature)
		{
			return false;
		}
		return true;
	}

	public bool IsMaterialOutput(Item item)
	{
		if (_materialOutputCache == null)
		{
			BuildMaterialOutputCache();
		}
		if (!_materialOutputCache.TryGetValue(cookingTemperature, out var value))
		{
			Debug.LogError((object)"Can't find smeltable item list for oven");
			return true;
		}
		return value.Contains(item.info);
	}

	public bool IsOutputItem(Item item)
	{
		if (!IsMaterialOutput(item))
		{
			return IsBurnableByproduct(item);
		}
		return true;
	}

	private void BuildMaterialOutputCache()
	{
		_materialOutputCache = new Dictionary<float, HashSet<ItemDefinition>>();
		float[] array = (from x in GameManager.server.preProcessed.prefabList.Values
			select x.GetComponent<BaseOven>() into x
			where (Object)(object)x != (Object)null
			select x.cookingTemperature).Distinct().ToArray();
		foreach (float key in array)
		{
			HashSet<ItemDefinition> hashSet = new HashSet<ItemDefinition>();
			_materialOutputCache[key] = hashSet;
			foreach (ItemDefinition item in ItemManager.itemList)
			{
				ItemModCookable itemModCookable = item.ItemModCookable;
				if (!((Object)(object)itemModCookable == (Object)null) && itemModCookable.CanBeCookedByAtTemperature(key))
				{
					hashSet.Add(itemModCookable.becomeOnCooked);
				}
			}
		}
	}

	public override bool HasSlot(Slot slot)
	{
		if (hasFireDeploySlot && slot == Slot.FireMod)
		{
			return true;
		}
		return base.HasSlot(slot);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			info.msg.baseOven = Pool.Get<BaseOven>();
			info.msg.baseOven.cookSpeed = GetSmeltingSpeed();
			if (visualFood)
			{
				SaveVisualFood(info);
			}
		}
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	protected override bool CanCompletePickup(BasePlayer player)
	{
		if (!CanPickupOven())
		{
			pickupErrorToFormat = (format: PickupErrors.ItemHasAttachment, arg0: pickup.itemTarget.displayName);
			return false;
		}
		return base.CanCompletePickup(player);
	}

	protected virtual bool CanPickupOven()
	{
		return children.Count == 0;
	}

	public virtual void SetAlwaysOn(bool flag)
	{
		SetFlag(Flags.Reserved9, flag);
		AlwaysOnToggled(flag);
	}

	public void AlwaysOnToggled(bool flag)
	{
		if (flag)
		{
			if (!IsOn())
			{
				StartCooking();
			}
		}
		else
		{
			StopCooking();
		}
	}

	public virtual bool IsAlwaysOn()
	{
		if (HasFlag(Flags.Reserved9))
		{
			return Creative.alwaysOnEnabled;
		}
		return false;
	}

	private void OnItemAddedOrRemovedVisualFood(Item item, bool bAdded)
	{
		if (bAdded)
		{
			for (int i = _inputSlotIndex; i <= _inputSlotIndex + inputSlots - 1; i++)
			{
				if (base.inventory.GetSlot(i) == item)
				{
					AddVisualFood(item, i - _inputSlotIndex);
					break;
				}
			}
		}
		if (!bAdded)
		{
			if (item.uid.Value != 0L)
			{
				TryRemoveVisualFood(item);
			}
			RemoveFinishedVisualFood(item);
		}
	}

	public override void OnItemPositionChanged(Item item, int from, int to)
	{
		base.OnItemPositionChanged(item, from, to);
		if (from < _inputSlotIndex || to > _inputSlotIndex + inputSlots)
		{
			return;
		}
		foreach (CookingItem cookingItem in cookingItems)
		{
			if (cookingItem.itemInstanceID.Value == item.uid.Value)
			{
				MoveVisualFood(item, to);
			}
		}
	}

	public override void OnItemAddedToStack(Item item, int amount)
	{
		UpdateVisualFoodAmount(item);
	}

	public override void OnItemRemovedFromStack(Item item, int amount)
	{
		UpdateVisualFoodAmount(item);
	}

	private void UpdateVisualFoodAmount(Item item)
	{
		foreach (CookingItem cookingItem in cookingItems)
		{
			if (cookingItem.itemInstanceID.Value == item.uid.Value)
			{
				cookingItem.cookingProgress = 0f;
				cookingItem.initialStackSize = item.amount;
			}
		}
	}

	private void MoveVisualFood(Item item, int to)
	{
		foreach (CookingItem cookingItem in cookingItems)
		{
			if (cookingItem.itemInstanceID.Value == item.uid.Value)
			{
				cookingItem.slotIndex = to - _inputSlotIndex;
			}
		}
		SendNetworkUpdate();
	}

	public void AddVisualFood(Item item, int slot)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		if (!visualFood)
		{
			return;
		}
		CookingItem cookingItem = cookingItems.Find((CookingItem x) => x.slotIndex == slot);
		if (cookingItem != null)
		{
			if (cookingItem.cookingProgress != 1f)
			{
				return;
			}
			TryRemoveVisualFood(cookingItem.itemInstanceID);
		}
		if (item != null)
		{
			CookingItem item2 = new CookingItem
			{
				itemInstanceID = item.uid,
				itemID = item.info.itemid,
				byproductItemID = item.info.ItemModCookable.becomeOnCooked.itemid,
				slotIndex = slot,
				initialStackSize = item.amount,
				cookingProgress = 0f
			};
			cookingItems.Add(item2);
		}
		SendNetworkUpdate();
	}

	public void TryRemoveVisualFood(Item item)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TryRemoveVisualFood(item.uid);
	}

	public void TryRemoveVisualFood(ItemId itemId)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		for (int num = cookingItems.Count - 1; num >= 0; num--)
		{
			if (cookingItems[num].itemInstanceID == itemId)
			{
				cookingItems.RemoveAt(num);
			}
		}
		SendNetworkUpdate();
	}

	private void RemoveFinishedVisualFood(Item cookedItem)
	{
		for (int num = cookingItems.Count - 1; num >= 0; num--)
		{
			if (cookingItems[num].cookingProgress == 1f && cookingItems[num].byproductItemID == cookedItem.info.itemid)
			{
				bool flag = true;
				for (int i = _outputSlotIndex; i <= _outputSlotIndex + outputSlots - 1; i++)
				{
					Item slot = base.inventory.GetSlot(i);
					if (slot != null && slot.info.itemid == cookedItem.info.itemid)
					{
						flag = false;
						break;
					}
				}
				if (flag)
				{
					cookingItems.RemoveAt(num);
				}
			}
		}
		SendNetworkUpdate();
	}

	private void SaveVisualFood(SaveInfo info)
	{
		info.msg.baseOven.cookingItems = Pool.Get<List<CookingItem>>();
		foreach (CookingItem cookingItem in cookingItems)
		{
			CookingItem val = Pool.Get<CookingItem>();
			val.itemID = cookingItem.itemID;
			val.slotIndex = cookingItem.slotIndex;
			val.initialStackSize = cookingItem.initialStackSize;
			val.cookingProgress = cookingItem.cookingProgress;
			info.msg.baseOven.cookingItems.Add(val);
		}
	}

	private void CookVisuals()
	{
		foreach (CookingItem cookingItem in cookingItems)
		{
			if (base.inventory != null && cookingItem != null && cookingItem.cookingProgress != 1f)
			{
				Item slot = base.inventory.GetSlot(cookingItem.slotIndex + _inputSlotIndex);
				if (slot == null)
				{
					cookingItem.cookingProgress = 1f;
					continue;
				}
				float cookTime = slot.info.ItemModCookable.cookTime;
				float cookingProgress = ((float)(cookingItem.initialStackSize - slot.amount) + (1f - slot.cookTimeLeft / cookTime)) / (float)cookingItem.initialStackSize;
				cookingItem.cookingProgress = cookingProgress;
			}
		}
	}
}


public enum TemperatureType
{
	Normal,
	Warming,
	Cooking,
	Smelting,
	Fractioning
}


public enum IndustrialSlotMode
{
	Furnace,
	LargeFurnace,
	OilRefinery,
	ElectricFurnace
}


public struct MinMax
{
	public int Min;

	public int Max;

	public MinMax(int min, int max)
	{
		Min = min;
		Max = max;
	}
}


public enum OvenItemType
{
	Burnable,
	Byproduct,
	MaterialInput,
	MaterialOutput
}


public class CookingItem
{
	public ItemId itemInstanceID;

	public int slotIndex;

	public float cookingProgress;

	public int itemID;

	public int byproductItemID;

	public int initialStackSize;
}


