using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class WorldNetworking
{
	private const int prefabsPerPacket = 100;

	private const int pathsPerPacket = 10;

	public static void OnMessageReceived(Message message)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Expected I4, but got Unknown
		WorldSerialization serialization = World.Serialization;
		WorldMessage val = message.read.Proto<WorldMessage>((WorldMessage)null);
		try
		{
			MessageType status = val.status;
			switch (status - 1)
			{
			case 0:
				SendWorldData(message.connection);
				return;
			}
			if (val.prefabs != null)
			{
				serialization.world.prefabs.AddRange(val.prefabs);
				val.prefabs.Clear();
			}
			if (val.paths != null)
			{
				serialization.world.paths.AddRange(val.paths);
				val.paths.Clear();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void SendWorldData(Connection connection)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		if (connection.hasRequestedWorld)
		{
			DebugEx.LogWarning((object)$"{connection} requested world data more than once", (StackTraceLogType)0);
			return;
		}
		connection.hasRequestedWorld = true;
		WorldSerialization serialization = World.Serialization;
		WorldMessage data = Pool.Get<WorldMessage>();
		for (int i = 0; i < serialization.world.prefabs.Count; i++)
		{
			if (data.prefabs != null && data.prefabs.Count >= 100)
			{
				data.status = (MessageType)2;
				SendWorldData(connection, ref data);
				data = Pool.Get<WorldMessage>();
			}
			if (data.prefabs == null)
			{
				data.prefabs = Pool.Get<List<PrefabData>>();
			}
			data.prefabs.Add(serialization.world.prefabs[i]);
		}
		for (int j = 0; j < serialization.world.paths.Count; j++)
		{
			if (data.paths != null && data.paths.Count >= 10)
			{
				data.status = (MessageType)2;
				SendWorldData(connection, ref data);
				data = Pool.Get<WorldMessage>();
			}
			if (data.paths == null)
			{
				data.paths = Pool.Get<List<PathData>>();
			}
			data.paths.Add(serialization.world.paths[j]);
		}
		if (data != null)
		{
			data.status = (MessageType)3;
			SendWorldData(connection, ref data);
		}
	}

	private static void SendWorldData(Connection connection, ref WorldMessage data)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
		obj.PacketID((Type)24);
		obj.Proto<WorldMessage>(data);
		obj.Send(new SendInfo(connection));
		if (data.prefabs != null)
		{
			data.prefabs.Clear();
		}
		if (data.paths != null)
		{
			data.paths.Clear();
		}
		data.Dispose();
		data = null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using ConVar;
using Rust;
using UnityEngine;
using UnityEngine.Networking;

public class WorldSetup : SingletonComponent<WorldSetup>
{
	public bool AutomaticallySetup;

	public bool BypassProceduralSpawn;

	public bool ForceGenerateOceanPatrols;

	public GameObject terrain;

	public GameObject decorPrefab;

	public GameObject grassPrefab;

	public GameObject spawnPrefab;

	private TerrainMeta terrainMeta;

	public uint EditorSeed;

	public uint EditorSalt;

	public uint EditorSize;

	public string EditorUrl = string.Empty;

	public string EditorConfigFile = string.Empty;

	[TextArea]
	public string EditorConfigString = string.Empty;

	public List<ProceduralObject> ProceduralObjects = new List<ProceduralObject>();

	internal List<MonumentNode> MonumentNodes = new List<MonumentNode>();

	public void OnValidate()
	{
		if ((Object)(object)terrain == (Object)null)
		{
			Terrain val = Object.FindObjectOfType<Terrain>();
			if ((Object)(object)val != (Object)null)
			{
				terrain = ((Component)val).gameObject;
			}
		}
	}

	protected override void Awake()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Expected O, but got Unknown
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		((SingletonComponent)this).Awake();
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/world", null, null, useProbabilities: false, useWorldConfig: false);
		foreach (Prefab prefab in array)
		{
			if ((Object)(object)prefab.Object.GetComponent<BaseEntity>() != (Object)null)
			{
				prefab.SpawnEntity(Vector3.zero, Quaternion.identity).Spawn();
			}
			else
			{
				prefab.Spawn(Vector3.zero, Quaternion.identity);
			}
		}
		SingletonComponent[] array2 = Object.FindObjectsOfType<SingletonComponent>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SingletonSetup();
		}
		if (Object.op_Implicit((Object)(object)terrain))
		{
			if (Object.op_Implicit((Object)(object)terrain.GetComponent<TerrainGenerator>()))
			{
				World.Procedural = true;
			}
			else
			{
				World.Procedural = false;
				terrainMeta = terrain.GetComponent<TerrainMeta>();
				terrainMeta.Init();
				terrainMeta.SetupComponents();
				terrainMeta.BindShaderProperties();
				terrainMeta.PostSetupComponents();
				World.InitSize(Mathf.RoundToInt(TerrainMeta.Size.x));
				CreateObject(decorPrefab);
				CreateObject(grassPrefab);
				CreateObject(spawnPrefab);
			}
		}
		World.Serialization = new WorldSerialization();
		World.Cached = false;
		World.CleanupOldFiles();
		if (!string.IsNullOrEmpty(EditorConfigString))
		{
			ConVar.World.configString = EditorConfigString;
		}
		if (!string.IsNullOrEmpty(EditorConfigFile))
		{
			ConVar.World.configFile = EditorConfigFile;
		}
		if (AutomaticallySetup)
		{
			((MonoBehaviour)this).StartCoroutine(InitCoroutine());
		}
	}

	public void CreateObject(GameObject prefab)
	{
		if (!((Object)(object)prefab == (Object)null))
		{
			GameObject val = Object.Instantiate<GameObject>(prefab);
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(true);
			}
		}
	}

	public IEnumerator InitCoroutine(CancellationToken ct = default(CancellationToken))
	{
		if (World.CanLoadFromUrl())
		{
			Debug.Log((object)("Loading custom map from " + World.Url));
		}
		else
		{
			Debug.Log((object)("Generating procedural map of size " + World.Size + " with seed " + World.Seed));
		}
		World.Config = new WorldConfig();
		World.Config.LoadScriptableConfigs();
		if (!string.IsNullOrEmpty(ConVar.World.configString))
		{
			Debug.Log((object)"Loading custom world config from world.configstring convar");
			World.Config.LoadFromJsonString(ConVar.World.configString);
		}
		else if (!string.IsNullOrEmpty(ConVar.World.configFile))
		{
			string text = ConVar.Server.rootFolder + "/" + ConVar.World.configFile;
			Debug.Log((object)("Loading custom world config from world.configfile convar: " + text));
			World.Config.LoadFromJsonFile(text);
		}
		World.ResetTiming();
		ProceduralComponent[] components = ((Component)this).GetComponentsInChildren<ProceduralComponent>(true);
		Timing downloadTimer = Timing.Start("Downloading World");
		if (World.Procedural && !World.CanLoadFromDisk() && World.CanLoadFromUrl())
		{
			LoadingScreen.Update("DOWNLOADING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			UnityWebRequest request = UnityWebRequest.Get(World.Url);
			request.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();
			request.Send();
			float lastProgress = 0f;
			while (!request.isDone)
			{
				if (ct.IsCancellationRequested)
				{
					yield break;
				}
				float downloadProgress = request.downloadProgress;
				if (!Mathf.Approximately(downloadProgress, lastProgress))
				{
					lastProgress = downloadProgress;
					LoadingScreen.Update($"DOWNLOADING WORLD {downloadProgress * 100f:0.0}%");
				}
				yield return CoroutineEx.waitForEndOfFrame;
			}
			if (!request.isHttpError && !request.isNetworkError)
			{
				World.Serialization.Load(request.downloadHandler.data);
				World.Serialization.Save(World.MapFolderName + "/" + World.MapFileName);
				World.Cached = true;
			}
			else
			{
				CancelSetup("Couldn't Download Level: " + World.Name + " (" + request.error + ")");
			}
		}
		downloadTimer.End();
		Timing loadTimer = Timing.Start("Loading World");
		if (World.Procedural && !World.Cached && World.CanLoadFromDisk())
		{
			LoadingScreen.Update("LOADING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.Load(World.MapFolderName + "/" + World.MapFileName);
			World.Cached = true;
		}
		loadTimer.End();
		if (World.Cached && 10 != World.Serialization.Version)
		{
			Debug.LogWarning((object)("World cache version mismatch: " + 10u + " != " + World.Serialization.Version));
			World.Serialization.Clear();
			World.Cached = false;
			if (World.CanLoadFromUrl())
			{
				CancelSetup("World File Outdated: " + World.Name);
			}
		}
		if (World.Cached && string.IsNullOrEmpty(World.Checksum))
		{
			World.Checksum = World.Serialization.Checksum;
		}
		World.Timestamp = World.Serialization.Timestamp;
		if (World.Cached)
		{
			World.InitSize(World.Serialization.world.size);
		}
		if ((Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.Setup();
		}
		if (Object.op_Implicit((Object)(object)terrain))
		{
			TerrainGenerator component = terrain.GetComponent<TerrainGenerator>();
			if (Object.op_Implicit((Object)(object)component))
			{
				if (World.Cached)
				{
					int cachedHeightMapResolution = World.GetCachedHeightMapResolution();
					int cachedSplatMapResolution = World.GetCachedSplatMapResolution();
					terrain = component.CreateTerrain(cachedHeightMapResolution, cachedSplatMapResolution);
				}
				else
				{
					terrain = component.CreateTerrain();
				}
				terrainMeta = terrain.GetComponent<TerrainMeta>();
				terrainMeta.Init();
				terrainMeta.SetupComponents();
				CreateObject(decorPrefab);
				CreateObject(grassPrefab);
				CreateObject(spawnPrefab);
			}
		}
		Timing spawnTimer = Timing.Start("Spawning World");
		if (World.Cached)
		{
			LoadingScreen.Update("SPAWNING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			if (ct.IsCancellationRequested || (Object)(object)TerrainMeta.HeightMap == (Object)null)
			{
				yield break;
			}
			TerrainMeta.HeightMap.FromByteArray(World.GetMap("terrain"));
			TerrainMeta.SplatMap.FromByteArray(World.GetMap("splat"));
			TerrainMeta.BiomeMap.FromByteArray(World.GetMap("biome"));
			TerrainMeta.TopologyMap.FromByteArray(World.GetMap("topology"));
			TerrainMeta.AlphaMap.FromByteArray(World.GetMap("alpha"));
			TerrainMeta.WaterMap.FromByteArray(World.GetMap("water"));
			IEnumerator worldSpawn = World.Spawn(0.2f, LoadingScreen.Update, ct);
			while (worldSpawn.MoveNext())
			{
				if (ct.IsCancellationRequested)
				{
					yield break;
				}
				yield return worldSpawn.Current;
			}
			TerrainMeta.Path.Clear();
			TerrainMeta.Path.Roads.AddRange(World.GetPaths("Road"));
			TerrainMeta.Path.AddRoad(TerrainMeta.Path.Roads, addToMaster: false);
			TerrainMeta.Path.Rivers.AddRange(World.GetPaths("River"));
			TerrainMeta.Path.Powerlines.AddRange(World.GetPaths("Powerline"));
			TerrainMeta.Path.Rails.AddRange(World.GetPaths("Rail"));
		}
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (DungeonBaseLink dungeonBaseLink in TerrainMeta.Path.DungeonBaseLinks)
			{
				if ((Object)(object)dungeonBaseLink != (Object)null)
				{
					dungeonBaseLink.Initialize();
				}
			}
		}
		spawnTimer.End();
		Timing loadPrefabsTimer = Timing.Start("Loading Monument Prefabs");
		if (!World.Cached && World.Procedural)
		{
			FileSystemBackend backend = FileSystem.Backend;
			AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
			if (assetBundleBackend != null)
			{
				List<string> requiredAssetScenes = AssetSceneManifest.Current.MonumentScenes;
				IEnumerator worldSpawn = assetBundleBackend.LoadAssetScenes(requiredAssetScenes);
				bool wantsCancel = false;
				float lastProgress = 0f;
				while (worldSpawn.MoveNext())
				{
					if (!wantsCancel && ct.IsCancellationRequested)
					{
						wantsCancel = true;
						Debug.LogWarning((object)"Cancel was requested but must wait for asset scenes to finish loading");
					}
					float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress(requiredAssetScenes);
					if (!Mathf.Approximately(assetSceneProgress, lastProgress))
					{
						lastProgress = assetSceneProgress;
						LoadingScreen.Update($"Loading Monument Prefabs {assetSceneProgress * 100f:0.0}%");
					}
					yield return worldSpawn.Current;
				}
			}
		}
		loadPrefabsTimer.End();
		Timing procgenTimer = Timing.Start("Processing World");
		if (components.Length != 0)
		{
			for (int i = 0; i < components.Length; i++)
			{
				ProceduralComponent component2 = components[i];
				if (Object.op_Implicit((Object)(object)component2) && component2.ShouldRun())
				{
					if (ct.IsCancellationRequested)
					{
						yield break;
					}
					uint seed = (uint)(World.Seed + i);
					LoadingScreen.Update(component2.Description.ToUpper());
					yield return CoroutineEx.waitForEndOfFrame;
					yield return CoroutineEx.waitForEndOfFrame;
					yield return CoroutineEx.waitForEndOfFrame;
					Timing timing = Timing.Start(component2.Description);
					if (Object.op_Implicit((Object)(object)component2))
					{
						component2.Process(seed);
					}
					timing.End();
				}
			}
		}
		procgenTimer.End();
		Timing saveTimer = Timing.Start("Saving World");
		if (ConVar.World.cache && World.Procedural && !World.Cached)
		{
			LoadingScreen.Update("SAVING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.world.size = World.Size;
			World.AddPaths(TerrainMeta.Path.Roads);
			World.AddPaths(TerrainMeta.Path.Rivers);
			World.AddPaths(TerrainMeta.Path.Powerlines);
			World.AddPaths(TerrainMeta.Path.Rails);
			World.Serialization.Save(World.MapFolderName + "/" + World.MapFileName);
		}
		saveTimer.End();
		Timing checksumTimer = Timing.Start("Calculating Checksum");
		if (string.IsNullOrEmpty(World.Serialization.Checksum))
		{
			LoadingScreen.Update("CALCULATING CHECKSUM");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.CalculateChecksum();
		}
		checksumTimer.End();
		if (string.IsNullOrEmpty(World.Checksum))
		{
			World.Checksum = World.Serialization.Checksum;
		}
		Timing oceanTimer = Timing.Start("Ocean Patrol Paths");
		LoadingScreen.Update("OCEAN PATROL PATHS");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if ((BaseBoat.generate_paths && (Object)(object)TerrainMeta.Path != (Object)null) || ForceGenerateOceanPatrols)
		{
			TerrainMeta.Path.OceanPatrolFar = BaseBoat.GenerateOceanPatrolPath(200f);
		}
		else
		{
			Debug.Log((object)"Skipping ocean patrol paths, baseboat.generate_paths == false");
		}
		oceanTimer.End();
		Timing finalizeTimer = Timing.Start("Finalizing World");
		LoadingScreen.Update("FINALIZING WORLD");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (Object.op_Implicit((Object)(object)terrainMeta))
		{
			if (World.Procedural)
			{
				terrainMeta.BindShaderProperties();
				terrainMeta.PostSetupComponents();
			}
			TerrainMargin.Create();
		}
		finalizeTimer.End();
		Timing cleaningTimer = Timing.Start("Cleaning Up");
		LoadingScreen.Update("CLEANING UP");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		List<string> invalidAssets = FileSystem.Backend.UnloadBundles("monuments");
		FileSystemBackend backend2 = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend2 is AssetBundleBackend) ? backend2 : null);
		if (val != null)
		{
			List<string> unloadableScenes = AssetSceneManifest.Current.UnloadableScenes;
			yield return val.UnloadAssetScenes(unloadableScenes, (Action<string, Dictionary<string, GameObject>>)delegate(string sceneName, Dictionary<string, GameObject> prefabs)
			{
				foreach (var (item, _) in prefabs)
				{
					invalidAssets.Add(item);
				}
			});
		}
		foreach (string item2 in invalidAssets)
		{
			GameManager.server.preProcessed.Invalidate(item2);
			GameManifest.Invalidate(item2);
			PrefabAttribute.server.Invalidate(StringPool.Get(item2));
		}
		Resources.UnloadUnusedAssets();
		cleaningTimer.End();
		LoadingScreen.Update("DONE");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (Object.op_Implicit((Object)(object)this))
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
	}

	private void CancelSetup(string msg)
	{
		Debug.LogError((object)msg);
		Application.Quit();
	}
}


using UnityEngine;

public class ApplyTerrainModifiers : MonoBehaviour
{
	protected void Awake()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		TerrainModifier[] modifiers = null;
		if (component.isServer)
		{
			modifiers = PrefabAttribute.server.FindAll<TerrainModifier>(component.prefabID);
		}
		((Component)this).transform.ApplyTerrainModifiers(modifiers);
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class TerrainCarve : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap))
		{
			TerrainMeta.AlphaMap.SetAlpha(position, 0f, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightAdd : TerrainModifier
{
	public float Delta = 1f;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			TerrainMeta.HeightMap.AddHeight(position, opacity * Delta * TerrainMeta.OneOverSize.y, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightRaise : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			TerrainMeta.HeightMap.RaiseHeight(position, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightSet : TerrainModifier
{
	public enum Mode
	{
		Set,
		Raise,
		Lower
	}

	public Mode HeightMode;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			switch (HeightMode)
			{
			case Mode.Set:
				TerrainMeta.HeightMap.SetHeight(position, opacity, radius, fade);
				break;
			case Mode.Raise:
				TerrainMeta.HeightMap.RaiseHeight(position, opacity, radius, fade);
				break;
			case Mode.Lower:
				TerrainMeta.HeightMap.LowerHeight(position, opacity, radius, fade);
				break;
			}
		}
	}
}


public enum Mode
{
	Set,
	Raise,
	Lower
}


using System;
using UnityEngine;

public abstract class TerrainModifier : PrefabAttribute
{
	public float Opacity = 1f;

	public float Radius;

	public float Fade;

	public void Apply(Vector3 pos, float scale)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		float opacity = Opacity;
		float radius = scale * Radius;
		float fade = scale * Fade;
		Apply(pos, opacity, radius, fade);
	}

	protected abstract void Apply(Vector3 position, float opacity, float radius, float fade);

	protected override Type GetIndexedType()
	{
		return typeof(TerrainModifier);
	}
}


using UnityEngine;

public static class TerrainModifierEx
{
	public static void ApplyTerrainModifiers(this Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		foreach (TerrainModifier obj in modifiers)
		{
			Vector3 val = Vector3.Scale(obj.worldPosition, scale);
			Vector3 pos2 = pos + rot * val;
			float y = scale.y;
			obj.Apply(pos2, y);
		}
	}

	public static void ApplyTerrainModifiers(this Transform transform, TerrainModifier[] modifiers)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		transform.ApplyTerrainModifiers(modifiers, transform.position, transform.rotation, transform.lossyScale);
	}
}


using UnityEngine;

public class TerrainPlacementBlocked : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.PlacementMap))
		{
			TerrainMeta.PlacementMap.SetBlocked(position, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainSplatRemove : TerrainModifier
{
	public Enum SplatType;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) && !TerrainMeta.TopologyMap.GetTopology(position, 8388608))
		{
			TerrainMeta.SplatMap.RemoveSplat(position, (int)SplatType, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainSplatSet : TerrainModifier
{
	public Enum SplatType;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap))
		{
			TerrainMeta.SplatMap.SetSplat(position, (int)SplatType, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainTopologyAdd : TerrainModifier
{
	[InspectorFlags]
	public Enum TopologyType = (Enum)512;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			TerrainMeta.TopologyMap.AddTopology(position, (int)TopologyType, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainTopologySet : TerrainModifier
{
	[InspectorFlags]
	public Enum TopologyType = (Enum)512;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			TerrainMeta.TopologyMap.SetTopology(position, (int)TopologyType, radius, fade);
		}
	}
}


using UnityEngine;

public class Monument : TerrainPlacement
{
	public float Radius;

	public float Fade = 10f;

	public bool AutoCliffSplat = true;

	public bool AutoCliffTopology = true;

	public bool RemoveExistingTopology;

	protected void OnDrawGizmosSelected()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, Radius);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, Radius - Fade);
	}

	protected override void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool useBlendMap = blendmap.isValid;
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData blenddata = new TextureData(useBlendMap ? blendmap.Get() : null);
		float num = (useBlendMap ? extents.x : Radius);
		float num2 = (useBlendMap ? extents.z : Radius);
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - num, 0f, 0f - num2));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(num, 0f, 0f - num2));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - num, 0f, num2));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(num, 0f, num2));
		TerrainMeta.HeightMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.HeightMap.Coordinate(z);
			float normX = TerrainMeta.HeightMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num3 = 1f;
			num3 = ((!useBlendMap) ? Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2)) : blenddata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z).w);
			if (num3 != 0f)
			{
				int num4 = Mathx.Min(x, z, TerrainMeta.HeightMap.res - 1 - x, TerrainMeta.HeightMap.res - 1 - z);
				if (num4 < 10)
				{
					num3 *= Mathf.SmoothStep(0f, 1f, Mathf.InverseLerp(0f, 10f, (float)num4));
				}
				if (num3 != 0f)
				{
					float num5 = TerrainMeta.NormalizeY(position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y);
					num5 = Mathf.SmoothStep(TerrainMeta.HeightMap.GetHeight01(x, z), num5, num3);
					TerrainMeta.HeightMap.SetHeight(x, z, num5);
				}
			}
		});
	}

	protected override void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool should0 = ShouldSplat(1);
		bool should1 = ShouldSplat(2);
		bool should2 = ShouldSplat(4);
		bool should3 = ShouldSplat(8);
		bool should4 = ShouldSplat(16);
		bool should5 = ShouldSplat(32);
		bool should6 = ShouldSplat(64);
		bool should7 = ShouldSplat(128);
		if (!should0 && !should1 && !should2 && !should3 && !should4 && !should5 && !should6 && !should7)
		{
			return;
		}
		TextureData splat0data = new TextureData(splatmap0.Get());
		TextureData splat1data = new TextureData(splatmap1.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.SplatMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
			if (AutoCliffSplat)
			{
				GenerateCliffSplat.Process(x, z);
			}
			float normZ = TerrainMeta.SplatMap.Coordinate(z);
			float normX = TerrainMeta.SplatMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				Vector4 interpolatedVector = splat0data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				Vector4 interpolatedVector2 = splat1data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				if (!should0)
				{
					interpolatedVector.x = 0f;
				}
				if (!should1)
				{
					interpolatedVector.y = 0f;
				}
				if (!should2)
				{
					interpolatedVector.z = 0f;
				}
				if (!should3)
				{
					interpolatedVector.w = 0f;
				}
				if (!should4)
				{
					interpolatedVector2.x = 0f;
				}
				if (!should5)
				{
					interpolatedVector2.y = 0f;
				}
				if (!should6)
				{
					interpolatedVector2.z = 0f;
				}
				if (!should7)
				{
					interpolatedVector2.w = 0f;
				}
				TerrainMeta.SplatMap.SetSplatRaw(x, z, interpolatedVector, interpolatedVector2, num);
			}
		});
	}

	protected override void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		TextureData alphadata = new TextureData(alphamap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.AlphaMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.AlphaMap.Coordinate(z);
			float normX = TerrainMeta.AlphaMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				float w = alphadata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z).w;
				TerrainMeta.AlphaMap.SetAlpha(x, z, w, num);
			}
		});
	}

	protected override void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool should0 = ShouldBiome(1);
		bool should1 = ShouldBiome(2);
		bool should2 = ShouldBiome(4);
		bool should3 = ShouldBiome(8);
		bool should4 = ShouldBiome(16);
		if (!should0 && !should1 && !should2 && !should3 && !should4)
		{
			return;
		}
		TextureData biomedata = new TextureData(biomemap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.BiomeMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.BiomeMap.Coordinate(z);
			float normX = TerrainMeta.BiomeMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				Vector4 interpolatedVector = biomedata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				float num2 = interpolatedVector.x;
				float num3 = interpolatedVector.y;
				float num4 = interpolatedVector.z;
				float num5 = interpolatedVector.w;
				float biome = 1f - num2 - num3 - num4 - num5;
				if (!should0)
				{
					num2 = 0f;
				}
				if (!should1)
				{
					num3 = 0f;
				}
				if (!should2)
				{
					num4 = 0f;
				}
				if (!should3)
				{
					num5 = 0f;
				}
				if (!should4)
				{
					biome = 0f;
				}
				TerrainMeta.BiomeMap.SetBiomeRaw(x, z, num2, num3, num4, num5, biome, num);
			}
		});
	}

	protected override void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		TextureData topologydata = new TextureData(topologymap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.TopologyMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Expected I4, but got Unknown
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Expected I4, but got Unknown
			float normZ = TerrainMeta.TopologyMap.Coordinate(z);
			float normX = TerrainMeta.TopologyMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			int interpolatedInt = topologydata.GetInterpolatedInt((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
			bool num = ShouldTopology(interpolatedInt);
			if (num && RemoveExistingTopology)
			{
				TerrainMeta.TopologyMap.RemoveTopology(x, z, (int)TopologyMask);
			}
			if (AutoCliffTopology)
			{
				GenerateCliffTopology.Process(x, z);
			}
			if (num)
			{
				TerrainMeta.TopologyMap.AddTopology(x, z, interpolatedInt & TopologyMask);
			}
		});
	}

	protected override void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}
}


using UnityEngine;

public class Mountain : TerrainPlacement
{
	public float Fade = 10f;

	public bool AutoCliffSplat;

	public bool AutoCliffTopology = true;

	protected void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.up * (0.5f * Fade);
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		Gizmos.DrawCube(((Component)this).transform.position + val, new Vector3(size.x, Fade, size.z));
		Gizmos.DrawWireCube(((Component)this).transform.position + val, new Vector3(size.x, Fade, size.z));
	}

	protected override void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.HeightMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.HeightMap.Coordinate(z);
			float normX = TerrainMeta.HeightMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				float num3 = TerrainMeta.NormalizeY(num);
				num3 = Mathx.SmoothMax(TerrainMeta.HeightMap.GetHeight01(x, z), num3, 0.1f);
				TerrainMeta.HeightMap.SetHeight(x, z, num3, num2);
			}
		});
	}

	protected override void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		bool should0 = ShouldSplat(1);
		bool should1 = ShouldSplat(2);
		bool should2 = ShouldSplat(4);
		bool should3 = ShouldSplat(8);
		bool should4 = ShouldSplat(16);
		bool should5 = ShouldSplat(32);
		bool should6 = ShouldSplat(64);
		bool should7 = ShouldSplat(128);
		if (!should0 && !should1 && !should2 && !should3 && !should4 && !should5 && !should6 && !should7)
		{
			return;
		}
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData splat0data = new TextureData(splatmap0.Get());
		TextureData splat1data = new TextureData(splatmap1.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.SplatMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0282: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			if (AutoCliffSplat)
			{
				GenerateCliffSplat.Process(x, z);
			}
			float normZ = TerrainMeta.SplatMap.Coordinate(z);
			float normX = TerrainMeta.SplatMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				Vector4 interpolatedVector = splat0data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				Vector4 interpolatedVector2 = splat1data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				if (!should0)
				{
					interpolatedVector.x = 0f;
				}
				if (!should1)
				{
					interpolatedVector.y = 0f;
				}
				if (!should2)
				{
					interpolatedVector.z = 0f;
				}
				if (!should3)
				{
					interpolatedVector.w = 0f;
				}
				if (!should4)
				{
					interpolatedVector2.x = 0f;
				}
				if (!should5)
				{
					interpolatedVector2.y = 0f;
				}
				if (!should6)
				{
					interpolatedVector2.z = 0f;
				}
				if (!should7)
				{
					interpolatedVector2.w = 0f;
				}
				TerrainMeta.SplatMap.SetSplatRaw(x, z, interpolatedVector, interpolatedVector2, num2);
			}
		});
	}

	protected override void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}

	protected override void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		bool should0 = ShouldBiome(1);
		bool should1 = ShouldBiome(2);
		bool should2 = ShouldBiome(4);
		bool should3 = ShouldBiome(8);
		bool should4 = ShouldBiome(16);
		if (!should0 && !should1 && !should2 && !should3 && !should4)
		{
			return;
		}
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData biomedata = new TextureData(biomemap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.BiomeMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.BiomeMap.Coordinate(z);
			float normX = TerrainMeta.BiomeMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				Vector4 interpolatedVector = biomedata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				float num3 = interpolatedVector.x;
				float num4 = interpolatedVector.y;
				float num5 = interpolatedVector.z;
				float num6 = interpolatedVector.w;
				float biome = 1f - num3 - num4 - num5 - num6;
				if (!should0)
				{
					num3 = 0f;
				}
				if (!should1)
				{
					num4 = 0f;
				}
				if (!should2)
				{
					num5 = 0f;
				}
				if (!should3)
				{
					num6 = 0f;
				}
				if (!should4)
				{
					biome = 0f;
				}
				TerrainMeta.BiomeMap.SetBiomeRaw(x, z, num3, num4, num5, num6, biome, num2);
			}
		});
	}

	protected override void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		TextureData topologydata = new TextureData(topologymap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.TopologyMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Expected I4, but got Unknown
			if (AutoCliffTopology)
			{
				GenerateCliffTopology.Process(x, z);
			}
			float normZ = TerrainMeta.TopologyMap.Coordinate(z);
			float normX = TerrainMeta.TopologyMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			int interpolatedInt = topologydata.GetInterpolatedInt((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
			if (ShouldTopology(interpolatedInt))
			{
				TerrainMeta.TopologyMap.AddTopology(x, z, interpolatedInt & TopologyMask);
			}
		});
	}

	protected override void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}
}


using System;
using UnityEngine;

public abstract class TerrainPlacement : PrefabAttribute
{
	[ReadOnly]
	public Vector3 size = Vector3.zero;

	[ReadOnly]
	public Vector3 extents = Vector3.zero;

	[ReadOnly]
	public Vector3 offset = Vector3.zero;

	public bool HeightMap = true;

	public bool AlphaMap = true;

	public bool WaterMap;

	[InspectorFlags]
	public Enum SplatMask;

	[InspectorFlags]
	public Enum BiomeMask;

	[InspectorFlags]
	public Enum TopologyMask;

	[HideInInspector]
	public Texture2DRef heightmap;

	[HideInInspector]
	public Texture2DRef splatmap0;

	[HideInInspector]
	public Texture2DRef splatmap1;

	[HideInInspector]
	public Texture2DRef alphamap;

	[HideInInspector]
	public Texture2DRef biomemap;

	[HideInInspector]
	public Texture2DRef topologymap;

	[HideInInspector]
	public Texture2DRef watermap;

	[HideInInspector]
	public Texture2DRef blendmap;

	public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (ShouldHeight())
		{
			ApplyHeight(localToWorld, worldToLocal);
		}
		if (ShouldSplat())
		{
			ApplySplat(localToWorld, worldToLocal);
		}
		if (ShouldAlpha())
		{
			ApplyAlpha(localToWorld, worldToLocal);
		}
		if (ShouldBiome())
		{
			ApplyBiome(localToWorld, worldToLocal);
		}
		if (ShouldTopology())
		{
			ApplyTopology(localToWorld, worldToLocal);
		}
		if (ShouldWater())
		{
			ApplyWater(localToWorld, worldToLocal);
		}
	}

	protected bool ShouldHeight()
	{
		if (heightmap.isValid)
		{
			return HeightMap;
		}
		return false;
	}

	protected bool ShouldSplat(int id = -1)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Invalid comparison between Unknown and I4
		if (splatmap0.isValid && splatmap1.isValid)
		{
			return (SplatMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldAlpha()
	{
		if (alphamap.isValid)
		{
			return AlphaMap;
		}
		return false;
	}

	protected bool ShouldBiome(int id = -1)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (biomemap.isValid)
		{
			return (BiomeMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldTopology(int id = -1)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (topologymap.isValid)
		{
			return (TopologyMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldWater()
	{
		if (watermap.isValid)
		{
			return WaterMap;
		}
		return false;
	}

	protected abstract void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected override Type GetIndexedType()
	{
		return typeof(TerrainPlacement);
	}
}


using UnityEngine;

public static class TerrainPlacementEx
{
	public static void ApplyTerrainPlacements(this Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (placements.Length != 0)
		{
			for (int i = 0; i < placements.Length; i++)
			{
				TerrainPlacement terrainPlacement = placements[i];
				Vector3 val = pos + rot * Vector3.Scale(terrainPlacement.worldPosition, scale);
				Quaternion val2 = rot * terrainPlacement.worldRotation;
				Matrix4x4 localToWorld = Matrix4x4.TRS(val, val2, scale);
				Matrix4x4 inverse = ((Matrix4x4)(ref localToWorld)).inverse;
				placements[i].Apply(localToWorld, inverse);
			}
		}
	}

	public static void ApplyTerrainPlacements(this Transform transform, TerrainPlacement[] placements)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		transform.ApplyTerrainPlacements(placements, transform.position, transform.rotation, transform.lossyScale);
	}
}


using System.IO;
using Rust.Water5;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ocean Settings", menuName = "Water5/Ocean Settings")]
public class OceanSettings : ScriptableObject
{
	[Header("Compute Shaders")]
	public ComputeShader waveSpectrumCompute;

	public ComputeShader fftCompute;

	public ComputeShader waveMergeCompute;

	public ComputeShader waveInitialSpectrum;

	[Header("Global Ocean Params")]
	public float[] octaveScales;

	public float lamda;

	public float windDirection;

	public float distanceAttenuationFactor;

	public float depthAttenuationFactor;

	[Header("Ocean Spectra")]
	public OceanSpectrumSettings[] spectrumSettings;

	[HideInInspector]
	public float[] spectrumRanges;

	public unsafe OceanDisplacementShort3[,,] LoadSimData()
	{
		OceanDisplacementShort3[,,] array = new OceanDisplacementShort3[spectrumSettings.Length, 72, 65536];
		string path = Application.streamingAssetsPath + "/" + ((Object)this).name + ".physicsdata.dat";
		if (!File.Exists(path))
		{
			Debug.Log((object)"Simulation Data not found");
			return array;
		}
		byte[] array2 = File.ReadAllBytes(path);
		fixed (byte* ptr2 = array2)
		{
			fixed (OceanDisplacementShort3* ptr = array)
			{
				UnsafeUtility.MemCpy((void*)ptr, (void*)ptr2, (long)array2.Length);
			}
		}
		return array;
	}

	internal unsafe NativeOceanDisplacementShort3 LoadNativeSimData()
	{
		NativeOceanDisplacementShort3 result = NativeOceanDisplacementShort3.Create(spectrumSettings.Length, 72, 65536);
		string path = Application.streamingAssetsPath + "/" + ((Object)this).name + ".physicsdata.dat";
		if (!File.Exists(path))
		{
			Debug.Log((object)"Simulation Data not found");
			return result;
		}
		byte[] array = File.ReadAllBytes(path);
		OceanDisplacementShort3* unsafePtr = result.GetUnsafePtr();
		fixed (byte* ptr = array)
		{
			UnsafeUtility.MemCpy((void*)unsafePtr, (void*)ptr, (long)array.Length);
		}
		return result;
	}
}


public enum WaterBodyType
{
	Ocean = 1,
	River = 2,
	Lake = 4,
	Pool = 8,
	Moonpool = 0x10,
	Radioactive = 0x20
}


using System;
using UnityEngine;

[ExecuteInEditMode]
public class WaterBody : MonoBehaviour
{
	[Flags]
	public enum FishingTag
	{
		MoonPool = 1,
		River = 2,
		Ocean = 4,
		Swamp = 8
	}

	public WaterBodyType Type = WaterBodyType.Lake;

	public Renderer Renderer;

	public Collider[] Triggers;

	public bool IsOcean;

	public FishingTag FishingType;

	public Transform Transform { get; private set; }

	private void Awake()
	{
		Transform = ((Component)this).transform;
	}

	private void OnEnable()
	{
		WaterSystem.RegisterBody(this);
	}

	private void OnDisable()
	{
		WaterSystem.UnregisterBody(this);
	}

	public void OnOceanLevelChanged(float newLevel)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOcean || Triggers == null || Triggers.Length == 0)
		{
			return;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				Vector3 position = ((Component)val).transform.position;
				position.y = newLevel;
				((Component)val).transform.position = position;
			}
		}
	}

	public float MinWaterLevel()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.position.y;
		if (Triggers == null || Triggers.Length == 0)
		{
			return num;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				float num2 = num;
				Bounds bounds = val.bounds;
				num = Mathf.Min(num2, ((Bounds)(ref bounds)).max.y);
			}
		}
		return num;
	}

	public float SqrDistance(Vector3 point)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Triggers == null || Triggers.Length == 0)
		{
			return num;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				MeshCollider val2 = (MeshCollider)(object)((val is MeshCollider) ? val : null);
				Vector3 val3;
				if ((Object)(object)val2 == (Object)null || val2.convex)
				{
					float num2 = num;
					val3 = val.ClosestPoint(point) - point;
					num = Mathf.Min(num2, ((Vector3)(ref val3)).sqrMagnitude);
				}
				else
				{
					float num3 = num;
					val3 = val.ClosestPointOnBounds(point) - point;
					num = Mathf.Min(num3, ((Vector3)(ref val3)).sqrMagnitude);
				}
			}
		}
		return num;
	}

	public int GetTopologyMask()
	{
		return Type switch
		{
			WaterBodyType.Lake => 65536, 
			WaterBodyType.Ocean => 128, 
			WaterBodyType.River => 16384, 
			WaterBodyType.Moonpool => 128, 
			WaterBodyType.Pool => 65536, 
			_ => 65536, 
		};
	}
}


using System;

[Flags]
public enum FishingTag
{
	MoonPool = 1,
	River = 2,
	Ocean = 4,
	Swamp = 8
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(PostOpaqueDepth))]
[RequireComponent(typeof(Camera))]
public class WaterCamera : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public class WaterCollision : MonoBehaviour
{
	private ListDictionary<Collider, List<Collider>> ignoredColliders;

	private HashSet<Collider> waterColliders;

	private WaterVisibilityGrid visibilityGrid;

	public const float IgnoreRadius = 0.01f;

	public WaterVisibilityGrid VisibilityGrid => visibilityGrid;

	public void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		waterColliders = new HashSet<Collider>();
		if (visibilityGrid != null)
		{
			visibilityGrid.Dispose();
		}
		visibilityGrid = new WaterVisibilityGrid();
	}

	private void OnDestroy()
	{
		visibilityGrid?.Dispose();
	}

	public void Clear()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (waterColliders.Count == 0)
		{
			return;
		}
		HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
		while (enumerator.MoveNext())
		{
			Enumerator<Collider> enumerator2 = ignoredColliders.Keys.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					Physics.IgnoreCollision(enumerator2.Current, enumerator.Current, false);
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if (waterColliders.Count != 0 && Object.op_Implicit((Object)(object)collider))
		{
			HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Physics.IgnoreCollision(collider, enumerator.Current, false);
			}
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(pos, radius))
		{
			return false;
		}
		return GamePhysics.CheckSphere<WaterVisibilityTrigger>(pos, radius, 262144, (QueryTriggerInteraction)2);
	}

	public void GetIgnore(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnore", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> val2 = new NativeList<int>(positions.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val3;
			if (visibilityGrid != null)
			{
				val3 = visibilityGrid.Check(positions, radii, val2);
			}
			else
			{
				GenerateAscSeqListJob generateAscSeqListJob = default(GenerateAscSeqListJob);
				generateAscSeqListJob.Values = val2;
				generateAscSeqListJob.Start = 0;
				generateAscSeqListJob.Step = 1;
				generateAscSeqListJob.Count = positions.Length;
				val3 = IJobExtensions.Schedule<GenerateAscSeqListJob>(generateAscSeqListJob, default(JobHandle));
			}
			((JobHandle)(ref val3)).Complete();
			if (!val2.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = positions;
				gatherJob.Indices = val2.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = val2.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				GamePhysics.CheckSpheres<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref results), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				Span<bool> values2 = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = val2.AsReadOnly();
				CollectionUtil.ScatterOutInplace(values2, ReadOnly<int>.op_Implicit(ref val4), defValue: false);
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetIgnoreIndirect(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> indices, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnoreIndirect", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> list = new NativeList<int>(indices.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val2 = default(JobHandle);
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.CheckIndirect(pos, radii, indices, list);
			}
			else
			{
				list.CopyFrom(in indices);
			}
			((JobHandle)(ref val2)).Complete();
			if (!list.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = pos;
				gatherJob.Indices = list.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = list.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				NativeArray<bool> val3 = default(NativeArray<bool>);
				val3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GamePhysics.CheckSpheres<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref val3), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				ReadOnlySpan<bool> from = NativeArray<bool>.op_Implicit(ref val3);
				Span<bool> to = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = list.AsReadOnly();
				CollectionUtil.ScatterTo(from, to, ReadOnly<int>.op_Implicit(ref val4));
				val3.Dispose();
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			list.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(Bounds bounds)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(bounds))
		{
			return false;
		}
		return GamePhysics.CheckBounds<WaterVisibilityTrigger>(bounds, 262144, (QueryTriggerInteraction)2);
	}

	public bool GetIgnore(Vector3 start, Vector3 end, float radius)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(start, end, radius))
		{
			return false;
		}
		return GamePhysics.CheckCapsule<WaterVisibilityTrigger>(start, end, radius, 262144, (QueryTriggerInteraction)2);
	}

	public void GetIgnoreIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnoreIndirect", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> list = new NativeList<int>(indices.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val2 = default(JobHandle);
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.CheckIndirect(starts, ends, radii, indices, list);
			}
			else
			{
				list.CopyFrom(in indices);
			}
			((JobHandle)(ref val2)).Complete();
			if (!list.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = starts;
				gatherJob.Indices = list.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<Vector3> results3 = default(NativeArray<Vector3>);
				results3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results3;
				gatherJob.Source = ends;
				gatherJob.Indices = list.AsReadOnly();
				GatherJob<Vector3> gatherJob3 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob3);
				NativeArray<float> results4 = default(NativeArray<float>);
				results4..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob4 = default(GatherJob<float>);
				gatherJob4.Results = results4;
				gatherJob4.Source = radii;
				gatherJob4.Indices = list.AsReadOnly();
				GatherJob<float> gatherJob5 = gatherJob4;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob5);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				NativeArray<bool> val3 = default(NativeArray<bool>);
				val3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GamePhysics.CheckCapsules<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), results4.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref val3), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None, mitigateSpheres: true);
				ReadOnlySpan<bool> from = NativeArray<bool>.op_Implicit(ref val3);
				Span<bool> to = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = list.AsReadOnly();
				CollectionUtil.ScatterTo(from, to, ReadOnly<int>.op_Implicit(ref val4));
				val3.Dispose();
				values.Dispose();
				results4.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			list.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(RaycastHit hit)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (waterColliders.Contains(((RaycastHit)(ref hit)).collider))
		{
			return GetIgnore(((RaycastHit)(ref hit)).point);
		}
		return false;
	}

	public bool GetIgnore(Collider collider)
	{
		if (waterColliders.Count == 0 || !Object.op_Implicit((Object)(object)collider))
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (waterColliders.Count == 0 || !Object.op_Implicit((Object)(object)collider))
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> list = new List<Collider> { trigger };
				HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Physics.IgnoreCollision(collider, enumerator.Current, true);
				}
				ignoredColliders.Add(collider, list);
			}
			return;
		}
		List<Collider> list2 = ignoredColliders[collider];
		if (ignore)
		{
			if (!list2.Contains(trigger))
			{
				list2.Add(trigger);
			}
		}
		else if (list2.Contains(trigger))
		{
			list2.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if ((Object)(object)key == (Object)null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Physics.IgnoreCollision(key, enumerator.Current, false);
				}
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class WaterCullingVolume : MonoBehaviour
{
	public bool isDynamic;
}


using UnityEngine;

public class WaterDepthMask : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class WaterInteraction : MonoBehaviour
{
	[SerializeField]
	private Texture2D texture;

	[Range(0f, 1f)]
	public float Displacement = 1f;

	[Range(0f, 1f)]
	public float Disturbance = 0.5f;
}


public enum WaterQuality
{
	Low,
	Medium,
	High
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Water5;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using WaterSystemJobs;

[ExecuteInEditMode]
public class WaterSystem : MonoBehaviour
{
	[Serializable]
	public class RenderingSettings
	{
		[Serializable]
		public class SkyProbe
		{
			public float ProbeUpdateInterval = 1f;

			public bool TimeSlicing = true;
		}

		[Serializable]
		public class SSR
		{
			public float FresnelCutoff = 0.02f;

			public float ThicknessMin = 1f;

			public float ThicknessMax = 20f;

			public float ThicknessStartDist = 40f;

			public float ThicknessEndDist = 100f;
		}

		public Vector4[] TessellationQuality;

		public SkyProbe SkyReflections;

		public SSR ScreenSpaceReflections;
	}

	private static float oceanLevel = 0f;

	[Header("Ocean Settings")]
	public OceanSettings oceanSettings;

	public OceanSimulation oceanSimulation;

	public WaterQuality Quality = WaterQuality.High;

	public Material oceanMaterial;

	public RenderingSettings Rendering = new RenderingSettings();

	public ComputeShader oceanVFaceShader;

	public int patchSize = 100;

	public int patchCount = 4;

	public float patchScale = 1f;

	public static WaterSystem Instance { get; private set; }

	public static WaterCollision Collision { get; private set; }

	public static WaterBody Ocean { get; private set; }

	public static Material OceanMaterial => Instance?.oceanMaterial;

	public static ListHashSet<WaterCamera> WaterCameras { get; } = new ListHashSet<WaterCamera>();

	public static HashSet<WaterBody> WaterBodies { get; } = new HashSet<WaterBody>();

	public static HashSet<WaterDepthMask> DepthMasks { get; } = new HashSet<WaterDepthMask>();

	public static float WaveTime { get; private set; }

	public static ComputeShader OceanVFaceShader => Instance?.oceanVFaceShader;

	public static float OceanLevel
	{
		get
		{
			return oceanLevel;
		}
		set
		{
			value = Mathf.Max(value, 0f);
			if (!Mathf.Approximately(oceanLevel, value))
			{
				oceanLevel = value;
				UpdateOceanLevel();
			}
		}
	}

	public bool IsInitialized { get; private set; }

	public int Layer => ((Component)this).gameObject.layer;

	public int Reflections => Water.reflections;

	public float WindDirection => oceanSettings.windDirection;

	public float[] OctaveScales => oceanSettings.octaveScales;

	private void CheckInstance()
	{
		Instance = (((Object)(object)Instance != (Object)null) ? Instance : this);
		Collision = (((Object)(object)Collision != (Object)null) ? Collision : ((Component)this).GetComponent<WaterCollision>());
	}

	private void Awake()
	{
		CheckInstance();
	}

	private void OnEnable()
	{
		CheckInstance();
		oceanSimulation = new OceanSimulation(oceanSettings);
		IsInitialized = true;
	}

	private void OnDisable()
	{
		if (!Application.isPlaying || !Application.isQuitting)
		{
			oceanSimulation.Dispose();
			oceanSimulation = null;
			IsInitialized = false;
			Instance = null;
		}
	}

	private void Update()
	{
		TimeWarning val = TimeWarning.New("UpdateWaves", 0);
		try
		{
			UpdateOceanSimulation();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Trace(Ray ray, out Vector3 position, float maxDist = 100f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			position = Vector3.zero;
			return false;
		}
		if (Instance.oceanSimulation.Trace(ray, maxDist, out position) && TerrainMeta.TopologyMap.GetTopology(position, 384))
		{
			return true;
		}
		return false;
	}

	public static bool Trace(Ray ray, out Vector3 position, out Vector3 normal, float maxDist = 100f)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			position = Vector3.zero;
			normal = Vector3.zero;
			return false;
		}
		normal = Vector3.up;
		if (Instance.oceanSimulation.Trace(ray, maxDist, out position) && TerrainMeta.TopologyMap.GetTopology(position, 384))
		{
			return true;
		}
		return false;
	}

	public static JobHandle ScheduleTraceBatchDefer(NativeList<Ray> rays, NativeArray<float> maxDists, NativeArray<bool> hitResults, NativeArray<Vector3> hitPositions, NativeArray<Vector3> hitNormals, JobHandle inputDeps)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			FillFalseJobDefer fillFalseJobDefer = default(FillFalseJobDefer);
			fillFalseJobDefer.rays = rays;
			fillFalseJobDefer.HitResults = hitResults;
			inputDeps = IJobParallelForDeferExtensions.Schedule<FillFalseJobDefer, Ray>(fillFalseJobDefer, rays, 256, inputDeps);
			return inputDeps;
		}
		inputDeps = Instance.oceanSimulation.TraceBatch(rays, maxDists, hitResults, hitPositions, inputDeps);
		AdjustByTopologyJob adjustByTopologyJob = default(AdjustByTopologyJob);
		adjustByTopologyJob.rays = rays;
		adjustByTopologyJob.hitResults = hitResults;
		adjustByTopologyJob.hitNormals = hitNormals;
		adjustByTopologyJob.hitPositions = hitPositions.AsReadOnly();
		adjustByTopologyJob.TopologyData = TerrainMeta.TopologyMap.src;
		adjustByTopologyJob.TopologyRes = TerrainMeta.TopologyMap.res;
		adjustByTopologyJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		adjustByTopologyJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		inputDeps = IJobParallelForDeferExtensions.Schedule<AdjustByTopologyJob, Ray>(adjustByTopologyJob, rays, 256, inputDeps);
		return inputDeps;
	}

	public static void GetHeightArray_Managed(Vector2[] pos, Vector2[] posUV, float[] shore, float[] terrainHeight, float[] waterHeight)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainTexturing.Instance != (Object)null)
		{
			for (int i = 0; i < posUV.Length; i++)
			{
				shore[i] = TerrainTexturing.Instance.GetCoarseDistanceToShore(posUV[i]);
			}
		}
		else
		{
			Array.Fill(shore, 0f, 0, posUV.Length);
		}
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			for (int j = 0; j < posUV.Length; j++)
			{
				terrainHeight[j] = TerrainMeta.HeightMap.GetHeightFast(posUV[j]);
			}
		}
		else
		{
			Array.Fill(terrainHeight, 0f, 0, posUV.Length);
		}
		if ((Object)(object)Instance != (Object)null && Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			bool flag = false;
			for (int k = 0; k < posUV.Length; k++)
			{
				Vector2 val = posUV[k];
				float num = TerrainMeta.WaterMap.GetHeightFast(val);
				if (num < OceanLevel + Instance.oceanSimulation.MaxLevel() && TerrainMeta.TopologyMap.GetTopology(val.x, val.y, 384))
				{
					if (!flag)
					{
						Instance.oceanSimulation.GetHeightBatch(pos, waterHeight, shore, terrainHeight);
						flag = true;
					}
					float num2 = waterHeight[k] + OceanLevel;
					num = Mathf.Max(num, num2);
				}
				waterHeight[k] = num;
			}
		}
		else if ((Object)(object)Instance != (Object)null)
		{
			Instance.oceanSimulation.GetHeightBatch(pos, waterHeight, shore, terrainHeight);
			for (int l = 0; l < pos.Length; l++)
			{
				waterHeight[l] += OceanLevel;
			}
		}
		else
		{
			Array.Fill(waterHeight, OceanLevel, 0, pos.Length);
		}
	}

	public static void GetHeightArray(Vector2[] pos, Vector2[] posUV, float[] shore, float[] terrainHeight, float[] waterHeight)
	{
		GetHeightArray_Managed(pos, posUV, shore, terrainHeight, waterHeight);
	}

	public static void RegisterBody(WaterBody body)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (body.Type == WaterBodyType.Ocean)
		{
			if ((Object)(object)Ocean == (Object)null)
			{
				Ocean = body;
				body.Transform.position = Vector3Ex.WithY(body.Transform.position, OceanLevel);
			}
			else if ((Object)(object)Ocean != (Object)(object)body)
			{
				Debug.LogWarning((object)"[Water] Ocean body is already registered. Ignoring call because only one is allowed.");
				return;
			}
		}
		WaterBodies.Add(body);
	}

	public static void UnregisterBody(WaterBody body)
	{
		if ((Object)(object)body == (Object)(object)Ocean)
		{
			Ocean = null;
		}
		WaterBodies.Remove(body);
	}

	private static void UpdateOceanLevel()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Ocean != (Object)null)
		{
			Ocean.Transform.position = Vector3Ex.WithY(Ocean.Transform.position, OceanLevel);
		}
		foreach (WaterBody waterBody in WaterBodies)
		{
			waterBody.OnOceanLevelChanged(OceanLevel);
		}
	}

	private void UpdateOceanSimulation()
	{
		if (Water.scaled_time)
		{
			WaveTime += Time.deltaTime;
		}
		else
		{
			WaveTime = Time.realtimeSinceStartup;
		}
		if (Weather.ocean_time >= 0f)
		{
			WaveTime = Weather.ocean_time;
		}
		float beaufort = (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance) ? SingletonComponent<Climate>.Instance.WeatherState.OceanScale : 4f);
		oceanSimulation?.Update(WaveTime, Time.deltaTime, beaufort);
	}

	public void Refresh()
	{
		oceanSimulation.Dispose();
		oceanSimulation = new OceanSimulation(oceanSettings);
	}

	private void EditorInitialize()
	{
	}

	private void EditorShutdown()
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class RenderingSettings
{
	[Serializable]
	public class SkyProbe
	{
		public float ProbeUpdateInterval = 1f;

		public bool TimeSlicing = true;
	}

	[Serializable]
	public class SSR
	{
		public float FresnelCutoff = 0.02f;

		public float ThicknessMin = 1f;

		public float ThicknessMax = 20f;

		public float ThicknessStartDist = 40f;

		public float ThicknessEndDist = 100f;
	}

	public Vector4[] TessellationQuality;

	public SkyProbe SkyReflections;

	public SSR ScreenSpaceReflections;
}


using System;

[Serializable]
public class SkyProbe
{
	public float ProbeUpdateInterval = 1f;

	public bool TimeSlicing = true;
}


using System;

[Serializable]
public class SSR
{
	public float FresnelCutoff = 0.02f;

	public float ThicknessMin = 1f;

	public float ThicknessMax = 20f;

	public float ThicknessStartDist = 40f;

	public float ThicknessEndDist = 100f;
}


using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class WaterVisibilityGrid : ICoarseQueryGridProvider, IDisposable
{
	private CoarseQueryGrid _queryGrid;

	private const int CellSize = 8;

	private readonly ListHashSet<WaterVisibilityTrigger> _dynamicListSet;

	public WaterVisibilityGrid()
	{
		_queryGrid = new CoarseQueryGrid(8, (int)(World.Size + 1000), -5f);
		_dynamicListSet = new ListHashSet<WaterVisibilityTrigger>();
	}

	public CoarseQueryGrid GetQueryGrid()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.PrepareForDynamicPopulate(_dynamicListSet.Count);
		Enumerator<WaterVisibilityTrigger> enumerator = _dynamicListSet.Values.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				WaterVisibilityTrigger current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && !((Object)(object)current.volume == (Object)null) && !((Object)(object)current.volume.trigger == (Object)null))
				{
					_queryGrid.AddDynamic(current.volume.trigger.bounds);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return _queryGrid;
	}

	public void AddTrigger(WaterVisibilityTrigger trigger)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (trigger.IsDynamic)
		{
			_dynamicListSet.Add(trigger);
		}
		else
		{
			_queryGrid.AddStatic(trigger.volume.trigger.bounds);
		}
	}

	public void RemoveTrigger(WaterVisibilityTrigger trigger)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (trigger.IsDynamic)
		{
			_dynamicListSet.Remove(trigger);
		}
		else
		{
			_queryGrid.RemoveStatic(trigger.volume.trigger.bounds);
		}
	}

	public bool Check(Bounds bounds)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(bounds);
	}

	public bool Check(Vector3 worldPosition, float radius)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(worldPosition, radius);
	}

	public JobHandle Check(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(positions, radii, results);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJobIndirect(positions, radii, indices, results);
	}

	public bool Check(Vector3 start, Vector3 end, float radius)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(start, end, radius);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJobIndirect(starts, ends, radii, indices, results);
	}

	public void Dispose()
	{
		_queryGrid.Dispose();
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class WaterVisibilityTrigger : EnvironmentVolumeTrigger
{
	public bool togglePhysics = true;

	public bool toggleVisuals = true;

	public bool IsDynamic;

	private long enteredTick;

	private static long ticks = 1L;

	private static SortedList<long, WaterVisibilityTrigger> tracker = new SortedList<long, WaterVisibilityTrigger>();

	public static void ResetTrackedTriggers()
	{
		ticks = 1L;
		tracker.Clear();
	}

	protected override void OnVolumeTriggerUpdate()
	{
		WaterSystem.Collision.VisibilityGrid.AddTrigger(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			WaterSystem.Collision.VisibilityGrid.RemoveTrigger(this);
		}
	}

	protected void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			tracker.Remove(enteredTick);
		}
	}

	private void ToggleVisibility()
	{
	}

	private void ResetVisibility()
	{
	}

	private void ToggleCollision(Collider other)
	{
		if (togglePhysics && (Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.SetIgnore(other, base.volume.trigger);
		}
	}

	private void ResetCollision(Collider other)
	{
		if (togglePhysics && (Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.SetIgnore(other, base.volume.trigger, ignore: false);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		bool num = (Object)(object)((Component)other).gameObject.GetComponent<PlayerWalkMovement>() != (Object)null;
		bool flag = ((Component)other).gameObject.CompareTag("MainCamera");
		if ((num || flag) && !tracker.ContainsValue(this))
		{
			enteredTick = ticks++;
			tracker.Add(enteredTick, this);
			ToggleVisibility();
		}
		if (!flag && !other.isTrigger)
		{
			ToggleCollision(other);
		}
	}

	protected void OnTriggerExit(Collider other)
	{
		bool num = (Object)(object)((Component)other).gameObject.GetComponent<PlayerWalkMovement>() != (Object)null;
		bool flag = ((Component)other).gameObject.CompareTag("MainCamera");
		if ((num || flag) && tracker.ContainsValue(this))
		{
			tracker.Remove(enteredTick);
			if (tracker.Count > 0)
			{
				bool flag2 = false;
				foreach (WaterVisibilityTrigger value in tracker.Values)
				{
					if (value.toggleVisuals)
					{
						flag2 = true;
						break;
					}
				}
				if (flag2)
				{
					tracker.Values[tracker.Count - 1].ToggleVisibility();
				}
				else
				{
					ResetVisibility();
				}
			}
			else
			{
				ResetVisibility();
			}
		}
		if (!flag && !other.isTrigger)
		{
			ResetCollision(other);
		}
	}
}


using System;
using UnityEngine;

public class WaterCheck : PrefabAttribute
{
	public bool Rotate = true;

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0f, 0f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}

	public bool Check(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return pos.y <= WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
	}

	protected override Type GetIndexedType()
	{
		return typeof(WaterCheck);
	}
}


using UnityEngine;

public static class WaterCheckEx
{
	public static bool ApplyWaterChecks(this Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		foreach (WaterCheck obj in anchors)
		{
			Vector3 val = Vector3.Scale(obj.worldPosition, scale);
			if (obj.Rotate)
			{
				val = rot * val;
			}
			Vector3 pos2 = pos + val;
			if (!obj.Check(pos2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class WaterCheckGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementDistance = 8f;

	public bool CheckRotate = true;
}


using UnityEngine;

[ExecuteInEditMode]
public class AdaptMeshToTerrain : MonoBehaviour
{
	public LayerMask LayerMask = LayerMask.op_Implicit(-1);

	public float RayHeight = 10f;

	public float RayMaxDistance = 20f;

	public float MinDisplacement = 0.01f;

	public float MaxDisplacement = 0.33f;

	[Range(8f, 64f)]
	public int PlaneResolution = 24;
}


using UnityEngine;

[ExecuteInEditMode]
public class AtmosphereVolume : MonoBehaviour
{
	public float MaxVisibleDistance = 750f;

	public float BoundsAttenuationDecay = 5f;

	public FogSettings FogSettings;
}


using System;
using UnityEngine;

[Serializable]
public struct FogSettings
{
	public Gradient ColorOverDaytime;

	public float Density;

	public float StartDistance;

	public float Height;

	public float HeightDensity;
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class AtmosphereVolumeRenderer : MonoBehaviour
{
	public FogMode Mode = (FogMode)3;

	public bool DistanceFog = true;

	public bool HeightFog = true;

	public AtmosphereVolume Volume;

	private static bool isSupported
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Invalid comparison between Unknown and I4
			if ((int)Application.platform != 0)
			{
				return (int)Application.platform != 1;
			}
			return false;
		}
	}
}


using System;
using UnityEngine.Rendering;

public class CommandBufferDesc
{
	public delegate void FillCommandBuffer(CommandBuffer cb);

	public CameraEvent CameraEvent { get; private set; }

	public int OrderId { get; private set; }

	public Action<CommandBuffer> FillDelegate { get; private set; }

	public CommandBufferDesc(CameraEvent cameraEvent, int orderId, FillCommandBuffer fill)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		CameraEvent = cameraEvent;
		OrderId = orderId;
		FillDelegate = fill.Invoke;
	}
}


using UnityEngine.Rendering;

public delegate void FillCommandBuffer(CommandBuffer cb);


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class CommandBufferManager : MonoBehaviour
{
}


using UnityEngine;

[ExecuteInEditMode]
public class DeferredDecal : MonoBehaviour
{
	public Mesh mesh;

	public Material material;

	public DeferredDecalQueue queue;

	public bool applyImmediately = true;
}


using UnityEngine;

[ExecuteInEditMode]
public class DeferredDecalRenderer : MonoBehaviour
{
}


using System;

[Serializable]
public enum DeferredDecalQueue
{
	Background,
	Foreground
}


using UnityEngine;

[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class BindRendererBounds : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class BindSubsurfaceProfile : MonoBehaviour
{
	public SubsurfaceProfile subsurfaceProfile;
}


using System;

[Serializable]
public struct SubsurfaceScatteringParams
{
	public enum Quality
	{
		Low,
		Medium,
		High
	}

	public bool enabled;

	public bool halfResolution;

	public float radiusScale;

	public static SubsurfaceScatteringParams Default = new SubsurfaceScatteringParams
	{
		enabled = true,
		halfResolution = true,
		radiusScale = 1f
	};
}


public enum Quality
{
	Low,
	Medium,
	High
}


using System;

[Serializable]
public struct ExtendGBufferParams
{
	public bool enabled;

	public static ExtendGBufferParams Default = new ExtendGBufferParams
	{
		enabled = false
	};
}


using System;
using UnityEngine;

[Serializable]
public struct ScreenSpaceRefractionParams
{
	[Range(0.001f, 1f)]
	public float screenWeightDistance;

	public static ScreenSpaceRefractionParams Default = new ScreenSpaceRefractionParams
	{
		screenWeightDistance = 0.1f
	};
}


using UnityEngine;

[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class DeferredExtension : MonoBehaviour
{
	public ExtendGBufferParams extendGBuffer = ExtendGBufferParams.Default;

	public SubsurfaceScatteringParams subsurfaceScattering = SubsurfaceScatteringParams.Default;

	public ScreenSpaceRefractionParams screenSpaceRefraction = ScreenSpaceRefractionParams.Default;

	public float depthScale = 100f;

	public bool debug;

	public bool forceToCameraResolution;

	public bool excludeMainLight;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Renderer))]
public class DeferredExtensionMesh : MonoBehaviour
{
	public SubsurfaceProfile subsurfaceProfile;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
public class DeferredIndirectLightingPass : MonoBehaviour
{
}


using UnityEngine;

public class SeparableSSS
{
	private static Vector3 Gaussian(float variance, float r, Color falloffColor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < 3; i++)
		{
			float num = r / (0.001f + ((Color)(ref falloffColor))[i]);
			((Vector3)(ref zero))[i] = Mathf.Exp((0f - num * num) / (2f * variance)) / (6.28f * variance);
		}
		return zero;
	}

	private static Vector3 Profile(float r, Color falloffColor)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		return 0.1f * Gaussian(0.0484f, r, falloffColor) + 0.118f * Gaussian(0.187f, r, falloffColor) + 0.113f * Gaussian(0.567f, r, falloffColor) + 0.358f * Gaussian(1.99f, r, falloffColor) + 0.078f * Gaussian(7.41f, r, falloffColor);
	}

	public static void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor)
	{
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		int num = targetSize * 2 - 1;
		float num2 = ((num > 20) ? 3f : 2f);
		float num3 = 2f;
		Color[] array = (Color[])(object)new Color[num];
		float num4 = 2f * num2 / (float)(num - 1);
		for (int i = 0; i < num; i++)
		{
			float num5 = 0f - num2 + (float)i * num4;
			float num6 = ((num5 < 0f) ? (-1f) : 1f);
			array[i].a = num2 * num6 * Mathf.Abs(Mathf.Pow(num5, num3)) / Mathf.Pow(num2, num3);
		}
		for (int j = 0; j < num; j++)
		{
			float num7 = ((j > 0) ? Mathf.Abs(array[j].a - array[j - 1].a) : 0f);
			float num8 = ((j < num - 1) ? Mathf.Abs(array[j].a - array[j + 1].a) : 0f);
			Vector3 val = (num7 + num8) / 2f * Profile(array[j].a, falloffColor);
			array[j].r = val.x;
			array[j].g = val.y;
			array[j].b = val.z;
		}
		Color val2 = array[num / 2];
		for (int num9 = num / 2; num9 > 0; num9--)
		{
			array[num9] = array[num9 - 1];
		}
		array[0] = val2;
		Vector3 zero = Vector3.zero;
		for (int k = 0; k < num; k++)
		{
			zero.x += array[k].r;
			zero.y += array[k].g;
			zero.z += array[k].b;
		}
		for (int l = 0; l < num; l++)
		{
			array[l].r /= zero.x;
			array[l].g /= zero.y;
			array[l].b /= zero.z;
		}
		target[targetStart] = array[0];
		for (uint num10 = 0u; num10 < targetSize - 1; num10++)
		{
			target[targetStart + num10 + 1] = array[targetSize + num10];
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct SubsurfaceProfileData
{
	[Range(0.1f, 100f)]
	public float ScatterRadius;

	[ColorUsage(false, false)]
	public Color SubsurfaceColor;

	[ColorUsage(false, false)]
	public Color FalloffColor;

	[ColorUsage(false, true)]
	public Color TransmissionTint;

	public static SubsurfaceProfileData Default
	{
		get
		{
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			SubsurfaceProfileData result = default(SubsurfaceProfileData);
			result.ScatterRadius = 1.2f;
			result.SubsurfaceColor = new Color(0.48f, 0.41f, 0.28f);
			result.FalloffColor = new Color(1f, 0.37f, 0.3f);
			result.TransmissionTint = new Color(0.48f, 0.41f, 0.28f);
			return result;
		}
	}

	public static SubsurfaceProfileData Invalid
	{
		get
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			SubsurfaceProfileData result = default(SubsurfaceProfileData);
			result.ScatterRadius = 0f;
			result.SubsurfaceColor = Color.clear;
			result.FalloffColor = Color.clear;
			result.TransmissionTint = Color.clear;
			return result;
		}
	}
}


using UnityEngine;

public class SubsurfaceProfile : ScriptableObject
{
	private static SubsurfaceProfileTexture profileTexture = new SubsurfaceProfileTexture();

	public SubsurfaceProfileData Data = SubsurfaceProfileData.Default;

	private int id = -1;

	public static Texture2D Texture
	{
		get
		{
			if (profileTexture == null)
			{
				return null;
			}
			return profileTexture.Texture;
		}
	}

	public static Vector4[] TransmissionTints
	{
		get
		{
			if (profileTexture == null)
			{
				return null;
			}
			return profileTexture.TransmissionTints;
		}
	}

	public int Id
	{
		get
		{
			return id;
		}
		set
		{
			id = value;
		}
	}

	private void OnEnable()
	{
		profileTexture.AddProfile(this);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SubsurfaceProfileTexture
{
	private struct SubsurfaceProfileEntry
	{
		public SubsurfaceProfileData data;

		public SubsurfaceProfile profile;

		public SubsurfaceProfileEntry(SubsurfaceProfileData data, SubsurfaceProfile profile)
		{
			this.data = data;
			this.profile = profile;
		}
	}

	public const int SUBSURFACE_PROFILE_COUNT = 16;

	public const int MAX_SUBSURFACE_PROFILES = 15;

	public const int SUBSURFACE_RADIUS_SCALE = 1024;

	public const int SUBSURFACE_KERNEL_SIZE = 3;

	private HashSet<SubsurfaceProfile> entries = new HashSet<SubsurfaceProfile>();

	private Texture2D texture;

	private Vector4[] transmissionTints = (Vector4[])(object)new Vector4[16];

	private const int KernelSize0 = 24;

	private const int KernelSize1 = 16;

	private const int KernelSize2 = 8;

	private const int KernelTotalSize = 49;

	private const int Width = 49;

	public Texture2D Texture
	{
		get
		{
			if ((Object)(object)texture == (Object)null)
			{
				CreateResources();
			}
			return texture;
		}
	}

	public Vector4[] TransmissionTints
	{
		get
		{
			if ((Object)(object)texture == (Object)null)
			{
				CreateResources();
			}
			return transmissionTints;
		}
	}

	public void AddProfile(SubsurfaceProfile profile)
	{
		entries.Add(profile);
		if (entries.Count > 15)
		{
			Debug.LogWarning((object)$"[SubsurfaceScattering] Maximum number of supported Subsurface Profiles has been reached ({entries.Count}/{15}). Please remove some.");
		}
		ReleaseResources();
	}

	public static Color Clamp(Color color, float min = 0f, float max = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Color result = default(Color);
		result.r = Mathf.Clamp(color.r, min, max);
		result.g = Mathf.Clamp(color.g, min, max);
		result.b = Mathf.Clamp(color.b, min, max);
		result.a = Mathf.Clamp(color.a, min, max);
		return result;
	}

	private void WriteKernel(ref Color[] pixels, ref Color[] kernel, int id, int y, in SubsurfaceProfileData data)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		Color val = Clamp(data.SubsurfaceColor);
		Color falloffColor = Clamp(data.FalloffColor, 0.009f);
		transmissionTints[id] = Color.op_Implicit(data.TransmissionTint);
		kernel[0] = val;
		kernel[0].a = data.ScatterRadius;
		SeparableSSS.CalculateKernel(kernel, 1, 24, val, falloffColor);
		SeparableSSS.CalculateKernel(kernel, 25, 16, val, falloffColor);
		SeparableSSS.CalculateKernel(kernel, 41, 8, val, falloffColor);
		int num = 49 * y;
		for (int i = 0; i < 49; i++)
		{
			Color val2 = kernel[i];
			val2.a *= ((i > 0) ? (data.ScatterRadius / 1024f) : 1f);
			pixels[num + i] = val2;
		}
	}

	private void CreateResources()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		if (entries.Count <= 0)
		{
			return;
		}
		int num = Mathf.Min(entries.Count, 15) + 1;
		ReleaseResources();
		texture = new Texture2D(49, num, (TextureFormat)17, false, true);
		((Object)texture).name = "SubsurfaceProfiles";
		((Texture)texture).wrapMode = (TextureWrapMode)1;
		((Texture)texture).filterMode = (FilterMode)1;
		Color[] pixels = texture.GetPixels(0);
		Color[] kernel = (Color[])(object)new Color[49];
		int num2 = num - 1;
		int id = 0;
		WriteKernel(ref pixels, ref kernel, id++, num2--, SubsurfaceProfileData.Default);
		foreach (SubsurfaceProfile entry in entries)
		{
			entry.Id = id;
			WriteKernel(ref pixels, ref kernel, id++, num2--, in entry.Data);
			if (num2 < 0)
			{
				break;
			}
		}
		texture.SetPixels(pixels, 0);
		texture.Apply(false, false);
	}

	public void ReleaseResources()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)texture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)texture);
			texture = null;
		}
		if (transmissionTints != null)
		{
			for (int i = 0; i < transmissionTints.Length; i++)
			{
				Vector4[] array = transmissionTints;
				int num = i;
				SubsurfaceProfileData @default = SubsurfaceProfileData.Default;
				array[num] = Color.op_Implicit(((Color)(ref @default.TransmissionTint)).linear);
			}
		}
	}
}


private struct SubsurfaceProfileEntry
{
	public SubsurfaceProfileData data;

	public SubsurfaceProfile profile;

	public SubsurfaceProfileEntry(SubsurfaceProfileData data, SubsurfaceProfile profile)
	{
		this.data = data;
		this.profile = profile;
	}
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Renderer))]
public class DeferredMeshDecal : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class DeferredMeshDecalRenderer : MonoBehaviour
{
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Environment Volume Properties")]
public class EnvironmentVolumeProperties : ScriptableObject
{
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Environment Volume Properties Collection")]
public class EnvironmentVolumePropertiesCollection : ScriptableObject
{
	[Serializable]
	public class EnvironmentMultiplier
	{
		public EnvironmentType Type;

		public float Multiplier;
	}

	[Serializable]
	public class OceanParameters
	{
		[Header("Lighting")]
		public AnimationCurve TransitionCurveLighting = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float DirectionalLightMultiplier = 0.25f;

		[Range(0f, 1f)]
		public float AmbientLightMultiplier;

		[Range(0f, 1f)]
		public float ReflectionMultiplier = 1f;

		[Header("Sun/Moon")]
		public AnimationCurve TransitionCurveSunMoon = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float SunMeshBrightnessMultiplier = 1f;

		[Range(0f, 1f)]
		public float MoonMeshBrightnessMultiplier = 1f;

		[Header("Atmosphere")]
		public AnimationCurve TransitionCurveAtmosphere = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float AtmosphereBrightnessMultiplier = 1f;

		[Header("Colors")]
		public AnimationCurve TransitionCurve = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float LightColorMultiplier = 1f;

		public Color LightColor = Color.black;

		[Range(0f, 1f)]
		public float SunRayColorMultiplier = 1f;

		public Color SunRayColor = Color.black;

		[Range(0f, 1f)]
		public float MoonRayColorMultiplier = 1f;

		public Color MoonRayColor = Color.black;
	}

	public float TransitionSpeed = 1f;

	public LayerMask ReflectionMask = LayerMask.op_Implicit(1084293120);

	[Horizontal(1, 0)]
	public EnvironmentMultiplier[] ReflectionMultipliers;

	public float DefaultReflectionMultiplier = 1f;

	[Horizontal(1, 0)]
	public EnvironmentMultiplier[] AmbientMultipliers;

	public float DefaultAmbientMultiplier = 1f;

	public OceanParameters OceanOverrides;
}


using System;

[Serializable]
public class EnvironmentMultiplier
{
	public EnvironmentType Type;

	public float Multiplier;
}


using System;
using UnityEngine;

[Serializable]
public class OceanParameters
{
	[Header("Lighting")]
	public AnimationCurve TransitionCurveLighting = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float DirectionalLightMultiplier = 0.25f;

	[Range(0f, 1f)]
	public float AmbientLightMultiplier;

	[Range(0f, 1f)]
	public float ReflectionMultiplier = 1f;

	[Header("Sun/Moon")]
	public AnimationCurve TransitionCurveSunMoon = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float SunMeshBrightnessMultiplier = 1f;

	[Range(0f, 1f)]
	public float MoonMeshBrightnessMultiplier = 1f;

	[Header("Atmosphere")]
	public AnimationCurve TransitionCurveAtmosphere = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float AtmosphereBrightnessMultiplier = 1f;

	[Header("Colors")]
	public AnimationCurve TransitionCurve = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float LightColorMultiplier = 1f;

	public Color LightColor = Color.black;

	[Range(0f, 1f)]
	public float SunRayColorMultiplier = 1f;

	public Color SunRayColor = Color.black;

	[Range(0f, 1f)]
	public float MoonRayColorMultiplier = 1f;

	public Color MoonRayColor = Color.black;
}


using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(DeferredIndirectLightingPass))]
[ExecuteInEditMode]
[RequireComponent(typeof(CommandBufferManager))]
public class SpatialEnvironmentVolumePass : MonoBehaviour
{
	private struct VolumeInfo
	{
		public Matrix4x4 InverseTransformation;

		public Vector4 boundsAndOcclusionFactor;

		public Vector4 positionAndShapeFlag;

		public Vector4 multipliersAndSunlightFlag;

		public Vector4 falloffPositive;

		public Vector4 falloffNegative;
	}

	private const int VOLUME_MASK_PASS_ID = 0;

	private const int VOLUME_OUTER_SHADING_PASS_ID = 1;

	private const int VOLUME_INNER_SHADING_PASS_ID = 2;

	private const int VOLUME_APPLY_TO_LIGHTING_PASS_ID = 3;

	private const CameraEvent VOLUME_RENDERING_CAMERA_EVENT = 6;

	private const int VOLUME_RENDERING_ORDER_ID = 1000;

	private static readonly int volumePropertiesId = Shader.PropertyToID("_VolumeProperties");

	private static readonly int volumeFalloffPositiveId = Shader.PropertyToID("_VolumeFalloffPositive");

	private static readonly int volumeFalloffNegativeId = Shader.PropertyToID("_VolumeFalloffNegative");

	private static readonly int envVolumeBufferId = Shader.PropertyToID("_EnvVolumeBuffer");

	private static readonly int numberOfVolumesId = Shader.PropertyToID("_NumberOfEnvironmentVolumes");

	private static readonly int volumeDepthStencilBuffer = Shader.PropertyToID("_VolumeDepthStencilBuffer");

	private static readonly int volumeRenderTarget = Shader.PropertyToID("_VolumeRenderTarget");

	private static readonly int inverseViewProjectionMatrixId = Shader.PropertyToID("_InvViewProjection");

	private static readonly int volumeInverseTransformationMatrixId = Shader.PropertyToID("_VolumeInvTransformation");

	private static EnvironmentVolumePropertiesCollection environmentVolumePropertiesStatic;

	[SerializeField]
	private Mesh cubeMesh;

	[SerializeField]
	private Mesh sphereMesh;

	[SerializeField]
	private Mesh capsuleMesh;

	[SerializeField]
	private Shader shader;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	[SerializeField]
	private Shader copyToDepthBufferShader;

	public static int VolumeInfoStride => 144;

	public bool IsInitialized { get; private set; }
}


using UnityEngine;

private struct VolumeInfo
{
	public Matrix4x4 InverseTransformation;

	public Vector4 boundsAndOcclusionFactor;

	public Vector4 positionAndShapeFlag;

	public Vector4 multipliersAndSunlightFlag;

	public Vector4 falloffPositive;

	public Vector4 falloffNegative;
}


using UnityEngine;

public class FoliageDisplacement : MonoBehaviour, IClientComponent, ILOD
{
	public bool moving;

	public bool billboard;

	public Mesh mesh;

	public Material material;
}


public class FoliageDisplacementManager : SingletonComponent<FoliageDisplacementManager>, IClientComponent
{
}


using UnityEngine;

[RequireComponent(typeof(MeshRenderer))]
[ExecuteInEditMode]
[RequireComponent(typeof(MeshFilter))]
public class Impostor : MonoBehaviour, IClientComponent, IPrefabPreProcess
{
	public ImpostorAsset asset;

	[Header("Baking")]
	public GameObject reference;

	public float angle;

	public int resolution = 1024;

	public int padding = 32;

	public bool spriteOutlineAsMesh;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private void OnEnable()
	{
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using System;
using UnityEngine;

public class ImpostorAsset : ScriptableObject
{
	[Serializable]
	public class TextureEntry
	{
		public string name;

		public Texture2D texture;

		public TextureEntry(string name, Texture2D texture)
		{
			this.name = name;
			this.texture = texture;
		}
	}

	public TextureEntry[] textures;

	public Vector2 size;

	public Vector2 pivot;

	public Mesh mesh;

	public Texture2D FindTexture(string name)
	{
		TextureEntry[] array = textures;
		foreach (TextureEntry textureEntry in array)
		{
			if (textureEntry.name == name)
			{
				return textureEntry.texture;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class TextureEntry
{
	public string name;

	public Texture2D texture;

	public TextureEntry(string name, Texture2D texture)
	{
		this.name = name;
		this.texture = texture;
	}
}


using UnityEngine;

public class ImpostorInstanceData
{
	public ImpostorBatch Batch;

	public int BatchIndex;

	private int hash;

	private Vector4 positionAndScale = Vector4.zero;

	public Renderer Renderer { get; private set; }

	public Mesh Mesh { get; private set; }

	public Material Material { get; private set; }

	public ImpostorInstanceData(Renderer renderer, Mesh mesh, Material material)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Renderer = renderer;
		Mesh = mesh;
		Material = material;
		hash = GenerateHashCode();
		Update();
	}

	public ImpostorInstanceData(Vector3 position, Vector3 scale, Mesh mesh, Material material)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		positionAndScale = new Vector4(position.x, position.y, position.z, scale.x);
		Mesh = mesh;
		Material = material;
		hash = GenerateHashCode();
		Update();
	}

	private int GenerateHashCode()
	{
		return (17 * 31 + ((object)Material).GetHashCode()) * 31 + ((object)Mesh).GetHashCode();
	}

	public override bool Equals(object obj)
	{
		ImpostorInstanceData impostorInstanceData = obj as ImpostorInstanceData;
		if ((Object)(object)impostorInstanceData.Material == (Object)(object)Material)
		{
			return (Object)(object)impostorInstanceData.Mesh == (Object)(object)Mesh;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return hash;
	}

	public Vector4 PositionAndScale()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Renderer != (Object)null)
		{
			Transform transform = ((Component)Renderer).transform;
			Vector3 position = transform.position;
			Vector3 lossyScale = transform.lossyScale;
			float num = (Renderer.enabled ? lossyScale.x : (0f - lossyScale.x));
			positionAndScale = new Vector4(position.x, position.y, position.z, num);
		}
		return positionAndScale;
	}

	public void Update()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (Batch != null)
		{
			Batch.Positions[BatchIndex] = PositionAndScale();
			Batch.IsDirty = true;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ImpostorBatch : IPooled
{
	public FPNativeList<Vector4> Positions;

	private FPNativeList<uint> args;

	private Queue<int> recycle = new Queue<int>(32);

	public Mesh Mesh { get; private set; }

	public Material Material { get; private set; }

	public ComputeBuffer PositionBuffer { get; private set; }

	public ComputeBuffer ArgsBuffer { get; private set; }

	public bool IsDirty { get; set; }

	public int Count => Positions.Count;

	public bool Visible => Positions.Count - recycle.Count > 0;

	private ComputeBuffer SafeRelease(ComputeBuffer buffer)
	{
		if (buffer != null)
		{
			buffer.Release();
		}
		return null;
	}

	public void Initialize(Mesh mesh, Material material)
	{
		Mesh = mesh;
		Material = material;
		args[0] = Mesh.GetIndexCount(0);
		args[2] = Mesh.GetIndexStart(0);
		args[3] = Mesh.GetBaseVertex(0);
	}

	void IPooled.LeavePool()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		Positions = Pool.Get<FPNativeList<Vector4>>();
		args = Pool.Get<FPNativeList<uint>>();
		args.Resize(5);
		ArgsBuffer = new ComputeBuffer(1, args.Count * 4, (ComputeBufferType)256);
	}

	void IPooled.EnterPool()
	{
		recycle.Clear();
		Pool.Free<FPNativeList<Vector4>>(ref Positions);
		Pool.Free<FPNativeList<uint>>(ref args);
		PositionBuffer = SafeRelease(PositionBuffer);
		ArgsBuffer.Release();
		ArgsBuffer = null;
	}

	public void AddInstance(ImpostorInstanceData data)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		data.Batch = this;
		if (recycle.Count > 0)
		{
			data.BatchIndex = recycle.Dequeue();
			Positions[data.BatchIndex] = data.PositionAndScale();
		}
		else
		{
			data.BatchIndex = Positions.Count;
			Positions.Add(data.PositionAndScale());
		}
		IsDirty = true;
	}

	public void RemoveInstance(ImpostorInstanceData data)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Positions[data.BatchIndex] = new Vector4(0f, 0f, 0f, -1f);
		recycle.Enqueue(data.BatchIndex);
		data.BatchIndex = 0;
		data.Batch = null;
		IsDirty = true;
	}

	public void UpdateBuffers()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Expected O, but got Unknown
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (IsDirty)
		{
			bool flag = false;
			if (PositionBuffer == null || PositionBuffer.count != Positions.Count)
			{
				PositionBuffer = SafeRelease(PositionBuffer);
				PositionBuffer = new ComputeBuffer(Positions.Count, 16);
				flag = true;
			}
			PositionBuffer.SetData<Vector4>(Positions.Array, 0, 0, Positions.Count);
			if (flag)
			{
				args[1] = (uint)Positions.Count;
				ArgsBuffer.SetData<uint>(args.Array, 0, 0, args.Count);
			}
			IsDirty = false;
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
public class ImpostorRenderer : MonoBehaviour
{
	public const string MainPassName = "DEFERRED";
}


using UnityEngine;

[RequireComponent(typeof(Light))]
public class ImpostorShadows : MonoBehaviour
{
}


using UnityEngine;

public class InstancedCameraComponent : MonoBehaviour
{
	public bool IsMirror;
}


using System;

public class InstancedEntityComponent : PrefabAttribute, IClientComponent
{
	public bool HideInsideNetworkRange;

	protected override Type GetIndexedType()
	{
		return typeof(InstancedEntityComponent);
	}
}


using System;
using Instancing;
using UnityEngine;

public class InstancedMeshFilter : PrefabAttribute, IClientComponent
{
	public MeshRenderer MeshRenderer;

	public RendererLOD RendererLOD;

	public MeshLOD MeshLOD;

	[NonSerialized]
	public InstancedMeshConfig Config;

	protected override Type GetIndexedType()
	{
		return typeof(InstancedMeshFilter);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class InstancedScheduler : SingletonComponent<InstancedScheduler>
{
	public ComputeShader CullShader;

	public ComputeShader SimplePostCullShader;

	public ComputeShader ClearBufferShader;

	public ComputeShader WriteIndirectArgsShader;

	public ComputeShader CopyMeshShader;

	public ConstructionSkin_ColourLookup ContainerColorLookup;

	public List<BuildingGrade> coloredSkins;
}


using System;

public class InstancingConfigComponent : PrefabAttribute, IClientComponent
{
	public bool DisableInstancing;

	protected override Type GetIndexedType()
	{
		return typeof(InstancingConfigComponent);
	}
}


using Instancing;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct PostCullingJob : IJob
{
	[ReadOnly]
	public NativeArray<int> CountPerMesh;

	[ReadOnly]
	public int RendererCount;

	[ReadOnly]
	public NativeArray<InstancedRendererJobData> Renderers;

	[WriteOnly]
	public JobInt PostCullMeshCount;

	[WriteOnly]
	public JobInt PostCullShadowCount;

	public void Execute()
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < RendererCount; i++)
		{
			InstancedRendererJobData instancedRendererJobData = Renderers[i];
			int num3 = CountPerMesh[i];
			if (instancedRendererJobData.HasShadow)
			{
				num2 += num3;
			}
			if (instancedRendererJobData.HasMesh)
			{
				num += num3;
			}
		}
		PostCullMeshCount.Value = num;
		PostCullShadowCount.Value = num2;
	}
}


using Unity.Mathematics;
using UnityEngine;

public static class Float4x4Ex
{
	public static float3 ToPosition(this float4x4 m)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((float4)(ref m.c3)).xyz;
	}

	public static Quaternion ToRotation(this float4x4 m)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(float3.op_Implicit(((float4)(ref m.c2)).xyz), float3.op_Implicit(((float4)(ref m.c1)).xyz));
	}
}


public class VirtualEntityScheduler
{
	public static VirtualEntityScheduler Instance { get; private set; } = new VirtualEntityScheduler();
}


using UnityEngine;

[ExecuteInEditMode]
public class LightCloneShadow : MonoBehaviour
{
	public bool cloneShadowMap;

	public bool cloneShadowMask;

	[Range(0f, 2f)]
	public int shadowMaskDownscale = 1;
}


using UnityEngine;

public class LiquidWobble : MonoBehaviour
{
	[Range(0f, 1f)]
	public float CurrentWaterLevelFraction;

	public float MinWaterLevel = -11f;

	public float MaxWaterLevel = 11f;

	public float MaxWobble = 0.03f;

	public float WobbleSpeed = 1f;

	public float Recovery = 1f;
}


using System;
using UnityEngine;

public struct MaterialPropertyDesc
{
	public int nameID;

	public Type type;

	public MaterialPropertyDesc(string name, Type type)
	{
		nameID = Shader.PropertyToID(name);
		this.type = type;
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MeshTerrainRoot : MonoBehaviour, IClientComponent
{
	public GameObject TerrainBlendSearchRoot;

	public Mesh TerrainMeshAsset;

	public Material TerrainMaterial;

	public Vector3 TerrainPos;

	public Vector3 TerrainSize;
}


using UnityEngine;

public class PlanarReflectionCamera : MonoBehaviour
{
	public static PlanarReflectionCamera instance;

	public float updateRate = 1f;

	public float nearClipPlane = 0.3f;

	public float farClipPlane = 25f;

	public Color fogColor = Color.white;

	public float fogDensity = 0.1f;

	public Mesh waterPlaneMesh;

	public Material waterPlaneMaterial;
}


using UnityEngine;

public class ReflectionPlane : DecayEntity
{
	private static readonly int _ColorTexID = Shader.PropertyToID("_ColorTex");

	private static readonly int _DepthTexID = Shader.PropertyToID("_DepthTex");

	private static readonly int _ReflectionLerpID = Shader.PropertyToID("_ReflectionLerp");

	[Header("Reflection Plane")]
	public LayerMask layerMask = LayerMask.op_Implicit(-1);

	public float nearClip;

	public float farClip;

	public Material reflectionMaterial;

	public Renderer reflectionRenderer;

	public float maxDistance;

	public float fadeTime = 0.25f;
}


public class MorphCache : FacepunchBehaviour
{
}


using UnityEngine;

public class ObjectMotionVectorFix : MonoBehaviour
{
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(CommandBufferManager))]
public class PostOpaqueDepth : MonoBehaviour
{
	public RenderTexture postOpaqueDepth;

	public RenderTexture PostOpaque => postOpaqueDepth;
}


using UnityEngine;

public class QuadDecal : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class ReflectionProbeEx : MonoBehaviour
{
	[Serializable]
	public enum ConvolutionQuality
	{
		Lowest,
		Low,
		Medium,
		High,
		VeryHigh
	}

	[Serializable]
	public struct RenderListEntry
	{
		public Renderer renderer;

		public bool alwaysEnabled;

		public RenderListEntry(Renderer renderer, bool alwaysEnabled)
		{
			this.renderer = renderer;
			this.alwaysEnabled = alwaysEnabled;
		}
	}

	private struct CubemapSkyboxVertex
	{
		public float x;

		public float y;

		public float z;

		public Color color;

		public float tu;

		public float tv;

		public float tw;
	}

	private struct CubemapFaceMatrices
	{
		public Matrix4x4 worldToView;

		public Matrix4x4 viewToWorld;

		public CubemapFaceMatrices(Vector3 x, Vector3 y, Vector3 z)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			worldToView = Matrix4x4.identity;
			((Matrix4x4)(ref worldToView))[0, 0] = ((Vector3)(ref x))[0];
			((Matrix4x4)(ref worldToView))[0, 1] = ((Vector3)(ref x))[1];
			((Matrix4x4)(ref worldToView))[0, 2] = ((Vector3)(ref x))[2];
			((Matrix4x4)(ref worldToView))[1, 0] = ((Vector3)(ref y))[0];
			((Matrix4x4)(ref worldToView))[1, 1] = ((Vector3)(ref y))[1];
			((Matrix4x4)(ref worldToView))[1, 2] = ((Vector3)(ref y))[2];
			((Matrix4x4)(ref worldToView))[2, 0] = ((Vector3)(ref z))[0];
			((Matrix4x4)(ref worldToView))[2, 1] = ((Vector3)(ref z))[1];
			((Matrix4x4)(ref worldToView))[2, 2] = ((Vector3)(ref z))[2];
			viewToWorld = ((Matrix4x4)(ref worldToView)).inverse;
		}
	}

	public ReflectionProbeRefreshMode refreshMode = (ReflectionProbeRefreshMode)1;

	public bool timeSlicing;

	public int resolution = 128;

	[InspectorName("HDR")]
	public bool hdr = true;

	public float shadowDistance;

	public ReflectionProbeClearFlags clearFlags = (ReflectionProbeClearFlags)1;

	public Color background = new Color(0.192f, 0.301f, 0.474f);

	public float nearClip = 0.3f;

	public float farClip = 1000f;

	public Transform attachToTarget;

	public Light directionalLight;

	public float textureMipBias = 2f;

	public bool highPrecision;

	public bool enableShadows;

	public ConvolutionQuality convolutionQuality;

	public List<RenderListEntry> staticRenderList = new List<RenderListEntry>();

	public Cubemap reflectionCubemap;

	public float reflectionIntensity = 1f;

	private Mesh blitMesh;

	private Mesh skyboxMesh;

	private static float[] octaVerts = new float[72]
	{
		0f, 1f, 0f, 0f, 0f, -1f, 1f, 0f, 0f, 0f,
		1f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, 1f,
		0f, 0f, 0f, 1f, -1f, 0f, 0f, 0f, 1f, 0f,
		-1f, 0f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 1f,
		0f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 0f, 0f,
		1f, 1f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 0f,
		0f, 0f, 1f, 0f, -1f, 0f, 0f, 0f, -1f, -1f,
		0f, 0f
	};

	private static readonly CubemapFaceMatrices[] cubemapFaceMatrices = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, -1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, 1f))
	};

	private static readonly CubemapFaceMatrices[] cubemapFaceMatricesD3D11 = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, 1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, -1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f))
	};

	private static readonly CubemapFaceMatrices[] shadowCubemapFaceMatrices = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, 1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, -1f))
	};

	private CubemapFaceMatrices[] platformCubemapFaceMatrices;

	private static readonly int[] tab32 = new int[32]
	{
		0, 9, 1, 10, 13, 21, 2, 29, 11, 14,
		16, 18, 22, 25, 3, 30, 8, 12, 20, 28,
		15, 17, 24, 7, 19, 27, 23, 6, 26, 5,
		4, 31
	};

	private void CreateMeshes()
	{
		if ((Object)(object)blitMesh == (Object)null)
		{
			blitMesh = CreateBlitMesh();
		}
		if ((Object)(object)skyboxMesh == (Object)null)
		{
			skyboxMesh = CreateSkyboxMesh();
		}
	}

	private void DestroyMeshes()
	{
		if ((Object)(object)blitMesh != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)blitMesh);
			blitMesh = null;
		}
		if ((Object)(object)skyboxMesh != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)skyboxMesh);
			skyboxMesh = null;
		}
	}

	private static Mesh CreateBlitMesh()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		val.vertices = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(-1f, -1f, 0f),
			new Vector3(-1f, 1f, 0f),
			new Vector3(1f, 1f, 0f),
			new Vector3(1f, -1f, 0f)
		};
		val.uv = (Vector2[])(object)new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		val.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		return val;
	}

	private static CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(v1.x, v1.y, v1.z);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(v2.x, v2.y, v2.z);
		Vector3 val3 = Vector3.Normalize(Vector3.Lerp(val, val2, 0.5f));
		CubemapSkyboxVertex result = default(CubemapSkyboxVertex);
		result.x = (result.tu = val3.x);
		result.y = (result.tv = val3.y);
		result.z = (result.tw = val3.z);
		result.color = Color.white;
		return result;
	}

	private static void Subdivide(List<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
	{
		CubemapSkyboxVertex item = SubDivVert(v1, v2);
		CubemapSkyboxVertex item2 = SubDivVert(v2, v3);
		CubemapSkyboxVertex item3 = SubDivVert(v1, v3);
		destArray.Add(v1);
		destArray.Add(item);
		destArray.Add(item3);
		destArray.Add(item);
		destArray.Add(v2);
		destArray.Add(item2);
		destArray.Add(item2);
		destArray.Add(item3);
		destArray.Add(item);
		destArray.Add(v3);
		destArray.Add(item3);
		destArray.Add(item2);
	}

	private static void SubdivideYOnly(List<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Abs(v2.y - v1.y);
		float num2 = Mathf.Abs(v2.y - v3.y);
		float num3 = Mathf.Abs(v3.y - v1.y);
		CubemapSkyboxVertex cubemapSkyboxVertex;
		CubemapSkyboxVertex cubemapSkyboxVertex2;
		CubemapSkyboxVertex cubemapSkyboxVertex3;
		if (num < num2 && num < num3)
		{
			cubemapSkyboxVertex = v3;
			cubemapSkyboxVertex2 = v1;
			cubemapSkyboxVertex3 = v2;
		}
		else if (num2 < num && num2 < num3)
		{
			cubemapSkyboxVertex = v1;
			cubemapSkyboxVertex2 = v2;
			cubemapSkyboxVertex3 = v3;
		}
		else
		{
			cubemapSkyboxVertex = v2;
			cubemapSkyboxVertex2 = v3;
			cubemapSkyboxVertex3 = v1;
		}
		CubemapSkyboxVertex item = SubDivVert(cubemapSkyboxVertex, cubemapSkyboxVertex2);
		CubemapSkyboxVertex item2 = SubDivVert(cubemapSkyboxVertex, cubemapSkyboxVertex3);
		destArray.Add(cubemapSkyboxVertex);
		destArray.Add(item);
		destArray.Add(item2);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(item2.x - cubemapSkyboxVertex2.x, item2.y - cubemapSkyboxVertex2.y, item2.z - cubemapSkyboxVertex2.z);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(item.x - cubemapSkyboxVertex3.x, item.y - cubemapSkyboxVertex3.y, item.z - cubemapSkyboxVertex3.z);
		if (val.x * val.x + val.y * val.y + val.z * val.z > val2.x * val2.x + val2.y * val2.y + val2.z * val2.z)
		{
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(cubemapSkyboxVertex3);
			destArray.Add(item2);
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex3);
		}
		else
		{
			destArray.Add(item2);
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(item2);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(cubemapSkyboxVertex3);
		}
	}

	private static Mesh CreateSkyboxMesh()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Expected O, but got Unknown
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		List<CubemapSkyboxVertex> list = new List<CubemapSkyboxVertex>();
		for (int i = 0; i < 24; i++)
		{
			CubemapSkyboxVertex item = default(CubemapSkyboxVertex);
			Vector3 val = Vector3.Normalize(new Vector3(octaVerts[i * 3], octaVerts[i * 3 + 1], octaVerts[i * 3 + 2]));
			item.x = (item.tu = val.x);
			item.y = (item.tv = val.y);
			item.z = (item.tw = val.z);
			item.color = Color.white;
			list.Add(item);
		}
		for (int j = 0; j < 3; j++)
		{
			List<CubemapSkyboxVertex> list2 = new List<CubemapSkyboxVertex>(list.Count);
			list2.AddRange(list);
			int count = list2.Count;
			list.Clear();
			list.Capacity = count * 4;
			for (int k = 0; k < count; k += 3)
			{
				Subdivide(list, list2[k], list2[k + 1], list2[k + 2]);
			}
		}
		for (int l = 0; l < 2; l++)
		{
			List<CubemapSkyboxVertex> list3 = new List<CubemapSkyboxVertex>(list.Count);
			list3.AddRange(list);
			int count2 = list3.Count;
			float num = Mathf.Pow(0.5f, (float)l + 1f);
			list.Clear();
			list.Capacity = count2 * 4;
			for (int m = 0; m < count2; m += 3)
			{
				if (Mathf.Max(Mathf.Max(Mathf.Abs(list3[m].y), Mathf.Abs(list3[m + 1].y)), Mathf.Abs(list3[m + 2].y)) > num)
				{
					list.Add(list3[m]);
					list.Add(list3[m + 1]);
					list.Add(list3[m + 2]);
				}
				else
				{
					SubdivideYOnly(list, list3[m], list3[m + 1], list3[m + 2]);
				}
			}
		}
		Mesh val2 = new Mesh();
		Vector3[] array = (Vector3[])(object)new Vector3[list.Count];
		Vector2[] array2 = (Vector2[])(object)new Vector2[list.Count];
		int[] array3 = new int[list.Count];
		for (int n = 0; n < list.Count; n++)
		{
			array[n] = new Vector3(list[n].x, list[n].y, list[n].z);
			array2[n] = Vector2.op_Implicit(new Vector3(list[n].tu, list[n].tv));
			array3[n] = n;
		}
		val2.vertices = array;
		val2.uv = array2;
		val2.triangles = array3;
		return val2;
	}

	private bool InitializeCubemapFaceMatrices()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Invalid comparison between Unknown and I4
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected I4, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		GraphicsDeviceType graphicsDeviceType = SystemInfo.graphicsDeviceType;
		if ((int)graphicsDeviceType != 2)
		{
			switch (graphicsDeviceType - 16)
			{
			case 1:
				platformCubemapFaceMatrices = cubemapFaceMatrices;
				break;
			case 2:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			case 5:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			case 0:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			default:
				platformCubemapFaceMatrices = null;
				break;
			}
		}
		else
		{
			platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
		}
		if (platformCubemapFaceMatrices == null)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogError((object)("[ReflectionProbeEx] Initialization failed. No cubemap ortho basis defined for " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString()));
			return false;
		}
		return true;
	}

	private int FastLog2(int value)
	{
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return tab32[(uint)((long)value * 130329821L) >> 27];
	}

	private uint ReverseBits(uint bits)
	{
		bits = (bits << 16) | (bits >> 16);
		bits = ((bits & 0xFF00FF) << 8) | ((bits & 0xFF00FF00u) >> 8);
		bits = ((bits & 0xF0F0F0F) << 4) | ((bits & 0xF0F0F0F0u) >> 4);
		bits = ((bits & 0x33333333) << 2) | ((bits & 0xCCCCCCCCu) >> 2);
		bits = ((bits & 0x55555555) << 1) | ((bits & 0xAAAAAAAAu) >> 1);
		return bits;
	}

	private void SafeCreateMaterial(ref Material mat, Shader shader)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		if ((Object)(object)mat == (Object)null)
		{
			mat = new Material(shader);
		}
	}

	private void SafeCreateMaterial(ref Material mat, string shaderName)
	{
		if ((Object)(object)mat == (Object)null)
		{
			SafeCreateMaterial(ref mat, Shader.Find(shaderName));
		}
	}

	private void SafeCreateCubeRT(ref RenderTexture rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite = 1)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Invalid comparison between Unknown and I4
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rt == (Object)null || !rt.IsCreated())
		{
			SafeDestroy<RenderTexture>(ref rt);
			rt = new RenderTexture(size, size, depth, format, readWrite)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).dimension = dim;
			if ((int)dim == 5)
			{
				rt.volumeDepth = 6;
			}
			rt.useMipMap = mips;
			rt.autoGenerateMips = false;
			((Texture)rt).filterMode = filter;
			((Texture)rt).anisoLevel = 0;
			rt.Create();
		}
	}

	private void SafeCreateCB(ref CommandBuffer cb, string name)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		if (cb == null)
		{
			cb = new CommandBuffer();
			cb.name = name;
		}
	}

	private void SafeDestroy<T>(ref T obj) where T : Object
	{
		if ((Object)(object)obj != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)obj);
			obj = default(T);
		}
	}

	private void SafeDispose<T>(ref T obj) where T : IDisposable
	{
		if (obj != null)
		{
			obj.Dispose();
			obj = default(T);
		}
	}
}


using System;

[Serializable]
public enum ConvolutionQuality
{
	Lowest,
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine;

[Serializable]
public struct RenderListEntry
{
	public Renderer renderer;

	public bool alwaysEnabled;

	public RenderListEntry(Renderer renderer, bool alwaysEnabled)
	{
		this.renderer = renderer;
		this.alwaysEnabled = alwaysEnabled;
	}
}


using UnityEngine;

private struct CubemapSkyboxVertex
{
	public float x;

	public float y;

	public float z;

	public Color color;

	public float tu;

	public float tv;

	public float tw;
}


using UnityEngine;

private struct CubemapFaceMatrices
{
	public Matrix4x4 worldToView;

	public Matrix4x4 viewToWorld;

	public CubemapFaceMatrices(Vector3 x, Vector3 y, Vector3 z)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		worldToView = Matrix4x4.identity;
		((Matrix4x4)(ref worldToView))[0, 0] = ((Vector3)(ref x))[0];
		((Matrix4x4)(ref worldToView))[0, 1] = ((Vector3)(ref x))[1];
		((Matrix4x4)(ref worldToView))[0, 2] = ((Vector3)(ref x))[2];
		((Matrix4x4)(ref worldToView))[1, 0] = ((Vector3)(ref y))[0];
		((Matrix4x4)(ref worldToView))[1, 1] = ((Vector3)(ref y))[1];
		((Matrix4x4)(ref worldToView))[1, 2] = ((Vector3)(ref y))[2];
		((Matrix4x4)(ref worldToView))[2, 0] = ((Vector3)(ref z))[0];
		((Matrix4x4)(ref worldToView))[2, 1] = ((Vector3)(ref z))[1];
		((Matrix4x4)(ref worldToView))[2, 2] = ((Vector3)(ref z))[2];
		viewToWorld = ((Matrix4x4)(ref worldToView)).inverse;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public static class CommandBufferEx
{
	public static void BlitArray(this CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int slice, int pass = 0)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		cb.SetGlobalTexture("_Source", source);
		cb.SetGlobalFloat("_SourceMip", 0f);
		if (slice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)slice);
			cb.SetGlobalInt("_TargetSlice", slice);
		}
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitArray(this CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Texture target, Material mat, int slice, int pass = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		cb.SetRenderTarget(RenderTargetIdentifier.op_Implicit(target), 0, (CubemapFace)(-1), -1);
		cb.SetGlobalTexture("_Source", source);
		cb.SetGlobalFloat("_SourceMip", 0f);
		if (slice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)slice);
			cb.SetGlobalInt("_TargetSlice", slice);
		}
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitArrayMip(this CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, int sourceSlice, Texture target, int targetMip, int targetSlice, Material mat, int pass = 0)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		int num = source.width >> sourceMip;
		int num2 = source.height >> sourceMip;
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(1f / (float)num, 1f / (float)num2, (float)num, (float)num2);
		int num3 = target.width >> targetMip;
		int num4 = target.height >> targetMip;
		Vector4 val2 = default(Vector4);
		((Vector4)(ref val2))..ctor(1f / (float)num3, 1f / (float)num4, (float)num3, (float)num4);
		cb.SetGlobalTexture("_Source", RenderTargetIdentifier.op_Implicit(source));
		cb.SetGlobalVector("_Source_TexelSize", val);
		cb.SetGlobalVector("_Target_TexelSize", val2);
		cb.SetGlobalFloat("_SourceMip", (float)sourceMip);
		if (sourceSlice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)sourceSlice);
			cb.SetGlobalInt("_TargetSlice", targetSlice);
		}
		cb.SetRenderTarget(RenderTargetIdentifier.op_Implicit(target), targetMip, (CubemapFace)(-1), -1);
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitMip(this CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, int slice, Material mat, int pass = 0)
	{
		cb.BlitArrayMip(blitMesh, source, mip, slice, target, mip, slice, mat, pass);
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteAlways]
public class SpatialBiomeFog : SingletonComponent<SpatialBiomeFog>
{
}


using UnityEngine;

public class TextureStreaming : SingletonComponent<MonoBehaviour>, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class VolumeClouds : SingletonComponent<VolumeClouds>
{
	public struct NoiseOffsets
	{
		public Vector2 CoverageBase;

		public Vector2 CoverageDetailPerlin;

		public Vector2 CoverageDetailWorley;

		public static NoiseOffsets Default(VolumeCloudsWeatherLayerConfig cfg)
		{
			NoiseOffsets result = default(NoiseOffsets);
			result.CoverageBase.x = cfg.CoverageBase.Offset.x;
			result.CoverageBase.y = cfg.CoverageBase.Offset.y;
			result.CoverageDetailPerlin.x = cfg.CoverageDetailPerlin.Offset.x;
			result.CoverageDetailPerlin.y = cfg.CoverageDetailPerlin.Offset.y;
			result.CoverageDetailWorley.x = cfg.CoverageDetailWorley.Offset.x;
			result.CoverageDetailWorley.y = cfg.CoverageDetailWorley.Offset.y;
			return result;
		}

		private static Vector2 RandVector(ref uint seed)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			float num = SeedRandom.Range(++seed, -100f, 100f);
			float num2 = SeedRandom.Range(++seed, -100f, 100f);
			return new Vector2(num, num2);
		}

		public static NoiseOffsets Random(uint seed)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			NoiseOffsets result = default(NoiseOffsets);
			result.CoverageBase = RandVector(ref seed);
			result.CoverageDetailPerlin = RandVector(ref seed);
			result.CoverageDetailWorley = RandVector(ref seed);
			return result;
		}
	}

	private static readonly int PID_DetailNoise = Shader.PropertyToID("_DetailNoise");

	private static readonly int PID_DetailScale = Shader.PropertyToID("_DetailScale");

	private static readonly int PID_Billows = Shader.PropertyToID("_Billows");

	private static readonly int PID_BillowsGamma = Shader.PropertyToID("_BillowsGamma");

	private static readonly int PID_BillowsFrequencyCurve = Shader.PropertyToID("_BillowsFrequencyCurve");

	private static readonly int PID_Wisps = Shader.PropertyToID("_Wisps");

	private static readonly int PID_WispsGamma = Shader.PropertyToID("_WispsGamma");

	private static readonly int PID_WispsFrequencyCurve = Shader.PropertyToID("_WispsFrequencyCurve");

	private static readonly int PID_DetailTypeDensityCurve = Shader.PropertyToID("_DetailTypeDensityCurve");

	private static readonly int PID_DetailTypeHeightTransition = Shader.PropertyToID("_DetailTypeHeightTransition");

	private static readonly int PID_WeatherMap = Shader.PropertyToID("_VolumeCloudsWeatherMap");

	private static readonly int PID_WeatherScale = Shader.PropertyToID("_VolumeCloudsWeatherMapScale");

	private static readonly int PID_Wind = Shader.PropertyToID("_VolumeCloudsWindVector");

	private static readonly int PID_Coverage = Shader.PropertyToID("_Coverage");

	private static readonly int PID_DensityScale = Shader.PropertyToID("_DensityScale");

	private static readonly int PID_DensityCurve = Shader.PropertyToID("_DensityCurve");

	private static readonly int PID_WispsDensitySoftening = Shader.PropertyToID("_WispsDensitySoftening");

	private static readonly int PID_MSIntensity = Shader.PropertyToID("_MSIntensity");

	private static readonly int PID_MSAbsorption = Shader.PropertyToID("_MSAbsorption");

	private static readonly int PID_MSMinDepth = Shader.PropertyToID("_MSMinDepth");

	private static readonly int PID_MSDepthFalloff = Shader.PropertyToID("_MSDepthFalloff");

	private static readonly int PID_Eccentricity = Shader.PropertyToID("_Eccentricity");

	private static readonly int PID_AmbientScatteringFalloff = Shader.PropertyToID("_AmbientScatteringFalloff");

	private static readonly int PID_ScatterBrightnessContrast = Shader.PropertyToID("_ScatterBrightnessContrast");

	private static readonly int PID_Absorption = Shader.PropertyToID("_Absorption");

	private static readonly int PID_CloudTypeTop = Shader.PropertyToID("_CloudTypeTop");

	private static readonly int PID_CloudTypeBottom = Shader.PropertyToID("_CloudTypeBottom");

	private static readonly int PID_MipDistance = Shader.PropertyToID("_MipDistance");

	private static readonly int PID_BlueNoise = Shader.PropertyToID("_BlueNoise");

	private static readonly int PID_CirrusOpaqueness = Shader.PropertyToID("_CirrusOpaqueness");

	private static readonly int PID_CirrusAbsorption = Shader.PropertyToID("_CirrusAbsorption");

	private static readonly int PID_CirrusEccentricity = Shader.PropertyToID("_CirrusEccentricity");

	private static readonly int PID_CirrusWeatherMap = Shader.PropertyToID("_CirrusWeatherMap");

	private static readonly int PID_CirrusWeatherMapScale = Shader.PropertyToID("_CirrusWeatherMapScale");

	private static readonly int PID_OutputTexture = Shader.PropertyToID("_OutputImage");

	private static readonly int PID_OutputImageSize = Shader.PropertyToID("_OutputImageSize");

	private static readonly int PID_CamPos = Shader.PropertyToID("_CamPos");

	private static readonly int PID_VolumeCloudTex = Shader.PropertyToID("_VolumeCloudTex");

	private static readonly int PID_VolumeCloudReflTex = Shader.PropertyToID("_VolumeCloudReflTex");

	private static readonly int PID_CloudTexSize = Shader.PropertyToID("_CloudTexSize");

	private static readonly int PID_FrameCount = Shader.PropertyToID("_FrameCount");

	private static readonly int PID_CamProjInv = Shader.PropertyToID("_CamProjInv");

	private static readonly int PID_StepCount = Shader.PropertyToID("_StepCount");

	private static readonly int PID_StepCountLow = Shader.PropertyToID("_StepCountLow");

	private static readonly int PID_VerticalProfileTopOffset = Shader.PropertyToID("_VerticalProfileTopOffset");

	private static readonly int PID_VerticalProfileTopScale = Shader.PropertyToID("_VerticalProfileTopScale");

	private static readonly int PID_VerticalProfileBottomOffset = Shader.PropertyToID("_VerticalProfileBottomOffset");

	private static readonly int PID_VerticalProfileBottomScale = Shader.PropertyToID("_VerticalProfileBottomScale");

	private static readonly int PID_WeatherScrollOffset = Shader.PropertyToID("_VolumeCloudsWeatherScrollOffset");

	private static readonly int PID_BlueNoiseOffset = Shader.PropertyToID("_BlueNoiseOffset");

	private static readonly int PID_RenderType = Shader.PropertyToID("_RenderType");

	private static readonly int PID_NumRadialLayers = Shader.PropertyToID("_NumRadialLayers");

	private static readonly int PID_LerpT = Shader.PropertyToID("_LerpT");

	private static readonly int PID_LerpSourceImage = Shader.PropertyToID("_LerpSourceImage");

	private static readonly int PID_LerpTargetImage = Shader.PropertyToID("_LerpTargetImage");

	private static readonly int PID_DepthBuffer = Shader.PropertyToID("_CloudDepthBuffer");

	private static readonly int PID_CamInvViewMatrix = Shader.PropertyToID("_CamInvViewMatrix");

	private static readonly int PID_PrevImage = Shader.PropertyToID("_PrevOutputImage");

	private static readonly int PID_LowResBuffer = Shader.PropertyToID("_LowResBuffer");

	private static readonly int PID_SizeDivisor = Shader.PropertyToID("_SizeDivisor");

	private static readonly int PID_ReprojectionMatrix = Shader.PropertyToID("_ReprojectionMatrix");

	private static readonly int PID_FirstFrame = Shader.PropertyToID("_FirstFrame");

	private static readonly int PID_CurrBlockOffsetX = Shader.PropertyToID("_CurrBlockOffsetX");

	private static readonly int PID_CurrBlockOffsetY = Shader.PropertyToID("_CurrBlockOffsetY");

	private static readonly int PID_ShadowInvViewProjMatrix = Shader.PropertyToID("_ShadowInvViewProjMatrix");

	private static readonly int PID_CloudShadowViewProj = Shader.PropertyToID("_CloudShadowViewProj");

	private static readonly int PID_CloudShadowMap = Shader.PropertyToID("_CloudShadowMap");

	private static readonly int PID_CloudShadowNearFar = Shader.PropertyToID("_CloudShadowNearFar");

	private static readonly int PID_SunColorScale = Shader.PropertyToID("_VolumeCloudsSunColorScale");

	private static readonly int PID_MoonColorScale = Shader.PropertyToID("_VolumeCloudsMoonColorScale");

	private static readonly int PID_AmbientColorScale = Shader.PropertyToID("_VolumeCloudsAmbientColorScale");

	private static readonly int PID_AmbientSaturation = Shader.PropertyToID("_VolumeCloudsAmbientSaturation");

	private static readonly int PID_MoonSaturation = Shader.PropertyToID("_VolumeCloudsMoonSaturation");

	private static readonly int PID_VolumeCloudsGroundRadius = Shader.PropertyToID("_VolumeCloudsGroundRadius");

	private static readonly int PID_CloudAmbientLight = Shader.PropertyToID("_CloudAmbientLight");

	private static readonly int PID_WindShear = Shader.PropertyToID("_WindShear");

	private static readonly int PID_ShadowDensityScale = Shader.PropertyToID("_VolumeCloudsShadowDensityScale");

	private static readonly int PID_AtmosphereShadowDensityScale = Shader.PropertyToID("_VolumeCloudsAtmosphereShadowDensityScale");

	private static readonly int PID_CloudHazeDensity = Shader.PropertyToID("_CloudHazeDensity");

	private static readonly int PID_CloudHazeHeightFalloff = Shader.PropertyToID("_CloudHazeHeightFalloff");

	private static readonly int PID_CloudHazeRampStartDistance = Shader.PropertyToID("_CloudHazeRampStartDistance");

	private static readonly int PID_CloudHazeRampEndDistance = Shader.PropertyToID("_CloudHazeRampEndDistance");

	private static readonly int PID_TODLerpValue = Shader.PropertyToID("_TOD_LerpValue");

	private static readonly int PID_HorizonBuffer = Shader.PropertyToID("_HorizonBuffer");

	private static readonly int PID_ApplySunContrast = Shader.PropertyToID("_VCloudsSunContrast");

	private static readonly int PID_ApplySunFogginess = Shader.PropertyToID("_VCloudsSunFogginess");

	private static readonly int PID_DetailScrollOffset = Shader.PropertyToID("_DetailScrollOffset");

	private int[,] PID_InstabilityParams;

	private int[,] PID_CoverageBaseParams;

	private int[,] PID_CoverageDetailParams;

	private int[,] PID_CoverageDetailWParams;

	private int[,] PID_RadialLayerParams;

	private int[,] PID_CurlNoiseParams;

	private void FetchShaderPropertyIDs()
	{
		char[] array = new char[4] { 'A', 'B', 'C', 'D' };
		PID_InstabilityParams = new int[4, 3];
		PID_CoverageBaseParams = new int[4, 3];
		PID_CoverageDetailParams = new int[4, 3];
		PID_CoverageDetailWParams = new int[4, 2];
		PID_RadialLayerParams = new int[3, 2];
		PID_CurlNoiseParams = new int[4, 1];
		for (int i = 0; i < 4; i++)
		{
			PID_InstabilityParams[i, 0] = Shader.PropertyToID($"_InstabilityParams{array[i]}0");
			PID_InstabilityParams[i, 1] = Shader.PropertyToID($"_InstabilityParams{array[i]}1");
			PID_InstabilityParams[i, 2] = Shader.PropertyToID($"_InstabilityParams{array[i]}2");
			PID_CoverageBaseParams[i, 0] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}0");
			PID_CoverageBaseParams[i, 1] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}1");
			PID_CoverageBaseParams[i, 2] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}2");
			PID_CoverageDetailParams[i, 0] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}0");
			PID_CoverageDetailParams[i, 1] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}1");
			PID_CoverageDetailParams[i, 2] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}2");
			PID_CoverageDetailWParams[i, 0] = Shader.PropertyToID($"_CoverageDetailWParams{array[i]}0");
			PID_CoverageDetailWParams[i, 1] = Shader.PropertyToID($"_CoverageDetailWParams{array[i]}1");
			PID_CurlNoiseParams[i, 0] = Shader.PropertyToID($"_CurlParams{array[i]}0");
		}
		for (int j = 0; j < 3; j++)
		{
			PID_RadialLayerParams[j, 0] = Shader.PropertyToID($"_RadialLayerParams{array[j]}0");
			PID_RadialLayerParams[j, 1] = Shader.PropertyToID($"_RadialLayerParams{array[j]}1");
		}
	}
}


using UnityEngine;

public struct NoiseOffsets
{
	public Vector2 CoverageBase;

	public Vector2 CoverageDetailPerlin;

	public Vector2 CoverageDetailWorley;

	public static NoiseOffsets Default(VolumeCloudsWeatherLayerConfig cfg)
	{
		NoiseOffsets result = default(NoiseOffsets);
		result.CoverageBase.x = cfg.CoverageBase.Offset.x;
		result.CoverageBase.y = cfg.CoverageBase.Offset.y;
		result.CoverageDetailPerlin.x = cfg.CoverageDetailPerlin.Offset.x;
		result.CoverageDetailPerlin.y = cfg.CoverageDetailPerlin.Offset.y;
		result.CoverageDetailWorley.x = cfg.CoverageDetailWorley.Offset.x;
		result.CoverageDetailWorley.y = cfg.CoverageDetailWorley.Offset.y;
		return result;
	}

	private static Vector2 RandVector(ref uint seed)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		float num = SeedRandom.Range(++seed, -100f, 100f);
		float num2 = SeedRandom.Range(++seed, -100f, 100f);
		return new Vector2(num, num2);
	}

	public static NoiseOffsets Random(uint seed)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		NoiseOffsets result = default(NoiseOffsets);
		result.CoverageBase = RandVector(ref seed);
		result.CoverageDetailPerlin = RandVector(ref seed);
		result.CoverageDetailWorley = RandVector(ref seed);
		return result;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Cirrus Config")]
public class VolumeCloudsCirrusConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig WeatherLayer = new VolumeCloudsWeatherLayerConfig();

	public float Opaqueness = 1f;

	public float Absorption = 0.2f;

	public float Eccentricity = 0.3f;

	public float CloudTextureGamma = 1f;

	public float CloudTextureScale = 1f;

	public void CopyWeatherGen(VolumeCloudsCirrusConfig copy)
	{
		WeatherLayer.CopyFrom(copy.WeatherLayer);
	}

	public void CopyFrom(VolumeCloudsCirrusConfig copy)
	{
		CopyWeatherGen(copy);
		Opaqueness = copy.Opaqueness;
		Absorption = copy.Absorption;
		Eccentricity = copy.Eccentricity;
		CloudTextureGamma = copy.CloudTextureGamma;
		CloudTextureScale = copy.CloudTextureScale;
	}

	public void Lerp(VolumeCloudsCirrusConfig a, VolumeCloudsCirrusConfig b, float t)
	{
		Opaqueness = Mathf.Lerp(a.Opaqueness, b.Opaqueness, t);
		Absorption = Mathf.Lerp(a.Absorption, b.Absorption, t);
		Eccentricity = Mathf.Lerp(a.Eccentricity, b.Eccentricity, t);
		CloudTextureGamma = Mathf.Lerp(a.CloudTextureGamma, b.CloudTextureGamma, t);
		CloudTextureScale = Mathf.Lerp(a.CloudTextureScale, b.CloudTextureScale, t);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Cloud Config")]
public class VolumeCloudsConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig WeatherLayer = new VolumeCloudsWeatherLayerConfig();

	[Header("Detail")]
	[Range(0f, 1f)]
	public float Billows = 1f;

	[Range(0f, 3f)]
	public float BillowsGamma = 2f;

	[Range(0f, 2f)]
	public float BillowsFrequencyCurve = 0.45f;

	[Range(0f, 1f)]
	public float Wisps = 1f;

	[Range(0f, 3f)]
	public float WispsGamma = 2f;

	[Range(0f, 2f)]
	public float WispsFrequencyCurve = 1f;

	[Range(0f, 2f)]
	public float DetailTypeDensityCurve = 0.25f;

	[Range(0.001f, 1f)]
	public float DetailTypeHeightTransition = 0.3f;

	[Range(0f, 2f)]
	public float CurlNoiseScale = 0.2f;

	public float CurlNoiseStrength = 50f;

	[Header("Density")]
	[Range(0f, 1f)]
	public float DensityScale = 0.05f;

	[Range(0f, 1f)]
	public float DensityCurve = 0.4f;

	[Range(0f, 1f)]
	public float WispsDensitySoftening = 0.3f;

	[Header("Multiple Scattering")]
	public float MSIntensity = 1f;

	[Range(0f, 1f)]
	public float MSAbsorption = 0.5f;

	[Range(0f, 2f)]
	public float MSDepthFalloff = 1f;

	[Range(0f, 1f)]
	public float MSMinDepth = 0.01f;

	[Header("Direct Scattering")]
	public Gradient SunColorScale;

	[Range(-1f, 1f)]
	public float SunEccentricity1 = 0.6f;

	[Range(-1f, 1f)]
	public float SunEccentricity2 = 0.2f;

	public Gradient MoonColorScale;

	[Range(-1f, 1f)]
	public float MoonEccentricity1 = 0.9f;

	[Range(-1f, 1f)]
	public float MoonEccentricity2 = 0.2f;

	[Range(0f, 2f)]
	public float MoonSaturation = 1f;

	[Range(0f, 3f)]
	public float DirectScatterBrightness = 1f;

	[Range(0f, 3f)]
	public float DirectScatterContrast = 1f;

	[Range(0f, 2f)]
	public float Absorption = 1f;

	[Header("Ambient Scattering")]
	public Gradient AmbientColorScale;

	[Range(0f, 1f)]
	public float AmbientSaturation = 0.6f;

	[Range(0f, 2f)]
	public float AmbientScatteringFalloff = 1f;

	[Range(0f, 3f)]
	public float AmbientScatterBrightness = 1f;

	[Range(0f, 3f)]
	public float AmbientScatterContrast = 1f;

	[Header("Other")]
	[Range(0f, 1f)]
	public float CoverageScale = 1f;

	[Range(0f, 1f)]
	public float CloudTypeTop = 1f;

	[Range(0f, 1f)]
	public float CloudTypeBottom;

	[Range(0f, 1f)]
	public float VerticalProfileTopEnd = 1f;

	[Range(0f, 1f)]
	public float VerticalProfileTopStart;

	[Range(0f, 1f)]
	public float VerticalProfileBottomStart = 1f;

	[Range(0f, 1f)]
	public float VerticalProfileBottomEnd;

	public float WindShear;

	public Vector2 WindVector = new Vector2(0f, 1f);

	[Range(0f, 1f)]
	public float ShadowDensityScale = 1f;

	[Range(0f, 1f)]
	public float AtmosphereShadowDensityScale = 1f;

	[Min(0f)]
	public float HazeDensity = 1f;

	[Min(0f)]
	public float HazeHeightFalloff = 0.035f;

	[Range(0f, 1f)]
	public float HorizonBuffer;

	public float EvalSunColorScale { get; set; }

	public float EvalMoonColorScale { get; set; }

	public float EvalAmbientColorScale { get; set; }

	public void CopyWeatherGen(VolumeCloudsConfig copy)
	{
		WeatherLayer.CopyFrom(copy.WeatherLayer);
	}

	public void CopyFrom(VolumeCloudsConfig copy)
	{
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		CopyWeatherGen(copy);
		Billows = copy.Billows;
		BillowsGamma = copy.BillowsGamma;
		BillowsFrequencyCurve = copy.BillowsFrequencyCurve;
		Wisps = copy.Wisps;
		WispsGamma = copy.WispsGamma;
		WispsFrequencyCurve = copy.WispsFrequencyCurve;
		DetailTypeDensityCurve = copy.DetailTypeDensityCurve;
		DetailTypeHeightTransition = copy.DetailTypeHeightTransition;
		CurlNoiseScale = copy.CurlNoiseScale;
		CurlNoiseStrength = copy.CurlNoiseStrength;
		DensityScale = copy.DensityScale;
		DensityCurve = copy.DensityCurve;
		WispsDensitySoftening = copy.WispsDensitySoftening;
		SunEccentricity1 = copy.SunEccentricity1;
		SunEccentricity2 = copy.SunEccentricity2;
		AmbientScatteringFalloff = copy.AmbientScatteringFalloff;
		Absorption = copy.Absorption;
		SunColorScale.SetKeys(copy.SunColorScale.colorKeys, copy.SunColorScale.alphaKeys);
		AmbientColorScale.SetKeys(copy.AmbientColorScale.colorKeys, copy.AmbientColorScale.alphaKeys);
		AmbientSaturation = copy.AmbientSaturation;
		CoverageScale = copy.CoverageScale;
		MSIntensity = copy.MSIntensity;
		MSAbsorption = copy.MSAbsorption;
		MSDepthFalloff = copy.MSDepthFalloff;
		MSMinDepth = copy.MSMinDepth;
		CloudTypeTop = copy.CloudTypeTop;
		CloudTypeBottom = copy.CloudTypeBottom;
		MoonColorScale.SetKeys(copy.MoonColorScale.colorKeys, copy.MoonColorScale.alphaKeys);
		MoonEccentricity1 = copy.MoonEccentricity1;
		MoonEccentricity2 = copy.MoonEccentricity2;
		MoonSaturation = copy.MoonSaturation;
		VerticalProfileTopEnd = copy.VerticalProfileTopEnd;
		VerticalProfileTopStart = copy.VerticalProfileTopStart;
		VerticalProfileBottomStart = copy.VerticalProfileBottomStart;
		VerticalProfileBottomEnd = copy.VerticalProfileBottomEnd;
		DirectScatterBrightness = copy.DirectScatterBrightness;
		DirectScatterContrast = copy.DirectScatterContrast;
		AmbientScatterBrightness = copy.AmbientScatterBrightness;
		AmbientScatterContrast = copy.AmbientScatterContrast;
		WindShear = copy.WindShear;
		WindVector = copy.WindVector;
		ShadowDensityScale = copy.ShadowDensityScale;
		AtmosphereShadowDensityScale = copy.AtmosphereShadowDensityScale;
		HazeDensity = copy.HazeDensity;
		HazeHeightFalloff = copy.HazeHeightFalloff;
		HorizonBuffer = copy.HorizonBuffer;
		EvalSunColorScale = copy.EvalSunColorScale;
		EvalMoonColorScale = copy.EvalMoonColorScale;
		EvalAmbientColorScale = copy.EvalAmbientColorScale;
	}

	public void Lerp(VolumeCloudsConfig a, VolumeCloudsConfig b, float t)
	{
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		Billows = Mathf.Lerp(a.Billows, b.Billows, t);
		BillowsGamma = Mathf.Lerp(a.BillowsGamma, b.BillowsGamma, t);
		BillowsFrequencyCurve = Mathf.Lerp(a.BillowsFrequencyCurve, b.BillowsFrequencyCurve, t);
		Wisps = Mathf.Lerp(a.Wisps, b.Wisps, t);
		WispsGamma = Mathf.Lerp(a.WispsGamma, b.WispsGamma, t);
		WispsFrequencyCurve = Mathf.Lerp(a.WispsFrequencyCurve, b.WispsFrequencyCurve, t);
		DetailTypeDensityCurve = Mathf.Lerp(a.DetailTypeDensityCurve, b.DetailTypeDensityCurve, t);
		DetailTypeHeightTransition = Mathf.Lerp(a.DetailTypeHeightTransition, b.DetailTypeHeightTransition, t);
		CurlNoiseScale = Mathf.Lerp(a.CurlNoiseScale, b.CurlNoiseScale, t);
		CurlNoiseStrength = Mathf.Lerp(a.CurlNoiseStrength, b.CurlNoiseStrength, t);
		DensityScale = Mathf.Lerp(a.DensityScale, b.DensityScale, t);
		DensityCurve = Mathf.Lerp(a.DensityCurve, b.DensityCurve, t);
		WispsDensitySoftening = Mathf.Lerp(a.WispsDensitySoftening, b.WispsDensitySoftening, t);
		MSIntensity = Mathf.Lerp(a.MSIntensity, b.MSIntensity, t);
		MSAbsorption = Mathf.Lerp(a.MSAbsorption, b.MSAbsorption, t);
		MSDepthFalloff = Mathf.Lerp(a.MSDepthFalloff, b.MSDepthFalloff, t);
		MSMinDepth = Mathf.Lerp(a.MSMinDepth, b.MSMinDepth, t);
		SunEccentricity1 = Mathf.Lerp(a.SunEccentricity1, b.SunEccentricity1, t);
		SunEccentricity2 = Mathf.Lerp(a.SunEccentricity2, b.SunEccentricity2, t);
		EvalAmbientColorScale = Mathf.Lerp(a.EvalAmbientColorScale, b.EvalAmbientColorScale, t);
		EvalSunColorScale = Mathf.Lerp(a.EvalSunColorScale, b.EvalSunColorScale, t);
		EvalMoonColorScale = Mathf.Lerp(a.EvalMoonColorScale, b.EvalMoonColorScale, t);
		AmbientSaturation = Mathf.Lerp(a.AmbientSaturation, b.AmbientSaturation, t);
		AmbientScatteringFalloff = Mathf.Lerp(a.AmbientScatteringFalloff, b.AmbientScatteringFalloff, t);
		Absorption = Mathf.Lerp(a.Absorption, b.Absorption, t);
		CoverageScale = Mathf.Lerp(a.CoverageScale, b.CoverageScale, t);
		CloudTypeTop = Mathf.Lerp(a.CloudTypeTop, b.CloudTypeTop, t);
		CloudTypeBottom = Mathf.Lerp(a.CloudTypeBottom, b.CloudTypeBottom, t);
		MoonEccentricity1 = Mathf.Lerp(a.MoonEccentricity1, b.MoonEccentricity1, t);
		MoonEccentricity2 = Mathf.Lerp(a.MoonEccentricity2, b.MoonEccentricity2, t);
		MoonSaturation = Mathf.Lerp(a.MoonSaturation, b.MoonSaturation, t);
		DirectScatterBrightness = Mathf.Lerp(a.DirectScatterBrightness, b.DirectScatterBrightness, t);
		DirectScatterContrast = Mathf.Lerp(a.DirectScatterContrast, b.DirectScatterContrast, t);
		AmbientScatterBrightness = Mathf.Lerp(a.AmbientScatterBrightness, b.AmbientScatterBrightness, t);
		AmbientScatterContrast = Mathf.Lerp(a.AmbientScatterContrast, b.AmbientScatterContrast, t);
		VerticalProfileTopStart = Mathf.Lerp(a.VerticalProfileTopStart, b.VerticalProfileTopStart, t);
		VerticalProfileTopEnd = Mathf.Lerp(a.VerticalProfileTopEnd, b.VerticalProfileTopEnd, t);
		VerticalProfileBottomStart = Mathf.Lerp(a.VerticalProfileBottomStart, b.VerticalProfileBottomStart, t);
		VerticalProfileBottomEnd = Mathf.Lerp(a.VerticalProfileBottomEnd, b.VerticalProfileBottomEnd, t);
		WindShear = Mathf.Lerp(a.WindShear, b.WindShear, t);
		WindVector = Vector2.Lerp(a.WindVector, b.WindVector, t);
		ShadowDensityScale = Mathf.Lerp(a.ShadowDensityScale, b.ShadowDensityScale, t);
		AtmosphereShadowDensityScale = Mathf.Lerp(a.AtmosphereShadowDensityScale, b.AtmosphereShadowDensityScale, t);
		HazeDensity = Mathf.Lerp(a.HazeDensity, b.HazeDensity, t);
		HazeHeightFalloff = Mathf.Lerp(a.HazeHeightFalloff, b.HazeHeightFalloff, t);
		HorizonBuffer = Mathf.Lerp(a.HorizonBuffer, b.HorizonBuffer, t);
	}
}


using System;
using System.Text;
using UnityEngine;

[Serializable]
public class VolumeCloudsNoiseLayerConfig
{
	[Range(0f, 6f)]
	public float Ceiling = 1f;

	[Range(-5f, 1f)]
	public float Floor;

	public Vector2 Frequency = Vector2.one;

	public Vector3 Offset = Vector3.zero;

	public int Octaves = 1;

	public float Rotation;

	[Range(0.001f, 10f)]
	public float Exponent = 1f;

	public void CopyFrom(VolumeCloudsNoiseLayerConfig copy)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Floor = copy.Floor;
		Ceiling = copy.Ceiling;
		Frequency = copy.Frequency;
		Offset = copy.Offset;
		Octaves = copy.Octaves;
		Rotation = copy.Rotation;
		Exponent = copy.Exponent;
	}

	public void Lerp(VolumeCloudsNoiseLayerConfig a, VolumeCloudsNoiseLayerConfig b, float t)
	{
		Floor = Mathf.SmoothStep(a.Floor, b.Floor, t);
		Ceiling = Mathf.SmoothStep(a.Ceiling, b.Ceiling, t);
		Frequency.x = Mathf.SmoothStep(a.Frequency.x, b.Frequency.x, t);
		Frequency.y = Mathf.SmoothStep(a.Frequency.y, b.Frequency.y, t);
		Offset.x = Mathf.SmoothStep(a.Offset.x, b.Offset.x, t);
		Offset.y = Mathf.SmoothStep(a.Offset.y, b.Offset.y, t);
		Offset.z = Mathf.SmoothStep(a.Offset.z, b.Offset.z, t);
		Rotation = Mathf.SmoothStep(a.Rotation, b.Rotation, t);
		Exponent = Mathf.SmoothStep(a.Exponent, b.Exponent, t);
	}

	public void Output(StringBuilder sb, Vector2 ofs)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		sb.AppendLine($"Ceiling: {Ceiling}");
		sb.AppendLine($"Floor: {Floor}");
		sb.AppendLine($"Freq: {Frequency}");
		sb.AppendLine($"Offset: {ofs}");
		sb.AppendLine($"Octaves: {Octaves}");
		sb.AppendLine($"Exp: {Exponent}");
	}
}


using System;
using UnityEngine;

[Serializable]
public class VolumeCloudsCurlNoiseConfig
{
	public Vector2 Frequency = Vector2.one;

	public float Strength;

	public int Octaves = 1;

	public void CopyFrom(VolumeCloudsCurlNoiseConfig copy)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Frequency = copy.Frequency;
		Strength = copy.Strength;
		Octaves = copy.Octaves;
	}
}


using System;
using System.Text;

[Serializable]
public class VolumeCloudsWeatherLayerConfig
{
	public VolumeCloudsNoiseLayerConfig Instability = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageBase = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageDetailPerlin = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageDetailWorley = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsCurlNoiseConfig Curl = new VolumeCloudsCurlNoiseConfig();

	public void CopyFrom(VolumeCloudsWeatherLayerConfig copy)
	{
		Instability.CopyFrom(copy.Instability);
		CoverageBase.CopyFrom(copy.CoverageBase);
		CoverageDetailPerlin.CopyFrom(copy.CoverageDetailPerlin);
		CoverageDetailWorley.CopyFrom(copy.CoverageDetailWorley);
		Curl.CopyFrom(copy.Curl);
	}

	public void Output(StringBuilder sb, VolumeClouds.NoiseOffsets ofs)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		sb.AppendLine("Cov base:");
		CoverageBase.Output(sb, ofs.CoverageBase);
		sb.AppendLine("Cov dp:");
		CoverageDetailPerlin.Output(sb, ofs.CoverageDetailPerlin);
		sb.AppendLine("Cov dw:");
		CoverageDetailWorley.Output(sb, ofs.CoverageDetailWorley);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Storm Layer Config")]
public class VolumeCloudsRadialWeatherLayerConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig Weather = new VolumeCloudsWeatherLayerConfig();

	public bool Enabled;

	public float Radius;

	public Vector2 Offset;

	public float Falloff;

	public float Blend;

	public bool FollowCamera;

	public void CopyFrom(VolumeCloudsRadialWeatherLayerConfig copy)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Enabled = copy.Enabled;
		Radius = copy.Radius;
		Offset = copy.Offset;
		Falloff = copy.Falloff;
		Blend = copy.Blend;
		FollowCamera = copy.FollowCamera;
	}
}


using UnityEngine;

public class ClothWindModify : FacepunchBehaviour
{
	public Cloth cloth;

	private Vector3 initialClothForce;

	public Vector3 worldWindScale = Vector3.one;

	public Vector3 turbulenceScale = Vector3.one;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(WindZone))]
public class WindZoneEx : MonoBehaviour
{
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(WindZone))]
public class WindZoneExManager : MonoBehaviour
{
	private enum TestMode
	{
		Disabled,
		Low
	}

	public float maxAccumMain = 4f;

	public float maxAccumTurbulence = 4f;

	public float globalMainScale = 1f;

	public float globalTurbulenceScale = 1f;

	public Transform testPosition;
}


private enum TestMode
{
	Disabled,
	Low
}


public enum RgbColor
{
	Default,
	BuildingPrivilege,
	Cold,
	Hot,
	Hurt,
	Healed,
	Irradiated,
	Comforted
}


using System.ComponentModel;
using UnityEngine;

public class RgbEffects : SingletonComponent<RgbEffects>
{
	[ClientVar(Help = "Enables RGB lighting effects (supports SteelSeries and Razer)", Saved = true)]
	public static bool Enabled = true;

	[ClientVar(Help = "Controls how RGB values are mapped to LED lights on SteelSeries devices", Saved = true)]
	public static Vector3 ColorCorrection_SteelSeries = new Vector3(1.5f, 1.5f, 1.5f);

	[ClientVar(Help = "Controls how RGB values are mapped to LED lights on Razer devices", Saved = true)]
	public static Vector3 ColorCorrection_Razer = new Vector3(3f, 3f, 3f);

	[ClientVar(Help = "Brightness of colors, from 0 to 1 (note: may affect color accuracy)", Saved = true)]
	public static float Brightness = 1f;

	public Color defaultColor;

	public Color buildingPrivilegeColor;

	public Color coldColor;

	public Color hotColor;

	public Color hurtColor;

	public Color healedColor;

	public Color irradiatedColor;

	public Color comfortedColor;

	[ClientVar(Name = "static")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static void ConVar_Static(Arg args)
	{
	}

	[ClientVar(Name = "pulse")]
	[EditorBrowsable(EditorBrowsableState.Never)]
	public static void ConVar_Pulse(Arg args)
	{
	}
}


using System;
using System.Net;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Rust;
using Rust.Platform.Common;

public class RustPlatformHooks : IPlatformHooks
{
	public static readonly RustPlatformHooks Instance = new RustPlatformHooks();

	public uint SteamAppId => Defines.appID;

	public ServerParameters? ServerParameters
	{
		get
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			if (Net.sv == null)
			{
				return null;
			}
			IPAddress iPAddress = null;
			if (!string.IsNullOrEmpty(ConVar.Server.ip))
			{
				iPAddress = IPAddress.Parse(ConVar.Server.ip);
			}
			if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
			{
				ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
			}
			return new ServerParameters("rust", "Rust", 2594.ToString(), Net.sv.secure, CommandLine.HasSwitch("-sdrnet"), iPAddress, (ushort)Net.sv.port, (ushort)ConVar.Server.queryport);
		}
	}

	public void Abort()
	{
		Application.Quit();
	}

	public void OnItemDefinitionsChanged()
	{
		ItemManager.InvalidateWorkshopSkinCache();
	}

	public void AuthSessionValidated(ulong userId, ulong ownerUserId, AuthResponse response, string rawResponse)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnSteamAuth(userId, ownerUserId, rawResponse);
		SingletonComponent<ServerMgr>.Instance.OnValidateAuthTicketResponse(userId, ownerUserId, response);
	}
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

[RequireComponent(typeof(VideoPlayer))]
public class SafeVideoPlayer : MonoBehaviour
{
	[SerializeField]
	private VideoPlayer _videoPlayer;

	[SerializeField]
	private RawImage _outputImage;

	[SerializeField]
	private string primaryURL;

	[SerializeField]
	private string fallbackURL;
}


using UnityEngine;

public class SendMessageToEntityOnAnimationFinish : StateMachineBehaviour
{
	public string messageToSendToEntity;

	public float repeatRate = 0.1f;

	private const float lastMessageSent = 0f;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (0f + repeatRate > Time.time || animator.IsInTransition(layerIndex) || ((AnimatorStateInfo)(ref stateInfo)).normalizedTime < 1f)
		{
			return;
		}
		for (int i = 0; i < animator.layerCount; i++)
		{
			if (i != layerIndex)
			{
				if (animator.IsInTransition(i))
				{
					return;
				}
				AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(i);
				if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f && ((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 1f)
				{
					return;
				}
			}
		}
		BaseEntity baseEntity = ((Component)animator).gameObject.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			((Component)baseEntity).SendMessage(messageToSendToEntity, (SendMessageOptions)1);
		}
	}
}


public enum AntiHackType
{
	None,
	NoClip,
	SpeedHack,
	FlyHack,
	ProjectileHack,
	MeleeHack,
	EyeHack,
	AttackHack,
	ReloadHack,
	CooldownHack,
	InsideTerrain,
	InsideGeometry,
	EffectHack,
	Ticks
}


using System;
using System.Collections.Generic;
using AntiHackJobs;
using ConVar;
using Epic.OnlineServices.Reports;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public static class AntiHack
{
	public struct Batch
	{
		public int PlayerIndex;

		public int Count;

		public bool Force;

		public bool ExcludeVehicleLayer;
	}

	private class GroupedLog : IPooled
	{
		public float firstLogTime;

		public string playerName;

		public AntiHackType antiHackType;

		public string message;

		public Vector3 averagePos;

		public int num;

		public GroupedLog()
		{
		}

		public GroupedLog(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			SetInitial(playerName, antiHackType, message, pos);
		}

		public void EnterPool()
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			firstLogTime = 0f;
			playerName = string.Empty;
			antiHackType = AntiHackType.None;
			averagePos = Vector3.zero;
			num = 0;
		}

		public void LeavePool()
		{
		}

		public void SetInitial(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			firstLogTime = Time.unscaledTime;
			this.playerName = playerName;
			this.antiHackType = antiHackType;
			this.message = message;
			averagePos = pos;
			num = 1;
		}

		public bool TryGroup(string playerName, AntiHackType antiHackType, string message, Vector3 pos, float maxDistance)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (antiHackType != this.antiHackType || playerName != this.playerName || message != this.message)
			{
				return false;
			}
			if (Vector3.SqrMagnitude(averagePos - pos) > maxDistance * maxDistance)
			{
				return false;
			}
			Vector3 val = averagePos * (float)num;
			averagePos = (val + pos) / (float)(num + 1);
			num++;
			return true;
		}
	}

	private const int movement_mask = 1503731969;

	private const int vehicle_mask = 8192;

	private const int grounded_mask = 1503764737;

	private const int player_mask = 131072;

	private static Collider[] buffer = (Collider[])(object)new Collider[4];

	private static Dictionary<ulong, int> kicks = new Dictionary<ulong, int>();

	private static Dictionary<ulong, int> bans = new Dictionary<ulong, int>();

	private const float LOG_GROUP_SECONDS = 60f;

	private static Queue<GroupedLog> groupedLogs = new Queue<GroupedLog>();

	private static NativeArray<float> DeltaTimes;

	private static NativeArray<bool> FindIndexWorkBuffer;

	private static NativeList<int> ValidIndexAccum1;

	private static NativeList<int> ValidIndexAccum2;

	private static NativeList<int> InvalidIndices;

	private static NativeList<Vector3> From;

	private static NativeList<Vector3> To;

	private static NativeList<Batch> Batches;

	private static NativeList<int> LayerMasks;

	private static NativeArray<float> PlayerRadii;

	private static NativeList<int> ToOverlapIndices;

	private static NativeList<Matrix4x4> Matrices;

	private static NativeList<Vector3> ToOverlapFrom;

	private static NativeList<Vector3> ToOverlapTo;

	private static NativeList<int> ToOverlapLayerMasks;

	private static NativeList<int> RaycastIndices;

	private static NativeList<RaycastCommand> RaycastRays;

	private static NativeList<SpherecastCommand> RaycastSpheres;

	private static NativeList<int> TraceIndices;

	private static NativeList<RaycastCommand> TraceRays;

	private static NativeList<SpherecastCommand> TraceSpheres;

	private static NativeArray<RaycastHit> RaycastHits;

	private static NativeArray<ColliderHit> ColliderHits;

	private static NativeArray<bool> TerrainIgnoreVolumeHits;

	private static NativeArray<int> QueryToBatchMap;

	private static BufferList<Collider> Colliders;

	public static RaycastHit isInsideRayHit;

	private static RaycastHit[] isInsideMeshRaycastHits = (RaycastHit[])(object)new RaycastHit[64];

	public static bool TestNoClipping(BasePlayer ply, Vector3 oldPos, Vector3 newPos, float radius, float backtracking, out Collider col, bool vehicleLayer = false, BaseEntity ignoreEntity = null, bool forceCast = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		int num = 1503731969;
		if (!vehicleLayer)
		{
			num &= -8193;
		}
		Vector3 val = newPos - oldPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = oldPos - normalized * backtracking;
		val = newPos - val2;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(val2, normalized);
		if (GamePhysics.CheckCapsule(oldPos, newPos, radius, num, (QueryTriggerInteraction)1))
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapCapsule(oldPos, newPos, radius, list, num, (QueryTriggerInteraction)1);
			bool recheck = false;
			bool recheckTerrain = false;
			for (int i = 0; i < list.Count; i++)
			{
				Collider val4 = list[i];
				if (IsColliderBlocking(val4, ply, forceCast, ignoreEntity, ref recheck, ref recheckTerrain))
				{
					col = val4;
					Pool.FreeUnmanaged<Collider>(ref list);
					return true;
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
			if (recheck || recheckTerrain)
			{
				if (!recheckTerrain && (Object)(object)ignoreEntity == (Object)null)
				{
					RaycastHit val5 = default(RaycastHit);
					bool result = Physics.Raycast(val3, ref val5, magnitude + radius, num, (QueryTriggerInteraction)1) || Physics.SphereCast(val3, radius, ref val5, magnitude, num, (QueryTriggerInteraction)1);
					col = ((RaycastHit)(ref val5)).collider;
					return result;
				}
				RaycastHit hitInfo;
				bool result2 = GamePhysics.Trace(val3, 0f, out hitInfo, magnitude + radius, num, (QueryTriggerInteraction)1, ignoreEntity) || GamePhysics.Trace(val3, radius, out hitInfo, magnitude, num, (QueryTriggerInteraction)1, ignoreEntity);
				col = ((RaycastHit)(ref hitInfo)).collider;
				return result2;
			}
		}
		col = null;
		return false;
	}

	private static bool IsColliderBlocking(Collider collider, BasePlayer ply, bool forceCast, BaseEntity ignoreEntity, ref bool recheck, ref bool recheckTerrain)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (collider is TerrainCollider)
		{
			recheckTerrain = true;
			return false;
		}
		if ((LayerMask.op_Implicit(collider.excludeLayers) & 0x1000) == 4096)
		{
			return false;
		}
		BaseEntity baseEntity = collider.ToBaseEntity();
		if (((1 << ((Component)collider).gameObject.layer) & 0x2000) > 0)
		{
			if (baseEntity is HotAirBalloon && Time.time - ply.unparentTime <= 5f)
			{
				return false;
			}
			recheck = true;
			return false;
		}
		if (GamePhysics.CompareEntity(baseEntity, ignoreEntity))
		{
			return false;
		}
		if (forceCast)
		{
			recheck = true;
			return false;
		}
		if ((Object)(object)baseEntity != (Object)null && baseEntity.ShouldUseCastNoClipChecks())
		{
			recheck = true;
			return false;
		}
		if (ply.GetParentEntity() is ElevatorLift)
		{
			recheck = true;
			return false;
		}
		return true;
	}

	public static void TestAreNoClipping(PlayerCache playerCache, ReadOnly<Vector3> fromPos, ReadOnly<Vector3> toPos, ReadOnly<Batch> batches, NativeList<int> foundIndices, Span<Collider> foundColls)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0550: Unknown result type (might be due to invalid IL or missing references)
		//IL_0555: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0449: Unknown result type (might be due to invalid IL or missing references)
		//IL_044e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0457: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_045d: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0464: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_0479: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0480: Unknown result type (might be due to invalid IL or missing references)
		//IL_0482: Unknown result type (might be due to invalid IL or missing references)
		//IL_0487: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_0494: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_05aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_05de: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0901: Unknown result type (might be due to invalid IL or missing references)
		//IL_0906: Unknown result type (might be due to invalid IL or missing references)
		//IL_065a: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_081e: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0830: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_091b: Unknown result type (might be due to invalid IL or missing references)
		//IL_092c: Unknown result type (might be due to invalid IL or missing references)
		//IL_092d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0863: Unknown result type (might be due to invalid IL or missing references)
		//IL_0868: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0876: Unknown result type (might be due to invalid IL or missing references)
		//IL_087b: Unknown result type (might be due to invalid IL or missing references)
		//IL_087d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0895: Unknown result type (might be due to invalid IL or missing references)
		//IL_0688: Unknown result type (might be due to invalid IL or missing references)
		//IL_0699: Unknown result type (might be due to invalid IL or missing references)
		//IL_069a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TestAreNoClipping", 0);
		try
		{
			float noclip_backtracking = ConVar.AntiHack.noclip_backtracking;
			float num = BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin);
			NativeListEx.Expand(ref LayerMasks, fromPos.Length, copyContents: false);
			BuildLayerMasksJob buildLayerMasksJob = default(BuildLayerMasksJob);
			buildLayerMasksJob.LayerMasks = LayerMasks;
			buildLayerMasksJob.Batches = batches;
			buildLayerMasksJob.DefaultMask = 1503731969;
			buildLayerMasksJob.NoVehiclesMask = 1503723777;
			BuildLayerMasksJob buildLayerMasksJob2 = buildLayerMasksJob;
			IJobExtensions.RunByRef<BuildLayerMasksJob>(ref buildLayerMasksJob2);
			NativeArrayEx.Expand(ref PlayerRadii, fromPos.Length, (NativeArrayOptions)0, copyContents: false);
			FillJob<float> fillJob = default(FillJob<float>);
			fillJob.Values = PlayerRadii;
			fillJob.Value = num;
			FillJob<float> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
			NativeArrayEx.Expand(ref TerrainIgnoreVolumeHits, fromPos.Length, (NativeArrayOptions)0, copyContents: false);
			GamePhysics.CheckCapsules(fromPos, toPos, PlayerRadii.AsReadOnly(), LayerMasks.AsReadOnly(), TerrainIgnoreVolumeHits, (QueryTriggerInteraction)1, GamePhysics.MasksToValidate.Terrain);
			NativeListEx.Expand(ref ToOverlapIndices, fromPos.Length, copyContents: false);
			GatherHitIndicesJob gatherHitIndicesJob = default(GatherHitIndicesJob);
			gatherHitIndicesJob.Results = ToOverlapIndices;
			gatherHitIndicesJob.Hits = TerrainIgnoreVolumeHits.GetSubArray(0, fromPos.Length).AsReadOnly();
			GatherHitIndicesJob gatherHitIndicesJob2 = gatherHitIndicesJob;
			IJobExtensions.RunByRef<GatherHitIndicesJob>(ref gatherHitIndicesJob2);
			if (ToOverlapIndices.IsEmpty)
			{
				return;
			}
			NativeArrayEx.Expand(ref QueryToBatchMap, fromPos.Length, (NativeArrayOptions)0, copyContents: false);
			BuildBatchLookupMapJob buildBatchLookupMapJob = default(BuildBatchLookupMapJob);
			buildBatchLookupMapJob.Lookup = QueryToBatchMap;
			buildBatchLookupMapJob.Batches = batches;
			BuildBatchLookupMapJob buildBatchLookupMapJob2 = buildBatchLookupMapJob;
			IJobExtensions.RunByRef<BuildBatchLookupMapJob>(ref buildBatchLookupMapJob2);
			ToOverlapFrom.Resize(ToOverlapIndices.Length, (NativeArrayOptions)0);
			GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
			gatherJob.Results = ToOverlapFrom.AsArray();
			gatherJob.Source = fromPos;
			gatherJob.Indices = ToOverlapIndices.AsReadOnly();
			GatherJob<Vector3> gatherJob2 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
			ToOverlapTo.Resize(ToOverlapIndices.Length, (NativeArrayOptions)0);
			gatherJob = default(GatherJob<Vector3>);
			gatherJob.Results = ToOverlapTo.AsArray();
			gatherJob.Source = toPos;
			gatherJob.Indices = ToOverlapIndices.AsReadOnly();
			GatherJob<Vector3> gatherJob3 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob3);
			ToOverlapLayerMasks.Resize(ToOverlapIndices.Length, (NativeArrayOptions)0);
			GatherJob<int> gatherJob4 = default(GatherJob<int>);
			gatherJob4.Results = ToOverlapLayerMasks.AsArray();
			gatherJob4.Source = LayerMasks.AsReadOnly();
			gatherJob4.Indices = ToOverlapIndices.AsReadOnly();
			GatherJob<int> gatherJob5 = gatherJob4;
			IJobExtensions.RunByRef<GatherJob<int>>(ref gatherJob5);
			ColliderHits.Expand<ColliderHit>(ToOverlapLayerMasks.Length * 16, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
			GamePhysics.OverlapCapsules(ToOverlapFrom.AsReadOnly(), ToOverlapTo.AsReadOnly(), PlayerRadii.GetSubArray(0, ToOverlapLayerMasks.Length).AsReadOnly(), ToOverlapLayerMasks.AsReadOnly(), ColliderHits, 16, (QueryTriggerInteraction)1, GamePhysics.MasksToValidate.Terrain);
			NativeListEx.Expand(ref TraceIndices, ToOverlapIndices.Length, copyContents: false);
			TraceRays.Expand<RaycastCommand>(ToOverlapIndices.Length, copyContents: false);
			NativeListEx.Expand(ref RaycastIndices, ToOverlapIndices.Length, copyContents: false);
			RaycastRays.Expand<RaycastCommand>(ToOverlapIndices.Length, copyContents: false);
			TimeWarning val2 = TimeWarning.New("FilterOverlapResults", 0);
			try
			{
				bool flag = false;
				QueryParameters val9 = default(QueryParameters);
				RaycastCommand val10 = default(RaycastCommand);
				for (int i = 0; i < ToOverlapIndices.Length; i++)
				{
					int num2 = ToOverlapIndices[i];
					int num3 = QueryToBatchMap[num2];
					Batch batch = batches[num3];
					if (flag)
					{
						if (foundColls[batch.PlayerIndex] != null)
						{
							continue;
						}
						flag = false;
					}
					BasePlayer ply = playerCache.Players[batch.PlayerIndex];
					bool force = batch.Force;
					bool recheck = false;
					bool recheckTerrain = false;
					Collider val3 = null;
					for (int j = 0; j < 16; j++)
					{
						int num4 = i * 16 + j;
						ColliderHit val4 = ColliderHits[num4];
						if (((ColliderHit)(ref val4)).instanceID == 0)
						{
							break;
						}
						Collider collider = ((ColliderHit)(ref val4)).collider;
						if (IsColliderBlocking(collider, ply, force, null, ref recheck, ref recheckTerrain))
						{
							flag = true;
							val3 = collider;
							break;
						}
					}
					int playerIndex = batch.PlayerIndex;
					if (flag)
					{
						foundIndices.Add(ref playerIndex);
						foundColls[playerIndex] = val3;
					}
					else if (recheck || recheckTerrain)
					{
						Vector3 val5 = ToOverlapFrom[i];
						Vector3 val6 = ToOverlapTo[i];
						Vector3 val7 = val6 - val5;
						Vector3 normalized = ((Vector3)(ref val7)).normalized;
						Vector3 val8 = val5 - normalized * noclip_backtracking;
						val7 = val6 - val8;
						float magnitude = ((Vector3)(ref val7)).magnitude;
						new Ray(val8, normalized);
						int num5 = ToOverlapLayerMasks[i];
						((QueryParameters)(ref val9))..ctor(num5, false, (QueryTriggerInteraction)1, false);
						((RaycastCommand)(ref val10))..ctor(val8, normalized, val9, magnitude + num);
						if (recheckTerrain)
						{
							TraceIndices.AddNoResize(num2);
							TraceRays.AddNoResize(val10);
						}
						else
						{
							RaycastIndices.AddNoResize(num2);
							RaycastRays.AddNoResize(val10);
						}
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			if (!TraceIndices.IsEmpty)
			{
				RaycastHits.Expand<RaycastHit>(TraceIndices.Length * 16, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
				GamePhysics.TraceRays(TraceRays.AsArray(), RaycastHits, 16, traceWater: false);
				val2 = TimeWarning.New("GatherRays", 0);
				try
				{
					int num6 = 0;
					TraceSpheres.Expand<SpherecastCommand>(TraceIndices.Length, copyContents: false);
					SpherecastCommand val12 = default(SpherecastCommand);
					for (int k = 0; k < TraceIndices.Length; k++)
					{
						if (!RecordNoclip(RaycastHits[k * 16], TraceIndices[k], batches, foundIndices, foundColls))
						{
							TraceIndices[num6++] = TraceIndices[k];
							RaycastCommand val11 = TraceRays[k];
							((SpherecastCommand)(ref val12))..ctor(((RaycastCommand)(ref val11)).from, num, ((RaycastCommand)(ref val11)).direction, val11.queryParameters, ((RaycastCommand)(ref val11)).distance - num);
							TraceSpheres.Add(ref val12);
						}
					}
					TraceIndices.Resize(num6, (NativeArrayOptions)0);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				if (!TraceIndices.IsEmpty)
				{
					GamePhysics.TraceSpheres(TraceSpheres.AsArray(), RaycastHits, 16, traceWater: false);
					TimeWarning val13 = TimeWarning.New("GatherSpheres", 0);
					try
					{
						for (int l = 0; l < TraceIndices.Length; l++)
						{
							RecordNoclip(RaycastHits[l * 16], TraceIndices[l], batches, foundIndices, foundColls);
						}
					}
					finally
					{
						((IDisposable)val13)?.Dispose();
					}
				}
			}
			if (RaycastIndices.IsEmpty)
			{
				return;
			}
			if (!TraceIndices.IsEmpty)
			{
				TimeWarning val14 = TimeWarning.New("SkipDupeRaycasts", 0);
				try
				{
					int num7 = 0;
					for (int m = 0; m < RaycastIndices.Length; m++)
					{
						int num8 = RaycastIndices[m];
						int num9 = QueryToBatchMap[num8];
						if (foundColls[batches[num9].PlayerIndex] == null)
						{
							int num10 = num7++;
							RaycastIndices[num10] = num8;
							RaycastRays[num10] = RaycastRays[m];
						}
					}
					RaycastIndices.Resize(num7, (NativeArrayOptions)0);
					RaycastRays.Resize(num7, (NativeArrayOptions)0);
				}
				finally
				{
					((IDisposable)val14)?.Dispose();
				}
			}
			if (!RaycastIndices.IsEmpty)
			{
				TimeWarning val15 = TimeWarning.New("RayCasts", 0);
				try
				{
					RaycastHits.Expand<RaycastHit>(RaycastIndices.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
					JobHandle val16 = RaycastCommand.ScheduleBatch(RaycastRays.AsArray(), RaycastHits, 1, default(JobHandle));
					((JobHandle)(ref val16)).Complete();
					int num11 = 0;
					RaycastSpheres.Expand<SpherecastCommand>(RaycastIndices.Length, copyContents: false);
					SpherecastCommand val18 = default(SpherecastCommand);
					for (int n = 0; n < RaycastIndices.Length; n++)
					{
						if (!RecordNoclip(RaycastHits[n], RaycastIndices[n], batches, foundIndices, foundColls))
						{
							RaycastIndices[num11++] = RaycastIndices[n];
							RaycastCommand val17 = RaycastRays[n];
							((SpherecastCommand)(ref val18))..ctor(((RaycastCommand)(ref val17)).from, num, ((RaycastCommand)(ref val17)).direction, val17.queryParameters, ((RaycastCommand)(ref val17)).distance - num);
							RaycastSpheres.AddNoResize(val18);
						}
					}
					RaycastIndices.Resize(num11, (NativeArrayOptions)0);
				}
				finally
				{
					((IDisposable)val15)?.Dispose();
				}
			}
			if (RaycastIndices.IsEmpty)
			{
				return;
			}
			TimeWarning val19 = TimeWarning.New("SphereCasts", 0);
			try
			{
				JobHandle val20 = SpherecastCommand.ScheduleBatch(RaycastSpheres.AsArray(), RaycastHits, 1, default(JobHandle));
				((JobHandle)(ref val20)).Complete();
				for (int num12 = 0; num12 < RaycastIndices.Length; num12++)
				{
					RecordNoclip(RaycastHits[num12], RaycastIndices[num12], batches, foundIndices, foundColls);
				}
			}
			finally
			{
				((IDisposable)val19)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static bool RecordNoclip(RaycastHit hit, int queryIndex, ReadOnly<Batch> batches, NativeList<int> foundIndices, Span<Collider> foundColls)
		{
			bool num13 = ((RaycastHit)(ref hit)).colliderInstanceID != 0;
			if (num13)
			{
				int num14 = QueryToBatchMap[queryIndex];
				int playerIndex2 = batches[num14].PlayerIndex;
				if (foundColls[playerIndex2] == null)
				{
					foundIndices.Add(ref playerIndex2);
					foundColls[playerIndex2] = ((RaycastHit)(ref hit)).collider;
				}
			}
			return num13;
		}
	}

	public static void Cycle()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.unscaledTime - 60f;
		if (groupedLogs.Count <= 0)
		{
			return;
		}
		GroupedLog groupedLog = groupedLogs.Peek();
		while (groupedLog.firstLogTime <= num)
		{
			GroupedLog groupedLog2 = groupedLogs.Dequeue();
			LogToConsole(groupedLog2.playerName, groupedLog2.antiHackType, $"{groupedLog2.message} (x{groupedLog2.num})", groupedLog2.averagePos);
			Pool.Free<GroupedLog>(ref groupedLog2);
			if (groupedLogs.Count != 0)
			{
				groupedLog = groupedLogs.Peek();
				continue;
			}
			break;
		}
	}

	public static void ResetTimer(BasePlayer ply)
	{
		ply.lastViolationTime = Time.realtimeSinceStartup;
		ply.lastMovementViolationTime = Time.realtimeSinceStartup;
	}

	public static bool ShouldIgnore(BasePlayer ply)
	{
		TimeWarning val = TimeWarning.New("AntiHack.ShouldIgnore", 0);
		try
		{
			if (ply.IsFlying)
			{
				ply.lastAdminCheatTime = Time.realtimeSinceStartup;
			}
			else if ((ply.IsAdmin || ply.IsDeveloper) && ply.lastAdminCheatTime == 0f)
			{
				ply.lastAdminCheatTime = Time.realtimeSinceStartup;
			}
			if (ply.IsAdmin)
			{
				if (ConVar.AntiHack.userlevel < 1)
				{
					return true;
				}
				if (ConVar.AntiHack.admincheat && ply.UsedAdminCheat())
				{
					return true;
				}
			}
			if (ply.IsDeveloper)
			{
				if (ConVar.AntiHack.userlevel < 2)
				{
					return true;
				}
				if (ConVar.AntiHack.admincheat && ply.UsedAdminCheat())
				{
					return true;
				}
			}
			if (ply.IsSpectating())
			{
				return true;
			}
			if (ply.isInvisible)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool ValidateMove(BasePlayer ply, TickInterpolator ticks, float deltaTime, in BasePlayer.CachedState initialState)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.ValidateMove", 0);
		try
		{
			if (ShouldIgnore(ply))
			{
				return true;
			}
			bool flag = deltaTime > ConVar.AntiHack.maxdeltatime;
			bool flag2 = deltaTime < ConVar.AntiHack.tick_buffer_server_lag_threshold && ConVar.AntiHack.tick_buffer_preventions && (float)ply.rawTickCount >= ConVar.AntiHack.tick_buffer_reject_threshold * (float)Player.tickrate_cl;
			if (IsNoClipping(ply, ticks, deltaTime, out var collider))
			{
				if (flag)
				{
					return false;
				}
				Analytics.Azure.OnNoclipViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count, collider);
				AddViolation(ply, AntiHackType.NoClip, ConVar.AntiHack.noclip_penalty * ticks.Length, ((Component)collider).gameObject);
				if (ConVar.AntiHack.noclip_reject)
				{
					return false;
				}
			}
			if (IsSpeeding(ply, ticks, deltaTime, in initialState))
			{
				if (flag)
				{
					return false;
				}
				Analytics.Azure.OnSpeedhackViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count);
				AddViolation(ply, AntiHackType.SpeedHack, ConVar.AntiHack.speedhack_penalty * ticks.Length);
				if (ConVar.AntiHack.speedhack_reject)
				{
					return false;
				}
			}
			if (IsFlying(ply, ticks, deltaTime, in initialState))
			{
				if (flag)
				{
					return false;
				}
				Analytics.Azure.OnFlyhackViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count);
				AddViolation(ply, AntiHackType.FlyHack, ConVar.AntiHack.flyhack_penalty * ticks.Length);
				if (ConVar.AntiHack.flyhack_reject && !(ply.lastGroundedPosition == default(Vector3)) && Vector3.Distance(ply.lastGroundedPosition, ((Component)ply).transform.position) <= 10f)
				{
					Collider col;
					bool num = TestNoClipping(ply, ((Component)ply).transform.position, ply.lastGroundedPosition, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out col);
					Vector3 val2 = ply.lastGroundedPosition + new Vector3(0f, BasePlayer.GetRadius(), 0f);
					Vector3 val3 = ply.lastGroundedPosition + new Vector3(0f, ply.GetHeight() - BasePlayer.GetRadius(), 0f);
					if (!num && !Physics.CheckCapsule(val2, val3, BasePlayer.GetRadius(), 1537286401))
					{
						ply.MovePosition(ply.lastGroundedPosition);
						ply.ClientRPC(RpcTarget.Player("ForcePositionTo", ply), ((Component)ply).transform.position);
						ply.violationLevel = 0f;
					}
				}
			}
			if (flag2)
			{
				Log(ply, AntiHackType.Ticks, $"Player had too many ticks buffered ({ply.rawTickCount})", logToAnalytics: false);
				Analytics.Azure.OnTickViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count);
				return false;
			}
			if (ConVar.AntiHack.serverside_fall_damage)
			{
				bool num2 = (Object)(object)((Component)ply).transform.parent == (Object)null;
				Matrix4x4 val4 = (num2 ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
				Vector3 oldPos = (num2 ? ticks.StartPoint : ((Matrix4x4)(ref val4)).MultiplyPoint3x4(ticks.StartPoint));
				Vector3 newPos = (num2 ? ticks.EndPoint : ((Matrix4x4)(ref val4)).MultiplyPoint3x4(ticks.EndPoint));
				TestServerSideFallDamage(ply, oldPos, newPos, deltaTime);
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void InitInternalState(int initCap)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		DisposeInternalState();
		DeltaTimes = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		FindIndexWorkBuffer = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ValidIndexAccum1 = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ValidIndexAccum2 = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		InvalidIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		From = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		To = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		Batches = new NativeList<Batch>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		LayerMasks = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		PlayerRadii = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ToOverlapIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		Matrices = new NativeList<Matrix4x4>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ToOverlapFrom = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ToOverlapTo = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ToOverlapLayerMasks = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastRays = new NativeList<RaycastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastSpheres = new NativeList<SpherecastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		TraceIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		TraceRays = new NativeList<RaycastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		TraceSpheres = new NativeList<SpherecastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastHits = new NativeArray<RaycastHit>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ColliderHits = new NativeArray<ColliderHit>(initCap, (Allocator)4, (NativeArrayOptions)0);
		TerrainIgnoreVolumeHits = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		QueryToBatchMap = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Colliders = new BufferList<Collider>(initCap);
	}

	public static void DisposeInternalState()
	{
		NativeArrayEx.SafeDispose(ref DeltaTimes);
		NativeArrayEx.SafeDispose(ref FindIndexWorkBuffer);
		NativeListEx.SafeDispose(ref ValidIndexAccum1);
		NativeListEx.SafeDispose(ref ValidIndexAccum2);
		NativeListEx.SafeDispose(ref InvalidIndices);
		From.SafeDispose<Vector3>();
		To.SafeDispose<Vector3>();
		NativeListEx.SafeDispose(ref Batches);
		NativeListEx.SafeDispose(ref LayerMasks);
		NativeArrayEx.SafeDispose(ref PlayerRadii);
		NativeListEx.SafeDispose(ref ToOverlapIndices);
		Matrices.SafeDispose<Matrix4x4>();
		ToOverlapFrom.SafeDispose<Vector3>();
		ToOverlapTo.SafeDispose<Vector3>();
		NativeListEx.SafeDispose(ref ToOverlapLayerMasks);
		NativeListEx.SafeDispose(ref RaycastIndices);
		RaycastRays.SafeDispose<RaycastCommand>();
		RaycastSpheres.SafeDispose<SpherecastCommand>();
		NativeListEx.SafeDispose(ref TraceIndices);
		TraceRays.SafeDispose<RaycastCommand>();
		TraceSpheres.SafeDispose<SpherecastCommand>();
		RaycastHits.SafeDispose<RaycastHit>();
		ColliderHits.SafeDispose<ColliderHit>();
		NativeArrayEx.SafeDispose(ref TerrainIgnoreVolumeHits);
		NativeArrayEx.SafeDispose(ref QueryToBatchMap);
		Colliders = null;
	}

	internal static void ValidateMoves(PlayerCache playerCache, TickInterpolatorCache.ReadOnlyState tickCache, NativeArray<BasePlayer.CachedState> stateCache, ReadOnly<int> indices, NativeArray<BasePlayer.PositionChange> results)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0465: Unknown result type (might be due to invalid IL or missing references)
		//IL_046a: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_0478: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_052c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0531: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_058e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0593: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_070d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0712: Unknown result type (might be due to invalid IL or missing references)
		//IL_0717: Unknown result type (might be due to invalid IL or missing references)
		//IL_0719: Unknown result type (might be due to invalid IL or missing references)
		//IL_071e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0720: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05db: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_074f: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_0626: Unknown result type (might be due to invalid IL or missing references)
		//IL_062d: Unknown result type (might be due to invalid IL or missing references)
		//IL_064d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_0666: Unknown result type (might be due to invalid IL or missing references)
		//IL_066b: Unknown result type (might be due to invalid IL or missing references)
		//IL_066f: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0690: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_0699: Unknown result type (might be due to invalid IL or missing references)
		//IL_069b: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_083e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0843: Unknown result type (might be due to invalid IL or missing references)
		//IL_0848: Unknown result type (might be due to invalid IL or missing references)
		//IL_084a: Unknown result type (might be due to invalid IL or missing references)
		//IL_084f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0851: Unknown result type (might be due to invalid IL or missing references)
		//IL_0960: Unknown result type (might be due to invalid IL or missing references)
		//IL_0965: Unknown result type (might be due to invalid IL or missing references)
		//IL_087c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0881: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0904: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0906: Unknown result type (might be due to invalid IL or missing references)
		//IL_0915: Unknown result type (might be due to invalid IL or missing references)
		//IL_090c: Unknown result type (might be due to invalid IL or missing references)
		//IL_090e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0917: Unknown result type (might be due to invalid IL or missing references)
		//IL_091b: Unknown result type (might be due to invalid IL or missing references)
		//IL_091d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.ValidateMoves", 0);
		try
		{
			ReadOnlySpan<BasePlayer> players = playerCache.Players;
			NativeArrayEx.Expand(ref DeltaTimes, players.Length, (NativeArrayOptions)0, copyContents: false);
			NativeListEx.Expand(ref ValidIndexAccum1, indices.Length, copyContents: false);
			NativeListEx.Expand(ref ValidIndexAccum2, indices.Length, copyContents: false);
			ValidIndexAccum1.Clear();
			ValidIndexAccum2.Clear();
			TimeWarning val2 = TimeWarning.New("ShouldIgnore", 0);
			try
			{
				Enumerator<int> enumerator = indices.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						int current = enumerator.Current;
						BasePlayer basePlayer = players[current];
						if (ShouldIgnore(basePlayer))
						{
							results[current] = BasePlayer.PositionChange.Valid;
							continue;
						}
						ValidIndexAccum1.Add(ref current);
						float tickDeltaTime = basePlayer.TickDeltaTime;
						_ = ConVar.AntiHack.maxdeltatime;
						DeltaTimes[current] = tickDeltaTime;
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeListEx.Expand(ref InvalidIndices, ValidIndexAccum1.Length, copyContents: false);
			InvalidIndices.Clear();
			if (Colliders.Capacity < players.Length)
			{
				Colliders.Resize(players.Length);
			}
			AreNoClipping(playerCache, tickCache, DeltaTimes.AsReadOnly(), ValidIndexAccum1.AsReadOnly(), InvalidIndices, Colliders.Buffer);
			NativeArrayEx.Expand(ref FindIndexWorkBuffer, players.Length, (NativeArrayOptions)0, copyContents: false);
			FindValidIndicesJob findValidIndicesJob = default(FindValidIndicesJob);
			findValidIndicesJob.ValidIndices = ValidIndexAccum2;
			findValidIndicesJob.WorkBuffer = FindIndexWorkBuffer;
			findValidIndicesJob.InvalidIndices = InvalidIndices.AsReadOnly();
			findValidIndicesJob.AllIndices = ValidIndexAccum1.AsReadOnly();
			FindValidIndicesJob findValidIndicesJob2 = findValidIndicesJob;
			IJobExtensions.RunByRef<FindValidIndicesJob>(ref findValidIndicesJob2);
			val2 = TimeWarning.New("NoClipRejections", 0);
			Enumerator<int> enumerator2;
			try
			{
				enumerator2 = InvalidIndices.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current2 = enumerator2.Current;
						if (DeltaTimes[current2] > ConVar.AntiHack.maxdeltatime)
						{
							results[current2] = BasePlayer.PositionChange.Invalid;
							continue;
						}
						BasePlayer obj = playerCache.Players[current2];
						Vector3 startPoint = TickInterpolatorCache.GetStartPoint(tickCache, current2);
						Vector3 endPoint = TickInterpolatorCache.GetEndPoint(tickCache, current2);
						TickInterpolatorCache.PlayerInfo playerInfo = tickCache.Infos[current2];
						Analytics.Azure.OnNoclipViolation(obj, startPoint, endPoint, playerInfo.Count, Colliders[current2]);
						AddViolation(obj, AntiHackType.NoClip, ConVar.AntiHack.noclip_penalty * playerInfo.Length, ((Component)Colliders[current2]).gameObject);
						if (ConVar.AntiHack.noclip_reject)
						{
							results[current2] = BasePlayer.PositionChange.Invalid;
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			Array.Clear(Colliders.Buffer, 0, Colliders.Capacity);
			NativeList<int> validIndexAccum = ValidIndexAccum2;
			NativeList<int> validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			InvalidIndices.Clear();
			enumerator2 = ValidIndexAccum1.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					int current3 = enumerator2.Current;
					BasePlayer obj2 = playerCache.Players[current3];
					float deltaTime = DeltaTimes[current3];
					BasePlayer.CachedState initialState = stateCache[current3];
					TickInterpolator tickInterpolator = obj2.TickInterpolator;
					if (IsSpeeding(obj2, tickInterpolator, deltaTime, in initialState))
					{
						InvalidIndices.Add(ref current3);
					}
					else
					{
						ValidIndexAccum2.Add(ref current3);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			val2 = TimeWarning.New("IsSpeedingRejections", 0);
			try
			{
				enumerator2 = InvalidIndices.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current4 = enumerator2.Current;
						if (DeltaTimes[current4] > ConVar.AntiHack.maxdeltatime)
						{
							results[current4] = BasePlayer.PositionChange.Invalid;
							continue;
						}
						BasePlayer obj3 = playerCache.Players[current4];
						Vector3 startPoint2 = TickInterpolatorCache.GetStartPoint(tickCache, current4);
						Vector3 endPoint2 = TickInterpolatorCache.GetEndPoint(tickCache, current4);
						TickInterpolatorCache.PlayerInfo playerInfo2 = tickCache.Infos[current4];
						Analytics.Azure.OnSpeedhackViolation(obj3, startPoint2, endPoint2, playerInfo2.Count);
						AddViolation(obj3, AntiHackType.SpeedHack, ConVar.AntiHack.speedhack_penalty * playerInfo2.Length);
						if (ConVar.AntiHack.speedhack_reject)
						{
							results[current4] = BasePlayer.PositionChange.Invalid;
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeList<int> validIndexAccum3 = ValidIndexAccum2;
			validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum3;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			InvalidIndices.Clear();
			enumerator2 = ValidIndexAccum1.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					int current5 = enumerator2.Current;
					BasePlayer obj4 = playerCache.Players[current5];
					float deltaTime2 = DeltaTimes[current5];
					BasePlayer.CachedState initialState2 = stateCache[current5];
					TickInterpolator tickInterpolator2 = obj4.TickInterpolator;
					if (IsFlying(obj4, tickInterpolator2, deltaTime2, in initialState2))
					{
						InvalidIndices.Add(ref current5);
					}
					else
					{
						ValidIndexAccum2.Add(ref current5);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			val2 = TimeWarning.New("IsFlyingRejections", 0);
			try
			{
				enumerator2 = InvalidIndices.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current6 = enumerator2.Current;
						if (DeltaTimes[current6] > ConVar.AntiHack.maxdeltatime)
						{
							results[current6] = BasePlayer.PositionChange.Invalid;
							continue;
						}
						BasePlayer basePlayer2 = playerCache.Players[current6];
						Vector3 startPoint3 = TickInterpolatorCache.GetStartPoint(tickCache, current6);
						Vector3 endPoint3 = TickInterpolatorCache.GetEndPoint(tickCache, current6);
						TickInterpolatorCache.PlayerInfo playerInfo3 = tickCache.Infos[current6];
						Analytics.Azure.OnFlyhackViolation(basePlayer2, startPoint3, endPoint3, playerInfo3.Count);
						AddViolation(basePlayer2, AntiHackType.FlyHack, ConVar.AntiHack.flyhack_penalty * playerInfo3.Length);
						if (!ConVar.AntiHack.flyhack_reject)
						{
							continue;
						}
						if (basePlayer2.lastGroundedPosition == default(Vector3))
						{
							ValidIndexAccum2.Add(ref current6);
						}
						else if (Vector3.Distance(basePlayer2.lastGroundedPosition, ((Component)basePlayer2).transform.position) <= 10f)
						{
							Collider col;
							bool num = TestNoClipping(basePlayer2, ((Component)basePlayer2).transform.position, basePlayer2.lastGroundedPosition, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out col);
							Vector3 val3 = basePlayer2.lastGroundedPosition + new Vector3(0f, BasePlayer.GetRadius(), 0f);
							Vector3 val4 = basePlayer2.lastGroundedPosition + new Vector3(0f, basePlayer2.GetHeight() - BasePlayer.GetRadius(), 0f);
							if (!num && !Physics.CheckCapsule(val3, val4, BasePlayer.GetRadius(), 1537286401))
							{
								basePlayer2.MovePosition(basePlayer2.lastGroundedPosition);
								basePlayer2.ClientRPC(RpcTarget.Player("ForcePositionTo", basePlayer2), ((Component)basePlayer2).transform.position);
								basePlayer2.violationLevel = 0f;
							}
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeList<int> validIndexAccum4 = ValidIndexAccum2;
			validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum4;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			InvalidIndices.Clear();
			val2 = TimeWarning.New("TickOverflowValidation", 0);
			try
			{
				enumerator2 = ValidIndexAccum1.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current7 = enumerator2.Current;
						BasePlayer basePlayer3 = players[current7];
						if (DeltaTimes[current7] < ConVar.AntiHack.tick_buffer_server_lag_threshold && ConVar.AntiHack.tick_buffer_preventions && (float)basePlayer3.rawTickCount >= ConVar.AntiHack.tick_buffer_reject_threshold * (float)Player.tickrate_cl)
						{
							Log(basePlayer3, AntiHackType.Ticks, $"Player had too many ticks buffered ({basePlayer3.rawTickCount})", logToAnalytics: false);
							Vector3 startPoint4 = TickInterpolatorCache.GetStartPoint(tickCache, current7);
							Vector3 endPoint4 = TickInterpolatorCache.GetEndPoint(tickCache, current7);
							Analytics.Azure.OnTickViolation(basePlayer3, startPoint4, endPoint4, tickCache.Infos[current7].Count);
							results[current7] = BasePlayer.PositionChange.Invalid;
						}
						else
						{
							ValidIndexAccum2.Add(ref current7);
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeList<int> validIndexAccum5 = ValidIndexAccum2;
			validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum5;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			if (ConVar.AntiHack.serverside_fall_damage)
			{
				TimeWarning val5 = TimeWarning.New("ServerSideFallDamageScope", 0);
				try
				{
					enumerator2 = ValidIndexAccum1.GetEnumerator();
					try
					{
						while (enumerator2.MoveNext())
						{
							int current8 = enumerator2.Current;
							BasePlayer basePlayer4 = playerCache.Players[current8];
							float deltaTime3 = DeltaTimes[current8];
							Vector3 startPoint5 = TickInterpolatorCache.GetStartPoint(tickCache, current8);
							Vector3 endPoint5 = TickInterpolatorCache.GetEndPoint(tickCache, current8);
							bool num2 = (Object)(object)((Component)basePlayer4).transform.parent == (Object)null;
							Matrix4x4 val6 = (num2 ? Matrix4x4.identity : ((Component)basePlayer4).transform.parent.localToWorldMatrix);
							Vector3 oldPos = (num2 ? startPoint5 : ((Matrix4x4)(ref val6)).MultiplyPoint3x4(startPoint5));
							Vector3 newPos = (num2 ? endPoint5 : ((Matrix4x4)(ref val6)).MultiplyPoint3x4(endPoint5));
							TestServerSideFallDamage(basePlayer4, oldPos, newPos, deltaTime3);
						}
					}
					finally
					{
						((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			val2 = TimeWarning.New("MarkPositionsValid", 0);
			try
			{
				enumerator2 = ValidIndexAccum1.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current9 = enumerator2.Current;
						results[current9] = BasePlayer.PositionChange.Valid;
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void ValidateEyeHistory(BasePlayer ply)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.ValidateEyeHistory", 0);
		try
		{
			for (int i = 0; i < ply.eyeHistory.Count; i++)
			{
				Vector3 val2 = ply.eyeHistory[i];
				if (ply.tickHistory.Distance(ply, val2) > ConVar.AntiHack.eye_history_forgiveness)
				{
					AddViolation(ply, AntiHackType.EyeHack, ConVar.AntiHack.eye_history_penalty);
					Analytics.Azure.OnEyehackViolation(ply, val2);
				}
			}
			ply.eyeHistory.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsInsideTerrain(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return TestInsideTerrain(((Component)ply).transform.position);
	}

	public static bool TestInsideTerrain(Vector3 pos)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.TestInsideTerrain", 0);
		try
		{
			if (!Object.op_Implicit((Object)(object)TerrainMeta.Terrain))
			{
				return false;
			}
			if (!Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				return false;
			}
			if (!Object.op_Implicit((Object)(object)TerrainMeta.Collision))
			{
				return false;
			}
			float terrain_padding = ConVar.AntiHack.terrain_padding;
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			if (pos.y > height - terrain_padding)
			{
				return false;
			}
			float num = TerrainMeta.Position.y + TerrainMeta.Terrain.SampleHeight(pos);
			if (pos.y > num - terrain_padding)
			{
				return false;
			}
			if (TerrainMeta.Collision.GetIgnore(pos))
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsInsideMesh(Vector3 pos)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.AntiHack.mesh_inside_check_distance <= 0f)
		{
			return false;
		}
		bool queriesHitBackfaces = Physics.queriesHitBackfaces;
		if (ConVar.AntiHack.use_legacy_mesh_inside_check)
		{
			Physics.queriesHitBackfaces = true;
			if (Physics.Raycast(pos, Vector3.up, ref isInsideRayHit, ConVar.AntiHack.mesh_inside_check_distance, 65536))
			{
				Physics.queriesHitBackfaces = queriesHitBackfaces;
				return Vector3.Dot(Vector3.up, ((RaycastHit)(ref isInsideRayHit)).normal) > 0f;
			}
			Physics.queriesHitBackfaces = queriesHitBackfaces;
			return false;
		}
		Physics.queriesHitBackfaces = true;
		int num = Physics.RaycastNonAlloc(pos, Vector3.up, isInsideMeshRaycastHits, ConVar.AntiHack.mesh_inside_check_distance, 65536);
		Physics.queriesHitBackfaces = queriesHitBackfaces;
		SortHitsByDistance(isInsideMeshRaycastHits, num);
		Collider val = null;
		ColliderInfo colliderInfo = default(ColliderInfo);
		for (int i = 0; i < num; i++)
		{
			RaycastHit val2 = isInsideMeshRaycastHits[i];
			if (((Component)((RaycastHit)(ref val2)).collider).TryGetComponent<ColliderInfo>(ref colliderInfo) && colliderInfo.HasFlag(ColliderInfo.Flags.AllowBuildInsideMesh))
			{
				continue;
			}
			if (Vector3.Dot(Vector3.up, ((RaycastHit)(ref val2)).normal) > 0f)
			{
				if ((Object)(object)val != (Object)(object)((RaycastHit)(ref val2)).collider)
				{
					isInsideRayHit = val2;
					return true;
				}
			}
			else
			{
				val = ((RaycastHit)(ref val2)).collider;
			}
		}
		return false;
	}

	private static void SortHitsByDistance(RaycastHit[] hits, int maxLength)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < maxLength - 1; i++)
		{
			int num = i;
			for (int j = i + 1; j < maxLength; j++)
			{
				if (((RaycastHit)(ref hits[j])).distance < ((RaycastHit)(ref hits[num])).distance)
				{
					num = j;
				}
			}
			if (num != i)
			{
				RaycastHit val = hits[i];
				hits[i] = hits[num];
				hits[num] = val;
			}
		}
	}

	public static bool IsNoClipping(BasePlayer ply, TickInterpolator ticks, float deltaTime, out Collider collider)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		collider = null;
		TimeWarning val = TimeWarning.New("AntiHack.IsNoClipping", 0);
		try
		{
			ply.vehiclePauseTime = Mathf.Max(0f, ply.vehiclePauseTime - deltaTime);
			ply.forceCastTime = Mathf.Max(0f, ply.forceCastTime - deltaTime);
			if (ConVar.AntiHack.noclip_protection <= 0)
			{
				return false;
			}
			ticks.Reset();
			if (!ticks.HasNext())
			{
				return false;
			}
			bool flag = (Object)(object)((Component)ply).transform.parent == (Object)null;
			Matrix4x4 val2 = (flag ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
			Vector3 val3 = (flag ? ticks.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.StartPoint));
			Vector3 val4 = (flag ? ticks.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.EndPoint));
			Vector3 val5 = BasePlayer.NoClipOffset();
			float radius = BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin);
			float noclip_backtracking = ConVar.AntiHack.noclip_backtracking;
			bool vehicleLayer = ply.vehiclePauseTime <= 0f && !ply.isMounted;
			bool forceCast = ply.forceCastTime > 0f;
			int num = ConVar.AntiHack.noclip_protection;
			if (deltaTime < ConVar.AntiHack.tick_buffer_server_lag_threshold && ConVar.AntiHack.tick_buffer_preventions && (float)ply.rawTickCount >= ConVar.AntiHack.tick_buffer_noclip_threshold * (float)Player.tickrate_cl)
			{
				num = Mathf.Min(2, ConVar.AntiHack.noclip_protection);
			}
			if (num >= 3)
			{
				float num2 = Mathf.Max(ConVar.AntiHack.noclip_stepsize, 0.1f);
				int num3 = Mathf.Max(ConVar.AntiHack.noclip_maxsteps, 1);
				num2 = Mathf.Max(ticks.Length / (float)num3, num2);
				while (ticks.MoveNext(num2))
				{
					val4 = (flag ? ticks.CurrentPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.CurrentPoint));
					if (TestNoClipping(ply, val3 + val5, val4 + val5, radius, noclip_backtracking, out collider, vehicleLayer, null, forceCast))
					{
						return true;
					}
					val3 = val4;
				}
			}
			else if (TestNoClipping(ply, val3 + val5, val4 + val5, radius, noclip_backtracking, out collider, vehicleLayer, null, forceCast))
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void AreNoClipping(PlayerCache playerCache, TickInterpolatorCache.ReadOnlyState tickCache, ReadOnly<float> deltaTimes, ReadOnly<int> indices, NativeList<int> foundIndices, Span<Collider> colliders)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.AreNoClipping", 0);
		try
		{
			ReadOnlySpan<BasePlayer> players = playerCache.Players;
			Enumerator<int> enumerator = indices.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					int current = enumerator.Current;
					BasePlayer basePlayer = players[current];
					float num = deltaTimes[current];
					basePlayer.vehiclePauseTime = Mathf.Max(0f, basePlayer.vehiclePauseTime - num);
					basePlayer.forceCastTime = Mathf.Max(0f, basePlayer.forceCastTime - num);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			if (ConVar.AntiHack.noclip_protection <= 0)
			{
				return;
			}
			int num2 = Mathf.Max(ConVar.AntiHack.noclip_maxsteps, 1);
			TimeWarning val2 = TimeWarning.New("GatherBatches", 0);
			try
			{
				NativeListEx.Expand(ref ToOverlapIndices, indices.Length, copyContents: false);
				GatherPlayersWithTicksJob gatherPlayersWithTicksJob = default(GatherPlayersWithTicksJob);
				gatherPlayersWithTicksJob.ValidIndices = ToOverlapIndices;
				gatherPlayersWithTicksJob.TickCache = tickCache;
				gatherPlayersWithTicksJob.Indices = indices;
				GatherPlayersWithTicksJob gatherPlayersWithTicksJob2 = gatherPlayersWithTicksJob;
				IJobExtensions.RunByRef<GatherPlayersWithTicksJob>(ref gatherPlayersWithTicksJob2);
				TimeWarning val3 = TimeWarning.New("GatherPlayerInfo", 0);
				try
				{
					NativeListEx.Expand(ref Batches, ToOverlapIndices.Length, copyContents: false);
					Matrices.Expand<Matrix4x4>(ToOverlapIndices.Length, copyContents: false);
					Enumerator<int> enumerator2 = ToOverlapIndices.GetEnumerator();
					try
					{
						while (enumerator2.MoveNext())
						{
							int current2 = enumerator2.Current;
							BasePlayer basePlayer2 = players[current2];
							Transform parent = ((Component)basePlayer2).transform.parent;
							Matrix4x4 val4 = (((Object)(object)parent == (Object)null) ? Matrix4x4.zero : parent.localToWorldMatrix);
							Matrices.AddNoResize(val4);
							bool excludeVehicleLayer = basePlayer2.vehiclePauseTime <= 0f && !basePlayer2.isMounted;
							bool force = basePlayer2.forceCastTime > 0f;
							Batches.AddNoResize(new Batch
							{
								PlayerIndex = current2,
								Count = (int)basePlayer2.rawTickCount,
								Force = force,
								ExcludeVehicleLayer = excludeVehicleLayer
							});
						}
					}
					finally
					{
						((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				From.Expand<Vector3>(ToOverlapIndices.Length * num2, copyContents: false);
				To.Expand<Vector3>(ToOverlapIndices.Length * num2, copyContents: false);
				GatherNoClipBatchesJob gatherNoClipBatchesJob = default(GatherNoClipBatchesJob);
				gatherNoClipBatchesJob.From = From;
				gatherNoClipBatchesJob.To = To;
				gatherNoClipBatchesJob.Batches = Batches.AsArray();
				gatherNoClipBatchesJob.TickCache = tickCache;
				gatherNoClipBatchesJob.Indices = ToOverlapIndices.AsReadOnly();
				gatherNoClipBatchesJob.Matrices = Matrices.AsReadOnly();
				gatherNoClipBatchesJob.DeltaTimes = deltaTimes;
				gatherNoClipBatchesJob.MaxSteps = num2;
				gatherNoClipBatchesJob.DefaultStepSize = Mathf.Max(ConVar.AntiHack.noclip_stepsize, 0.1f);
				gatherNoClipBatchesJob.DefaultProtection = ConVar.AntiHack.noclip_protection;
				gatherNoClipBatchesJob.MaxTickCount = ConVar.AntiHack.tick_buffer_noclip_threshold * (float)Player.tickrate_cl;
				gatherNoClipBatchesJob.LagThreshold = ConVar.AntiHack.tick_buffer_server_lag_threshold;
				gatherNoClipBatchesJob.TickBufferPrevention = ConVar.AntiHack.tick_buffer_preventions;
				GatherNoClipBatchesJob gatherNoClipBatchesJob2 = gatherNoClipBatchesJob;
				IJobExtensions.RunByRef<GatherNoClipBatchesJob>(ref gatherNoClipBatchesJob2);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			foundIndices.Clear();
			if (!Batches.IsEmpty)
			{
				TestAreNoClipping(playerCache, From.AsReadOnly(), To.AsReadOnly(), Batches.AsReadOnly(), foundIndices, colliders);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool IsSpeeding(BasePlayer ply, TickInterpolator ticks, float deltaTime, in BasePlayer.CachedState initialState)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.IsSpeeding", 0);
		try
		{
			ply.speedhackPauseTime = Mathf.Max(0f, ply.speedhackPauseTime - deltaTime);
			ply.speedhackExtraSpeedTime = Mathf.Max(0f, ply.speedhackExtraSpeedTime - deltaTime);
			if (ConVar.AntiHack.speedhack_protection <= 0)
			{
				return false;
			}
			bool num = (Object)(object)((Component)ply).transform.parent == (Object)null;
			Matrix4x4 val2 = (num ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
			Vector3 val3 = (num ? ticks.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.StartPoint));
			Vector3 val4 = (num ? ticks.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.EndPoint));
			float running = 1f;
			float ducking = 0f;
			float crawling = 0f;
			bool flag = false;
			if (ConVar.AntiHack.speedhack_protection >= 2)
			{
				bool flag2 = ply.IsRunning();
				bool flag3 = ply.IsDucked();
				flag = initialState.IsSwimming;
				bool num2 = ply.IsCrawling();
				running = (flag2 ? 1f : 0f);
				ducking = ((flag3 || flag) ? 1f : 0f);
				crawling = (num2 ? 1f : 0f);
			}
			float speed = ply.GetSpeed(running, ducking, crawling, initialState.IsSwimming);
			Vector3 val5 = val4 - val3;
			float num3 = ((flag && ConVar.AntiHack.speedhack_protection >= 3) ? ((Vector3)(ref val5)).magnitude : Vector3Ex.Magnitude2D(val5));
			float num4 = deltaTime * speed;
			if (!flag && num3 > num4)
			{
				Vector3 val6 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetNormal(val3) : Vector3.up);
				float num5 = Mathf.Max(0f, Vector3.Dot(Vector3Ex.XZ3D(val6), Vector3Ex.XZ3D(val5))) * ConVar.AntiHack.speedhack_slopespeed * deltaTime;
				num3 = Mathf.Max(0f, num3 - num5);
			}
			float num6 = Mathf.Max((ply.speedhackPauseTime > 0f) ? ConVar.AntiHack.speedhack_forgiveness_inertia : ConVar.AntiHack.speedhack_forgiveness, 0.1f);
			float num7 = num6 + Mathf.Max(ConVar.AntiHack.speedhack_forgiveness, 0.1f);
			ply.speedhackDistance = Mathf.Clamp(ply.speedhackDistance, 0f - num7, num7);
			float num8 = ((ply.speedhackExtraSpeedTime > 0f) ? (ply.speedhackExtraSpeed * deltaTime) : 0f);
			ply.speedhackDistance = Mathf.Clamp(ply.speedhackDistance - num4 - num8, 0f - num7, num7);
			if (ply.speedhackDistance > num6)
			{
				return true;
			}
			ply.speedhackDistance = Mathf.Clamp(ply.speedhackDistance + num3, 0f - num7, num7);
			if (ply.speedhackDistance > num6)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool IsFlying(BasePlayer ply, TickInterpolator ticks, float deltaTime, in BasePlayer.CachedState initialState)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.IsFlying", 0);
		try
		{
			ply.flyhackPauseTime = Mathf.Max(0f, ply.flyhackPauseTime - deltaTime);
			if (ConVar.AntiHack.flyhack_protection <= 0)
			{
				return false;
			}
			ticks.Reset();
			if (!ticks.HasNext())
			{
				return false;
			}
			bool flag = (Object)(object)((Component)ply).transform.parent == (Object)null;
			Matrix4x4 val2 = (flag ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
			Vector3 oldPos = (flag ? ticks.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.StartPoint));
			Vector3 newPos = (flag ? ticks.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.EndPoint));
			BasePlayer.CachedState playerState = initialState;
			playerState.IsValid &= ConVar.AntiHack.flyhack_usecachedstate;
			if (ConVar.AntiHack.flyhack_protection >= 3)
			{
				float num = Mathf.Max(ConVar.AntiHack.flyhack_stepsize, 0.1f);
				int num2 = Mathf.Max(ConVar.AntiHack.flyhack_maxsteps, 1);
				num = Mathf.Max(ticks.Length / (float)num2, num);
				while (ticks.MoveNext(num))
				{
					newPos = (flag ? ticks.CurrentPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.CurrentPoint));
					if (TestFlying(ply, oldPos, newPos, verifyGrounded: true, in playerState))
					{
						return true;
					}
					playerState.IsValid = false;
					oldPos = newPos;
				}
			}
			else if (ConVar.AntiHack.flyhack_protection >= 2)
			{
				if (TestFlying(ply, oldPos, newPos, verifyGrounded: true, in playerState))
				{
					return true;
				}
			}
			else if (TestFlying(ply, oldPos, newPos, verifyGrounded: false, in playerState))
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool TestFlying(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool verifyGrounded, in BasePlayer.CachedState playerState)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		bool isInAir = ply.isInAir;
		if (!ply.isInAir)
		{
			ply.lastGroundedPosition = oldPos;
		}
		ply.isInAir = false;
		ply.isOnPlayer = false;
		if (verifyGrounded)
		{
			float flyhack_extrusion = ConVar.AntiHack.flyhack_extrusion;
			Vector3 val = (oldPos + newPos) * 0.5f;
			if (!ply.OnLadder())
			{
				if (playerState.IsValid ? IsInWaterCached(in playerState.WaterInfo, oldPos - new Vector3(0f, flyhack_extrusion, 0f), ply) : WaterLevel.Test(val - new Vector3(0f, flyhack_extrusion, 0f), waves: true, volumes: true, ply))
				{
					if (ply.waterDelay <= 0f)
					{
						ply.waterDelay = 0.3f;
					}
				}
				else if ((EnvironmentManager.Get(val) & EnvironmentType.Elevator) == 0)
				{
					float flyhack_margin = ConVar.AntiHack.flyhack_margin;
					float radius = BasePlayer.GetRadius();
					float height = BasePlayer.GetHeight(ducked: false);
					Vector3 val2 = val + new Vector3(0f, radius - flyhack_extrusion, 0f);
					Vector3 val3 = val + new Vector3(0f, height - radius, 0f);
					float num = radius - flyhack_margin;
					ply.isInAir = !Physics.CheckCapsule(val2, val3, num, 1503764737, (QueryTriggerInteraction)1);
					if (ply.isInAir)
					{
						int num2 = Physics.OverlapCapsuleNonAlloc(val2, val3, num, buffer, 131072, (QueryTriggerInteraction)1);
						for (int i = 0; i < num2; i++)
						{
							BasePlayer basePlayer = ((Component)buffer[i]).gameObject.ToBaseEntity() as BasePlayer;
							if (!((Object)(object)basePlayer == (Object)null) && !((Object)(object)basePlayer == (Object)(object)ply) && !basePlayer.isInAir && !basePlayer.isOnPlayer && !basePlayer.TriggeredAntiHack() && !basePlayer.IsSleeping())
							{
								ply.isOnPlayer = true;
								ply.isInAir = false;
								break;
							}
						}
						for (int j = 0; j < buffer.Length; j++)
						{
							buffer[j] = null;
						}
					}
				}
			}
		}
		else
		{
			ply.isInAir = !ply.OnLadder() && !ply.IsSwimming() && !ply.IsOnGround();
		}
		if (ply.isInAir)
		{
			bool flag = false;
			Vector3 val4 = newPos - oldPos;
			float num3 = Mathf.Abs(val4.y);
			float num4 = Vector3Ex.Magnitude2D(val4);
			if (val4.y >= 0f)
			{
				ply.flyhackDistanceVertical += val4.y;
				flag = true;
			}
			if (num3 < num4)
			{
				ply.flyhackDistanceHorizontal += num4;
				flag = true;
			}
			if (flag)
			{
				float num5 = Mathf.Max((ply.flyhackPauseTime > 0f) ? ConVar.AntiHack.flyhack_forgiveness_vertical_inertia : ConVar.AntiHack.flyhack_forgiveness_vertical, 0f);
				float num6 = BasePlayer.GetJumpHeight() + num5;
				if (ply.flyhackDistanceVertical > num6)
				{
					return true;
				}
				float num7 = Mathf.Max((ply.flyhackPauseTime > 0f) ? ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia : ConVar.AntiHack.flyhack_forgiveness_horizontal, 0f);
				float num8 = 5f + num7;
				if (ply.flyhackDistanceHorizontal > num8)
				{
					return true;
				}
			}
		}
		else
		{
			if (isInAir)
			{
				ply.lastInAirTime = Time.realtimeSinceStartup;
			}
			ply.flyhackDistanceVertical = 0f;
			ply.flyhackDistanceHorizontal = 0f;
		}
		return false;
		static bool IsInWaterCached(in WaterLevel.WaterInfo cachedInfo, Vector3 adjustedPos, BasePlayer player)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			if (!cachedInfo.isValid)
			{
				return WaterLevel.Test(in cachedInfo, volumes: true, adjustedPos, player);
			}
			return true;
		}
	}

	public static bool TestServerSideFallDamage(BasePlayer ply, Vector3 oldPos, Vector3 newPos, float deltaTime)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (ply.waterDelay >= 0f)
		{
			ply.waterDelay -= deltaTime;
		}
		if (ply.isInAir)
		{
			Vector3 val = newPos - oldPos;
			if (val.y < 0f)
			{
				if (ply.timeInAir == 0f)
				{
					ply.initialVelocity = ply.estimatedVelocity;
					ply.fallingDistance = ply.GetHeight();
					ply.timeInAir = 1f;
				}
				ply.timeInAir += deltaTime;
				ply.fallingDistance += val.y;
				if (ply.estimatedVelocity.y < ply.fallingVelocity)
				{
					ply.fallingVelocity = ply.estimatedVelocity.y;
				}
				ply.fallingVelocity = ply.estimatedVelocity.y;
			}
		}
		else if (ply.waterDelay <= 0f)
		{
			if (ply.OnLadder() || ply.IsSwimming())
			{
				ResetServerFall(ply);
				return false;
			}
			float num = 0f - Mathf.Sqrt(Mathf.Abs(0f - ((Vector3)(ref ply.initialVelocity)).magnitude * ((Vector3)(ref ply.initialVelocity)).magnitude + 2f * Physics.gravity.y * ply.fallingDistance) * 1.4f);
			if (ply.fallingVelocity < 0f || (num < 0f && ply.timeInAir > 0f))
			{
				float num2 = Mathf.Max(Mathf.Abs(num), Mathf.Abs(ply.fallingVelocity));
				ply.ApplyFallDamageFromVelocity(0f - num2);
				ResetServerFall(ply);
			}
		}
		return false;
	}

	public static void ResetServerFall(BasePlayer ply)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		ply.fallingVelocity = 0f;
		ply.fallingDistance = 0f;
		ply.timeInAir = 0f;
		ply.initialVelocity = default(Vector3);
	}

	public static bool TestIsBuildingInsideSomething(Construction.Target target, Vector3 deployPos)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.AntiHack.build_inside_check <= 0)
		{
			return false;
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.IsInBounds(deployPos))
			{
				return false;
			}
		}
		if (IsInsideMesh(deployPos) && IsInsideMesh(((Ray)(ref target.ray)).origin))
		{
			LogToConsoleBatched(target.player, AntiHackType.InsideGeometry, "Tried to build while clipped inside " + ((Object)((RaycastHit)(ref isInsideRayHit)).collider).name, 25f);
			if (ConVar.AntiHack.build_inside_check > 1)
			{
				return true;
			}
		}
		return false;
	}

	public static void FadeViolations(BasePlayer ply, float deltaTime)
	{
		if (Time.realtimeSinceStartup - ply.lastViolationTime > ConVar.AntiHack.relaxationpause)
		{
			ply.violationLevel = Mathf.Max(0f, ply.violationLevel - ConVar.AntiHack.relaxationrate * deltaTime);
		}
	}

	public static void EnforceViolations(BasePlayer ply)
	{
		if (ConVar.AntiHack.enforcementlevel > 0 && ply.violationLevel > ConVar.AntiHack.maxviolation)
		{
			if (ConVar.AntiHack.debuglevel >= 1)
			{
				LogToConsole(ply, ply.lastViolationType, "Enforcing (violation of " + ply.violationLevel + ")");
			}
			string reason = ply.lastViolationType.ToString() + " Violation Level " + ply.violationLevel;
			if (ConVar.AntiHack.enforcementlevel > 1)
			{
				Kick(ply, reason);
			}
			else
			{
				Kick(ply, reason);
			}
		}
	}

	public static void Log(BasePlayer ply, AntiHackType type, string message, bool logToAnalytics = true)
	{
		if (ConVar.AntiHack.debuglevel > 1)
		{
			LogToConsole(ply, type, message);
		}
		if (logToAnalytics)
		{
			Analytics.Azure.OnAntihackViolation(ply, type, message);
		}
		LogToEAC(ply, type, message);
	}

	public static void LogToConsoleBatched(BasePlayer ply, AntiHackType type, string message, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		string playerName = ((object)ply).ToString();
		Vector3 position = ((Component)ply).transform.position;
		foreach (GroupedLog groupedLog2 in groupedLogs)
		{
			if (groupedLog2.TryGroup(playerName, type, message, position, maxDistance))
			{
				return;
			}
		}
		GroupedLog groupedLog = Pool.Get<GroupedLog>();
		groupedLog.SetInitial(playerName, type, message, position);
		groupedLogs.Enqueue(groupedLog);
	}

	private static void LogToConsole(BasePlayer ply, AntiHackType type, string message)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[7]
		{
			((object)ply)?.ToString(),
			" ",
			type.ToString(),
			": ",
			message,
			" at ",
			null
		};
		Vector3 position = ((Component)ply).transform.position;
		obj[6] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
		Debug.LogWarning((object)string.Concat(obj));
	}

	private static void LogToConsole(string plyName, AntiHackType type, string message, Vector3 pos)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[7]
		{
			plyName,
			" ",
			type.ToString(),
			": ",
			message,
			" at ",
			null
		};
		Vector3 val = pos;
		obj[6] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
		Debug.LogWarning((object)string.Concat(obj));
	}

	private static void LogToEAC(BasePlayer ply, AntiHackType type, string message)
	{
		if (ConVar.AntiHack.reporting)
		{
			EACServer.SendPlayerBehaviorReport((PlayerReportsCategory)2, ply.UserIDString, type.ToString() + ": " + message);
		}
	}

	public static void AddViolation(BasePlayer ply, AntiHackType type, float amount, GameObject gameObject = null)
	{
		if (Interface.CallHook("OnPlayerViolation", (object)ply, (object)type, (object)amount, (object)gameObject) != null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("AntiHack.AddViolation", 0);
		try
		{
			ply.lastViolationType = type;
			ply.lastViolationTime = Time.realtimeSinceStartup;
			ply.violationLevel += amount;
			if (type == AntiHackType.NoClip || type == AntiHackType.FlyHack || type == AntiHackType.SpeedHack || type == AntiHackType.InsideGeometry || type == AntiHackType.InsideTerrain || type == AntiHackType.Ticks)
			{
				ply.lastMovementViolationTime = Time.realtimeSinceStartup;
			}
			if ((ConVar.AntiHack.debuglevel >= 2 && amount > 0f) || (ConVar.AntiHack.debuglevel >= 3 && type != AntiHackType.NoClip) || ConVar.AntiHack.debuglevel >= 4)
			{
				string text = "Added violation of " + amount + " in frame " + Time.frameCount + " (now has " + ply.violationLevel + ")";
				if ((Object)(object)gameObject != (Object)null)
				{
					text = text + " " + ((Object)gameObject).name;
					BaseEntity baseEntity = gameObject.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null)
					{
						text = text + " (entity: " + baseEntity.ShortPrefabName + ")";
					}
				}
				LogToConsole(ply, type, text);
			}
			EnforceViolations(ply);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Kick(BasePlayer ply, string reason)
	{
		AddRecord(ply, kicks);
		ply.Kick(reason);
	}

	public static void Ban(BasePlayer ply, string reason)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		AddRecord(ply, bans);
		ConsoleSystem.Run(Option.Server, "ban", new object[2]
		{
			ply.userID.Get(),
			reason
		});
	}

	private static void AddRecord(BasePlayer ply, Dictionary<ulong, int> records)
	{
		if (records.ContainsKey(ply.userID))
		{
			records[ply.userID]++;
		}
		else
		{
			records.Add(ply.userID, 1);
		}
	}

	public static int GetKickRecord(BasePlayer ply)
	{
		return GetRecord(ply, kicks);
	}

	public static int GetBanRecord(BasePlayer ply)
	{
		return GetRecord(ply, bans);
	}

	private static int GetRecord(BasePlayer ply, Dictionary<ulong, int> records)
	{
		if (!records.ContainsKey(ply.userID))
		{
			return 0;
		}
		return records[ply.userID];
	}
}


public struct Batch
{
	public int PlayerIndex;

	public int Count;

	public bool Force;

	public bool ExcludeVehicleLayer;
}


using Facepunch;
using UnityEngine;

private class GroupedLog : IPooled
{
	public float firstLogTime;

	public string playerName;

	public AntiHackType antiHackType;

	public string message;

	public Vector3 averagePos;

	public int num;

	public GroupedLog()
	{
	}

	public GroupedLog(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		SetInitial(playerName, antiHackType, message, pos);
	}

	public void EnterPool()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		firstLogTime = 0f;
		playerName = string.Empty;
		antiHackType = AntiHackType.None;
		averagePos = Vector3.zero;
		num = 0;
	}

	public void LeavePool()
	{
	}

	public void SetInitial(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		firstLogTime = Time.unscaledTime;
		this.playerName = playerName;
		this.antiHackType = antiHackType;
		this.message = message;
		averagePos = pos;
		num = 1;
	}

	public bool TryGroup(string playerName, AntiHackType antiHackType, string message, Vector3 pos, float maxDistance)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (antiHackType != this.antiHackType || playerName != this.playerName || message != this.message)
		{
			return false;
		}
		if (Vector3.SqrMagnitude(averagePos - pos) > maxDistance * maxDistance)
		{
			return false;
		}
		Vector3 val = averagePos * (float)num;
		averagePos = (val + pos) / (float)(num + 1);
		num++;
		return true;
	}
}


using System;
using System.Collections;
using ConVar;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Networking;

public static class Auth_CentralizedBans
{
	[JsonModel]
	private class BanPayload
	{
		public ulong steamId;

		public string reason;

		public long expiryDate;

		public bool isMute;
	}

	private static readonly BanPayload payloadData = new BanPayload();

	public static IEnumerator Run(Connection connection)
	{
		int num = default(int);
		UnityWebRequest ownerRequest = default(UnityWebRequest);
		UnityWebRequest userRequest = default(UnityWebRequest);
		while (true)
		{
			object obj = Interface.CallHook("OnCentralizedBanCheck", (object)connection);
			if (obj != null)
			{
				break;
			}
			string text2;
			switch (num)
			{
			default:
				yield break;
			case 0:
				connection.authStatusCentralizedBans = string.Empty;
				if (!connection.active || connection.rejected)
				{
					yield break;
				}
				if (string.IsNullOrWhiteSpace(Server.bansServerEndpoint) || !Server.bansServerEndpoint.StartsWith("http"))
				{
					connection.authStatusCentralizedBans = "ok";
					yield break;
				}
				if (!Server.bansServerEndpoint.EndsWith("/") && !Server.bansServerEndpoint.EndsWith("="))
				{
					Server.bansServerEndpoint += "/";
				}
				if (connection.ownerid != 0L && connection.ownerid != connection.userid)
				{
					string text = Server.bansServerEndpoint + connection.ownerid;
					ownerRequest = UnityWebRequest.Get(text);
					ownerRequest.timeout = Server.bansServerTimeout;
					yield return ownerRequest.SendWebRequest();
					break;
				}
				goto IL_0186;
			case 1:
				if (CheckIfPlayerBanned(connection.ownerid, connection, ownerRequest))
				{
					connection.authStatusCentralizedBans = "banned_account_owner";
					yield break;
				}
				ownerRequest = null;
				goto IL_0186;
			case 2:
				{
					if (CheckIfPlayerBanned(connection.userid, connection, userRequest))
					{
						connection.authStatusCentralizedBans = "banned_account_player";
					}
					else
					{
						connection.authStatusCentralizedBans = "ok";
					}
					yield break;
				}
				IL_0186:
				text2 = Server.bansServerEndpoint + connection.userid;
				userRequest = UnityWebRequest.Get(text2);
				userRequest.timeout = Server.bansServerTimeout;
				yield return userRequest.SendWebRequest();
				break;
			}
		}
	}

	private static bool CheckIfPlayerBanned(ulong steamId, Connection connection, UnityWebRequest request)
	{
		if (request.isNetworkError)
		{
			Debug.LogError((object)("Failed to check centralized bans due to a network error (" + request.error + ")"));
			if (Server.bansServerFailureMode == 1)
			{
				Reject("Centralized Ban Error: Network Error");
				return true;
			}
			return false;
		}
		if (request.responseCode == 404)
		{
			return false;
		}
		if (request.isHttpError)
		{
			Debug.LogError((object)$"Failed to check centralized bans due to a server error ({request.responseCode}: {request.error})");
			if (Server.bansServerFailureMode == 1)
			{
				Reject("Centralized Ban Error: Server Error");
				return true;
			}
			return false;
		}
		try
		{
			payloadData.steamId = 0uL;
			payloadData.reason = null;
			payloadData.expiryDate = 0L;
			payloadData.isMute = false;
			JsonUtility.FromJsonOverwrite(request.downloadHandler.text, (object)payloadData);
			if (payloadData.expiryDate > 0 && Epoch.Current >= payloadData.expiryDate)
			{
				return false;
			}
			if (payloadData.steamId != steamId)
			{
				Debug.LogError((object)$"Failed to check centralized bans due to SteamID mismatch (expected {steamId}, got {payloadData.steamId})");
				if (Server.bansServerFailureMode == 1)
				{
					Reject("Centralized Ban Error: SteamID Mismatch");
					return true;
				}
				return false;
			}
			string text = payloadData.reason ?? "no reason given";
			string text2 = ((payloadData.expiryDate > 0) ? (" for " + NumberExtensions.FormatSecondsLong(payloadData.expiryDate - Epoch.Current)) : "");
			if (payloadData.isMute)
			{
				PlayerState val = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(steamId);
				val.chatMuted = true;
				if (payloadData.expiryDate > 0)
				{
					val.chatMuteExpiryTimestamp = payloadData.expiryDate;
				}
				else
				{
					val.chatMuteExpiryTimestamp = 0.0;
				}
			}
			else
			{
				Reject("You are banned from this server" + text2 + " (" + text + ")");
			}
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to check centralized bans due to a malformed response: " + request.downloadHandler.text));
			Debug.LogException(ex);
			if (Server.bansServerFailureMode == 1)
			{
				Reject("Centralized Ban Error: Malformed Response");
				return true;
			}
			return false;
		}
		void Reject(string reason)
		{
			ConnectionAuth.Reject(connection, reason);
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
	}
}


[JsonModel]
private class BanPayload
{
	public ulong steamId;

	public string reason;

	public long expiryDate;

	public bool isMute;
}


using System.Collections;
using Network;

public static class Auth_EAC
{
	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusEAC = string.Empty;
		if (connection.active && !connection.rejected)
		{
			EACServer.OnJoinGame(connection);
			while (connection.active && !connection.rejected && connection.authStatusEAC == string.Empty)
			{
				yield return null;
			}
		}
	}
}


using System;
using System.Collections;
using System.Threading.Tasks;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using Network;
using UnityEngine;

public static class Auth_Nexus
{
	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusNexus = string.Empty;
		if (!connection.active || connection.rejected)
		{
			yield break;
		}
		if (!NexusServer.Started)
		{
			connection.authStatusNexus = "ok";
			yield break;
		}
		Task<NexusLoginResult> loginTask = NexusServer.Login(connection.userid);
		yield return (object)new WaitUntil((Func<bool>)(() => loginTask.IsCompleted));
		if (loginTask.IsFaulted || loginTask.IsCanceled)
		{
			Reject("Nexus login failure");
			if (loginTask.Exception != null)
			{
				Debug.LogException((Exception)loginTask.Exception);
			}
			connection.authStatusNexus = "nexus_login_fail";
			yield break;
		}
		NexusLoginResult result = loginTask.Result;
		if (((NexusLoginResult)(ref result)).IsRedirect)
		{
			string text = ((((NexusLoginResult)(ref result)).AssignedZoneKey == null) ? null : NexusServer.FindZone(((NexusLoginResult)(ref result)).AssignedZoneKey)?.ConnectionProtocol());
			ConsoleNetwork.SendClientCommandImmediate(connection, "nexus.redirect", ((NexusLoginResult)(ref result)).RedirectIpAddress, ((NexusLoginResult)(ref result)).RedirectGamePort, text ?? "");
			Reject("Redirecting to another zone...");
			connection.authStatusNexus = "nexus_login_redirect";
			yield break;
		}
		if (((NexusLoginResult)(ref result)).AssignedZoneKey == null)
		{
			string spawnZoneKey;
			NexusZoneDetails spawnZone;
			try
			{
				spawnZoneKey = ZoneController.Instance.ChooseSpawnZone(connection.userid, isAlreadyAssignedToThisZone: false);
				if (string.IsNullOrWhiteSpace(spawnZoneKey))
				{
					throw new Exception("ZoneController did not choose a spawn zone (returned '" + (spawnZoneKey ?? "<null>") + "')");
				}
				spawnZone = NexusServer.FindZone(spawnZoneKey);
				if (spawnZone == null)
				{
					throw new Exception("ZoneController picked a spawn zone which we don't know about (" + spawnZoneKey + ")");
				}
			}
			catch (Exception ex)
			{
				Reject("Nexus spawn - exception while choosing spawn zone");
				Debug.LogException(ex);
				connection.authStatusNexus = "nexus_zone_pick_fail";
				yield break;
			}
			Task assignTask = NexusServer.AssignInitialZone(connection.userid, spawnZoneKey);
			yield return (object)new WaitUntil((Func<bool>)(() => assignTask.IsCompleted));
			if (assignTask.IsFaulted || assignTask.IsCanceled)
			{
				Reject("Nexus spawn - exception while registering transfer to spawn zone");
				if (assignTask.Exception != null)
				{
					Debug.LogException((Exception)assignTask.Exception);
				}
				connection.authStatusNexus = "nexus_zone_transfer_fail";
				yield break;
			}
			if (spawnZoneKey != NexusServer.ZoneKey)
			{
				ConsoleNetwork.SendClientCommandImmediate(connection, "nexus.redirect", spawnZone.IpAddress, spawnZone.GamePort, spawnZone.ConnectionProtocol());
				Reject("Redirecting to another zone...");
				connection.authStatusNexus = "nexus_zone_redirect";
				yield break;
			}
		}
		if (NexusServer.TryGetPlayer(connection.userid, out var player))
		{
			Variable val = default(Variable);
			if (!player.TryGetVariable("appKey", ref val) || (int)val.Type != 1 || string.IsNullOrWhiteSpace(val.GetAsString()))
			{
				player.SetVariable("appKey", Guid.NewGuid().ToString("N"), false, false);
			}
		}
		else
		{
			Debug.LogWarning((object)$"Couldn't find NexusPlayer for {connection.userid}, skipping setting up their app key");
		}
		connection.authStatusNexus = "ok";
		void Reject(string reason)
		{
			ConnectionAuth.Reject(connection, reason);
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
	}
}


using System;
using System.Collections;
using System.Threading.Tasks;
using ConVar;
using Network;
using UnityEngine;

public static class Auth_PremiumServer
{
	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusPremiumServer = string.Empty;
		if (!connection.active || connection.rejected)
		{
			yield break;
		}
		if (!Server.premium)
		{
			connection.authStatusPremiumServer = "ok";
			yield break;
		}
		Task<PremiumUtil.PremiumCheckResult> checkTask = PremiumUtil.CheckIfPlayerIsPremium(connection.userid);
		yield return (object)new WaitUntil((Func<bool>)(() => checkTask.IsCompleted));
		if (checkTask.IsFaulted || checkTask.IsCanceled)
		{
			Reject(connection, "Failed to validate premium status: Faulted/Canceled");
			if (checkTask.Exception != null)
			{
				Debug.LogException((Exception)checkTask.Exception);
			}
			connection.authStatusNexus = "premium_error";
		}
		else if (!checkTask.Result.IsPremium)
		{
			Reject(connection, checkTask.Result.FailReason ?? "Failed to validate premium status: Unknown Fail Reason");
			connection.authStatusPremiumServer = "account_not_premium";
		}
		else
		{
			connection.authStatusPremiumServer = "ok";
			connection.lastPremiumCheckTime = Time.realtimeSinceStartupAsDouble;
		}
	}

	private static void Reject(Connection connection, string reason)
	{
		ConnectionAuth.Reject(connection, reason);
		PlatformService.Instance.EndPlayerSession(connection.userid);
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;

public static class Auth_Steam
{
	internal static List<Connection> waitingList = new List<Connection>();

	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusSteam = string.Empty;
		if (!connection.active || connection.rejected)
		{
			yield break;
		}
		if (!PlatformService.Instance.BeginPlayerSession(connection.userid, connection.token))
		{
			ConnectionAuth.Reject(connection, "Steam Auth Failed");
			yield break;
		}
		waitingList.Add(connection);
		Stopwatch timeout = Stopwatch.StartNew();
		while (timeout.Elapsed.TotalSeconds < 30.0 && connection.active && !(connection.authStatusSteam != string.Empty))
		{
			yield return null;
		}
		waitingList.Remove(connection);
		if (connection.active)
		{
			if (connection.authStatusSteam.Length == 0)
			{
				ConnectionAuth.Reject(connection, "Steam Auth Timeout: No auth response");
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam == "banned")
			{
				ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam == "gamebanned")
			{
				ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam == "vacbanned")
			{
				ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam != "ok")
			{
				ConnectionAuth.Reject(connection, "Steam Auth Failed", "Steam Auth Error: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else
			{
				string text = (Server.censorplayerlist ? RandomUsernames.Get(connection.userid + (ulong)Random.Range(0, 100000)) : connection.username);
				PlatformService.Instance.UpdatePlayerSession(connection.userid, text);
			}
		}
	}

	public static bool ValidateConnecting(ulong steamid, ulong ownerSteamID, AuthResponse response)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Invalid comparison between Unknown and I4
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Invalid comparison between Unknown and I4
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Invalid comparison between Unknown and I4
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Invalid comparison between Unknown and I4
		Connection val = waitingList.Find((Connection x) => x.userid == steamid);
		if (val == null)
		{
			return false;
		}
		val.ownerid = ownerSteamID;
		if (ServerUsers.Is(ownerSteamID, ServerUsers.UserGroup.Banned) || ServerUsers.Is(steamid, ServerUsers.UserGroup.Banned))
		{
			val.authStatusSteam = "banned";
			return true;
		}
		if ((int)response == 2)
		{
			val.authStatusSteam = "ok";
			return true;
		}
		if ((int)response == 3)
		{
			val.authStatusSteam = "vacbanned";
			return true;
		}
		if ((int)response == 4)
		{
			val.authStatusSteam = "gamebanned";
			return true;
		}
		if (!Server.strictauth_steam && (int)response == 1)
		{
			Debug.LogWarning((object)("Steam Auth Timeout: AuthResponse.TimedOut for " + steamid + " / " + ownerSteamID + " - bypassing since strictauth_steam is false"));
			val.authStatusSteam = "ok";
			return true;
		}
		val.authStatusSteam = ((object)(AuthResponse)(ref response)/*cast due to .constrained prefix*/).ToString();
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using UnityEngine;

public class ConnectionAuth : MonoBehaviour
{
	[NonSerialized]
	public static List<Connection> m_AuthConnection = new List<Connection>();

	private static RealTimeSince _sinceClientRequirementRefresh;

	private static (int, int)? _clientRequirementCache;

	private static string _clientVersionMismatchMessage;

	public bool IsAuthed(ulong iSteamID)
	{
		if (Object.op_Implicit((Object)(object)BasePlayer.FindByID(iSteamID)))
		{
			return true;
		}
		if (SingletonComponent<ServerMgr>.Instance.connectionQueue.IsJoining(iSteamID))
		{
			return true;
		}
		if (SingletonComponent<ServerMgr>.Instance.connectionQueue.IsQueued(iSteamID))
		{
			return true;
		}
		return false;
	}

	public static void Reject(Connection connection, string strReason, string strReasonPrivate = null)
	{
		DebugEx.Log((object)(((object)connection).ToString() + " Rejecting connection - " + (string.IsNullOrEmpty(strReasonPrivate) ? strReason : strReasonPrivate)), (StackTraceLogType)0);
		Net.sv.Kick(connection, strReason, false);
		m_AuthConnection.Remove(connection);
	}

	public static void OnDisconnect(Connection connection)
	{
		m_AuthConnection.Remove(connection);
	}

	public void Approve(Connection connection)
	{
		m_AuthConnection.Remove(connection);
		SingletonComponent<ServerMgr>.Instance.connectionQueue.Join(connection);
	}

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2594)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log((object)("Not kicking " + connection.userid + " for incompatible protocol (is a developer)"), (StackTraceLogType)0);
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + NumberExtensions.FormatSecondsLong(user.expiry - Epoch.Current)) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log((object)(((object)connection).ToString() + " has auth level 1"), (StackTraceLogType)0);
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log((object)(((object)connection).ToString() + " has auth level 2"), (StackTraceLogType)0);
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log((object)(((object)connection).ToString() + " is a developer"), (StackTraceLogType)0);
			connection.authLevel = 3u;
		}
		if (Interface.CallHook("IOnUserApprove", (object)connection) == null)
		{
			m_AuthConnection.Add(connection);
			((MonoBehaviour)this).StartCoroutine(AuthorisationRoutine(connection));
		}
	}

	public IEnumerator AuthorisationRoutine(Connection connection)
	{
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_Steam.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_EAC.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_CentralizedBans.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_Nexus.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_PremiumServer.Run(connection));
		if (connection.rejected || !connection.active)
		{
			yield break;
		}
		if (IsAuthed(connection.userid))
		{
			Reject(connection, "You are already connected as a player!");
			yield break;
		}
		if (connection.authLevel == 0)
		{
			(int, int)? minClientRequirement = GetMinClientRequirement();
			if (minClientRequirement.HasValue && (connection.clientChangeset < minClientRequirement.Value.Item1 || connection.clientBuildTime < minClientRequirement.Value.Item2))
			{
				Reject(connection, GetClientVersionMismatchMessage());
				yield break;
			}
		}
		Approve(connection);
	}

	private static (int Changeset, int BuildTime)? GetMinClientRequirement()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Invalid comparison between Unknown and I4
		if (RealTimeSince.op_Implicit(_sinceClientRequirementRefresh) < 10f)
		{
			return _clientRequirementCache;
		}
		_sinceClientRequirementRefresh = RealTimeSince.op_Implicit(0f);
		_clientRequirementCache = null;
		try
		{
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.Branch : null);
			}
			if (obj == null)
			{
				obj = "";
			}
			string text = (string)obj;
			if (!string.IsNullOrWhiteSpace(text))
			{
				JObject obj2 = Application.Manifest?.Metadata;
				object obj3;
				if (obj2 == null)
				{
					obj3 = null;
				}
				else
				{
					JToken obj4 = obj2["ClientVersions"];
					obj3 = ((obj4 != null) ? obj4[(object)text] : null);
				}
				JToken val = (JToken)obj3;
				if (val != null && (int)val.Type == 1)
				{
					int item = val.Value<int>((object)"Changeset");
					int item2 = val.Value<int>((object)"Timestamp");
					_clientRequirementCache = (item, item2);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			_clientRequirementCache = null;
		}
		return _clientRequirementCache;
	}

	private static string GetClientVersionMismatchMessage()
	{
		if (!string.IsNullOrEmpty(_clientVersionMismatchMessage))
		{
			return _clientVersionMismatchMessage;
		}
		BuildInfo current = BuildInfo.Current;
		object obj;
		if (current == null)
		{
			obj = null;
		}
		else
		{
			ScmInfo scm = current.Scm;
			obj = ((scm != null) ? scm.Branch : null);
		}
		if (obj == null)
		{
			obj = "unknown";
		}
		string text = (string)obj;
		string text2 = text.ToLowerInvariant();
		string clientVersionMismatchMessage = ((text2 == "release") ? "Client update required. Close Rust and apply update from Steam." : ((!(text2 == "main")) ? ("Client update required. Apply \"Rust - Staging Branch\" (" + text + " beta) update from Steam.") : "Client update required. Apply \"Rust - Staging Branch\" update from Steam."));
		_clientVersionMismatchMessage = clientVersionMismatchMessage;
		return _clientVersionMismatchMessage;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;

public class ConnectionQueue
{
	private class ReservedServerSlot : IPooled
	{
		public ulong UserId;

		public float Expiry;

		public void EnterPool()
		{
		}

		public void LeavePool()
		{
			UserId = 0uL;
			Expiry = 0f;
		}
	}

	public List<Connection> queue = new List<Connection>();

	public List<Connection> joining = new List<Connection>();

	private List<ReservedServerSlot> reservedSlots = new List<ReservedServerSlot>();

	private float nextCleanupReservedSlots;

	public float nextMessageTime;

	public int ReservedCount => reservedSlots.Count;

	public int Queued => queue.Count;

	public int Joining => joining.Count;

	public bool IsServerFull => SingletonComponent<ServerMgr>.Instance.AvailableSlots - Joining <= 0;

	public void SkipQueue(ulong userid)
	{
		for (int i = 0; i < queue.Count; i++)
		{
			Connection val = queue[i];
			if (val.userid == userid)
			{
				JoinGame(val);
				break;
			}
		}
	}

	internal void Join(Connection connection)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnConnectionQueue", (object)connection) == null)
		{
			nextMessageTime = 0f;
			if ((Queued == 0 && !IsServerFull) || CanJumpQueue(connection))
			{
				JoinGame(connection);
				return;
			}
			connection.state = (State)2;
			queue.Add(connection);
		}
	}

	public void Cycle(int availableSlots)
	{
		if (Interface.CallHook("OnQueueCycle", (object)availableSlots) != null)
		{
			return;
		}
		if (Time.realtimeSinceStartup > nextCleanupReservedSlots)
		{
			nextCleanupReservedSlots = Time.realtimeSinceStartup + 1f;
			CleanupExpiredReservedSlots();
		}
		if (queue.Count != 0)
		{
			SendQueueUpdates();
			if (!IsServerFull)
			{
				JoinGame(queue[0]);
			}
		}
	}

	public void SendQueueUpdates()
	{
		if (!(nextMessageTime > Time.realtimeSinceStartup))
		{
			nextMessageTime = Time.realtimeSinceStartup + 10f;
			for (int i = 0; i < queue.Count; i++)
			{
				SendQueueUpdate(queue[i], i);
			}
		}
	}

	public void SendQueueUpdate(Connection c, int position)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnQueueUpdate", (object)c, (object)position) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)26);
			obj.UInt16((ushort)Queued);
			obj.UInt16((ushort)position);
			obj.Send(new SendInfo(c));
		}
	}

	public void RemoveConnection(Connection connection)
	{
		if (Interface.CallHook("OnConnectionDequeue", (object)connection) == null)
		{
			if (queue.Remove(connection))
			{
				nextMessageTime = 0f;
			}
			joining.Remove(connection);
		}
	}

	public void TryAddReservedSlot(Connection connection)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Invalid comparison between Unknown and I4
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Invalid comparison between Unknown and I4
		if (connection.canReserveSlot && ((int)connection.state == 4 || (int)connection.state == 3))
		{
			AddReservation(connection.userid);
		}
	}

	private void JoinGame(Connection connection)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		queue.Remove(connection);
		connection.state = (State)3;
		RemoveReservedSlot(connection.userid);
		nextMessageTime = 0f;
		joining.Add(connection);
		SingletonComponent<ServerMgr>.Instance.JoinGame(connection);
	}

	public void JoinedGame(Connection connection)
	{
		RemoveConnection(connection);
	}

	private void AddReservation(ulong userId)
	{
		ReservedServerSlot reservedServerSlot = FindQueueSpot(userId);
		if (reservedServerSlot == null)
		{
			reservedServerSlot = Pool.Get<ReservedServerSlot>();
			reservedSlots.Add(reservedServerSlot);
		}
		reservedServerSlot.UserId = userId;
		reservedServerSlot.Expiry = Time.realtimeSinceStartup + (float)Server.rejoin_delay;
	}

	private void CleanupExpiredReservedSlots()
	{
		if (reservedSlots.Count == 0)
		{
			return;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			ReservedServerSlot reservedServerSlot = reservedSlots[i];
			if (realtimeSinceStartup > reservedServerSlot.Expiry)
			{
				reservedSlots.RemoveAt(i);
				i--;
				Pool.Free<ReservedServerSlot>(ref reservedServerSlot);
			}
		}
	}

	private ReservedServerSlot FindQueueSpot(ulong userId)
	{
		foreach (ReservedServerSlot reservedSlot in reservedSlots)
		{
			if (reservedSlot.UserId == userId)
			{
				return reservedSlot;
			}
		}
		return null;
	}

	private void RemoveReservedSlot(ulong userId)
	{
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			ReservedServerSlot reservedServerSlot = reservedSlots[i];
			if (reservedServerSlot.UserId == userId)
			{
				reservedSlots.RemoveAt(i);
				i--;
				Pool.Free<ReservedServerSlot>(ref reservedServerSlot);
			}
		}
	}

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", (object)connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
		{
			return true;
		}
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			if (reservedSlots[i].UserId == connection.userid && reservedSlots[i].Expiry > Time.realtimeSinceStartup)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsQueued(ulong userid)
	{
		for (int i = 0; i < queue.Count; i++)
		{
			if (queue[i].userid == userid)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsJoining(ulong userid)
	{
		for (int i = 0; i < joining.Count; i++)
		{
			if (joining[i].userid == userid)
			{
				return true;
			}
		}
		return false;
	}
}


using Facepunch;

private class ReservedServerSlot : IPooled
{
	public ulong UserId;

	public float Expiry;

	public void EnterPool()
	{
	}

	public void LeavePool()
	{
		UserId = 0uL;
		Expiry = 0f;
	}
}


using System;
using System.Collections.Concurrent;
using System.IO;
using ConVar;
using Epic.OnlineServices;
using Epic.OnlineServices.AntiCheatCommon;
using Epic.OnlineServices.AntiCheatServer;
using Epic.OnlineServices.Connect;
using Epic.OnlineServices.Reports;
using Network;
using Oxide.Core;
using UnityEngine;

public static class EACServer
{
	private static AntiCheatServerInterface Interface = null;

	private static ReportsInterface Reports = null;

	private static ConcurrentDictionary<uint, Connection> client2connection = new ConcurrentDictionary<uint, Connection>();

	private static ConcurrentDictionary<Connection, uint> connection2client = new ConcurrentDictionary<Connection, uint>();

	private static ConcurrentDictionary<Connection, AntiCheatCommonClientAuthStatus> connection2status = new ConcurrentDictionary<Connection, AntiCheatCommonClientAuthStatus>();

	private static uint clientHandleCounter = 0u;

	private static bool CanEnableGameplayData
	{
		get
		{
			if (Server.official)
			{
				return Server.stats;
			}
			return false;
		}
	}

	private static bool CanSendAnalytics
	{
		get
		{
			if (CanEnableGameplayData)
			{
				return (Handle)(object)Interface != (Handle)null;
			}
			return false;
		}
	}

	private static bool CanSendReports => (Handle)(object)Reports != (Handle)null;

	private static IntPtr GenerateCompatibilityClient()
	{
		return (IntPtr)(++clientHandleCounter);
	}

	public static void Encrypt(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		uint count = (uint)dst.Count;
		dst = new ArraySegment<byte>(dst.Array, dst.Offset, 0);
		if (!((Handle)(object)Interface != (Handle)null))
		{
			return;
		}
		IntPtr client = GetClient(connection);
		if (client != IntPtr.Zero)
		{
			ProtectMessageOptions val = default(ProtectMessageOptions);
			((ProtectMessageOptions)(ref val)).ClientHandle = client;
			((ProtectMessageOptions)(ref val)).Data = src;
			((ProtectMessageOptions)(ref val)).OutBufferSizeBytes = count;
			ProtectMessageOptions val2 = val;
			uint count2 = default(uint);
			Result val3 = Interface.ProtectMessage(ref val2, dst, ref count2);
			if ((int)val3 == 0)
			{
				dst = new ArraySegment<byte>(dst.Array, dst.Offset, (int)count2);
			}
			else
			{
				Debug.LogWarning((object)("[EAC] ProtectMessage failed: " + ((object)(Result)(ref val3)/*cast due to .constrained prefix*/).ToString()));
			}
		}
	}

	public static void Decrypt(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		uint count = (uint)dst.Count;
		dst = new ArraySegment<byte>(dst.Array, dst.Offset, 0);
		if (!((Handle)(object)Interface != (Handle)null))
		{
			return;
		}
		IntPtr client = GetClient(connection);
		if (client != IntPtr.Zero)
		{
			UnprotectMessageOptions val = default(UnprotectMessageOptions);
			((UnprotectMessageOptions)(ref val)).ClientHandle = client;
			((UnprotectMessageOptions)(ref val)).Data = src;
			((UnprotectMessageOptions)(ref val)).OutBufferSizeBytes = count;
			UnprotectMessageOptions val2 = val;
			uint count2 = default(uint);
			Result val3 = Interface.UnprotectMessage(ref val2, dst, ref count2);
			if ((int)val3 == 0)
			{
				dst = new ArraySegment<byte>(dst.Array, dst.Offset, (int)count2);
			}
			else
			{
				Debug.LogWarning((object)("[EAC] UnprotectMessage failed: " + ((object)(Result)(ref val3)/*cast due to .constrained prefix*/).ToString()));
			}
		}
	}

	private static IntPtr GetClient(Connection connection)
	{
		connection2client.TryGetValue(connection, out var value);
		return (IntPtr)value;
	}

	private static Connection GetConnection(IntPtr client)
	{
		client2connection.TryGetValue((uint)(int)client, out var value);
		return value;
	}

	public static bool IsAuthenticated(Connection connection)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		connection2status.TryGetValue(connection, out var value);
		return (int)value == 2;
	}

	private static void OnAuthenticatedLocal(Connection connection)
	{
		if (!Server.strictauth_eac && connection.authStatusEAC == string.Empty)
		{
			connection.authStatusEAC = "ok";
		}
		connection2status[connection] = (AntiCheatCommonClientAuthStatus)1;
	}

	private static void OnAuthenticatedRemote(Connection connection)
	{
		if (Server.strictauth_eac && connection.authStatusEAC == string.Empty)
		{
			connection.authStatusEAC = "ok";
		}
		connection2status[connection] = (AntiCheatCommonClientAuthStatus)2;
	}

	private static void OnVerifyIdToken(ref VerifyIdTokenCallbackInfo data)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.anticheattoken)
		{
			Debug.LogWarning((object)"[EAC] Verify ID token skipped: server.anticheattoken == false");
			return;
		}
		IntPtr client = (IntPtr)((VerifyIdTokenCallbackInfo)(ref data)).ClientData;
		Connection connection = GetConnection(client);
		if (connection == null)
		{
			Debug.LogError((object)("[EAC] Verify ID token for invalid client: " + client));
			return;
		}
		if (connection.IsDevelopmentBuild())
		{
			Debug.LogWarning((object)("[EAC] Verify ID token skipped for unprotected client: " + ((object)connection).ToString()));
			return;
		}
		if ((int)((VerifyIdTokenCallbackInfo)(ref data)).ResultCode != 0)
		{
			Result resultCode = ((VerifyIdTokenCallbackInfo)(ref data)).ResultCode;
			string text = "Verify ID token " + ((object)(Result)(ref resultCode)/*cast due to .constrained prefix*/).ToString();
			Debug.Log((object)$"[EAC] Kicking {connection.userid} / {connection.username} ({text})");
			connection.authStatusEAC = "eactoken";
			Net.sv.Kick(connection, "EAC: " + text, false);
			return;
		}
		string text2 = ((object)((VerifyIdTokenCallbackInfo)(ref data)).AccountId).ToString();
		string text3 = connection.userid.ToString();
		if (text2 != text3)
		{
			string text4 = "Verify ID token account mismatch with " + text2 + " != " + text3;
			Debug.Log((object)$"[EAC] Kicking {connection.userid} / {connection.username} ({text4})");
			connection.authStatusEAC = "eactoken";
			Net.sv.Kick(connection, "EAC: " + text4, false);
		}
	}

	private static void OnClientAuthStatusChanged(ref OnClientAuthStatusChangedCallbackInfo data)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Invalid comparison between Unknown and I4
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Invalid comparison between Unknown and I4
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Expected O, but got Unknown
		TimeWarning val = TimeWarning.New("AntiCheatKickPlayer", 10);
		try
		{
			IntPtr clientHandle = ((OnClientAuthStatusChangedCallbackInfo)(ref data)).ClientHandle;
			Connection connection = GetConnection(clientHandle);
			if (connection == null)
			{
				Debug.LogError((object)("[EAC] Status update for invalid client: " + clientHandle));
			}
			else if ((int)((OnClientAuthStatusChangedCallbackInfo)(ref data)).ClientAuthStatus == 1)
			{
				OnAuthenticatedLocal(connection);
				SetClientNetworkStateOptions val2 = default(SetClientNetworkStateOptions);
				((SetClientNetworkStateOptions)(ref val2)).ClientHandle = clientHandle;
				((SetClientNetworkStateOptions)(ref val2)).IsNetworkActive = false;
				SetClientNetworkStateOptions val3 = val2;
				Interface.SetClientNetworkState(ref val3);
			}
			else if ((int)((OnClientAuthStatusChangedCallbackInfo)(ref data)).ClientAuthStatus == 2)
			{
				OnAuthenticatedRemote(connection);
				IdToken val4 = default(IdToken);
				((IdToken)(ref val4)).ProductUserId = ProductUserId.FromString(Utf8String.op_Implicit(connection.anticheatId));
				((IdToken)(ref val4)).JsonWebToken = Utf8String.op_Implicit(connection.anticheatToken);
				IdToken val5 = val4;
				EOS.VerifyIdToken(clientHandle, val5, new OnVerifyIdTokenCallback(OnVerifyIdToken));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void OnClientActionRequired(ref OnClientActionRequiredCallbackInfo data)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Invalid comparison between Unknown and I4
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Invalid comparison between Unknown and I4
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Invalid comparison between Unknown and I4
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Invalid comparison between Unknown and I4
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("OnClientActionRequired", 10);
		try
		{
			IntPtr clientHandle = ((OnClientActionRequiredCallbackInfo)(ref data)).ClientHandle;
			Connection connection = GetConnection(clientHandle);
			if (connection == null)
			{
				Debug.LogError((object)("[EAC] Status update for invalid client: " + clientHandle));
			}
			else
			{
				if ((int)((OnClientActionRequiredCallbackInfo)(ref data)).ClientAction != 1)
				{
					return;
				}
				Utf8String actionReasonDetailsString = ((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonDetailsString;
				if (connection.IsDevelopmentBuild())
				{
					Debug.LogWarning((object)("[EAC] Remove player action skipped for unprotected client: " + ((object)connection).ToString()));
					return;
				}
				Debug.Log((object)$"[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})");
				connection.authStatusEAC = "eac";
				Net.sv.Kick(connection, Utf8String.op_Implicit(Utf8String.op_Implicit("EAC: ") + actionReasonDetailsString), false);
				Interface.CallHook("OnPlayerKicked", (object)connection, (object)actionReasonDetailsString.ToString());
				if ((int)((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonCode == 10 || (int)((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonCode == 9)
				{
					connection.authStatusEAC = "eacbanned";
					ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username + " (banned by anticheat)");
					Interface.CallHook("OnPlayerBanned", (object)connection, (object)actionReasonDetailsString.ToString());
					if ((int)((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonCode == 10)
					{
						Entity.DeleteBy(connection.userid);
					}
				}
				UnregisterClientOptions val2 = default(UnregisterClientOptions);
				((UnregisterClientOptions)(ref val2)).ClientHandle = clientHandle;
				UnregisterClientOptions val3 = val2;
				Interface.UnregisterClient(ref val3);
				client2connection.TryRemove((uint)(int)clientHandle, out var _);
				connection2client.TryRemove(connection, out var _);
				connection2status.TryRemove(connection, out var _);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void SendToClient(ref OnMessageToClientCallbackInfo data)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		IntPtr clientHandle = ((OnMessageToClientCallbackInfo)(ref data)).ClientHandle;
		Connection connection = GetConnection(clientHandle);
		if (connection == null)
		{
			Debug.LogError((object)("[EAC] Network packet for invalid client: " + clientHandle));
			return;
		}
		NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
		obj.PacketID((Type)22);
		obj.UInt32((uint)((OnMessageToClientCallbackInfo)(ref data)).MessageData.Count);
		((Stream)(object)obj).Write(((OnMessageToClientCallbackInfo)(ref data)).MessageData.Array, ((OnMessageToClientCallbackInfo)(ref data)).MessageData.Offset, ((OnMessageToClientCallbackInfo)(ref data)).MessageData.Count);
		obj.Send(new SendInfo(connection));
	}

	public static void DoStartup()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Expected O, but got Unknown
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Expected O, but got Unknown
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Expected O, but got Unknown
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv.secure && !Application.isEditor)
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
			AddNotifyClientActionRequiredOptions val = default(AddNotifyClientActionRequiredOptions);
			AddNotifyClientAuthStatusChangedOptions val2 = default(AddNotifyClientAuthStatusChangedOptions);
			AddNotifyMessageToClientOptions val3 = default(AddNotifyMessageToClientOptions);
			BeginSessionOptions val4 = default(BeginSessionOptions);
			((BeginSessionOptions)(ref val4)).LocalUserId = null;
			((BeginSessionOptions)(ref val4)).EnableGameplayData = CanEnableGameplayData;
			((BeginSessionOptions)(ref val4)).RegisterTimeoutSeconds = 20u;
			((BeginSessionOptions)(ref val4)).ServerName = Utf8String.op_Implicit(Server.hostname);
			BeginSessionOptions val5 = val4;
			LogGameRoundStartOptions val6 = default(LogGameRoundStartOptions);
			((LogGameRoundStartOptions)(ref val6)).LevelName = Utf8String.op_Implicit(World.Name);
			LogGameRoundStartOptions val7 = val6;
			EOS.Initialize(true, Server.anticheatid, Server.anticheatkey, Server.rootFolder + "/Log.EAC.txt");
			Interface = EOS.Interface.GetAntiCheatServerInterface();
			Interface.AddNotifyClientActionRequired(ref val, (object)null, new OnClientActionRequiredCallback(OnClientActionRequired));
			Interface.AddNotifyClientAuthStatusChanged(ref val2, (object)null, new OnClientAuthStatusChangedCallback(OnClientAuthStatusChanged));
			Interface.AddNotifyMessageToClient(ref val3, (object)null, new OnMessageToClientCallback(SendToClient));
			Interface.BeginSession(ref val5);
			Interface.LogGameRoundStart(ref val7);
		}
		else
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
		}
	}

	public static void DoUpdate()
	{
		if (Net.sv.secure && !Application.isEditor)
		{
			EOS.Tick();
		}
	}

	public static void DoShutdown()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv.secure && !Application.isEditor)
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
			if ((Handle)(object)Interface != (Handle)null)
			{
				Debug.Log((object)"EasyAntiCheat Server Shutting Down");
				EndSessionOptions val = default(EndSessionOptions);
				Interface.EndSession(ref val);
				Interface = null;
				EOS.Shutdown();
			}
		}
		else
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
		}
	}

	public static void OnLeaveGame(Connection connection)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		AntiCheatCommonClientAuthStatus value3;
		if (Net.sv.secure && !Application.isEditor)
		{
			if ((Handle)(object)Interface != (Handle)null)
			{
				IntPtr client = GetClient(connection);
				if (client != IntPtr.Zero)
				{
					UnregisterClientOptions val = default(UnregisterClientOptions);
					((UnregisterClientOptions)(ref val)).ClientHandle = client;
					UnregisterClientOptions val2 = val;
					Interface.UnregisterClient(ref val2);
					client2connection.TryRemove((uint)(int)client, out var _);
				}
				connection2client.TryRemove(connection, out var _);
				connection2status.TryRemove(connection, out value3);
			}
		}
		else
		{
			connection2status.TryRemove(connection, out value3);
		}
	}

	public static void OnJoinGame(Connection connection)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Invalid comparison between Unknown and I4
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv.secure && !Application.isEditor)
		{
			if (!((Handle)(object)Interface != (Handle)null))
			{
				return;
			}
			IntPtr intPtr = GenerateCompatibilityClient();
			if (intPtr == IntPtr.Zero)
			{
				Debug.LogError((object)("[EAC] GenerateCompatibilityClient returned invalid client: " + intPtr));
				return;
			}
			RegisterClientOptions val = default(RegisterClientOptions);
			((RegisterClientOptions)(ref val)).ClientHandle = intPtr;
			((RegisterClientOptions)(ref val)).UserId = ProductUserId.FromString(Utf8String.op_Implicit(connection.anticheatId));
			((RegisterClientOptions)(ref val)).IpAddress = Utf8String.op_Implicit(connection.IPAddressWithoutPort());
			((RegisterClientOptions)(ref val)).ClientType = (AntiCheatCommonClientType)(connection.IsDevelopmentBuild() ? 1 : 0);
			((RegisterClientOptions)(ref val)).ClientPlatform = (AntiCheatCommonClientPlatform)((connection.os == "windows") ? 1 : ((connection.os == "linux") ? 3 : ((connection.os == "mac") ? 2 : 0)));
			RegisterClientOptions val2 = val;
			if ((int)((RegisterClientOptions)(ref val2)).ClientType == 1)
			{
				Debug.LogWarning((object)("[EAC] Joining game as unprotected client: " + ((object)connection).ToString()));
			}
			SetClientDetailsOptions val3 = default(SetClientDetailsOptions);
			((SetClientDetailsOptions)(ref val3)).ClientHandle = intPtr;
			((SetClientDetailsOptions)(ref val3)).ClientFlags = (AntiCheatCommonClientFlags)((connection.authLevel != 0) ? 1 : 0);
			SetClientDetailsOptions val4 = val3;
			Interface.RegisterClient(ref val2);
			Interface.SetClientDetails(ref val4);
			client2connection.TryAdd((uint)(int)intPtr, connection);
			connection2client.TryAdd(connection, (uint)(int)intPtr);
			connection2status.TryAdd(connection, (AntiCheatCommonClientAuthStatus)0);
		}
		else
		{
			connection2status.TryAdd(connection, (AntiCheatCommonClientAuthStatus)0);
			OnAuthenticatedLocal(connection);
			OnAuthenticatedRemote(connection);
		}
	}

	public static void OnStartLoading(Connection connection)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Handle)(object)Interface != (Handle)null)
		{
			IntPtr client = GetClient(connection);
			if (client != IntPtr.Zero)
			{
				SetClientNetworkStateOptions val = default(SetClientNetworkStateOptions);
				((SetClientNetworkStateOptions)(ref val)).ClientHandle = client;
				((SetClientNetworkStateOptions)(ref val)).IsNetworkActive = false;
				SetClientNetworkStateOptions val2 = val;
				Interface.SetClientNetworkState(ref val2);
			}
		}
	}

	public static void OnFinishLoading(Connection connection)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Handle)(object)Interface != (Handle)null)
		{
			IntPtr client = GetClient(connection);
			if (client != IntPtr.Zero)
			{
				SetClientNetworkStateOptions val = default(SetClientNetworkStateOptions);
				((SetClientNetworkStateOptions)(ref val)).ClientHandle = client;
				((SetClientNetworkStateOptions)(ref val)).IsNetworkActive = true;
				SetClientNetworkStateOptions val2 = val;
				Interface.SetClientNetworkState(ref val2);
			}
		}
	}

	public static void OnMessageReceived(Message message)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		IntPtr client = GetClient(message.connection);
		byte[] array = default(byte[]);
		int count = default(int);
		if (client == IntPtr.Zero)
		{
			Debug.LogError((object)("EAC network packet from invalid connection: " + message.connection.userid));
		}
		else if (message.read.TemporaryBytesWithSize(ref array, ref count))
		{
			ReceiveMessageFromClientOptions val = default(ReceiveMessageFromClientOptions);
			((ReceiveMessageFromClientOptions)(ref val)).ClientHandle = client;
			((ReceiveMessageFromClientOptions)(ref val)).Data = new ArraySegment<byte>(array, 0, count);
			ReceiveMessageFromClientOptions val2 = val;
			Interface.ReceiveMessageFromClient(ref val2);
		}
	}

	public static void LogPlayerUseWeapon(BasePlayer player, BaseProjectile weapon)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && player.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerShooting", 0);
			try
			{
				Vector3 networkPosition = player.GetNetworkPosition();
				Quaternion networkRotation = player.GetNetworkRotation();
				Item item = weapon.GetItem();
				string text = ((item != null) ? item.info.shortname : "unknown");
				LogPlayerUseWeaponOptions val2 = default(LogPlayerUseWeaponOptions);
				LogPlayerUseWeaponData value = default(LogPlayerUseWeaponData);
				((LogPlayerUseWeaponData)(ref value)).PlayerHandle = GetClient(player.net.connection);
				Vec3f value2 = default(Vec3f);
				((Vec3f)(ref value2)).x = networkPosition.x;
				((Vec3f)(ref value2)).y = networkPosition.y;
				((Vec3f)(ref value2)).z = networkPosition.z;
				((LogPlayerUseWeaponData)(ref value)).PlayerPosition = value2;
				Quat value3 = default(Quat);
				((Quat)(ref value3)).w = networkRotation.w;
				((Quat)(ref value3)).x = networkRotation.x;
				((Quat)(ref value3)).y = networkRotation.y;
				((Quat)(ref value3)).z = networkRotation.z;
				((LogPlayerUseWeaponData)(ref value)).PlayerViewRotation = value3;
				((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit(text);
				((LogPlayerUseWeaponOptions)(ref val2)).UseWeaponData = value;
				Interface.LogPlayerUseWeapon(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void LogPlayerSpawn(BasePlayer player)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && player.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerSpawn", 0);
			try
			{
				LogPlayerSpawnOptions val2 = default(LogPlayerSpawnOptions);
				((LogPlayerSpawnOptions)(ref val2)).SpawnedPlayerHandle = GetClient(player.net.connection);
				Interface.LogPlayerSpawn(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void LogPlayerDespawn(BasePlayer player)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && player.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerDespawn", 0);
			try
			{
				LogPlayerDespawnOptions val2 = default(LogPlayerDespawnOptions);
				((LogPlayerDespawnOptions)(ref val2)).DespawnedPlayerHandle = GetClient(player.net.connection);
				Interface.LogPlayerDespawn(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void LogPlayerTakeDamage(BasePlayer player, HitInfo info, bool wasWounded)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		if (!CanSendAnalytics || !((Object)(object)info.Initiator != (Object)null) || !(info.Initiator is BasePlayer))
		{
			return;
		}
		BasePlayer basePlayer = info.Initiator.ToPlayer();
		if (player.net.connection == null || basePlayer.net.connection == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EAC.LogPlayerTakeDamage", 0);
		try
		{
			LogPlayerTakeDamageOptions val2 = default(LogPlayerTakeDamageOptions);
			LogPlayerUseWeaponData value = default(LogPlayerUseWeaponData);
			((LogPlayerTakeDamageOptions)(ref val2)).AttackerPlayerHandle = GetClient(basePlayer.net.connection);
			((LogPlayerTakeDamageOptions)(ref val2)).VictimPlayerHandle = GetClient(player.net.connection);
			((LogPlayerTakeDamageOptions)(ref val2)).DamageTaken = info.damageTypes.Total();
			Vec3f value2 = default(Vec3f);
			((Vec3f)(ref value2)).x = info.HitPositionWorld.x;
			((Vec3f)(ref value2)).y = info.HitPositionWorld.y;
			((Vec3f)(ref value2)).z = info.HitPositionWorld.z;
			((LogPlayerTakeDamageOptions)(ref val2)).DamagePosition = value2;
			((LogPlayerTakeDamageOptions)(ref val2)).IsCriticalHit = info.isHeadshot;
			if (player.IsDead())
			{
				((LogPlayerTakeDamageOptions)(ref val2)).DamageResult = (AntiCheatCommonPlayerTakeDamageResult)(wasWounded ? 5 : 4);
			}
			else if (player.IsWounded())
			{
				((LogPlayerTakeDamageOptions)(ref val2)).DamageResult = (AntiCheatCommonPlayerTakeDamageResult)3;
			}
			if ((Object)(object)info.Weapon != (Object)null)
			{
				Item item = info.Weapon.GetItem();
				if (item != null)
				{
					((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit(item.info.shortname);
				}
				else
				{
					((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit("unknown");
				}
			}
			else
			{
				((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit("unknown");
			}
			Vector3 position = basePlayer.eyes.position;
			Quaternion rotation = basePlayer.eyes.rotation;
			Vector3 position2 = player.eyes.position;
			Quaternion rotation2 = player.eyes.rotation;
			value2 = default(Vec3f);
			((Vec3f)(ref value2)).x = position.x;
			((Vec3f)(ref value2)).y = position.y;
			((Vec3f)(ref value2)).z = position.z;
			((LogPlayerTakeDamageOptions)(ref val2)).AttackerPlayerPosition = value2;
			Quat value3 = default(Quat);
			((Quat)(ref value3)).w = rotation.w;
			((Quat)(ref value3)).x = rotation.x;
			((Quat)(ref value3)).y = rotation.y;
			((Quat)(ref value3)).z = rotation.z;
			((LogPlayerTakeDamageOptions)(ref val2)).AttackerPlayerViewRotation = value3;
			value2 = default(Vec3f);
			((Vec3f)(ref value2)).x = position2.x;
			((Vec3f)(ref value2)).y = position2.y;
			((Vec3f)(ref value2)).z = position2.z;
			((LogPlayerTakeDamageOptions)(ref val2)).VictimPlayerPosition = value2;
			value3 = default(Quat);
			((Quat)(ref value3)).w = rotation2.w;
			((Quat)(ref value3)).x = rotation2.x;
			((Quat)(ref value3)).y = rotation2.y;
			((Quat)(ref value3)).z = rotation2.z;
			((LogPlayerTakeDamageOptions)(ref val2)).VictimPlayerViewRotation = value3;
			((LogPlayerTakeDamageOptions)(ref val2)).PlayerUseWeaponData = value;
			Interface.LogPlayerTakeDamage(ref val2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static void LogPlayerTick(BasePlayer player, in BasePlayer.CachedState tickState)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		if (!CanSendAnalytics || player.net == null || player.net.connection == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EAC.LogPlayerTick", 0);
		try
		{
			Vector3 position = player.eyes.position;
			Quaternion rotation = player.eyes.rotation;
			Vector3 center = player.GetCenter();
			LogPlayerTickOptions val2 = default(LogPlayerTickOptions);
			((LogPlayerTickOptions)(ref val2)).PlayerHandle = GetClient(player.net.connection);
			Vec3f value = default(Vec3f);
			((Vec3f)(ref value)).x = center.x;
			((Vec3f)(ref value)).y = center.y;
			((Vec3f)(ref value)).z = center.z;
			((LogPlayerTickOptions)(ref val2)).PlayerPosition = value;
			value = default(Vec3f);
			((Vec3f)(ref value)).x = position.x;
			((Vec3f)(ref value)).y = position.y;
			((Vec3f)(ref value)).z = position.z;
			((LogPlayerTickOptions)(ref val2)).PlayerViewPosition = value;
			Quat value2 = default(Quat);
			((Quat)(ref value2)).w = rotation.w;
			((Quat)(ref value2)).x = rotation.x;
			((Quat)(ref value2)).y = rotation.y;
			((Quat)(ref value2)).z = rotation.z;
			((LogPlayerTickOptions)(ref val2)).PlayerViewRotation = value2;
			((LogPlayerTickOptions)(ref val2)).PlayerHealth = player.Health();
			if (player.IsDucked())
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 1);
			}
			if (player.isMounted)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 3);
			}
			if (player.IsCrawling())
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 2);
			}
			if (tickState.IsSwimming)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 4);
			}
			if (!player.IsOnGround())
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 5);
			}
			if (player.OnLadder())
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 7);
			}
			if (player.IsFlying)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 6);
			}
			Interface.LogPlayerTick(ref val2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void LogPlayerRevive(BasePlayer source, BasePlayer target)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && target.net.connection != null && (Object)(object)source != (Object)null && source.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerRevive", 0);
			try
			{
				LogPlayerReviveOptions val2 = default(LogPlayerReviveOptions);
				((LogPlayerReviveOptions)(ref val2)).RevivedPlayerHandle = GetClient(target.net.connection);
				((LogPlayerReviveOptions)(ref val2)).ReviverPlayerHandle = GetClient(source.net.connection);
				Interface.LogPlayerRevive(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void SendPlayerBehaviorReport(BasePlayer reporter, PlayerReportsCategory reportCategory, string reportedID, string reportText)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendReports)
		{
			SendPlayerBehaviorReportOptions val = default(SendPlayerBehaviorReportOptions);
			((SendPlayerBehaviorReportOptions)(ref val)).ReportedUserId = ProductUserId.FromString(Utf8String.op_Implicit(reportedID));
			((SendPlayerBehaviorReportOptions)(ref val)).ReporterUserId = ProductUserId.FromString(Utf8String.op_Implicit(reporter.UserIDString));
			((SendPlayerBehaviorReportOptions)(ref val)).Category = reportCategory;
			((SendPlayerBehaviorReportOptions)(ref val)).Message = Utf8String.op_Implicit(reportText);
			SendPlayerBehaviorReportOptions val2 = val;
			Reports.SendPlayerBehaviorReport(ref val2, (object)null, (OnSendPlayerBehaviorReportCompleteCallback)null);
		}
	}

	public static void SendPlayerBehaviorReport(PlayerReportsCategory reportCategory, string reportedID, string reportText)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendReports)
		{
			SendPlayerBehaviorReportOptions val = default(SendPlayerBehaviorReportOptions);
			((SendPlayerBehaviorReportOptions)(ref val)).ReportedUserId = ProductUserId.FromString(Utf8String.op_Implicit(reportedID));
			((SendPlayerBehaviorReportOptions)(ref val)).Category = reportCategory;
			((SendPlayerBehaviorReportOptions)(ref val)).Message = Utf8String.op_Implicit(reportText);
			SendPlayerBehaviorReportOptions val2 = val;
			Reports.SendPlayerBehaviorReport(ref val2, (object)null, (OnSendPlayerBehaviorReportCompleteCallback)null);
		}
	}
}


using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using ConVar;
using UnityEngine;

public static class MapUploader
{
	private static readonly HttpClient Http = new HttpClient();

	public static bool IsUploaded { get; private set; }

	public static string OriginalName { get; private set; }

	public static string OriginalMapFileName { get; private set; }

	public static string OriginalSaveFileName { get; private set; }

	public static bool IsImageUploaded { get; private set; }

	public static string ImageUrl { get; private set; }

	public static async Task UploadMap()
	{
		if (IsUploaded)
		{
			Debug.Log((object)"[Rust.MapCache] Map was already uploaded!");
			return;
		}
		if (!World.Procedural)
		{
			Debug.Log((object)"[Rust.MapCache] Server is not using a procedural map, will not upload to backend");
			return;
		}
		if (World.CanLoadFromUrl())
		{
			Debug.Log((object)"[Rust.MapCache] server.levelurl appears to have already been set, not uploading map to backend");
			return;
		}
		string mapFileName = World.MapFileName;
		string fullPath = Path.GetFullPath(Path.Join((ReadOnlySpan<char>)World.MapFolderName, (ReadOnlySpan<char>)mapFileName));
		if (!File.Exists(fullPath))
		{
			Debug.LogWarning((object)("[Rust.MapCache] Map file was not found: " + fullPath));
			return;
		}
		try
		{
			using FileStream fs = File.OpenRead(fullPath);
			string text = await UploadMapImpl(fs, mapFileName);
			if (text != null)
			{
				OriginalName = World.Name;
				OriginalMapFileName = World.MapFileName;
				OriginalSaveFileName = World.SaveFileName;
				Server.levelurl = text;
				World.Url = text;
				IsUploaded = true;
				Debug.Log((object)("[Rust.MapCache] Map uploaded to backend: " + text));
			}
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"[Rust.MapCache] Failed to upload map to backend: {arg}");
		}
	}

	private static async Task<string> UploadMapImpl(Stream stream, string mapFileName)
	{
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		if (string.IsNullOrWhiteSpace(mapFileName))
		{
			throw new ArgumentNullException("mapFileName");
		}
		if (!stream.CanRead || !stream.CanSeek)
		{
			throw new ArgumentException("Stream must be readable and seekable.", "stream");
		}
		string requestUri = "https://api.facepunch.com/api/public/rust-map-upload/" + mapFileName;
		for (int i = 0; i < 10; i++)
		{
			try
			{
				stream.Seek(0L, SeekOrigin.Begin);
				using MemoryStream streamCopy = new MemoryStream();
				await stream.CopyToAsync(streamCopy);
				streamCopy.Position = 0L;
				HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Put, requestUri);
				try
				{
					request.Content = (HttpContent)new StreamContent((Stream)streamCopy);
					HttpResponseMessage response = await Http.SendAsync(request);
					try
					{
						if (response.IsSuccessStatusCode)
						{
							string text = await response.Content.ReadAsStringAsync();
							if (string.IsNullOrWhiteSpace(text) || !text.StartsWith("http"))
							{
								throw new Exception("Backend sent an invalid success response when uploading the map.");
							}
							return text;
						}
						int statusCode = (int)response.StatusCode;
						if (statusCode >= 400 && statusCode <= 499)
						{
							Debug.LogError((object)("[Rust.MapCache] Backend refused our map upload request: " + await response.Content.ReadAsStringAsync()));
							return null;
						}
						response.EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)response)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)request)?.Dispose();
				}
			}
			catch (Exception arg)
			{
				Debug.LogWarning((object)$"[Rust.MapCache] Failed to upload map file: {arg}");
				await Task.Delay(1000 + i * 5000);
			}
		}
		Debug.LogError((object)"[Rust.MapCache] Unable to upload map file!");
		return null;
	}

	public static async void UploadMapImage(byte[] image)
	{
		if (IsImageUploaded)
		{
			Debug.Log((object)"[Rust.MapCache-Images] Image was already uploaded!");
			return;
		}
		string mapFileName = World.MapFileName;
		try
		{
			string text = await UploadMapImageImpl(image, mapFileName);
			if (text != null)
			{
				ImageUrl = text;
				IsImageUploaded = true;
				Debug.Log((object)("[Rust.MapCache-Images] Image uploaded to backend: " + text));
			}
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"[Rust.MapCache-Images] Failed to upload image to backend: {arg}");
		}
	}

	private static async Task<string> UploadMapImageImpl(byte[] image, string mapFileName)
	{
		if (image == null)
		{
			throw new ArgumentNullException("image");
		}
		if (string.IsNullOrWhiteSpace(mapFileName))
		{
			throw new ArgumentNullException("mapFileName");
		}
		if (image.Length == 0)
		{
			throw new ArgumentException("Empty image", "image");
		}
		string requestUri = "https://api.facepunch.com/api/public/rust-map-image-upload/" + mapFileName;
		for (int i = 0; i < 10; i++)
		{
			try
			{
				HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Put, requestUri);
				try
				{
					request.Content = (HttpContent)new ByteArrayContent(image);
					request.Content.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
					HttpResponseMessage response = await Http.SendAsync(request);
					try
					{
						if (response.IsSuccessStatusCode)
						{
							string text = await response.Content.ReadAsStringAsync();
							if (string.IsNullOrWhiteSpace(text) || !text.StartsWith("http"))
							{
								throw new Exception("Backend sent an invalid success response when uploading the map image");
							}
							return text;
						}
						int statusCode = (int)response.StatusCode;
						if (statusCode >= 400 && statusCode <= 499)
						{
							Debug.LogError((object)("[Rust.MapCache-Images] Backend refused our image upload request: " + await response.Content.ReadAsStringAsync()));
							return null;
						}
						response.EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)response)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)request)?.Dispose();
				}
			}
			catch (Exception arg)
			{
				Debug.LogWarning((object)$"[Rust.MapCache-Images] Failed to upload map file: {arg}");
				await Task.Delay(1000 + i * 5000);
			}
		}
		Debug.LogError((object)"[Rust.MapCache-Images] Unable to upload image!");
		return null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using ProtoBuf.Nexus;
using Rust;
using UnityEngine;

public class NexusClanBackend : IClanBackend, IDisposable
{
	private readonly Dictionary<long, NexusClanWrapper> _clanWrappers;

	private IClanChangeSink _changeSink;

	private NexusClanChatCollector _chatCollector;

	private NexusClanEventHandler _eventHandler;

	private NexusZoneClient _client;

	public NexusClanBackend()
	{
		_clanWrappers = new Dictionary<long, NexusClanWrapper>();
	}

	public ValueTask Initialize(IClanChangeSink changeSink)
	{
		if (!NexusServer.Started)
		{
			throw new InvalidOperationException("Cannot use the Nexus clan backend when nexus is not enabled on this server!");
		}
		_clanWrappers.Clear();
		_changeSink = changeSink;
		_chatCollector = new NexusClanChatCollector(changeSink);
		_eventHandler = new NexusClanEventHandler(this, changeSink);
		_client = NexusServer.ZoneClient;
		_client.ClanEventListener = (INexusClanEventListener)(object)_eventHandler;
		((MonoBehaviour)Global.Runner).StartCoroutine(BroadcastClanChatBatches());
		return default(ValueTask);
	}

	public void Dispose()
	{
		_clanWrappers.Clear();
		_changeSink = null;
		_chatCollector = null;
		_eventHandler = null;
		NexusZoneClient client = _client;
		if (((client != null) ? client.ClanEventListener : null) != null)
		{
			_client.ClanEventListener = null;
		}
		_client = null;
	}

	public async ValueTask<ClanValueResult<IClan>> Get(long clanId)
	{
		NexusClanResult<NexusClan> val = await _client.GetClan(clanId);
		NexusClan clan = default(NexusClan);
		if (val.IsSuccess && val.TryGetResponse(ref clan))
		{
			return ClanValueResult<IClan>.op_Implicit((IClan)(object)Wrap(clan));
		}
		return ClanValueResult<IClan>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public bool TryGet(long clanId, out IClan clan)
	{
		NexusClan clan2 = default(NexusClan);
		if (!_client.TryGetClan(clanId, ref clan2))
		{
			clan = null;
			return false;
		}
		clan = (IClan)(object)Wrap(clan2);
		return true;
	}

	public async ValueTask<ClanValueResult<IClan>> GetByMember(ulong steamId)
	{
		NexusClanResult<NexusClan> val = await _client.GetClanByMember(NexusClanUtil.GetPlayerId(steamId));
		NexusClan clan = default(NexusClan);
		if (val.IsSuccess && val.TryGetResponse(ref clan))
		{
			return ClanValueResult<IClan>.op_Implicit((IClan)(object)Wrap(clan));
		}
		return ClanValueResult<IClan>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanValueResult<IClan>> Create(ulong leaderSteamId, string name)
	{
		ClanCreateParameters val = default(ClanCreateParameters);
		((ClanCreateParameters)(ref val)).ClanName = name;
		((ClanCreateParameters)(ref val)).ClanNameNormalized = name.ToLowerInvariant().Normalize(NormalizationForm.FormKC);
		((ClanCreateParameters)(ref val)).LeaderPlayerId = NexusClanUtil.GetPlayerId(leaderSteamId);
		((ClanCreateParameters)(ref val)).LeaderRoleName = "Leader";
		((ClanCreateParameters)(ref val)).LeaderRoleVariables = NexusClanUtil.DefaultLeaderVariables;
		((ClanCreateParameters)(ref val)).MemberRoleName = "Member";
		ClanCreateParameters val2 = val;
		NexusClanResult<NexusClan> val3 = await _client.CreateClan(val2);
		NexusClan clan = default(NexusClan);
		if (val3.IsSuccess && val3.TryGetResponse(ref clan))
		{
			return ClanValueResult<IClan>.op_Implicit((IClan)(object)Wrap(clan));
		}
		return ClanValueResult<IClan>.op_Implicit(val3.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanValueResult<List<ClanInvitation>>> ListInvitations(ulong steamId)
	{
		NexusClanResult<List<ClanInvitation>> val = await _client.ListClanInvitations(NexusClanUtil.GetPlayerId(steamId));
		List<ClanInvitation> source = default(List<ClanInvitation>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			List<ClanInvitation> list = source.Select(delegate(ClanInvitation i)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0037: Unknown result type (might be due to invalid IL or missing references)
				ClanInvitation result = default(ClanInvitation);
				result.ClanId = ((ClanInvitation)(ref i)).ClanId;
				result.Recruiter = NexusClanUtil.GetSteamId(((ClanInvitation)(ref i)).RecruiterPlayerId);
				result.Timestamp = ((ClanInvitation)(ref i)).Timestamp;
				return result;
			}).ToList();
			return new ClanValueResult<List<ClanInvitation>>(list);
		}
		return ClanValueResult<List<ClanInvitation>>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanValueResult<List<ClanLeaderboardEntry>>> GetLeaderboard(int limit = 100)
	{
		NexusClanResult<List<ClanLeaderboardEntry>> val = await _client.GetClanLeaderboard(limit);
		List<ClanLeaderboardEntry> source = default(List<ClanLeaderboardEntry>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			List<ClanLeaderboardEntry> list = source.Select(delegate(ClanLeaderboardEntry c)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				ClanLeaderboardEntry result = default(ClanLeaderboardEntry);
				result.ClanId = ((ClanLeaderboardEntry)(ref c)).ClanId;
				result.Name = ((ClanLeaderboardEntry)(ref c)).Name;
				result.Score = ((ClanLeaderboardEntry)(ref c)).Score;
				return result;
			}).ToList();
			return new ClanValueResult<List<ClanLeaderboardEntry>>(list);
		}
		return ClanValueResult<List<ClanLeaderboardEntry>>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public void HandleClanChatBatch(ClanChatBatchRequest request)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (_changeSink == null)
		{
			return;
		}
		foreach (Message message in request.messages)
		{
			_changeSink.ClanChatMessage(message.clanId, new ClanChatEntry
			{
				SteamId = message.userId,
				Message = message.text,
				Name = message.name,
				Time = message.timestamp
			});
		}
	}

	private IEnumerator BroadcastClanChatBatches()
	{
		while (_chatCollector != null && NexusServer.Started)
		{
			List<Message> list = Pool.Get<List<Message>>();
			_chatCollector.TakeMessages(list);
			if (list.Count > 0)
			{
				SendClanChatBatch(list);
			}
			else
			{
				Pool.Free<Message>(ref list, false);
			}
			yield return CoroutineEx.waitForSecondsRealtime(Nexus.clanClatBatchDuration);
		}
		static async void SendClanChatBatch(List<Message> messages)
		{
			Request val = Pool.Get<Request>();
			val.isFireAndForget = true;
			val.clanChatBatch = Pool.Get<ClanChatBatchRequest>();
			val.clanChatBatch.messages = messages;
			try
			{
				(await NexusServer.BroadcastRpc(val))?.Dispose();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
	}

	public void UpdateWrapper(long clanId)
	{
		NexusClanWrapper value;
		lock (_clanWrappers)
		{
			if (!_clanWrappers.TryGetValue(clanId, out value))
			{
				return;
			}
		}
		value.UpdateValuesInternal();
	}

	public void RemoveWrapper(long clanId)
	{
		lock (_clanWrappers)
		{
			_clanWrappers.Remove(clanId);
		}
	}

	private NexusClanWrapper Wrap(NexusClan clan)
	{
		lock (_clanWrappers)
		{
			if (_clanWrappers.TryGetValue(clan.ClanId, out var value) && value.Internal == clan)
			{
				return value;
			}
			value = new NexusClanWrapper(clan, _chatCollector);
			_clanWrappers[clan.ClanId] = value;
			return value;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;

public class NexusClanChatCollector
{
	private readonly IClanChangeSink _external;

	private readonly List<Message> _messagesBuffer;

	public NexusClanChatCollector(IClanChangeSink external)
	{
		_external = external ?? throw new ArgumentNullException("external");
		_messagesBuffer = new List<Message>();
	}

	public void TakeMessages(List<Message> messages)
	{
		foreach (Message item in _messagesBuffer)
		{
			messages.Add(item);
		}
		_messagesBuffer.Clear();
	}

	public void OnClanChatMessage(long clanId, ClanChatEntry entry)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Message val = Pool.Get<Message>();
		val.clanId = clanId;
		val.userId = entry.SteamId;
		val.name = entry.Name;
		val.text = entry.Message;
		val.timestamp = entry.Time;
		_messagesBuffer.Add(val);
		_external.ClanChatMessage(clanId, entry);
	}
}


using System;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;

public class NexusClanEventHandler : INexusClanEventListener
{
	private readonly NexusClanBackend _backend;

	private readonly IClanChangeSink _changeSink;

	public NexusClanEventHandler(NexusClanBackend backend, IClanChangeSink changeSink)
	{
		_backend = backend ?? throw new ArgumentNullException("backend");
		_changeSink = changeSink ?? throw new ArgumentNullException("changeSink");
	}

	public void OnDisbanded(in ClanDisbandedEvent args)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		IClanChangeSink changeSink = _changeSink;
		ClanDisbandedEvent val = args;
		changeSink.ClanDisbanded(((ClanDisbandedEvent)(ref val)).ClanId);
		val = args;
		foreach (string member in ((ClanDisbandedEvent)(ref val)).Members)
		{
			ulong steamId = NexusClanUtil.GetSteamId(member);
			_changeSink.MembershipChanged(steamId, (long?)null);
		}
	}

	public void OnInvitation(in ClanInvitedEvent args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ClanInvitedEvent val = args;
		ulong steamId = NexusClanUtil.GetSteamId(((ClanInvitedEvent)(ref val)).PlayerId);
		IClanChangeSink changeSink = _changeSink;
		val = args;
		changeSink.InvitationCreated(steamId, ((ClanInvitedEvent)(ref val)).ClanId);
	}

	public void OnJoined(in ClanJoinedEvent args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ClanJoinedEvent val = args;
		ulong steamId = NexusClanUtil.GetSteamId(((ClanJoinedEvent)(ref val)).PlayerId);
		IClanChangeSink changeSink = _changeSink;
		val = args;
		changeSink.MembershipChanged(steamId, (long?)((ClanJoinedEvent)(ref val)).ClanId);
	}

	public void OnKicked(in ClanKickedEvent args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		ClanKickedEvent val = args;
		ulong steamId = NexusClanUtil.GetSteamId(((ClanKickedEvent)(ref val)).PlayerId);
		_changeSink.MembershipChanged(steamId, (long?)null);
	}

	public void OnChanged(in ClanChangedEvent args)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		NexusClanBackend backend = _backend;
		ClanChangedEvent val = args;
		backend.UpdateWrapper(((ClanChangedEvent)(ref val)).ClanId);
		IClanChangeSink changeSink = _changeSink;
		val = args;
		changeSink.ClanChanged(((ClanChangedEvent)(ref val)).ClanId, (ClanDataSource)(-1));
	}

	public void OnUnload(in long clanId)
	{
		_backend.RemoveWrapper(clanId);
	}

	void INexusClanEventListener.OnDisbanded(in ClanDisbandedEvent args)
	{
		OnDisbanded(in args);
	}

	void INexusClanEventListener.OnInvitation(in ClanInvitedEvent args)
	{
		OnInvitation(in args);
	}

	void INexusClanEventListener.OnJoined(in ClanJoinedEvent args)
	{
		OnJoined(in args);
	}

	void INexusClanEventListener.OnKicked(in ClanKickedEvent args)
	{
		OnKicked(in args);
	}

	void INexusClanEventListener.OnChanged(in ClanChangedEvent args)
	{
		OnChanged(in args);
	}

	void INexusClanEventListener.OnUnload(in long clanId)
	{
		OnUnload(in clanId);
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using UnityEngine;

public static class NexusClanUtil
{
	public const string MotdVariable = "motd";

	public const string MotdAuthorVariable = "motd_author";

	public const string LogoVariable = "logo";

	public const string ColorVariable = "color";

	public const string CanSetLogoVariable = "can_set_logo";

	public const string CanSetMotdVariable = "can_set_motd";

	public const string CanSetPlayerNotesVariable = "can_set_player_notes";

	public const string PlayerNoteVariable = "notes";

	public static readonly List<VariableUpdate> DefaultLeaderVariables = new List<VariableUpdate>
	{
		new VariableUpdate("can_set_logo", bool.TrueString, (bool?)null, (bool?)null),
		new VariableUpdate("can_set_motd", bool.TrueString, (bool?)null, (bool?)null),
		new VariableUpdate("can_set_player_notes", bool.TrueString, (bool?)null, (bool?)null)
	};

	private static readonly Memoized<string, ulong> SteamIdToPlayerId = new Memoized<string, ulong>((Func<ulong, string>)((ulong steamId) => steamId.ToString("G")));

	public static string GetPlayerId(ulong steamId)
	{
		return SteamIdToPlayerId.Get(steamId);
	}

	public static string GetPlayerId(ulong? steamId)
	{
		if (!steamId.HasValue)
		{
			return null;
		}
		return SteamIdToPlayerId.Get(steamId.Value);
	}

	public static ulong GetSteamId(string playerId)
	{
		return ulong.Parse(playerId);
	}

	public static ulong? TryGetSteamId(string playerId)
	{
		if (!ulong.TryParse(playerId, out var result))
		{
			return null;
		}
		return result;
	}

	public static void GetMotd(this NexusClan clan, out string motd, out long motdTimestamp, out ulong motdAuthor)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Invalid comparison between Unknown and I4
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Invalid comparison between Unknown and I4
		Variable val = default(Variable);
		Variable val2 = default(Variable);
		if (!clan.TryGetVariable("motd", ref val) || !clan.TryGetVariable("motd_author", ref val2) || (int)val.Type != 1 || (int)val2.Type != 1)
		{
			motd = null;
			motdTimestamp = 0L;
			motdAuthor = 0uL;
		}
		else
		{
			motd = val.GetAsString();
			motdTimestamp = val.LastUpdated * 1000;
			motdAuthor = GetSteamId(val2.GetAsString());
		}
	}

	public static void GetBanner(this NexusClan clan, out byte[] logo, out Color32 color)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Invalid comparison between Unknown and I4
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Variable val = default(Variable);
		logo = ((clan.TryGetVariable("logo", ref val) && (int)val.Type == 0) ? val.GetAsBinary() : null);
		Variable val2 = default(Variable);
		color = ((clan.TryGetVariable("color", ref val2) && (int)val2.Type == 1) ? ColorEx.FromInt32(int.Parse(val2.GetAsString())) : Color32.op_Implicit(Color.white));
	}

	public static ClanRole ToClanRole(this NexusClanRole role)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = role.Rank == 1;
		ClanRole result = default(ClanRole);
		result.RoleId = role.RoleId;
		result.Rank = role.Rank;
		result.Name = role.Name;
		result.CanInvite = flag || role.CanInvite;
		result.CanKick = flag || role.CanKick;
		result.CanPromote = flag || role.CanPromote;
		result.CanDemote = flag || role.CanDemote;
		Variable variable = default(Variable);
		result.CanSetLogo = flag || (role.TryGetVariable("can_set_logo", ref variable) && ParseFlag(variable));
		Variable variable2 = default(Variable);
		result.CanSetMotd = flag || (role.TryGetVariable("can_set_motd", ref variable2) && ParseFlag(variable2));
		Variable variable3 = default(Variable);
		result.CanSetPlayerNotes = flag || (role.TryGetVariable("can_set_player_notes", ref variable3) && ParseFlag(variable3));
		result.CanAccessLogs = flag || role.CanAccessLogs;
		result.CanAccessScoreEvents = flag || role.CanAccessScoreEvents;
		return result;
	}

	public static ClanMember ToClanMember(this NexusClanMember member)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		Variable val = default(Variable);
		member.TryGetVariable("notes", ref val);
		ClanMember result = default(ClanMember);
		result.SteamId = GetSteamId(member.PlayerId);
		result.RoleId = member.RoleId;
		result.Joined = member.Joined * 1000;
		result.LastSeen = member.LastSeen * 1000;
		result.Notes = ((val != null) ? val.GetAsString() : null);
		result.NotesTimestamp = ((val != null) ? val.LastUpdated : 0);
		return result;
	}

	public static ClanInvite ToClanInvite(this ClanInvite invite)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		ClanInvite result = default(ClanInvite);
		result.SteamId = GetSteamId(((ClanInvite)(ref invite)).PlayerId);
		result.Recruiter = GetSteamId(((ClanInvite)(ref invite)).RecruiterPlayerId);
		result.Timestamp = ((ClanInvite)(ref invite)).Created * 1000;
		return result;
	}

	public static ClanResult ToClanResult(this NexusClanResultCode result)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected I4, but got Unknown
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		return (ClanResult)((int)result switch
		{
			0 => 0, 
			1 => 1, 
			2 => 3, 
			3 => 4, 
			4 => 5, 
			5 => 9, 
			6 => 10, 
			7 => 11, 
			8 => 12, 
			9 => 13, 
			10 => 14, 
			11 => 15, 
			_ => throw new NotSupportedException($"Cannot map NexusClanResultCode {result} to ClanResult"), 
		});
	}

	public static ClanRoleParameters ToRoleParameters(this ClanRole role)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		ClanRoleParameters result = default(ClanRoleParameters);
		((ClanRoleParameters)(ref result)).Name = role.Name;
		((ClanRoleParameters)(ref result)).CanInvite = role.CanInvite;
		((ClanRoleParameters)(ref result)).CanKick = role.CanKick;
		((ClanRoleParameters)(ref result)).CanPromote = role.CanPromote;
		((ClanRoleParameters)(ref result)).CanDemote = role.CanDemote;
		((ClanRoleParameters)(ref result)).CanAccessLogs = role.CanAccessLogs;
		((ClanRoleParameters)(ref result)).CanAccessScoreEvents = role.CanAccessScoreEvents;
		((ClanRoleParameters)(ref result)).Variables = new List<VariableUpdate>(3)
		{
			FlagVariable("can_set_logo", role.CanSetLogo),
			FlagVariable("can_set_motd", role.CanSetMotd),
			FlagVariable("can_set_player_notes", role.CanSetPlayerNotes)
		};
		return result;
	}

	public static VariableUpdate FlagVariable(string key, bool value)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return new VariableUpdate(key, value ? bool.TrueString : bool.FalseString, (bool?)null, (bool?)null);
	}

	private static bool ParseFlag(Variable variable, bool defaultValue = false)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		if (variable == null || (int)variable.Type != 1 || !bool.TryParse(variable.GetAsString(), out var result))
		{
			return false;
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Facepunch.Extend;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using UnityEngine;

public class NexusClanWrapper : IClan
{
	private const int MaxChatScrollback = 20;

	public readonly NexusClan Internal;

	private readonly NexusClanChatCollector _chatCollector;

	private readonly List<ClanRole> _roles;

	private readonly List<ClanMember> _members;

	private readonly List<ClanInvite> _invites;

	private readonly List<ClanChatEntry> _chatHistory;

	private RealTimeSince _sinceLastRefresh;

	public long ClanId => Internal.ClanId;

	public string Name => Internal.Name;

	public long Created => Internal.Created;

	public ulong Creator => NexusClanUtil.GetSteamId(Internal.Creator);

	public string Motd { get; private set; }

	public long MotdTimestamp { get; private set; }

	public ulong MotdAuthor { get; private set; }

	public byte[] Logo { get; private set; }

	public Color32 Color { get; private set; }

	public long Score => Internal.Score;

	public IReadOnlyList<ClanRole> Roles => _roles;

	public IReadOnlyList<ClanMember> Members => _members;

	public int MaxMemberCount { get; private set; }

	public IReadOnlyList<ClanInvite> Invites => _invites;

	public NexusClanWrapper(NexusClan clan, NexusClanChatCollector chatCollector)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Internal = clan ?? throw new ArgumentNullException("clan");
		_chatCollector = chatCollector ?? throw new ArgumentNullException("chatCollector");
		_roles = new List<ClanRole>();
		_members = new List<ClanMember>();
		_invites = new List<ClanInvite>();
		_chatHistory = new List<ClanChatEntry>(20);
		_sinceLastRefresh = RealTimeSince.op_Implicit(0f);
		UpdateValuesInternal();
	}

	public void UpdateValuesInternal()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		Internal.GetMotd(out var motd, out var motdTimestamp, out var motdAuthor);
		Motd = motd;
		MotdTimestamp = motdTimestamp;
		MotdAuthor = motdAuthor;
		Internal.GetBanner(out var logo, out var color);
		Logo = logo;
		Color = color;
		List.Resize<ClanRole>(_roles, Internal.Roles.Count);
		for (int i = 0; i < _roles.Count; i++)
		{
			_roles[i] = Internal.Roles[i].ToClanRole();
		}
		List.Resize<ClanMember>(_members, Internal.Members.Count);
		for (int j = 0; j < _members.Count; j++)
		{
			_members[j] = Internal.Members[j].ToClanMember();
		}
		MaxMemberCount = Internal.MaxMemberCount;
		List.Resize<ClanInvite>(_invites, Internal.Invites.Count);
		for (int k = 0; k < _invites.Count; k++)
		{
			_invites[k] = Internal.Invites[k].ToClanInvite();
		}
	}

	public async ValueTask RefreshIfStale()
	{
		if (RealTimeSince.op_Implicit(_sinceLastRefresh) > 30f)
		{
			_sinceLastRefresh = RealTimeSince.op_Implicit(0f);
			try
			{
				await Internal.Refresh();
				UpdateValuesInternal();
			}
			catch (Exception ex)
			{
				Debug.LogError((object)$"Failed to refresh nexus clan ID {ClanId}");
				Debug.LogException(ex);
			}
		}
	}

	public async ValueTask<ClanValueResult<ClanLogs>> GetLogs(int limit, ulong bySteamId)
	{
		NexusClanResult<List<ClanLogEntry>> val = await Internal.GetLogs(NexusClanUtil.GetPlayerId(bySteamId), limit);
		List<ClanLogEntry> source = default(List<ClanLogEntry>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			ClanLogs val2 = default(ClanLogs);
			val2.ClanId = ClanId;
			val2.Entries = source.Select(delegate(ClanLogEntry e)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				ClanLogEntry result = default(ClanLogEntry);
				result.Timestamp = ((ClanLogEntry)(ref e)).Timestamp * 1000;
				result.EventKey = ((ClanLogEntry)(ref e)).EventKey;
				result.Arg1 = ((ClanLogEntry)(ref e)).Arg1;
				result.Arg2 = ((ClanLogEntry)(ref e)).Arg2;
				result.Arg3 = ((ClanLogEntry)(ref e)).Arg3;
				result.Arg4 = ((ClanLogEntry)(ref e)).Arg4;
				return result;
			}).ToList();
			return ClanValueResult<ClanLogs>.op_Implicit(val2);
		}
		return ClanValueResult<ClanLogs>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanResult> UpdateLastSeen(ulong steamId)
	{
		return (await Internal.UpdateLastSeen(NexusClanUtil.GetPlayerId(steamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SetMotd(string newMotd, ulong bySteamId)
	{
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetMotd))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(2)
		{
			new VariableUpdate("motd", newMotd, (bool?)null, (bool?)null),
			new VariableUpdate("motd_author", playerId, (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_motd";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId;
		((ClanVariablesUpdate)(ref val)).Arg2 = newMotd;
		return (await @internal.UpdateVariables(val)).ToClanResult();
	}

	public async ValueTask<ClanResult> SetLogo(byte[] newLogo, ulong bySteamId)
	{
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetLogo))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(1)
		{
			new VariableUpdate("logo", (Memory<byte>)newLogo, (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_logo";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId;
		return (await @internal.UpdateVariables(val)).ToClanResult();
	}

	public async ValueTask<ClanResult> SetColor(Color32 newColor, ulong bySteamId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetLogo))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(1)
		{
			new VariableUpdate("color", ColorEx.ToInt32(newColor).ToString("G"), (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_color";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId;
		((ClanVariablesUpdate)(ref val)).Arg2 = ColorEx.ToHex(newColor);
		return (await @internal.UpdateVariables(val)).ToClanResult();
	}

	public async ValueTask<ClanResult> Invite(ulong steamId, ulong bySteamId)
	{
		return (await Internal.Invite(NexusClanUtil.GetPlayerId(steamId), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> CancelInvite(ulong steamId, ulong bySteamId)
	{
		return (await Internal.CancelInvite(NexusClanUtil.GetPlayerId(steamId), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> AcceptInvite(ulong steamId)
	{
		return (await Internal.AcceptInvite(NexusClanUtil.GetPlayerId(steamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> Kick(ulong steamId, ulong bySteamId)
	{
		return (await Internal.Kick(NexusClanUtil.GetPlayerId(steamId), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SetPlayerRole(ulong steamId, int newRoleId, ulong bySteamId)
	{
		return (await Internal.SetPlayerRole(NexusClanUtil.GetPlayerId(steamId), newRoleId, NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SetPlayerNotes(ulong steamId, string notes, ulong bySteamId)
	{
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetPlayerNotes))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(steamId);
		string playerId2 = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(1)
		{
			new VariableUpdate("notes", notes, (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_notes";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId2;
		((ClanVariablesUpdate)(ref val)).Arg2 = playerId;
		((ClanVariablesUpdate)(ref val)).Arg3 = notes;
		return (await @internal.UpdatePlayerVariables(playerId, val)).ToClanResult();
	}

	public async ValueTask<ClanResult> CreateRole(ClanRole role, ulong bySteamId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return (await Internal.CreateRole(role.ToRoleParameters(), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> UpdateRole(ClanRole role, ulong bySteamId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return (await Internal.UpdateRole(role.RoleId, role.ToRoleParameters(), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SwapRoleRanks(int roleIdA, int roleIdB, ulong bySteamId)
	{
		return (await Internal.SwapRoleRanks(roleIdA, roleIdB, NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> DeleteRole(int roleId, ulong bySteamId)
	{
		return (await Internal.DeleteRole(roleId, NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> Disband(ulong bySteamId)
	{
		return (await Internal.Disband(NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanValueResult<ClanScoreEvents>> GetScoreEvents(int limit, ulong bySteamId)
	{
		NexusClanResult<List<ClanScoreEventEntry>> val = await Internal.GetScoreEvents(NexusClanUtil.GetPlayerId(bySteamId), limit);
		List<ClanScoreEventEntry> source = default(List<ClanScoreEventEntry>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			ClanScoreEvents val2 = default(ClanScoreEvents);
			val2.ClanId = ClanId;
			val2.ScoreEvents = source.Select(delegate(ClanScoreEventEntry e)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_0097: Unknown result type (might be due to invalid IL or missing references)
				ClanScoreEvent result = default(ClanScoreEvent);
				result.Timestamp = ((ClanScoreEventEntry)(ref e)).Timestamp * 1000;
				result.Type = (ClanScoreEventType)((ClanScoreEventEntry)(ref e)).Type;
				result.Score = ((ClanScoreEventEntry)(ref e)).Score;
				result.Multiplier = ((ClanScoreEventEntry)(ref e)).Multiplier;
				result.SteamId = NexusClanUtil.TryGetSteamId(((ClanScoreEventEntry)(ref e)).PlayerId);
				result.OtherSteamId = NexusClanUtil.TryGetSteamId(((ClanScoreEventEntry)(ref e)).OtherPlayerId);
				result.OtherClanId = ((ClanScoreEventEntry)(ref e)).OtherClanId;
				result.Arg1 = ((ClanScoreEventEntry)(ref e)).Arg1;
				result.Arg2 = ((ClanScoreEventEntry)(ref e)).Arg2;
				return result;
			}).ToList();
			return ClanValueResult<ClanScoreEvents>.op_Implicit(val2);
		}
		return ClanValueResult<ClanScoreEvents>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public ValueTask<ClanResult> AddScoreEvent(ClanScoreEvent scoreEvent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected I4, but got Unknown
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		NexusClan @internal = Internal;
		NewClanScoreEventEntry val = default(NewClanScoreEventEntry);
		((NewClanScoreEventEntry)(ref val)).Type = (int)scoreEvent.Type;
		((NewClanScoreEventEntry)(ref val)).Score = scoreEvent.Score;
		((NewClanScoreEventEntry)(ref val)).Multiplier = scoreEvent.Multiplier;
		((NewClanScoreEventEntry)(ref val)).PlayerId = NexusClanUtil.GetPlayerId(scoreEvent.SteamId);
		((NewClanScoreEventEntry)(ref val)).OtherPlayerId = NexusClanUtil.GetPlayerId(scoreEvent.OtherSteamId);
		((NewClanScoreEventEntry)(ref val)).OtherClanId = scoreEvent.OtherClanId;
		((NewClanScoreEventEntry)(ref val)).Arg1 = scoreEvent.Arg1;
		((NewClanScoreEventEntry)(ref val)).Arg2 = scoreEvent.Arg2;
		@internal.AddScoreEvent(val);
		return new ValueTask<ClanResult>((ClanResult)1);
	}

	public ValueTask<ClanValueResult<ClanChatScrollback>> GetChatScrollback()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatHistory)
		{
			ClanChatScrollback val = default(ClanChatScrollback);
			val.ClanId = ClanId;
			val.Entries = _chatHistory.ToList();
			return new ValueTask<ClanValueResult<ClanChatScrollback>>(ClanValueResult<ClanChatScrollback>.op_Implicit(val));
		}
	}

	public ValueTask<ClanResult> SendChatMessage(string name, string message, ulong bySteamId)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (!List.TryFindWith<ClanMember, ulong>((IReadOnlyCollection<ClanMember>)_members, (Func<ClanMember, ulong>)((ClanMember m) => m.SteamId), bySteamId, (IEqualityComparer<ulong>)null).HasValue)
		{
			return new ValueTask<ClanResult>((ClanResult)0);
		}
		string message2 = default(string);
		if (!ClanValidator.ValidateChatMessage(message, ref message2))
		{
			return new ValueTask<ClanResult>((ClanResult)6);
		}
		ClanChatEntry val = default(ClanChatEntry);
		val.SteamId = bySteamId;
		val.Name = name;
		val.Message = message2;
		val.Time = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
		ClanChatEntry entry = val;
		AddScrollback(in entry);
		_chatCollector.OnClanChatMessage(ClanId, entry);
		return new ValueTask<ClanResult>((ClanResult)1);
	}

	public void AddScrollback(in ClanChatEntry entry)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatHistory)
		{
			if (_chatHistory.Count >= 20)
			{
				_chatHistory.RemoveAt(0);
			}
			_chatHistory.Add(entry);
		}
	}

	private bool CheckRole(ulong steamId, Func<ClanRole, bool> roleTest)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		ClanMember? val = List.TryFindWith<ClanMember, ulong>((IReadOnlyCollection<ClanMember>)_members, (Func<ClanMember, ulong>)((ClanMember m) => m.SteamId), steamId, (IEqualityComparer<ulong>)null);
		if (!val.HasValue)
		{
			return false;
		}
		ClanRole? val2 = List.TryFindWith<ClanRole, int>((IReadOnlyCollection<ClanRole>)_roles, (Func<ClanRole, int>)((ClanRole r) => r.RoleId), val.Value.RoleId, (IEqualityComparer<int>)null);
		if (!val2.HasValue)
		{
			return false;
		}
		if (val2.Value.Rank != 1)
		{
			return roleTest(val2.Value);
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using UnityEngine;

public class BasicZoneController : ZoneController
{
	public BasicZoneController(NexusZoneClient zoneClient)
		: base(zoneClient)
	{
	}

	public override string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone)
	{
		if (ZoneClient.Zone.IsStarterZone())
		{
			return ZoneClient.Zone.Key;
		}
		string key = ZoneClient.Zone.Key;
		List<NexusZoneDetails> list = Pool.Get<List<NexusZoneDetails>>();
		GetStarterZones(list);
		if (list.Count > 0)
		{
			int index = Random.Range(0, list.Count);
			key = list[index].Key;
		}
		Pool.FreeUnmanaged<NexusZoneDetails>(ref list);
		return key;
	}

	private void GetStarterZones(List<NexusZoneDetails> zones)
	{
		NexusZoneClient zoneClient = ZoneClient;
		object obj;
		if (zoneClient == null)
		{
			obj = null;
		}
		else
		{
			NexusDetails nexus = zoneClient.Nexus;
			obj = ((nexus != null) ? nexus.Zones : null);
		}
		if (obj == null)
		{
			return;
		}
		foreach (NexusZoneDetails zone in ZoneClient.Nexus.Zones)
		{
			if (zone.IsStarterZone())
			{
				zones.Add(zone);
			}
		}
	}
}


using UnityEngine;

public class NexusCleanupOnShutdown : MonoBehaviour
{
	public void OnDestroy()
	{
		NexusServer.Shutdown();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Sqlite;

public class NexusDB : Database
{
	public int JournalCount { get; private set; }

	public DateTimeOffset? OldestJournal { get; private set; }

	public int TransferredCount { get; private set; }

	public void Initialize()
	{
		if (!((Database)this).TableExists("seen"))
		{
			((Database)this).Execute("CREATE TABLE seen (id BLOB PRIMARY KEY)");
		}
		if (!((Database)this).TableExists("journal"))
		{
			((Database)this).Execute("CREATE TABLE journal (id BLOB PRIMARY KEY, time INTEGER, data BLOB)");
		}
		else
		{
			JournalCount = ((Database)this).Query<int>("SELECT COUNT(*) FROM journal");
			if (JournalCount > 0)
			{
				long seconds = ((Database)this).Query<long>("SELECT MIN(time) FROM journal");
				OldestJournal = DateTimeOffset.FromUnixTimeSeconds(seconds);
			}
			else
			{
				OldestJournal = null;
			}
		}
		if (!((Database)this).TableExists("transferred"))
		{
			((Database)this).Execute("CREATE TABLE transferred (id INTEGER PRIMARY KEY)");
		}
		else
		{
			TransferredCount = ((Database)this).Query<int>("SELECT COUNT(*) FROM transferred");
		}
	}

	public bool Seen(Guid id)
	{
		((Database)this).Execute<Guid>("INSERT INTO seen(id) VALUES(?) ON CONFLICT DO NOTHING", id);
		return ((Database)this).AffectedRows > 0;
	}

	public bool SeenJournaled(Guid id, byte[] data)
	{
		long num = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
		((Database)this).BeginTransaction();
		try
		{
			((Database)this).Execute<Guid>("INSERT INTO seen(id) VALUES(?) ON CONFLICT DO NOTHING", id);
			if (((Database)this).AffectedRows <= 0)
			{
				((Database)this).Commit();
				return false;
			}
			((Database)this).Execute<Guid, long, byte[]>("INSERT INTO journal(id, time, data) VALUES(?, ?, ?)", id, num, data);
			JournalCount++;
			if (!OldestJournal.HasValue)
			{
				OldestJournal = DateTimeOffset.UtcNow;
			}
			((Database)this).Commit();
			return true;
		}
		catch
		{
			((Database)this).Rollback();
			throw;
		}
	}

	public List<(Guid Id, long Time, byte[] Data)> ReadJournal()
	{
		IntPtr intPtr = ((Database)this).Prepare("SELECT id, time, data FROM journal ORDER BY time ASC");
		return ((Database)this).ExecuteAndReadQueryResults<(Guid, long, byte[])>(intPtr, (Func<IntPtr, (Guid, long, byte[])>)ReadJournalRow).ToList();
	}

	private static (Guid, long, byte[]) ReadJournalRow(IntPtr stmHandle)
	{
		Guid columnValue = Database.GetColumnValue<Guid>(stmHandle, 0);
		long columnValue2 = Database.GetColumnValue<long>(stmHandle, 1);
		byte[] columnValue3 = Database.GetColumnValue<byte[]>(stmHandle, 2);
		return (columnValue, columnValue2, columnValue3);
	}

	public void ClearJournal()
	{
		((Database)this).Execute("DELETE FROM journal");
		JournalCount = 0;
		OldestJournal = null;
	}

	public void MarkTransferred(HashSet<NetworkableId> entityIds)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (entityIds == null || entityIds.Count == 0)
		{
			return;
		}
		IntPtr intPtr = ((Database)this).Prepare("INSERT INTO transferred(id) VALUES(?) ON CONFLICT DO NOTHING");
		try
		{
			((Database)this).BeginTransaction();
			try
			{
				foreach (NetworkableId entityId in entityIds)
				{
					Database.Bind<ulong>(intPtr, 1, entityId.Value);
					((Database)this).ExecuteQuery(intPtr);
				}
				((Database)this).Commit();
				TransferredCount += entityIds.Count;
			}
			catch
			{
				((Database)this).Rollback();
				throw;
			}
		}
		finally
		{
			((Database)this).Complete(intPtr);
		}
	}

	public List<NetworkableId> ReadTransferred()
	{
		IntPtr intPtr = ((Database)this).Prepare("SELECT id FROM transferred");
		return ((Database)this).ExecuteAndReadQueryResults<NetworkableId>(intPtr, (Func<IntPtr, NetworkableId>)((IntPtr h) => new NetworkableId((ulong)Database.GetColumnValue<uint>(h, 0)))).ToList();
	}

	public void ClearTransferred()
	{
		((Database)this).Execute("DELETE FROM transferred");
		TransferredCount = 0;
	}
}


using Facepunch.Nexus.Models;
using UnityEngine;

public static class NexusExtensions
{
	public static Vector2 Position(this ZoneDetails zone)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)zone.PositionX, (float)zone.PositionY);
	}

	public static Vector2 Position(this NexusZoneDetails zone)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)zone.PositionX, (float)zone.PositionY);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;

public class NexusRpcResult : IDisposable, IPooled
{
	public readonly Dictionary<string, Response> Responses;

	public NexusRpcResult()
	{
		Responses = new Dictionary<string, Response>(StringComparer.InvariantCultureIgnoreCase);
	}

	public void Dispose()
	{
		NexusRpcResult nexusRpcResult = this;
		Pool.Free<NexusRpcResult>(ref nexusRpcResult);
	}

	public void EnterPool()
	{
		foreach (KeyValuePair<string, Response> response in Responses)
		{
			response.Value.Dispose();
		}
		Responses.Clear();
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Nexus;
using Facepunch.Nexus.Logging;
using Facepunch.Nexus.Models;
using Facepunch.Sqlite;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class NexusServer
{
	private struct ZonePlayerManifest
	{
		public RealTimeSince Received;

		public List<ulong> UserIds;
	}

	private struct PendingCall
	{
		public bool IsBroadcast;

		public RealTimeUntil TimeUntilTimeout;

		public TaskCompletionSource<bool> Completion;

		public NexusRpcResult Result;
	}

	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static NexusErrorHandler <>9__26_0;

		public static Func<NexusZoneDetails, string> <>9__29_0;

		public static Comparison<(string Zone, FerryStatus Status)> <>9__45_1;

		public static Func<NexusZoneDetails, string> <>9__50_0;

		public static Func<NexusZoneDetails, int> <>9__63_0;

		public static Func<NexusZoneDetails, string> <>9__85_0;

		public static Func<NexusZoneDetails, string> <>9__96_1;

		public static Func<NexusZoneDetails, string> <>9__103_0;

		internal void <Initialize>b__26_0(BaseNexusClient _, Exception ex)
		{
			Debug.LogException(ex);
		}

		internal string <FindZone>b__29_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal int <UpdateFerryStatuses>b__45_1((string Zone, FerryStatus Status) a, (string Zone, FerryStatus Status) b)
		{
			return a.Status.timestamp.CompareTo(b.Status.timestamp);
		}

		internal string <TryGetIslandPosition>b__50_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal int <HandleMessage>b__63_0(NexusZoneDetails z)
		{
			return z.Id;
		}

		internal string <ZoneRpc>b__85_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal string <RefreshZoneStatus>b__96_1(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal string <TransferEntityImpl>b__103_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal string <.cctor>b__113_0(ulong i)
		{
			return i.ToString("G");
		}
	}

	private static bool _isRefreshingCompanion;

	private static RealTimeSince _lastCompanionRefresh;

	private static readonly Memoized<string, ulong> SteamIdToString = new Memoized<string, ulong>((Func<ulong, string>)((ulong i) => i.ToString("G")));

	private static readonly MemoryStream WriterStream = new MemoryStream();

	private static NexusDB _database;

	private static readonly Dictionary<string, List<(string Zone, FerryStatus Status)>> FerryEntries = new Dictionary<string, List<(string, FerryStatus)>>(StringComparer.InvariantCultureIgnoreCase);

	private static bool _updatingFerries;

	private static int _cyclesWithoutFerry;

	private static float _zoneContactRadius;

	private static Dictionary<string, NexusIsland> _existingIslands;

	private const int MapRenderVersion = 5;

	private static readonly HashSet<ulong> PlayerManifest = new HashSet<ulong>();

	private static readonly Dictionary<string, ZonePlayerManifest> ZonePlayerManifests = new Dictionary<string, ZonePlayerManifest>(StringComparer.InvariantCultureIgnoreCase);

	private static RealTimeSince _lastPlayerManifestBroadcast;

	private static bool _playerManifestDirty;

	private static RealTimeSince _lastPlayerManifestRebuild;

	private static readonly Dictionary<Uuid, PendingCall> PendingCalls = new Dictionary<Uuid, PendingCall>();

	private static RealTimeSince _sinceLastRpcTimeoutCheck = RealTimeSince.op_Implicit(0f);

	private static readonly Dictionary<string, ServerStatus> ZoneStatuses = new Dictionary<string, ServerStatus>(StringComparer.InvariantCultureIgnoreCase);

	private static bool _isRefreshingZoneStatus;

	private static RealTimeSince _lastZoneStatusRefresh;

	private static DateTimeOffset? _lastUnsavedTransfer;

	private const string CopyFromKey = "$copyFrom";

	public static NexusZoneClient ZoneClient { get; private set; }

	public static bool Started { get; private set; }

	public static bool FailedToStart { get; private set; }

	public static int? NexusId
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			ZoneDetails zone = zoneClient.Zone;
			if (zone == null)
			{
				return null;
			}
			return zone.NexusId;
		}
	}

	public static string ZoneKey
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			ZoneDetails zone = zoneClient.Zone;
			if (zone == null)
			{
				return null;
			}
			return zone.Key;
		}
	}

	public static long? LastReset
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			NexusDetails nexus = zoneClient.Nexus;
			if (nexus == null)
			{
				return null;
			}
			return nexus.LastReset;
		}
	}

	public static List<NexusZoneDetails> Zones
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			NexusDetails nexus = zoneClient.Nexus;
			if (nexus == null)
			{
				return null;
			}
			return nexus.Zones;
		}
	}

	public static bool NeedsJournalFlush
	{
		get
		{
			if (Started && _database.OldestJournal.HasValue)
			{
				return (DateTimeOffset.UtcNow - _database.OldestJournal.Value).TotalSeconds >= (double)Nexus.transferFlushTime;
			}
			return false;
		}
	}

	private static int RpcResponseTtl => Nexus.messageLockDuration * 4;

	public static bool NeedTransferFlush
	{
		get
		{
			if (Started && _lastUnsavedTransfer.HasValue)
			{
				return (DateTimeOffset.UtcNow - _lastUnsavedTransfer.Value).TotalSeconds >= (double)Nexus.transferFlushTime;
			}
			return false;
		}
	}

	private static void RefreshCompanionVariables()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (!_isRefreshingCompanion && !(RealTimeSince.op_Implicit(_lastCompanionRefresh) < 60f))
		{
			RefreshCompanionVariablesImpl();
		}
		static async void RefreshCompanionVariablesImpl()
		{
			_ = 3;
			try
			{
				_isRefreshingCompanion = true;
				_lastCompanionRefresh = RealTimeSince.op_Implicit(0f);
				await ZoneClient.SetZoneVariable("protocol", Net.sv.ProtocolId, false, false);
				if (CompanionServer.Server.IsEnabled)
				{
					string text = await App.GetPublicIPAsync();
					string appPort = App.port.ToString("G", CultureInfo.InvariantCulture);
					await ZoneClient.SetZoneVariable("appIp", text ?? "", false, false);
					await ZoneClient.SetZoneVariable("appPort", appPort, false, false);
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)"Failed to set up Rust companion nexus zone variables");
				Debug.LogException(ex);
			}
			finally
			{
				_isRefreshingCompanion = false;
			}
		}
	}

	public static IEnumerator Initialize()
	{
		if (Started)
		{
			Debug.LogError((object)"NexusServer was already started");
			yield break;
		}
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient != null)
		{
			((BaseNexusClient)zoneClient).Dispose();
		}
		ZoneClient = null;
		NexusDB database = _database;
		if (database != null)
		{
			((Database)database).Close();
		}
		_database = null;
		ZoneController.Instance = null;
		Started = false;
		FailedToStart = true;
		if (string.IsNullOrWhiteSpace(Nexus.endpoint) || !Nexus.endpoint.StartsWith("http") || string.IsNullOrWhiteSpace(Nexus.secretKey))
		{
			Debug.Log((object)"Nexus endpoint and/or secret key is not set, not starting nexus connection");
			FailedToStart = false;
			yield break;
		}
		GameObject val = new GameObject("NexusCleanupOnShutdown");
		val.AddComponent<NexusCleanupOnShutdown>();
		Object.DontDestroyOnLoad((Object)val);
		try
		{
			_database = new NexusDB();
			((Database)_database).Open($"{ConVar.Server.rootFolder}/nexus.{270}.db", true);
			_database.Initialize();
		}
		catch (Exception ex2)
		{
			Debug.LogException(ex2);
			yield break;
		}
		ZoneClient = new NexusZoneClient((INexusLogger)(object)NexusServerLogger.Instance, Nexus.endpoint, Nexus.secretKey, Nexus.messageLockDuration);
		NexusZoneClient zoneClient2 = ZoneClient;
		object obj = <>c.<>9__26_0;
		if (obj == null)
		{
			NexusErrorHandler val2 = delegate(BaseNexusClient _, Exception ex)
			{
				Debug.LogException(ex);
			};
			<>c.<>9__26_0 = val2;
			obj = (object)val2;
		}
		((BaseNexusClient)zoneClient2).OnError += (NexusErrorHandler)obj;
		Task startTask = ((BaseNexusClient)ZoneClient).Start();
		yield return (object)new WaitUntil((Func<bool>)(() => startTask.IsCompleted));
		if (startTask.Exception != null)
		{
			Debug.LogException((Exception)startTask.Exception);
			yield break;
		}
		if (string.IsNullOrWhiteSpace(ZoneKey))
		{
			Debug.LogError((object)"Zone name is not available after nexus initialization");
			yield break;
		}
		Debug.Log((object)$"Connected as zone '{ZoneKey}' in Nexus {ZoneClient.Zone.NexusName} (id={ZoneClient.Zone.NexusId})");
		ZoneController.Instance = BuildZoneController(Nexus.zoneController);
		if (ZoneController.Instance == null)
		{
			Debug.LogError((object)(string.IsNullOrWhiteSpace(Nexus.zoneController) ? "Zone controller was not specified (nexus.zoneController convar)" : ("Zone controller is not supported: " + Nexus.zoneController)));
			yield break;
		}
		Variable cfgVariable2 = default(Variable);
		if (ZoneClient.TryGetNexusVariable("server.cfg", ref cfgVariable2))
		{
			Debug.Log((object)"Running server.cfg from nexus variable");
			RunConsoleConfig(cfgVariable2);
		}
		Variable cfgVariable3 = default(Variable);
		if (ZoneClient.TryGetZoneVariable("server.cfg", ref cfgVariable3))
		{
			Debug.Log((object)"Running server.cfg from zone variable");
			RunConsoleConfig(cfgVariable3);
		}
		if (string.IsNullOrWhiteSpace(ConVar.World.configString) && string.IsNullOrWhiteSpace(ConVar.World.configFile))
		{
			Debug.Log((object)"Attempting to pull world config from the nexus");
			string worldConfigString;
			try
			{
				worldConfigString = GetWorldConfigString();
			}
			catch (Exception ex3)
			{
				Debug.LogException(ex3);
				yield break;
			}
			Debug.Log((object)("Will use world config from nexus: " + worldConfigString));
			ConVar.World.configString = worldConfigString;
		}
		else
		{
			Debug.LogWarning((object)"World config convar(s) are already set, will not pull world config from nexus");
		}
		Started = true;
		FailedToStart = false;
		static void RunConsoleConfig(Variable cfgVariable)
		{
			//IL_0004: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Invalid comparison between Unknown and I4
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (cfgVariable != null && (int)cfgVariable.Type == 1)
			{
				string asString = cfgVariable.GetAsString();
				if (!string.IsNullOrWhiteSpace(asString))
				{
					ConsoleSystem.RunFile(Option.Server, asString);
				}
			}
		}
	}

	public static void Shutdown()
	{
		Started = false;
		FailedToStart = false;
		_existingIslands?.Clear();
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient != null)
		{
			((BaseNexusClient)zoneClient).Dispose();
		}
		ZoneClient = null;
		NexusDB database = _database;
		if (database != null)
		{
			((Database)database).Close();
		}
		_database = null;
	}

	public static void Update()
	{
		if (Started)
		{
			ReadIncomingMessages();
			CheckForRpcTimeouts();
			RefreshZoneStatus();
			UpdatePlayerManifest();
			RefreshCompanionVariables();
		}
	}

	public static NexusZoneDetails FindZone(string zoneKey)
	{
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient == null)
		{
			return null;
		}
		NexusDetails nexus = zoneClient.Nexus;
		if (nexus == null)
		{
			return null;
		}
		List<NexusZoneDetails> zones = nexus.Zones;
		if (zones == null)
		{
			return null;
		}
		return List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), zoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
	}

	public static Task<NexusLoginResult> Login(ulong steamId)
	{
		return ZoneClient.PlayerLogin(SteamIdToString.Get(steamId));
	}

	public static void Logout(ulong steamId)
	{
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient != null)
		{
			zoneClient.PlayerLogout(SteamIdToString.Get(steamId));
		}
	}

	public static bool TryGetPlayer(ulong steamId, out NexusPlayer player)
	{
		if (!Started)
		{
			player = null;
			return false;
		}
		return ZoneClient.TryGetPlayer(SteamIdToString.Get(steamId), ref player);
	}

	public static Task AssignInitialZone(ulong steamId, string zoneKey)
	{
		return ZoneClient.Assign(steamId.ToString("G"), zoneKey);
	}

	private static ZoneController BuildZoneController(string name)
	{
		if (name.ToLowerInvariant() == "basic")
		{
			return new BasicZoneController(ZoneClient);
		}
		return null;
	}

	public static void PostGameSaved()
	{
		_database?.ClearJournal();
		_database?.ClearTransferred();
		_lastUnsavedTransfer = null;
	}

	public static async void UpdateFerries()
	{
		if (ZoneClient == null || _updatingFerries)
		{
			return;
		}
		try
		{
			_updatingFerries = true;
			await UpdateFerriesImpl();
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			_updatingFerries = false;
		}
	}

	private static async Task UpdateFerriesImpl()
	{
		if (ZoneClient == null)
		{
			return;
		}
		Request obj = Pool.Get<Request>();
		obj.ferryStatus = Pool.Get<FerryStatusRequest>();
		using (NexusRpcResult statusResponse = await BroadcastRpc(obj))
		{
			UpdateFerryStatuses(statusResponse);
		}
		string zone = ZoneKey;
		Variable val = default(Variable);
		List<(string, FerryStatus)> value;
		if (ZoneClient.TryGetZoneVariable("ferry", ref val) && (int)val.Type == 1 && TryParseFerrySchedule(zone, val.GetAsString(), out var schedule))
		{
			if (FerryEntries.TryGetValue(zone, out var entries) && entries.Count > 1)
			{
				for (int i = 1; i < entries.Count; i++)
				{
					(string, FerryStatus) tuple = entries[i];
					await RetireFerry(tuple.Item1, tuple.Item2.entityId, tuple.Item2.timestamp);
				}
			}
			if (entries != null && entries.Count > 0)
			{
				_cyclesWithoutFerry = 0;
				(string, FerryStatus) tuple2 = entries[0];
				if (!tuple2.Item2.schedule.SequenceEqual<string>(schedule, StringComparer.InvariantCultureIgnoreCase))
				{
					await UpdateFerrySchedule(tuple2.Item1, tuple2.Item2.entityId, tuple2.Item2.timestamp, schedule);
				}
			}
			else
			{
				if (entries != null && entries.Count != 0)
				{
					return;
				}
				_cyclesWithoutFerry++;
				if (_cyclesWithoutFerry < 5)
				{
					return;
				}
				_cyclesWithoutFerry = 0;
				BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/nexus/ferry/nexusferry.entity.prefab");
				if (!(baseEntity is NexusFerry nexusFerry))
				{
					Debug.LogError((object)"Failed to spawn nexus ferry!");
					if ((Object)(object)baseEntity != (Object)null)
					{
						Object.Destroy((Object)(object)baseEntity);
					}
				}
				else
				{
					nexusFerry.Initialize(zone, schedule);
					nexusFerry.Spawn();
				}
			}
		}
		else if (FerryEntries.TryGetValue(zone, out value) && value.Count > 0)
		{
			_cyclesWithoutFerry = 0;
			foreach (var item in value)
			{
				await RetireFerry(item.Item1, item.Item2.entityId, item.Item2.timestamp);
			}
		}
		else
		{
			_cyclesWithoutFerry = 0;
		}
	}

	public static bool TryGetFerryStatus(string ownerZone, out string currentZone, out FerryStatus status)
	{
		if (!FerryEntries.TryGetValue(ownerZone, out List<(string, FerryStatus)> value) || value.Count < 1)
		{
			currentZone = null;
			status = null;
			return false;
		}
		(currentZone, status) = value[0];
		return true;
	}

	private static Task RetireFerry(string zone, NetworkableId entityId, long timestamp)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Request val = Pool.Get<Request>();
		val.ferryRetire = Pool.Get<FerryRetireRequest>();
		val.ferryRetire.entityId = entityId;
		val.ferryRetire.timestamp = timestamp;
		return ZoneRpc(zone, val);
	}

	private static Task UpdateFerrySchedule(string zone, NetworkableId entityId, long timestamp, List<string> schedule)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Request val = Pool.Get<Request>();
		val.ferryUpdateSchedule = Pool.Get<FerryUpdateScheduleRequest>();
		val.ferryUpdateSchedule.entityId = entityId;
		val.ferryUpdateSchedule.timestamp = timestamp;
		val.ferryUpdateSchedule.schedule = List.ShallowClonePooled<string>(schedule);
		return ZoneRpc(zone, val);
	}

	private static bool TryParseFerrySchedule(string zone, string scheduleString, out List<string> entries)
	{
		if (!NexusUtil.TryParseFerrySchedule(zone, scheduleString, out var entries2))
		{
			entries = null;
			return false;
		}
		List<string> list = entries2.ToList();
		foreach (string item in list)
		{
			if (FindZone(item) == null)
			{
				Debug.LogError((object)("Ferry schedule for '" + zone + "' lists an invalid zone '" + item + "': " + scheduleString));
				entries = null;
				return false;
			}
		}
		entries = list;
		return true;
	}

	private static void UpdateFerryStatuses(NexusRpcResult statusResponse)
	{
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<string, List<(string, FerryStatus)>> ferryEntry in FerryEntries)
		{
			List<(string, FerryStatus)> value = ferryEntry.Value;
			foreach (var item in value)
			{
				item.Item2.Dispose();
			}
			Pool.FreeUnmanaged<(string, FerryStatus)>(ref value);
		}
		FerryEntries.Clear();
		foreach (KeyValuePair<string, Response> response in statusResponse.Responses)
		{
			FerryStatusResponse ferryStatus = response.Value.ferryStatus;
			if (ferryStatus?.statuses == null)
			{
				continue;
			}
			foreach (FerryStatus status in ferryStatus.statuses)
			{
				AddFerryStatus(response.Key, status);
			}
		}
		string zoneKey = ZoneKey;
		Enumerator<NexusFerry> enumerator5 = NexusFerry.All.GetEnumerator();
		try
		{
			while (enumerator5.MoveNext())
			{
				NexusFerry current3 = enumerator5.Current;
				AddFerryStatus(zoneKey, current3.GetStatus());
			}
		}
		finally
		{
			((IDisposable)enumerator5/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (List<(string, FerryStatus)> value3 in FerryEntries.Values)
		{
			if (value3.Count > 1)
			{
				value3.Sort(((string Zone, FerryStatus Status) a, (string Zone, FerryStatus Status) b) => a.Status.timestamp.CompareTo(b.Status.timestamp));
			}
		}
		static void AddFerryStatus(string currentZone, FerryStatus status)
		{
			if (!FerryEntries.TryGetValue(status.ownerZone, out List<(string, FerryStatus)> value2))
			{
				value2 = Pool.Get<List<(string, FerryStatus)>>();
				FerryEntries.Add(status.ownerZone, value2);
			}
			value2.Add((currentZone, status.Copy()));
		}
	}

	public static void UpdateIslands()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Invalid comparison between Unknown and I4
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		if (ZoneClient == null)
		{
			return;
		}
		Variable val = default(Variable);
		if (ZoneClient.TryGetNexusVariable("map.contactRadius", ref val) && (int)val.Type == 1 && float.TryParse(val.GetAsString(), out var result))
		{
			_zoneContactRadius = result;
		}
		else
		{
			_zoneContactRadius = Nexus.defaultZoneContactRadius;
		}
		if (_existingIslands == null)
		{
			_existingIslands = new Dictionary<string, NexusIsland>();
		}
		HashSet<NexusIsland> hashSet = Pool.Get<HashSet<NexusIsland>>();
		hashSet.Clear();
		if (_existingIslands.Count == 0)
		{
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (enumerator.Current is NexusIsland nexusIsland)
					{
						if (string.IsNullOrEmpty(nexusIsland.ZoneKey) || _existingIslands.ContainsKey(nexusIsland.ZoneKey))
						{
							hashSet.Add(nexusIsland);
						}
						else
						{
							_existingIslands.Add(nexusIsland.ZoneKey, nexusIsland);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Dictionary<string, NexusZoneDetails> dictionary = Pool.Get<Dictionary<string, NexusZoneDetails>>();
		dictionary.Clear();
		foreach (NexusZoneDetails zone in ZoneClient.Nexus.Zones)
		{
			if (TryGetZoneStatus(zone.Key, out var status) && status.IsOnline)
			{
				dictionary.Add(zone.Key, zone);
			}
		}
		foreach (KeyValuePair<string, NexusZoneDetails> item in dictionary)
		{
			if (item.Key == ZoneKey)
			{
				continue;
			}
			if (!IsCloseTo(item.Value))
			{
				if (_existingIslands.TryGetValue(item.Key, out var value))
				{
					hashSet.Add(value);
				}
				continue;
			}
			var (val2, val3) = CalculateIslandTransform(item.Value);
			if (_existingIslands.TryGetValue(item.Key, out var value2) && (Object)(object)value2 != (Object)null)
			{
				((Component)value2).transform.SetPositionAndRotation(val2, val3);
			}
			else
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/nexus/island/nexusisland.prefab", val2, val3);
				if (!(baseEntity is NexusIsland nexusIsland2))
				{
					baseEntity.Kill();
					Debug.LogError((object)"Failed to spawn nexus island entity!");
					continue;
				}
				nexusIsland2.ZoneKey = item.Key;
				nexusIsland2.Spawn();
				_existingIslands[item.Key] = nexusIsland2;
				value2 = nexusIsland2;
			}
			value2.SetFlag(BaseEntity.Flags.Reserved1, TryGetZoneStatus(item.Key, out var status2) && status2.IsFull);
		}
		foreach (KeyValuePair<string, NexusIsland> existingIsland in _existingIslands)
		{
			if (!dictionary.ContainsKey(existingIsland.Key))
			{
				hashSet.Add(existingIsland.Value);
			}
		}
		foreach (NexusIsland item2 in hashSet)
		{
			if (item2 != null)
			{
				if (item2.ZoneKey != null)
				{
					_existingIslands.Remove(item2.ZoneKey);
				}
				item2.Kill();
			}
		}
		hashSet.Clear();
		Pool.FreeUnmanaged<NexusIsland>(ref hashSet);
		dictionary.Clear();
		Pool.FreeUnmanaged<string, NexusZoneDetails>(ref dictionary);
	}

	public static bool TryGetIsland(string zoneKey, out NexusIsland island)
	{
		if (_existingIslands == null)
		{
			island = null;
			return false;
		}
		if (_existingIslands.TryGetValue(zoneKey, out island))
		{
			return (Object)(object)island != (Object)null;
		}
		return false;
	}

	public static bool TryGetIslandPosition(string zoneKey, out Vector3 position)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		NexusZoneDetails val = List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), zoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
		if (val == null)
		{
			position = Vector3.zero;
			return false;
		}
		(position, _) = CalculateIslandTransform(val);
		return true;
	}

	private static (Vector3, Quaternion) CalculateIslandTransform(NexusZoneDetails otherZone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		Bounds worldBounds = GetWorldBounds();
		float num = Mathf.Max(((Bounds)(ref worldBounds)).extents.x, ((Bounds)(ref worldBounds)).extents.z) * 1.5f;
		float num2 = Vector2Ex.AngleFromTo(ZoneClient.Zone.Position(), otherZone.Position());
		Vector3 val = TerrainMeta.Center + Quaternion.Euler(0f, num2, 0f) * Vector3.right * num;
		Vector3 val2 = Vector3Ex.WithY(((Bounds)(ref worldBounds)).ClosestPoint(val), TerrainMeta.Center.y);
		Vector3 val3 = TerrainMeta.Center - val2;
		Quaternion item = Quaternion.LookRotation(((Vector3)(ref val3)).normalized);
		return (Vector3Ex.WithY(val2, WaterSystem.OceanLevel), item);
	}

	public static Bounds GetWorldBounds()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (((Object)(object)SingletonComponent<ValidBounds>.Instance != (Object)null) ? ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).extents : (Vector3.one * float.MaxValue));
		val.x = Mathf.Min(val.x, (float)World.Size * 1.5f);
		val.y = 0.01f;
		val.z = Mathf.Min(val.z, (float)World.Size * 1.5f);
		val.x = Mathf.Min((float)World.Size * Nexus.islandSpawnDistance, val.x * 0.9f);
		val.z = Mathf.Min((float)World.Size * Nexus.islandSpawnDistance, val.z * 0.9f);
		return new Bounds(Vector3.zero, val * 2f);
	}

	private static bool IsCloseTo(NexusZoneDetails otherZone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.Distance(ZoneClient.Zone.Position(), otherZone.Position()) <= _zoneContactRadius;
	}

	private static void ReadIncomingMessages()
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		NexusMessage val = default(NexusMessage);
		while (ZoneClient.TryReceiveMessage(ref val))
		{
			if (!((NexusMessage)(ref val)).IsBinary)
			{
				Debug.LogWarning((object)"Received a nexus message that's not binary, ignoring");
				ZoneClient.AcknowledgeMessage(ref val);
				continue;
			}
			byte[] asBinary;
			Packet val2;
			try
			{
				asBinary = ((NexusMessage)(ref val)).AsBinary;
				val2 = ReadPacket(asBinary);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				ZoneClient.AcknowledgeMessage(ref val);
				continue;
			}
			bool num = !RequiresJournaling(val2) || _database.SeenJournaled(Uuid.op_Implicit(((NexusMessage)(ref val)).Id), asBinary);
			ZoneClient.AcknowledgeMessage(ref val);
			if (!num)
			{
				Debug.LogWarning((object)"Already saw this nexus message, ignoring");
				val2.Dispose();
			}
			else
			{
				HandleMessage(((NexusMessage)(ref val)).Id, val2);
			}
		}
	}

	public static void RestoreUnsavedState()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Started)
		{
			ReplayJournaledMessages();
			DeleteTransferredEntities();
			ConsoleSystem.Run(Option.Server, "server.save", Array.Empty<object>());
		}
	}

	private static void ReplayJournaledMessages()
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		List<(Guid, long, byte[])> list = _database.ReadJournal();
		if (list.Count == 0)
		{
			Debug.Log((object)"No messages found in the nexus message journal");
			return;
		}
		Debug.Log((object)$"Replaying {list.Count} nexus messages from the journal");
		foreach (var (guid, seconds, data) in list)
		{
			try
			{
				Debug.Log((object)$"Replaying message ID {guid}, received {DateTimeOffset.FromUnixTimeSeconds(seconds):R}");
				Packet packet = ReadPacket(data);
				HandleMessage(Uuid.op_Implicit(guid), packet);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		Debug.Log((object)$"Finished replaying {list.Count} nexus messages from the journal");
	}

	private static void DeleteTransferredEntities()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		List<NetworkableId> list = _database.ReadTransferred();
		if (list.Count == 0)
		{
			Debug.Log((object)"No entities found in the transferred list");
			return;
		}
		foreach (NetworkableId item in list)
		{
			try
			{
				BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item);
				if (!((Object)(object)baseNetworkable == (Object)null))
				{
					Debug.Log((object)$"Found {baseNetworkable}, killing it because it was transferred away");
					baseNetworkable.Kill();
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		Debug.Log((object)$"Finished making sure {list.Count} entities do not exist");
	}

	private static bool RequiresJournaling(Packet packet)
	{
		if (packet.request == null || !packet.request.isFireAndForget)
		{
			return false;
		}
		return packet.request.transfer != null;
	}

	public static async void UploadMapImage(bool force = false)
	{
		_ = 1;
		try
		{
			int valueOrDefault = (World.Config?.JsonString?.GetHashCode()).GetValueOrDefault();
			string key = $"{2594}##{270}##{World.Name}##{World.Size}##{World.Seed}##{World.Salt}##{Nexus.mapImageScale}##{valueOrDefault}##{5}";
			if (!force && (await ZoneClient.CheckUploadedMap()).Key == key)
			{
				Debug.Log((object)"Nexus already has this map's image uploaded, will not render and upload again");
				return;
			}
			Debug.Log((object)"Rendering map image to upload to nexus...");
			int oceanMargin = 0;
			int imageWidth;
			int imageHeight;
			Color background;
			byte[] array = MapImageRenderer.Render(out imageWidth, out imageHeight, out background, Nexus.mapImageScale, lossy: false, transparent: true, oceanMargin);
			Debug.Log((object)"Uploading map image to nexus...");
			await ZoneClient.UploadMap(key, array);
			Debug.Log((object)"Map image was updated in the nexus");
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void HandleMessage(Uuid id, Packet packet)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (packet.protocol != 270)
			{
				Debug.LogWarning((object)"Received a nexus message with wrong protocol, ignoring");
				return;
			}
			NexusZoneDetails val = List.FindWith<NexusZoneDetails, int>((IReadOnlyCollection<NexusZoneDetails>)ZoneClient.Nexus.Zones, (Func<NexusZoneDetails, int>)((NexusZoneDetails z) => z.Id), packet.sourceZone, (IEqualityComparer<int>)null);
			if (val == null)
			{
				Debug.LogWarning((object)$"Received a nexus message from unknown zone ID {packet.sourceZone}, ignoring");
			}
			else if (packet.request != null)
			{
				HandleRpcInvocation(val, id, packet.request);
			}
			else if (packet.response != null)
			{
				HandleRpcResponse(val, id, packet.response);
			}
			else
			{
				Debug.LogWarning((object)"Received a nexus message without the request or request sections set, ignoring");
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			if (packet != null)
			{
				packet.Dispose();
			}
		}
	}

	private static Packet ReadPacket(byte[] data)
	{
		return Packet.Deserialize(data);
	}

	private static Task SendRequestImpl(Uuid id, Request request, string toZoneKey, int? ttl = null)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Packet val = Pool.Get<Packet>();
		val.protocol = 270u;
		val.sourceZone = ZoneClient.Zone.ZoneId;
		val.request = request;
		return SendPacket(id, val, toZoneKey, ttl);
	}

	private static async void SendResponseImpl(Response response, string toZoneKey, int? ttl = null)
	{
		try
		{
			Packet val = Pool.Get<Packet>();
			val.protocol = 270u;
			val.sourceZone = ZoneClient.Zone.ZoneId;
			val.response = response;
			await SendPacket(Uuid.Generate(), val, toZoneKey, ttl);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static Task SendPacket(Uuid id, Packet packet, string toZoneKey, int? ttl = null)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		WriterStream.SetLength(0L);
		WriterStream.Position = 0L;
		ProtoStreamExtensions.WriteToStream((IProto)(object)packet, (Stream)WriterStream, false, 2097152);
		Memory<byte> memory = new Memory<byte>(WriterStream.GetBuffer(), 0, (int)WriterStream.Length);
		packet.Dispose();
		return ZoneClient.SendMessage(toZoneKey, id, memory, ttl);
	}

	public static bool IsOnline(ulong userId)
	{
		RebuildPlayerManifestIfDirty();
		if (!PlayerManifest.Contains(userId))
		{
			return ServerPlayers.IsOnline(userId);
		}
		return true;
	}

	public static void AddZonePlayerManifest(string zoneKey, List<ulong> userIds)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (ZonePlayerManifests.TryGetValue(zoneKey, out var value))
		{
			if (value.UserIds != null)
			{
				Pool.FreeUnmanaged<ulong>(ref value.UserIds);
			}
			ZonePlayerManifests.Remove(zoneKey);
		}
		ZonePlayerManifests.Add(zoneKey, new ZonePlayerManifest
		{
			Received = RealTimeSince.op_Implicit(0f),
			UserIds = List.ShallowClonePooled<ulong>(userIds)
		});
	}

	private static void UpdatePlayerManifest()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_lastPlayerManifestBroadcast) >= Nexus.playerManifestInterval)
		{
			_lastPlayerManifestBroadcast = RealTimeSince.op_Implicit(0f);
			BroadcastPlayerManifest();
		}
		if (RealTimeSince.op_Implicit(_lastPlayerManifestRebuild) > Nexus.playerManifestInterval)
		{
			_playerManifestDirty = true;
		}
		RebuildPlayerManifestIfDirty();
	}

	private static async void BroadcastPlayerManifest()
	{
		try
		{
			Request obj = Pool.Get<Request>();
			obj.isFireAndForget = true;
			obj.playerManifest = Pool.Get<PlayerManifestRequest>();
			obj.playerManifest.userIds = Pool.Get<List<ulong>>();
			ServerPlayers.GetAll(obj.playerManifest.userIds);
			await BroadcastRpc(obj);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void RebuildPlayerManifestIfDirty()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (!_playerManifestDirty)
		{
			return;
		}
		_playerManifestDirty = false;
		_lastPlayerManifestRebuild = RealTimeSince.op_Implicit(0f);
		RemoveInvalidPlayerManifests();
		PlayerManifest.Clear();
		foreach (ZonePlayerManifest value in ZonePlayerManifests.Values)
		{
			foreach (ulong userId in value.UserIds)
			{
				PlayerManifest.Add(userId);
			}
		}
	}

	private static void RemoveInvalidPlayerManifests()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		List<string> list = Pool.Get<List<string>>();
		foreach (KeyValuePair<string, ZonePlayerManifest> zonePlayerManifest in ZonePlayerManifests)
		{
			if (FindZone(zonePlayerManifest.Key) == null || RealTimeSince.op_Implicit(zonePlayerManifest.Value.Received) > Nexus.playerManifestInterval * 3f)
			{
				list.Add(zonePlayerManifest.Key);
			}
		}
		foreach (string item in list)
		{
			if (ZonePlayerManifests.TryGetValue(item, out var value))
			{
				ZonePlayerManifests.Remove(item);
				if (value.UserIds != null)
				{
					Pool.FreeUnmanaged<ulong>(ref value.UserIds);
				}
			}
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	public static async Task<Response> ZoneRpc(string zone, Request request, float timeoutAfter = 30f)
	{
		if (string.IsNullOrEmpty(zone))
		{
			throw new ArgumentNullException("zone");
		}
		if (string.Equals(zone, ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			return HandleRpcInvocationImpl(List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), ZoneKey, (IEqualityComparer<string>)null), Uuid.Empty, request);
		}
		using NexusRpcResult nexusRpcResult = await CallRpcImpl(zone, request, timeoutAfter, throwOnTimeout: true);
		Response val = nexusRpcResult.Responses[zone];
		if (!string.IsNullOrWhiteSpace(val.status?.errorMessage))
		{
			throw new Exception(val.status.errorMessage);
		}
		return val.Copy();
	}

	public static Task<NexusRpcResult> BroadcastRpc(Request request, float timeoutAfter = 30f)
	{
		return CallRpcImpl(null, request, timeoutAfter, throwOnTimeout: false);
	}

	private static async Task<NexusRpcResult> CallRpcImpl(string zone, Request request, float timeoutAfter, bool throwOnTimeout)
	{
		Uuid id = Uuid.Generate();
		TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();
		NexusRpcResult result = Pool.Get<NexusRpcResult>();
		try
		{
			float actualTimeout = timeoutAfter * Nexus.rpcTimeoutMultiplier;
			await SendRequestImpl(id, request, zone, (int)actualTimeout + RpcResponseTtl);
			PendingCalls.Add(id, new PendingCall
			{
				IsBroadcast = string.IsNullOrWhiteSpace(zone),
				TimeUntilTimeout = RealTimeUntil.op_Implicit(actualTimeout),
				Completion = tcs,
				Result = result
			});
			bool flag = await tcs.Task;
			if (throwOnTimeout && !flag)
			{
				throw new TimeoutException("Nexus RPC invocation timed out");
			}
		}
		catch
		{
			Pool.Free<NexusRpcResult>(ref result);
			throw;
		}
		return result;
	}

	private static void HandleRpcInvocation(NexusZoneDetails from, Uuid id, Request request)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		Response val = HandleRpcInvocationImpl(from, id, request);
		if (val != null)
		{
			SendResponseImpl(val, from.Key, RpcResponseTtl);
		}
	}

	private static Response HandleRpcInvocationImpl(NexusZoneDetails from, Uuid id, Request request)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (!Handle<TransferRequest, TransferHandler>(request.transfer, from, id, request, out var response) && !Handle<PingRequest, PingHandler>(request.ping, from, id, request, out response) && !Handle<SpawnOptionsRequest, SpawnOptionsHandler>(request.spawnOptions, from, id, request, out response) && !Handle<SleepingBagRespawnRequest, RespawnAtBagHandler>(request.respawnAtBag, from, id, request, out response) && !Handle<SleepingBagDestroyRequest, DestroyBagHandler>(request.destroyBag, from, id, request, out response) && !Handle<FerryStatusRequest, FerryStatusHandler>(request.ferryStatus, from, id, request, out response) && !Handle<FerryRetireRequest, FerryRetireHandler>(request.ferryRetire, from, id, request, out response) && !Handle<FerryUpdateScheduleRequest, FerryUpdateScheduleHandler>(request.ferryUpdateSchedule, from, id, request, out response) && !Handle<ClanChatBatchRequest, ClanChatBatchHandler>(request.clanChatBatch, from, id, request, out response) && !Handle<PlayerManifestRequest, PlayerManifestHandler>(request.playerManifest, from, id, request, out response))
		{
			Debug.LogError((object)"Received a nexus RPC invocation with a missing or unsupported request, ignoring");
			return null;
		}
		return response;
	}

	private static bool Handle<TProto, THandler>(TProto proto, NexusZoneDetails from, Uuid id, Request request, out Response response) where TProto : class where THandler : BaseNexusRequestHandler<TProto>, new()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (proto == null)
		{
			response = null;
			return false;
		}
		THandler val = Pool.Get<THandler>();
		val.Initialize(from, id, request.isFireAndForget, proto);
		val.Execute();
		response = val.Response;
		Pool.Free<THandler>(ref val);
		return true;
	}

	private static void HandleRpcResponse(NexusZoneDetails from, Uuid id, Response response)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (!PendingCalls.TryGetValue(response.id, out var value))
		{
			Debug.LogWarning((object)"Received an unexpected nexus RPC response (likely timed out), ignoring");
			return;
		}
		if (!value.Result.Responses.ContainsKey(from.Key))
		{
			value.Result.Responses.Add(from.Key, response.Copy());
		}
		int num;
		if (!value.IsBroadcast)
		{
			num = 1;
		}
		else
		{
			NexusZoneClient zoneClient = ZoneClient;
			int? obj;
			if (zoneClient == null)
			{
				obj = null;
			}
			else
			{
				NexusDetails nexus = zoneClient.Nexus;
				obj = ((nexus == null) ? ((int?)null) : nexus.Zones?.Count);
			}
			int? num2 = obj;
			num = num2.GetValueOrDefault() - 1;
		}
		int num3 = num;
		if (value.Result.Responses.Count >= num3)
		{
			PendingCalls.Remove(id);
			value.Completion.TrySetResult(result: true);
		}
	}

	private static void CheckForRpcTimeouts()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_sinceLastRpcTimeoutCheck) < 1f)
		{
			return;
		}
		_sinceLastRpcTimeoutCheck = RealTimeSince.op_Implicit(0f);
		List<(Uuid, PendingCall)> list = Pool.Get<List<(Uuid, PendingCall)>>();
		foreach (KeyValuePair<Uuid, PendingCall> pendingCall in PendingCalls)
		{
			Uuid key = pendingCall.Key;
			PendingCall value = pendingCall.Value;
			if (RealTimeUntil.op_Implicit(value.TimeUntilTimeout) <= 0f)
			{
				list.Add((key, value));
			}
		}
		foreach (var item3 in list)
		{
			Uuid item = item3.Item1;
			PendingCall item2 = item3.Item2;
			PendingCalls.Remove(item);
			item2.Completion.TrySetResult(result: false);
		}
		Pool.FreeUnmanaged<(Uuid, PendingCall)>(ref list);
	}

	private static void RefreshZoneStatus()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (!_isRefreshingZoneStatus && !(RealTimeSince.op_Implicit(_lastZoneStatusRefresh) < Nexus.pingInterval))
		{
			RefreshZoneStatusImpl();
		}
		static async void RefreshZoneStatusImpl()
		{
			try
			{
				_isRefreshingZoneStatus = true;
				_lastZoneStatusRefresh = RealTimeSince.op_Implicit(0f);
				Request obj = Pool.Get<Request>();
				obj.ping = Pool.Get<PingRequest>();
				using (NexusRpcResult nexusRpcResult = await BroadcastRpc(obj))
				{
					List<string> list = Pool.Get<List<string>>();
					foreach (string key in ZoneStatuses.Keys)
					{
						if (List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), key, (IEqualityComparer<string>)null) == null)
						{
							list.Add(key);
						}
					}
					foreach (string item in list)
					{
						ZoneStatuses.Remove(item);
					}
					Pool.FreeUnmanaged<string>(ref list);
					foreach (KeyValuePair<string, Response> response in nexusRpcResult.Responses)
					{
						if (string.IsNullOrWhiteSpace(response.Key))
						{
							Debug.LogWarning((object)"Received a ping response for a zone with a null key");
						}
						else if (response.Value?.ping == null)
						{
							Debug.LogWarning((object)("Received a ping response from '" + response.Key + "' but the data was null"));
						}
						else
						{
							ZoneStatuses[response.Key] = new ServerStatus
							{
								IsOnline = true,
								LastSeen = RealTimeSince.op_Implicit(0f),
								Players = response.Value.ping.players,
								MaxPlayers = response.Value.ping.maxPlayers,
								QueuedPlayers = response.Value.ping.queuedPlayers
							};
						}
					}
					foreach (NexusZoneDetails zone in Zones)
					{
						if (!nexusRpcResult.Responses.ContainsKey(zone.Key))
						{
							if (ZoneStatuses.TryGetValue(zone.Key, out var value))
							{
								ZoneStatuses[zone.Key] = new ServerStatus
								{
									IsOnline = false,
									LastSeen = value.LastSeen,
									Players = value.Players,
									MaxPlayers = value.MaxPlayers,
									QueuedPlayers = value.QueuedPlayers
								};
							}
							else
							{
								ZoneStatuses[zone.Key] = new ServerStatus
								{
									IsOnline = false
								};
							}
						}
					}
				}
				_lastZoneStatusRefresh = RealTimeSince.op_Implicit(0f);
			}
			finally
			{
				_isRefreshingZoneStatus = false;
			}
			OnZoneStatusesRefreshed();
		}
	}

	public static bool TryGetZoneStatus(string zone, out ServerStatus status)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (!Started)
		{
			status = default(ServerStatus);
			return false;
		}
		if (string.Equals(zone, ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			status = new ServerStatus
			{
				IsOnline = true,
				LastSeen = RealTimeSince.op_Implicit(0f),
				Players = BasePlayer.activePlayerList.Count,
				MaxPlayers = ConVar.Server.maxplayers,
				QueuedPlayers = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued
			};
			return true;
		}
		return ZoneStatuses.TryGetValue(zone, out status);
	}

	private static void OnZoneStatusesRefreshed()
	{
		UpdateIslands();
		UpdateFerries();
	}

	public static async Task TransferEntity(BaseEntity entity, string toZoneKey, string method, bool includeFerry = true)
	{
		try
		{
			await TransferEntityImpl(FindRootEntity(entity, includeFerry), toZoneKey, method, ZoneKey, toZoneKey);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)ex);
		}
	}

	public static async Task TransferEntityImpl(BaseEntity rootEntity, string toZoneKey, string method, string from, string to)
	{
		if ((Object)(object)rootEntity == (Object)null)
		{
			throw new ArgumentNullException("rootEntity");
		}
		if (string.IsNullOrWhiteSpace(toZoneKey))
		{
			throw new ArgumentNullException("toZoneKey");
		}
		if (string.Equals(toZoneKey, ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			throw new ArgumentException("Attempted to transfer a player to the current server's zone", "toZoneKey");
		}
		NexusZoneDetails toZone = List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)ZoneClient.Nexus.Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), toZoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
		if (toZone == null)
		{
			throw new ArgumentException("Target zone (" + toZoneKey + ") was not found in the nexus", "toZoneKey");
		}
		BuildTransferRequest(rootEntity, method, from, to, out var request, out var networkables, out var players, out var playerIds);
		HashSet<NetworkableId> transferEntityIds = Pool.Get<HashSet<NetworkableId>>();
		transferEntityIds.Clear();
		foreach (BaseNetworkable item in networkables)
		{
			if (item.net != null && ((NetworkableId)(ref item.net.ID)).IsValid)
			{
				transferEntityIds.Add(item.net.ID);
			}
		}
		foreach (BaseNetworkable item2 in networkables)
		{
			if (item2.net != null && ((NetworkableId)(ref item2.net.ID)).IsValid)
			{
				transferEntityIds.Add(item2.net.ID);
			}
			if (item2 is BaseEntity baseEntity)
			{
				baseEntity.SetFlag(BaseEntity.Flags.Transferring, b: true);
			}
		}
		try
		{
			if (playerIds.Count > 0)
			{
				await ZoneClient.RegisterTransfers(toZoneKey, (IEnumerable<string>)playerIds);
			}
			await SendRequestImpl(Uuid.Generate(), request, toZoneKey, null);
		}
		catch
		{
			foreach (BaseNetworkable item3 in networkables)
			{
				if ((Object)(object)item3 != (Object)null && item3 is BaseEntity baseEntity2)
				{
					baseEntity2.SetFlag(BaseEntity.Flags.Transferring, b: false);
				}
			}
			throw;
		}
		foreach (BasePlayer item4 in players)
		{
			if ((Object)(object)item4 != (Object)null && item4.IsConnected)
			{
				ConsoleNetwork.SendClientCommandImmediate(item4.net.connection, "nexus.redirect", toZone.IpAddress, toZone.GamePort, toZone.ConnectionProtocol());
				item4.limitNetworking = true;
				item4.EnableSaving(wants: false);
				((FacepunchBehaviour)item4).Invoke((Action)item4.KickAfterServerTransfer, 1f);
			}
		}
		for (int num = networkables.Count - 1; num >= 0; num--)
		{
			try
			{
				BaseNetworkable baseNetworkable = networkables[num];
				if ((Object)(object)baseNetworkable != (Object)null)
				{
					if (baseNetworkable is BaseEntity entity)
					{
						UnparentUnknown(entity, transferEntityIds);
					}
					if (baseNetworkable is BasePlayer basePlayer && players.Contains(basePlayer))
					{
						basePlayer.SetParent(null, worldPositionStays: true);
					}
					else
					{
						baseNetworkable.Kill();
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		_database.MarkTransferred(transferEntityIds);
		transferEntityIds.Clear();
		Pool.FreeUnmanaged<NetworkableId>(ref transferEntityIds);
		Pool.FreeUnmanaged<BaseNetworkable>(ref networkables);
		Pool.FreeUnmanaged<BasePlayer>(ref players);
		Pool.FreeUnmanaged<string>(ref playerIds);
		_lastUnsavedTransfer = DateTimeOffset.UtcNow;
	}

	private static void UnparentUnknown(BaseEntity entity, HashSet<NetworkableId> knownEntityIds)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		foreach (BaseEntity child in entity.children)
		{
			if (knownEntityIds.Contains(child.net.ID))
			{
				UnparentUnknown(child, knownEntityIds);
			}
			else
			{
				list.Add(child);
			}
		}
		foreach (BaseEntity item in list)
		{
			Debug.Log((object)$"Unparenting {entity}", (Object)(object)entity);
			item.SetParent(null, worldPositionStays: true, sendImmediate: true);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public static void BuildTransferRequest(BaseEntity rootEntity, string method, string from, string to, out Request request, out List<BaseNetworkable> networkables, out List<BasePlayer> players, out List<string> playerIds)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		List<BaseNetworkable> entitiesList = (networkables = Pool.Get<List<BaseNetworkable>>());
		List<BasePlayer> playerList = (players = Pool.Get<List<BasePlayer>>());
		List<string> playerIdsList = (playerIds = Pool.Get<List<string>>());
		request = Pool.Get<Request>();
		request.isFireAndForget = true;
		request.transfer = Pool.Get<TransferRequest>();
		request.transfer.method = method;
		request.transfer.from = from;
		request.transfer.to = to;
		List<Entity> serializedEntities = (request.transfer.entities = Pool.Get<List<Entity>>());
		List<PlayerSecondaryData> secondaryData = (request.transfer.secondaryData = Pool.Get<List<PlayerSecondaryData>>());
		Queue<BaseNetworkable> pendingEntities = Pool.Get<Queue<BaseNetworkable>>();
		pendingEntities.Clear();
		HashSet<NetworkableId> seenEntityIds = Pool.Get<HashSet<NetworkableId>>();
		seenEntityIds.Clear();
		pendingEntities.Enqueue(rootEntity);
		seenEntityIds.Add(rootEntity.net.ID);
		while (pendingEntities.Count > 0)
		{
			BaseNetworkable baseNetworkable = pendingEntities.Dequeue();
			Entity val = null;
			if (CanTransferEntity(baseNetworkable))
			{
				val = AddEntity(baseNetworkable);
			}
			foreach (BaseEntity child in baseNetworkable.children)
			{
				if ((Object)(object)child != (Object)null && seenEntityIds.Add(child.net.ID))
				{
					pendingEntities.Enqueue(child);
				}
			}
			if (baseNetworkable is BaseMountable baseMountable)
			{
				BasePlayer mounted = baseMountable.GetMounted();
				if ((Object)(object)mounted != (Object)null && seenEntityIds.Add(mounted.net.ID))
				{
					pendingEntities.Enqueue(mounted);
				}
			}
			if (val != null)
			{
				val.InspectUids((UidInspector<ulong>)ScanForAdditionalEntities);
			}
		}
		seenEntityIds.Clear();
		Pool.FreeUnmanaged<NetworkableId>(ref seenEntityIds);
		pendingEntities.Clear();
		Pool.FreeUnmanaged<BaseNetworkable>(ref pendingEntities);
		Entity AddEntity(BaseNetworkable entity)
		{
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			BaseNetworkable.SaveInfo saveInfo = default(BaseNetworkable.SaveInfo);
			saveInfo.forDisk = true;
			saveInfo.forTransfer = true;
			saveInfo.msg = Pool.Get<Entity>();
			BaseNetworkable.SaveInfo info = saveInfo;
			entity.Save(info);
			if (entity == rootEntity && info.msg.parent != null)
			{
				info.msg.parent.Dispose();
				info.msg.parent = null;
				if (info.msg.baseEntity != null)
				{
					Vector3 pos = default(Vector3);
					Quaternion val2 = default(Quaternion);
					((Component)rootEntity).transform.GetPositionAndRotation(ref pos, ref val2);
					info.msg.baseEntity.pos = pos;
					info.msg.baseEntity.rot = ((Quaternion)(ref val2)).eulerAngles;
				}
			}
			serializedEntities.Add(info.msg);
			entitiesList.Add(entity);
			if (entity is BasePlayer basePlayer && ((object)basePlayer).GetType() == typeof(BasePlayer) && (ulong)basePlayer.userID > uint.MaxValue)
			{
				playerList.Add(basePlayer);
				playerIdsList.Add(basePlayer.UserIDString);
				secondaryData.Add(basePlayer.SaveSecondaryData());
			}
			return info.msg;
		}
		void ScanForAdditionalEntities(UidType type, ref ulong uid)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			NetworkableId val3 = default(NetworkableId);
			((NetworkableId)(ref val3))..ctor(uid);
			if ((int)type == 0 && ((NetworkableId)(ref val3)).IsValid && seenEntityIds.Add(val3))
			{
				BaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(val3);
				if ((Object)(object)baseNetworkable2 != (Object)null)
				{
					pendingEntities.Enqueue(baseNetworkable2);
				}
			}
		}
	}

	private static bool CanTransferEntity(BaseNetworkable networkable)
	{
		if ((Object)(object)networkable == (Object)null)
		{
			return false;
		}
		if (networkable is BaseEntity { enableSaving: false })
		{
			return false;
		}
		if (networkable is BasePlayer basePlayer && !basePlayer.IsAlive())
		{
			return false;
		}
		return true;
	}

	public static BaseEntity FindRootEntity(BaseEntity startEntity, bool includeFerry)
	{
		BaseEntity baseEntity = startEntity;
		BaseEntity parent2;
		while (TryGetParent(baseEntity, out parent2) && (includeFerry || !(parent2 is NexusFerry)))
		{
			baseEntity = parent2;
		}
		return baseEntity;
		static bool TryGetParent(BaseEntity entity, out BaseEntity parent)
		{
			BaseEntity parentEntity = entity.GetParentEntity();
			if ((Object)(object)parentEntity != (Object)null && parentEntity.enableSaving)
			{
				parent = parentEntity;
				return true;
			}
			if (entity is BasePlayer basePlayer)
			{
				BaseMountable mounted = basePlayer.GetMounted();
				if ((Object)(object)mounted != (Object)null && mounted.enableSaving)
				{
					parent = mounted;
					return true;
				}
			}
			parent = null;
			return false;
		}
	}

	private static string GetWorldConfigString()
	{
		List<string> stack = Pool.Get<List<string>>();
		JObject worldConfigImpl = GetWorldConfigImpl(ZoneKey, stack);
		Pool.FreeUnmanaged<string>(ref stack);
		if (worldConfigImpl == null)
		{
			return null;
		}
		return ((JToken)worldConfigImpl).ToString((Formatting)0, Array.Empty<JsonConverter>());
	}

	private static JObject GetWorldConfigImpl(string zoneKey, List<string> stack)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Invalid comparison between Unknown and I4
		if (stack.Count > 20)
		{
			throw new Exception("Cannot load world config from nexus - there is a cyclic dependency between zones (" + string.Join(" -> ", stack) + ")");
		}
		bool required = stack.Count > 0;
		if (!TryGetWorldConfigObject(zoneKey, required, out var cfg, out var error))
		{
			throw new Exception(error + " (" + string.Join(" -> ", stack) + ")");
		}
		JToken val = default(JToken);
		if (!cfg.TryGetValue("$copyFrom", ref val))
		{
			return cfg;
		}
		if ((int)val.Type != 8)
		{
			throw new Exception("Cannot get world config from nexus - zone '" + zoneKey + "' has a $copyFrom, but its value is not a string");
		}
		stack.Add(zoneKey);
		JObject obj = MergeInto(GetWorldConfigImpl(val.ToObject<string>(), stack), cfg);
		obj.Remove("$copyFrom");
		return obj;
	}

	private static bool TryGetWorldConfigObject(string zoneKey, bool required, out JObject cfg, out string error)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Invalid comparison between Unknown and I4
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Expected O, but got Unknown
		cfg = null;
		NexusZoneClient zoneClient = ZoneClient;
		object obj;
		if (zoneClient == null)
		{
			obj = null;
		}
		else
		{
			NexusDetails nexus = zoneClient.Nexus;
			obj = ((nexus != null) ? nexus.Zones : null);
		}
		if (obj == null)
		{
			error = "Cannot get world config from nexus - nexus server isn't started";
			return false;
		}
		NexusZoneDetails val = FindZone(zoneKey);
		if (val == null)
		{
			error = "Cannot get world config for nexus zone '" + zoneKey + "' - zone was not found";
			return false;
		}
		if (!((Dictionary<string, VariableData>)(object)val.Variables).TryGetValue("world.cfg", out VariableData value))
		{
			if (required)
			{
				error = "Cannot get world config for nexus zone '" + zoneKey + "' - world.cfg variable not found but is required by another zone";
				return false;
			}
			cfg = new JObject();
			error = null;
			return true;
		}
		if ((int)((VariableData)(ref value)).Type != 1 || string.IsNullOrWhiteSpace(((VariableData)(ref value)).Value))
		{
			error = "Cannot get world config for nexus zone '" + zoneKey + "' - world.cfg variable is empty or not a string";
			return false;
		}
		try
		{
			cfg = JObject.Parse(((VariableData)(ref value)).Value);
			error = null;
			return true;
		}
		catch (Exception ex)
		{
			error = "Cannot get world config for nexus zone '" + zoneKey + "' - failed to parse: `" + ((VariableData)(ref value)).Value + "` (" + ex.Message + ")";
			return false;
		}
	}

	private static JObject MergeInto(JObject baseObject, JObject sourceObject)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		JObject val = new JObject(baseObject);
		foreach (KeyValuePair<string, JToken> item in sourceObject)
		{
			val[item.Key] = item.Value;
		}
		return val;
	}
}


using System.Collections.Generic;

private struct ZonePlayerManifest
{
	public RealTimeSince Received;

	public List<ulong> UserIds;
}


using System.Threading.Tasks;

private struct PendingCall
{
	public bool IsBroadcast;

	public RealTimeUntil TimeUntilTimeout;

	public TaskCompletionSource<bool> Completion;

	public NexusRpcResult Result;
}


public struct ServerStatus
{
	public bool IsOnline;

	public RealTimeSince LastSeen;

	public int Players;

	public int MaxPlayers;

	public int QueuedPlayers;

	public bool IsFull => Players + QueuedPlayers >= MaxPlayers;
}


using System;
using ConVar;
using Facepunch.Nexus.Logging;
using UnityEngine;

public class NexusServerLogger : INexusLogger
{
	public static NexusServerLogger Instance { get; } = new NexusServerLogger();

	private NexusServerLogger()
	{
	}

	public void Log(NexusLogLevel level, string message, Exception exception = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Invalid comparison between Unknown and I4
		if (!Nexus.logging)
		{
			return;
		}
		if ((int)level != 1)
		{
			if ((int)level == 2)
			{
				Debug.LogError((object)message);
			}
			else
			{
				Debug.Log((object)message);
			}
		}
		else
		{
			Debug.LogWarning((object)message);
		}
		if (exception != null)
		{
			Debug.LogException(exception);
		}
	}
}


public static class NexusVariables
{
	public static readonly string Blueprints = $"blueprints.{5}";
}


using System;
using Facepunch.Nexus;
using UnityEngine;

public abstract class ZoneController
{
	protected readonly NexusZoneClient ZoneClient;

	public static ZoneController Instance { get; set; }

	protected ZoneController(NexusZoneClient zoneClient)
	{
		ZoneClient = zoneClient ?? throw new ArgumentNullException("zoneClient");
	}

	public abstract string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone);

	public virtual (Vector3 Position, Quaternion Rotation, bool PreserveY) ChooseTransferDestination(string sourceZone, string method, string from, string to, Vector3 position, Quaternion rotation)
	{
		switch (method)
		{
		case "console":
			return ChooseConsoleTransferDestination(sourceZone);
		case "ferry":
			return ChooseFerryTransferDestination(sourceZone);
		case "ocean":
			return ChooseOceanTransferDestination(sourceZone);
		default:
			Debug.LogError((object)("Unhandled transfer method '" + method + "', using default destination"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
	}

	protected virtual (Vector3, Quaternion, bool) ChooseConsoleTransferDestination(string sourceZone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer.SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(null, 0uL);
		return (spawnPoint.pos, spawnPoint.rot, false);
	}

	protected virtual (Vector3, Quaternion, bool) ChooseFerryTransferDestination(string sourceZone)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!NexusServer.TryGetIsland(sourceZone, out var island))
		{
			return ChooseTransferFallbackDestination(sourceZone);
		}
		if (!island.TryFindPosition(out var position))
		{
			Debug.LogWarning((object)("Couldn't find a destination position for source zone '" + sourceZone + "'"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
		return (position, ((Component)island).transform.rotation, true);
	}

	protected virtual (Vector3, Quaternion, bool) ChooseOceanTransferDestination(string sourceZone)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!NexusServer.TryGetIsland(sourceZone, out var island))
		{
			Debug.LogWarning((object)("Couldn't find nexus island for source zone '" + sourceZone + "'"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
		if (!island.TryFindPosition(out var position))
		{
			Debug.LogWarning((object)("Couldn't find a destination position for source zone '" + sourceZone + "'"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
		return (position, ((Component)island).transform.rotation, true);
	}

	protected virtual (Vector3, Quaternion, bool) ChooseTransferFallbackDestination(string sourceZone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		Bounds worldBounds = NexusServer.GetWorldBounds();
		float num = Mathf.Max(((Bounds)(ref worldBounds)).extents.x, ((Bounds)(ref worldBounds)).extents.z);
		Vector3 position;
		Vector3 val = (NexusServer.TryGetIslandPosition(sourceZone, out position) ? (position + new Vector3((float)Random.Range(-1, 1), 0f, (float)Random.Range(-1, 1)) * 100f) : (Vector3Ex.XZ3D(Random.insideUnitCircle) * num * 0.75f));
		Vector3 val2 = Vector3Ex.WithY(val, WaterLevel.GetWaterSurface(val, waves: false, volumes: false));
		Vector3 val3 = Vector3Ex.WithY(TerrainMeta.Center, val2.y) - val2;
		Quaternion item = Quaternion.LookRotation(((Vector3)(ref val3)).normalized, Vector3.up);
		return (val2, item, true);
	}

	public virtual bool CanRespawnAcrossZones(BasePlayer player)
	{
		return true;
	}
}


using System;
using Facepunch;
using Network;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerStateManager
{
	private readonly MruDictionary<ulong, PlayerState> _cache;

	private readonly UserPersistance _persistence;

	public int CacheSize
	{
		get
		{
			return _cache.Capacity;
		}
		set
		{
			_cache.SetCapacity(value);
		}
	}

	public int CacheCount => _cache.Count;

	public long CacheEvictions => _cache.EvictionCount;

	public PlayerStateManager(UserPersistance persistence)
	{
		_cache = new MruDictionary<ulong, PlayerState>(10000, (Action<ulong, PlayerState>)FreeOldState);
		_persistence = persistence;
	}

	public PlayerState Get(ulong playerId)
	{
		TimeWarning val = TimeWarning.New("PlayerStateManager.Get", 0);
		try
		{
			PlayerState result = default(PlayerState);
			if (_cache.TryGetValue(playerId, ref result))
			{
				return result;
			}
			byte[] playerState = _persistence.GetPlayerState(playerId);
			PlayerState val2;
			if (playerState != null && playerState.Length != 0)
			{
				try
				{
					val2 = PlayerState.Deserialize(playerState);
					OnPlayerStateLoaded(val2);
					_cache.Add(playerId, val2);
					return val2;
				}
				catch (Exception arg)
				{
					Debug.LogError((object)$"Failed to load player state for {playerId}: {arg}");
				}
			}
			val2 = Pool.Get<PlayerState>();
			_cache.Add(playerId, val2);
			return val2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Save(ulong playerId)
	{
		PlayerState state = default(PlayerState);
		if (_cache.TryGetValue(playerId, ref state))
		{
			SaveState(playerId, state);
		}
	}

	private void SaveState(ulong playerId, PlayerState state)
	{
		TimeWarning val = TimeWarning.New("PlayerStateManager.SaveState", 0);
		try
		{
			byte[] state2 = ProtoStreamExtensions.ToProtoBytes((IProto)(object)state);
			_persistence.SetPlayerState(playerId, state2);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to save player state for {playerId}: {arg}");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FreeOldState(ulong playerId, PlayerState state)
	{
		SaveState(playerId, state);
		state.Dispose();
	}

	public void Reset(ulong playerId)
	{
		_cache.Remove(playerId);
		_persistence.ResetPlayerState(playerId);
	}

	private void OnPlayerStateLoaded(PlayerState state)
	{
		state.unHostileTimestamp = Math.Min(state.unHostileTimestamp, TimeEx.currentTimestamp + 1800.0);
	}
}


using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using UnityEngine;

public static class PremiumUtil
{
	public struct PremiumCheckResult
	{
		public bool IsPremium;

		public bool Exception;

		public bool ShowException;

		public string FailReason;

		public PremiumCheckResult(bool isPremium, string failReason = null)
		{
			IsPremium = isPremium;
			FailReason = failReason;
			Exception = false;
			ShowException = true;
		}
	}

	[JsonModel]
	public class PremiumStatusResult
	{
		public long RequiredValueUsdCents;

		public long ValueUsdCents;

		[JsonIgnore]
		public bool Exception;

		[JsonIgnore]
		public bool IsPremium
		{
			get
			{
				if (ValueUsdCents >= RequiredValueUsdCents)
				{
					return RequiredValueUsdCents != 0;
				}
				return false;
			}
		}
	}

	[JsonModel]
	private class PremiumCheckRequest
	{
		public List<ulong> SteamIds { get; set; }
	}

	[JsonModel]
	private class PremiumCheckResponse
	{
		public Dictionary<ulong, bool> Results { get; set; }
	}

	public const string KickReason = "premium_account_required";

	public static readonly Phrase KickPhrase = new Phrase("premium.kick_phrase", "Your account must have premium status to play on this server.");

	public static string PremiumStatusEndpoint = "https://rust-premium.facepunch.com/api/premium/status";

	private static readonly HttpClient Http = new HttpClient();

	public static async Task<PremiumCheckResult> CheckIfPlayerIsPremium(ulong steamId)
	{
		try
		{
			List<ulong> players = Pool.Get<List<ulong>>();
			players.Add(steamId);
			Dictionary<ulong, bool> obj = await CheckIfPlayersArePremium(players);
			Pool.FreeUnmanaged<ulong>(ref players);
			if (!obj.TryGetValue(steamId, out var value))
			{
				Debug.LogError((object)$"Failed to check if user {steamId} is premium due to user not being in the results");
				return new PremiumCheckResult(isPremium: false, "Failed to validate premium status: Missing User in Results");
			}
			if (!value)
			{
				return new PremiumCheckResult(isPremium: false, "premium_account_required");
			}
			return new PremiumCheckResult(isPremium: true);
		}
		catch (HttpRequestException val)
		{
			Debug.LogError((object)$"Failed to check if user {steamId} is premium due to a network error");
			Debug.LogException((Exception)val);
			PremiumCheckResult result = new PremiumCheckResult(isPremium: false, "Failed to validate premium status: Network Error");
			result.Exception = true;
			result.ShowException = false;
			return result;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)$"Failed to check if user {steamId} is premium due to an exception");
			Debug.LogException(ex);
			PremiumCheckResult result = new PremiumCheckResult(isPremium: false, "Failed to validate premium status: Exception");
			result.Exception = true;
			return result;
		}
	}

	public static async Task<Dictionary<ulong, bool>> CheckIfPlayersArePremium(List<ulong> steamIds)
	{
		if (steamIds == null)
		{
			throw new ArgumentNullException("steamIds");
		}
		if (steamIds.Count == 0)
		{
			throw new ArgumentException("SteamIDs list cannot be empty", "steamIds");
		}
		string text = JsonConvert.SerializeObject((object)new PremiumCheckRequest
		{
			SteamIds = steamIds
		});
		HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, Server.premiumVerifyEndpoint);
		try
		{
			request.Content = (HttpContent)new StringContent(text, Encoding.UTF8, "application/json");
			HttpResponseMessage response = await Http.SendAsync(request);
			try
			{
				response.EnsureSuccessStatusCode();
				string text2 = await response.Content.ReadAsStringAsync();
				PremiumCheckResponse premiumCheckResponse = JsonConvert.DeserializeObject<PremiumCheckResponse>(text2);
				if (premiumCheckResponse?.Results == null || premiumCheckResponse.Results.Count != steamIds.Count)
				{
					throw new Exception("Premium verify endpoint returned malformed response: " + text2);
				}
				return premiumCheckResponse.Results;
			}
			finally
			{
				((IDisposable)response)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)request)?.Dispose();
		}
	}
}


public struct PremiumCheckResult
{
	public bool IsPremium;

	public bool Exception;

	public bool ShowException;

	public string FailReason;

	public PremiumCheckResult(bool isPremium, string failReason = null)
	{
		IsPremium = isPremium;
		FailReason = failReason;
		Exception = false;
		ShowException = true;
	}
}


using Newtonsoft.Json;

[JsonModel]
public class PremiumStatusResult
{
	public long RequiredValueUsdCents;

	public long ValueUsdCents;

	[JsonIgnore]
	public bool Exception;

	[JsonIgnore]
	public bool IsPremium
	{
		get
		{
			if (ValueUsdCents >= RequiredValueUsdCents)
			{
				return RequiredValueUsdCents != 0;
			}
			return false;
		}
	}
}


using System.Collections.Generic;

[JsonModel]
private class PremiumCheckRequest
{
	public List<ulong> SteamIds { get; set; }
}


using System.Collections.Generic;

[JsonModel]
private class PremiumCheckResponse
{
	public Dictionary<ulong, bool> Results { get; set; }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Models;
using Facepunch.Network;
using Facepunch.Ping;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Ionic.Crc;
using Network;
using Network.Visibility;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai.Gen2;
using SilentOrbit.ProtocolBuffers;
using Steamworks;
using UnityEngine;

public class ServerMgr : SingletonComponent<ServerMgr>, IServerCallback
{
	public const string BYPASS_PROCEDURAL_SPAWN_PREF = "bypassProceduralSpawn";

	private ConnectionAuth auth;

	public UserPersistance persistance;

	public PlayerStateManager playerStateManager;

	private AIThinkManager.QueueType aiTick;

	private Stopwatch methodTimer = new Stopwatch();

	private Stopwatch updateTimer = new Stopwatch();

	private RealTimeSinceEx sinceLastPremiumRecheck = 0.0;

	private List<ulong> bannedPlayerNotices = new List<ulong>();

	private string _AssemblyHash;

	public IEnumerator restartCoroutine;

	public static readonly Phrase RESTARTING_SERVER_PHRASE = new Phrase("server.restarting_server", "Server Restarting...");

	public static readonly Phrase RESTARTING_SERVER_WITH_INFO_PHRASE = new Phrase("server.restarting_server_info", "Server Restarting: ({0})");

	public static readonly Phrase RESTARTING_SERVER_IN_MINUTES_PHRASE = new Phrase("server.restarting_server_in_minutes", "Server Restarting in {0} minutes!");

	public static readonly Phrase RESTARTING_SERVER_IN_MINUTES_WITH_INFO_PHRASE = new Phrase("server.restarting_server_in_minutes_info", "Server Restarting in {0} minutes ({1})");

	public static readonly Phrase RESTARTING_SERVER_IN_SECONDS_PHRASE = new Phrase("server.restarting_server_in", "Server Restarting in {0} seconds!");

	public static readonly Phrase RESTARTING_SERVER_IN_SECONDS_WITH_INFO_PHRASE = new Phrase("server.restarting_server_in_info", "Server Restarting in {0} seconds ({1})");

	public static readonly Phrase RESTART_INTERRUPTED_PHRASE = new Phrase("server.restart_interrupted", "Server Restart interrupted!");

	public ConnectionQueue connectionQueue = new ConnectionQueue();

	public TimeAverageValueLookup<Type> packetHistory = new TimeAverageValueLookup<Type>();

	public TimeAverageValueLookup<uint> rpcHistory = new TimeAverageValueLookup<uint>();

	private Stopwatch timer = new Stopwatch();

	public bool runFrameUpdate { get; private set; }

	public int AvailableSlots => ConVar.Server.maxplayers - BasePlayer.activePlayerList.Count - connectionQueue.ReservedCount;

	private string AssemblyHash
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Expected O, but got Unknown
			if (_AssemblyHash == null)
			{
				string location = typeof(ServerMgr).Assembly.Location;
				if (!string.IsNullOrEmpty(location))
				{
					byte[] array = File.ReadAllBytes(location);
					CRC32 val = new CRC32();
					val.SlurpBlock(array, 0, array.Length);
					_AssemblyHash = val.Crc32Result.ToString("x");
				}
				else
				{
					_AssemblyHash = "il2cpp";
				}
			}
			return _AssemblyHash;
		}
	}

	public bool Restarting => restartCoroutine != null;

	public bool Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		TutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);
		BasePlayer.InitInternalState();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			TimeWarning val = TimeWarning.New("SpawnHandler.UpdateDistributions", 0);
			try
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (loadSave)
		{
			World.LoadedFromSave = true;
			World.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));
		}
		else
		{
			SaveRestore.SaveCreatedTime = DateTime.UtcNow;
			World.LoadedFromSave = false;
		}
		if (!World.LoadedFromSave)
		{
			SaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());
		}
		SaveRestore.InitializeWipeId();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			TimeWarning val;
			if (!skipInitialSpawn)
			{
				val = TimeWarning.New("SpawnHandler.InitialSpawn", 200);
				try
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			val = TimeWarning.New("SpawnHandler.StartSpawnTick", 200);
			try
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		CreateImportantEntities();
		auth = ((Component)this).GetComponent<ConnectionAuth>();
		Analytics.Azure.Initialize();
		return World.LoadedFromSave;
	}

	public void OpenConnection(bool useSteamServer = true)
	{
		if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
		}
		Net.sv.ip = ConVar.Server.ip;
		Net.sv.port = ConVar.Server.port;
		Net.sv.secure = ConVar.Server.secure;
		bool secure = ConVar.Server.secure;
		if (CommandLine.HasSwitch("-insecure"))
		{
			Net.sv.secure = false;
			ConVar.Server.secure = false;
		}
		if (Net.sv.secure && ConVar.Server.encryption < 2)
		{
			Debug.LogWarning((object)"A server requires a minimum 'encryption' convar value of 1 to be secure and visible in the server browser, in a future release this will be increased to 2. To remain secure, increase your 'encryption' convar to 2 before starting your server.");
			if (ConVar.Server.encryption < 1)
			{
				Net.sv.secure = false;
				ConVar.Server.secure = false;
			}
		}
		if (!secure && !CommandLine.HasSwitch("-insecure"))
		{
			Debug.LogWarning((object)"The 'secure' convar is now obsolete. For running an insecure server please pass '-insecure' in the startup parameters. This convar will be removed in a future release.");
			Net.sv.secure = false;
		}
		if (useSteamServer)
		{
			StartSteamServer();
		}
		else
		{
			PlatformService.Instance.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		}
		if (!Net.sv.Start((IServerCallback)(object)this))
		{
			Debug.LogWarning((object)"Couldn't Start Server.");
			CloseConnection();
			return;
		}
		((BaseNetwork)Net.sv).cryptography = (INetworkCryptography)(object)new NetworkCryptographyServer();
		EACServer.DoStartup();
		((MonoBehaviour)this).InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		((MonoBehaviour)this).InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		Interface.CallHook("IOnServerInitialized");
	}

	public void CloseConnection()
	{
		if (persistance != null)
		{
			persistance.Dispose();
			persistance = null;
		}
		EACServer.DoShutdown();
		Net.sv.callbackHandler = null;
		TimeWarning val = TimeWarning.New("sv.Stop", 0);
		try
		{
			Net.sv.Stop("Shutting Down");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("RCon.Shutdown", 0);
		try
		{
			RCon.Shutdown();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("PlatformService.Shutdown", 0);
		try
		{
			IPlatformService instance = PlatformService.Instance;
			if (instance != null)
			{
				instance.Shutdown();
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("CompanionServer.Shutdown", 0);
		try
		{
			CompanionServer.Server.Shutdown();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("NexusServer.Shutdown", 0);
		try
		{
			NexusServer.Shutdown();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("ServerOcclusion.Dispose", 0);
		try
		{
			if (ServerOcclusion.OcclusionEnabled)
			{
				ServerOcclusion.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		ConsoleSystem.OnReplicatedVarChanged -= OnReplicatedVarChanged;
		BasePlayer.DisposeInternalState();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			CloseConnection();
		}
	}

	private void OnApplicationQuit()
	{
		Application.isQuitting = true;
		CloseConnection();
	}

	private void CreateImportantEntities()
	{
		CreateImportantEntity<EnvSync>("assets/bundled/prefabs/system/net_env.prefab");
		CreateImportantEntity<CommunityEntity>("assets/bundled/prefabs/system/server/community.prefab");
		CreateImportantEntity<ResourceDepositManager>("assets/bundled/prefabs/system/server/resourcedepositmanager.prefab");
		CreateImportantEntity<RelationshipManager>("assets/bundled/prefabs/system/server/relationship_manager.prefab");
		if (Clan.enabled)
		{
			CreateImportantEntity<ClanManager>("assets/bundled/prefabs/system/server/clan_manager.prefab");
		}
		CreateImportantEntity<TreeManager>("assets/bundled/prefabs/system/tree_manager.prefab");
		CreateImportantEntity<GlobalNetworkHandler>("assets/bundled/prefabs/system/net_global.prefab");
		CreateImportantEntity<CopyPasteEntity>("assets/bundled/prefabs/system/copy_paste.prefab");
		CreateImportantEntity<BuriedItems>("assets/bundled/prefabs/system/server/buried_items.prefab");
	}

	public void CreateImportantEntity<T>(string prefabName) where T : BaseEntity
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)BaseNetworkable.serverEntities.OfType<T>().FirstOrDefault()))
		{
			Debug.LogWarning((object)("Missing " + typeof(T).Name + " - creating"));
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabName);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Debug.LogWarning((object)"Couldn't create");
			}
			else
			{
				baseEntity.Spawn();
			}
		}
	}

	private void StartSteamServer()
	{
		PlatformService.Instance.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		((MonoBehaviour)this).InvokeRepeating("UpdateServerInformation", 2f, 30f);
		((MonoBehaviour)this).InvokeRepeating("UpdateItemDefinitions", 10f, 3600f);
		DebugEx.Log((object)"SteamServer Initialized", (StackTraceLogType)0);
	}

	private void UpdateItemDefinitions()
	{
		Debug.Log((object)"Checking for new Steam Item Definitions..");
		PlatformService.Instance.RefreshItemDefinitions();
	}

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Invalid comparison between Unknown and I4
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Invalid comparison between Unknown and I4
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Invalid comparison between Unknown and I4
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Invalid comparison between Unknown and I4
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Connection val = ((IEnumerable<Connection>)Net.sv.connections).FirstOrDefault((Func<Connection, bool>)((Connection x) => x.userid == SteamId));
		if (val == null)
		{
			Debug.LogWarning((object)$"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
		}
		else if ((int)Status == 2)
		{
			Debug.LogWarning((object)$"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
		}
		else if ((int)Status != 1)
		{
			if (((int)Status == 4 || (int)Status == 3) && !bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", (object)val, (object)Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + StringEx.EscapeRichText(val.username, false) + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			Debug.Log((object)$"Kicking {val.ipaddress}/{val.userid}/{val.username} (Steam Status \"{((object)(AuthResponse)(ref Status)/*cast due to .constrained prefix*/).ToString()}\")");
			val.authStatusSteam = ((object)(AuthResponse)(ref Status)/*cast due to .constrained prefix*/).ToString();
			Net.sv.Kick(val, "Steam: " + ((object)(AuthResponse)(ref Status)/*cast due to .constrained prefix*/).ToString(), false);
		}
	}

	private void Update()
	{
		if (!runFrameUpdate)
		{
			return;
		}
		updateTimer.Restart();
		Manifest manifest = Application.Manifest;
		if (manifest != null && manifest.Features.ServerAnalytics)
		{
			try
			{
				PerformanceLogging.server.OnFrame();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		TimeWarning val = TimeWarning.New("ServerMgr.Update", 500);
		try
		{
			try
			{
				TimeWarning val2 = TimeWarning.New("EACServer.DoUpdate", 100);
				try
				{
					EACServer.DoUpdate();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex2)
			{
				Debug.LogWarning((object)"Server Exception: EACServer.DoUpdate");
				Debug.LogException(ex2, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BuriedItems.DoUpdate", 100);
				try
				{
					if (Object.op_Implicit((Object)(object)BuriedItems.Instance))
					{
						BuriedItems.Instance.DoUpdate();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex3)
			{
				Debug.LogWarning((object)"Server Exception: BuriedItems.DoUpdate");
				Debug.LogException(ex3, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("PlatformService.Update", 100);
				try
				{
					PlatformService.Instance.Update();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex4)
			{
				Debug.LogWarning((object)"Server Exception: Platform Service Update");
				Debug.LogException(ex4, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BaseMountable.PlayerSyncCycle", 0);
				try
				{
					BaseMountable.PlayerSyncCycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex5)
			{
				Debug.LogWarning((object)"Server Exception: BaseMountable Player Sync Cycle");
				Debug.LogException(ex5, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Net.sv.Cycle", 100);
				try
				{
					methodTimer.Restart();
					((BaseNetwork)Net.sv).Cycle();
					RuntimeProfiler.Net_Cycle = methodTimer.Elapsed;
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex6)
			{
				Debug.LogWarning((object)"Server Exception: Network Cycle");
				Debug.LogException(ex6, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("ServerBuildingManager.Cycle", 0);
				try
				{
					BuildingManager.server.Cycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex7)
			{
				Debug.LogWarning((object)"Server Exception: Building Manager");
				Debug.LogException(ex7, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BasePlayer.ServerCycle", 0);
				try
				{
					bool batchsynctransforms = Physics.batchsynctransforms;
					bool autosynctransforms = Physics.autosynctransforms;
					if (batchsynctransforms && autosynctransforms)
					{
						Physics.autoSyncTransforms = false;
					}
					if (!Physics.autoSyncTransforms)
					{
						methodTimer.Restart();
						Physics.SyncTransforms();
						RuntimeProfiler.Physics_SyncTransforms = methodTimer.Elapsed;
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("CameraRendererManager.Tick", 100);
						try
						{
							CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
							if ((Object)(object)instance != (Object)null)
							{
								methodTimer.Restart();
								instance.Tick();
								RuntimeProfiler.Companion_Tick = methodTimer.Elapsed;
							}
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogWarning((object)"Server Exception: CameraRendererManager.Tick");
						Debug.LogException(ex8, (Object)(object)this);
					}
					methodTimer.Restart();
					BasePlayer.ServerCycle(Time.deltaTime);
					RuntimeProfiler.BasePlayer_ServerCycle = methodTimer.Elapsed;
					try
					{
						TimeWarning val3 = TimeWarning.New("FlameTurret.BudgetedUpdate", 0);
						try
						{
							((ObjectWorkQueue<FlameTurret>)FlameTurret.updateFlameTurretQueueServer).RunQueue(0.25);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogWarning((object)"Server Exception: FlameTurret.BudgetedUpdate");
						Debug.LogException(ex9, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("AutoTurret.BudgetedUpdate", 0);
						try
						{
							((PersistentObjectWorkQueue<AutoTurret>)AutoTurret.updateAutoTurretScanQueue).RunList((double)AutoTurret.auto_turret_budget_ms);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogWarning((object)"Server Exception: AutoTurret.BudgetedUpdate");
						Debug.LogException(ex10, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("GunTrap.BudgetedUpdate", 0);
						try
						{
							((PersistentObjectWorkQueue<GunTrap>)GunTrap.updateGunTrapWorkQueue).RunList((double)GunTrap.gun_trap_budget_ms);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogWarning((object)"Server Exception: GunTrap.BudgetedUpdate");
						Debug.LogException(ex11, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("BaseFishingRod.BudgetedUpdate", 0);
						try
						{
							((ObjectWorkQueue<BaseFishingRod>)BaseFishingRod.updateFishingRodQueue).RunQueue(1.0);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogWarning((object)"Server Exception: BaseFishingRod.BudgetedUpdate");
						Debug.LogException(ex12, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("DroppedItem.BudgetedUpdate", 0);
						try
						{
							((PersistentObjectWorkQueue<DroppedItem>)DroppedItem.underwaterStatusQueue).RunList((double)DroppedItem.underwater_drag_budget_ms);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogWarning((object)"Server Exception: DroppedItem.BudgetedUpdate");
						Debug.LogException(ex13, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("ItemModFoodSpoiling.BudgetedUpdate", 0);
						try
						{
							if (ConVar.Server.foodSpoiling)
							{
								((PersistentObjectWorkQueue<Item>)ItemModFoodSpoiling.foodSpoilItems).RunList((double)ConVar.Server.foodSpoilingBudgetMs);
							}
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex14)
					{
						Debug.LogWarning((object)"Server Exception: ItemModFoodSpoiling.BudgetedUpdate");
						Debug.LogException(ex14, (Object)(object)this);
					}
					if (batchsynctransforms && autosynctransforms)
					{
						Physics.autoSyncTransforms = true;
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex15)
			{
				Debug.LogWarning((object)"Server Exception: Player Update");
				Debug.LogException(ex15, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("connectionQueue.Cycle", 0);
				try
				{
					connectionQueue.Cycle(AvailableSlots);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex16)
			{
				Debug.LogWarning((object)"Server Exception: Connection Queue");
				Debug.LogException(ex16, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("IOEntity.ProcessQueue", 0);
				try
				{
					IOEntity.ProcessQueue();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex17)
			{
				Debug.LogWarning((object)"Server Exception: IOEntity.ProcessQueue");
				Debug.LogException(ex17, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("NpcManagers.Tick", 0);
				try
				{
					if ((Object)(object)SingletonComponent<NpcFireManager>.Instance != (Object)null)
					{
						SingletonComponent<NpcFireManager>.Instance.Tick();
					}
					if ((Object)(object)SingletonComponent<NpcNoiseManager>.Instance != (Object)null)
					{
						SingletonComponent<NpcNoiseManager>.Instance.Tick();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex18)
			{
				Debug.LogWarning((object)"Server Exception: NpcManagers.Tick");
				Debug.LogException(ex18, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("FSMComponent.BudgetedUpdate", 0);
				try
				{
					((PersistentObjectWorkQueue<FSMComponent>)FSMComponent.workQueue).RunList(0.5);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex19)
			{
				Debug.LogWarning((object)"Server Exception: FSMComponent.BudgetedUpdate");
				Debug.LogException(ex19, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("LimitedTurnNavAgent.TickSteering", 0);
				try
				{
					LimitedTurnNavAgent.TickSteering();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex20)
			{
				Debug.LogWarning((object)"Server Exception: LimitedTurnNavAgent.TickSteering");
				Debug.LogException(ex20, (Object)(object)this);
			}
			if (!AI.spliceupdates)
			{
				aiTick = AIThinkManager.QueueType.Human;
			}
			else
			{
				aiTick = ((aiTick == AIThinkManager.QueueType.Human) ? AIThinkManager.QueueType.Animal : AIThinkManager.QueueType.Human);
			}
			if (aiTick == AIThinkManager.QueueType.Human)
			{
				try
				{
					TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessQueue", 0);
					try
					{
						AIThinkManager.ProcessQueue(AIThinkManager.QueueType.Human);
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				catch (Exception ex21)
				{
					Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessQueue");
					Debug.LogException(ex21, (Object)(object)this);
				}
				if (!AI.spliceupdates)
				{
					aiTick = AIThinkManager.QueueType.Animal;
				}
			}
			if (aiTick == AIThinkManager.QueueType.Animal)
			{
				try
				{
					TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessAnimalQueue", 0);
					try
					{
						AIThinkManager.ProcessQueue(AIThinkManager.QueueType.Animal);
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				catch (Exception ex22)
				{
					Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessAnimalQueue");
					Debug.LogException(ex22, (Object)(object)this);
				}
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessPetQueue", 0);
				try
				{
					AIThinkManager.ProcessQueue(AIThinkManager.QueueType.Pets);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex23)
			{
				Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessPetQueue");
				Debug.LogException(ex23, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessPetMovementQueue", 0);
				try
				{
					BasePet.ProcessMovementQueue();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex24)
			{
				Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessPetMovementQueue");
				Debug.LogException(ex24, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BaseSculpture.ProcessGridUpdates", 0);
				try
				{
					BaseSculpture.ProcessGridUpdates();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex25)
			{
				Debug.LogWarning((object)"Server Exception: BaseSculpture.ProcessGridUpdates");
				Debug.LogException(ex25, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("GrowableEntity.BudgetedUpdate", 0);
				try
				{
					((ObjectWorkQueue<GrowableEntity>)GrowableEntity.growableEntityUpdateQueue).RunQueue((double)GrowableEntity.framebudgetms);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex26)
			{
				Debug.LogWarning((object)"Server Exception: GrowableEntity.BudgetedUpdate");
				Debug.LogException(ex26, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BasePlayer.BudgetedLifeStoryUpdate", 0);
				try
				{
					((ObjectWorkQueue<BasePlayer>)BasePlayer.lifeStoryQueue).RunQueue((double)BasePlayer.lifeStoryFramebudgetms);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex27)
			{
				Debug.LogWarning((object)"Server Exception: BasePlayer.BudgetedLifeStoryUpdate");
				Debug.LogException(ex27, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("JunkPileWater.UpdateNearbyPlayers", 0);
				try
				{
					((ObjectWorkQueue<JunkPileWater>)JunkPileWater.junkpileWaterWorkQueue).RunQueue((double)JunkPileWater.framebudgetms);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex28)
			{
				Debug.LogWarning((object)"Server Exception: JunkPileWater.UpdateNearbyPlayers");
				Debug.LogException(ex28, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("IndustrialEntity.RunQueue", 0);
				try
				{
					if (!SaveRestore.IsSaving || !ConVar.Server.pauseindustrialduringsave)
					{
						((ObjectWorkQueue<IndustrialEntity>)IndustrialEntity.Queue).RunQueue((double)ConVar.Server.industrialFrameBudgetMs);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex29)
			{
				Debug.LogWarning((object)"Server Exception: IndustrialEntity.RunQueue");
				Debug.LogException(ex29, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Hopper.WorkQueue", 0);
				try
				{
					((PersistentObjectWorkQueue<Hopper>)Hopper.WorkQueue).RunList((double)ConVar.Server.hopperAnimationBudgetMs);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex30)
			{
				Debug.LogWarning((object)"Server Exception: Hopper.WorkQueue");
				Debug.LogException(ex30, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("AntiHack.Cycle", 0);
				try
				{
					AntiHack.Cycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex31)
			{
				Debug.LogWarning((object)"Server Exception: AntiHack.Cycle");
				Debug.LogException(ex31, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("TreeManager.SendPendingTrees", 0);
				try
				{
					TreeManager.server.SendPendingTrees();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex32)
			{
				Debug.LogWarning((object)"Server Exception: TreeManager.SendPendingTrees");
				Debug.LogException(ex32, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("ChickenCoop.CoopWorkQueue", 0);
				try
				{
					((ObjectWorkQueue<ChickenCoop>)ChickenCoop.CoopWorkQueue).RunQueue(0.10000000149011612);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex33)
			{
				Debug.LogWarning((object)"Server Exception: ChickenCoop.CoopWorkQueue");
				Debug.LogException(ex33, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("FarmableAnimal.NeedsWorkQueue", 0);
				try
				{
					((ObjectWorkQueue<FarmableAnimal>)FarmableAnimal.NeedsWorkQueue).RunQueue(0.10000000149011612);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex34)
			{
				Debug.LogWarning((object)"Server Exception: FarmableAnimal.NeedsWorkQueue");
				Debug.LogException(ex34, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Chicken.EggWorkQueue", 0);
				try
				{
					((ObjectWorkQueue<Chicken>)Chicken.EggWorkQueue).RunQueue(0.10000000149011612);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex35)
			{
				Debug.LogWarning((object)"Server Exception: Chicken.EggWorkQueue");
				Debug.LogException(ex35, (Object)(object)this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		RuntimeProfiler.ServerMgr_Update = updateTimer.Elapsed;
	}

	private void LateUpdate()
	{
		if (!runFrameUpdate)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("ServerMgr.LateUpdate", 500);
		try
		{
			if (!SteamNetworking.steamnagleflush)
			{
				return;
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Connection.Flush", 0);
				try
				{
					for (int i = 0; i < Net.sv.connections.Count; i++)
					{
						Net.sv.Flush(Net.sv.connections[i]);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)"Server Exception: Connection.Flush");
				Debug.LogException(ex, (Object)(object)this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FixedUpdate()
	{
		TimeWarning val = TimeWarning.New("ServerMgr.FixedUpdate", 0);
		try
		{
			try
			{
				TimeWarning val2 = TimeWarning.New("BaseMountable.FixedUpdateCycle", 0);
				try
				{
					BaseMountable.FixedUpdateCycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)"Server Exception: Mountable Cycle");
				Debug.LogException(ex, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Buoyancy.Cycle", 0);
				try
				{
					Buoyancy.Cycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex2)
			{
				Debug.LogWarning((object)"Server Exception: Buoyancy Cycle");
				Debug.LogException(ex2, (Object)(object)this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		NexusServer.Update();
		for (int i = 0; i < Net.sv.connections.Count; i++)
		{
			Connection val = Net.sv.connections[i];
			if (!val.isAuthenticated && !(val.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Net.sv.Kick(val, "Authentication Timed Out", false);
			}
		}
		float num = Mathf.Max(ConVar.Server.premiumRecheckInterval, 60f);
		if (ConVar.Server.premium && (double)sinceLastPremiumRecheck > (double)num)
		{
			sinceLastPremiumRecheck = 0.0;
			RecheckPremiumStatus();
		}
	}

	private void DoHeartbeat()
	{
		ItemManager.Heartbeat();
	}

	private void RecheckPremiumStatus()
	{
		float num = Mathf.Clamp(ConVar.Server.premiumRecheckMinSeconds, 60f, 1800f);
		double num2 = Time.realtimeSinceStartupAsDouble - (double)num;
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection connection in Net.sv.connections)
		{
			if (connection.connected && connection.lastPremiumCheckTime < num2)
			{
				list.Add(connection);
			}
		}
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<Connection>(ref list);
			return;
		}
		list.Sort((Connection x, Connection y) => x.lastPremiumCheckTime.CompareTo(y.lastPremiumCheckTime));
		int num3 = Mathf.Clamp(ConVar.Server.premiumRecheckMaxBatchSize, 10, 500);
		if (list.Count > num3)
		{
			list.RemoveRange(num3, list.Count - num3);
		}
		RecheckPremiumStatusImpl(list);
		static async void RecheckPremiumStatusImpl(List<Connection> connections)
		{
			try
			{
				List<ulong> steamIds = Pool.Get<List<ulong>>();
				foreach (Connection connection2 in connections)
				{
					steamIds.Add(connection2.userid);
				}
				Dictionary<ulong, bool> dictionary = await PremiumUtil.CheckIfPlayersArePremium(steamIds);
				Pool.FreeUnmanaged<ulong>(ref steamIds);
				double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
				foreach (Connection connection3 in connections)
				{
					if (connection3.connected)
					{
						if (!dictionary.TryGetValue(connection3.userid, out var value))
						{
							Debug.LogWarning((object)$"Missing premium status for {connection3.userid}");
						}
						else
						{
							connection3.lastPremiumCheckTime = realtimeSinceStartupAsDouble;
							if (!value && BasePlayer.TryFindByID(connection3.userid, out var basePlayer))
							{
								basePlayer.Kick("premium_account_required", reserveSlot: false);
							}
						}
					}
				}
				Pool.FreeUnmanaged<Connection>(ref connections);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)"Error rechecking premium status for connected players");
				Debug.LogException(ex);
			}
		}
	}

	private static BaseGameMode Gamemode()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (!((Object)(object)activeGameMode != (Object)null))
		{
			return null;
		}
		return activeGameMode;
	}

	public static string GamemodeName()
	{
		return Gamemode()?.shortname ?? "rust";
	}

	public static string GamemodeTitle()
	{
		return Gamemode()?.gamemodeTitle ?? "Survival";
	}

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateServerInformation", 0);
		try
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.GetServerBrowserMapName();
			string text = "stok";
			if (Restarting)
			{
				text = "strst";
			}
			string text2 = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text3 = $"gm{GamemodeName()}";
			if (text3 != "gmrust" && text3 != "gmvanilla")
			{
				ConVar.Server.tags = ConVar.Server.tags.Replace("vanilla", "");
			}
			string text4 = (ConVar.Server.pve ? ",pve" : string.Empty);
			string text5 = ConVar.Server.tags?.Trim(',') ?? "";
			string text6 = ((!string.IsNullOrWhiteSpace(text5)) ? ("," + text5) : "");
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj == null)
			{
				obj = "0";
			}
			string text7 = (string)obj;
			string text8 = (ConVar.Server.premium ? ",premium" : "");
			string text9 = PingEstimater.GetCachedClosestRegion().Code;
			if (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))
			{
				text9 = ConVar.Server.ping_region_code_override;
			}
			SteamServer.GameTags = ServerTagCompressor.CompressTags($"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text9},v{2594}{text4}{text6},{text2},{text3},cs{text7}{text8},ts{RelationshipManager.maxTeamSize}");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = StringEx.SplitToChunks(ConVar.Server.description, 100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("status", text);
			string text10 = World.Seed.ToString();
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.ingameMap)
			{
				text10 = "0";
			}
			SteamServer.SetKey("world.seed", text10);
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			SteamServer.SetKey("map_image_url", MapUploader.ImageUrl);
			if (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))
			{
				SteamServer.SetKey("favendpoint", ConVar.Server.favoritesEndpoint);
			}
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("uptime", ((int)Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("ram_sys", (Performance.report.memoryUsageSystem / 1000000).ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Interface.CallHook("OnServerInformationUpdated");
	}

	public void OnDisconnected(string strReason, Connection connection)
	{
		Analytics.Azure.OnPlayerDisconnected(connection, strReason);
		GlobalNetworkHandler.server.OnClientDisconnected(connection);
		connectionQueue.TryAddReservedSlot(connection);
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		if (connection.authStatusSteam == "ok")
		{
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			Interface.CallHook("OnPlayerDisconnected", (object)basePlayer, (object)strReason);
			basePlayer.OnDisconnected();
		}
		if (connection.authStatusNexus == "ok")
		{
			NexusServer.Logout(connection.userid);
		}
	}

	public static void OnEnterVisibility(Connection connection, Group group)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)19);
			obj.GroupID(group.ID);
			obj.Send(new SendInfo(connection));
		}
	}

	public static void OnLeaveVisibility(Connection connection, Group group)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)20);
			obj.GroupID(group.ID);
			obj.Send(new SendInfo(connection));
			NetWrite obj2 = ((BaseNetwork)Net.sv).StartWrite();
			obj2.PacketID((Type)8);
			obj2.GroupID(group.ID);
			obj2.Send(new SendInfo(connection));
		}
	}

	public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null, ulong teamId = 0uL)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnFindSpawnPoint", (object)forPlayer, (object)teamId);
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
				if (forPlayer.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)
				{
					spawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;
				}
				else
				{
					spawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;
				}
				return spawnPoint;
			}
		}
		BaseGameMode baseGameMode = Gamemode();
		if (Object.op_Implicit((Object)(object)baseGameMode) && baseGameMode.useCustomSpawns)
		{
			BasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);
			if (playerSpawn != null)
			{
				return playerSpawn;
			}
		}
		if ((Object)(object)SingletonComponent<SpawnHandler>.Instance != (Object)null && !flag)
		{
			BasePlayer.SpawnPoint spawnPointForTeam = SpawnHandler.GetSpawnPointForTeam(teamId);
			if (spawnPointForTeam != null)
			{
				spawnPointForTeam.isProcedualSpawn = true;
				return spawnPointForTeam;
			}
			BasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();
			if (spawnPoint2 != null)
			{
				spawnPoint2.isProcedualSpawn = true;
				return spawnPoint2;
			}
		}
		BasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland2 != (Object)null)
			{
				spawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;
				spawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;
				return spawnPoint3;
			}
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject val = array[Random.Range(0, array.Length)];
			spawnPoint3.pos = val.transform.position;
			spawnPoint3.rot = val.transform.rotation;
		}
		else
		{
			Debug.Log((object)"Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if ((Object)(object)MainCamera.mainCamera != (Object)null)
			{
				spawnPoint3.pos = MainCamera.position;
				spawnPoint3.rot = MainCamera.rotation;
			}
		}
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(new Ray(spawnPoint3.pos, Vector3.down), ref val2, 32f, 1537286401))
		{
			spawnPoint3.pos = ((RaycastHit)(ref val2)).point;
		}
		return spawnPoint3;
	}

	public void JoinGame(Connection connection)
	{
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		Approval val = Pool.Get<Approval>();
		try
		{
			uint num = (uint)ConVar.Server.encryption;
			if (num > 1 && connection.os == "editor" && DeveloperList.Contains(connection.ownerid))
			{
				num = 1u;
			}
			if (num > 1 && !Net.sv.secure)
			{
				num = 1u;
			}
			val.level = Application.loadedLevelName;
			val.levelConfig = World.Config.JsonString;
			val.levelTransfer = World.Transfer;
			val.levelUrl = World.Url;
			val.levelSeed = World.Seed;
			val.levelSize = World.Size;
			val.checksum = World.Checksum;
			val.hostname = ConVar.Server.hostname;
			val.official = ConVar.Server.official;
			val.encryption = num;
			val.version = BuildInfo.Current.Scm.Branch + "#" + BuildInfo.Current.Scm.ChangeId;
			val.nexus = World.Nexus;
			val.nexusEndpoint = Nexus.endpoint;
			val.nexusId = NexusServer.NexusId.GetValueOrDefault();
			NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
			val2.PacketID((Type)3);
			ProtoStreamExtensions.WriteToStream((IProto)(object)val, (Stream)(object)val2, false, 2097152);
			val2.Send(new SendInfo(connection));
			connection.encryptionLevel = num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		connection.connected = true;
	}

	internal void Shutdown()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(Option.Server, "server.save", Array.Empty<object>());
		ConsoleSystem.Run(Option.Server, "server.writecfg", Array.Empty<object>());
	}

	private static void ShowToastToAllClients(GameTip.Styles style, Phrase phrase, bool overlay = false, params string[] arguments)
	{
		ConsoleNetwork.BroadcastToAllClients("gametip.showtoast_translated", (int)style, phrase.token, phrase.english, overlay, arguments);
	}

	private IEnumerator ServerRestartWarning(string info, int iSeconds)
	{
		if (iSeconds < 0)
		{
			yield break;
		}
		Phrase restartingPhrase = (string.IsNullOrEmpty(info) ? RESTARTING_SERVER_PHRASE : RESTARTING_SERVER_WITH_INFO_PHRASE);
		Phrase restartingInMinutesPhrase = (string.IsNullOrEmpty(info) ? RESTARTING_SERVER_IN_MINUTES_PHRASE : RESTARTING_SERVER_IN_MINUTES_WITH_INFO_PHRASE);
		Phrase restartingInSecondsPhrase = (string.IsNullOrEmpty(info) ? RESTARTING_SERVER_IN_SECONDS_PHRASE : RESTARTING_SERVER_IN_SECONDS_WITH_INFO_PHRASE);
		if (!string.IsNullOrEmpty(info))
		{
			ShowToastToAllClients(GameTip.Styles.Server_Event, restartingPhrase, false, info);
		}
		for (int i = iSeconds; i > 0; i--)
		{
			if (i == iSeconds || i % 60 == 0 || (i < 300 && i % 30 == 0) || (i < 60 && i % 10 == 0) || i < 10)
			{
				if (i >= 60)
				{
					string text = TimeSpan.FromSeconds(i).ToString("mm\\:ss");
					ShowToastToAllClients(GameTip.Styles.Server_Event, restartingInMinutesPhrase, false, text, info);
				}
				else
				{
					ShowToastToAllClients(GameTip.Styles.Server_Event, restartingInSecondsPhrase, false, i.ToString(), info);
				}
				Debug.Log((object)$"Restarting in {i} seconds");
			}
			yield return CoroutineEx.waitForSeconds(1f);
		}
		ShowToastToAllClients(GameTip.Styles.Server_Event, restartingPhrase, false, info);
		yield return CoroutineEx.waitForSeconds(2f);
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int j = 0; j < array.Length; j++)
		{
			array[j].Kick("Server Restarting");
		}
		yield return CoroutineEx.waitForSeconds(1f);
		ConsoleSystem.Run(Option.Server, "quit", Array.Empty<object>());
	}

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if ((Object)(object)SingletonComponent<ServerMgr>.Instance == (Object)null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ShowToastToAllClients(GameTip.Styles.Server_Event, RESTART_INTERRUPTED_PHRASE, false);
			((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", (object)strNotice, (object)iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

	public static void SendReplicatedVars(string filter)
	{
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection connection in Net.sv.connections)
		{
			if (connection.connected)
			{
				list.Add(connection);
			}
		}
		List<Command> list2 = Pool.Get<List<Command>>();
		foreach (Command item in Server.Replicated)
		{
			if (item.FullName.StartsWith(filter))
			{
				list2.Add(item);
			}
		}
		val.PacketID((Type)25);
		val.Int32(list2.Count);
		foreach (Command item2 in list2)
		{
			val.String(item2.FullName, false);
			val.String(item2.String, false);
		}
		val.Send(new SendInfo(list));
		Pool.FreeUnmanaged<Command>(ref list2);
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public static void SendReplicatedVars(Connection connection)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		List<Command> replicated = Server.Replicated;
		val.PacketID((Type)25);
		val.Int32(replicated.Count);
		foreach (Command item in replicated)
		{
			val.String(item.FullName, false);
			val.String(item.String, false);
		}
		val.Send(new SendInfo(connection));
	}

	private static void OnReplicatedVarChanged(string fullName, string value)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection connection in Net.sv.connections)
		{
			if (connection.connected)
			{
				list.Add(connection);
			}
		}
		val.PacketID((Type)25);
		val.Int32(1);
		val.String(fullName, false);
		val.String(value, false);
		val.Send(new SendInfo(list));
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	void IServerCallback.RequestSave(Stream stream)
	{
		SaveRestore.RequestSave(stream);
	}

	void IServerCallback.AddOnSaveCallback(Action<Stream> callback)
	{
		SaveRestore.AddOnSaveCallback(callback);
	}

	void IServerCallback.RemoveOnSaveCallback(Action<Stream> callback)
	{
		SaveRestore.RemoveOnSaveCallback(callback);
	}

	ServerInfo IServerCallback.GetServerInfo()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		ServerInfo result = default(ServerInfo);
		result.NetworkVersion = 2594;
		BuildInfo current = BuildInfo.Current;
		object obj;
		if (current == null)
		{
			obj = null;
		}
		else
		{
			ScmInfo scm = current.Scm;
			obj = ((scm != null) ? scm.ChangeId : null);
		}
		if (obj == null)
		{
			obj = "0";
		}
		result.Changeset = (string)obj;
		result.Hostname = ConVar.Server.hostname;
		result.Seed = World.Seed;
		result.WorldSize = World.Size;
		result.Level = LevelManager.CurrentLevelName;
		result.LevelUrl = World.Url;
		result.Checksum = World.Checksum;
		return result;
	}

	private void Log(Exception e)
	{
		if (Global.developer > 0)
		{
			Debug.LogException(e);
		}
	}

	public void OnNetworkMessage(Message packet)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_0587: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Invalid comparison between Unknown and I4
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected I4, but got Unknown
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Expected I4, but got Unknown
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Server.packetlog_enabled)
		{
			packetHistory.Increment(packet.type);
		}
		if (PacketProfiler.enabled)
		{
			PacketProfiler.LogInbound(packet.type, (int)((Stream)(object)packet.read).Length);
		}
		Type type = packet.type;
		if ((int)type != 4)
		{
			switch (type - 9)
			{
			default:
				switch (type - 18)
				{
				case 0:
				{
					if (packet.connection.GetPacketsPerSecond(packet.type) >= 1)
					{
						Net.sv.Kick(packet.connection, "Packet Flooding: User Information", packet.connection.connected);
						return;
					}
					TimeWarning val = TimeWarning.New("GiveUserInformation", 20);
					try
					{
						OnGiveUserInformation(packet);
					}
					catch (Exception e4)
					{
						Log(e4);
						Net.sv.Kick(packet.connection, "Invalid Packet: User Information", false);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
					packet.connection.AddPacketsPerSecond(packet.type);
					return;
				}
				case 4:
				{
					TimeWarning val = TimeWarning.New("OnEACMessage", 20);
					try
					{
						EACServer.OnMessageReceived(packet);
						return;
					}
					catch (Exception e6)
					{
						Log(e6);
						Net.sv.Kick(packet.connection, "Invalid Packet: EAC", false);
						return;
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				case 6:
				{
					if (!World.Transfer || !packet.connection.connected)
					{
						return;
					}
					if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_world)
					{
						Net.sv.Kick(packet.connection, "Packet Flooding: World", packet.connection.connected);
						return;
					}
					TimeWarning val = TimeWarning.New("OnWorldMessage", 20);
					try
					{
						WorldNetworking.OnMessageReceived(packet);
						return;
					}
					catch (Exception e5)
					{
						Log(e5);
						Net.sv.Kick(packet.connection, "Invalid Packet: World", false);
						return;
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				case 3:
				{
					if (!packet.connection.connected)
					{
						return;
					}
					if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_voice)
					{
						Net.sv.Kick(packet.connection, "Packet Flooding: Disconnect Reason", packet.connection.connected);
						return;
					}
					TimeWarning val = TimeWarning.New("OnPlayerVoice", 20);
					try
					{
						OnPlayerVoice(packet);
					}
					catch (Exception e3)
					{
						Log(e3);
						Net.sv.Kick(packet.connection, "Invalid Packet: Player Voice", false);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
					packet.connection.AddPacketsPerSecond(packet.type);
					return;
				}
				}
				break;
			case 0:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_rpc)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: RPC Message", false);
					return;
				}
				TimeWarning val = TimeWarning.New("OnRPCMessage", 20);
				try
				{
					OnRPCMessage(packet);
				}
				catch (Exception e8)
				{
					Log(e8);
					Net.sv.Kick(packet.connection, "Invalid Packet: RPC Message", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 3:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_command)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: Client Command", packet.connection.connected);
					return;
				}
				TimeWarning val = TimeWarning.New("OnClientCommand", 20);
				try
				{
					ConsoleNetwork.OnClientCommand(packet);
				}
				catch (Exception e7)
				{
					Log(e7);
					Net.sv.Kick(packet.connection, "Invalid Packet: Client Command", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 5:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= 1)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: Disconnect Reason", packet.connection.connected);
					return;
				}
				TimeWarning val = TimeWarning.New("ReadDisconnectReason", 20);
				try
				{
					ReadDisconnectReason(packet);
					Net.sv.Disconnect(packet.connection);
				}
				catch (Exception e2)
				{
					Log(e2);
					Net.sv.Kick(packet.connection, "Invalid Packet: Disconnect Reason", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 6:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_tick)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: Player Tick", packet.connection.connected);
					return;
				}
				TimeWarning val = TimeWarning.New("OnPlayerTick", 20);
				try
				{
					OnPlayerTick(packet);
				}
				catch (Exception e)
				{
					Log(e);
					Net.sv.Kick(packet.connection, "Invalid Packet: Player Tick", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 1:
			case 2:
			case 4:
				break;
			}
			ProcessUnhandledPacket(packet);
		}
		else
		{
			if (!packet.connection.connected)
			{
				return;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) >= 1)
			{
				Net.sv.Kick(packet.connection, "Packet Flooding: Client Ready", packet.connection.connected);
				return;
			}
			TimeWarning val = TimeWarning.New("ClientReady", 20);
			try
			{
				ClientReady(packet);
			}
			catch (Exception e9)
			{
				Log(e9);
				Net.sv.Kick(packet.connection, "Invalid Packet: Client Ready", false);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			packet.connection.AddPacketsPerSecond(packet.type);
		}
	}

	public void ProcessUnhandledPacket(Message packet)
	{
		if (Global.developer > 0)
		{
			Debug.LogWarning((object)("[SERVER][UNHANDLED] " + ((object)(Type)(ref packet.type)/*cast due to .constrained prefix*/).ToString()));
		}
		Net.sv.Kick(packet.connection, "Sent Unhandled Message", false);
	}

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String(4096, false);
		string text2 = ((object)packet.connection).ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			Interface.CallHook("OnClientDisconnect", (object)packet.connection, (object)text);
			DebugEx.Log((object)(text2 + " disconnecting: " + text), (StackTraceLogType)0);
		}
	}

	private BasePlayer SpawnPlayerSleeping(Connection connection)
	{
		BasePlayer basePlayer = BasePlayer.FindSleeping(connection.userid);
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (!basePlayer.IsSleeping())
		{
			Debug.LogWarning((object)"Player spawning into sleeper that isn't sleeping!");
			basePlayer.Kill();
			return null;
		}
		basePlayer.PlayerInit(connection);
		basePlayer.inventory.SendSnapshot();
		DebugEx.Log((object)(((object)basePlayer.net.connection).ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]"), (StackTraceLogType)0);
		return basePlayer;
	}

	public BasePlayer SpawnNewPlayer(Connection connection)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(connection.userid);
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint(null, playerTeam?.teamID ?? 0);
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", (object)basePlayer, (object)connection) != null)
		{
			return (BasePlayer)(object)spawnPoint;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		if (connection == null)
		{
			basePlayer.EnableTransferProtection();
		}
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		if (connection != null)
		{
			basePlayer.PlayerInit(connection);
			bool flag = Application.isEditor || (SleepingBag.FindForPlayer(basePlayer.userID, ignoreTimers: true).Length == 0 && !basePlayer.hasPreviousLife);
			if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
			{
				BaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer, flag);
			}
			else if (flag)
			{
				basePlayer.Respawn();
			}
			DebugEx.Log((object)$"{basePlayer.displayName} with steamid {basePlayer.userID.Get()} joined from ip {basePlayer.net.connection.ipaddress}", (StackTraceLogType)0);
			DebugEx.Log((object)$"\tNetworkId {basePlayer.userID.Get()} is {basePlayer.net.ID} ({basePlayer.displayName})", (StackTraceLogType)0);
			if (basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
			{
				DebugEx.Log((object)$"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}", (StackTraceLogType)0);
			}
		}
		if (playerTeam != null && playerTeam.usePartySpawn && spawnPoint.isProcedualSpawn && playerTeam.firstSpawnLocation == default(Vector3))
		{
			playerTeam.firstSpawnLocation = spawnPoint.pos;
		}
		return basePlayer;
	}

	private void ClientReady(Message packet)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Invalid comparison between Unknown and I4
		if ((int)packet.connection.state != 3)
		{
			Net.sv.Kick(packet.connection, "Invalid connection state", false);
			return;
		}
		ClientReady val = packet.read.Proto<ClientReady>((ClientReady)null);
		try
		{
			foreach (ClientInfo item in val.clientInfo)
			{
				Interface.CallHook("OnPlayerSetInfo", (object)packet.connection, (object)item.name, (object)item.value);
				packet.connection.info.Set(item.name, item.value);
			}
			packet.connection.globalNetworking = val.globalNetworking;
			connectionQueue.JoinedGame(packet.connection);
			Analytics.Azure.OnPlayerConnected(packet.connection);
			AddPartyMembersToTeam(packet.connection, val.party);
			TimeWarning val2 = TimeWarning.New("ClientReady", 0);
			try
			{
				TimeWarning val3 = TimeWarning.New("SpawnPlayerSleeping", 0);
				BasePlayer basePlayer;
				try
				{
					basePlayer = SpawnPlayerSleeping(packet.connection);
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				if ((Object)(object)basePlayer == (Object)null)
				{
					val3 = TimeWarning.New("SpawnNewPlayer", 0);
					try
					{
						basePlayer = SpawnNewPlayer(packet.connection);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				basePlayer.SendRespawnOptions();
				basePlayer.LoadClanInfo();
				if ((Object)(object)basePlayer != (Object)null)
				{
					Util.SendSignedInNotification(basePlayer);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SendReplicatedVars(packet.connection);
	}

	private void AddPartyMembersToTeam(Connection connection, PartyData party)
	{
		if (party == null || party.members == null || party.members.Count == 0)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindByJoinKey(party.joinKey);
		if (playerTeam != null)
		{
			if (!RelationshipManager.ServerInstance.IsPlayerInTeam(connection.userid))
			{
				playerTeam.AddPlayer(connection.userid);
			}
			return;
		}
		foreach (PartyMemberData member in party.members)
		{
			if (!RelationshipManager.ServerInstance.IsPlayerInTeam(member.steamId))
			{
				SingletonComponent<ServerMgr>.Instance.persistance.SetDefaultPlayerName(member.steamId, member.name);
				if (playerTeam == null)
				{
					playerTeam = RelationshipManager.ServerInstance.CreatePartyTeam(party.joinKey);
				}
				playerTeam.AddPlayer(member.steamId);
				if (playerTeam.members.Count == 1 || member.isLeader)
				{
					playerTeam.teamLeader = member.steamId;
				}
			}
		}
	}

	private void OnRPCMessage(Message packet)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		timer.Restart();
		NetworkableId uid = packet.read.EntityID();
		uint num = packet.read.UInt32();
		if (ConVar.Server.rpclog_enabled)
		{
			rpcHistory.Increment(num);
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(uid) as BaseEntity;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.SendDemoTransientEntity();
			baseEntity.SV_RPCMessage(num, packet);
			if (timer.Elapsed > RuntimeProfiler.RpcWarningThreshold)
			{
				LagSpikeProfiler.RPC(timer.Elapsed, packet, baseEntity, num);
			}
		}
	}

	private void OnPlayerTick(Message packet)
	{
		BasePlayer basePlayer = packet.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.OnReceivedTick(packet.read);
		}
	}

	private void OnPlayerVoice(Message packet)
	{
		BasePlayer basePlayer = packet.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.OnReceivedVoice(packet.read.BytesWithSize(10485760u, false));
		}
	}

	private void OnGiveUserInformation(Message packet)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if ((int)packet.connection.state != 0)
		{
			Net.sv.Kick(packet.connection, "Invalid connection state", false);
			return;
		}
		packet.connection.state = (State)1;
		if (packet.read.UInt8() != 228)
		{
			Net.sv.Kick(packet.connection, "Invalid Connection Protocol", false);
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128, false);
		packet.connection.username = packet.read.String(256, false);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Net.sv.Kick(packet.connection, "Invalid Username", false);
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Net.sv.Kick(packet.connection, "Invalid Username", false);
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128, false);
		}
		Interface.CallHook("OnClientAuth", (object)packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log((object)("Kicking " + ((object)packet.connection)?.ToString() + " - their branch is '" + text + "' not '" + branch + "'"), (StackTraceLogType)0);
			Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!", false);
		}
		else if (packet.connection.protocol > 2594)
		{
			DebugEx.Log((object)("Kicking " + ((object)packet.connection)?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2594), (StackTraceLogType)0);
			Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!", false);
		}
		else if (packet.connection.protocol < 2594)
		{
			DebugEx.Log((object)("Kicking " + ((object)packet.connection)?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2594), (StackTraceLogType)0);
			Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!", false);
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u, false);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Net.sv.Kick(packet.connection, "Invalid Token", false);
				return;
			}
			packet.connection.anticheatId = packet.read.StringRaw(128, false);
			packet.connection.anticheatToken = packet.read.StringRaw(2048, false);
			packet.connection.clientChangeset = packet.read.Int32();
			packet.connection.clientBuildTime = packet.read.Int64();
			auth.OnNewConnection(packet.connection);
		}
	}
}


using System;
using System.IO;
using System.Linq;
using Facepunch;
using Rust;
using UnityEngine;
using UnityEngine.Profiling;

public class ServerPerformance : BaseMonoBehaviour
{
	public static ulong deaths;

	public static ulong spawns;

	public static ulong position_changes;

	private string fileName;

	private int lastFrame;

	private void Start()
	{
		if (Profiler.supported && CommandLine.HasSwitch("-perf"))
		{
			fileName = "perfdata." + DateTime.Now.ToString() + ".txt";
			fileName = fileName.Replace('\\', '-');
			fileName = fileName.Replace('/', '-');
			fileName = fileName.Replace(' ', '_');
			fileName = fileName.Replace(':', '.');
			lastFrame = Time.frameCount;
			File.WriteAllText(fileName, "MemMono,MemUnity,Frame,PlayerCount,Sleepers,CollidersDisabled,BehavioursDisabled,GameObjects,Colliders,RigidBodies,BuildingBlocks,nwSend,nwRcv,cnInit,cnApp,cnRej,deaths,spawns,poschange\r\n");
			((FacepunchBehaviour)this).InvokeRepeating((Action)WriteLine, 1f, 60f);
		}
	}

	private void WriteLine()
	{
		Rust.GC.Collect();
		uint monoUsedSize = Profiler.GetMonoUsedSize();
		uint usedHeapSize = Profiler.usedHeapSize;
		int count = BasePlayer.activePlayerList.Count;
		int count2 = BasePlayer.sleepingPlayerList.Count;
		int num = Object.FindObjectsOfType<GameObject>().Length;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		int num6 = 0;
		int num7 = Time.frameCount - lastFrame;
		File.AppendAllText(fileName, monoUsedSize + "," + usedHeapSize + "," + num7 + "," + count + "," + count2 + "," + NetworkSleep.totalCollidersDisabled + "," + NetworkSleep.totalBehavioursDisabled + "," + num + "," + Object.FindObjectsOfType<Collider>().Length + "," + Object.FindObjectsOfType<Rigidbody>().Length + "," + Object.FindObjectsOfType<BuildingBlock>().Length + "," + num2 + "," + num3 + "," + num4 + "," + num5 + "," + num6 + "," + deaths + "," + spawns + "," + position_changes + "\r\n");
		lastFrame = Time.frameCount;
		deaths = 0uL;
		spawns = 0uL;
		position_changes = 0uL;
	}

	public static void DoReport()
	{
		string text = "report." + DateTime.Now.ToString() + ".txt";
		text = text.Replace('\\', '-');
		text = text.Replace('/', '-');
		text = text.Replace(' ', '_');
		text = text.Replace(':', '.');
		File.WriteAllText(text, "Report Generated " + DateTime.Now.ToString() + "\r\n");
		string filename = text;
		Object[] objects = (Object[])(object)Object.FindObjectsOfType<Transform>();
		ComponentReport(filename, "All Objects", objects);
		string filename2 = text;
		objects = (Object[])(object)Object.FindObjectsOfType<BaseEntity>();
		ComponentReport(filename2, "Entities", objects);
		string filename3 = text;
		objects = (Object[])(object)Object.FindObjectsOfType<Rigidbody>();
		ComponentReport(filename3, "Rigidbodies", objects);
		string filename4 = text;
		objects = (Object[])(object)(from x in Object.FindObjectsOfType<Collider>()
			where !x.enabled
			select x).ToArray();
		ComponentReport(filename4, "Disabled Colliders", objects);
		string filename5 = text;
		objects = (Object[])(object)(from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).ToArray();
		ComponentReport(filename5, "Enabled Colliders", objects);
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.DumpReport(text);
		}
	}

	public static string WorkoutPrefabName(GameObject obj)
	{
		if ((Object)(object)obj == (Object)null)
		{
			return "null";
		}
		string text = (obj.activeSelf ? "" : " (inactive)");
		BaseEntity baseEntity = obj.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			return baseEntity.PrefabName + text;
		}
		return ((Object)obj).name + text;
	}

	public static void ComponentReport(string filename, string Title, Object[] objects)
	{
		File.AppendAllText(filename, "\r\n\r\n" + Title + ":\r\n\r\n");
		foreach (IGrouping<string, Object> item in from x in objects
			group x by WorkoutPrefabName(((Component)((x is Component) ? x : null)).gameObject) into x
			orderby x.Count() descending
			select x)
		{
			File.AppendAllText(filename, "\t" + WorkoutPrefabName(((Component)/*isinst with value type is only supported in some contexts*/).gameObject) + " - " + item.Count() + "\r\n");
		}
		File.AppendAllText(filename, "\r\nTotal: " + objects.Count() + "\r\n\r\n\r\n");
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class ServerPlayers
{
	private static readonly HashSet<ulong> OnlineUserIdSet = new HashSet<ulong>();

	private static int _currentFrame;

	public static bool IsOnline(ulong userId)
	{
		RebuildIfNecessary();
		return OnlineUserIdSet.Contains(userId);
	}

	public static void GetAll(List<ulong> userIds)
	{
		RebuildIfNecessary();
		foreach (ulong item in OnlineUserIdSet)
		{
			userIds.Add(item);
		}
	}

	private static void RebuildIfNecessary()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		int frameCount = Time.frameCount;
		if (frameCount == _currentFrame)
		{
			return;
		}
		_currentFrame = frameCount;
		OnlineUserIdSet.Clear();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				OnlineUserIdSet.Add(current.userID);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public static class ServerSubscriptions
{
	private static readonly Memoized<string, string> FoundationGrade = new Memoized<string, string>((Func<string, string>)((string s) => s.Replace("Block", "").ToLower()));

	private static readonly Memoized<string, string> FoundationType = new Memoized<string, string>((Func<string, string>)((string s) => (!s.Contains("foundation.triangle")) ? "s" : "t"));

	public static void StartSubscribeFeed()
	{
		InvokeHandler.InvokeRepeating((Behaviour)(object)Global.Runner, (Action)SendPlayerPositions, 0f, 0.2f);
		InvokeHandler.InvokeRepeating((Behaviour)(object)Global.Runner, (Action)SendFoundations, 0f, 5f);
	}

	public static void StopSubscribeFeed()
	{
		InvokeHandler.CancelInvoke((Behaviour)(object)Global.Runner, (Action)SendPlayerPositions);
		InvokeHandler.CancelInvoke((Behaviour)(object)Global.Runner, (Action)SendFoundations);
	}

	private static void SendFoundations()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isServerStarted || !RCon.HasSubscribers)
		{
			return;
		}
		ListDictionary<uint, BuildingManager.Building> buildingDictionary = BuildingManager.server.buildingDictionary;
		StringBuilder stringBuilder = Pool.Get<StringBuilder>();
		Vector3 val = default(Vector3);
		Quaternion val2 = default(Quaternion);
		foreach (KeyValuePair<uint, BuildingManager.Building> item in buildingDictionary)
		{
			Enumerator<BuildingBlock> enumerator2 = item.Value.buildingBlocks.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BuildingBlock current = enumerator2.Current;
					if (((Object)current).name.Contains("foundation") && !((Object)current).name.Contains("foundation.steps"))
					{
						((Component)current).gameObject.transform.GetPositionAndRotation(ref val, ref val2);
						stringBuilder.AppendJoin(',', FoundationGrade.Get(current.grade.ToString()), FoundationType.Get(((Object)current).name), val.x.ToString("0.00"), val.y.ToString("0.00"), val.z.ToString("0.00"), ((Quaternion)(ref val2)).eulerAngles.y.ToString("0.0"), ((Bounds)(ref current.bounds)).size.x);
						stringBuilder.Append("\n");
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		try
		{
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Remove(stringBuilder.Length - 1, 1);
			}
			RCon.SendMessageToSubscribers(stringBuilder.ToString(), -64002);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		Pool.FreeUnmanaged(ref stringBuilder);
	}

	private static void SendPlayerPositions()
	{
		if (!Application.isServerStarted || !RCon.HasSubscribers)
		{
			return;
		}
		try
		{
			RCon.SendMessageToSubscribers(ConVar.Server.GetPlayerListPosTable(forJson: true).ToJson(true), -64001);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch.Math;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using UnityEngine;

public static class ServerUsers
{
	public enum UserGroup
	{
		None,
		Owner,
		Moderator,
		Banned,
		SkipQueue
	}

	[JsonModel]
	public class User
	{
		public ulong steamid;

		[JsonConverter(typeof(StringEnumConverter))]
		public UserGroup group;

		public string username;

		public string notes;

		public long expiry;

		[JsonIgnore]
		public bool IsExpired
		{
			get
			{
				if (expiry > 0)
				{
					return Epoch.Current > expiry;
				}
				return false;
			}
		}
	}

	private static StringBuilder sb = new StringBuilder(65536);

	public static Dictionary<ulong, User> users = new Dictionary<ulong, User>();

	public static void Remove(ulong uid)
	{
		Interface.CallHook("OnServerUserRemove", (object)uid);
		users.Remove(uid);
	}

	public static void Set(ulong uid, UserGroup group, string username, string notes, long expiry = -1L)
	{
		Remove(uid);
		User value = new User
		{
			steamid = uid,
			group = group,
			username = username,
			notes = notes,
			expiry = expiry
		};
		Interface.CallHook("OnServerUserSet", (object)uid, (object)group, (object)username, (object)notes, (object)expiry);
		users.Add(uid, value);
	}

	public static User Get(ulong uid)
	{
		if (!users.TryGetValue(uid, out var value))
		{
			return null;
		}
		if (!value.IsExpired)
		{
			return value;
		}
		Remove(uid);
		return null;
	}

	public static bool Is(ulong uid, UserGroup group)
	{
		User user = Get(uid);
		if (user == null)
		{
			return false;
		}
		return user.group == group;
	}

	public static IEnumerable<User> GetAll(UserGroup group)
	{
		return from x in users.Values
			where x.@group == @group
			where !x.IsExpired
			select x;
	}

	public static void Clear()
	{
		users.Clear();
	}

	public static void Load()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		string serverFolder = Server.GetServerFolder("cfg");
		Option server;
		if (File.Exists(serverFolder + "/bans.cfg"))
		{
			string text = File.ReadAllText(serverFolder + "/bans.cfg");
			if (!string.IsNullOrEmpty(text))
			{
				Debug.Log((object)("Running " + serverFolder + "/bans.cfg"));
				server = Option.Server;
				ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text);
			}
		}
		if (File.Exists(serverFolder + "/users.cfg"))
		{
			string text2 = File.ReadAllText(serverFolder + "/users.cfg");
			if (!string.IsNullOrEmpty(text2))
			{
				Debug.Log((object)("Running " + serverFolder + "/users.cfg"));
				server = Option.Server;
				ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text2);
			}
		}
	}

	public static void Save()
	{
		foreach (ulong item in (from kv in users
			where kv.Value.IsExpired
			select kv.Key).ToList())
		{
			Remove(item);
		}
		string serverFolder = Server.GetServerFolder("cfg");
		sb.Clear();
		foreach (User item2 in GetAll(UserGroup.Banned))
		{
			if (!(item2.notes == "EAC"))
			{
				sb.Append("banid ");
				sb.Append(item2.steamid);
				sb.Append(' ');
				StringBuilderExtensions.QuoteSafe(sb, item2.username);
				sb.Append(' ');
				StringBuilderExtensions.QuoteSafe(sb, item2.notes);
				sb.Append(' ');
				sb.Append(item2.expiry);
				sb.Append("\r\n");
			}
		}
		File.WriteAllText(serverFolder + "/bans.cfg", sb.ToString());
		sb.Clear();
		foreach (User item3 in GetAll(UserGroup.Owner))
		{
			sb.Append("ownerid ");
			sb.Append(item3.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item3.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item3.notes);
			sb.Append("\r\n");
		}
		foreach (User item4 in GetAll(UserGroup.Moderator))
		{
			sb.Append("moderatorid ");
			sb.Append(item4.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item4.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item4.notes);
			sb.Append("\r\n");
		}
		foreach (User item5 in GetAll(UserGroup.SkipQueue))
		{
			sb.Append("skipqueueid ");
			sb.Append(item5.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item5.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item5.notes);
			sb.Append("\r\n");
		}
		File.WriteAllText(serverFolder + "/users.cfg", sb.ToString());
	}

	public static string BanListString(bool bHeader = false)
	{
		List<User> list = GetAll(UserGroup.Banned).ToList();
		sb.Clear();
		if (bHeader)
		{
			if (list.Count == 0)
			{
				return "ID filter list: empty\n";
			}
			if (list.Count == 1)
			{
				sb.Append("ID filter list: 1 entry\n");
			}
			else
			{
				sb.Append($"ID filter list: {list.Count} entries\n");
			}
		}
		int num = 1;
		foreach (User item in list)
		{
			sb.Append(num);
			sb.Append(' ');
			sb.Append(item.steamid);
			sb.Append(" : ");
			if (item.expiry > 0)
			{
				double num2 = (double)(item.expiry - Epoch.Current) / 60.0;
				sb.Append(num2.ToString("F3"));
				sb.Append(" min");
			}
			else
			{
				sb.Append("permanent");
			}
			sb.Append('\n');
			num++;
		}
		return sb.ToString();
	}

	public static string BanListStringEx()
	{
		IEnumerable<User> all = GetAll(UserGroup.Banned);
		sb.Clear();
		int num = 1;
		foreach (User item in all)
		{
			sb.Append(num);
			sb.Append(' ');
			sb.Append(item.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item.notes);
			sb.Append(' ');
			sb.Append(item.expiry);
			sb.Append('\n');
			num++;
		}
		return sb.ToString();
	}
}


public enum UserGroup
{
	None,
	Owner,
	Moderator,
	Banned,
	SkipQueue
}


using Facepunch.Math;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

[JsonModel]
public class User
{
	public ulong steamid;

	[JsonConverter(typeof(StringEnumConverter))]
	public UserGroup group;

	public string username;

	public string notes;

	public long expiry;

	[JsonIgnore]
	public bool IsExpired
	{
		get
		{
			if (expiry > 0)
			{
				return Epoch.Current > expiry;
			}
			return false;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class TriggerHurtEx : TriggerBase, IServerComponent, IHurtTrigger
{
	public enum HurtType
	{
		Simple,
		IncludeBleedingAndScreenShake
	}

	public class EntityTriggerInfo
	{
		public Vector3 lastPosition;
	}

	public float repeatRate = 0.1f;

	[Header("LOS Settings")]
	public bool LOSCheck;

	public float LOSDistance = 2f;

	[Header("On Enter")]
	public List<DamageTypeEntry> damageOnEnter;

	public GameObjectRef effectOnEnter;

	public HurtType hurtTypeOnEnter;

	[Header("On Timer (damage per second)")]
	public List<DamageTypeEntry> damageOnTimer;

	public GameObjectRef effectOnTimer;

	public HurtType hurtTypeOnTimer;

	[Header("On Move (damage per meter)")]
	public List<DamageTypeEntry> damageOnMove;

	public GameObjectRef effectOnMove;

	public HurtType hurtTypeOnMove;

	[Header("On Leave")]
	public List<DamageTypeEntry> damageOnLeave;

	public GameObjectRef effectOnLeave;

	public HurtType hurtTypeOnLeave;

	public bool damageEnabled = true;

	internal Dictionary<BaseEntity, EntityTriggerInfo> entityInfo;

	internal List<BaseEntity> entityAddList;

	internal List<BaseEntity> entityLeaveList;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (baseEntity.IsNpc && baseEntity is NPCPlayer)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal void DoDamage(BaseEntity ent, HurtType type, List<DamageTypeEntry> damage, GameObjectRef effect, float multiply = 1f)
	{
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		if (!damageEnabled)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TriggerHurtEx.DoDamage", 0);
		try
		{
			if (damage != null && damage.Count > 0)
			{
				if (LOSCheck)
				{
					Vector3 val2 = ((Component)this).transform.position + new Vector3(0f, 0.1f, 0f);
					Vector3 val3 = ((Component)ent).transform.position - ((Component)this).transform.position;
					if (GamePhysics.Trace(new Ray(val2, ((Vector3)(ref val3)).normalized), 0f, out var _, LOSDistance, 1218519297, (QueryTriggerInteraction)1, ((Component)this).gameObject.ToBaseEntity()))
					{
						return;
					}
				}
				BaseCombatEntity baseCombatEntity = ent as BaseCombatEntity;
				if (Object.op_Implicit((Object)(object)baseCombatEntity))
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.damageTypes.Add(damage);
					hitInfo2.damageTypes.ScaleAll(multiply);
					hitInfo2.DoHitEffects = true;
					hitInfo2.DidHit = true;
					hitInfo2.Initiator = ((Component)this).gameObject.ToBaseEntity();
					hitInfo2.PointStart = ((Component)this).transform.position;
					hitInfo2.PointEnd = ((Component)baseCombatEntity).transform.position;
					ModifyHit(hitInfo2);
					if (type == HurtType.Simple)
					{
						baseCombatEntity.Hurt(hitInfo2);
					}
					else
					{
						baseCombatEntity.OnAttacked(hitInfo2);
					}
				}
			}
			if (effect.isValid)
			{
				Effect.server.Run(effect.resourcePath, ent, StringPool.closest, ((Component)this).transform.position, Vector3.up);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected virtual void ModifyHit(HitInfo info)
	{
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (!((Object)(object)ent == (Object)null))
		{
			if (entityAddList == null)
			{
				entityAddList = new List<BaseEntity>();
			}
			entityAddList.Add(ent);
			((FacepunchBehaviour)this).Invoke((Action)ProcessQueues, 0.1f);
		}
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (!((Object)(object)ent == (Object)null))
		{
			if (entityLeaveList == null)
			{
				entityLeaveList = new List<BaseEntity>();
			}
			entityLeaveList.Add(ent);
			((FacepunchBehaviour)this).Invoke((Action)ProcessQueues, 0.1f);
		}
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, repeatRate, repeatRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		ProcessQueues();
		if (entityInfo == null)
		{
			return;
		}
		KeyValuePair<BaseEntity, EntityTriggerInfo>[] array = entityInfo.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			KeyValuePair<BaseEntity, EntityTriggerInfo> keyValuePair = array[i];
			if (keyValuePair.Key.IsValid())
			{
				Vector3 position = ((Component)keyValuePair.Key).transform.position;
				Vector3 val = position - keyValuePair.Value.lastPosition;
				float magnitude = ((Vector3)(ref val)).magnitude;
				if (magnitude > 0.01f)
				{
					keyValuePair.Value.lastPosition = position;
					DoDamage(keyValuePair.Key, hurtTypeOnMove, damageOnMove, effectOnMove, magnitude);
				}
				DoDamage(keyValuePair.Key, hurtTypeOnTimer, damageOnTimer, effectOnTimer, repeatRate);
			}
		}
	}

	private void ProcessQueues()
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if (entityAddList != null)
		{
			foreach (BaseEntity entityAdd in entityAddList)
			{
				if (entityAdd.IsValid())
				{
					DoDamage(entityAdd, hurtTypeOnEnter, damageOnEnter, effectOnEnter);
					if (entityInfo == null)
					{
						entityInfo = new Dictionary<BaseEntity, EntityTriggerInfo>();
					}
					if (!entityInfo.ContainsKey(entityAdd))
					{
						entityInfo.Add(entityAdd, new EntityTriggerInfo
						{
							lastPosition = ((Component)entityAdd).transform.position
						});
					}
				}
			}
			entityAddList = null;
		}
		if (entityLeaveList == null)
		{
			return;
		}
		foreach (BaseEntity entityLeave in entityLeaveList)
		{
			if (!entityLeave.IsValid())
			{
				continue;
			}
			DoDamage(entityLeave, hurtTypeOnLeave, damageOnLeave, effectOnLeave);
			if (entityInfo != null)
			{
				entityInfo.Remove(entityLeave);
				if (entityInfo.Count == 0)
				{
					entityInfo = null;
				}
			}
		}
		entityLeaveList.Clear();
	}
}


public enum HurtType
{
	Simple,
	IncludeBleedingAndScreenShake
}


using UnityEngine;

public class EntityTriggerInfo
{
	public Vector3 lastPosition;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Math;
using Facepunch.Nexus;
using Facepunch.Rust;
using Facepunch.Sqlite;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class UserPersistance : IDisposable
{
	public static Database blueprints;

	public static Database deaths;

	public static Database identities;

	public static Database tokens;

	public static Database playerState;

	public static Dictionary<ulong, string> nameCache;

	private static Dictionary<ulong, string> wipeIdCache;

	public static MruDictionary<ulong, (int Token, bool Locked)> tokenCache;

	public UserPersistance(string strFolder)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Expected O, but got Unknown
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Expected O, but got Unknown
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Expected O, but got Unknown
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Expected O, but got Unknown
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Expected O, but got Unknown
		blueprints = new Database();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		string text = strFolder + "/player.blueprints.";
		if ((Object)(object)activeGameMode != (Object)null && activeGameMode.wipeBpsOnProtocol)
		{
			text = text + 270 + ".";
		}
		blueprints.Open(text + 5 + ".db", true);
		if (!blueprints.TableExists("data"))
		{
			blueprints.Execute("CREATE TABLE data ( userid TEXT PRIMARY KEY, info BLOB, updated INTEGER )");
		}
		deaths = new Database();
		deaths.Open(strFolder + "/player.deaths." + 5 + ".db", true);
		if (!deaths.TableExists("data"))
		{
			deaths.Execute("CREATE TABLE data ( userid TEXT, born INTEGER, died INTEGER, info BLOB )");
			deaths.Execute("CREATE INDEX IF NOT EXISTS userindex ON data ( userid )");
			deaths.Execute("CREATE INDEX IF NOT EXISTS diedindex ON data ( died )");
		}
		identities = new Database();
		identities.Open(strFolder + "/player.identities." + 5 + ".db", true);
		if (!identities.TableExists("data"))
		{
			identities.Execute("CREATE TABLE data ( userid INT PRIMARY KEY, username TEXT )");
		}
		tokens = new Database();
		tokens.Open(strFolder + "/player.tokens.db", true);
		if (!tokens.TableExists("data"))
		{
			tokens.Execute("CREATE TABLE data ( userid INT PRIMARY KEY, token INT, locked BOOLEAN DEFAULT 0 )");
		}
		if (!tokens.ColumnExists("data", "locked"))
		{
			tokens.Execute("ALTER TABLE data ADD COLUMN locked BOOLEAN DEFAULT 0");
		}
		playerState = new Database();
		playerState.Open(strFolder + "/player.states." + 270 + ".db", true);
		if (!playerState.TableExists("data"))
		{
			playerState.Execute("CREATE TABLE data ( userid INT PRIMARY KEY, state BLOB )");
		}
		nameCache = new Dictionary<ulong, string>();
		tokenCache = new MruDictionary<ulong, (int, bool)>(500, (Action<ulong, (int, bool)>)null);
		wipeIdCache = new Dictionary<ulong, string>();
	}

	public virtual void Dispose()
	{
		if (blueprints != null)
		{
			blueprints.Close();
			blueprints = null;
		}
		if (deaths != null)
		{
			deaths.Close();
			deaths = null;
		}
		if (identities != null)
		{
			identities.Close();
			identities = null;
		}
		if (tokens != null)
		{
			tokens.Close();
			tokens = null;
		}
		if (playerState != null)
		{
			playerState.Close();
			playerState = null;
		}
	}

	public PersistantPlayer GetPlayerInfo(ulong playerID)
	{
		PersistantPlayer val = FetchFromDatabase(playerID);
		if (val == null)
		{
			val = Pool.Get<PersistantPlayer>();
		}
		if (val.unlockedItems == null)
		{
			val.unlockedItems = Pool.Get<List<int>>();
		}
		return val;
	}

	private PersistantPlayer FetchFromDatabase(ulong playerID)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			byte[] array = null;
			NexusPlayer player;
			Variable val = default(Variable);
			if (!NexusServer.Started)
			{
				array = blueprints.Query<byte[], ulong>("SELECT info FROM data WHERE userid = ?", playerID);
			}
			else if (NexusServer.TryGetPlayer(playerID, out player) && player.TryGetVariable(NexusVariables.Blueprints, ref val) && (int)val.Type == 0)
			{
				array = val.GetAsBinary();
			}
			if (array != null)
			{
				return PersistantPlayer.Deserialize(array);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Error loading player blueprints: (" + ex.Message + ")"));
		}
		return null;
	}

	public void SetPlayerInfo(ulong playerID, PersistantPlayer info)
	{
		TimeWarning val = TimeWarning.New("SetPlayerInfo", 0);
		try
		{
			TimeWarning val2 = TimeWarning.New("ToProtoBytes", 0);
			byte[] array;
			try
			{
				array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)info);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NexusPlayer player;
			if (!NexusServer.Started)
			{
				blueprints.Execute<ulong, byte[], int>("INSERT OR REPLACE INTO data ( userid, info, updated ) VALUES ( ?, ?, ? )", playerID, array, Epoch.Current);
			}
			else if (!NexusServer.TryGetPlayer(playerID, out player))
			{
				Debug.LogError((object)$"Couldn't find NexusPlayer to save player info! {playerID}");
			}
			else
			{
				player.SetVariable(NexusVariables.Blueprints, array, false, true);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void AddLifeStory(ulong playerID, PlayerLifeStory lifeStory)
	{
		if (deaths == null || lifeStory == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("AddLifeStory", 0);
		try
		{
			TimeWarning val2 = TimeWarning.New("ToProtoBytes", 0);
			byte[] array;
			try
			{
				array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)lifeStory);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			deaths.Execute<ulong, int, int, byte[]>("INSERT INTO data ( userid, born, died, info ) VALUES ( ?, ?, ?, ? )", playerID, (int)lifeStory.timeBorn, (int)lifeStory.timeDied, array);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public PlayerLifeStory GetLastLifeStory(ulong playerID)
	{
		if (deaths == null)
		{
			return null;
		}
		TimeWarning val = TimeWarning.New("GetLastLifeStory", 0);
		try
		{
			try
			{
				byte[] array = deaths.Query<byte[], ulong>("SELECT info FROM data WHERE userid = ? ORDER BY died DESC LIMIT 1", playerID);
				if (array == null)
				{
					return null;
				}
				PlayerLifeStory obj = PlayerLifeStory.Deserialize(array);
				obj.ShouldPool = false;
				return obj;
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Error loading lifestory from database: (" + ex.Message + ")"));
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool DoesPlayerExist(ulong steamId)
	{
		return GetPlayerName(steamId) != null;
	}

	public string GetPlayerName(ulong playerID)
	{
		if (playerID == 0L)
		{
			return null;
		}
		if (nameCache.TryGetValue(playerID, out var value))
		{
			return value;
		}
		string text = identities.Query<string, ulong>("SELECT username FROM data WHERE userid = ?", playerID);
		nameCache[playerID] = text;
		return text;
	}

	public void SetPlayerName(ulong playerID, string name)
	{
		if (playerID != 0L && !string.IsNullOrEmpty(name))
		{
			if (string.IsNullOrEmpty(GetPlayerName(playerID)))
			{
				identities.Execute<ulong, string>("INSERT INTO data ( userid, username ) VALUES ( ?, ? )", playerID, name);
			}
			else
			{
				identities.Execute<string, ulong>("UPDATE data SET username = ? WHERE userid = ?", name, playerID);
			}
			nameCache[playerID] = name;
		}
	}

	public void SetDefaultPlayerName(ulong playerID, string name)
	{
		if (string.IsNullOrEmpty(GetPlayerName(playerID)))
		{
			SetPlayerName(playerID, name);
		}
	}

	public int GetOrGenerateAppToken(ulong playerID, out bool locked)
	{
		if (tokens == null)
		{
			locked = false;
			return 0;
		}
		TimeWarning val = TimeWarning.New("GetOrGenerateAppToken", 0);
		try
		{
			(int, bool) tuple = default((int, bool));
			if (tokenCache.TryGetValue(playerID, ref tuple))
			{
				locked = tuple.Item2;
				return tuple.Item1;
			}
			int num = tokens.Query<int, ulong>("SELECT token FROM data WHERE userid = ?", playerID);
			if (num != 0)
			{
				bool flag = tokens.Query<int, ulong>("SELECT locked FROM data WHERE userid = ?", playerID) != 0;
				tokenCache.Add(playerID, (num, flag));
				locked = flag;
				return num;
			}
			int num2 = GenerateAppToken();
			tokens.Execute<ulong, int>("INSERT INTO data ( userid, token ) VALUES ( ?, ? )", playerID, num2);
			tokenCache.Add(playerID, (num2, false));
			locked = false;
			return num2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RegenerateAppToken(ulong playerID)
	{
		if (tokens == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("RegenerateAppToken", 0);
		try
		{
			tokenCache.Remove(playerID);
			bool flag = tokens.Query<int, ulong>("SELECT locked FROM data WHERE userid = ?", playerID) != 0;
			int num = GenerateAppToken();
			tokens.Execute<ulong, int, bool>("INSERT OR REPLACE INTO data ( userid, token, locked ) VALUES ( ?, ?, ? )", playerID, num, flag);
			tokenCache.Add(playerID, (num, false));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static int GenerateAppToken()
	{
		int num = Random.Range(int.MinValue, int.MaxValue);
		if (num == 0)
		{
			num++;
		}
		return num;
	}

	public bool SetAppTokenLocked(ulong playerID, bool locked)
	{
		if (tokens == null)
		{
			return false;
		}
		GetOrGenerateAppToken(playerID, out var locked2);
		if (locked2 == locked)
		{
			return false;
		}
		tokens.Execute<int, ulong>("UPDATE data SET locked = ? WHERE userid = ?", locked ? 1 : 0, playerID);
		tokenCache.Remove(playerID);
		return true;
	}

	public byte[] GetPlayerState(ulong playerID)
	{
		if (playerID == 0L)
		{
			return null;
		}
		return playerState.Query<byte[], ulong>("SELECT state FROM data WHERE userid = ?", playerID);
	}

	public void SetPlayerState(ulong playerID, byte[] state)
	{
		if (playerID != 0L && state != null)
		{
			playerState.Execute<ulong, byte[]>("INSERT OR REPLACE INTO data ( userid, state ) VALUES ( ?, ? )", playerID, state);
		}
	}

	public string GetUserWipeId(ulong playerID)
	{
		if (playerID <= 10000000)
		{
			return null;
		}
		if (wipeIdCache.TryGetValue(playerID, out var value))
		{
			return value;
		}
		value = StringEx.HexString(StringEx.Sha256(playerID + SaveRestore.WipeId));
		wipeIdCache[playerID] = value;
		Analytics.Azure.OnPlayerInitializedWipeId(playerID, value);
		return value;
	}

	public void ResetPlayerState(ulong playerID)
	{
		if (playerID != 0L)
		{
			playerState.Execute<ulong>("DELETE FROM data WHERE userid = ?", playerID);
		}
	}
}


using System;
using System.Net;
using Newtonsoft.Json;

[JsonModel]
public class IPAddressJsonConverter : JsonConverter
{
	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof(IPAddress);
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		string text = ((value is IPAddress iPAddress) ? iPAddress.ToString() : null);
		writer.WriteValue(text);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Invalid comparison between Unknown and I4
		if ((int)reader.TokenType != 9)
		{
			return null;
		}
		if (!IPAddress.TryParse((string)reader.Value, out IPAddress address))
		{
			return null;
		}
		return address;
	}
}


public class PremiumClientCache
{
}


using System.Collections.Generic;
using UnityEngine;

public static class AssetNameCache
{
	private static Dictionary<Object, string> mixed = new Dictionary<Object, string>();

	private static Dictionary<Object, string> lower = new Dictionary<Object, string>();

	private static Dictionary<Object, string> upper = new Dictionary<Object, string>();

	private static string LookupName(Object obj)
	{
		if (obj == (Object)null)
		{
			return string.Empty;
		}
		if (!mixed.TryGetValue(obj, out var value))
		{
			value = obj.name;
			mixed.Add(obj, value);
		}
		return value;
	}

	private static string LookupNameLower(Object obj)
	{
		if (obj == (Object)null)
		{
			return string.Empty;
		}
		if (!lower.TryGetValue(obj, out var value))
		{
			value = obj.name.ToLower();
			lower.Add(obj, value);
		}
		return value;
	}

	private static string LookupNameUpper(Object obj)
	{
		if (obj == (Object)null)
		{
			return string.Empty;
		}
		if (!upper.TryGetValue(obj, out var value))
		{
			value = obj.name.ToUpper();
			upper.Add(obj, value);
		}
		return value;
	}

	public static string GetName(this PhysicMaterial mat)
	{
		return LookupName((Object)(object)mat);
	}

	public static string GetNameLower(this PhysicMaterial mat)
	{
		return LookupNameLower((Object)(object)mat);
	}

	public static string GetNameUpper(this PhysicMaterial mat)
	{
		return LookupNameUpper((Object)(object)mat);
	}

	public static string GetName(this Material mat)
	{
		return LookupName((Object)(object)mat);
	}

	public static string GetNameLower(this Material mat)
	{
		return LookupNameLower((Object)(object)mat);
	}

	public static string GetNameUpper(this Material mat)
	{
		return LookupNameUpper((Object)(object)mat);
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Building Grade")]
public class BuildingGrade : ScriptableObject
{
	public enum Enum
	{
		None = -1,
		Twigs,
		Wood,
		Stone,
		Metal,
		TopTier,
		Count
	}

	public Enum type;

	public ulong skin;

	public bool enabledInStandalone;

	[Tooltip("Will bypass the inventory check if this is enabled, allowing anyone to craft this item, enabledInStandalone will still need to be true")]
	public bool alwaysUnlock;

	public float baseHealth;

	public List<ItemAmount> baseCost;

	public PhysicMaterial physicMaterial;

	public ProtectionProperties damageProtecton;

	public bool supportsColourChange;

	public BaseEntity.Menu.Option upgradeMenu;
}


public enum Enum
{
	None = -1,
	Twigs,
	Wood,
	Stone,
	Metal,
	TopTier,
	Count
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Sqlite;
using Ionic.Crc;
using ProtoBuf;
using UnityEngine.Assertions;

public class FileStorage : IDisposable
{
	private class CacheData
	{
		public byte[] data;

		public NetworkableId entityID;

		public uint numID;
	}

	public enum Type
	{
		png,
		jpg,
		ogg,
		sculpt
	}

	private class FileDatabase : Database
	{
		public IEnumerable<AssociatedFile> QueryAll(NetworkableId entityID)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			IntPtr intPtr = ((Database)this).Prepare("SELECT filetype, crc, part, data FROM data WHERE entid = ?");
			Database.Bind<ulong>(intPtr, 1, entityID.Value);
			return ((Database)this).ExecuteAndReadQueryResults<AssociatedFile>(intPtr, (Func<IntPtr, AssociatedFile>)ReadAssociatedFileRow);
		}

		private static AssociatedFile ReadAssociatedFileRow(IntPtr stmHandle)
		{
			AssociatedFile obj = Pool.Get<AssociatedFile>();
			obj.type = Database.GetColumnValue<int>(stmHandle, 0);
			obj.crc = (uint)Database.GetColumnValue<int>(stmHandle, 1);
			obj.numID = (uint)Database.GetColumnValue<int>(stmHandle, 2);
			obj.data = Database.GetColumnValue<byte[]>(stmHandle, 3);
			return obj;
		}
	}

	private FileDatabase db;

	private CRC32 crc = new CRC32();

	private MruDictionary<uint, CacheData> _cache = new MruDictionary<uint, CacheData>(1000, (Action<uint, CacheData>)null);

	public static FileStorage server = new FileStorage("sv.files." + 270, server: true);

	protected FileStorage(string name, bool server)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		if (server)
		{
			string text = Server.filesStorageFolder + "/" + name + ".db";
			db = new FileDatabase();
			((Database)db).Open(text, true);
			if (!((Database)db).TableExists("data"))
			{
				((Database)db).Execute("CREATE TABLE data ( crc INTEGER PRIMARY KEY, data BLOB, updated INTEGER, entid INTEGER, filetype INTEGER, part INTEGER )");
				((Database)db).Execute("CREATE INDEX IF NOT EXISTS entindex ON data ( entid )");
			}
		}
	}

	~FileStorage()
	{
		Dispose();
	}

	public void Dispose()
	{
		if (db != null)
		{
			((Database)db).Close();
			db = null;
		}
	}

	private uint GetCRC(byte[] data, Type type)
	{
		TimeWarning val = TimeWarning.New("FileStorage.GetCRC", 0);
		try
		{
			crc.Reset();
			crc.SlurpBlock(data, 0, data.Length);
			crc.UpdateCRC((byte)type);
			return (uint)crc.Crc32Result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public uint Store(byte[] data, Type type, NetworkableId entityID, uint numID = 0u)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.Store", 0);
		try
		{
			uint cRC = GetCRC(data, type);
			if (db != null)
			{
				((Database)db).Execute<int, byte[], long, int, int>("INSERT OR REPLACE INTO data ( crc, data, entid, filetype, part ) VALUES ( ?, ?, ?, ?, ? )", (int)cRC, data, (long)entityID.Value, (int)type, (int)numID);
			}
			_cache.Remove(cRC);
			_cache.Add(cRC, new CacheData
			{
				data = data,
				entityID = entityID,
				numID = numID
			});
			return cRC;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public byte[] Get(uint crc, Type type, NetworkableId entityID, uint numID = 0u)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.Get", 0);
		try
		{
			CacheData cacheData = default(CacheData);
			if (_cache.TryGetValue(crc, ref cacheData))
			{
				Assert.IsTrue(cacheData.data != null, "FileStorage cache contains a null texture");
				return cacheData.data;
			}
			if (db == null)
			{
				return null;
			}
			byte[] array = ((Database)db).Query<byte[], int, int, int, int>("SELECT data FROM data WHERE crc = ? AND filetype = ? AND entid = ? AND part = ? LIMIT 1", (int)crc, (int)type, (int)entityID.Value, (int)numID);
			if (array == null)
			{
				return null;
			}
			_cache.Remove(crc);
			_cache.Add(crc, new CacheData
			{
				data = array,
				entityID = entityID,
				numID = 0u
			});
			return array;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(uint crc, Type type, NetworkableId entityID)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.Remove", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<int, int, long>("DELETE FROM data WHERE crc = ? AND filetype = ? AND entid = ?", (int)crc, (int)type, (long)entityID.Value);
			}
			_cache.Remove(crc);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveExact(uint crc, Type type, NetworkableId entityID, uint numid)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.RemoveExact", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<int, int, long, int>("DELETE FROM data WHERE crc = ? AND filetype = ? AND entid = ? AND part = ?", (int)crc, (int)type, (long)entityID.Value, (int)numid);
			}
			_cache.Remove(crc);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveEntityNum(NetworkableId entityid, uint numid)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.RemoveEntityNum", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<long, int>("DELETE FROM data WHERE entid = ? AND part = ?", (long)entityid.Value, (int)numid);
			}
			uint[] array = (from x in (IEnumerable<KeyValuePair<uint, CacheData>>)_cache
				where x.Value.entityID == entityid && x.Value.numID == numid
				select x.Key).ToArray();
			foreach (uint num in array)
			{
				_cache.Remove(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveAllByEntity(NetworkableId entityid)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.RemoveAllByEntity", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<long>("DELETE FROM data WHERE entid = ?", (long)entityid.Value);
			}
			uint[] array = (from x in (IEnumerable<KeyValuePair<uint, CacheData>>)_cache
				where x.Value.entityID == entityid
				select x.Key).ToArray();
			foreach (uint num in array)
			{
				_cache.Remove(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ReassignEntityId(NetworkableId oldId, NetworkableId newId)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.ReassignEntityId", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<long, long>("UPDATE data SET entid = ? WHERE entid = ?", (long)newId.Value, (long)oldId.Value);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public IEnumerable<AssociatedFile> QueryAllByEntity(NetworkableId entityID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return db.QueryAll(entityID);
	}
}


private class CacheData
{
	public byte[] data;

	public NetworkableId entityID;

	public uint numID;
}


public enum Type
{
	png,
	jpg,
	ogg,
	sculpt
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Sqlite;
using ProtoBuf;

private class FileDatabase : Database
{
	public IEnumerable<AssociatedFile> QueryAll(NetworkableId entityID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		IntPtr intPtr = ((Database)this).Prepare("SELECT filetype, crc, part, data FROM data WHERE entid = ?");
		Database.Bind<ulong>(intPtr, 1, entityID.Value);
		return ((Database)this).ExecuteAndReadQueryResults<AssociatedFile>(intPtr, (Func<IntPtr, AssociatedFile>)ReadAssociatedFileRow);
	}

	private static AssociatedFile ReadAssociatedFileRow(IntPtr stmHandle)
	{
		AssociatedFile obj = Pool.Get<AssociatedFile>();
		obj.type = Database.GetColumnValue<int>(stmHandle, 0);
		obj.crc = (uint)Database.GetColumnValue<int>(stmHandle, 1);
		obj.numID = (uint)Database.GetColumnValue<int>(stmHandle, 2);
		obj.data = Database.GetColumnValue<byte[]>(stmHandle, 3);
		return obj;
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class GameManifest : ScriptableObject
{
	[Serializable]
	public struct PooledString
	{
		[HideInInspector]
		public string str;

		public uint hash;
	}

	[Serializable]
	public class PrefabProperties
	{
		[HideInInspector]
		public string name;

		public string guid;

		public uint hash;

		public bool pool;
	}

	[Serializable]
	public class EffectCategory
	{
		[HideInInspector]
		public string folder;

		public List<string> prefabs;
	}

	[Serializable]
	public class GuidPath
	{
		[HideInInspector]
		public string name;

		public string guid;
	}

	internal static GameManifest loadedManifest;

	public static Dictionary<string, string> guidToPath = new Dictionary<string, string>();

	public static Dictionary<string, string> pathToGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

	public static Dictionary<string, Object> guidToObject = new Dictionary<string, Object>();

	public PooledString[] pooledStrings;

	public PrefabProperties[] prefabProperties;

	public EffectCategory[] effectCategories;

	public GuidPath[] guidPaths;

	public string[] entities;

	public static GameManifest Current
	{
		get
		{
			if ((Object)(object)loadedManifest != (Object)null)
			{
				return loadedManifest;
			}
			Load();
			return loadedManifest;
		}
	}

	public static void Load()
	{
		if ((Object)(object)loadedManifest != (Object)null)
		{
			return;
		}
		loadedManifest = FileSystem.Load<GameManifest>("Assets/manifest.asset", true);
		PrefabProperties[] array = loadedManifest.prefabProperties;
		foreach (PrefabProperties prefabProperties in array)
		{
			guidToPath.Add(prefabProperties.guid, prefabProperties.name);
			pathToGuid.Add(prefabProperties.name, prefabProperties.guid);
		}
		GuidPath[] array2 = loadedManifest.guidPaths;
		foreach (GuidPath guidPath in array2)
		{
			if (!guidToPath.ContainsKey(guidPath.guid))
			{
				guidToPath.Add(guidPath.guid, guidPath.name);
				pathToGuid.Add(guidPath.name, guidPath.guid);
			}
		}
		DebugEx.Log((object)GetMetadataStatus(), (StackTraceLogType)0);
	}

	public static void LoadAssets()
	{
		if (Skinnable.All == null)
		{
			Skinnable.All = FileSystem.LoadAllFromBundle<Skinnable>("skinnables.preload.bundle", "t:Skinnable");
			if (Skinnable.All == null || Skinnable.All.Length == 0)
			{
				throw new Exception("Error loading skinnables");
			}
			DebugEx.Log((object)GetAssetStatus(), (StackTraceLogType)0);
		}
	}

	internal static Dictionary<string, string[]> LoadEffectDictionary()
	{
		EffectCategory[] array = loadedManifest.effectCategories;
		Dictionary<string, string[]> dictionary = new Dictionary<string, string[]>();
		EffectCategory[] array2 = array;
		foreach (EffectCategory effectCategory in array2)
		{
			dictionary.Add(effectCategory.folder, effectCategory.prefabs.ToArray());
		}
		return dictionary;
	}

	internal static string GUIDToPath(string guid)
	{
		if (string.IsNullOrEmpty(guid))
		{
			Debug.LogError((object)"GUIDToPath: guid is empty");
			return string.Empty;
		}
		Load();
		if (guidToPath.TryGetValue(guid, out var value))
		{
			return value;
		}
		Debug.LogWarning((object)("GUIDToPath: no path found for guid " + guid));
		return string.Empty;
	}

	internal static Object GUIDToObject(string guid)
	{
		Object value = null;
		if (guidToObject.TryGetValue(guid, out value))
		{
			return value;
		}
		string text = GUIDToPath(guid);
		if (string.IsNullOrEmpty(text))
		{
			Debug.LogWarning((object)("Missing file for guid " + guid));
			guidToObject.Add(guid, null);
			return null;
		}
		Object val = FileSystem.Load<Object>(text, true);
		guidToObject.Add(guid, val);
		return val;
	}

	public static void Invalidate(string path)
	{
		if (pathToGuid.TryGetValue(path, out var value) && guidToObject.TryGetValue(value, out var value2))
		{
			if (value2 != (Object)null)
			{
				Object.DestroyImmediate(value2, true);
			}
			guidToObject.Remove(value);
		}
	}

	private static string GetMetadataStatus()
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)loadedManifest != (Object)null)
		{
			stringBuilder.Append("Manifest Metadata Loaded");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.pooledStrings.Length.ToString());
			stringBuilder.Append(" pooled strings");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.prefabProperties.Length.ToString());
			stringBuilder.Append(" prefab properties");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.effectCategories.Length.ToString());
			stringBuilder.Append(" effect categories");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.entities.Length.ToString());
			stringBuilder.Append(" entity names");
			stringBuilder.AppendLine();
		}
		else
		{
			stringBuilder.Append("Manifest Metadata Missing");
		}
		return stringBuilder.ToString();
	}

	private static string GetAssetStatus()
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)loadedManifest != (Object)null)
		{
			stringBuilder.Append("Manifest Assets Loaded");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append((Skinnable.All != null) ? Skinnable.All.Length.ToString() : "0");
			stringBuilder.Append(" skinnable objects");
		}
		else
		{
			stringBuilder.Append("Manifest Assets Missing");
		}
		return stringBuilder.ToString();
	}
}


using System;
using UnityEngine;

[Serializable]
public struct PooledString
{
	[HideInInspector]
	public string str;

	public uint hash;
}


using System;
using UnityEngine;

[Serializable]
public class PrefabProperties
{
	[HideInInspector]
	public string name;

	public string guid;

	public uint hash;

	public bool pool;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class EffectCategory
{
	[HideInInspector]
	public string folder;

	public List<string> prefabs;
}


using System;
using UnityEngine;

[Serializable]
public class GuidPath
{
	[HideInInspector]
	public string name;

	public string guid;
}


using System;
using UnityEngine;

[Serializable]
public class HairDye
{
	public enum CopyProperty
	{
		DyeColor,
		RootColor,
		TipColor,
		Brightness,
		DyeRoughness,
		DyeScatter,
		Specular,
		Roughness,
		Count
	}

	[Flags]
	public enum CopyPropertyMask
	{
		DyeColor = 1,
		RootColor = 2,
		TipColor = 4,
		Brightness = 8,
		DyeRoughness = 0x10,
		DyeScatter = 0x20,
		Specular = 0x40,
		Roughness = 0x80
	}

	[ColorUsage(false, true)]
	public Color capBaseColor;

	public Material sourceMaterial;

	[InspectorFlags]
	public CopyPropertyMask copyProperties;

	private static MaterialPropertyDesc[] transferableProps = new MaterialPropertyDesc[8]
	{
		new MaterialPropertyDesc("_DyeColor", typeof(Color)),
		new MaterialPropertyDesc("_RootColor", typeof(Color)),
		new MaterialPropertyDesc("_TipColor", typeof(Color)),
		new MaterialPropertyDesc("_Brightness", typeof(float)),
		new MaterialPropertyDesc("_DyeRoughness", typeof(float)),
		new MaterialPropertyDesc("_DyeScatter", typeof(float)),
		new MaterialPropertyDesc("_HairSpecular", typeof(float)),
		new MaterialPropertyDesc("_HairRoughness", typeof(float))
	};

	public static int _HairBaseColorUV1 = Shader.PropertyToID("_HairBaseColorUV1");

	public static int _HairBaseColorUV2 = Shader.PropertyToID("_HairBaseColorUV2");

	public static int _HairPackedMapUV1 = Shader.PropertyToID("_HairPackedMapUV1");

	public static int _HairPackedMapUV2 = Shader.PropertyToID("_HairPackedMapUV2");

	public void Apply(HairDyeCollection collection, MaterialPropertyBlock block)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)sourceMaterial != (Object)null))
		{
			return;
		}
		for (int i = 0; i < 8; i++)
		{
			if (((uint)copyProperties & (uint)(1 << i)) == 0)
			{
				continue;
			}
			MaterialPropertyDesc materialPropertyDesc = transferableProps[i];
			if (sourceMaterial.HasProperty(materialPropertyDesc.nameID))
			{
				if (materialPropertyDesc.type == typeof(Color))
				{
					block.SetColor(materialPropertyDesc.nameID, sourceMaterial.GetColor(materialPropertyDesc.nameID));
				}
				else if (materialPropertyDesc.type == typeof(float))
				{
					block.SetFloat(materialPropertyDesc.nameID, sourceMaterial.GetFloat(materialPropertyDesc.nameID));
				}
			}
		}
	}

	public void ApplyCap(HairDyeCollection collection, HairType type, MaterialPropertyBlock block)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (collection.applyCap)
		{
			switch (type)
			{
			case HairType.Head:
			case HairType.Armpit:
			case HairType.Pubic:
				block.SetColor(_HairBaseColorUV1, ((Color)(ref capBaseColor)).gamma);
				block.SetTexture(_HairPackedMapUV1, (Texture)(((Object)(object)collection.capMask != (Object)null) ? ((object)collection.capMask) : ((object)Texture2D.blackTexture)));
				break;
			case HairType.Facial:
				block.SetColor(_HairBaseColorUV2, ((Color)(ref capBaseColor)).gamma);
				block.SetTexture(_HairPackedMapUV2, (Texture)(((Object)(object)collection.capMask != (Object)null) ? ((object)collection.capMask) : ((object)Texture2D.blackTexture)));
				break;
			}
		}
	}
}


public enum CopyProperty
{
	DyeColor,
	RootColor,
	TipColor,
	Brightness,
	DyeRoughness,
	DyeScatter,
	Specular,
	Roughness,
	Count
}


using System;

[Flags]
public enum CopyPropertyMask
{
	DyeColor = 1,
	RootColor = 2,
	TipColor = 4,
	Brightness = 8,
	DyeRoughness = 0x10,
	DyeScatter = 0x20,
	Specular = 0x40,
	Roughness = 0x80
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Hair Dye Collection")]
public class HairDyeCollection : ScriptableObject
{
	public Texture capMask;

	public bool applyCap;

	public HairDye[] Variations;

	public HairDye Get(float seed)
	{
		if (Variations.Length != 0)
		{
			return Variations[Mathf.Clamp(Mathf.FloorToInt(seed * (float)Variations.Length), 0, Variations.Length - 1)];
		}
		return null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Hair Set")]
public class HairSet : ScriptableObject
{
	[Serializable]
	public class MeshReplace
	{
		[HideInInspector]
		public string FindName;

		public Mesh Find;

		public Mesh[] ReplaceShapes;

		public bool Test(string materialName)
		{
			return FindName == materialName;
		}
	}

	public MeshReplace[] MeshReplacements;

	public void Process(PlayerModelHair playerModelHair, HairDyeCollection dyeCollection, HairDye dye, MaterialPropertyBlock block)
	{
		List<SkinnedMeshRenderer> list = Pool.Get<List<SkinnedMeshRenderer>>();
		((Component)playerModelHair).gameObject.GetComponentsInChildren<SkinnedMeshRenderer>(true, list);
		foreach (SkinnedMeshRenderer item in list)
		{
			if (!((Object)(object)item.sharedMesh == (Object)null) && !((Object)(object)((Renderer)item).sharedMaterial == (Object)null))
			{
				string name = ((Object)item.sharedMesh).name;
				_ = ((Object)((Renderer)item).sharedMaterial).name;
				if (!((Component)item).gameObject.activeSelf)
				{
					((Component)item).gameObject.SetActive(true);
				}
				for (int i = 0; i < MeshReplacements.Length; i++)
				{
					MeshReplacements[i].Test(name);
				}
				if (dye != null && ((Component)item).gameObject.activeSelf)
				{
					dye.Apply(dyeCollection, block);
				}
			}
		}
		Pool.FreeUnmanaged<SkinnedMeshRenderer>(ref list);
	}

	public void ProcessMorphs(GameObject obj, int blendShapeIndex = -1)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class MeshReplace
{
	[HideInInspector]
	public string FindName;

	public Mesh Find;

	public Mesh[] ReplaceShapes;

	public bool Test(string materialName)
	{
		return FindName == materialName;
	}
}


using System;

[Serializable]
public enum HairType
{
	Head,
	Eyebrow,
	Facial,
	Armpit,
	Pubic,
	Count
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Hair Set Collection")]
public class HairSetCollection : ScriptableObject
{
	[Serializable]
	public struct HairSetEntry
	{
		public HairSet HairSet;

		public GameObjectRef HairPrefab;

		public HairDyeCollection HairDyeCollection;
	}

	public HairSetEntry[] Head;

	public HairSetEntry[] Eyebrow;

	public HairSetEntry[] Facial;

	public HairSetEntry[] Armpit;

	public HairSetEntry[] Pubic;

	public HairSetEntry[] GetListByType(HairType hairType)
	{
		return hairType switch
		{
			HairType.Head => Head, 
			HairType.Eyebrow => Eyebrow, 
			HairType.Facial => Facial, 
			HairType.Armpit => Armpit, 
			HairType.Pubic => Pubic, 
			_ => null, 
		};
	}

	public int GetIndex(HairSetEntry[] list, float typeNum)
	{
		return Mathf.Clamp(Mathf.FloorToInt(typeNum * (float)list.Length), 0, list.Length - 1);
	}

	public int GetIndex(HairType hairType, float typeNum)
	{
		HairSetEntry[] listByType = GetListByType(hairType);
		return GetIndex(listByType, typeNum);
	}

	public HairSetEntry Get(HairType hairType, float typeNum)
	{
		HairSetEntry[] listByType = GetListByType(hairType);
		return listByType[GetIndex(listByType, typeNum)];
	}
}


using System;

[Serializable]
public struct HairSetEntry
{
	public HairSet HairSet;

	public GameObjectRef HairPrefab;

	public HairDyeCollection HairDyeCollection;
}


using Rust.Workshop;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skins/ItemSkin")]
public class ItemSkin : SteamInventoryItem
{
	public Skinnable Skinnable;

	public Material[] Materials;

	[Tooltip("If set, whenever we make an item with this skin, we'll spawn this item without a skin instead")]
	public ItemDefinition Redirect;

	public bool UnlockedByDefault;

	public void ApplySkin(GameObject obj)
	{
		if (!((Object)(object)Skinnable == (Object)null))
		{
			Skin.Apply(obj, Skinnable, Materials);
		}
	}

	public override bool HasUnlocked(ulong playerId)
	{
		if (UnlockedByDefault)
		{
			return true;
		}
		if ((Object)(object)Redirect != (Object)null && (Object)(object)Redirect.isRedirectOf != (Object)null && (Object)(object)Redirect.isRedirectOf.steamItem != (Object)null)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(playerId);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.blueprints.CheckSkinOwnership(Redirect.isRedirectOf.steamItem.id, basePlayer.userID))
			{
				return true;
			}
		}
		return base.HasUnlocked(playerId);
	}
}


using System;
using System.Linq;
using UnityEngine;

public class ItemSkinDirectory : ScriptableObject
{
	[Serializable]
	public struct Skin
	{
		public int id;

		public int itemid;

		public string name;

		public bool isSkin;

		private SteamInventoryItem _invItem;

		public SteamInventoryItem invItem
		{
			get
			{
				if ((Object)(object)_invItem == (Object)null && !string.IsNullOrEmpty(name))
				{
					_invItem = FileSystem.Load<SteamInventoryItem>(name, true);
				}
				return _invItem;
			}
		}
	}

	private static ItemSkinDirectory _Instance;

	public Skin[] skins;

	public static ItemSkinDirectory Instance
	{
		get
		{
			if ((Object)(object)_Instance == (Object)null)
			{
				_Instance = FileSystem.Load<ItemSkinDirectory>("assets/skins.asset", true);
				if ((Object)(object)_Instance == (Object)null)
				{
					throw new Exception("Couldn't load assets/skins.asset");
				}
				if (_Instance.skins == null || _Instance.skins.Length == 0)
				{
					throw new Exception("Loaded assets/skins.asset but something is wrong");
				}
			}
			return _Instance;
		}
	}

	public static Skin[] ForItem(ItemDefinition item)
	{
		return Instance.skins.Where((Skin x) => x.isSkin && x.itemid == item.itemid).ToArray();
	}

	public static Skin FindByInventoryDefinitionId(int id)
	{
		return Instance.skins.Where((Skin x) => x.id == id).FirstOrDefault();
	}

	public static bool TryGetItemFromDefinitionID(int id, out ItemDefinition result)
	{
		result = null;
		Skin skin = FindByInventoryDefinitionId(id);
		if ((Object)(object)skin.invItem != (Object)null)
		{
			result = skin.invItem.itemDefinition;
			if (skin.invItem is ItemSkin itemSkin && (Object)(object)itemSkin.Redirect != (Object)null)
			{
				result = itemSkin.Redirect;
			}
		}
		return (Object)(object)result != (Object)null;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Skin
{
	public int id;

	public int itemid;

	public string name;

	public bool isSkin;

	private SteamInventoryItem _invItem;

	public SteamInventoryItem invItem
	{
		get
		{
			if ((Object)(object)_invItem == (Object)null && !string.IsNullOrEmpty(name))
			{
				_invItem = FileSystem.Load<SteamInventoryItem>(name, true);
			}
			return _invItem;
		}
	}
}


using System;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Loot Spawn")]
public class LootSpawn : ScriptableObject
{
	[Serializable]
	public struct Entry
	{
		[Tooltip("If this category is chosen, we will spawn 1+ this amount")]
		public int extraSpawns;

		[Tooltip("If a subcategory exists we'll choose from there instead of any items specified")]
		public LootSpawn category;

		[Tooltip("The higher this number, the more likely this will be chosen")]
		public int weight;

		[Tooltip("Adding eras to this list will restrict the loot table to only work in these eras")]
		public Era[] restrictedEras;

		public int RuntimeWeightBonus()
		{
			return (BaseGameMode.GetActiveGameMode(serverside: true)?.GetLootWeightModifier(GetWeightBonusItem())).GetValueOrDefault();
		}

		public ItemDefinition GetWeightBonusItem()
		{
			if (category.allowedItems.Length == 1)
			{
				return category.allowedItems[0].itemDef;
			}
			return null;
		}
	}

	public ItemAmountRanged[] items;

	public Entry[] subSpawn;

	[NonSerialized]
	private Entry[] allowedSubSpawn;

	[NonSerialized]
	private ItemAmountRanged[] allowedItems;

	private Era era;

	private uint lastGameModeFilterApplied;

	public bool HasAnySpawns()
	{
		EnsureFilterUpdated();
		if (allowedSubSpawn.Length == 0)
		{
			return allowedItems.Length != 0;
		}
		return true;
	}

	public void ClearCache()
	{
		allowedItems = null;
		allowedSubSpawn = null;
		if (subSpawn != null)
		{
			Entry[] array = subSpawn;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].category?.ClearCache();
			}
		}
	}

	private void EnsureFilterUpdated()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool num = era != ConVar.Server.Era;
		bool flag = lastGameModeFilterApplied != BaseGameMode.GetActiveGameModeId(serverside: true);
		if (!num && !flag && allowedSubSpawn != null)
		{
			return;
		}
		era = ConVar.Server.Era;
		lastGameModeFilterApplied = BaseGameMode.GetActiveGameModeId(serverside: true);
		Entry[] array = subSpawn;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].category.EnsureFilterUpdated();
		}
		if (subSpawn == null || subSpawn.Length == 0)
		{
			allowedSubSpawn = Array.Empty<Entry>();
		}
		else
		{
			allowedSubSpawn = subSpawn.Where((Entry x) => x.category.HasAnySpawns() && (x.restrictedEras == null || x.restrictedEras.Length == 0 || Array.IndexOf(x.restrictedEras, ConVar.Server.Era) != -1)).ToArray();
		}
		if (items == null || items.Length == 0)
		{
			allowedItems = Array.Empty<ItemAmountRanged>();
			return;
		}
		allowedItems = items.Where((ItemAmountRanged x) => x.itemDef.IsAllowed((EraRestriction)2)).ToArray();
	}

	public ItemDefinition GetBlueprintBaseDef()
	{
		return ItemManager.FindItemDefinition("blueprintbase");
	}

	public void SpawnIntoContainer(ItemContainer container, ItemOwnershipShare ownership = default(ItemOwnershipShare), ItemContainer fallbackContainer = null)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		EnsureFilterUpdated();
		if (allowedSubSpawn != null && allowedSubSpawn.Length != 0)
		{
			SubCategoryIntoContainer(container, ownership, fallbackContainer);
		}
		else
		{
			if (allowedItems == null)
			{
				return;
			}
			ItemAmountRanged[] array = allowedItems;
			foreach (ItemAmountRanged itemAmountRanged in array)
			{
				if (itemAmountRanged == null)
				{
					continue;
				}
				Item item = null;
				if (itemAmountRanged.itemDef.spawnAsBlueprint)
				{
					ItemDefinition blueprintBaseDef = GetBlueprintBaseDef();
					if ((Object)(object)blueprintBaseDef == (Object)null)
					{
						continue;
					}
					Item item2 = ItemManager.Create(blueprintBaseDef, 1, 0uL);
					item2.blueprintTarget = itemAmountRanged.itemDef.itemid;
					item = item2;
				}
				else
				{
					item = ItemManager.CreateByItemID(itemAmountRanged.itemid, (int)itemAmountRanged.GetAmount(), 0uL);
				}
				if (item == null)
				{
					continue;
				}
				item.OnVirginSpawn();
				if (ownership.IsValid())
				{
					item.SetItemOwnership(ownership.username, ownership.reason);
				}
				if (!item.MoveToContainer(container) && (fallbackContainer == null || !item.MoveToContainer(fallbackContainer)))
				{
					if (Object.op_Implicit((Object)(object)container.playerOwner))
					{
						item.Drop(container.playerOwner.GetDropPosition(), container.playerOwner.GetDropVelocity());
					}
					else
					{
						item.Remove();
					}
				}
			}
		}
	}

	private void SubCategoryIntoContainer(ItemContainer container, ItemOwnershipShare ownership = default(ItemOwnershipShare), ItemContainer fallbackContainer = null)
	{
		int num = allowedSubSpawn.Sum((Entry x) => x.weight + x.RuntimeWeightBonus());
		int num2 = Random.Range(0, num);
		for (int i = 0; i < allowedSubSpawn.Length; i++)
		{
			if ((Object)(object)allowedSubSpawn[i].category == (Object)null)
			{
				continue;
			}
			num -= allowedSubSpawn[i].weight + allowedSubSpawn[i].RuntimeWeightBonus();
			if (num2 >= num)
			{
				for (int j = 0; j < 1 + allowedSubSpawn[i].extraSpawns; j++)
				{
					allowedSubSpawn[i].category.SpawnIntoContainer(container, ownership, fallbackContainer);
				}
				return;
			}
		}
		string text = (((Object)(object)container.entityOwner != (Object)null) ? ((Object)container.entityOwner).name : "Unknown");
		Debug.LogWarning((object)$"SubCategoryIntoContainer for loot '{((Object)this).name}' for entity '{text}' ended with randomWeight ({num2}) < totalWeight ({num}). This should never happen! ", (Object)(object)this);
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public struct Entry
{
	[Tooltip("If this category is chosen, we will spawn 1+ this amount")]
	public int extraSpawns;

	[Tooltip("If a subcategory exists we'll choose from there instead of any items specified")]
	public LootSpawn category;

	[Tooltip("The higher this number, the more likely this will be chosen")]
	public int weight;

	[Tooltip("Adding eras to this list will restrict the loot table to only work in these eras")]
	public Era[] restrictedEras;

	public int RuntimeWeightBonus()
	{
		return (BaseGameMode.GetActiveGameMode(serverside: true)?.GetLootWeightModifier(GetWeightBonusItem())).GetValueOrDefault();
	}

	public ItemDefinition GetWeightBonusItem()
	{
		if (category.allowedItems.Length == 1)
		{
			return category.allowedItems[0].itemDef;
		}
		return null;
	}
}


using System;
using UnityEngine;

public static class MapImageRenderer
{
	private readonly struct Array2D<T>
	{
		private readonly T[] _items;

		private readonly int _width;

		private readonly int _height;

		public ref T this[int x, int y]
		{
			get
			{
				int num = Mathf.Clamp(x, 0, _width - 1);
				int num2 = Mathf.Clamp(y, 0, _height - 1);
				return ref _items[num2 * _width + num];
			}
		}

		public Array2D(T[] items, int width, int height)
		{
			_items = items;
			_width = width;
			_height = height;
		}
	}

	private static readonly Vector4 StartColor = new Vector4(0.28627452f, 23f / 85f, 0.24705884f, 1f);

	private static readonly Vector4 WaterColor = new Vector4(0.16941601f, 0.31755757f, 0.36200002f, 1f);

	private static readonly Vector4 GravelColor = new Vector4(0.25f, 37f / 152f, 0.22039475f, 1f);

	private static readonly Vector4 DirtColor = new Vector4(0.6f, 0.47959462f, 0.33f, 1f);

	private static readonly Vector4 SandColor = new Vector4(0.7f, 0.65968585f, 0.5277487f, 1f);

	private static readonly Vector4 GrassColor = new Vector4(0.35486364f, 0.37f, 0.2035f, 1f);

	private static readonly Vector4 ForestColor = new Vector4(0.24843751f, 0.3f, 9f / 128f, 1f);

	private static readonly Vector4 RockColor = new Vector4(0.4f, 0.39379844f, 0.37519377f, 1f);

	private static readonly Vector4 SnowColor = new Vector4(0.86274517f, 0.9294118f, 0.94117653f, 1f);

	private static readonly Vector4 PebbleColor = new Vector4(7f / 51f, 0.2784314f, 0.2761563f, 1f);

	private static readonly Vector4 OffShoreColor = new Vector4(0.04090196f, 0.22060032f, 14f / 51f, 1f);

	private static readonly Vector3 SunDirection = Vector3.Normalize(new Vector3(0.95f, 2.87f, 2.37f));

	private const float SunPower = 0.65f;

	private const float Brightness = 1.05f;

	private const float Contrast = 0.94f;

	private const float OceanWaterLevel = 0f;

	private static readonly Vector4 Half = new Vector4(0.5f, 0.5f, 0.5f, 0.5f);

	public static byte[] Render(out int imageWidth, out int imageHeight, out Color background, float scale = 0.5f, bool lossy = true, bool transparent = false, int oceanMargin = 500)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		if (lossy && transparent)
		{
			throw new ArgumentException("Rendering a transparent map is not possible when using lossy compression (JPG)");
		}
		imageWidth = 0;
		imageHeight = 0;
		background = Color.op_Implicit(OffShoreColor);
		TerrainTexturing instance = TerrainTexturing.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			return null;
		}
		Terrain component = ((Component)instance).GetComponent<Terrain>();
		TerrainMeta component2 = ((Component)instance).GetComponent<TerrainMeta>();
		TerrainHeightMap terrainHeightMap = ((Component)instance).GetComponent<TerrainHeightMap>();
		TerrainSplatMap terrainSplatMap = ((Component)instance).GetComponent<TerrainSplatMap>();
		TerrainTopologyMap terrainTopologyMap = ((Component)instance).GetComponent<TerrainTopologyMap>();
		if ((Object)(object)component == (Object)null || (Object)(object)component2 == (Object)null || (Object)(object)terrainHeightMap == (Object)null || (Object)(object)terrainSplatMap == (Object)null || (Object)(object)terrainTopologyMap == (Object)null)
		{
			return null;
		}
		int mapRes = (int)((float)World.Size * Mathf.Clamp(scale, 0.1f, 4f));
		float invMapRes = 1f / (float)mapRes;
		if (mapRes <= 0)
		{
			return null;
		}
		imageWidth = mapRes + oceanMargin * 2;
		imageHeight = mapRes + oceanMargin * 2;
		Color[] array = (Color[])(object)new Color[imageWidth * imageHeight];
		Array2D<Color> output = new Array2D<Color>(array, imageWidth, imageHeight);
		float maxDepth = (transparent ? Mathf.Max(Mathf.Abs(GetHeight(0f, 0f)), 5f) : 50f);
		Vector4 offShoreColor = (transparent ? Vector4.zero : OffShoreColor);
		Vector4 waterColor = (Vector4)(transparent ? new Vector4(WaterColor.x, WaterColor.y, WaterColor.z, 0.5f) : WaterColor);
		Parallel.For(0, imageHeight, (Action<int>)delegate(int y)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0157: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_0231: Unknown result type (might be due to invalid IL or missing references)
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_0243: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			//IL_024d: Unknown result type (might be due to invalid IL or missing references)
			//IL_024f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0251: Unknown result type (might be due to invalid IL or missing references)
			//IL_0256: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Unknown result type (might be due to invalid IL or missing references)
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_026a: Unknown result type (might be due to invalid IL or missing references)
			//IL_026f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0206: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_020b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0228: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0278: Unknown result type (might be due to invalid IL or missing references)
			//IL_027d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02be: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02df: Unknown result type (might be due to invalid IL or missing references)
			y -= oceanMargin;
			float y2 = (float)y * invMapRes;
			int num = mapRes + oceanMargin;
			for (int i = -oceanMargin; i < num; i++)
			{
				float x2 = (float)i * invMapRes;
				Vector4 startColor = StartColor;
				float num2 = GetHeight(x2, y2);
				Vector3 val = GetNormal(x2, y2);
				float num3 = GetShoreDist(x2, y2);
				bool flag = (GetTopology(x2, y2) & 0x180) != 0;
				float num4 = Math.Max(Vector3.Dot(val, SunDirection), 0f);
				startColor = Vector4.Lerp(startColor, GravelColor, GetSplat(x2, y2, 128) * GravelColor.w);
				startColor = Vector4.Lerp(startColor, PebbleColor, GetSplat(x2, y2, 64) * PebbleColor.w);
				startColor = Vector4.Lerp(startColor, RockColor, GetSplat(x2, y2, 8) * RockColor.w);
				startColor = Vector4.Lerp(startColor, DirtColor, GetSplat(x2, y2, 1) * DirtColor.w);
				startColor = Vector4.Lerp(startColor, GrassColor, GetSplat(x2, y2, 16) * GrassColor.w);
				startColor = Vector4.Lerp(startColor, ForestColor, GetSplat(x2, y2, 32) * ForestColor.w);
				startColor = Vector4.Lerp(startColor, SandColor, GetSplat(x2, y2, 4) * SandColor.w);
				startColor = Vector4.Lerp(startColor, SnowColor, GetSplat(x2, y2, 2) * SnowColor.w);
				float num5 = 0f;
				if (num3 > 0f)
				{
					num5 = 0f - num2;
					if (num5 <= 0f || !flag)
					{
						num5 = Mathf.Max(num5, 0.1f * num3);
					}
				}
				if (num5 > 0f)
				{
					startColor = Vector4.Lerp(startColor, waterColor, Mathf.Clamp(0.5f + num5 / 5f, 0f, 1f));
					startColor = Vector4.Lerp(startColor, offShoreColor, Mathf.Clamp(num5 / maxDepth, 0f, 1f));
				}
				else
				{
					startColor += (num4 - 0.5f) * 0.65f * startColor;
					startColor = (startColor - Half) * 0.94f + Half;
				}
				startColor *= 1.05f;
				output[i + oceanMargin, y + oceanMargin] = (transparent ? new Color(startColor.x, startColor.y, startColor.z, startColor.w) : new Color(startColor.x, startColor.y, startColor.z));
			}
		});
		background = output[0, 0];
		return EncodeToFile(imageWidth, imageHeight, array, lossy);
		float GetHeight(float x, float y)
		{
			return terrainHeightMap.GetHeight(x, y);
		}
		Vector3 GetNormal(float x, float y)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			return terrainHeightMap.GetNormal(x, y);
		}
		static float GetShoreDist(float x, float y)
		{
			return TerrainTexturing.Instance.GetCoarseVectorToShore(x, y).shoreDist;
		}
		float GetSplat(float x, float y, int mask)
		{
			return terrainSplatMap.GetSplat(x, y, mask);
		}
		int GetTopology(float x, float y)
		{
			return terrainTopologyMap.GetTopology(x, y, 16f);
		}
	}

	private static byte[] EncodeToFile(int width, int height, Color[] pixels, bool lossy)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Expected O, but got Unknown
		Texture2D val = null;
		try
		{
			val = new Texture2D(width, height, (TextureFormat)4, false);
			val.SetPixels(pixels);
			val.Apply();
			return lossy ? ImageConversion.EncodeToJPG(val, 85) : ImageConversion.EncodeToPNG(val);
		}
		finally
		{
			if ((Object)(object)val != (Object)null)
			{
				Object.Destroy((Object)(object)val);
			}
		}
	}

	private static Vector3 UnpackNormal(Vector4 value)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		value.x *= value.w;
		Vector3 val = default(Vector3);
		val.x = value.x * 2f - 1f;
		val.y = value.y * 2f - 1f;
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(val.x, val.y);
		val.z = Mathf.Sqrt(1f - Mathf.Clamp(Vector2.Dot(val2, val2), 0f, 1f));
		return val;
	}
}


using UnityEngine;

private readonly struct Array2D<T>
{
	private readonly T[] _items;

	private readonly int _width;

	private readonly int _height;

	public ref T this[int x, int y]
	{
		get
		{
			int num = Mathf.Clamp(x, 0, _width - 1);
			int num2 = Mathf.Clamp(y, 0, _height - 1);
			return ref _items[num2 * _width + num];
		}
	}

	public Array2D(T[] items, int width, int height)
	{
		_items = items;
		_width = width;
		_height = height;
	}
}


using Development.Attributes;
using Facepunch;
using UnityEngine;

[ResetStaticFields]
public static class NameHelper
{
	public static string FilterGenericName(string name)
	{
		return name;
	}

	public static string Get(ulong userId, string name, bool isClient = true, bool forceFriendly = false)
	{
		return name;
	}

	public static string Get(IPlayerInfo playerInfo, bool isClient = true)
	{
		return Get(playerInfo.UserId, playerInfo.UserName, isClient);
	}

	public static string GetPlayerNameStreamSafe(BasePlayer from, BasePlayer target)
	{
		if ((Object)(object)from == (Object)null || (Object)(object)target == (Object)null)
		{
			return string.Empty;
		}
		if (!from.net.connection.info.GetBool("global.streamermode", false))
		{
			return target.displayName;
		}
		return RandomUsernames.Get((ulong)target.userID);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Nexus.Models;
using UnityEngine;

public static class NexusUtil
{
	private static readonly char[] ScheduleSeparators = new char[1] { ',' };

	public static bool TryParseFerrySchedule(string zone, string scheduleString, out string[] entries)
	{
		if (string.IsNullOrWhiteSpace(zone) || string.IsNullOrWhiteSpace(scheduleString))
		{
			entries = null;
			return false;
		}
		string[] array = scheduleString.Split(ScheduleSeparators, StringSplitOptions.RemoveEmptyEntries);
		if (!array.Contains<string>(zone, StringComparer.InvariantCultureIgnoreCase))
		{
			Array.Resize(ref array, array.Length + 1);
			Array.Copy(array, 0, array, 1, array.Length - 1);
			array[0] = zone;
		}
		if (array.Length <= 1)
		{
			Debug.LogWarning((object)("Ferry schedule for '" + zone + "' needs at least two zones in it: " + scheduleString));
			entries = null;
			return false;
		}
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = array[i].Trim();
			string text = array[i];
			if (string.IsNullOrWhiteSpace(text))
			{
				Debug.LogWarning((object)("Ferry schedule for '" + zone + "' has empty entries: " + scheduleString));
				entries = null;
				return false;
			}
			string b = ((i == 0) ? array[^1] : array[i - 1]);
			if (string.Equals(text, b, StringComparison.InvariantCultureIgnoreCase))
			{
				Debug.LogWarning((object)("Ferry schedule for '" + zone + "' has the same zone twice in a row: " + scheduleString));
				entries = null;
				return false;
			}
		}
		entries = array;
		return true;
	}

	public static string ConnectionProtocol(this NexusZoneDetails zone)
	{
		if (zone == null || !zone.Variables.TryGetString("protocol", out var value))
		{
			return "";
		}
		return value ?? "";
	}

	public static bool IsStarterZone(this ZoneDetails zone)
	{
		return ((zone != null) ? zone.Variables : null).IsStarterZone();
	}

	public static bool IsStarterZone(this NexusZoneDetails zone)
	{
		return ((zone != null) ? zone.Variables : null).IsStarterZone();
	}

	private static bool IsStarterZone(this VariableDictionary variables)
	{
		string value;
		bool result = default(bool);
		return variables.TryGetString("starterZone", out value) && bool.TryParse(value, out result) && result;
	}

	public static bool TryGetString(this VariableDictionary variables, string key, out string value)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (variables != null && ((Dictionary<string, VariableData>)(object)variables).TryGetValue(key, out VariableData value2) && (int)((VariableData)(ref value2)).Type == 1 && !string.IsNullOrWhiteSpace(((VariableData)(ref value2)).Value))
		{
			value = ((VariableData)(ref value2)).Value;
			return true;
		}
		value = null;
		return false;
	}
}


using System;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Player/Player Bone Pos Data", fileName = "Player Bone Pos Data")]
public class PlayerBonePosData : ScriptableObject
{
	[Serializable]
	public class BonePosData
	{
		public AnimationClip sourceAnim;

		public float animStartTime;

		public Vector3 rootRotationOffset;

		[ReadOnly]
		public Vector3[] bonePositions;

		[ReadOnly]
		public Quaternion[] boneRotations;
	}

	public SkeletonDefinition skeletonDef;

	public GameObjectRef playerModel;

	[ReadOnly]
	public string[] boneNames;

	public BonePosData crawling;

	public BonePosData ducking;

	public BonePosData incapacitated;

	public BonePosData onladder;

	public BonePosData sleeping;

	public BonePosData standing;

	public BonePosData swimming;

	public BonePosData[] mountedPoses;

	public BonePosData GetBonePositionData(BasePlayer.PlayerFlags flagsOnDeath, ModelState modelState)
	{
		if (flagsOnDeath.HasFlag(BasePlayer.PlayerFlags.Sleeping))
		{
			return sleeping;
		}
		if (flagsOnDeath.HasFlag(BasePlayer.PlayerFlags.Incapacitated))
		{
			return incapacitated;
		}
		if (flagsOnDeath.HasFlag(BasePlayer.PlayerFlags.Wounded))
		{
			return crawling;
		}
		if (modelState.onLadder)
		{
			return onladder;
		}
		if (modelState.ducked)
		{
			return ducking;
		}
		if (modelState.waterLevel >= 0.75f)
		{
			return swimming;
		}
		if (modelState.mounted)
		{
			if (modelState.poseType < mountedPoses.Length)
			{
				return mountedPoses[modelState.poseType];
			}
			if (modelState.poseType == 128)
			{
				return standing;
			}
			Debug.LogWarning((object)$"PlayerCorpse GetBonePositionData: No saved bone position data for mount pose {modelState.poseType}. Falling back to SitGeneric. Please update the 'Server Side Ragdoll Bone Pos Data' file with the new mount pose.");
			return mountedPoses[7];
		}
		return standing;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BonePosData
{
	public AnimationClip sourceAnim;

	public float animStartTime;

	public Vector3 rootRotationOffset;

	[ReadOnly]
	public Vector3[] bonePositions;

	[ReadOnly]
	public Quaternion[] boneRotations;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Player/Player Inventory Properties")]
public class PlayerInventoryProperties : BaseScriptableObject
{
	[Serializable]
	public class ItemAmountSkinned : ItemAmount
	{
		public ulong skinOverride;

		public bool blueprint;
	}

	public enum LoadoutCategory
	{
		Tiers,
		NPCs,
		Other
	}

	public string niceName;

	public int order = 100;

	public LoadoutCategory category = LoadoutCategory.Other;

	public List<ItemAmountSkinned> belt;

	public List<ItemAmountSkinned> main;

	public List<ItemAmountSkinned> wear;

	public bool StripBelt = true;

	public bool StripMain = true;

	public bool StripWear = true;

	public GameObjectRef DeathIconPrefab;

	public PlayerInventoryProperties giveBase;

	private static PlayerInventoryProperties[] allInventories;

	public void GiveToPlayer(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		if (player is HumanNPC humanNPC && DeathIconPrefab.isValid)
		{
			humanNPC.DeathIconOverride = DeathIconPrefab;
		}
		if (giveBase != null)
		{
			giveBase.GiveToPlayer(player);
		}
		if (belt != null && belt.Count > 0)
		{
			if (StripBelt)
			{
				player.inventory.containerBelt.Clear();
			}
			foreach (ItemAmountSkinned item2 in belt)
			{
				CreateItem(item2, player.inventory.containerBelt);
			}
		}
		if (main != null && main.Count > 0)
		{
			if (StripMain)
			{
				player.inventory.containerMain.Clear();
			}
			foreach (ItemAmountSkinned item3 in main)
			{
				CreateItem(item3, player.inventory.containerMain);
			}
		}
		if (wear == null || wear.Count <= 0)
		{
			return;
		}
		if (StripWear)
		{
			player.inventory.containerWear.Clear();
		}
		foreach (ItemAmountSkinned item4 in wear)
		{
			CreateItem(item4, player.inventory.containerWear);
		}
		void CreateItem(ItemAmountSkinned toCreate, ItemContainer destination)
		{
			Item item = null;
			if (toCreate.blueprint)
			{
				item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				item.blueprintTarget = (((Object)(object)toCreate.itemDef.isRedirectOf != (Object)null) ? toCreate.itemDef.isRedirectOf.itemid : toCreate.itemDef.itemid);
			}
			else
			{
				item = ItemManager.Create(toCreate.itemDef, (int)toCreate.amount, toCreate.skinOverride);
			}
			player.inventory.GiveItem(item, destination);
		}
	}

	public static PlayerInventoryProperties GetInventoryConfig(string name)
	{
		if (allInventories == null)
		{
			allInventories = FileSystem.LoadAll<PlayerInventoryProperties>("assets/content/properties/playerinventory", "");
			Debug.Log((object)$"Found {allInventories.Length} inventories");
		}
		if (allInventories != null)
		{
			PlayerInventoryProperties[] array = allInventories;
			foreach (PlayerInventoryProperties playerInventoryProperties in array)
			{
				if (playerInventoryProperties.niceName.ToLower() == name.ToLower())
				{
					return playerInventoryProperties;
				}
			}
		}
		return null;
	}
}


using System;

[Serializable]
public class ItemAmountSkinned : ItemAmount
{
	public ulong skinOverride;

	public bool blueprint;
}


public enum LoadoutCategory
{
	Tiers,
	NPCs,
	Other
}


using UnityEngine;

public class PolymorphicAttribute : PropertyAttribute
{
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Protection Properties")]
public class ProtectionProperties : ScriptableObject
{
	[TextArea]
	public string comments;

	[Range(0f, 100f)]
	public float density = 1f;

	[ArrayIndexIsEnumRanged(enumType = typeof(DamageType), min = -4f, max = 3f)]
	public float[] amounts = new float[26];

	public void OnValidate()
	{
		if (amounts.Length >= 26)
		{
			return;
		}
		float[] array = new float[26];
		for (int i = 0; i < array.Length; i++)
		{
			if (i >= amounts.Length)
			{
				if (i == 21)
				{
					array[i] = amounts[9];
				}
			}
			else
			{
				array[i] = amounts[i];
			}
		}
		amounts = array;
	}

	public void Clear()
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			amounts[i] = 0f;
		}
	}

	public void Add(float amount)
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			amounts[i] += amount;
		}
	}

	public void Add(DamageType index, float amount)
	{
		amounts[(int)index] += amount;
	}

	public void Add(ProtectionProperties other, float scale)
	{
		for (int i = 0; i < Mathf.Min(other.amounts.Length, amounts.Length); i++)
		{
			amounts[i] += other.amounts[i] * scale;
		}
	}

	public void Add(List<Item> items, HitArea area = (HitArea)(-1))
	{
		for (int i = 0; i < items.Count; i++)
		{
			Item item = items[i];
			ItemModWearable component = ((Component)item.info).GetComponent<ItemModWearable>();
			if (!((Object)(object)component == (Object)null) && component.ProtectsArea(area))
			{
				component.CollectProtection(item, this);
			}
		}
	}

	public void Multiply(float multiplier)
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			amounts[i] *= multiplier;
		}
	}

	public void Multiply(DamageType index, float multiplier)
	{
		amounts[(int)index] *= multiplier;
	}

	public void Scale(DamageTypeList damageList, float ProtectionAmount = 1f)
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			if (amounts[i] != 0f)
			{
				damageList.Scale((DamageType)i, 1f - Mathf.Clamp(amounts[i] * ProtectionAmount, -1f, 1f));
			}
		}
	}

	public float Get(DamageType damageType)
	{
		return amounts[(int)damageType];
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Recipe")]
public class Recipe : ScriptableObject
{
	[Serializable]
	public struct RecipeIngredient
	{
		public ItemDefinition Ingredient;

		[SerializeField]
		private int Count;

		public int GetIngredientCount(ItemDefinition producedItem)
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			float num = 1f;
			if ((Object)(object)activeGameMode != (Object)null)
			{
				num = activeGameMode.GetCraftingCostModifier(producedItem);
			}
			return Mathf.RoundToInt((float)Count * num);
		}
	}

	[Header("Produced Item")]
	public ItemDefinition ProducedItem;

	public int ProducedItemCount = 1;

	public bool CanQueueMultiple = true;

	[Header("Spawned Item")]
	public GameObjectRef SpawnedItem;

	public string SpawnedItemName;

	public string SpawnedItemDescription;

	public Sprite SpawnedItemIcon;

	[Header("Misc")]
	public bool RequiresBlueprint;

	public RecipeIngredient[] Ingredients;

	public float MixingDuration;

	public string DisplayName
	{
		get
		{
			if ((Object)(object)ProducedItem != (Object)null)
			{
				return ProducedItem.displayName.translated;
			}
			if (SpawnedItem != null)
			{
				return SpawnedItemName;
			}
			return null;
		}
	}

	public string DisplayDescription
	{
		get
		{
			if ((Object)(object)ProducedItem != (Object)null)
			{
				return ProducedItem.displayDescription.translated;
			}
			if (SpawnedItem != null)
			{
				return SpawnedItemDescription;
			}
			return null;
		}
	}

	public Sprite DisplayIcon
	{
		get
		{
			if ((Object)(object)ProducedItem != (Object)null)
			{
				return ProducedItem.iconSprite;
			}
			if (SpawnedItem != null)
			{
				return SpawnedItemIcon;
			}
			return null;
		}
	}

	public bool ContainsItem(Item item)
	{
		if (item == null)
		{
			return false;
		}
		if (Ingredients == null)
		{
			return false;
		}
		RecipeIngredient[] ingredients = Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			RecipeIngredient recipeIngredient = ingredients[i];
			if ((Object)(object)item.info == (Object)(object)recipeIngredient.Ingredient)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct RecipeIngredient
{
	public ItemDefinition Ingredient;

	[SerializeField]
	private int Count;

	public int GetIngredientCount(ItemDefinition producedItem)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		float num = 1f;
		if ((Object)(object)activeGameMode != (Object)null)
		{
			num = activeGameMode.GetCraftingCostModifier(producedItem);
		}
		return Mathf.RoundToInt((float)Count * num);
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class RecipeDictionary
{
	private static Dictionary<uint, Dictionary<int, List<Recipe>>> recipeListsDict = new Dictionary<uint, Dictionary<int, List<Recipe>>>();

	public static void CacheRecipes(RecipeList recipeList)
	{
		if (recipeList == null || recipeListsDict.TryGetValue(recipeList.FilenameStringId, out var _))
		{
			return;
		}
		Dictionary<int, List<Recipe>> dictionary = new Dictionary<int, List<Recipe>>();
		recipeListsDict.Add(recipeList.FilenameStringId, dictionary);
		foreach (Recipe allRecipe in recipeList.AllRecipes)
		{
			List<Recipe> value2 = null;
			if (!dictionary.TryGetValue(allRecipe.Ingredients[0].Ingredient.itemid, out value2))
			{
				value2 = new List<Recipe>();
				dictionary.Add(allRecipe.Ingredients[0].Ingredient.itemid, value2);
			}
			value2.Add(allRecipe);
		}
	}

	public static Recipe GetMatchingRecipeAndQuantity(RecipeList recipeList, List<Item> orderedIngredients, out int quantity)
	{
		quantity = 0;
		if (recipeList == null)
		{
			return null;
		}
		if (orderedIngredients == null || orderedIngredients.Count == 0)
		{
			return null;
		}
		List<Recipe> recipesByFirstIngredient = GetRecipesByFirstIngredient(recipeList, orderedIngredients[0]);
		if (recipesByFirstIngredient == null)
		{
			return null;
		}
		foreach (Recipe item2 in recipesByFirstIngredient)
		{
			if ((Object)(object)item2 == (Object)null || item2.Ingredients.Length != orderedIngredients.Count)
			{
				continue;
			}
			bool flag = true;
			int num = int.MaxValue;
			int num2 = 0;
			Recipe.RecipeIngredient[] ingredients = item2.Ingredients;
			for (int i = 0; i < ingredients.Length; i++)
			{
				Recipe.RecipeIngredient recipeIngredient = ingredients[i];
				Item item = orderedIngredients[num2];
				int ingredientCount = recipeIngredient.GetIngredientCount(item2.ProducedItem);
				if ((Object)(object)recipeIngredient.Ingredient != (Object)(object)item.info || item.amount < ingredientCount)
				{
					flag = false;
					break;
				}
				int num3 = item.amount / ingredientCount;
				if (num2 == 0)
				{
					num = num3;
				}
				else if (num3 < num)
				{
					num = num3;
				}
				num2++;
			}
			if (flag)
			{
				quantity = num;
				if (quantity > 1 && !item2.CanQueueMultiple)
				{
					quantity = 1;
				}
				return item2;
			}
		}
		return null;
	}

	private static List<Recipe> GetRecipesByFirstIngredient(RecipeList recipeList, Item firstIngredient)
	{
		if (recipeList == null)
		{
			return null;
		}
		if (firstIngredient == null)
		{
			return null;
		}
		if (!recipeListsDict.TryGetValue(recipeList.FilenameStringId, out var value))
		{
			CacheRecipes(recipeList);
			if (!recipeListsDict.TryGetValue(recipeList.FilenameStringId, out value))
			{
				return null;
			}
		}
		if (value == null)
		{
			return null;
		}
		if (!value.TryGetValue(firstIngredient.info.itemid, out var value2))
		{
			return null;
		}
		return value2;
	}

	public static bool ValidIngredientForARecipe(Item ingredient, RecipeList recipeList)
	{
		if (ingredient == null)
		{
			return false;
		}
		if (recipeList == null)
		{
			return false;
		}
		foreach (Recipe allRecipe in recipeList.AllRecipes)
		{
			if (!((Object)(object)allRecipe == (Object)null) && allRecipe.ContainsItem(ingredient))
			{
				return true;
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Recipe List")]
public class RecipeList : BaseScriptableObject
{
	public Recipe[] Recipes;

	public RecipeList[] AdditionalRecipeLists;

	private bool initd;

	private List<Recipe> _recipes;

	public List<Recipe> AllRecipes
	{
		get
		{
			if (initd)
			{
				return _recipes;
			}
			initd = true;
			_recipes = new List<Recipe>();
			if (Recipes != null)
			{
				_recipes.AddRange(Recipes);
			}
			if (AdditionalRecipeLists != null)
			{
				RecipeList[] additionalRecipeLists = AdditionalRecipeLists;
				foreach (RecipeList recipeList in additionalRecipeLists)
				{
					_recipes.AddRange(recipeList.Recipes);
				}
			}
			return _recipes;
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Recoil Properties")]
public class RecoilProperties : ScriptableObject
{
	public float recoilYawMin;

	public float recoilYawMax;

	public float recoilPitchMin;

	public float recoilPitchMax;

	public float timeToTakeMin;

	public float timeToTakeMax = 0.1f;

	public float ADSScale = 0.5f;

	public float movementPenalty;

	public float clampPitch = float.NegativeInfinity;

	public AnimationCurve pitchCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public AnimationCurve yawCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public bool useCurves;

	public bool curvesAsScalar;

	public int shotsUntilMax = 30;

	public float maxRecoilRadius = 5f;

	[Header("AimCone")]
	public bool overrideAimconeWithCurve;

	public float aimconeCurveScale = 1f;

	[Tooltip("How much to scale aimcone by based on how far into the shot sequence we are (shots v shotsUntilMax)")]
	public AnimationCurve aimconeCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	[Tooltip("Randomly select how much to scale final aimcone by per shot, you can use this to weigh a fraction of shots closer to the center")]
	public AnimationCurve aimconeProbabilityCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 1f),
		new Keyframe(0.5f, 0f),
		new Keyframe(1f, 1f)
	});

	[Tooltip("Scale the actual final aimcone produced by the ammunition itself if the ammo contains multiple projectiles")]
	public float ammoAimconeScaleMultiProjectile = 1f;

	[Tooltip("Scale the actual final aimcone produced by the ammunition itself if the ammo contains only one projectile")]
	public float ammoAimconeScaleSingleProjectile = 1f;

	public RecoilProperties newRecoilOverride;

	public RecoilProperties GetRecoil()
	{
		if (!((Object)(object)newRecoilOverride != (Object)null))
		{
			return this;
		}
		return newRecoilOverride;
	}
}


using System;

[Serializable]
public class SkinReplacement
{
	public enum SkinType
	{
		NONE,
		Hands,
		Head,
		Feet,
		Torso,
		Legs
	}

	public SkinType skinReplacementType;

	public GameObjectRef targetReplacement;
}


public enum SkinType
{
	NONE,
	Hands,
	Head,
	Feet,
	Torso,
	Legs
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skin Set")]
public class SkinSet : ScriptableObject
{
	public string Label;

	public Gradient SkinColour;

	public HairSetCollection HairCollection;

	[Header("Models")]
	public GameObjectRef Head;

	public GameObjectRef Torso;

	public GameObjectRef Legs;

	public GameObjectRef Feet;

	public GameObjectRef Hands;

	[Header("Censored Variants")]
	public GameObjectRef CensoredTorso;

	public GameObjectRef CensoredLegs;

	[Header("Materials")]
	public Material HeadMaterial;

	public Material BodyMaterial;

	public Material EyeMaterial;

	internal Color GetSkinColor(float skinNumber)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return SkinColour.Evaluate(skinNumber);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skin Set Collection")]
public class SkinSetCollection : ScriptableObject
{
	public SkinSet[] Skins;

	public int GetIndex(float MeshNumber)
	{
		return Mathf.Clamp(Mathf.FloorToInt(MeshNumber * (float)Skins.Length), 0, Skins.Length - 1);
	}

	public SkinSet Get(float MeshNumber)
	{
		return Skins[GetIndex(MeshNumber)];
	}
}


using System;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public sealed class SoftRequireComponent : Attribute
{
	public Type m_Type0;

	public Type m_Type1;

	public Type m_Type2;

	public SoftRequireComponent(Type requiredComponent)
	{
		m_Type0 = requiredComponent;
	}

	public SoftRequireComponent(Type requiredComponent, Type requiredComponent2)
	{
		m_Type0 = requiredComponent;
		m_Type1 = requiredComponent2;
	}

	public SoftRequireComponent(Type requiredComponent, Type requiredComponent2, Type requiredComponent3)
	{
		m_Type0 = requiredComponent;
		m_Type1 = requiredComponent2;
		m_Type2 = requiredComponent3;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Steam DLC Item")]
public class SteamDLCItem : ScriptableObject
{
	public Phrase dlcName;

	public int dlcAppID;

	public bool bypassLicenseCheck;

	public bool HasLicense(ulong steamid)
	{
		if (bypassLicenseCheck)
		{
			return true;
		}
		if (!PlatformService.Instance.IsValid)
		{
			return false;
		}
		return PlatformService.Instance.PlayerOwnsDownloadableContent(steamid, dlcAppID);
	}

	public bool CanUse(BasePlayer player)
	{
		if (player.isServer)
		{
			if (!HasLicense(player.userID))
			{
				return (ulong)player.userID < 10000000;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Generic Steam Inventory Category")]
public class SteamInventoryCategory : ScriptableObject
{
	public enum Price
	{
		CannotBuy,
		VLV25,
		VLV50,
		VLV75,
		VLV100,
		VLV150,
		VLV200,
		VLV250,
		VLV300,
		VLV350,
		VLV400,
		VLV450,
		VLV500,
		VLV550,
		VLV600,
		VLV650,
		VLV700,
		VLV750,
		VLV800,
		VLV850,
		VLV900,
		VLV950,
		VLV1000,
		VLV1100,
		VLV1200,
		VLV1300,
		VLV1400,
		VLV1500,
		VLV1600,
		VLV1700,
		VLV1800,
		VLV1900,
		VLV2000,
		VLV2500,
		VLV3000,
		VLV3500,
		VLV4000,
		VLV4500,
		VLV5000,
		VLV6000,
		VLV7000,
		VLV8000,
		VLV9000,
		VLV10000
	}

	public enum DropChance
	{
		NeverDrop,
		VeryRare,
		Rare,
		Common,
		VeryCommon,
		ExtremelyRare
	}

	[Header("Steam Inventory")]
	public bool canBeSoldToOtherUsers;

	public bool canBeTradedWithOtherUsers;

	public bool isCommodity;

	public Price price;

	public DropChance dropChance;

	public bool CanBeInCrates = true;
}


public enum Price
{
	CannotBuy,
	VLV25,
	VLV50,
	VLV75,
	VLV100,
	VLV150,
	VLV200,
	VLV250,
	VLV300,
	VLV350,
	VLV400,
	VLV450,
	VLV500,
	VLV550,
	VLV600,
	VLV650,
	VLV700,
	VLV750,
	VLV800,
	VLV850,
	VLV900,
	VLV950,
	VLV1000,
	VLV1100,
	VLV1200,
	VLV1300,
	VLV1400,
	VLV1500,
	VLV1600,
	VLV1700,
	VLV1800,
	VLV1900,
	VLV2000,
	VLV2500,
	VLV3000,
	VLV3500,
	VLV4000,
	VLV4500,
	VLV5000,
	VLV6000,
	VLV7000,
	VLV8000,
	VLV9000,
	VLV10000
}


public enum DropChance
{
	NeverDrop,
	VeryRare,
	Rare,
	Common,
	VeryCommon,
	ExtremelyRare
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skins/Inventory Item")]
public class SteamInventoryItem : ScriptableObject
{
	public enum Category
	{
		None,
		Clothing,
		Weapon,
		Decoration,
		Crate,
		Resource
	}

	public enum SubCategory
	{
		None,
		Shirt,
		Pants,
		Jacket,
		Hat,
		Mask,
		Footwear,
		Weapon,
		Misc,
		Crate,
		Resource,
		CrateUncraftable
	}

	public int id;

	public Sprite icon;

	public Phrase displayName;

	public Phrase displayDescription;

	[Tooltip("Images to show on the Steam store page for this item. Should all be square and hosted on https://files.facepunch.com/")]
	public string[] storeImages = Array.Empty<string>();

	[Header("Steam Inventory")]
	public Category category;

	public SubCategory subcategory;

	public SteamInventoryCategory steamCategory;

	[Tooltip("If true then this item will be placed under the Limited tab, otherwise it goes under General.")]
	public bool isLimitedTimeOffer = true;

	[Tooltip("Stop this item being broken down into cloth etc")]
	public bool PreventBreakingDown;

	[Tooltip("Set to true to allow players to delete the item from their inventory")]
	public bool IsTwitchDrop;

	[Header("Meta")]
	public string itemname;

	public ulong workshopID;

	public SteamDLCItem DlcItem;

	[Tooltip("Does nothing currently")]
	public bool forceCraftableItemDesc;

	[Tooltip("If enabled the item store will not show this as a 3d model")]
	public bool forceDisableTurntableInItemStore;

	[Tooltip("If the player owns this steam item, we will consider ourselves unlocked")]
	public SteamInventoryItem UnlockedViaSteamItem;

	public ItemDefinition itemDefinition => ItemManager.FindItemDefinition(itemname);

	public virtual bool HasUnlocked(ulong playerId)
	{
		if ((Object)(object)DlcItem != (Object)null && DlcItem.HasLicense(playerId))
		{
			return true;
		}
		if ((Object)(object)UnlockedViaSteamItem != (Object)null)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(playerId);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.blueprints.CheckSkinOwnership(UnlockedViaSteamItem.id, basePlayer.userID))
			{
				return true;
			}
		}
		return false;
	}
}


public enum Category
{
	None,
	Clothing,
	Weapon,
	Decoration,
	Crate,
	Resource
}


public enum SubCategory
{
	None,
	Shirt,
	Pants,
	Jacket,
	Hat,
	Mask,
	Footwear,
	Weapon,
	Misc,
	Crate,
	Resource,
	CrateUncraftable
}


using System;
using System.Collections.Generic;

public static class StringFormatCache
{
	private struct Key1 : IEquatable<Key1>
	{
		public string format;

		public string value1;

		public Key1(string format, string value1)
		{
			this.format = format;
			this.value1 = value1;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key1))
			{
				return false;
			}
			return Equals((Key1)other);
		}

		public bool Equals(Key1 other)
		{
			if (format == other.format)
			{
				return value1 == other.value1;
			}
			return false;
		}
	}

	private struct Key2 : IEquatable<Key2>
	{
		public string format;

		public string value1;

		public string value2;

		public Key2(string format, string value1, string value2)
		{
			this.format = format;
			this.value1 = value1;
			this.value2 = value2;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key2))
			{
				return false;
			}
			return Equals((Key2)other);
		}

		public bool Equals(Key2 other)
		{
			if (format == other.format && value1 == other.value1)
			{
				return value2 == other.value2;
			}
			return false;
		}
	}

	private struct Key3 : IEquatable<Key3>
	{
		public string format;

		public string value1;

		public string value2;

		public string value3;

		public Key3(string format, string value1, string value2, string value3)
		{
			this.format = format;
			this.value1 = value1;
			this.value2 = value2;
			this.value3 = value3;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key3))
			{
				return false;
			}
			return Equals((Key3)other);
		}

		public bool Equals(Key3 other)
		{
			if (format == other.format && value1 == other.value1 && value2 == other.value2)
			{
				return value3 == other.value3;
			}
			return false;
		}
	}

	private struct Key4 : IEquatable<Key4>
	{
		public string format;

		public string value1;

		public string value2;

		public string value3;

		public string value4;

		public Key4(string format, string value1, string value2, string value3, string value4)
		{
			this.format = format;
			this.value1 = value1;
			this.value2 = value2;
			this.value3 = value3;
			this.value4 = value4;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode() ^ value4.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key4))
			{
				return false;
			}
			return Equals((Key4)other);
		}

		public bool Equals(Key4 other)
		{
			if (format == other.format && value1 == other.value1 && value2 == other.value2 && value3 == other.value3)
			{
				return value4 == other.value4;
			}
			return false;
		}
	}

	private static Dictionary<Key1, string> dict1 = new Dictionary<Key1, string>();

	private static Dictionary<Key2, string> dict2 = new Dictionary<Key2, string>();

	private static Dictionary<Key3, string> dict3 = new Dictionary<Key3, string>();

	private static Dictionary<Key4, string> dict4 = new Dictionary<Key4, string>();

	public static string Get(string format, string value1)
	{
		Key1 key = new Key1(format, value1);
		if (!dict1.TryGetValue(key, out var value2))
		{
			value2 = string.Format(format, value1);
			dict1.Add(key, value2);
		}
		return value2;
	}

	public static string Get(string format, string value1, string value2)
	{
		Key2 key = new Key2(format, value1, value2);
		if (!dict2.TryGetValue(key, out var value3))
		{
			value3 = string.Format(format, value1, value2);
			dict2.Add(key, value3);
		}
		return value3;
	}

	public static string Get(string format, string value1, string value2, string value3)
	{
		Key3 key = new Key3(format, value1, value2, value3);
		if (!dict3.TryGetValue(key, out var value4))
		{
			value4 = string.Format(format, value1, value2, value3);
			dict3.Add(key, value4);
		}
		return value4;
	}

	public static string Get(string format, string value1, string value2, string value3, string value4)
	{
		Key4 key = new Key4(format, value1, value2, value3, value4);
		if (!dict4.TryGetValue(key, out var value5))
		{
			value5 = string.Format(format, value1, value2, value3, value4);
			dict4.Add(key, value5);
		}
		return value5;
	}
}


using System;

private struct Key1 : IEquatable<Key1>
{
	public string format;

	public string value1;

	public Key1(string format, string value1)
	{
		this.format = format;
		this.value1 = value1;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key1))
		{
			return false;
		}
		return Equals((Key1)other);
	}

	public bool Equals(Key1 other)
	{
		if (format == other.format)
		{
			return value1 == other.value1;
		}
		return false;
	}
}


using System;

private struct Key2 : IEquatable<Key2>
{
	public string format;

	public string value1;

	public string value2;

	public Key2(string format, string value1, string value2)
	{
		this.format = format;
		this.value1 = value1;
		this.value2 = value2;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key2))
		{
			return false;
		}
		return Equals((Key2)other);
	}

	public bool Equals(Key2 other)
	{
		if (format == other.format && value1 == other.value1)
		{
			return value2 == other.value2;
		}
		return false;
	}
}


using System;

private struct Key3 : IEquatable<Key3>
{
	public string format;

	public string value1;

	public string value2;

	public string value3;

	public Key3(string format, string value1, string value2, string value3)
	{
		this.format = format;
		this.value1 = value1;
		this.value2 = value2;
		this.value3 = value3;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key3))
		{
			return false;
		}
		return Equals((Key3)other);
	}

	public bool Equals(Key3 other)
	{
		if (format == other.format && value1 == other.value1 && value2 == other.value2)
		{
			return value3 == other.value3;
		}
		return false;
	}
}


using System;

private struct Key4 : IEquatable<Key4>
{
	public string format;

	public string value1;

	public string value2;

	public string value3;

	public string value4;

	public Key4(string format, string value1, string value2, string value3, string value4)
	{
		this.format = format;
		this.value1 = value1;
		this.value2 = value2;
		this.value3 = value3;
		this.value4 = value4;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode() ^ value4.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key4))
		{
			return false;
		}
		return Equals((Key4)other);
	}

	public bool Equals(Key4 other)
	{
		if (format == other.format && value1 == other.value1 && value2 == other.value2 && value3 == other.value3)
		{
			return value4 == other.value4;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class StringPool
{
	public static Dictionary<uint, string> toString;

	public static Dictionary<string, uint> toNumber;

	private static bool initialized;

	public static uint closest;

	private static void Init()
	{
		if (initialized)
		{
			return;
		}
		toString = new Dictionary<uint, string>();
		toNumber = new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase);
		GameManifest gameManifest = FileSystem.Load<GameManifest>("Assets/manifest.asset", true);
		for (uint num = 0u; num < gameManifest.pooledStrings.Length; num++)
		{
			string str = gameManifest.pooledStrings[num].str;
			uint hash = gameManifest.pooledStrings[num].hash;
			if (toString.TryGetValue(hash, out var value))
			{
				if (str != value)
				{
					Debug.LogWarning((object)$"Hash collision: {hash} already exists in string pool. `{str}` and `{value}` have the same hash.");
				}
			}
			else
			{
				toString.Add(hash, str);
				toNumber.Add(str, hash);
			}
		}
		initialized = true;
		closest = Get("closest");
	}

	public static string Get(uint i)
	{
		if (i == 0)
		{
			return string.Empty;
		}
		Init();
		if (toString.TryGetValue(i, out var value))
		{
			return value;
		}
		Debug.LogWarning((object)("StringPool.GetString - no string for ID" + i));
		return "";
	}

	public static uint Get(string str)
	{
		if (string.IsNullOrEmpty(str))
		{
			return 0u;
		}
		Init();
		if (toNumber.TryGetValue(str, out var value))
		{
			return value;
		}
		Debug.LogWarning((object)("StringPool.GetNumber - no number for string " + str));
		return 0u;
	}

	public static uint Add(string str)
	{
		uint value = 0u;
		if (!toNumber.TryGetValue(str, out value))
		{
			value = StringEx.ManifestHash(str);
			toString.Add(value, str);
			toNumber.Add(str, value);
		}
		return value;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Underwear")]
public class Underwear : ScriptableObject
{
	public string shortname = "";

	public Phrase displayName;

	public Sprite icon;

	public Sprite iconFemale;

	public SkinReplacement[] replacementsMale;

	public SkinReplacement[] replacementsFemale;

	[Tooltip("User can craft this item on any server if they have this steam item")]
	public SteamInventoryItem steamItem;

	[Tooltip("User can craft this item if they have this DLC purchased")]
	public SteamDLCItem steamDLC;

	public bool adminOnly;

	public uint GetID()
	{
		return StringPool.Get(shortname);
	}

	public bool HasMaleParts()
	{
		return replacementsMale.Length != 0;
	}

	public bool HasFemaleParts()
	{
		return replacementsFemale.Length != 0;
	}

	public bool ValidForPlayer(BasePlayer player)
	{
		if (HasMaleParts() && HasFemaleParts())
		{
			return true;
		}
		bool flag = IsFemale(player);
		if (flag && HasFemaleParts())
		{
			return true;
		}
		if (!flag && HasMaleParts())
		{
			return true;
		}
		return false;
	}

	public static bool IsFemale(BasePlayer player)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		ulong num = player.userID.Get();
		long num2 = 4332L;
		State state = Random.state;
		Random.InitState((int)(num2 + (long)num));
		float num3 = Random.Range(0f, 1f);
		Random.state = state;
		if (!(num3 > 0.5f))
		{
			return false;
		}
		return true;
	}

	public static bool Validate(Underwear underwear, BasePlayer player)
	{
		if ((Object)(object)underwear == (Object)null)
		{
			return true;
		}
		if (!underwear.ValidForPlayer(player))
		{
			return false;
		}
		if (underwear.adminOnly && (!player.IsAdmin || !player.IsDeveloper))
		{
			return false;
		}
		bool num = (Object)(object)underwear.steamItem == (Object)null || player.blueprints.steamInventory.HasItem(underwear.steamItem.id);
		bool flag = false;
		if (player.isServer && ((Object)(object)underwear.steamDLC == (Object)null || underwear.steamDLC.HasLicense(player.userID)))
		{
			flag = true;
		}
		return num && flag;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Underwear Manifest")]
public class UnderwearManifest : ScriptableObject
{
	public static UnderwearManifest instance;

	public List<Underwear> underwears;

	public static UnderwearManifest Get()
	{
		if ((Object)(object)instance == (Object)null)
		{
			instance = Resources.Load<UnderwearManifest>("UnderwearManifest");
		}
		return instance;
	}

	public void PrintManifest()
	{
		Debug.Log((object)"MANIFEST CONTENTS");
		foreach (Underwear underwear in underwears)
		{
			Debug.Log((object)("Underwear name : " + underwear.shortname + " underwear ID : " + underwear.GetID()));
		}
	}

	public Underwear GetUnderwear(uint id)
	{
		foreach (Underwear underwear in underwears)
		{
			if (underwear.GetID() == id)
			{
				return underwear;
			}
		}
		return null;
	}

	public Underwear GetUnderwearWithSkinId(int skinId)
	{
		foreach (Underwear underwear in underwears)
		{
			if ((Object)(object)underwear.steamItem != (Object)null && underwear.steamItem.id == skinId)
			{
				return underwear;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

public class SpringUtil
{
	public static void SimpleDampedSpring(ref float val, ref float velocity, float targetValue, float dampening, float frequency, float delta)
	{
		float num = 1f + 2f * delta * dampening * frequency;
		float num2 = frequency * frequency;
		float num3 = delta * num2;
		float num4 = delta * num3;
		float num5 = 1f / (num + num4);
		float num6 = num * val + delta * velocity + num4 * targetValue;
		float num7 = velocity + num3 * (targetValue - val);
		val = num6 * num5;
		velocity = num7 * num5;
	}

	public static void DampedSpring(ref float val, ref float velocity, float targetValue, float reductionAmount, float reductionDuration, float frequency, float delta)
	{
		float num = FrequencyInHertz(frequency);
		float dampening = DampeningInDuration(reductionAmount, reductionDuration, num);
		SimpleDampedSpring(ref val, ref velocity, targetValue, dampening, num, delta);
	}

	public static void DampedSpring(ref Vector3 val, ref Vector3 velocity, Vector3 targetValue, float reductionAmount, float reductionDuration, float frequency, float delta)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float num = FrequencyInHertz(frequency);
		float dampening = DampeningInDuration(reductionAmount, reductionDuration, num);
		SimpleDampedSpring(ref val.x, ref velocity.x, targetValue.x, dampening, num, delta);
		SimpleDampedSpring(ref val.y, ref velocity.y, targetValue.y, dampening, num, delta);
		SimpleDampedSpring(ref val.z, ref velocity.z, targetValue.z, dampening, num, delta);
	}

	private static float FrequencyInHertz(float rawFrequency)
	{
		return MathF.PI * 2f * rawFrequency;
	}

	private static float DampeningInDuration(float reductionRate, float duration, float freqHertz)
	{
		float num = Mathf.Log(reductionRate);
		float num2 = freqHertz * (0f - duration);
		return num / num2;
	}
}


using UnityEngine;

public class OpenSteamURL : MonoBehaviour
{
	public bool openInSteam = true;
}


public class SteamClientWrapper : SingletonComponent<SteamClientWrapper>
{
}


public class WorkshopSkin : WorkshopSkinBase
{
}


using UnityEngine;
using UnityEngine.Playables;

public class DemoTimelineController : MonoBehaviour
{
	public PlayableDirector Director;
}


using UnityEngine.Playables;

public class DemoTrackBehaviour : PlayableBehaviour
{
	public string DemoName;
}


using System;
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

[Serializable]
public class TimelineConvarController : PlayableAsset, ITimelineClipAsset
{
	public string convarName = string.Empty;

	public TimelineConvarPlayable template = new TimelineConvarPlayable();

	public ClipCaps clipCaps => (ClipCaps)2;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ScriptPlayable<TimelineConvarPlayable> val = ScriptPlayable<TimelineConvarPlayable>.Create(graph, template, 0);
		val.GetBehaviour().convar = convarName;
		return ScriptPlayable<TimelineConvarPlayable>.op_Implicit(val);
	}
}


using System;
using UnityEngine.Playables;

[Serializable]
public class TimelineConvarPlayable : PlayableBehaviour
{
	[NonSerialized]
	public string convar;

	public float ConvarValue;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class Achievements : SingletonComponent<Achievements>
{
	public SoundDefinition listComplete;

	public SoundDefinition itemComplete;

	public SoundDefinition popup;

	public Canvas Canvas;

	public Text titleText;
}


using UnityEngine;
using UnityEngine.UI;

public class AchievementTodo : BaseMonoBehaviour
{
	public Text text;

	public RectTransform checkIcon;

	public RectTransform checkBox;

	public Color AliveColor;

	public Color DeadColor;

	public Color HighlightColor;
}


using UnityEngine;

public class AdminUI : MonoBehaviour
{
	public bool AllowInDemo;

	public GameObject TargetGameObject;
}


using UnityEngine;

public class AddNewEventUIButton : MonoBehaviour
{
}


using UnityEngine;

public class AddNewStateUIButton : MonoBehaviour
{
}


public class AggressionTimerEventUI : BaseEventUI
{
}


public class AmmoBelowEventUI : BaseEventUI
{
}


public class AndEventUI : BaseEventUI
{
}


public class AttackedEventUI : BaseEventUI
{
}


public class AttackTickEventUI : BaseEventUI
{
}


using Rust.UI;
using UnityEngine;

public class BaseEventUI : MonoBehaviour
{
	public RustText TextEventType;

	public RustText TextOutput;

	public RustButton ToggleInvert;

	public Dropdown DropdownInputMemorySlot;

	public Dropdown DropdownOutputMemorySlot;

	public RustInput InputFloatValue;

	public RustInput InputFloatValue2;

	[HideInInspector]
	public AIEventType EventType;

	[HideInInspector]
	public BaseStateUI Output;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BaseStateUI : MonoBehaviour
{
	public Dropdown DropdownInputMemorySlot;

	public Transform PrefabAddNewEvent;

	public Transform PrefabTimerEvent;

	public Transform PrefabPlayerDetectedEvent;

	public Transform PrefabStateErrorEvent;

	public Transform PrefabStateFinishedEvent;

	public Transform PrefabAttackedEvent;

	public Transform PrefabInAttackRangeEvent;

	public Transform PrefabHealthBelowEvent;

	public Transform PrefabInRangeEvent;

	public Transform PrefabPerformedAttackEvent;

	public Transform PrefabTirednessAboveEvent;

	public Transform PrefabHungerAboveEvent;

	public Transform PrefabThreatDetectevEvent;

	public Transform PrefabTargetDetectevEvent;

	public Transform PrefabAmmoBelowEvent;

	public Transform PrefabBestTargetDetectedEvent;

	public Transform PrefabIsVisibleEvent;

	public Transform PrefabAttackTickEvent;

	public Transform PrefabIsMountedEvent;

	public Transform PrefabAndEvent;

	public Transform PrefabChanceEvent;

	public Transform PrefabTargetLostEvent;

	public Transform PrefabTimeSinceThreatEvent;

	public Transform PrefabOnPositionMemorySetEvent;

	public Transform PrefabAggressionTimerEvent;

	public Transform PrefabReloadingEvent;

	public Transform PrefabInRangeOfHomeEvent;

	public Transform PrefabIsBlindedEvent;

	public RustText TextStateName;

	public Transform EventContainer;

	public ScrollRect Scroll;
}


public class BestTargetDetectedEventUI : BaseEventUI
{
}


public class ChanceEventUI : BaseEventUI
{
}


using UnityEngine;
using UnityEngine.EventSystems;

public class DeleteEventButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public void OnPointerDown(PointerEventData eventData)
	{
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class EnumListItemUI : MonoBehaviour
{
	public object Value;

	public RustText TextValue;

	private EnumListUI list;

	public void Init(object value, string valueText, EnumListUI list)
	{
		Value = value;
		this.list = list;
		((TMP_Text)TextValue).text = valueText;
	}

	public void Clicked()
	{
		list.ItemClicked(Value);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class EnumListUI : MonoBehaviour
{
	public Transform PrefabItem;

	public Transform Container;

	private Action<object> clickedAction;

	private CanvasScaler canvasScaler;

	private void Awake()
	{
		Hide();
	}

	public void Show(List<object> values, Action<object> clicked)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.SetActive(true);
		clickedAction = clicked;
		foreach (Transform item in Container)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
		foreach (object value in values)
		{
			Transform obj = Object.Instantiate<Transform>(PrefabItem);
			obj.SetParent(Container, false);
			((Component)obj).GetComponent<EnumListItemUI>().Init(value, value.ToString(), this);
		}
	}

	public void ItemClicked(object value)
	{
		clickedAction?.Invoke(value);
		Hide();
	}

	public void Hide()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


public class HealthBelowEventUI : BaseEventUI
{
}


public class HungerAboveEventUI : BaseEventUI
{
}


public class InAttackRangeEventUI : BaseEventUI
{
}


public class InRangeEventUI : BaseEventUI
{
}


public class InRangeOfHomeEventUI : BaseEventUI
{
}


public class IsBlindedEventUI : BaseEventUI
{
}


public class IsMountedEventUI : BaseEventUI
{
}


public class IsVisibleEventUI : BaseEventUI
{
}


using Rust.UI;
using UnityEngine;

public class MemorySlotUI : MonoBehaviour
{
	public RustText Label;
}


public class OnPositionMemorySetEventUI : BaseEventUI
{
}


public class PerformedAttackedEventUI : BaseEventUI
{
}


public class PlayerDetectedEventUI : BaseEventUI
{
}


public class ReloadEventUI : BaseEventUI
{
}


public class StateErrorEventUI : BaseEventUI
{
}


public class StateFinishedEventUI : BaseEventUI
{
}


public class TargetDetectedEventUI : BaseEventUI
{
}


public class TargetLostEventUI : BaseEventUI
{
}


public class ThreatDetectedEventUI : BaseEventUI
{
}


public class TimerEventUI : BaseEventUI
{
}


public class TimeSinceThreatEventUI : BaseEventUI
{
}


public class TirednessAboveEventUI : BaseEventUI
{
}


using Rust.UI;
using UnityEngine;

public class UIAIDesignerScreen : SingletonComponent<UIAIDesignerScreen>, IUIScreen
{
	public GameObject SaveEntityButton;

	public GameObject SaveServerButton;

	public GameObject SaveDefaultButton;

	public RustInput InputAIDescription;

	public RustText TextDefaultStateContainer;

	public Transform PrefabAddNewStateButton;

	public Transform StateContainer;

	public Transform PrefabState;

	public EnumListUI PopupList;

	public static EnumListUI EnumList;

	public NeedsCursor needsCursor;

	protected CanvasGroup canvasGroup;

	public GameObject RootPanel;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class AspectRatioGuide : MonoBehaviour
{
	public AspectRatioFitter aspectRatioFitter;

	public RustText label;

	public float aspect;

	public float ratio;

	private void Populate()
	{
		aspect = CameraMan.GuideAspect;
		ratio = Mathf.Max(CameraMan.GuideRatio, 1f);
		aspectRatioFitter.aspectRatio = aspect / ratio;
		((TMP_Text)label).text = $"{aspect}:{ratio}";
	}

	public void Awake()
	{
		Populate();
	}

	public void Update()
	{
		Populate();
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class BlurManager : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public PostProcessProfile standardBlurProfile;

	public PostProcessProfile heavyBlurProfile;
}


using TMPro;
using UnityEngine;

public class Branding : BaseMonoBehaviour
{
	public TextMeshProUGUI versionText;

	public CanvasGroup canvasGroup;

	private string oldChangeId;
}


using UnityEngine;

public class BuildCostIndicator : SingletonComponent<BuildCostIndicator>, IClientComponent
{
	public BuildCostIndicatorRow[] Rows;

	public CanvasGroup Fader;
}


public class BuildCostIndicatorRow : CostIndicatorRow
{
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChatEntry : MonoBehaviour
{
	public TextMeshProUGUI text;

	public RawImage avatar;

	public HttpImage httpAvatar;

	public CanvasGroup canvasGroup;

	public Phrase LocalPhrase = new Phrase("local", "local");

	public Phrase CardsPhrase = new Phrase("cards", "cards");

	public Phrase TeamPhrase = new Phrase("team", "team");

	public TmProEmojiRedirector EmojiRedirector;

	public Phrase ClanPhrase = new Phrase("clan", "clan");
}


using UnityEngine;

public class EmojiAutocomplete : MonoBehaviour
{
	public RectTransform Parent;

	public GameObjectRef EmojiPrefab;

	public RectTransform Selector;
}


using UnityEngine;
using UnityEngine.UI;

public class EmojiController : ListComponent<EmojiController>
{
	public Image Image;

	public RawImage VideoImage;

	public RectTransform rectTransform;
}


using Rust.UI;

public class EmojiControllerGallery : EmojiController
{
	public RustText NameText;
}


using Rust.UI;
using UnityEngine;

public class EmojiGallery : MonoBehaviour
{
	public GameObjectRef EmojiPrefab;

	public Transform Parent;

	public RustEmojiLibrary Library;

	public GameObject HighlightRoot;

	public RustText HighlightText;

	public EmojiController SkinIndicator;

	public EmojiController[] SkinToneGallery;

	public RustEmojiConfig SkinDemoConfig;

	public GameObject SkinPickerRoot;

	public TmProEmojiInputField TargetInputField;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Emoji Config")]
public class RustEmojiConfig : ScriptableObject
{
	public bool Hide;

	public RustEmojiLibrary.EmojiSource Source;
}


using System;
using System.Collections.Generic;
using System.IO;
using ConVar;
using UnityEngine;
using UnityEngine.Experimental.Rendering;

public class RustEmojiLibrary : BaseScriptableObject
{
	public enum EmojiType
	{
		Core,
		Item,
		Server
	}

	[Serializable]
	public struct EmojiSource
	{
		public string Name;

		public EmojiType Type;

		public EmojiResult[] Emoji;

		public SteamDLCItem RequiredDLC;

		public SteamInventoryItem RequiredItem;

		public uint ServerCrc;

		public FileStorage.Type ServerFileType;

		public bool HasSkinTone => Emoji.Length > 1;

		public EmojiResult GetEmojiIndex(int index)
		{
			return Emoji[Mathf.Clamp(index, 0, Emoji.Length - 1)];
		}

		public bool CanBeUsedBy(BasePlayer p, ulong userId)
		{
			if ((Object)(object)p != (Object)null && p.UnlockAllSkins)
			{
				return true;
			}
			if ((Object)(object)RequiredDLC != (Object)null && !RequiredDLC.CanUse(p))
			{
				return false;
			}
			if ((Object)(object)RequiredItem != (Object)null)
			{
				if ((Object)(object)p == (Object)null)
				{
					p = BasePlayer.FindByID(userId);
				}
				if ((Object)(object)p != (Object)null && p.blueprints.CheckSkinOwnership(RequiredItem.id, p.userID))
				{
					return true;
				}
				return false;
			}
			return true;
		}

		public bool StringMatch(string input, out int index)
		{
			index = 0;
			if (Name.Equals(input, StringComparison.CurrentCultureIgnoreCase))
			{
				return true;
			}
			for (int i = 0; i < Emoji.Length; i++)
			{
				if ($"{Name}+{i}".Equals(input, StringComparison.CurrentCultureIgnoreCase))
				{
					index = i;
					return true;
				}
			}
			return false;
		}
	}

	public struct ServerEmojiConfig
	{
		public uint CRC;

		public FileStorage.Type FileType;
	}

	public static NetworkableId EmojiStorageNetworkId = new NetworkableId(0uL);

	[HideInInspector]
	public RustEmojiConfig[] Configs;

	public RenderTextureDescriptor RenderTextureDesc = new RenderTextureDescriptor(256, 256, (GraphicsFormat)8, 0);

	public int InitialPoolSize = 10;

	private List<EmojiSource> all = new List<EmojiSource>();

	private List<EmojiSource> conditionalAccessOnly = new List<EmojiSource>();

	public GameObjectRef VideoPlayerRef;

	private static RustEmojiLibrary _instance = null;

	private static bool hasPrewarmed = false;

	private const long MAX_FILE_SIZE_BYTES = 250000L;

	public const int MAX_TEX_SIZE_PIXELS = 256;

	public static Dictionary<string, ServerEmojiConfig> allServerEmoji = new Dictionary<string, ServerEmojiConfig>();

	private static bool hasLoaded = false;

	[NonSerialized]
	public static List<string> cachedServerList = new List<string>();

	public static RustEmojiLibrary Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<RustEmojiLibrary>("assets/content/ui/gameui/emoji/rustemojilibrary.asset", true);
				_instance.Prewarm();
			}
			return _instance;
		}
	}

	private void Prewarm()
	{
		if (hasPrewarmed)
		{
			return;
		}
		hasPrewarmed = true;
		all.Clear();
		conditionalAccessOnly.Clear();
		RustEmojiConfig[] configs = Configs;
		foreach (RustEmojiConfig rustEmojiConfig in configs)
		{
			if (!rustEmojiConfig.Hide)
			{
				all.Add(rustEmojiConfig.Source);
				if ((Object)(object)rustEmojiConfig.Source.RequiredItem != (Object)null || (Object)(object)rustEmojiConfig.Source.RequiredDLC != (Object)null)
				{
					conditionalAccessOnly.Add(rustEmojiConfig.Source);
				}
			}
		}
		foreach (ItemDefinition item in ItemManager.itemList)
		{
			if (!item.Hidden() && !((Object)(object)item.iconSprite == (Object)null))
			{
				all.Add(new EmojiSource
				{
					Name = item.shortname,
					Type = EmojiType.Item,
					Emoji = new EmojiResult[1]
					{
						new EmojiResult
						{
							Sprite = item.iconSprite
						}
					}
				});
			}
		}
	}

	public bool TryGetEmoji(string key, out EmojiSource er, out int skinVariantIndex, out int allIndex, bool serverSide = false)
	{
		er = default(EmojiSource);
		skinVariantIndex = 0;
		allIndex = 0;
		Prewarm();
		foreach (EmojiSource item in serverSide ? conditionalAccessOnly : all)
		{
			if (item.Type != EmojiType.Server || !Global.blockServerEmoji)
			{
				if (item.StringMatch(key, out skinVariantIndex))
				{
					er = item;
					return true;
				}
				allIndex++;
			}
		}
		return false;
	}

	public static void FindAllServerEmoji()
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (hasLoaded)
		{
			return;
		}
		hasLoaded = true;
		string serverFolder = Server.GetServerFolder("serveremoji");
		if (!Directory.Exists(serverFolder))
		{
			return;
		}
		foreach (string item in Directory.EnumerateFiles(serverFolder))
		{
			try
			{
				FileInfo fileInfo = new FileInfo(item);
				bool flag = fileInfo.Extension == ".png";
				bool flag2 = fileInfo.Extension == ".jpg";
				if (!CheckByteArray(fileInfo.Length))
				{
					Debug.Log((object)$"{serverFolder} file size is too big for emoji, max file size is {250000L} bytes");
					continue;
				}
				byte[] data = File.ReadAllBytes(item);
				if (flag && !ImageProcessing.IsValidPNG(data, 256))
				{
					Debug.Log((object)(item + " is an invalid png"));
				}
				else if (flag2 && !ImageProcessing.IsValidJPG(data, 256))
				{
					Debug.Log((object)(item + " is an invalid jpg"));
				}
				else if (flag || flag2)
				{
					FileStorage.Type type = FileStorage.Type.jpg;
					if (flag)
					{
						type = FileStorage.Type.png;
					}
					uint cRC = FileStorage.server.Store(data, type, EmojiStorageNetworkId);
					string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(item);
					if (!allServerEmoji.ContainsKey(fileNameWithoutExtension))
					{
						allServerEmoji.Add(fileNameWithoutExtension, new ServerEmojiConfig
						{
							CRC = cRC,
							FileType = type
						});
					}
				}
			}
			catch (Exception arg)
			{
				Debug.Log((object)$"Exception loading {item} - {arg}");
			}
		}
		cachedServerList = new List<string>();
		foreach (KeyValuePair<string, ServerEmojiConfig> item2 in allServerEmoji)
		{
			cachedServerList.Add(item2.Key);
			cachedServerList.Add(item2.Value.CRC.ToString());
			List<string> list = cachedServerList;
			int fileType = (int)item2.Value.FileType;
			list.Add(fileType.ToString());
		}
	}

	public static void ResetServerEmoji()
	{
		hasLoaded = false;
		allServerEmoji.Clear();
		FindAllServerEmoji();
	}

	private static bool CheckByteArray(long arrayLength)
	{
		return arrayLength <= 250000;
	}

	public static bool CheckByteArray(int arrayLength)
	{
		return (long)arrayLength <= 250000L;
	}
}


public enum EmojiType
{
	Core,
	Item,
	Server
}


using System;
using UnityEngine;

[Serializable]
public struct EmojiSource
{
	public string Name;

	public EmojiType Type;

	public EmojiResult[] Emoji;

	public SteamDLCItem RequiredDLC;

	public SteamInventoryItem RequiredItem;

	public uint ServerCrc;

	public FileStorage.Type ServerFileType;

	public bool HasSkinTone => Emoji.Length > 1;

	public EmojiResult GetEmojiIndex(int index)
	{
		return Emoji[Mathf.Clamp(index, 0, Emoji.Length - 1)];
	}

	public bool CanBeUsedBy(BasePlayer p, ulong userId)
	{
		if ((Object)(object)p != (Object)null && p.UnlockAllSkins)
		{
			return true;
		}
		if ((Object)(object)RequiredDLC != (Object)null && !RequiredDLC.CanUse(p))
		{
			return false;
		}
		if ((Object)(object)RequiredItem != (Object)null)
		{
			if ((Object)(object)p == (Object)null)
			{
				p = BasePlayer.FindByID(userId);
			}
			if ((Object)(object)p != (Object)null && p.blueprints.CheckSkinOwnership(RequiredItem.id, p.userID))
			{
				return true;
			}
			return false;
		}
		return true;
	}

	public bool StringMatch(string input, out int index)
	{
		index = 0;
		if (Name.Equals(input, StringComparison.CurrentCultureIgnoreCase))
		{
			return true;
		}
		for (int i = 0; i < Emoji.Length; i++)
		{
			if ($"{Name}+{i}".Equals(input, StringComparison.CurrentCultureIgnoreCase))
			{
				index = i;
				return true;
			}
		}
		return false;
	}
}


public struct ServerEmojiConfig
{
	public uint CRC;

	public FileStorage.Type FileType;
}


using System;
using UnityEngine;
using UnityEngine.Video;

[Serializable]
public struct EmojiResult
{
	public Sprite Sprite;

	public VideoClip Video;
}


public class TmProEmojiInputField : RTLTMP_InputField
{
	public TmProEmojiRedirector Redirector;

	public EmojiAutocomplete Autocomplete;
}


using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class TmProEmojiRedirector : MonoBehaviour
{
	public struct EmojiSub
	{
		public int targetCharIndex;

		public int targetCharIndexWithRichText;

		public string targetEmoji;

		public RustEmojiLibrary.EmojiSource targetEmojiResult;

		public TMP_CharacterInfo charToReplace;
	}

	public GameObjectRef SpritePrefab;

	public float EmojiScale = 1.5f;

	public bool NonDestructiveChange;

	public bool CanTextHaveLegitimateRichText = true;

	public static void FindEmojiSubstitutions(string text, RustEmojiLibrary library, List<(EmojiSub, int)> foundSubs, bool richText, bool isServer = false, int messageLength = 0)
	{
		EmojiSub item = default(EmojiSub);
		bool flag = false;
		int num = 0;
		int num2 = 0;
		bool flag2 = false;
		int num3 = 0;
		int length = text.Length;
		if (messageLength > 0)
		{
			num3 = length - messageLength;
		}
		foundSubs.Clear();
		for (int i = 0; i < length; i++)
		{
			char c = text[i];
			num2++;
			if (richText)
			{
				if (c == '<')
				{
					bool flag3 = false;
					for (int j = i + 1; j < length && text[j] != '\u200b'; j++)
					{
						if (text[j] == '>')
						{
							flag3 = true;
							break;
						}
						if (text[j] == '<')
						{
							break;
						}
					}
					if (flag3)
					{
						flag2 = true;
						continue;
					}
				}
				if (flag2 && c == '>')
				{
					flag2 = false;
					continue;
				}
				if (flag2)
				{
					continue;
				}
			}
			if (num2 < num3)
			{
				num++;
				continue;
			}
			if (c == ':')
			{
				if (!flag)
				{
					flag = true;
					item.targetCharIndex = num;
					item.targetCharIndexWithRichText = num2 - 1;
				}
				else
				{
					if (library.TryGetEmoji(item.targetEmoji, out item.targetEmojiResult, out var skinVariantIndex, out var _, isServer))
					{
						foundSubs.Add((item, skinVariantIndex));
					}
					item = default(EmojiSub);
					flag = false;
				}
			}
			else if (flag)
			{
				item.targetEmoji += c;
				if (c == ' ')
				{
					item = default(EmojiSub);
					flag = false;
				}
			}
			num++;
		}
	}
}


using TMPro;

public struct EmojiSub
{
	public int targetCharIndex;

	public int targetCharIndexWithRichText;

	public string targetEmoji;

	public RustEmojiLibrary.EmojiSource targetEmojiResult;

	public TMP_CharacterInfo charToReplace;
}


using ConVar;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class UIChat : PriorityListComponent<UIChat>
{
	public GameObject inputArea;

	public GameObject chatArea;

	public TMP_InputField inputField;

	public TextMeshProUGUI channelLabel;

	public ScrollRect scrollRect;

	public CanvasGroup canvasGroup;

	public bool allowOpeningWhileCursorVisible;

	public GameObjectRef chatItemPlayer;

	public GameObject userPopup;

	public EmojiGallery emojiGallery;

	public GameObject dmPicker;

	public GameObject dmNameSection;

	public RustText dmName;

	public CanvasGroup backgroundCanvasGroup;

	public int maxMessageCount = 16;

	public bool fadeOutMessages = true;

	public bool enableSingleChannel;

	public Chat.ChatChannel singleChannel;

	public UIFriendsList friendsList;

	[Tooltip("Disable the text input field rather than hiding it.")]
	[Header("Disable Settings")]
	public bool useDisable;

	public RustInput rustInput;

	[FormerlySerializedAs("forceOpen")]
	public bool isMainMenuChat;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIChatPopup : MonoBehaviour
{
	public static Phrase MutePhrase = new Phrase("chat.mute", "Mute");

	public static Phrase UnmutePhrase = new Phrase("chat.unmute", "Unmute");

	public static Phrase MutedGlobalChatPhrase = new Phrase("chat.mutedglobal", "Muted global chat.");

	public static Phrase UnmutedGlobalChatPhrase = new Phrase("chat.unmutedglobal", "Unmuted global chat.");

	public UIChat Chat;

	public RustText TextToggleMute;

	public RustText TextToggleGlobalMute;

	public Button SendMessageButton;

	public Button SteamProfileButton;

	public Button MuteButton;

	public Button ReportButton;

	public GameObject AddFriendRow;

	public Button AddSteamFriendButton;

	public Button AddDiscordFriendButton;

	public GameObject InviteToTeamButton;

	public GameObject ViewInDiscordButton;

	public GameObject AcceptInviteButton;
}


using Rust.UI;
using UnityEngine;

public class UI_MainMenuChat : UIChat
{
	public static UI_MainMenuChat MenuChatInstance;

	[Header("Menu Chat")]
	public RustText placeholderText;

	public GameObject dmTargetIconSteam;

	public GameObject dmTargetIconDiscord;

	public GameObject dmTargetIconDefault;

	[Space]
	public RectTransform windowMovingParent;

	public UIEscapeCapture escapeCapture;

	public CanvasGroup dismisser;

	public override int Priority => 0;
}


using UnityEngine;

public class UI_MenuDMPicker : UIFriendsListBase
{
	public UI_MainMenuChat chat;

	public GameObjectRef FriendPrefab;

	public FriendStyleDef FriendStyle;

	public RectTransform Container;
}


using System.Collections;
using UnityEngine;
using UnityEngine.SceneManagement;

public class ChildrenFromScene : MonoBehaviour
{
	public string SceneName;

	public bool StartChildrenDisabled;

	private IEnumerator Start()
	{
		Debug.LogWarning((object)("WARNING: CHILDRENFROMSCENE(" + SceneName + ") - WE SHOULDN'T BE USING THIS SHITTY COMPONENT NOW WE HAVE AWESOME PREFABS"), (Object)(object)((Component)this).gameObject);
		Scene sceneByName = SceneManager.GetSceneByName(SceneName);
		if (!((Scene)(ref sceneByName)).isLoaded)
		{
			yield return SceneManager.LoadSceneAsync(SceneName, (LoadSceneMode)1);
		}
		sceneByName = SceneManager.GetSceneByName(SceneName);
		GameObject[] rootGameObjects = ((Scene)(ref sceneByName)).GetRootGameObjects();
		foreach (GameObject val in rootGameObjects)
		{
			val.transform.SetParent(((Component)this).transform, false);
			val.Identity();
			Transform transform = val.transform;
			RectTransform val2 = (RectTransform)(object)((transform is RectTransform) ? transform : null);
			if (Object.op_Implicit((Object)(object)val2))
			{
				val2.pivot = Vector2.zero;
				val2.anchoredPosition = Vector2.zero;
				val2.anchorMin = Vector2.zero;
				val2.anchorMax = Vector2.one;
				val2.sizeDelta = Vector2.one;
			}
			SingletonComponent[] componentsInChildren = val.GetComponentsInChildren<SingletonComponent>(true);
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				componentsInChildren[j].SingletonSetup();
			}
			if (StartChildrenDisabled)
			{
				val.SetActive(false);
			}
		}
		SceneManager.UnloadSceneAsync(sceneByName);
	}
}


using Rust.UI;

public class UIClanConfirmation : BaseMonoBehaviour
{
	public RustText Text;

	public RustText TryAgainText;
}


using Rust.UI;

public class UIClanCreator : BaseMonoBehaviour
{
	public static readonly Phrase CreateNameBlank = (Phrase)(object)new TokenisedPhrase("clan.create.name_blank", "You need to type in a name for your clan.");

	public static readonly Phrase CreateNameInvalid = (Phrase)(object)new TokenisedPhrase("clan.create.name_invalid", "The clan name you typed in is not valid.");

	public static readonly Phrase CreateAlreadyInClan = (Phrase)(object)new TokenisedPhrase("clan.create.already_in_clan", "You are already in a clan. You will need to leave your clan if you want to make a new one.");

	public static readonly Phrase CreateDuplicateName = (Phrase)(object)new TokenisedPhrase("clan.create.duplicate_name", "There is already a clan using the name you typed in. Please try a different name.");

	public static readonly Phrase CreateFailure = (Phrase)(object)new TokenisedPhrase("clan.create.fail", "Failed to create a new clan.");

	public UIClans UiClans;

	public RustInput ClanName;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIClanInvitation : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase AcceptInvitationFailure = (Phrase)(object)new TokenisedPhrase("clan.accept_invitation.fail", "Failed to accept the clan invitation.");

	public static readonly Phrase AcceptInvitationFull = (Phrase)(object)new TokenisedPhrase("clan.accept_invitation.full", "Cannot accept this clan invitation because the clan is full.");

	public static readonly Phrase DeclineInvitationFailure = (Phrase)(object)new TokenisedPhrase("clan.decline_invitation.fail", "Failed to decline the clan invitation.");

	public RustText ClanName;

	public RustText ClanMembers;

	public Image ClanBanner;

	public RawImage RecruiterAvatar;

	public RustText RecruiterName;

	public GameObject ActionsContainer;
}


using UnityEngine;

public class UIClanInvitations : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform InvitationList;

	public GameObjectRef InvitationPrefab;
}


using Rust.UI;
using UnityEngine.UI;

public class UIClanInvite : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase CancelInviteFailure = (Phrase)(object)new TokenisedPhrase("clan.cancel_invite.fail", "Failed to revoke the clan invitation.");

	public RawImage Avatar;

	public RustText Name;

	public RustText Recruiter;

	public RustText Created;

	public RustButton CancelButton;
}


using UnityEngine;

public class UIClanInvites : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform InviteList;

	public GameObjectRef InvitePrefab;
}


using UnityEngine;

public class UIClanLeaderboard : BaseMonoBehaviour
{
	public UIClans UiClans;

	public GameObject LoadingIndicator;

	public GameObject Content;

	public RectTransform EntryList;

	public GameObjectRef EntryPrefab;
}


using Rust.UI;
using UnityEngine;

public class UIClanLeaderboardEntry : MonoBehaviour
{
	public RustText ClanName;

	public RustText Score;
}


using UnityEngine;

public class UIClanLog : BaseMonoBehaviour
{
	public static readonly Phrase RefreshFailure = (Phrase)(object)new TokenisedPhrase("clan.refresh_log.fail", "Failed to load the clan event log from the server.");

	public UIClans UiClans;

	public RectTransform EntryList;

	public GameObjectRef EntryPrefab;
}


using Rust.UI;

public class UIClanLogEntry : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase FoundedEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.founded", "The clan was founded by {0}.");

	public static readonly Phrase SetMotdEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_motd", "{0} has updated the clan's message of the day.");

	public static readonly Phrase SetLogoEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_logo", "{0} has updated the clan's logo.");

	public static readonly Phrase SetColorEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_color", "{0} has changed the clan's banner color to #{1}.");

	public static readonly Phrase InviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.invite", "{1} was invited to the clan by {0}.");

	public static readonly Phrase LeaveEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.leave", "{0} has left the clan.");

	public static readonly Phrase KickEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.kick", "{1} was kicked out of the clan by {0}.");

	public static readonly Phrase AcceptInviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.accept_invite", "{0} has joined the clan.");

	public static readonly Phrase DeclineInviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.decline_invite", "{0} has declined their clan invitation.");

	public static readonly Phrase CancelInviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.cancel_invite", "{0} has cancelled {1}'s clan invitation.");

	public static readonly Phrase CreateRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.create_role", "{0} has created a new role {1}.");

	public static readonly Phrase UpdateRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.update_role", "{0} has updated the role {1}.");

	public static readonly Phrase UpdateRoleRenamedEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.update_role_renamed", "{0} has updated the role {1} and renamed it to {2}.");

	public static readonly Phrase SwapRolesEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.swap_roles", "{0} has swapped the positions of roles {1} and {2}.");

	public static readonly Phrase DeleteRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.delete_role", "{0} has deleted the role {1}.");

	public static readonly Phrase ChangeRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.change_role", "{0} has changed the role of {1} from {2} to {3}.");

	public static readonly Phrase SetNotesEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_notes", "{0} set the notes for {1} to {2}.");

	public RustText Event;

	public RustText Time;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIClanMember : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static Phrase OnlinePhrase = new Phrase("clan.member.online", "Online");

	public Image Highlight;

	public Color HighlightColor;

	public Color SelectedColor;

	public RawImage Avatar;

	public RustText Name;

	public RustText Rank;

	public RustText LastSeen;
}


using Rust.UI;
using UnityEngine;

public class UIClanMemberDetails : UIClanMember
{
	public static readonly Phrase KickConfirmation = new Phrase("clan.confirmation.kick", "Are you sure you want to kick this player out of your clan?");

	public static readonly Phrase SaveNotesFailure = (Phrase)(object)new TokenisedPhrase("clan.set_member_notes.fail", "Failed to save your updated player notes.");

	public static readonly Phrase ChangeRankCannotDemoteLeader = (Phrase)(object)new TokenisedPhrase("clan.change_member_rank.cannot_demote_leader", "As a clan leader, you cannot demote yourself unless you promote another clan member to the leader role.");

	public static readonly Phrase ChangeRankFailure = (Phrase)(object)new TokenisedPhrase("clan.change_member_rank.fail", "Failed to change the rank of the player.");

	public static readonly Phrase KickFailure = (Phrase)(object)new TokenisedPhrase("clan.kick_member.fail", "Failed to kick the player out of the clan.");

	public UIClans UiClans;

	public RustInput NoteEditor;

	public RustButton SaveNoteButton;

	public GameObject ChangeRankSection;

	public Dropdown ChangeRankDropdown;

	public GameObject KickSection;

	public RustButton KickButton;
}


using UnityEngine;

public class UIClanMembers : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform MemberList;

	public GameObjectRef MemberPrefab;

	public UIClanMemberDetails MemberDetails;
}


using Rust.UI;
using UnityEngine.UI;

public class UIClanOverview : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase SetMotdFailure = (Phrase)(object)new TokenisedPhrase("clan.set_motd.fail", "Failed to update the message of the day.");

	public UIClans UiClans;

	public RawImage MotdAuthorAvatar;

	public RustText MotdAuthorName;

	public RustText MotdTime;

	public RustInput MotdInput;

	public RustButton MotdSaveButton;

	public RustButton MotdCancelButton;
}


using System;
using Rust.UI;
using UnityEngine.UI;

public class UIClanRank : BaseMonoBehaviour
{
	public static readonly Phrase MoveUpFailure = (Phrase)(object)new TokenisedPhrase("clan.move_rank_up.fail", "Failed to move the rank up.");

	public static readonly Phrase MoveDownFailure = (Phrase)(object)new TokenisedPhrase("clan.move_rank_down.fail", "Failed to move the rank down.");

	public static readonly Phrase DeleteRankFailure = (Phrase)(object)new TokenisedPhrase("clan.delete_rank.fail", "Failed to delete the rank.");

	public static readonly Phrase DeleteRankNotEmpty = new Phrase("clan.delete_rank.not_empty", "Some clan members are still be assigned this rank. You will need to assign them to a different rank before you can delete this one.");

	private static readonly Memoized<string, int> IndexToString = new Memoized<string, int>((Func<int, string>)((int i) => (i + 1).ToString("G")));

	public Image Highlight;

	public RustText IndexLabel;

	public RustText Name;

	public RustButton MoveUpButton;

	public RustButton MoveDownButton;

	public RustButton DeleteButton;
}


using Rust.UI;

public class UIClanRankCreator : BaseMonoBehaviour
{
	public static readonly Phrase CreateRankFailure = (Phrase)(object)new TokenisedPhrase("clan.create_rank.fail", "Failed to create the new rank.");

	public static readonly Phrase CreateRankDuplicate = (Phrase)(object)new TokenisedPhrase("clan.create_rank.duplicate", "There is already a rank in your clan with that name.");

	public static readonly Phrase CreateRankNameInvalid = (Phrase)(object)new TokenisedPhrase("clan.create_rank.name_invalid", "The clan rank name you typed in is not valid.");

	public UIClans UiClans;

	public RustInput RankName;

	public RustButton Submit;
}


using Rust.UI;

public class UIClanRankEditor : BaseMonoBehaviour
{
	public static readonly Phrase SaveRankFailure = (Phrase)(object)new TokenisedPhrase("clan.save_rank.fail", "Failed to save your changes to the rank.");

	public static readonly Phrase SaveRankDuplicate = (Phrase)(object)new TokenisedPhrase("clan.save_rank.duplicate", "There is already a rank in your clan with that name.");

	public UIClans UiClans;

	public RustInput NameEditor;

	public RustButton SetMotd;

	public RustButton SetLogo;

	public RustButton Invite;

	public RustButton Kick;

	public RustButton Promote;

	public RustButton Demote;

	public RustButton SetPlayerNotes;

	public RustButton AccessLogs;

	public RustButton AccessScoreEvents;

	public RustButton CancelButton;

	public RustButton SubmitButton;
}


using UnityEngine;

public class UIClanRanks : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform RankContainer;

	public GameObjectRef RankPrefab;

	public UIClanRankCreator RankCreator;

	[Header("Sections")]
	public RectTransform RankListing;

	public UIClanRankEditor RankEditor;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIClans : SingletonComponent<UIClans>
{
	public static readonly Phrase LeaveConfirmation = new Phrase("clan.confirmation.leave", "Are you sure you want to leave your clan?");

	public static readonly Phrase GetInvitationsFailure = (Phrase)(object)new TokenisedPhrase("clan.get_invitations.fail", "Failed to load your clan invitations from the server.");

	public static readonly Phrase GetClanFailure = (Phrase)(object)new TokenisedPhrase("clan.get_clan.fail", "Failed to load your clan from the server.");

	public static readonly Phrase LeaveFailure = (Phrase)(object)new TokenisedPhrase("clan.leave.fail", "Failed to leave your clan.");

	public static readonly Phrase LeaveNoOtherLeader = (Phrase)(object)new TokenisedPhrase("clan.leave.no_other_leader", "As a clan leader, you cannot leave your clan unless it is empty or you promote another member to the leader role.");

	public CanvasGroup CanvasGroup;

	public UIEscapeCapture EscapeCapture;

	public NeedsCursor NeedsCursor;

	public NeedsKeyboard NeedsKeyboard;

	public GameObject ClanTableRequired;

	[Header("States")]
	public GameObject EmptyState;

	public GameObject CreateState;

	public GameObject InvitesState;

	public GameObject MainState;

	[Header("General")]
	public RustText ClanName;

	public Image ClanBanner;

	public RawImage ClanLogo;

	public RustText ClanMembers;

	public RustText ClanScore;

	public RustButton LeaveButton;

	public Texture2D DefaultLogo;

	public RustButton OverviewButton;

	public RustButton ScoreEventsButton;

	public RustButton LogsButton;

	public RustButton SettingsButton;

	public RustButton CreatePrompt;

	public CanvasGroup LoadingIndicator;

	public UIClanLeaderboard Leaderboard;

	public UIClanConfirmation Confirmation;

	public UIClanConfirmation Error;

	[Header("Tabs")]
	public UIClanInvitations Invitations;

	public UIClanOverview Overview;

	public UIClanMembers Members;

	public UIClanInvites Invites;

	public UIClanRanks Ranks;

	public UIClanScoreEvents ScoreEvents;

	public UIClanLog Logs;

	public UIClanSettings Settings;
}


using UnityEngine;

public class UIClanScoreEvents : BaseMonoBehaviour
{
	public static readonly Phrase RefreshFailure = (Phrase)(object)new TokenisedPhrase("clan.refresh_score_events.fail", "Failed to load the clan score event log from the server.");

	public UIClans UiClans;

	public RectTransform EntryList;

	public GameObjectRef EntryPrefab;
}


using Rust.UI;

public class UIClanScoreEventsEntry : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase ClanPlayerKilledEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.clan_player_killed", "{0} killed {1}, member of clan {2}.");

	public static readonly Phrase ClanPlayerDiedEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.clan_player_died", "{0} was killed by {1}, member of clan {2}.");

	public static readonly Phrase KilledUnarmedEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.killed_unarmed", "{0} killed {1} when they were unarmed.");

	public static readonly Phrase DestroyedToolCupboardEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.destroyed_tool_cupboard", "{0} destroyed a Tool Cupboard owned by clan {1}.");

	public static readonly Phrase HackedCrateEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.hacked_crate", "{0} hacked a locked crate.");

	public static readonly Phrase OpenedHackedCrateEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.opened_hacked_crate", "{0} opened a hacked crate.");

	public static readonly Phrase DestroyedBradleyEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.destroyed_bradley", "{0} destroyed Bradley APC.");

	public static readonly Phrase RanExcavatorEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.ran_excavator", "{0} ran the Giant Excavator.");

	public static readonly Phrase ReachedCargoShipEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.boarded_cargo_ship", "{0} has boarded a Cargo Ship.");

	public static readonly Phrase LootedEliteCrateEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.looted_elite_crate", "{0} has looted an Elite Crate.");

	public static readonly Phrase UnknownEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.unknown", "{0} did something (event type = {1}).");

	public RustText Event;

	public RustText Score;

	public RustText Multiplier;

	public RustText Time;
}


using Rust.UI;
using UnityEngine;

public class UIClanSettings : BaseMonoBehaviour
{
	public static readonly Phrase SetLogoFailure = (Phrase)(object)new TokenisedPhrase("clan.set_logo.fail", "Failed to update the clan logo.");

	public static readonly Phrase SetColorFailure = (Phrase)(object)new TokenisedPhrase("clan.set_color.fail", "Failed to update the clan banner color.");

	public UIClans UiClans;

	[Header("Logo Editing")]
	public RustButton EditLogoButton;

	public GameObjectRef ChangeSignDialog;

	public MeshPaintableSource[] PaintableSources;

	[Header("Banner Colors")]
	public RectTransform ColorsContainer;
}


public interface IUIPlayerRefreshCallback
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class CompassMapMarker : MonoBehaviour
{
	public Image MarkerImage;

	public Image MarkerImageOuter;

	public GameObject LeaderRoot;

	public RustText MarkerLabel;
}


using UnityEngine;
using UnityEngine.UI;

public class CompassMissionMarker : MonoBehaviour
{
	public Image Icon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ConsoleUI : SingletonComponent<ConsoleUI>
{
	public RustText text;

	public InputField outputField;

	public InputField inputField;

	public GameObject AutocompleteDropDown;

	public GameObject ItemTemplate;

	public Color errorColor;

	public Color warningColor;

	public Color inputColor;
}


public static class ContextMenuUI
{
	public enum MenuType
	{
		Use,
		RightClick,
		Reload,
		Gesture,
		Pet,
		Ping
	}
}


public enum MenuType
{
	Use,
	RightClick,
	Reload,
	Gesture,
	Pet,
	Ping
}


using UnityEngine;

public class ConvarToggleChildren : MonoBehaviour
{
	public string ConvarName;

	public string ConvarEnabled = "True";

	private bool state;

	private Command Command;

	protected void Awake()
	{
		Command = Client.Find(ConvarName);
		if (Command == null)
		{
			Command = Server.Find(ConvarName);
		}
		if (Command != null)
		{
			SetState(Command.String == ConvarEnabled);
		}
	}

	protected void Update()
	{
		if (Command != null)
		{
			bool flag = Command.String == ConvarEnabled;
			if (state != flag)
			{
				SetState(flag);
			}
		}
	}

	private void SetState(bool newState)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in ((Component)this).transform)
		{
			((Component)item).gameObject.SetActive(newState);
		}
		state = newState;
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class CopyText : MonoBehaviour
{
	public RustText TargetText;

	public void TriggerCopy()
	{
		if ((Object)(object)TargetText != (Object)null)
		{
			GUIUtility.systemCopyBuffer = ((TMP_Text)TargetText).text;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public abstract class CostIndicatorRow : MonoBehaviour
{
	public RustText ItemName;

	public Image ItemSprite;

	public RustText Amount;

	public RectTransform FillRect;

	public Image BackgroundImage;

	public Color OkColour;

	public Color MissingColour;

	public ItemDefinition currentDef { get; private set; }
}


using UnityEngine;
using UnityEngine.UI;

public class Crosshair : BaseMonoBehaviour
{
	public static bool Enabled = true;

	public Image Image;

	public RectTransform reticleTransform;

	public CanvasGroup reticleAlpha;

	public RectTransform hitNotifyMarker;

	public CanvasGroup hitNotifyAlpha;

	public static Crosshair instance;

	public static float lastHitTime = 0f;

	public float crosshairAlpha = 0.75f;

	public float aimconeMultiplier = 3f;

	public float aimconeLerpSpeed = 15f;

	public GameObjectRef pointsSplashEffect;
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class CursorManager : SingletonComponent<CursorManager>
{
	private static int iHoldOpen;

	private static int iPreviousOpen;

	private static float lastTimeVisible;

	private static float lastTimeInvisible;

	private void Update()
	{
		if (!((Object)(object)SingletonComponent<CursorManager>.Instance != (Object)(object)this))
		{
			if (iHoldOpen == 0 && iPreviousOpen == 0)
			{
				SwitchToGame();
			}
			else
			{
				SwitchToUI();
			}
			iPreviousOpen = iHoldOpen;
			iHoldOpen = 0;
		}
	}

	public void SwitchToGame()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		if ((int)Cursor.lockState != 1)
		{
			Cursor.lockState = (CursorLockMode)1;
		}
		if (Cursor.visible)
		{
			Cursor.visible = false;
		}
		lastTimeInvisible = Time.time;
	}

	private void SwitchToUI()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if ((int)Cursor.lockState != 0)
		{
			Cursor.lockState = (CursorLockMode)0;
		}
		if (!Cursor.visible)
		{
			Cursor.visible = true;
		}
		lastTimeVisible = Time.time;
	}

	public static void HoldOpen(int frames = 1)
	{
		iHoldOpen += frames;
	}

	public static bool WasVisible(float deltaTime)
	{
		return Time.time - lastTimeVisible <= deltaTime;
	}

	public static bool WasInvisible(float deltaTime)
	{
		return Time.time - lastTimeInvisible <= deltaTime;
	}
}


using UnityEngine;

public class NeedsCursor : MonoBehaviour, IClientComponent
{
	private void Update()
	{
		CursorManager.HoldOpen();
	}
}


public class NeedsMouseWheel : ListComponent<NeedsMouseWheel>
{
	public static bool AnyActive()
	{
		return ListComponent<NeedsMouseWheel>.InstanceList.Count > 0;
	}
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
public class DamageToggle : MonoBehaviour
{
	public Toggle toggle;

	private void Reset()
	{
		toggle = ((Component)this).GetComponent<Toggle>();
	}
}


public class ContainerSourceLocalPlayer : ItemContainerSource
{
	public PlayerInventory.Type type;

	public bool hideInvalidIcons;

	private ItemIcon[] allIcons;

	public override ItemContainer GetItemContainer()
	{
		return null;
	}
}


public class ContainerSourceLoot : ItemContainerSource
{
	public int container;

	public override ItemContainer GetItemContainer()
	{
		return null;
	}
}


public class ContainerSourceSelectedItem : ItemContainerSource
{
	public override ItemContainer GetItemContainer()
	{
		return null;
	}
}


using UnityEngine;

public abstract class ItemContainerSource : MonoBehaviour
{
	public abstract ItemContainer GetItemContainer();
}


using Rust.UI;
using UnityEngine.UI;

public class ButtonIcon : RustButton
{
	public Image Image;
}


using Rust.UI;

public class DebugCameraInfoReadout : SingletonComponent<DebugCameraInfoReadout>
{
	public RustText ReadoutText;
}


using UnityEngine;

public class DemoPlaybackUI : SingletonComponent<DemoPlaybackUI>
{
	public GameObject Root;
}


using Rust.UI;
using UnityEngine;

public class DemoPlaybackWidget : SingletonComponent<DemoPlaybackWidget>
{
	public RustSlider DemoProgress;

	public RustText DemoName;

	public RustText DemoDuration;

	public RustText DemoCurrentTime;

	public GameObject PausedRoot;

	public GameObject PlayingRoot;

	public RectTransform DemoPlaybackHandle;

	public RectTransform ShotPlaybackWindow;

	public RustButton LoopButton;

	public GameObject ShotButtonRoot;

	public RustText ShotNameText;

	public GameObject ShotNameRoot;

	public RectTransform ShotRecordWindow;

	public CanvasGroup InteractionBlocker;
}


using UnityEngine;

public class DemoRootFade : MonoBehaviour
{
	public CanvasGroup Canvas;
}


using Rust.UI;
using UnityEngine.EventSystems;

public class DemoShotButton : RustButton, IPointerClickHandler, IEventSystemHandler
{
	public bool FireEventOnClicked;

	public override void OnPointerDown(PointerEventData eventData)
	{
		if (!FireEventOnClicked)
		{
			((RustButton)this).OnPointerDown(eventData);
		}
	}

	public override void OnPointerUp(PointerEventData eventData)
	{
		if (!FireEventOnClicked)
		{
			((RustButton)this).OnPointerUp(eventData);
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (FireEventOnClicked)
		{
			((RustButton)this).Press();
		}
	}
}


using Rust.UI;
using UnityEngine;

public class DemoShotEntry : MonoBehaviour
{
	public RustButton PlayButton;

	public Sprite DragSprite;

	public RustInput RenameInput;
}


using Rust.UI;
using UnityEngine;

public class DemoShotListFolderWidget : MonoBehaviour
{
	public RustButton FolderName;

	public Transform ChildRoot;

	public GameObject UpArrow;

	public GameObject DownArrow;

	public RustText CountText;

	public GameObject OpenRoot;

	public GameObject ModifyRoot;

	public RustInput FolderRenameInput;
}


using UnityEngine;

public class DemoShotListRootFolder : MonoBehaviour
{
}


using Rust.UI;
using UnityEngine;

public class DemoShotListWidget : SingletonComponent<DemoShotListWidget>
{
	public GameObjectRef ShotListEntry;

	public GameObjectRef FolderEntry;

	public Transform ShotListParent;

	public RustInput FolderNameInput;

	public GameObject ShotsRoot;

	public GameObject NoShotsRoot;

	public GameObject TopUpArrow;

	public GameObject TopDownArrow;

	public Canvas DragCanvas;
}


using Rust.UI;
using UnityEngine;

public class DemoShotRecordWidget : MonoBehaviour
{
	public RustInput NameInput;

	public GameObject RecordingRoot;

	public GameObject PreRecordingRoot;

	public RustButton CountdownToggle;

	public RustButton PauseOnSaveToggle;

	public RustButton ReturnToStartToggle;

	public RustButton RecordDofToggle;

	public RustOption FolderDropdown;

	public GameObject RecordingUnderlay;

	public AudioSource CountdownAudio;

	public GameObject ShotRecordTime;

	public RustText ShotRecordTimeText;

	public RustText ShotNameText;

	public GameObject RecordingInProcessRoot;

	public GameObject CountdownActiveRoot;

	public GameObject CountdownActiveSliderRoot;

	public RustSlider CountdownActiveSlider;

	public RustText CountdownActiveText;
}


using Rust.UI;
using UnityEngine;

public class DemoText : MonoBehaviour
{
	public RustText TimeText;

	public RustText TotalSecondText;

	public RustText TimeScaleText;

	public RustText FilenameText;

	public RustText DateTimeText;

	public RustText ParentText;

	public RustText DofText;

	public RustText ParentBone;

	public GameObject InternalRoot;

	public GameObject ParentRoot;

	public GameObject DofRoot;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class KeyframeView : MonoBehaviour
{
	public ScrollRect Scroller;

	public GameObjectRef KeyframePrefab;

	public RectTransform KeyframeRoot;

	public Transform CurrentPositionIndicator;

	public bool LockScrollToCurrentPosition;

	public RustText TrackName;
}


using UnityEngine;

public class KeyframeWidget : MonoBehaviour
{
	public Tooltip AttachedTooltip;
}


using Rust.UI;
using UnityEngine;

public class DemoRecorder : SingletonComponent<DemoRecorder>
{
	public RustInput nameInputField;

	public GameObject RecordingUnderlay;

	public GameObject Panel;

	public CanvasGroup CanvasGroup;

	public UIConfirmationPopup confirmationPopup;

	public RustButton autofillButton;

	private bool autoFill;

	public static readonly Phrase overwritePhrase = new Phrase("demo.overwrite", "You are about to overwrite a demo with the same name as {0} - proceed?");
}


using Rust.UI;
using UnityEngine;

public class DemoRecorderProgress : SingletonComponent<DemoRecorderProgress>
{
	public RustText RecordingLabel;

	public RustText ProgressLabel;

	public GameObject RecordingUnderlay;
}


using UnityEngine;
using UnityEngine.UI;

public class DeveloperTools : SingletonComponent<DeveloperTools>
{
	public GameObject developerTools;

	public GameObject navButton;

	public GameObject panelContainer;

	public Text ConsoleInput;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackMainScreenUI : FacepunchBehaviour
{
	[SerializeField]
	private Canvas inGameDisplay;

	[SerializeField]
	private Canvas notInGameDisplay;

	[SerializeField]
	private Sprite faceNeutral;

	[SerializeField]
	private Sprite faceShocked;

	[SerializeField]
	private Sprite faceSad;

	[SerializeField]
	private Sprite faceCool;

	[SerializeField]
	private Sprite faceHappy;

	[SerializeField]
	private Sprite faceLove;

	[SerializeField]
	private Image faceInGame;

	[SerializeField]
	private Image faceNotInGame;

	[SerializeField]
	private Sprite[] faceNeutralVariants;

	[SerializeField]
	private Sprite[] faceHalloweenVariants;

	[SerializeField]
	private RustText cardCountText;

	[SerializeField]
	private RustText payoutText;

	[SerializeField]
	private RustText insuranceText;

	[SerializeField]
	private Canvas placeBetsCanvas;

	[SerializeField]
	private HorizontalLayoutGroup cardsLayout;

	[SerializeField]
	private BlackjackScreenCardUI[] cards;

	[SerializeField]
	private Phrase phraseBust;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackScreenCardUI : FacepunchBehaviour
{
	[SerializeField]
	private Canvas baseCanvas;

	[SerializeField]
	private Canvas cardFront;

	[SerializeField]
	private Canvas cardBack;

	[SerializeField]
	private Image image;

	[SerializeField]
	private RustText text;

	[SerializeField]
	private Sprite heartSprite;

	[SerializeField]
	private Sprite diamondSprite;

	[SerializeField]
	private Sprite spadeSprite;

	[SerializeField]
	private Sprite clubSprite;
}


using Rust.UI;
using UnityEngine;

public class BlackjackScreenInputUI : MonoBehaviour
{
	[SerializeField]
	private Canvas availableOption;

	[SerializeField]
	private Canvas unavailableOption;

	[SerializeField]
	private RustText availableOptionText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackSmallScreenUI : FacepunchBehaviour
{
	[SerializeField]
	private Canvas notInGameDisplay;

	[SerializeField]
	private Canvas inGameDisplay;

	[SerializeField]
	private RustText cardCountText;

	[SerializeField]
	private RustText betText;

	[SerializeField]
	private RustText splitBetText;

	[SerializeField]
	private RustText insuranceText;

	[SerializeField]
	private RustText bankText;

	[SerializeField]
	private RustText splitText;

	[SerializeField]
	private Canvas infoTextCanvas;

	[SerializeField]
	private RustText inGameText;

	[SerializeField]
	private RustText notInGameText;

	[SerializeField]
	private HorizontalLayoutGroup cardsLayout;

	[SerializeField]
	private BlackjackScreenCardUI[] cards;

	[SerializeField]
	private BlackjackScreenInputUI[] inputs;

	[SerializeField]
	private Phrase phraseBust;

	[SerializeField]
	private Phrase phraseBet;

	[SerializeField]
	private Phrase phrasePlaceYourBet;

	[SerializeField]
	private Phrase phraseStandoff;

	[SerializeField]
	private Phrase phraseYouWin;

	[SerializeField]
	private Phrase phraseYouLose;

	[SerializeField]
	private Phrase phraseWaitingForOtherPlayers;

	[SerializeField]
	private Phrase phraseAddFunds;

	[SerializeField]
	private Phrase phraseWaitingForPlayer;

	[SerializeField]
	private Phrase phraseSplitStored;

	[SerializeField]
	private Phrase phraseSplitActive;

	[SerializeField]
	private Phrase phraseHand;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackUI : MonoBehaviour
{
	[SerializeField]
	private Image[] playerCardImages;

	[SerializeField]
	private Image[] dealerCardImages;

	[SerializeField]
	private Image[] splitCardImages;

	[SerializeField]
	private Image[] playerCardBackings;

	[SerializeField]
	private Image[] dealerCardBackings;

	[SerializeField]
	private Image[] splitCardBackings;

	[SerializeField]
	private CardGamePlayerWidget[] playerWidgets;

	[SerializeField]
	private GameObject dealerValueObj;

	[SerializeField]
	private RustText dealerValueText;

	[SerializeField]
	private GameObject yourValueObj;

	[SerializeField]
	private RustText yourValueText;

	[SerializeField]
	private Phrase phrasePlaceYourBet;

	[SerializeField]
	private Phrase phraseHit;

	[SerializeField]
	private Phrase phraseStand;

	[SerializeField]
	private Phrase phraseSplit;

	[SerializeField]
	private Phrase phraseDouble;

	[SerializeField]
	private Phrase phraseInsurance;

	[SerializeField]
	private Phrase phraseBust;

	[SerializeField]
	private Phrase phraseBlackjack;

	[SerializeField]
	private Phrase phraseStandoff;

	[SerializeField]
	private Phrase phraseYouWin;

	[SerializeField]
	private Phrase phraseYouLose;

	[SerializeField]
	private Phrase phraseWaitingForOtherPlayers;

	[SerializeField]
	private Phrase phraseHand;

	[SerializeField]
	private Phrase phraseInsurancePaidOut;

	[SerializeField]
	private Sprite insuranceIcon;

	[SerializeField]
	private Sprite noIcon;

	[SerializeField]
	private Color bustTextColour;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class CardGamePlayerWidget : MonoBehaviour
{
	[SerializeField]
	private GameObjectRef cardImageSmallPrefab;

	[SerializeField]
	private RawImage avatar;

	[SerializeField]
	private RustText playerName;

	[SerializeField]
	private RustText scrapTotal;

	[SerializeField]
	private RustText betText;

	[SerializeField]
	private Image background;

	[SerializeField]
	private Color inactiveBackground;

	[SerializeField]
	private Color activeBackground;

	[SerializeField]
	private Color foldedBackground;

	[SerializeField]
	private Color winnerBackground;

	[SerializeField]
	private Animation actionShowAnimation;

	[SerializeField]
	private RustText actionText;

	[SerializeField]
	private Sprite canSeeIcon;

	[SerializeField]
	private Sprite cannotSeeIcon;

	[SerializeField]
	private Sprite blankSprite;

	[SerializeField]
	private Image cornerIcon;

	[SerializeField]
	private Transform cardDisplayParent;

	[SerializeField]
	private GridLayoutGroup cardDisplayGridLayout;

	[SerializeField]
	private GameObject circle;

	[SerializeField]
	private RustText circleText;
}


using System;
using Facepunch.CardGames;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class CardGameUI : UIDialog
{
	[Serializable]
	public class PlayingCardImage
	{
		public Rank rank;

		public Suit suit;

		public Sprite image;

		public Sprite imageSmall;

		public Sprite imageTransparent;
	}

	[Serializable]
	public class InfoTextUI
	{
		public enum Attitude
		{
			Neutral,
			Good,
			Bad
		}

		public GameObject gameObj;

		public RustText rustText;

		public Image background;
	}

	public interface ICardGameSubUI
	{
		int DynamicBetAmount { get; }

		void UpdateInGameUI(CardGameUI ui, CardGameController game);

		string GetSecondaryInfo(CardGameUI ui, CardGameController game, out InfoTextUI.Attitude attitude);

		void UpdateInGameUI_NoPlayer(CardGameUI ui);
	}

	[Header("Card Game")]
	[SerializeField]
	private InfoTextUI primaryInfo;

	[SerializeField]
	private InfoTextUI secondaryInfo;

	[SerializeField]
	private InfoTextUI playerLeaveInfo;

	[SerializeField]
	private GameObject playingUI;

	[SerializeField]
	private PlayingCardImage[] cardImages;

	[SerializeField]
	private CardInputWidget[] inputWidgets;

	[SerializeField]
	private RustSlider dismountProgressSlider;

	[SerializeField]
	private Phrase phraseLoading;

	[SerializeField]
	private Phrase phraseWaitingForNextRound;

	[SerializeField]
	private Phrase phraseNotEnoughPlayers;

	[SerializeField]
	private Phrase phrasePlayerLeftGame;

	[SerializeField]
	private Phrase phraseNotEnoughBuyIn;

	[SerializeField]
	private Phrase phraseTooMuchBuyIn;

	public Phrase phraseYourTurn;

	public Phrase phraseYouWinTheRound;

	public Phrase phraseRoundWinner;

	public Phrase phraseRoundWinners;

	public Phrase phraseScrapWon;

	public Phrase phraseScrapReturned;

	public Phrase phraseChangeBetAmount;

	public Phrase phraseBet;

	public Phrase phraseBetAdd;

	public Phrase phraseAllIn;

	public GameObject amountChangeRoot;

	public RustText amountChangeText;

	public Color colourNeutralUI;

	public Color colourGoodUI;

	public Color colourBadUI;

	[SerializeField]
	private CanvasGroup timerCanvas;

	[SerializeField]
	private RustSlider timerSlider;

	[SerializeField]
	private UIChat chat;

	[SerializeField]
	private HudElement Hunger;

	[SerializeField]
	private HudElement Thirst;

	[SerializeField]
	private HudElement Health;

	[SerializeField]
	private HudElement PendingHealth;

	public Sprite cardNone;

	public Sprite cardBackLarge;

	public Sprite cardBackSmall;

	private static Sprite cardBackLargeStatic;

	private static Sprite cardBackSmallStatic;

	[SerializeField]
	private TexasHoldEmUI texasHoldEmUI;

	[SerializeField]
	private BlackjackUI blackjackUI;
}


using System;
using Facepunch.CardGames;
using UnityEngine;

[Serializable]
public class PlayingCardImage
{
	public Rank rank;

	public Suit suit;

	public Sprite image;

	public Sprite imageSmall;

	public Sprite imageTransparent;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public class InfoTextUI
{
	public enum Attitude
	{
		Neutral,
		Good,
		Bad
	}

	public GameObject gameObj;

	public RustText rustText;

	public Image background;
}


public enum Attitude
{
	Neutral,
	Good,
	Bad
}


using Facepunch.CardGames;

public interface ICardGameSubUI
{
	int DynamicBetAmount { get; }

	void UpdateInGameUI(CardGameUI ui, CardGameController game);

	string GetSecondaryInfo(CardGameUI ui, CardGameController game, out InfoTextUI.Attitude attitude);

	void UpdateInGameUI_NoPlayer(CardGameUI ui);
}


using Rust.UI;
using UnityEngine;

public class CardInputWidget : MonoBehaviour
{
	public RustText InputText;

	public RustText ActionText;

	public RustText ExtraText;
}


using UnityEngine;
using UnityEngine.UI;

public class PlayingCardSprite : MonoBehaviour
{
	[SerializeField]
	private Image image;

	[SerializeField]
	private Animation anim;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class TexasHoldEmUI : MonoBehaviour
{
	[SerializeField]
	private Image[] holeCardImages;

	[SerializeField]
	private Image[] holeCardBackings;

	[SerializeField]
	[FormerlySerializedAs("flopCardImages")]
	private Image[] communityCardImages;

	[SerializeField]
	private Image[] communityCardBackings;

	[SerializeField]
	private RustText potText;

	[SerializeField]
	private CardGamePlayerWidget[] playerWidgets;

	[SerializeField]
	private Phrase phraseWinningHand;

	[SerializeField]
	private Phrase foldPhrase;

	[SerializeField]
	private Phrase raisePhrase;

	[SerializeField]
	private Phrase checkPhrase;

	[SerializeField]
	private Phrase callPhrase;

	[SerializeField]
	private Phrase phraseRoyalFlush;

	[SerializeField]
	private Phrase phraseStraightFlush;

	[SerializeField]
	private Phrase phraseFourOfAKind;

	[SerializeField]
	private Phrase phraseFullHouse;

	[SerializeField]
	private Phrase phraseFlush;

	[SerializeField]
	private Phrase phraseStraight;

	[SerializeField]
	private Phrase phraseThreeOfAKind;

	[SerializeField]
	private Phrase phraseTwoPair;

	[SerializeField]
	private Phrase phrasePair;

	[SerializeField]
	private Phrase phraseHighCard;

	[SerializeField]
	private Phrase phraseRaiseAmount;

	[SerializeField]
	private Sprite dealerChip;

	[SerializeField]
	private Sprite smallBlindChip;

	[SerializeField]
	private Sprite bigBlindChip;

	[SerializeField]
	private Sprite noIcon;
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ChangeSignText : UIDialog
{
	public Action<int, Texture2D> onUpdateTexture;

	public Action onClose;

	public GameObject objectContainer;

	public Transform panTransform;

	public Transform rotateTransform;

	public GameObject currentFrameSection;

	public GameObject[] frameOptions;

	public Canvas canvas;

	public RectTransform rightPanelRect;

	public Camera cameraPreview;

	public Camera camera3D;

	public Light previewLight;

	public Vector3 homeRotation;

	public RectTransform toolsContainer;

	public RectTransform brushesContainer;

	public RustSlider brushSizeSlider;

	public RustSlider brushSpacingSlider;

	public RustSlider brushOpacitySlider;

	public GameObject chatToggleButton;

	public Toggle autoSaveToggle;

	[Header("Layout")]
	public FlexElement rootElement;

	public FlexElement bodyElement;

	public FlexElement controlsElement;

	public FlexElement floatElement;
}


using UnityEngine;

public class CinematicDialog : UIDialog
{
	public CanvasGroup FullFadeGroup;
}


using UnityEngine;
using UnityEngine.UI;

public class UIColorPickerButton : MonoBehaviour
{
	public Image Image;

	public Color Color = Color.white;
}


using Rust.UI;
using UnityEngine;

public class UIFireworkDesigner : UIDialog
{
	public RustInput Title;

	public RustText StarsPlaced;

	public RectTransform Canvas;

	public RectTransform InnerCanvas;

	public GameObject StarPrefab;
}


using Rust.UI;
using UnityEngine;

public class UIFireworkDesignItem : MonoBehaviour
{
	public static readonly Phrase EmptyPhrase = new Phrase("firework.pattern.design.empty", "Empty");

	public static readonly Phrase UntitledPhrase = new Phrase("firework.pattern.design.untitled", "Untitled");

	public RustText Title;

	public RustButton LoadButton;

	public RustButton SaveButton;

	public RustButton EraseButton;

	public UIFireworkDesigner Designer;

	public int Index;
}


using Rust.UI;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class UIFireworkStar : EventTrigger
{
	public Image Image;

	public RustText Text;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class KeyCodeEntry : UIDialog
{
	public Text textDisplay;

	public Action onClosed;

	public Text typeDisplay;

	public Phrase masterCodePhrase;

	public Phrase guestCodePhrase;

	public GameObject memoryKeycodeButton;
}


using UnityEngine;
using UnityEngine.UI;

public class StampClanLogo : MonoBehaviour
{
	public GameObject UiElement;

	public RawImage LogoPreview;

	public MeshPaintController Controller;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class PhoneDialler : UIDialog
{
	public GameObject DialingRoot;

	public GameObject CallInProcessRoot;

	public GameObject IncomingCallRoot;

	public RustText ThisPhoneNumber;

	public RustInput PhoneNameInput;

	public RustText textDisplay;

	public RustText CallTimeText;

	public RustButton DefaultDialViewButton;

	public RustText[] IncomingCallNumber;

	public GameObject NumberDialRoot;

	public GameObject PromptVoicemailRoot;

	public RustButton ContactsButton;

	public RustText FailText;

	public NeedsCursor CursorController;

	public NeedsKeyboard KeyboardController;

	public Phrase WrongNumberPhrase;

	public Phrase NetworkBusy;

	public Phrase Engaged;

	public GameObjectRef DirectoryEntryPrefab;

	public Transform DirectoryRoot;

	public GameObject NoDirectoryRoot;

	public RustButton DirectoryPageUp;

	public RustButton DirectoryPageDown;

	public Transform ContactsRoot;

	public RustInput ContactsNameInput;

	public RustInput ContactsNumberInput;

	public GameObject NoContactsRoot;

	public RustButton AddContactButton;

	public SoundDefinition DialToneSfx;

	public Button[] NumberButtons;

	public Phrase AnsweringMachine;

	public VoicemailDialog Voicemail;

	public GameObject VoicemailRoot;
}


using Rust.UI;
using UnityEngine;

public class PhoneDirectoryEntry : MonoBehaviour
{
	public RustText PhoneNumber;

	public RustText PhoneName;

	public GameObject DeleteIcon;

	public GameObject CensorIcon;
}


using Rust.UI;
using UnityEngine;

public class VoicemailDialog : MonoBehaviour
{
	public GameObject RecordingRoot;

	public RustSlider RecordingProgress;

	public GameObject BrowsingRoot;

	public PhoneDialler ParentDialler;

	public GameObjectRef VoicemailEntry;

	public Transform VoicemailEntriesRoot;

	public GameObject NoVoicemailRoot;

	public GameObject NoCassetteRoot;
}


using Rust.UI;
using UnityEngine;

public class VoicemailEntry : MonoBehaviour
{
	public GameObject PlayingRoot;

	public RustText DisplayName;

	public RustIcon PlayIcon;

	public RustSlider ProgressSlider;
}


using System;
using Rust.UI;
using UnityEngine;

public class PickAFriend : UIDialog
{
	public RustInput rustInput;

	public bool AutoSelectInputField;

	public bool AllowMultiple;

	public Action<ulong, string> onSelected;

	public SteamFriendsList friendsList;

	public Func<ulong, bool> shouldShowPlayer
	{
		set
		{
			if ((Object)(object)friendsList != (Object)null)
			{
				friendsList.shouldShowPlayer = value;
			}
		}
	}
}


using Rust.UI;
using UnityEngine;

public class FavouriteRadioStation : MonoBehaviour
{
	public RustText UrlText;

	public GameObject XmasRoot;
}


using Rust.UI;
using UnityEngine;

public class RadioDialog : UIDialog
{
	public RustInput IpInput;

	public GameObjectRef FavouritePrefab;

	public Transform FavouritesContainer;

	public GameObject HasCassetteRoot;

	public static RadioDialog Instance;
}


using Rust.UI;

public class SoundLightDialog : UIDialog
{
	public RustOption ColourOption;

	public RustOption VolumeOption;

	public RustOption SpeedOption;

	public RustOption PatternOption;

	public RustOption GradientOption;
}


using Rust.UI;

public class RenameSleepingBag : UIDialog
{
	public RustInput input;

	public SleepingBag bag;
}


using Rust.UI;

public class SetupAppNotification : UIDialog
{
	public RustInput titleInput;

	public RustInput bodyInput;
}


public class SprayCanSkinSelect : UIDialog
{
	public IconSkinPicker skinPicker;
}


using Rust.UI;
using UnityEngine;

public class TechTreeDialog : UIDialog, IInventoryChanged
{
	private const string techTreeLevelPrefKey = "techTreeLevel";

	private TechTreeData[] dataOptions;

	public float graphScale = 1f;

	public RustButton[] tierButtons;

	public GameObjectRef entryPrefab;

	public GameObjectRef groupPrefab;

	public GameObjectRef linePrefab;

	public RectTransform contents;

	public RectTransform contentParent;

	public TechTreeSelectedNodeUI selectedNodeUI;

	public const float nodeSize = 128f;

	public const float gridSize = 64f;

	public GameObjectRef unlockEffect;

	public RustText scrapCount;

	private Vector2 startPos = Vector2.zero;

	public ScrollRectZoom zoom;

	public TechTreeData data
	{
		get
		{
			if (dataOptions == null)
			{
				return null;
			}
			return dataOptions[selectedDataIndex];
		}
	}

	private int selectedDataIndex
	{
		get
		{
			return PlayerPrefs.GetInt("techTreeLevel", 0);
		}
		set
		{
			PlayerPrefs.SetInt("techTreeLevel", value);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class TechTreeEntry : TechTreeWidget
{
	public RawImage icon;

	public GameObject ableToUnlockBackground;

	public GameObject unlockedBackground;

	public GameObject lockedBackground;

	public GameObject lockOverlay;

	public GameObject selectedBackground;

	public Image radialUnlock;

	public float holdTime = 1f;
}


public class TechTreeGroup : TechTreeWidget
{
}


using UnityEngine.UI;

public class TechTreeLine : TechTreeWidget
{
	public RawImage center;

	public RawImage topLeft;

	public RawImage topRight;

	public RawImage bottomLeft;

	public RawImage bottomRight;

	public RawImage centerDotted;

	public RawImage topLeftDotted;

	public RawImage topRightDotted;

	public RawImage bottomLeftDotted;

	public RawImage bottomRightDotted;

	public int from;

	public int to;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class TechTreeSelectedNodeUI : MonoBehaviour
{
	public RustText selectedTitle;

	public RawImage selectedIcon;

	public RustText selectedDescription;

	public RustText costText;

	public RustText craftingCostText;

	public GameObject costObject;

	public GameObject cantAffordObject;

	public GameObject unlockedObject;

	public GameObject unlockButton;

	public GameObject noPathObject;

	public TechTreeDialog dialog;

	public Color ColorAfford;

	public Color ColorCantAfford;

	public GameObject totalRequiredRoot;

	public RustText totalRequiredText;

	public ItemInformationPanel[] informationPanels;

	public GameObject workbenchTaxRoot;

	public RustText workbenchTaxText;

	public Tooltip workbenchTaxTooltip;
}


using UnityEngine;

public class TechTreeWidget : BaseMonoBehaviour
{
	public int id;

	public RectTransform rectTransform => ((Component)this).GetComponent<RectTransform>();
}


using UnityEngine;
using UnityEngine.EventSystems;

public class ZoomImage : MonoBehaviour, IScrollHandler, IEventSystemHandler
{
	[SerializeField]
	private float _minimumScale = 0.5f;

	[SerializeField]
	private float _initialScale = 1f;

	[SerializeField]
	private float _maximumScale = 3f;

	[SerializeField]
	private float _scaleIncrement = 0.5f;

	[HideInInspector]
	private Vector3 _scale;

	private RectTransform _thisTransform;

	private void Awake()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		ref RectTransform thisTransform = ref _thisTransform;
		Transform transform = ((Component)this).transform;
		thisTransform = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		((Vector3)(ref _scale)).Set(_initialScale, _initialScale, 1f);
		((Transform)_thisTransform).localScale = _scale;
	}

	public void OnScroll(PointerEventData eventData)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		RectTransformUtility.ScreenPointToLocalPointInRectangle(_thisTransform, Vector2.op_Implicit(Input.mousePosition), (Camera)null, ref val);
		float y = eventData.scrollDelta.y;
		if (y > 0f && _scale.x < _maximumScale)
		{
			((Vector3)(ref _scale)).Set(_scale.x + _scaleIncrement, _scale.y + _scaleIncrement, 1f);
			((Transform)_thisTransform).localScale = _scale;
			RectTransform thisTransform = _thisTransform;
			thisTransform.anchoredPosition -= val * _scaleIncrement;
		}
		else if (y < 0f && _scale.x > _minimumScale)
		{
			((Vector3)(ref _scale)).Set(_scale.x - _scaleIncrement, _scale.y - _scaleIncrement, 1f);
			((Transform)_thisTransform).localScale = _scale;
			RectTransform thisTransform2 = _thisTransform;
			thisTransform2.anchoredPosition += val * _scaleIncrement;
		}
	}
}


public class UIDialog : ListComponent<UIDialog>
{
	public SoundDefinition openSoundDef;

	public SoundDefinition closeSoundDef;
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UIVideoPlayer : UIDialog
{
	public AspectRatioFitter aspectRatioFitter;

	public GameObject closeButton;

	public VideoPlayer videoPlayer;

	public RawImage videoCanvas;

	public RectTransform videoProgressBar;

	public GameObject loadingIndicator;

	public float audioDuckingAmount = 0.333f;

	public float timeoutAfter = 5f;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;

public class DynamicMouseCursor : MonoBehaviour
{
	public Texture2D RegularCursor;

	public Vector2 RegularCursorPos;

	public Texture2D HoverCursor;

	public Vector2 HoverCursorPos;

	private Texture2D current;

	private void LateUpdate()
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (!Cursor.visible)
		{
			return;
		}
		GameObject val = CurrentlyHoveredItem();
		TimeWarning val2;
		if ((Object)(object)val != (Object)null)
		{
			val2 = TimeWarning.New("RustControl", 0);
			try
			{
				RustControl componentInParent = val.GetComponentInParent<RustControl>();
				if ((Object)(object)componentInParent != (Object)null && componentInParent.IsDisabled)
				{
					UpdateCursor(RegularCursor, RegularCursorPos);
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("ISubmitHandler", 0);
			try
			{
				if (val.GetComponentInParent<ISubmitHandler>() != null)
				{
					UpdateCursor(HoverCursor, HoverCursorPos);
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("IPointerDownHandler", 0);
			try
			{
				if (val.GetComponentInParent<IPointerDownHandler>() != null)
				{
					UpdateCursor(HoverCursor, HoverCursorPos);
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		val2 = TimeWarning.New("UpdateCursor", 0);
		try
		{
			UpdateCursor(RegularCursor, RegularCursorPos);
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	private void UpdateCursor(Texture2D cursor, Vector2 offs)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)current == (Object)(object)cursor))
		{
			current = cursor;
			Cursor.SetCursor(cursor, offs, (CursorMode)0);
		}
	}

	private GameObject CurrentlyHoveredItem()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		FpStandaloneInputModule obj = EventSystem.current.currentInputModule as FpStandaloneInputModule;
		if (obj == null)
		{
			return null;
		}
		RaycastResult pointerCurrentRaycast = obj.CurrentData.pointerCurrentRaycast;
		return ((RaycastResult)(ref pointerCurrentRaycast)).gameObject;
	}
}


using UnityEngine;

public class EntityHUDRender : MonoBehaviour
{
}


using System.Diagnostics;
using Facepunch;
using Rust;
using TMPro;
using UnityEngine;

public class ErrorText : MonoBehaviour
{
	public TextMeshProUGUI text;

	public int maxLength = 1024;

	private Stopwatch stopwatch;

	public void OnEnable()
	{
		Output.OnMessage += CaptureLog;
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Output.OnMessage -= CaptureLog;
		}
	}

	internal void CaptureLog(string error, string stacktrace, LogType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Invalid comparison between Unknown and I4
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		if (((int)type == 0 || (int)type == 4 || (int)type == 1) && !((Object)(object)text == (Object)null))
		{
			TextMeshProUGUI val = text;
			((TMP_Text)val).text = ((TMP_Text)val).text + error + "\n" + stacktrace + "\n\n";
			if (((TMP_Text)text).text.Length > maxLength)
			{
				((TMP_Text)text).text = ((TMP_Text)text).text.Substring(((TMP_Text)text).text.Length - maxLength, maxLength);
			}
			stopwatch = Stopwatch.StartNew();
		}
	}

	protected void Update()
	{
		if (stopwatch != null && stopwatch.Elapsed.TotalSeconds > 30.0)
		{
			((TMP_Text)text).text = string.Empty;
			stopwatch = null;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ExpandedLifeStats : MonoBehaviour
{
	[Serializable]
	public struct GenericStatDisplay
	{
		public string statKey;

		public Sprite statSprite;

		public Phrase displayPhrase;
	}

	public GameObject DisplayRoot;

	public GameObjectRef GenericStatRow;

	[Header("Resources")]
	public Transform ResourcesStatRoot;

	public List<GenericStatDisplay> ResourceStats;

	[Header("Weapons")]
	public GameObjectRef WeaponStatRow;

	public Transform WeaponsRoot;

	[Header("Misc")]
	public Transform MiscRoot;

	public List<GenericStatDisplay> MiscStats;

	public LifeInfographic Infographic;

	public RectTransform MoveRoot;

	public Vector2 OpenPosition;

	public Vector2 ClosedPosition;

	public GameObject OpenButtonRoot;

	public GameObject CloseButtonRoot;

	public GameObject ScrollGradient;

	public ScrollRect Scroller;
}


using System;
using UnityEngine;

[Serializable]
public struct GenericStatDisplay
{
	public string statKey;

	public Sprite statSprite;

	public Phrase displayPhrase;
}


using System;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;

public class LocalizationFontFallbackSettings : BaseScriptableObject
{
	[Serializable]
	public class FontConfig
	{
		[Serializable]
		public struct LanguageFallbackFonts
		{
			public string languageName;

			public TMP_FontAsset[] fallbackFonts;
		}

		public TMP_FontAsset baseFont;

		public List<TMP_FontAsset> baseFallback;

		public List<LanguageFallbackFonts> fallbacksPerLanguage;
	}

	public List<FontConfig> fontConfigs;

	public static LocalizationFontFallbackSettings Get()
	{
		return FileSystem.Load<LocalizationFontFallbackSettings>("Assets/Content/UI/Fonts/Localization Font Fallback Settings.asset", true);
	}

	public static void UpdateFonts()
	{
		string language = Translate.GetLanguage();
		LocalizationFontFallbackSettings localizationFontFallbackSettings = Get();
		if (localizationFontFallbackSettings == null)
		{
			return;
		}
		foreach (FontConfig fontConfig in localizationFontFallbackSettings.fontConfigs)
		{
			if (!((Object)(object)fontConfig.baseFont == (Object)null))
			{
				FontConfig.LanguageFallbackFonts languageFallbackFonts = fontConfig.fallbacksPerLanguage.Find((FontConfig.LanguageFallbackFonts x) => x.languageName == language);
				if (languageFallbackFonts.fallbackFonts != null && languageFallbackFonts.fallbackFonts.Length != 0)
				{
					fontConfig.baseFont.fallbackFontAssetTable = languageFallbackFonts.fallbackFonts.Concat(fontConfig.baseFallback).Distinct().ToList();
				}
				else
				{
					fontConfig.baseFont.fallbackFontAssetTable = fontConfig.baseFallback;
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using TMPro;

[Serializable]
public class FontConfig
{
	[Serializable]
	public struct LanguageFallbackFonts
	{
		public string languageName;

		public TMP_FontAsset[] fallbackFonts;
	}

	public TMP_FontAsset baseFont;

	public List<TMP_FontAsset> baseFallback;

	public List<LanguageFallbackFonts> fallbacksPerLanguage;
}


using System;
using TMPro;

[Serializable]
public struct LanguageFallbackFonts
{
	public string languageName;

	public TMP_FontAsset[] fallbackFonts;
}


using UnityEngine.EventSystems;

public class FpStandaloneInputModule : StandaloneInputModule
{
	public PointerEventData CurrentData
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			if (!((PointerInputModule)this).m_PointerData.ContainsKey(-1))
			{
				return new PointerEventData(EventSystem.current);
			}
			return ((PointerInputModule)this).m_PointerData[-1];
		}
	}
}


using System.Diagnostics;
using UnityEngine;
using UnityEngine.UI;

public class FPSText : MonoBehaviour
{
	public Text text;

	private Stopwatch fpsTimer = Stopwatch.StartNew();

	protected void Update()
	{
		if (!(fpsTimer.Elapsed.TotalSeconds < 0.5))
		{
			((Behaviour)this.text).enabled = true;
			fpsTimer.Reset();
			fpsTimer.Start();
			string text = Performance.current.frameRate + " FPS";
			this.text.text = text;
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Friend Style")]
public class FriendStyleDef : ScriptableObject
{
	public Color32 OnlineColor;

	public Sprite OnlineIcon;

	public Color32 AwayColor;

	public Sprite AwayIcon;

	public Color32 BusyColor;

	public Sprite BusyIcon;

	public Color32 OfflineColor;

	public Sprite OfflineIcon;

	public Sprite SteamIcon;

	public Sprite DiscordIcon;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UIFriends : UI_Window
{
	public static UIFriends Instance;

	public CanvasGroup CanvasGroup;

	public RectTransform Body;

	public UIFriendsListBase FriendsList;

	public UIFriendsListButton Button;

	public GameObject DiscordSettingsButton;

	public GameObject DiscordSettingsPanel;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UIFriendsList : UIFriendsListBase
{
	public GameObjectRef FriendPrefab;

	public FriendStyleDef FriendStyle;

	public RustInput SearchInput;

	public RustButton ShowPendingToggle;

	public RustButton ShowOfflineToggle;

	public FlexElement RootElement;

	public GameObject PendingSection;

	public RustText PendingCount;

	public RectTransform PendingContainer;

	public GameObject InGameSection;

	public RustText InGameCount;

	public RectTransform InGameContainer;

	public GameObject OnlineSection;

	public RustText OnlineCount;

	public RectTransform OnlineContainer;

	public GameObject OfflineSection;

	public RustText OfflineCount;

	public RectTransform OfflineContainer;

	public GameObject LinkDiscordSection;

	public UIChat Chat;

	public UIFriendsListContextMenu ContextMenu;

	public UIParty Party;

	public UIParty FooterParty;
}


public abstract class UIFriendsListBase : ListComponent<UIFriendsListBase>
{
}


using Rust.UI;
using UnityEngine;

[RequireComponent(typeof(RustButton))]
public class UIFriendsListButton : UIFriendsListBase
{
	public GameObject OnlineTag;

	public RustFlexText OnlineCount;

	public GameObject Callout;

	public GameObject Notification;

	public CanvasGroup NotificationCanvasGroup;

	public ChatEntry ChatEntry;

	public float NotificationDuration = 5f;

	public UI_MainMenuChat chat;
}


using UnityEngine;

public class UIFriendsListContextMenu : MonoBehaviour
{
	public UIFriendsList FriendsList;

	[SerializeField]
	private CanvasGroup canvasGroup;

	public GameObject SendMessageButton;

	public GameObject InviteToGameButton;

	public GameObject JoinGameButton;

	public GameObject AddFriendSteamButton;

	public GameObject AddFriendDiscordButton;

	public GameObject PromotePartyLeaderButton;

	public GameObject KickPartyMemberButton;

	public GameObject InviteToPartyButton;

	public GameObject LeavePartyButton;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIFriendsListItem : MonoBehaviour
{
	public HttpImage Avatar;

	public RawImage AvatarImage;

	public Image StatusIndicator;

	public RustText Name;

	public GameObject NicknameSection;

	public RustText Nickname;

	public RustText Subtitle;

	public Image PlatformIcon;

	public GameObject SteamAccountTag;

	public RustText SteamAccountName;

	public GameObject PendingFriendControls;

	public GameObject PartyOwnerIcon;

	public static Phrase InvitedToPartyPhrase = new Phrase("party_invite.invited_to_party", "has invited you to a party");
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class GameStat : MonoBehaviour
{
	[Serializable]
	public struct Stat
	{
		public string statName;

		public string statTitle;
	}

	public float refreshTime = 5f;

	public Text title;

	public Text globalStat;

	public Text localStat;

	private long globalValue;

	private long localValue;

	private float secondsSinceRefresh;

	private float secondsUntilUpdate;

	private float secondsUntilChange;

	public Stat[] stats;
}


using System;

[Serializable]
public struct Stat
{
	public string statName;

	public string statTitle;
}


using UnityEngine;
using UnityEngine.UI;

public class CustomGestureWidget : MonoBehaviour, IClientComponent
{
	public PieShape Shape;

	public Image GestureIcon;

	public Color HighlightedColor = Color.red;

	public Color NeutralColor = Color.white;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class GestureCustomiser : MonoBehaviour
{
	public CustomGestureWidget[] Shapes;

	public float Padding = 1f;

	public float Offset;

	public RustText SelectedGestureName;

	public Image SelectedGestureIcon;

	public Phrase EmptySlotName = new Phrase("empty_gesture_slot", "Empty Slot");

	public Sprite EmptySlotIcon;

	public GameObject PickerRoot;

	public GameObjectRef PickerPrefab;

	public Transform PickerContent;

	public RustText WheelHeader;

	public RustButton WheelRightButton;

	public RustButton WheelLeftButton;

	public VideoPlayer PreviewVideo;

	public RawImage VideoImage;

	public GameObject NoValidGesturesText;

	public GameObject EmptySlotInputHelp;

	public GameObject FilledSlotInputHelp;
}


using ConVar;
using UnityEngine;

public class FPSGraph : Graph
{
	public void Refresh()
	{
		((Behaviour)this).enabled = FPS.graph > 0;
		((Rect)(ref Area)).width = (Resolution = Mathf.Clamp(FPS.graph, 0, Screen.width));
	}

	protected void OnEnable()
	{
		Refresh();
	}

	protected override float GetValue()
	{
		return 1f / Time.deltaTime;
	}

	protected override Color GetColor(float value)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!(value < 10f))
		{
			if (!(value < 30f))
			{
				return Color.green;
			}
			return Color.yellow;
		}
		return Color.red;
	}
}


using UnityEngine;

public abstract class Graph : MonoBehaviour
{
	public Material Material;

	public int Resolution = 128;

	public Vector2 ScreenFill = new Vector2(0f, 0f);

	public Vector2 ScreenOrigin = new Vector2(0f, 0f);

	public Vector2 Pivot = new Vector2(0f, 0f);

	public Rect Area = new Rect(0f, 0f, 128f, 32f);

	internal float CurrentValue;

	private int index;

	private float[] values;

	private float max;

	protected abstract float GetValue();

	protected abstract Color GetColor(float value);

	protected Vector3 GetVertex(float x, float y)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(x, y, 0f);
	}

	protected void Update()
	{
		if (values == null || values.Length != Resolution)
		{
			values = new float[Resolution];
		}
		max = 0f;
		for (int i = 0; i < values.Length - 1; i++)
		{
			max = Mathf.Max(max, values[i] = values[i + 1]);
		}
		max = Mathf.Max(max, CurrentValue = (values[values.Length - 1] = GetValue()));
	}

	protected void OnGUI()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Invalid comparison between Unknown and I4
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		if ((int)Event.current.type == 7 && values != null && values.Length != 0)
		{
			float num = Mathf.Max(((Rect)(ref Area)).width, ScreenFill.x * (float)Screen.width);
			float num2 = Mathf.Max(((Rect)(ref Area)).height, ScreenFill.y * (float)Screen.height);
			float num3 = ((Rect)(ref Area)).x - Pivot.x * num + ScreenOrigin.x * (float)Screen.width;
			float num4 = ((Rect)(ref Area)).y - Pivot.y * num2 + ScreenOrigin.y * (float)Screen.height;
			GL.PushMatrix();
			Material.SetPass(0);
			GL.LoadPixelMatrix();
			GL.Begin(7);
			for (int i = 0; i < values.Length; i++)
			{
				float num5 = values[i];
				float num6 = num / (float)values.Length;
				float num7 = num2 * num5 / max;
				float num8 = num3 + (float)i * num6;
				float num9 = num4;
				GL.Color(GetColor(num5));
				GL.Vertex(GetVertex(num8 + 0f, num9 + num7));
				GL.Vertex(GetVertex(num8 + num6, num9 + num7));
				GL.Vertex(GetVertex(num8 + num6, num9 + 0f));
				GL.Vertex(GetVertex(num8 + 0f, num9 + 0f));
			}
			GL.End();
			GL.PopMatrix();
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class HostileNote : MonoBehaviour, IClientComponent
{
	public CanvasGroup warnGroup;

	public CanvasGroup group;

	public CanvasGroup timerGroup;

	public CanvasGroup smallWarning;

	public Text timerText;

	public RustText smallWarningText;

	public static float unhostileTime;

	public static float weaponDrawnDuration;

	public Color warnColor;

	public Color hostileColor;

	public float requireDistanceToSafeZone = 200f;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class HudElement : MonoBehaviour
{
	public Text[] ValueText;

	public Image[] FilledImage;

	public float lastValue;

	private float lastMax;

	public void SetValue(float value, float max = 1f)
	{
		TimeWarning val = TimeWarning.New("HudElement.SetValue", 0);
		try
		{
			value = Mathf.CeilToInt(value);
			if (value != lastValue || max != lastMax)
			{
				lastValue = value;
				lastMax = max;
				float image = value / max;
				SetText(value.ToString("0"));
				SetImage(image);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetText(string v)
	{
		for (int i = 0; i < ValueText.Length; i++)
		{
			ValueText[i].text = v;
		}
	}

	private void SetImage(float f)
	{
		for (int i = 0; i < FilledImage.Length; i++)
		{
			FilledImage[i].fillAmount = f;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class InfoBar : MonoBehaviour
{
	public Text TextValue;

	public RustText RustTextValue;

	public Image ImageFill;

	public Color GoodColor;

	public Color BadColor;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ContactsEntry : MonoBehaviour
{
	public RustText nameText;

	public RustText reputationText;

	public RawImage smallMugshot;

	public RelationshipManager.PlayerRelationshipInfo info;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ContactsPanel : SingletonComponent<ContactsPanel>
{
	public enum SortMode
	{
		None,
		RecentlySeen
	}

	public RectTransform alliesBucket;

	public RectTransform seenBucket;

	public RectTransform enemiesBucket;

	public RectTransform contentsBucket;

	public ContactsEntry contactEntryPrefab;

	public RawImage mugshotTest;

	public RawImage fullBodyTest;

	public RustButton[] filterButtons;

	public RelationshipManager.RelationshipType selectedRelationshipType = RelationshipManager.RelationshipType.Friend;

	public RustButton lastSeenToggle;

	public Phrase sortingByLastSeenPhrase;

	public Phrase sortingByFirstSeen;

	public RustText sortText;
}


public enum SortMode
{
	None,
	RecentlySeen
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class GameTip : SingletonComponent<GameTip>
{
	public enum Styles
	{
		Blue_Normal = 0,
		Red_Normal = 1,
		Blue_Long = 2,
		Blue_Short = 3,
		Server_Event = 4,
		Error = 5,
		LAST = 5
	}

	[Serializable]
	public struct Theme
	{
		public Styles style;

		public Icons Icon;

		public Color BackgroundColor;

		public Color ForegroundColor;

		public float duration;

		public float fadeTime;

		public bool bump;
	}

	public Canvas canvas;

	public CanvasGroup canvasGroup;

	public RustIcon icon;

	public Image background;

	public RustText text;

	public Theme[] themes;
}


public enum Styles
{
	Blue_Normal = 0,
	Red_Normal = 1,
	Blue_Long = 2,
	Blue_Short = 3,
	Server_Event = 4,
	Error = 5,
	LAST = 5
}


using System;
using Rust.UI;
using UnityEngine;

[Serializable]
public struct Theme
{
	public Styles style;

	public Icons Icon;

	public Color BackgroundColor;

	public Color ForegroundColor;

	public float duration;

	public float fadeTime;

	public bool bump;
}


using System;
using Painting;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class ImagePainter : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IInitializePotentialDragHandler
{
	[Serializable]
	public class OnDrawingEvent : UnityEvent<Vector2, Brush>
	{
	}

	internal class PointerState
	{
		public Vector2 lastPos;

		public bool isDown;
	}

	public OnDrawingEvent onDrawing = new OnDrawingEvent();

	public MonoBehaviour redirectRightClick;

	[Tooltip("Spacing scale will depend on your texel size, tweak to what's right.")]
	public float spacingScale = 1f;

	internal Brush brush;

	internal PointerState[] pointerState = new PointerState[3]
	{
		new PointerState(),
		new PointerState(),
		new PointerState()
	};

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if ((int)eventData.button != 1)
		{
			Vector2 position = default(Vector2);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, eventData.position, eventData.pressEventCamera, ref position);
			DrawAt(position, eventData.button);
			pointerState[eventData.button].isDown = true;
		}
	}

	public virtual void OnPointerUp(PointerEventData eventData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		pointerState[eventData.button].isDown = false;
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((int)eventData.button == 1)
		{
			if (Object.op_Implicit((Object)(object)redirectRightClick))
			{
				((Component)redirectRightClick).SendMessage("OnDrag", (object)eventData);
			}
		}
		else
		{
			Vector2 position = default(Vector2);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, eventData.position, eventData.pressEventCamera, ref position);
			DrawAt(position, eventData.button);
		}
	}

	public virtual void OnBeginDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1 && Object.op_Implicit((Object)(object)redirectRightClick))
		{
			((Component)redirectRightClick).SendMessage("OnBeginDrag", (object)eventData);
		}
	}

	public virtual void OnEndDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1 && Object.op_Implicit((Object)(object)redirectRightClick))
		{
			((Component)redirectRightClick).SendMessage("OnEndDrag", (object)eventData);
		}
	}

	public virtual void OnInitializePotentialDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1 && Object.op_Implicit((Object)(object)redirectRightClick))
		{
			((Component)redirectRightClick).SendMessage("OnInitializePotentialDrag", (object)eventData);
		}
	}

	private void DrawAt(Vector2 position, InputButton button)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (brush == null)
		{
			return;
		}
		PointerState pointerState = this.pointerState[button];
		Vector2 val = rectTransform.Unpivot(position);
		if (pointerState.isDown)
		{
			Vector2 val2 = pointerState.lastPos - val;
			Vector2 normalized = ((Vector2)(ref val2)).normalized;
			for (float num = 0f; num < ((Vector2)(ref val2)).magnitude; num += Mathf.Max(brush.spacing, 1f) * Mathf.Max(spacingScale, 0.1f))
			{
				((UnityEvent<Vector2, Brush>)onDrawing).Invoke(val + num * normalized, brush);
			}
			pointerState.lastPos = val;
		}
		else
		{
			((UnityEvent<Vector2, Brush>)onDrawing).Invoke(val, brush);
			pointerState.lastPos = val;
		}
	}

	private void Start()
	{
	}

	public void UpdateBrush(Brush brush)
	{
		this.brush = brush;
	}
}


using System;
using Painting;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class OnDrawingEvent : UnityEvent<Vector2, Brush>
{
}


using UnityEngine;

internal class PointerState
{
	public Vector2 lastPos;

	public bool isDown;
}


using UnityEngine;

public class IndependentScale : MonoBehaviour, IClientComponent
{
	public Transform scaleParent;

	public Vector3 initialScale = Vector3.one;
}


using UnityEngine;
using UnityEngine.UI;

public class IndependentScaleImagePPU : MonoBehaviour, IClientComponent
{
	public Transform scaleParent;

	public Image image;
}


public enum MapLayer
{
	Overworld = -1,
	TrainTunnels = 0,
	Underwater1 = 1,
	Underwater2 = 2,
	Underwater3 = 3,
	Underwater4 = 4,
	Underwater5 = 5,
	Underwater6 = 6,
	Underwater7 = 7,
	Underwater8 = 8,
	Dungeons = 10
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Rendering;

public class MapLayerRenderer : SingletonComponent<MapLayerRenderer>
{
	public Camera renderCamera;

	public CameraEvent cameraEvent;

	public Material renderMaterial;

	private MapLayer? _currentlyRenderedLayer;

	private NetworkableId? _currentlyRenderedDungeon;

	private int? _underwaterLabFloorCount;

	[ClientVar(ClientAdmin = true)]
	public static bool DebugLabs;

	public void Render(MapLayer layer)
	{
		if (layer < MapLayer.TrainTunnels)
		{
			return;
		}
		if (layer == MapLayer.Dungeons)
		{
			RenderDungeonsLayer();
		}
		else if (layer != _currentlyRenderedLayer)
		{
			_currentlyRenderedLayer = layer;
			switch (layer)
			{
			case MapLayer.TrainTunnels:
				RenderTrainLayer();
				break;
			case MapLayer.Underwater1:
			case MapLayer.Underwater2:
			case MapLayer.Underwater3:
			case MapLayer.Underwater4:
			case MapLayer.Underwater5:
			case MapLayer.Underwater6:
			case MapLayer.Underwater7:
			case MapLayer.Underwater8:
				RenderUnderwaterLabs((int)(layer - 1));
				break;
			}
		}
	}

	private void RenderImpl(CommandBuffer cb)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		double num = (double)World.Size * 1.5;
		renderCamera.orthographicSize = (float)num / 2f;
		renderCamera.RemoveAllCommandBuffers();
		renderCamera.AddCommandBuffer(cameraEvent, cb);
		renderCamera.Render();
		renderCamera.RemoveAllCommandBuffers();
	}

	public static MapLayerRenderer GetOrCreate()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<MapLayerRenderer>.Instance != (Object)null)
		{
			return SingletonComponent<MapLayerRenderer>.Instance;
		}
		return GameManager.server.CreatePrefab("assets/prefabs/engine/maplayerrenderer.prefab", Vector3.zero, Quaternion.identity).GetComponent<MapLayerRenderer>();
	}

	private void RenderDungeonsLayer()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = FindDungeon(MainCamera.isValid ? MainCamera.position : Vector3.zero);
		if (_currentlyRenderedLayer == MapLayer.Dungeons)
		{
			NetworkableId? currentlyRenderedDungeon = _currentlyRenderedDungeon;
			NetworkableId? val = proceduralDynamicDungeon?.net?.ID;
			if (currentlyRenderedDungeon.HasValue == val.HasValue && (!currentlyRenderedDungeon.HasValue || currentlyRenderedDungeon.GetValueOrDefault() == val.GetValueOrDefault()))
			{
				return;
			}
		}
		_currentlyRenderedLayer = MapLayer.Dungeons;
		_currentlyRenderedDungeon = proceduralDynamicDungeon?.net?.ID;
		CommandBuffer val2 = BuildCommandBufferDungeons(proceduralDynamicDungeon);
		try
		{
			RenderImpl(val2);
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	private CommandBuffer BuildCommandBufferDungeons(ProceduralDynamicDungeon closest)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer val = new CommandBuffer
		{
			name = "DungeonsLayer Render"
		};
		if ((Object)(object)closest != (Object)null && closest.spawnedCells != null)
		{
			Matrix4x4 val2 = Matrix4x4.Translate(closest.mapOffset);
			foreach (ProceduralDungeonCell spawnedCell in closest.spawnedCells)
			{
				if ((Object)(object)spawnedCell == (Object)null || spawnedCell.mapRendererLods == null || spawnedCell.mapRendererLods.Length == 0)
				{
					continue;
				}
				RendererLOD[] mapRendererLods = spawnedCell.mapRendererLods;
				foreach (RendererLOD rendererLOD in mapRendererLods)
				{
					if ((Object)(object)rendererLOD == (Object)null)
					{
						continue;
					}
					Matrix4x4 localToWorldMatrix;
					Mesh finalLodMesh = rendererLOD.GetFinalLodMesh(out localToWorldMatrix);
					if (!((Object)(object)finalLodMesh == (Object)null))
					{
						int subMeshCount = finalLodMesh.subMeshCount;
						Matrix4x4 val3 = val2 * localToWorldMatrix;
						for (int j = 0; j < subMeshCount; j++)
						{
							val.DrawMesh(finalLodMesh, val3, renderMaterial, j);
						}
					}
				}
			}
		}
		return val;
	}

	public static ProceduralDynamicDungeon FindDungeon(Vector3 position, float maxDist = 200f)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon result = null;
		float num = 100000f;
		foreach (ProceduralDynamicDungeon dungeon in ProceduralDynamicDungeon.dungeons)
		{
			if (!((Object)(object)dungeon == (Object)null) && dungeon.isClient)
			{
				float num2 = Vector3.Distance(position, ((Component)dungeon).transform.position);
				if (!(num2 > maxDist) && !(num2 > num))
				{
					result = dungeon;
					num = num2;
				}
			}
		}
		return result;
	}

	private void RenderTrainLayer()
	{
		CommandBuffer val = BuildCommandBufferTrainTunnels();
		try
		{
			RenderImpl(val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private CommandBuffer BuildCommandBufferTrainTunnels()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer val = new CommandBuffer
		{
			name = "TrainLayer Render"
		};
		foreach (DungeonGridCell dungeonGridCell in TerrainMeta.Path.DungeonGridCells)
		{
			if (dungeonGridCell.MapRendererLods == null || dungeonGridCell.MapRendererLods.Length == 0)
			{
				continue;
			}
			RendererLOD[] mapRendererLods = dungeonGridCell.MapRendererLods;
			for (int i = 0; i < mapRendererLods.Length; i++)
			{
				Matrix4x4 localToWorldMatrix;
				Mesh finalLodMesh = mapRendererLods[i].GetFinalLodMesh(out localToWorldMatrix);
				if (!((Object)(object)finalLodMesh == (Object)null))
				{
					int subMeshCount = finalLodMesh.subMeshCount;
					for (int j = 0; j < subMeshCount; j++)
					{
						val.DrawMesh(finalLodMesh, localToWorldMatrix, renderMaterial, j);
					}
				}
			}
		}
		return val;
	}

	private void RenderUnderwaterLabs(int floor)
	{
		CommandBuffer val = BuildCommandBufferUnderwaterLabs(floor);
		try
		{
			RenderImpl(val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int GetUnderwaterLabFloorCount()
	{
		if (_underwaterLabFloorCount.HasValue)
		{
			return _underwaterLabFloorCount.Value;
		}
		List<DungeonBaseInfo> dungeonBaseEntrances = TerrainMeta.Path.DungeonBaseEntrances;
		_underwaterLabFloorCount = ((dungeonBaseEntrances != null && dungeonBaseEntrances.Count > 0) ? dungeonBaseEntrances.Max((DungeonBaseInfo l) => l.Floors.Count) : 0);
		if (DebugLabs && dungeonBaseEntrances != null)
		{
			Debug.Log((object)$"Setup underwater lab: count: {dungeonBaseEntrances.Count} floors: {_underwaterLabFloorCount.Value}");
		}
		return _underwaterLabFloorCount.Value;
	}

	private CommandBuffer BuildCommandBufferUnderwaterLabs(int floor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer val = new CommandBuffer
		{
			name = "UnderwaterLabLayer Render"
		};
		foreach (DungeonBaseInfo dungeonBaseEntrance in TerrainMeta.Path.DungeonBaseEntrances)
		{
			if (dungeonBaseEntrance.Floors.Count <= floor)
			{
				continue;
			}
			foreach (DungeonBaseLink link in dungeonBaseEntrance.Floors[floor].Links)
			{
				if (link.MapRendererLods == null || link.MapRendererLods.Length == 0)
				{
					if (DebugLabs)
					{
						Debug.Log((object)$"{link} has no renderers");
					}
					continue;
				}
				RendererLOD[] mapRendererLods = link.MapRendererLods;
				foreach (RendererLOD rendererLOD in mapRendererLods)
				{
					if ((Object)(object)rendererLOD == (Object)null)
					{
						if (DebugLabs)
						{
							Debug.Log((object)$"{link} has a null renderer");
						}
						continue;
					}
					Matrix4x4 localToWorldMatrix;
					Mesh finalLodMesh = rendererLOD.GetFinalLodMesh(out localToWorldMatrix);
					if (!((Object)(object)finalLodMesh == (Object)null))
					{
						int subMeshCount = finalLodMesh.subMeshCount;
						for (int j = 0; j < subMeshCount; j++)
						{
							val.DrawMesh(finalLodMesh, localToWorldMatrix, renderMaterial, j);
						}
					}
				}
			}
		}
		return val;
	}
}


using System.Text.RegularExpressions;
using UnityEngine;

public static class MapHelper
{
	public static Vector2i? StringToGrid(string text)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		Match match = new Regex("^([a-zA-Z]+)(\\d+)$").Match(text);
		if (!match.Success)
		{
			return null;
		}
		int num = 0;
		string text2 = match.Groups[1].Value.ToLower();
		foreach (char c in text2)
		{
			num = num * 26 + c - 97 + 1;
		}
		num--;
		if (!int.TryParse(match.Groups[2].Value, out var result))
		{
			return null;
		}
		return new Vector2i(num, result);
	}

	public static Vector3 GridToPosition(Vector2i grid)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		float num = 146.28572f;
		int num2 = Mathf.FloorToInt((float)World.Size / num + 0.001f);
		float num3 = World.Size / num2;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(0L - (long)World.Size) / 2f, (float)World.Size / 2f);
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor((float)grid.x * num3, (float)grid.y * num3);
		return new Vector3(val.x + val2.x, 0f, val.y - val2.y) + new Vector3(num3 / 2f, 0f, num3 / -2f);
	}

	public static Vector3? StringToPosition(string text)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Vector2i? val = StringToGrid(text);
		if (!val.HasValue)
		{
			return null;
		}
		return GridToPosition(val.Value);
	}

	public static string PositionToString(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GridToString(PositionToGrid(position));
	}

	public static Vector2i PositionToGrid(Vector3 position)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		float num = 146.28572f;
		int num2 = Mathf.FloorToInt((float)World.Size / num + 0.001f);
		float num3 = World.Size / num2;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(0L - (long)World.Size) / 2f, (float)World.Size / 2f);
		Vector2 val2 = new Vector2(position.x - val.x, val.y - position.z);
		int num4 = Mathf.FloorToInt(val2.x / num3);
		int num5 = Mathf.FloorToInt(val2.y / num3);
		return new Vector2i(num4, num5);
	}

	public static string GridToString(Vector2i grid)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		grid.x = Mathf.Max(grid.x, 0);
		int num = grid.x + 1;
		string text = "";
		while (num > 0)
		{
			num--;
			text = (char)(65 + num % 26) + text;
			num /= 26;
		}
		return $"{text}{grid.y}";
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MapInterface : SingletonComponent<MapInterface>
{
	[Serializable]
	public struct PointOfInterestSpriteConfig
	{
		public Sprite inner;

		public Sprite outer;
	}

	public static bool IsOpen;

	public static bool HasPreviouslyOpenedInThisSession;

	public Image cameraPositon;

	public ScrollRectEx scrollRect;

	public ScrollRectZoom scrollRectZoom;

	public RustButton showGridToggle;

	public RustButton FocusButton;

	public CanvasGroup CanvasGroup;

	public SoundDefinition PlaceMarkerSound;

	public SoundDefinition ClearMarkerSound;

	public MapView View;

	public UINexusMap NexusMap;

	public GameObject NexusButtonGroup;

	public RustButton NexusToggle;

	public Color[] PointOfInterestColours;

	public PointOfInterestSpriteConfig[] PointOfInterestSprites;

	public Sprite PingBackground;

	public bool DebugStayOpen;

	public GameObject MarkerListSection;

	public GameObject ControlsRoot;

	public GameObjectRef MarkerListPrefab;

	public GameObject MarkerHeader;

	public Transform LocalPlayerMarkerListParent;

	public Transform TeamMarkerListParent;

	public GameObject TeamLeaderHeader;

	public GameObject MissionListHeader;

	public Transform MissionListContent;

	public GameObjectRef MissionListPrefab;

	public VendorList VendorList;

	public RustButton HideTeamLeaderMarkersToggle;

	public CanvasGroup TeamMarkersCanvas;

	public RustImageButton ShowSleepingBagsButton;

	public RustImageButton ShowVendingMachinesButton;

	public RustImageButton ShowMissionProvidersButton;

	public UIEscapeCapture EscapeCapture;
}


using System;
using UnityEngine;

[Serializable]
public struct PointOfInterestSpriteConfig
{
	public Sprite inner;

	public Sprite outer;
}


using UnityEngine;
using UnityEngine.UI;

public class MapMarkerIconSelector : MonoBehaviour
{
	public Image OuterImage;

	public Image InnerImage;

	public GameObject Selected;
}


public class MapScaleIndependent : IndependentScale
{
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class MapView : FacepunchBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public RawImage mapImage;

	public Image cameraPositon;

	public GameObject cameraPositionDirectionIndicator;

	public GameObject cameraPositionNoDirectionIndicator;

	public ScrollRectEx scrollRect;

	public CanvasGroup contentCanvasGroup;

	public GameObject monumentMarkerContainer;

	public Transform clusterMarkerContainer;

	public GameObjectRef monumentMarkerPrefab;

	public GameObject missionMarkerContainer;

	public GameObjectRef missionMarkerPrefab;

	public Transform activeInteractionParent;

	public Transform localPlayerInterestPointRoot;

	public GameObject shelterMarkerContainer;

	public GameObjectRef shelterMapMarkerPrefab;

	public TeamMemberMapMarker[] teamPositions;

	public TeamMemberMapMarker[] clanPositions;

	public List<PointOfInterestMapMarker> PointOfInterestMarkers;

	public List<PointOfInterestMapMarker> TeamPointOfInterestMarkers;

	public List<PointOfInterestMapMarker> LocalPings;

	public List<PointOfInterestMapMarker> TeamPings;

	public GameObject PlayerDeathMarker;

	public List<SleepingBagMapMarker> SleepingBagMarkers = new List<SleepingBagMapMarker>();

	public List<SleepingBagClusterMapMarker> SleepingBagClusters = new List<SleepingBagClusterMapMarker>();

	public RectTransform FogIndependentInteractionRoot;

	[FormerlySerializedAs("TrainLayer")]
	public RawImage UndergroundLayer;

	public bool ShowGrid;

	public bool ShowPointOfInterestMarkers;

	public bool ShowDeathMarker = true;

	public bool ShowSleepingBags = true;

	public bool AllowSleepingBagDeletion;

	public bool ShowLocalPlayer = true;

	public bool ShowTeamMembers = true;

	public bool ShowBagsOnBottom;

	public bool ShowTrainLayer;

	public bool ShowMissions;

	public bool ForceShowVendingMachines;

	[FormerlySerializedAs("ShowTrainLayer")]
	public bool ShowUndergroundLayers;

	public bool MLRSMarkerMode;

	public RustImageButton LockButton;

	public RustImageButton OverworldButton;

	public RustImageButton TrainButton;

	public RustImageButton[] UnderwaterButtons;

	public RustImageButton DungeonButton;

	public CanvasLineRenderer CargoPatrolPath;

	public CanvasLineRenderer[] HarborPaths;

	public CanvasLineRenderer FerryPath;

	public CanvasLineRenderer HeliPath;

	public PaintableImageGrid FogOfWarGrid;

	public Texture2D FogOfWarTex;

	public UnityEvent onClicked;

	public void OnPointerDown(PointerEventData eventData)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class MissionMapMarker : MonoBehaviour
{
	public Image Icon;

	public Tooltip TooltipComponent;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MissionPointMapMarker : MonoBehaviour
{
	public RustText MissionName;

	public Image Icon;
}


using Facepunch;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MonumentMarker : MonoBehaviour
{
	public RustText text;

	public Image imageBackground;

	public Image image;

	public Color dayColor;

	public Color nightColor;

	public void Setup(LandmarkInfo info)
	{
		text.SetText(info.displayPhrase.IsValid() ? info.displayPhrase.translated : ((Object)((Component)info).transform.root).name, true, false);
		if ((Object)(object)info.mapIcon != (Object)null)
		{
			image.sprite = info.mapIcon;
			ComponentExtensions.SetActive<RustText>(text, false);
			ComponentExtensions.SetActive<Image>(imageBackground, true);
		}
		else
		{
			ComponentExtensions.SetActive<RustText>(text, true);
			ComponentExtensions.SetActive<Image>(imageBackground, false);
		}
		SetNightMode(nightMode: false);
	}

	public void SetNightMode(bool nightMode)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Color color = (nightMode ? nightColor : dayColor);
		Color color2 = (nightMode ? dayColor : nightColor);
		if ((Object)(object)text != (Object)null)
		{
			((Graphic)text).color = color;
		}
		if ((Object)(object)image != (Object)null)
		{
			((Graphic)image).color = color;
		}
		if ((Object)(object)imageBackground != (Object)null)
		{
			((Graphic)imageBackground).color = color2;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class PointOfInterestMapMarker : MonoBehaviour
{
	public Image MapIcon;

	public Image MapIconOuter;

	public GameObject LeaderRoot;

	public GameObject EditPopup;

	public Tooltip Tooltip;

	public GameObject MarkerLabelRoot;

	public RustText MarkerLabel;

	public RustText NoMarkerLabel;

	public RustInput MarkerLabelModify;

	public MapMarkerIconSelector[] IconSelectors;

	public MapMarkerIconSelector[] ColourSelectors;

	public bool IsListWidget;

	public GameObject DeleteButton;
}


using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SleepingBagClusterMapMarker : MonoBehaviour
{
	public TextMeshProUGUI CountText;

	public List<SleepingBagButton> SleepingBagButtons;

	public GameObject OpenRoot;

	public Tooltip SummaryTooltip;

	public Image RimImage;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SleepingBagMapMarker : MonoBehaviour
{
	public Image MapIcon;

	public Image SleepingBagIcon;

	public Sprite SleepingBagSprite;

	public Sprite BedSprite;

	public Sprite BeachTowelSprite;

	public Sprite CamperSprite;

	public Tooltip MarkerTooltip;

	public GameObject LockRoot;

	public TextMeshProUGUI LockTime;

	public GameObject OccupiedRoot;

	public Image CircleRim;

	public Image CircleFill;

	public RustButton DeleteButton;

	public Image ConfirmSlider;

	public GameObject CorpseRoot;

	public Image CorpseImage;
}


using UnityEngine;
using UnityEngine.UI;

public class TeamMemberMapMarker : MonoBehaviour
{
	public RectTransform rectTransform;

	public Text nameTagText;

	public Tooltip toolTip;

	public Image innerImage;
}


using UnityEngine;

public class UIMapExplosion : MonoBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class UIMapGenericRadius : MonoBehaviour
{
	public Image radialImage;

	public Image outlineImage;

	public float radius;

	public CanvasGroup fade;

	public RectTransform rect;
}


using Rust.UI;
using UnityEngine;

public class UIMapMissionProvider : MonoBehaviour
{
	public Tooltip TargetTooltip;

	public RustText CountText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIMapVendingMachineMarker : MonoBehaviour
{
	public Color inStock;

	public Color outOfStock;

	public Image colorBackground;

	public string displayName;

	public Tooltip toolTip;

	public RustButton button;
}


using TMPro;
using UnityEngine;

public class UIMapVendingMachineMarkerCluster : MonoBehaviour
{
	public GameObject OpenRoot;

	public TextMeshProUGUI CountText;

	public GameObjectRef MarkerPrefab;

	public Transform MarkerParent;
}


public class UINexusMap : UINexusMapBase
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public abstract class UINexusMapBase : BaseMonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public RawImage BackgroundImage;

	public RawImage BackgroundFillImage;

	public RectTransform LoadingView;

	public RectTransform MissingView;

	public ScrollRectEx MapScrollRect;

	public ScrollRectZoom MapScrollZoom;

	public RectTransform CameraPositon;

	public CanvasGroup ZoneNameCanvasGroup;

	public RectTransform ZoneNameContainer;

	public GameObjectRef ZoneNameMarkerPrefab;

	[Header("Zone Details")]
	public CanvasGroup ZoneDetails;

	public RustText ZoneName;

	public RustText OnlineCount;

	public RustText MaxCount;

	public GameObjectRef ZoneNameLabelPrefab;

	public GameObject InboundFerriesSection;

	public RectTransform InboundFerriesList;

	public GameObject OutboundFerriesSection;

	public RectTransform OutboundFerriesList;

	public GameObject ConnectionsSection;

	public RectTransform ConnectionsList;

	[Header("Behavior")]
	public bool ShowLocalPlayer;

	public float OutOfBoundsScaleFactor = 5f;

	public float ZoneNameAlphaPower = 100f;

	public UnityEvent OnMapLoaded = new UnityEvent();

	public UnityEvent OnClicked = new UnityEvent();

	public void OnPointerDown(PointerEventData eventData)
	{
	}
}


using Facepunch.Flexbox;
using Rust.UI;

public class UINexusMapWidget : UINexusMapBase
{
	public RustButton FocusButton;

	public FlexTransition RevealTransition;
}


using System;
using Painting;
using UnityEngine;
using UnityEngine.Events;

public class UIPaintBox : MonoBehaviour
{
	[Serializable]
	public class OnBrushChanged : UnityEvent<Brush>
	{
	}

	public OnBrushChanged onBrushChanged = new OnBrushChanged();

	public Brush brush;

	public void UpdateBrushSize(int size)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		brush.brushSize = Vector2.one * (float)size;
		brush.spacing = Mathf.Clamp((float)size * 0.1f, 1f, 3f);
		OnChanged();
	}

	public void UpdateBrushTexture(Texture2D tex)
	{
		brush.texture = tex;
		OnChanged();
	}

	public void UpdateBrushColor(Color col)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		brush.color.r = col.r;
		brush.color.g = col.g;
		brush.color.b = col.b;
		OnChanged();
	}

	public void UpdateBrushAlpha(float a)
	{
		brush.color.a = a;
		OnChanged();
	}

	public void UpdateBrushEraser(bool b)
	{
		brush.erase = b;
	}

	private void OnChanged()
	{
		((UnityEvent<Brush>)onBrushChanged).Invoke(brush);
	}
}


using System;
using Painting;
using UnityEngine.Events;

[Serializable]
public class OnBrushChanged : UnityEvent<Brush>
{
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SingleVendor : FacepunchBehaviour, IComparable<SingleVendor>
{
	public RustText VendorName;

	public TmProEmojiRedirector emojiRedirector;

	public Transform ListingsParent;

	public Transform AccordionRow;

	public Transform AccordionChevron;

	public Image[] AccordionImages = (Image[])(object)new Image[3];

	public GameObjectRef VendorListingPrefab;

	[Header("References")]
	public GameObject NoListings;

	public FlexTransition VendorListingsTransition;

	public Image OwnerImage;

	public RustText OwnerName;

	public SellOrderContainer SellOrdersContainer;

	private List<VendorListing> listings;

	public const int COUNT_FOR_ACCORDION = 5;

	public int CompareTo(SingleVendor other)
	{
		SellOrderContainer sellOrdersContainer = SellOrdersContainer;
		bool flag = sellOrdersContainer != null && sellOrdersContainer.sellOrders.Count >= 5;
		SellOrderContainer sellOrdersContainer2 = other.SellOrdersContainer;
		bool flag2 = sellOrdersContainer2 != null && sellOrdersContainer2.sellOrders.Count >= 5;
		if (flag && !flag2)
		{
			return 1;
		}
		if (!flag && flag2)
		{
			return -1;
		}
		SellOrderContainer sellOrdersContainer3 = SellOrdersContainer;
		if (sellOrdersContainer3 != null && sellOrdersContainer3.sellOrders.Count == 0)
		{
			SellOrderContainer sellOrdersContainer4 = other.SellOrdersContainer;
			if (sellOrdersContainer4 != null && sellOrdersContainer4.sellOrders.Count > 0)
			{
				return -1;
			}
		}
		SellOrderContainer sellOrdersContainer5 = SellOrdersContainer;
		if (sellOrdersContainer5 != null && sellOrdersContainer5.sellOrders.Count > 0)
		{
			SellOrderContainer sellOrdersContainer6 = other.SellOrdersContainer;
			if (sellOrdersContainer6 != null && sellOrdersContainer6.sellOrders.Count == 0)
			{
				return 1;
			}
		}
		return 0;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class VendorList : MonoBehaviour
{
	public GameObject singleHeader;

	public GameObject multiHeader;

	public Transform ListParent;

	public GameObjectRef SingleVendorPrefab;

	public ScrollRect scrollRect;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class VendorListing : FacepunchBehaviour
{
	public Image panelBacking;

	[Header("Text")]
	public RustText AvailableText;

	public RustText CostText;

	public RustText AvailableAmount;

	public RustText CostAmount;

	public RustText InStockAmount;

	public RustText InStockText;

	public VendingPriceMultiplierWidget PriceMultiplier;

	public VendingPriceMultiplierWidget RecievedCurrencyMultiplier;

	[Header("Icons")]
	public VirtualItemIcon AvaliableIcon;

	public VirtualItemIcon CostIcon;

	[Header("Tooltips")]
	public Tooltip avaliableIconTooltip;

	public Tooltip costIconTooltip;

	[SerializeField]
	private FlexTransition transition;

	public static Phrase inStockPhrase = new Phrase("vendor_in_stock", "In Stock");

	public static Phrase outOfStockPhrase = new Phrase("vendor_out_stock", "Sold Out");

	public static Phrase attachmentsPhrase = new Phrase("vendor_attachments", "Attachments");

	public static Phrase ammoPhrase = new Phrase("vendor_ammo", "Ammo");
}


using System;
using Facepunch.Extend;
using Rust.UI;
using UnityEngine;

public class MenuTip : MonoBehaviour
{
	public RustText text;

	public RustIcon icon;

	public LoadingScreen screen;

	public static Phrase[] MenuTips = (Phrase[])(object)new Phrase[35]
	{
		new TokenisedPhrase("menutip_bag", "Don't forget to create a sleeping bag! You can pick which one to respawn at on the death screen."),
		new TokenisedPhrase("menutip_baggive", "You can give a sleeping bag to a Steam friend."),
		new TokenisedPhrase("menutip_sneakanimal", "Some animals have blind spots. Sneak up from behind to get close enough to make the kill."),
		new TokenisedPhrase("menutip_humanmeat", "Human meat will severely dehydrate you."),
		new TokenisedPhrase("menutip_hammerpickup", "You can use the Hammer tool to pick up objects. Providing they are unlocked and/or opened."),
		new TokenisedPhrase("menutip_seedsun", "Ensure seeds are placed in full sunlight for faster growth."),
		new TokenisedPhrase("menutip_lakeriverdrink", "You can drink from lakes and rivers to recover a portion of your health."),
		new TokenisedPhrase("menutip_cookmeat", "Cook meat in a campfire to increase its healing abilities."),
		new TokenisedPhrase("menutip_rotatedeployables", "Rotate deployables before placing them by pressing [R]"),
		new TokenisedPhrase("menutip_repairblocked", "You cannot repair or upgrade building parts for 30 seconds after they've been damaged."),
		new TokenisedPhrase("menutip_hammerrepair", "Hit objects with your hammer to repair them, providing you have the necessary resources."),
		new TokenisedPhrase("menutip_altlook", "Hold [+altlook] to check your surroundings."),
		new TokenisedPhrase("menutip_upkeepwarning", "The larger you expand your base the more it'll cost to upkeep"),
		new TokenisedPhrase("menutip_report", "If you wish to report any in-game issues try pressing F7"),
		new TokenisedPhrase("menutip_radwash", "Submerge yourself in water and slosh around to remove radiation"),
		new TokenisedPhrase("menutip_switchammo", "Switch between ammo types by holding the [+reload] key"),
		new TokenisedPhrase("menutip_riverplants", "Edible plants are commonly found on river sides."),
		new TokenisedPhrase("menutip_buildwarnmonument", "Building near monuments may attract unwanted attention."),
		new TokenisedPhrase("menutip_vending", "Sell your unwanted items safely by crafting a vending machine."),
		new TokenisedPhrase("menutip_switchammo", "Switch between ammo types by holding the [+reload] key."),
		new TokenisedPhrase("menutip_oretip", "Stone and Ore Nodes are most commonly found around cliffs, mountains and other rock formations."),
		new TokenisedPhrase("menutip_crouchwalk", "Crouching allows you to move silently."),
		new TokenisedPhrase("menutip_accuracy", "Standing still or crouching while shooting increases accuracy."),
		new TokenisedPhrase("menutip_crashharvest", "You can harvest metal from helicopter and apc crash sites."),
		new TokenisedPhrase("menutip_canmelt", "You can melt Empty Cans in a campfire to receive Metal Fragments."),
		new TokenisedPhrase("menutip_stacksplit", "You can split a stack of items in half by holding [Middle Mouse] and dragging"),
		new TokenisedPhrase("menutip_divesite", "Floating Buoys on the ocean indicate a potential dive site, You may find treasure below"),
		new TokenisedPhrase("menutip_craftingqueue", "You can move crafting items to the front of the crafting queue by right clicking on the item in the crafting queue"),
		new TokenisedPhrase("menutip_thirdsplit", "You can split stacks of items into a third by holding Shift and [Middle Mouse] dragging"),
		new TokenisedPhrase("menutip_removeitemquickcraft", "You can cancel crafting an item by right clicking the item in the quick craft menu"),
		new TokenisedPhrase("menutip_quickcraftmulti", "[Middle Mouse] an item in quick craft menu will add 5x to your crafting queue"),
		new TokenisedPhrase("menutip_inputsplit", "You can split items by the exact amount by right clicking the split bar"),
		new TokenisedPhrase("menutip_gestures", "Cheer on your friends by pressing [+gestures] to open the gesture menu"),
		new TokenisedPhrase("menutip_horsesharperturns", "Hold [+duck] while riding to make your horse take sharper turns"),
		new TokenisedPhrase("menutip_horseskid", "Pressing [+duck] while galloping will make your horse skid and stop faster")
	};

	private int currentTipIndex;

	private float nextTipTime;

	private bool disabled;

	public void OnEnable()
	{
		disabled = false;
		icon.SetIcon((Icons)61530);
		currentTipIndex = Random.Range(0, MenuTips.Length);
	}

	public void Update()
	{
		if (LoadingScreen.isOpen && !disabled && Time.realtimeSinceStartup >= nextTipTime)
		{
			currentTipIndex++;
			if (currentTipIndex >= MenuTips.Length)
			{
				currentTipIndex = 0;
			}
			nextTipTime = Time.realtimeSinceStartup + 6f;
			UpdateTip();
		}
	}

	public void SetCustomTip(string iconString, string tip)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!Enum.TryParse<Icons>(iconString, ignoreCase: true, out Icons result))
		{
			result = (Icons)61737;
		}
		icon.SetIcon(result);
		text.SetText(StringExtensions.Truncate(StringEx.FilterRichText(tip, true, new string[4] { "color", "u", "b", "i" }), 400, (string)null));
		disabled = true;
	}

	public void UpdateTip()
	{
		text.SetPhrase(MenuTips[currentTipIndex], Array.Empty<object>());
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SelectedContact : SingletonComponent<SelectedContact>
{
	public RustText nameText;

	public RustText seenText;

	public RawImage mugshotImage;

	public Texture2D unknownMugshot;

	public InputField noteInput;

	public GameObject[] relationshipTypeTags;

	public Phrase lastSeenPrefix;

	public Phrase nowPhrase;

	public Phrase agoSuffix;

	public RustButton FriendlyButton;

	public RustButton SeenButton;

	public RustButton EnemyButton;

	public RustButton chatMute;
}


using UnityEngine;

public class UIBuffs : SingletonComponent<UIBuffs>
{
	public bool Enabled = true;

	public Transform PrefabBuffIcon;

	public void Refresh(PlayerModifiers modifiers)
	{
		if (!Enabled)
		{
			return;
		}
		RemoveAll();
		if ((Object)(object)modifiers == (Object)null)
		{
			return;
		}
		foreach (Modifier item in modifiers.All)
		{
			if (item != null)
			{
				Object.Instantiate<Transform>(PrefabBuffIcon).SetParent(((Component)this).transform);
			}
		}
	}

	private void RemoveAll()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in ((Component)this).transform)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
	}
}


using TMPro;
using UnityEngine;

public abstract class UIBuffsIcon<T, T2> : SingletonComponent<UIBuffsIcon<T, T2>> where T : BaseModifiers<T2> where T2 : BaseCombatEntity
{
	public TextMeshProUGUI Text;

	public Tooltip ToolTip;

	public CanvasGroup Group;

	protected UIBuffsIcon()
	{
		((SingletonComponent<UIBuffsIcon<UIBuffsIcon<T, T2>, ?>>)(object)this)..ctor();
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UICompass : MonoBehaviour
{
	public RawImage compassStrip;

	public CanvasGroup compassGroup;

	public List<CompassMapMarker> CompassMarkers;

	public List<CompassMapMarker> TeamCompassMarkers;

	public List<CompassMissionMarker> MissionMarkers;

	public CompassMapMarker DeathMarker;

	public static readonly Phrase IslandInfoPhrase = new Phrase("nexus.compass.island_info", "Continue for {distance} to travel to {zone}");

	public RectTransform IslandInfoContainer;

	public RustText IslandInfoText;

	public float IslandInfoDistanceThreshold = 250f;

	public float IslandLookThreshold = -0.8f;

	public RectTransform IslandInfoFullContainer;

	public List<CompassMapMarker> LocalPings;

	public List<CompassMapMarker> TeamPings;

	public Image LeftPingPulse;

	public Image RightPingPulse;
}


using UnityEngine;

public class UIFadeOut : MonoBehaviour
{
	public float secondsToFadeOut = 3f;

	public bool destroyOnFaded = true;

	public CanvasGroup targetGroup;

	public float fadeDelay;
}


using UnityEngine;
using UnityEngine.UI;

public class UIFishing : SingletonComponent<UIFishing>
{
	public Slider TensionLine;

	public Image FillImage;

	public Gradient FillGradient;

	private void Start()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


public class UIHorseBuffsIcon : UIBuffsIcon<HorseModifiers, RidableHorse>
{
}


using UnityEngine;

public class UIHUD : SingletonComponent<UIHUD>, IUIScreen
{
	public UIChat chatPanel;

	public HudElement Hunger;

	public HudElement Thirst;

	public HudElement Health;

	public HudElement PendingHealth;

	public HudElement VehicleHealth;

	public HudElement AnimalStamina;

	public HudElement AnimalStaminaMax;

	public HudElement ShieldHealth;

	public RectTransform vitalsRect;

	public RectTransform noticesRect;

	public Canvas healthCanvas;

	public UICompass CompassWidget;

	public GameObject KeyboardCaptureMode;
}


public class UIPlayerBuffsIcon : UIBuffsIcon<PlayerModifiers, BasePlayer>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIRecordingInfo : SingletonComponent<UIRecordingInfo>
{
	public RustText CountdownText;

	public Slider TapeProgressSlider;

	public GameObject CountdownRoot;

	public GameObject RecordingRoot;

	public Transform Spinner;

	public float SpinSpeed = 180f;

	public Image CassetteImage;

	private void Start()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIRestrained : SingletonComponent<UIRestrained>
{
	public Image Fill;

	private void Start()
	{
		SetActive(state: false);
		SetProgress(0f);
	}

	public void SetActive(bool state)
	{
		((Component)this).gameObject.SetActive(state);
	}

	public void SetProgress(Item handcuffItem)
	{
		if (handcuffItem == null)
		{
			SetProgress(0f);
		}
		else
		{
			SetProgress(1f - handcuffItem.condition / handcuffItem.maxCondition);
		}
	}

	public void SetProgress(float progress)
	{
		Fill.fillAmount = progress;
	}
}


public class UIUnderlay : SingletonComponent<UIUnderlay>
{
	public GameObjectRef damageDirectional;

	public GameObjectRef waterDirectional;
}


using UnityEngine;

public class IngameMenuBackground : MonoBehaviour
{
	public static bool Enabled;

	public CanvasGroup canvasGroup;
}


public class AmmoInformationPanel : ItemInformationPanel
{
	public ItemTextValue[] modifierValues;

	public ItemTextValue durationValue;

	public ItemStatValue damageDisplay;

	public ItemStatValue velocityDisplay;

	public ItemStatValue spreadDisplay;

	public ItemTextValue pelletsDisplay;

	public ItemStatValue falloffRangeDisplay;

	public ItemTextValue thicknessDisplay;
}


using UnityEngine;
using UnityEngine.UI;

public class ArmorInformationPanel : ItemInformationPanel
{
	public ItemTextValue projectileDisplay;

	public ItemTextValue meleeDisplay;

	public ItemTextValue coldDisplay;

	public ItemTextValue explosionDisplay;

	public ItemTextValue radiationDisplay;

	public ItemTextValue biteDisplay;

	public ItemTextValue speedDisplay;

	public ItemTextValue spacer;

	public Text areaProtectionText;

	public Phrase LegText;

	public Phrase ChestText;

	public Phrase HeadText;

	public Phrase ChestLegsText;

	public Phrase WholeBodyText;

	public ItemTextValue eggVision;

	public ItemIcon[] insertIcons;

	public GridLayoutGroup informationGridLayout;

	public RectOffset paddingOnResize;

	public Vector2 cellSizeOnResize;

	public Vector2 spacingOnResize;

	private RectOffset originalPadding;

	private Vector2 originalCellSize;

	private Vector2 originalSpacing;

	private ProtectionProperties protection;
}


public class ArmorInsertInformationPanel : ItemInformationPanel
{
	public ItemTextValue projectileDisplay;

	public ItemTextValue meleeDisplay;

	public ItemTextValue coldDisplay;

	public ItemTextValue explosionDisplay;

	public ItemTextValue radiationDisplay;

	public ItemTextValue biteDisplay;

	public ItemTextValue spacer;
}


using UnityEngine;

public class BackpackInventoryPanel : MonoBehaviour
{
	private ItemIcon icon;

	public GameObject[] ShowWhenSelected;

	public GameObject[] HideWhenSelected;

	public Vector3 BackpackTargetRotation = new Vector3(0f, 0f, 0f);

	public Vector3 BackpackTargetUIShift = Vector2.op_Implicit(new Vector2(160f, 0f));

	public AnimationCurve BackpackModelRotateCurve;

	public AnimationCurve BackpackUIShiftCurve;

	public AnimationCurve BackpackTransparencyCurve;

	public AnimationCurve FadeOutWhenOpenCurve;

	public float OpenScale = 1f;

	public float CloseScale = 1f;

	public float BackpackAlphaActiveThreshold = 1f;

	public RectTransform PreviewModelRectTransform;

	public CanvasGroup BackpackInventoryCanvas;

	public CanvasGroup[] FadeOutWhenOpen;
}


using Rust.UI;
using UnityEngine;

public class BeltBarIcon : MonoBehaviour
{
	public RustText TextBind;

	public string bind;
}


using UnityEngine;

public class BlueprintInformationPanel : ItemInformationPanel
{
	public GameObject LearnedRoot;

	public GameObject NotLearnedRoot;

	public GameObject NotLearnableRoot;
}


using UnityEngine;
using UnityEngine.UI;

public class BlueprintButton : MonoBehaviour, IClientComponent, IInventoryChanged
{
	public Image image;

	public Image imageFavourite;

	public Button button;

	public CanvasGroup group;

	public GameObject newNotification;

	public GameObject lockedOverlay;

	public Tooltip Tip;

	public Image FavouriteIcon;

	public PingWidget TutorialHighlight;
}


using TMPro;
using UnityEngine;

public class BlueprintCategoryButton : MonoBehaviour, IInventoryChanged
{
	public TextMeshProUGUI amountLabel;

	public ItemCategory Category;

	public bool AlwaysShow;

	public bool ShowItemCount = true;

	public GameObject BackgroundHighlight;

	public SoundDefinition clickSound;

	public SoundDefinition hoverSound;

	public PingWidget tutorialHighlight;
}


using Rust.UI;
using UnityEngine;

public class BlueprintCraftGridRow : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public RustText amountText;

	public RustText itemNameText;

	public RustText totalText;

	public RustText haveText;

	public Color colorOK;

	public Color colorBad;
}


using UnityEngine;
using UnityEngine.UI;

public class BlueprintHeader : MonoBehaviour
{
	public Text categoryName;

	public Text unlockCount;

	public void Setup(ItemCategory name, int unlocked, int total)
	{
		categoryName.text = name.ToString().ToUpper();
		unlockCount.text = $"UNLOCKED {unlocked}/{total}";
	}
}


using TMPro;
using UnityEngine;

public class CraftingNotice : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public TextMeshProUGUI itemName;

	public TextMeshProUGUI craftSeconds;
}


using UnityEngine;
using UnityEngine.UI;

public class CraftingQueue : SingletonComponent<CraftingQueue>
{
	public GameObject queueContainer;

	public GameObject queueItemPrefab;

	private ScrollRect scrollRect;
}


using UnityEngine;
using UnityEngine.UI;

public class CraftingQueueIcon : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public Image icon;

	public Image iconCancel;

	public GameObject timeLeft;

	public GameObject craftingCount;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SelectedBlueprint : SingletonComponent<SelectedBlueprint>, IInventoryChanged
{
	public ItemBlueprint blueprint;

	public InputField craftAmountText;

	public GameObject ingredientGrid;

	public IconSkinPicker skinPicker;

	public Image iconImage;

	public RustText titleText;

	public RustText descriptionText;

	public CanvasGroup CraftArea;

	public Button CraftButton;

	public RustText CraftingTime;

	public RustText CraftingAmount;

	public GameObject TutorialCraftButtonHighlight;

	public Sprite FavouriteOnSprite;

	public Sprite FavouriteOffSprite;

	public Image FavouriteButtonStatusMarker;

	public GameObject[] workbenchReqs;

	private ItemInformationPanel[] informationPanels;

	public static bool isOpen
	{
		get
		{
			if ((Object)(object)SingletonComponent<SelectedBlueprint>.Instance == (Object)null)
			{
				return false;
			}
			return (Object)(object)SingletonComponent<SelectedBlueprint>.Instance.blueprint != (Object)null;
		}
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UIBlueprints : ListComponent<UIBlueprints>
{
	public GameObjectRef buttonPrefab;

	public ScrollRect scrollRect;

	public CanvasGroup ScrollRectCanvasGroup;

	public TMP_InputField searchField;

	public GameObject searchFieldPlaceholder;

	public GameObject listAvailable;

	public GameObject listLocked;

	public GameObject Categories;

	public VerticalLayoutGroup CategoryVerticalLayoutGroup;

	public BlueprintCategoryButton FavouriteCategoryButton;
}


using System;
using Rust.UI;
using UnityEngine;

public class ChangelogButton : MonoBehaviour
{
	public RustButton Button;

	public CanvasGroup CanvasGroup;

	private void Update()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Expected O, but got Unknown
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: false);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			if (CanvasGroup.alpha != 1f)
			{
				CanvasGroup.alpha = 1f;
				CanvasGroup.blocksRaycasts = true;
				Button.Text.SetPhrase(new Phrase(activeGameMode.shortname, activeGameMode.shortname), Array.Empty<object>());
			}
		}
		else if (CanvasGroup.alpha != 0f)
		{
			CanvasGroup.alpha = 0f;
			CanvasGroup.blocksRaycasts = false;
		}
	}
}


using Rust.UI;
using UnityEngine;

public class ChangelogPanel : MonoBehaviour
{
	public GameObject AddedHeader;

	public GameObject RemovedHeader;

	public GameObject ChangedHeader;

	public RustText AddedContent;

	public RustText RemovedContent;

	public RustText ChangedContent;
}


using UnityEngine;
using UnityEngine.UI;

public class ChickenCoopStatusNeedWidget : MonoBehaviour
{
	public Image ProgressImage;

	public Image BackgroundImage;

	public Color BackgroundPositiveColour;

	public Color BackgroundNegativeColour;

	public Color ProgressPositiveColour;

	public Color ProgressNegativeColour;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChickenCoopStatusWidget : MonoBehaviour
{
	public RustText HatchTime;

	public Image HatchProgressBar;

	public GameObject HatchingRoot;

	public GameObject AliveRoot;

	public RustText NameText;

	public ChickenCoopStatusNeedWidget HungerWidget;

	public ChickenCoopStatusNeedWidget ThirstWidget;

	public ChickenCoopStatusNeedWidget LoveWidget;

	public ChickenCoopStatusNeedWidget SunlightWidget;

	public GameObject HappyFace;

	public GameObject NeutralFace;

	public GameObject SadFace;

	public TMP_InputField NameInput;

	public GameObject NameEditRoot;

	public bool IsLootPanel;
}


public class ConstructableInformationPanel : ItemInformationPanel
{
	public BlueprintCraftGridRow[] ingredientRows;
}


using UnityEngine;
using UnityEngine.UI;

public class ConsumableInformationPanel : ItemInformationPanel
{
	public ItemTextValue[] values;

	public UIGenesDisplay Genes;

	public Text TextUnknownGenetics;

	public Text LabelGenetics;

	public GameObject GeneticsGameObject;

	public ItemTextValue durationValue;

	public ItemTextValue baitValue;

	public ItemTextValue baitStackSize;

	public ItemTextValue spoilTime;

	public GameObject refrigeratedIcon;

	public GameObject chickenFood;
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class DragReceiver : MonoBehaviour
{
	[Serializable]
	public class TriggerEvent : UnityEvent<BaseEventData>
	{
	}

	public TriggerEvent onEndDrag;
}


using System;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[Serializable]
public class TriggerEvent : UnityEvent<BaseEventData>
{
}


using Rust.UI;

public class DroneInformationPanel : ItemInformationPanel
{
	public RustText identifierLabel;
}


using UnityEngine;
using UnityEngine.UI;

public class EngineItemInformationPanel : ItemInformationPanel
{
	[SerializeField]
	private Text tier;

	[SerializeField]
	private Phrase low;

	[SerializeField]
	private Phrase medium;

	[SerializeField]
	private Phrase high;

	[SerializeField]
	private GameObject accelerationRoot;

	[SerializeField]
	private GameObject topSpeedRoot;

	[SerializeField]
	private GameObject fuelEconomyRoot;
}


using UnityEngine.UI;

public class ExplosiveInformationPanel : ItemInformationPanel
{
	public ItemTextValue explosiveDmgDisplay;

	public ItemTextValue lethalDmgDisplay;

	public ItemTextValue throwDistanceDisplay;

	public ItemTextValue projectileDistanceDisplay;

	public ItemTextValue fuseLengthDisplay;

	public ItemTextValue blastRadiusDisplay;

	public Text unreliableText;
}


public class FlameThrowerInformationPanel : ItemInformationPanel
{
	public ItemStatValue damageDisplay;

	public ItemStatValue rangeDisplay;
}


public class FrankensteinPartInformationPanel : ItemInformationPanel
{
	public ItemTextValue healthDisplay;

	public ItemTextValue speedDisplay;

	public ItemTextValue attackRateDisplay;

	public ItemTextValue attackDamageDisplay;
}


public class GunModInformationPanel : ItemInformationPanel
{
	public ItemTextValue fireRateDisplay;

	public ItemTextValue velocityDisplay;

	public ItemTextValue damageDisplay;

	public ItemTextValue accuracyDisplay;

	public ItemTextValue recoilDisplay;

	public ItemTextValue zoomDisplay;

	public ItemTextValue ammoDisplay;
}


using UnityEngine;
using UnityEngine.UI;

public class HeadInformationPanel : ItemInformationPanel
{
	public ItemDefinition HeadInfo;

	public GameObject PlayerRoot;

	public GameObject NPCRoot;

	public GameObject HorseRoot;

	public Image NPCImage;

	public Text NPCText;

	public Text PlayerNameText;

	public Text PlayerIdText;

	public Text HorseBreedText;
}


public class HorseEquipmentInformationPanel : ItemInformationPanel
{
	public ItemTextValue horseProtectionDisplay;

	public ItemTextValue riderProtectionDisplay;

	public ItemTextValue maxSpeedDisplay;

	public ItemTextValue storageAmountDisplay;
}


public class IOEntityInformationPanel : ItemInformationPanel
{
	public ItemTextValue requiredPowerDisplay;

	public ItemTextValue requiredFluidDisplay;

	public ItemTextValue generatedPowerDisplay;

	public ItemTextValue capacityDisplay;

	public ItemTextValue chargeDisplay;

	public ItemTextValue rangeDisplay;
}


using UnityEngine;

public class ItemDropCommand : MonoBehaviour
{
	public string command = "drop";
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ItemIcon : BaseMonoBehaviour, IPointerClickHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler, IDraggable, IPreInventoryChanged, IItemAmountChanged, IItemIconChanged
{
	private Color backgroundColor;

	public Color selectedBackgroundColor = new Color(0.12156863f, 0.41960785f, 32f / 51f, 40f / 51f);

	public float unoccupiedAlpha = 1f;

	public Color unoccupiedColor;

	public ItemContainerSource containerSource;

	public int slotOffset;

	[Range(0f, 64f)]
	public int slot;

	public bool setSlotFromSiblingIndex = true;

	public GameObject slots;

	public CanvasGroup iconContents;

	public CanvasGroup canvasGroup;

	public Image iconImage;

	public Image underlayImage;

	public Text amountText;

	public Text hoverText;

	public Image hoverOutline;

	public Image cornerIcon;

	public Image lockedImage;

	public Image progressImage;

	public Image backgroundImage;

	public Image backgroundUnderlayImage;

	public Image progressPanel;

	public Sprite emptySlotBackgroundSprite;

	public CanvasGroup conditionObject;

	public Image conditionFill;

	public Image maxConditionFill;

	public GameObject lightEnabled;

	public GameObject burstEnabled;

	public bool allowSelection = true;

	public bool allowDropping = true;

	public bool allowMove = true;

	public bool showCountDropShadow;

	[NonSerialized]
	public Item item;

	[NonSerialized]
	public bool invalidSlot;

	public SoundDefinition hoverSound;

	public virtual void OnPointerClick(PointerEventData eventData)
	{
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
	}

	public void OnPointerExit(PointerEventData eventData)
	{
	}
}


using UnityEngine;

public class ItemInformationPanel : MonoBehaviour
{
	public bool ForceHidden(ItemDefinition info)
	{
		if ((Object)(object)info == (Object)null)
		{
			return false;
		}
		return (Object)(object)((Component)info).GetComponent<ItemModHideInfoPanel>() != (Object)null;
	}

	public virtual bool EligableForDisplay(ItemDefinition info)
	{
		return false;
	}

	public virtual void SetupForItem(ItemDefinition info, Item item = null)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ItemModifiableStatValue : MonoBehaviour
{
	public Text text;

	public Slider slider;

	public Slider positiveModificationSlider;

	public Slider negativeModificationSlider;

	public Tooltip modificationNumbersTooltip;

	public bool smallerIsBetter;

	public bool asPercentage;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ItemOptionButton : MonoBehaviour
{
	public RustText name;

	public Image icon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ItemOwnershipPanel : MonoBehaviour
{
	public LayoutElement Layout;

	public Image BackgroundImage;

	public Tooltip Tooltip;

	public RustText Label;

	public Color[] Colors;
}


public class ItemPanel : SingletonComponent<ItemPanel>
{
}


public interface IItemPanel
{
}


using TMPro;
using UnityEngine;

public class ItemPickupNotice : MonoBehaviour
{
	public TextMeshProUGUI Text;

	public TextMeshProUGUI Amount;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class ItemPreviewIcon : BaseMonoBehaviour, IInventoryChanged, IItemAmountChanged, IItemIconChanged
{
	public ItemContainerSource containerSource;

	[Range(0f, 64f)]
	public int slot;

	public bool setSlotFromSiblingIndex = true;

	public CanvasGroup iconContents;

	public Image iconImage;

	public Text amountText;

	[NonSerialized]
	public Item item;
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ItemSplitter : MonoBehaviour
{
	public Slider slider;

	public TextMeshProUGUI textValue;

	public TextMeshProUGUI splitAmountText;

	public TMP_InputField amountInputField;
}


using UnityEngine;

public class ItemSplitterDragOut : MonoBehaviour, IDraggable
{
	public ItemSplitter rootSplitter;
}


using UnityEngine;

public class ItemSplitterSlider : MonoBehaviour
{
	public ItemSplitter Splitter;
}


using UnityEngine;
using UnityEngine.UI;

public class ItemStatValue : MonoBehaviour
{
	public Text text;

	public Slider slider;

	public bool smallerIsBetter;

	public bool asPercentage;
}


public class ItemSubmitPanel : LootPanel
{
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class ItemTextValue : MonoBehaviour
{
	public Text text;

	public Color bad;

	public Color good;

	public bool negativestat;

	public bool asPercentage;

	public bool useColors = true;

	public bool signed = true;

	public string affix;

	public string suffix;

	public float multiplier = 1f;

	public float addition;

	public void SetValue(float val, int numDecimals = 0, string overrideText = "")
	{
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		val = val * multiplier + addition;
		text.text = ((overrideText == "") ? string.Format("{0}{1:n" + numDecimals + "}", (val > 0f && signed) ? "+" : "", val) : overrideText);
		if (!string.IsNullOrEmpty(affix))
		{
			text.text = affix + text.text;
		}
		if (asPercentage)
		{
			Text obj = text;
			obj.text += " %";
		}
		if (suffix != "" && !float.IsPositiveInfinity(val))
		{
			Text obj2 = text;
			obj2.text += suffix;
		}
		bool flag = val > 0f;
		if (negativestat)
		{
			flag = !flag;
		}
		if (useColors)
		{
			((Graphic)text).color = (flag ? good : bad);
		}
	}

	public void SetValue(TimeSpan time)
	{
		text.text = time.ToShortString();
	}

	public void SetValue(string display)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		text.text = display;
		if (!string.IsNullOrEmpty(affix))
		{
			text.text = affix + text.text;
		}
		bool flag = true;
		if (negativestat)
		{
			flag = !flag;
		}
		if (useColors)
		{
			((Graphic)text).color = (flag ? good : bad);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class KeyInformationPanel : ItemInformationPanel
{
	[SerializeField]
	private Text id;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LootPanel : MonoBehaviour
{
	public interface IHasLootPanel
	{
		Phrase LootPanelTitle { get; }
	}

	public Text Title;

	public RustText TitleText;

	public bool hideInvalidIcons;

	[Tooltip("Only needed if hideInvalidIcons is true")]
	public CanvasGroup canvasGroup;
}


public interface IHasLootPanel
{
	Phrase LootPanelTitle { get; }
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelCardTableTerminal : LootPanel
{
	[SerializeField]
	private Text buyInInfoText;

	[SerializeField]
	private Phrase phraseMin;

	[SerializeField]
	private Phrase phraseMax;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelChickenCoop : LootPanel
{
	public ChickenCoopStatusWidget[] StatusWidgets;

	public CanvasGroup ControlsGroup;

	public Button fromButton;

	public Button toButton;

	public Tooltip FoodTooltip;
}


using UnityEngine;

public class LootPanelContainer : MonoBehaviour
{
	public static string containerName = "generic";

	public GameObject NoLootPanel;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LootPanelEngine : LootPanel
{
	[SerializeField]
	private Image engineImage;

	[SerializeField]
	private ItemIcon[] icons;

	[SerializeField]
	private GameObject warning;

	[SerializeField]
	private RustText hp;

	[SerializeField]
	private RustText power;

	[SerializeField]
	private RustText acceleration;

	[SerializeField]
	private RustText topSpeed;

	[SerializeField]
	private RustText fuelEconomy;
}


using UnityEngine.UI;

public class LootPanelFrankensteinTable : LootPanel, IInventoryChanged
{
	public Button StartCreatingButton;
}


using Rust.UI;
using UnityEngine;

public class LootPanelHorse : LootPanel
{
	public RustText breedTitle;

	public RustText healthText;

	public RustText maxSpeedText;

	public RustText staminaText;

	public GameObject[] storageSlots;

	public GameObject buffs;
}


using Rust.UI;
using UnityEngine;

public class LootPanelIndustrialCrafter : LootPanel
{
	public GameObject CraftingRoot;

	public RustSlider ProgressSlider;

	public Transform Spinner;

	public float SpinSpeed = 90f;

	public GameObject WorkbenchLevelRoot;
}


using UnityEngine;

public class LootPanelLocker : LootPanel
{
	public GameObject[] controls;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelMixingTable : LootPanel, IInventoryChanged
{
	public GameObject controlsOn;

	public GameObject controlsOff;

	public Button StartMixingButton;

	public InfoBar ProgressBar;

	public GameObjectRef recipeItemPrefab;

	public RectTransform recipeContentRect;

	public ScrollRect ScrollView;

	public static readonly Phrase MixingPhrase = new Phrase("mixingtable.mixing", "Mixing... {0} seconds remaining");

	public static readonly Phrase CookingPhrase = new Phrase("cookingworkbench.cooking", "Cooking... {0} seconds remaining");
}


public class LootPanelOven : LootPanel
{
}


using UnityEngine;

public class LootPanelPlayerCorpse : LootPanel
{
	public GameObject[] BeltRoots;

	public GameObject[] ClothingRoots;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelReclaim : LootPanel
{
	public int oldOverflow = -1;

	public Text overflowText;

	public GameObject overflowObject;

	public static readonly Phrase MorePhrase = new Phrase("reclaim.more", "additional items...");
}


using UnityEngine;

public class LootPanelRecycler : LootPanel
{
	public GameObject controlsOn;

	public GameObject controlsOff;

	public GameObject recycle_efficiency_safezone;

	public GameObject recycle_efficiency_radtown;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LootPanelTrophyStand : LootPanel
{
	public GameObject SubmitButton;

	public GameObject NonMatchingTrophyButton;

	public Text CountText;

	public GameObject CountRoot;

	public GameObject NameRoot;

	public RustText NameText;

	public GameObject ClearButton;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelWaterCatcher : LootPanel
{
	public ItemIcon sourceItem;

	public Image capacityImage;

	public CanvasGroup helpCanvas;

	public CanvasGroup buttonsCanvas;

	public Button fromButton;

	public Button toButton;

	public Button drinkButton;
}


using UnityEngine;

public class MeleeWeaponInformationPanel : ItemInformationPanel
{
	public ItemStatValue damageDisplay;

	public ItemStatValue attackRateDisplay;

	public ItemStatValue attackSizeDisplay;

	public ItemStatValue attackRangeDisplay;

	public ItemStatValue oreGatherDisplay;

	public ItemStatValue treeGatherDisplay;

	public ItemStatValue fleshGatherDisplay;

	public GameObject untieCrateDisplay;

	public GameObject shieldCompatible;
}


using UnityEngine;

public class NoticeArea : SingletonComponent<NoticeArea>
{
	public GameObjectRef itemPickupPrefab;

	public GameObjectRef itemPickupCondensedText;

	public GameObjectRef itemDroppedPrefab;

	public AnimationCurve pickupSizeCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve pickupAlphaCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve reuseAlphaCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve reuseSizeCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	private IVitalNotice[] notices;

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		notices = ((Component)this).GetComponentsInChildren<IVitalNotice>(true);
	}
}


using System;
using UnityEngine;

public class LootAllButton : MonoBehaviour
{
	public Func<Item, bool> Filter;

	public OvenLootPanel inventoryGrid;
}


using System.Collections.Generic;
using UnityEngine;

public class LootGrid : MonoBehaviour
{
	public int Container;

	public int Offset;

	public int Count = 1;

	public GameObject ItemIconPrefab;

	public Sprite BackgroundImage;

	public ItemContainerSource Inventory;

	private List<ItemIcon> _icons = new List<ItemIcon>();

	public void CreateInventory(ItemContainerSource inventory, int? slots = null, int? offset = null)
	{
		foreach (ItemIcon icon in _icons)
		{
			Object.Destroy((Object)(object)((Component)icon).gameObject);
		}
		_icons.Clear();
		Inventory = inventory;
		Count = slots ?? Count;
		Offset = offset ?? Offset;
		for (int i = 0; i < Count; i++)
		{
			ItemIcon component = Object.Instantiate<GameObject>(ItemIconPrefab, ((Component)this).transform).GetComponent<ItemIcon>();
			component.slot = Offset + i;
			component.emptySlotBackgroundSprite = BackgroundImage ?? component.emptySlotBackgroundSprite;
			component.containerSource = inventory;
			_icons.Add(component);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust.UI;
using UnityEngine;

public class OvenItemIcon : MonoBehaviour
{
	[Serializable]
	public class OvenSlotConfig
	{
		public OvenSlotType Type;

		public Sprite BackgroundImage;

		public Phrase SlotPhrase;
	}

	public ItemIcon ItemIcon;

	public RustText ItemLabel;

	public RustText MaterialLabel;

	public OvenSlotType SlotType;

	public Phrase EmptyPhrase = new Phrase("empty", "empty");

	public List<OvenSlotConfig> SlotConfigs = new List<OvenSlotConfig>();

	public float DisabledAlphaScale;

	public CanvasGroup CanvasGroup;

	private Item _item;

	private void Start()
	{
		OvenSlotConfig ovenSlotConfig = SlotConfigs.FirstOrDefault((OvenSlotConfig x) => x.Type == SlotType);
		if (ovenSlotConfig == null)
		{
			Debug.LogError((object)$"Can't find slot config for '{SlotType}'");
			return;
		}
		ItemIcon.emptySlotBackgroundSprite = ovenSlotConfig.BackgroundImage;
		MaterialLabel.SetPhrase(ovenSlotConfig.SlotPhrase, Array.Empty<object>());
		UpdateLabels();
	}

	private void Update()
	{
		if (ItemIcon.item != _item)
		{
			_item = ItemIcon.item;
			UpdateLabels();
		}
	}

	private void UpdateLabels()
	{
		CanvasGroup.alpha = ((_item != null) ? 1f : DisabledAlphaScale);
		RustText itemLabel = ItemLabel;
		if (itemLabel != null)
		{
			itemLabel.SetPhrase((_item == null) ? EmptyPhrase : _item.info.displayName, Array.Empty<object>());
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class OvenSlotConfig
{
	public OvenSlotType Type;

	public Sprite BackgroundImage;

	public Phrase SlotPhrase;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class OvenLineRow : MonoBehaviour
{
	public LootGrid Above;

	public LootGrid Below;

	public Transform Container;

	public Color Color = Color.white;

	public Sprite TriangleSprite;

	public int LineWidth = 2;

	public int ArrowWidth = 6;

	public int ArrowHeight = 4;

	public int Padding = 2;

	private int _topCount;

	private int _bottomCount;

	private List<GameObject> images = new List<GameObject>();

	private void Update()
	{
		LootGrid above = Above;
		int num = ((above != null) ? ((Component)above).transform.childCount : 0);
		LootGrid below = Below;
		int num2 = ((below != null) ? ((Component)below).transform.childCount : 0);
		if (num2 == _bottomCount && num == _topCount)
		{
			return;
		}
		_bottomCount = num2;
		_topCount = num;
		foreach (GameObject image in images)
		{
			Object.Destroy((Object)(object)image);
		}
		CreateRow(above: true);
		CreateRow(above: false);
	}

	private void CreateRow(bool above)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		LootGrid lootGrid = (above ? Above : Below);
		int num = (above ? _topCount : _bottomCount);
		if (num == 0)
		{
			return;
		}
		int num2 = num;
		GridLayoutGroup component = ((Component)lootGrid).GetComponent<GridLayoutGroup>();
		float x = component.cellSize.x;
		float x2 = component.spacing.x;
		float num3 = x + x2;
		float num4 = num3 * (float)(num - 1) / 2f;
		if (above)
		{
			for (int i = 0; i < num; i++)
			{
				if (i == 0 || i == num - 1)
				{
					Image obj = CreateImage();
					((Graphic)obj).rectTransform.anchorMin = new Vector2(0.5f, above ? 0.5f : 0f);
					((Graphic)obj).rectTransform.anchorMax = new Vector2(0.5f, above ? 1f : 0.5f);
					((Graphic)obj).rectTransform.offsetMin = new Vector2(0f - num4 + (float)i * num3 - (float)(LineWidth / 2), (float)(above ? (LineWidth / 2) : Padding));
					((Graphic)obj).rectTransform.offsetMax = new Vector2(0f - num4 + (float)i * num3 + (float)(LineWidth / 2), (float)(above ? (-Padding) : (-LineWidth / 2)));
				}
			}
		}
		else
		{
			Image obj2 = CreateImage();
			((Graphic)obj2).rectTransform.anchorMin = new Vector2(0.5f, 0f);
			((Graphic)obj2).rectTransform.anchorMax = new Vector2(0.5f, 0.5f);
			((Graphic)obj2).rectTransform.offsetMin = new Vector2((float)(-LineWidth / 2), (float)Padding);
			((Graphic)obj2).rectTransform.offsetMax = new Vector2((float)(LineWidth / 2), (float)(-LineWidth / 2));
			Image obj3 = CreateImage();
			obj3.sprite = TriangleSprite;
			((Object)((Component)obj3).gameObject).name = "triangle";
			obj3.useSpriteMesh = true;
			((Transform)((Graphic)obj3).rectTransform).localRotation = Quaternion.Euler(0f, 0f, 180f);
			((Graphic)obj3).rectTransform.anchorMin = new Vector2(0.5f, 0f);
			((Graphic)obj3).rectTransform.anchorMax = new Vector2(0.5f, 0f);
			((Graphic)obj3).rectTransform.pivot = new Vector2(0.5f, 0f);
			((Graphic)obj3).rectTransform.offsetMin = new Vector2((float)(-ArrowWidth / 2), 0f);
			((Graphic)obj3).rectTransform.offsetMax = new Vector2((float)(ArrowWidth / 2), (float)ArrowHeight);
		}
		if (above && num2 >= 1)
		{
			float num5 = num3 * (float)(num2 - 1) + (float)LineWidth;
			Image obj4 = CreateImage();
			((Graphic)obj4).rectTransform.anchorMin = new Vector2(0.5f, 0.5f);
			((Graphic)obj4).rectTransform.anchorMax = new Vector2(0.5f, 0.5f);
			((Graphic)obj4).rectTransform.offsetMin = new Vector2(num5 / -2f, (float)(-LineWidth / 2));
			((Graphic)obj4).rectTransform.offsetMax = new Vector2(num5 / 2f, (float)(LineWidth / 2));
		}
	}

	private Image CreateImage()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = new GameObject("Line");
		Image obj = val.AddComponent<Image>();
		images.Add(val);
		((Transform)((Graphic)obj).rectTransform).SetParent(Container ?? ((Component)this).transform);
		((Component)obj).transform.localScale = Vector3.one;
		((Graphic)obj).color = Color;
		return obj;
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class OvenLootPanel : MonoBehaviour
{
	public GameObject controlsOn;

	public GameObject controlsOff;

	public Image TitleBackground;

	public RustText TitleText;

	public Color AlertBackgroundColor;

	public Color AlertTextColor;

	public Color OffBackgroundColor;

	public Color OffTextColor;

	public Color OnBackgroundColor;

	public Color OnTextColor;

	private Phrase OffPhrase = new Phrase("off", "off");

	private Phrase OnPhrase = new Phrase("on", "on");

	private Phrase NoFuelPhrase = new Phrase("no_fuel", "No Fuel");

	public GameObject FuelRowPrefab;

	public GameObject MaterialRowPrefab;

	public GameObject ItemRowPrefab;

	public Sprite IconBackground_Wood;

	public Sprite IconBackGround_Input;

	public LootGrid LootGrid_Wood;

	public LootGrid LootGrid_Input;

	public LootGrid LootGrid_Output;

	public GameObject Contents;

	public GameObject[] ElectricDisableRoots = (GameObject[])(object)new GameObject[0];
}


public enum OvenSlotType
{
	Fuel,
	Charcoal,
	Material,
	Smelted,
	FoodInput,
	FoodOutput
}


public enum OvenStatus
{
	NoFuel,
	Off,
	On
}


using UnityEngine.UI;

public class PaperDollSegment : BaseMonoBehaviour
{
	public static HitArea selectedAreas;

	[InspectorFlags]
	public HitArea area;

	public Image overlayImg;
}


using UnityEngine;

public class ProjectileWeaponInformationPanel : ItemInformationPanel
{
	public ItemModifiableStatValue damageDisplay;

	public ItemModifiableStatValue recoilDisplay;

	public ItemModifiableStatValue rofDisplay;

	public ItemModifiableStatValue accuracyDisplay;

	public ItemModifiableStatValue rangeDisplay;

	public ItemStatValue minigunMoveDisplay;

	public GameObject shieldCompatible;

	public GameObject bypassModTogglesButtonParent;

	public ItemIcon[] attachmentIcons;

	public void SetBypassModToggles(bool toggle)
	{
	}
}


using Rust;
using TMPro;
using UnityEngine;

public class ProtectionValue : MonoBehaviour, IClothingChanged
{
	public CanvasGroup group;

	public TextMeshProUGUI text;

	public DamageType damageType;

	public bool selectedItem;

	public bool displayBaseProtection;
}


using UnityEngine;

public class QuickCraft : SingletonComponent<QuickCraft>, IInventoryChanged
{
	public GameObjectRef craftButton;

	public GameObject empty;

	public Sprite FavouriteOnSprite;

	public Sprite FavouriteOffSprite;

	public Color FavouriteOnColor;

	public Color FavouriteOffColor;
}


using UnityEngine;
using UnityEngine.UI;

public class QuickCraftButton : MonoBehaviour
{
	public Image icon;

	public Image favourite;

	public Tooltip tooltip;

	public Text CraftCount;

	public Image FavouriteIcon;

	public const int QuickCraftMultipleCount = 5;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class RepairBenchPanel : LootPanel
{
	public RustText infoText;

	public GameObject repairButton;

	public GameObject skinLinkButton;

	public Color gotColor;

	public Color notGotColor;

	public Color skinColour;

	public Phrase phraseEmpty;

	public Phrase phraseNotRepairable;

	public Phrase phraseRepairNotNeeded;

	public Phrase phraseNoBlueprint;

	public GameObject skinsPanel;

	public GameObject changeSkinDialog;

	public IconSkinPicker picker;

	public GameObject costIconsParent;

	public List<VirtualItemIcon> costIcons;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ResearchTablePanel : LootPanel
{
	public Button researchButton;

	public RustText timerText;

	public GameObject itemDescNoItem;

	public GameObject itemDescTooBroken;

	public GameObject itemDescNotResearchable;

	public GameObject itemDescTooMany;

	public GameObject itemTakeBlueprint;

	public GameObject itemDescAlreadyResearched;

	public GameObject itemDescDefaultBlueprint;

	public RustText researchCostText;

	public ItemIcon scrapIcon;

	[NonSerialized]
	public bool wasResearching;

	public GameObject[] workbenchReqs;
}


using UnityEngine;
using UnityEngine.UI;

public class SeedInformationPanel : ItemInformationPanel
{
	public ItemTextValue maxHarvestsDisplay;

	public UIGenesDisplay GeneticsDisplay;

	public Text TextUnknownGenetics;

	public GameObject GeneticsGameObject;

	public ItemStatValue WaterResilience;

	public ItemStatValue GroundResilience;

	public ItemStatValue LightResilience;

	public ItemStatValue TemperatureResilience;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SelectedItem : SingletonComponent<SelectedItem>, IInventoryChanged
{
	public static readonly Phrase DropTitle = new Phrase("drop", "Drop");

	public static readonly Phrase DropDesc = new Phrase("drop_desc", "");

	public Image icon;

	public Image iconSplitter;

	public RustText title;

	public RustText description;

	public GameObject splitPanel;

	public GameObject itemProtection;

	public GameObject OwnershipContainer;

	public ItemOwnershipPanel OwnershipItem;

	private List<ItemOwnershipPanel> ownershipPanels = new List<ItemOwnershipPanel>();

	public GameObject menuOption;

	public GameObject optionsParent;

	public GameObject innerPanelContainer;
}


public class ShieldInformationPanel : ItemInformationPanel
{
	public ItemStatValue damageMitigationDisplay;
}


using UnityEngine;
using UnityEngine.UI;

public class SquareBorder : MonoBehaviour
{
	public float Size;

	public Color Color;

	public RectTransform Top;

	public RectTransform Bottom;

	public RectTransform Left;

	public RectTransform Right;

	public Image TopImage;

	public Image BottomImage;

	public Image LeftImage;

	public Image RightImage;

	private float _lastSize;

	private Color _lastColor;

	private void Update()
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (_lastSize != Size)
		{
			Top.offsetMin = new Vector2(0f, 0f - Size);
			Bottom.offsetMax = new Vector2(0f, Size);
			Left.offsetMin = new Vector2(0f, Size);
			Left.offsetMax = new Vector2(Size, 0f - Size);
			Right.offsetMin = new Vector2(0f - Size, Size);
			Right.offsetMax = new Vector2(0f, 0f - Size);
			_lastSize = Size;
		}
		if (_lastColor != Color)
		{
			((Graphic)TopImage).color = Color;
			((Graphic)BottomImage).color = Color;
			((Graphic)LeftImage).color = Color;
			((Graphic)RightImage).color = Color;
			_lastColor = Color;
		}
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class UIBelt : SingletonComponent<UIBelt>
{
	public List<ItemIcon> ItemIcons;

	protected override void Awake()
	{
		ItemIcons = (from s in ((Component)this).GetComponentsInChildren<ItemIcon>()
			orderby s.slot
			select s).ToList();
	}

	public ItemIcon GetItemIconAtSlot(int slot)
	{
		if (slot < 0 || slot >= ItemIcons.Count)
		{
			return null;
		}
		return ItemIcons[slot];
	}
}


public class UIContacts : SingletonComponent<UIContacts>
{
	public static bool isOpen;

	public static float LastOpened;

	public ContactsPanel contactsPanel;
}


using UnityEngine;

public class UICrafting : SingletonComponent<UICrafting>
{
	public GameObject skinViewerPrefab;

	public static bool isOpen;

	public static float LastOpened;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class UIIntegerEntry : MonoBehaviour
{
	public InputField textEntry;

	public event Action textChanged;

	public void OnAmountTextChanged()
	{
		this.textChanged();
	}

	public void SetAmount(int amount)
	{
		if (amount != GetIntAmount())
		{
			textEntry.text = amount.ToString();
		}
	}

	public int GetIntAmount()
	{
		int result = 0;
		int.TryParse(textEntry.text, out result);
		return result;
	}

	public void PlusMinus(int delta)
	{
		SetAmount(GetIntAmount() + delta);
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UIInventory : SingletonComponent<UIInventory>
{
	public TextMeshProUGUI PlayerName;

	public static bool isOpen;

	public static float LastOpened;

	public VerticalLayoutGroup rightContents;

	public GameObject QuickCraft;

	public Transform InventoryIconContainer;

	public ChangelogPanel ChangelogPanel;

	public ContactsPanel contactsPanel;

	public GameObject backpackSlot;

	public UnderwearSkinPicker underwearSkinPicker;
}


public interface IContainerSounds
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using VLB;

public class UIMixingTableItem : MonoBehaviour
{
	public Image ItemIcon;

	public Tooltip ItemTooltip;

	public RustText TextItemNameAndQuantity;

	public UIMixingTableItemIngredient[] Ingredients;

	public bool Available;

	public Recipe Recipe;

	public void Init(Recipe r, UnityAction<Recipe> onClicked)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected O, but got Unknown
		Recipe = r;
		if ((Object)(object)Recipe == (Object)null)
		{
			return;
		}
		((UnityEvent)((Component)this).gameObject.GetOrAddComponent<Button>().onClick).AddListener((UnityAction)delegate
		{
			onClicked.Invoke(Recipe);
		});
		ItemIcon.sprite = Recipe.DisplayIcon;
		TextItemNameAndQuantity.SetText($"{Recipe.ProducedItemCount} x {Recipe.DisplayName}", true, false);
		ItemTooltip.Text = Recipe.DisplayDescription;
		for (int i = 0; i < Ingredients.Length; i++)
		{
			if (i >= Recipe.Ingredients.Length)
			{
				Ingredients[i].InitBlank();
			}
			else
			{
				Ingredients[i].Init(Recipe.Ingredients[i], Recipe.ProducedItem);
			}
		}
	}

	public void CleanUp()
	{
		Button component = ((Component)this).gameObject.GetComponent<Button>();
		if ((Object)(object)component != (Object)null)
		{
			((UnityEventBase)component.onClick).RemoveAllListeners();
		}
	}

	public void SetAvailable(bool flag)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Available = flag;
		((Graphic)TextItemNameAndQuantity).color = (Color)(flag ? new Color(0.78f, 0.78f, 0.78f) : Color.grey);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIMixingTableItemIngredient : MonoBehaviour
{
	public Image ItemIcon;

	public Text ItemCount;

	public Tooltip ToolTip;

	public void Init(Recipe.RecipeIngredient ingredient, ItemDefinition producedItem)
	{
		ItemIcon.sprite = ingredient.Ingredient.iconSprite;
		int ingredientCount = ingredient.GetIngredientCount(producedItem);
		ItemCount.text = ingredientCount.ToString();
		((Behaviour)ItemIcon).enabled = true;
		((Behaviour)ItemCount).enabled = true;
		ToolTip.Text = $"{ingredientCount} x {ingredient.Ingredient.displayName.translated}";
		((Behaviour)ToolTip).enabled = true;
	}

	public void InitBlank()
	{
		((Behaviour)ItemIcon).enabled = false;
		((Behaviour)ItemCount).enabled = false;
		((Behaviour)ToolTip).enabled = false;
	}
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(ItemIcon))]
public class VehicleEditingItemIcon : MonoBehaviour, IInventoryChanged
{
	[SerializeField]
	private Image foregroundImage;

	[SerializeField]
	private Image linkImage;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class VehicleEditingPanel : LootPanel
{
	[Serializable]
	private class CreateChassisEntry
	{
		public byte garageChassisIndex;

		public Button craftButton;

		public Text craftButtonText;

		public Text requirementsText;

		public ItemDefinition GetChassisItemDef(ModularCarGarage garage)
		{
			return garage.chassisBuildOptions[garageChassisIndex].itemDef;
		}
	}

	[Range(0f, 1f)]
	[SerializeField]
	private float disabledAlpha = 0.25f;

	[Header("Edit Vehicle")]
	[SerializeField]
	private CanvasGroup editGroup;

	[SerializeField]
	private GameObject moduleInternalItemsGroup;

	[SerializeField]
	private GameObject moduleInternalLiquidsGroup;

	[SerializeField]
	private GameObject destroyChassisGroup;

	[SerializeField]
	private Button itemTakeButton;

	[SerializeField]
	private Button liquidTakeButton;

	[SerializeField]
	private GameObject liquidHelp;

	[SerializeField]
	private GameObject liquidButton;

	[SerializeField]
	private Color gotColor;

	[SerializeField]
	private Color notGotColor;

	[SerializeField]
	private Text generalInfoText;

	[SerializeField]
	private Text generalWarningText;

	[SerializeField]
	private Image generalWarningImage;

	[SerializeField]
	private Text repairInfoText;

	[SerializeField]
	private Button repairButton;

	[SerializeField]
	private Text destroyChassisButtonText;

	[SerializeField]
	private Text destroyChassisCountdown;

	[SerializeField]
	private Phrase phraseEditingInfo;

	[SerializeField]
	private Phrase phraseNoOccupant;

	[SerializeField]
	private Phrase phraseBadOccupant;

	[SerializeField]
	private Phrase phrasePlayerObstructing;

	[SerializeField]
	private Phrase phraseNotDriveable;

	[SerializeField]
	private Phrase phraseNotRepairable;

	[SerializeField]
	private Phrase phraseRepairNotNeeded;

	[SerializeField]
	private Phrase phraseRepairSelectInfo;

	[SerializeField]
	private Phrase phraseRepairEnactInfo;

	[SerializeField]
	private Phrase phraseHasLock;

	[SerializeField]
	private Phrase phraseHasNoLock;

	[SerializeField]
	private Phrase phraseAddLock;

	[SerializeField]
	private Phrase phraseAddLockButton;

	[SerializeField]
	private Phrase phraseChangeLockCodeButton;

	[SerializeField]
	private Text carLockInfoText;

	[SerializeField]
	private RustText carLockButtonText;

	[SerializeField]
	private Button actionLockButton;

	[SerializeField]
	private Button removeLockButton;

	[SerializeField]
	private GameObjectRef keyEnterDialog;

	[SerializeField]
	private Phrase phraseEmptyStorage;

	[Header("Create Chassis")]
	[SerializeField]
	private CreateChassisEntry[] chassisOptions;
}


using System;
using UnityEngine.UI;

[Serializable]
private class CreateChassisEntry
{
	public byte garageChassisIndex;

	public Button craftButton;

	public Text craftButtonText;

	public Text requirementsText;

	public ItemDefinition GetChassisItemDef(ModularCarGarage garage)
	{
		return garage.chassisBuildOptions[garageChassisIndex].itemDef;
	}
}


public class VehicleModuleInformationPanel : ItemInformationPanel
{
	public interface IVehicleModuleInfo
	{
		int SocketsTaken { get; }
	}

	public ItemStatValue socketsDisplay;

	public ItemStatValue hpDisplay;
}


public interface IVehicleModuleInfo
{
	int SocketsTaken { get; }
}


using UnityEngine;
using UnityEngine.UI;

public class VirtualItemIcon : MonoBehaviour
{
	public ItemDefinition itemDef;

	public int itemAmount;

	public bool asBlueprint;

	public Image iconImage;

	public Image bpUnderlay;

	public Text amountText;

	public Text hoverText;

	public CanvasGroup iconContents;

	public Tooltip ToolTip;

	public CanvasGroup conditionObject;

	public Image conditionFill;

	public Image maxConditionFill;

	public Image cornerIcon;

	[Header("Slots")]
	public GameObject slots;

	public Image[] slotImages;

	public static Phrase attachmentsPhrase = new Phrase("vendor_attachments", "Attachments");

	public static Phrase ammoPhrase = new Phrase("vendor_ammo", "Ammo");
}


using UnityEngine;

[RequireComponent(typeof(ItemIcon))]
public class WearableFeedbackItemIcon : FacepunchBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class WorkbenchPanel : LootPanel, IInventoryChanged
{
	public GameObject openTechTreeButton;

	public Text timerText;

	public Text costText;

	public GameObject expermentCostParent;

	public GameObject controlsParent;

	public GameObject allUnlockedNotification;

	public GameObject informationParent;

	public GameObject cycleIcon;

	public TechTreeDialog techTreeDialog;
}


using UnityEngine;

public class InventoryUI : MonoBehaviour
{
	public GameObject ContactsButton;

	public GameObject ClanButton;
}


using UnityEngine;
using UnityEngine.UI;

public class IOEntityUISlotEntry : MonoBehaviour
{
	public RawImage icon;

	public Text leftText;

	public Text rightText;
}


using System;
using System.Globalization;
using System.Linq;
using UnityEngine;

public static class ItemSearchUtils
{
	public static IOrderedEnumerable<ItemDefinition> SearchForItems(string searchString, Func<ItemDefinition, bool> validFilter = null)
	{
		if (searchString == "")
		{
			searchString = "BALLS BALLS BALLS";
		}
		return from y in ItemManager.itemList.Where((ItemDefinition x) => IsValidSearchResult(searchString, x, validFilter == null) && (validFilter == null || validFilter(x))).Take(60)
			orderby ScoreSearchResult(searchString, y)
			select y;
	}

	public static bool IsValidSearchResult(string search, ItemDefinition target, bool checkItemIsValid)
	{
		if (checkItemIsValid && (!((Object)(object)target.isRedirectOf != (Object)null) || target.redirectVendingBehaviour != ItemDefinition.RedirectVendingBehaviour.ListAsUniqueItem) && target.Hidden())
		{
			return false;
		}
		if (!StringEx.Contains(target.shortname, search, CompareOptions.IgnoreCase) && !StringEx.Contains(target.displayName.translated, search, CompareOptions.IgnoreCase) && !StringEx.Contains(target.displayDescription.translated, search, CompareOptions.IgnoreCase) && CultureInfo.CurrentCulture.CompareInfo.IndexOf(target.displayName.translated, search, CompareOptions.IgnoreCase | CompareOptions.IgnoreNonSpace) < 0)
		{
			return CultureInfo.CurrentCulture.CompareInfo.IndexOf(target.displayDescription.translated, search, CompareOptions.IgnoreCase | CompareOptions.IgnoreNonSpace) >= 0;
		}
		return true;
	}

	private static float ScoreSearchResult(string search, ItemDefinition target)
	{
		float num = 0f;
		if (target.shortname.Equals(search, StringComparison.CurrentCultureIgnoreCase) || target.displayName.translated.Equals(search, StringComparison.CurrentCultureIgnoreCase))
		{
			num -= (float)(500 - search.Length);
		}
		float num2 = (StringEx.Contains(target.shortname, search, CompareOptions.IgnoreCase) ? ((float)search.Length / (float)target.shortname.Length) : 0f);
		float num3 = (StringEx.Contains(target.displayName.translated, search, CompareOptions.IgnoreCase) ? ((float)search.Length / (float)target.displayName.translated.Length) : 0f);
		float num4 = Mathf.Max(num2, num3);
		num -= 50f * num4;
		if (StringEx.Contains(target.displayDescription.translated, search, CompareOptions.IgnoreCase))
		{
			num -= (float)search.Length;
		}
		return num;
	}
}


using System.Collections.Generic;
using System.Linq;
using Rust.UI.MainMenu;
using UnityEngine;

public class KeybindCategory : MonoBehaviour
{
	private List<UI_SettingsTweakKeyBind> keybinds = new List<UI_SettingsTweakKeyBind>();

	private void Awake()
	{
		for (int i = ((Component)this).transform.GetSiblingIndex() + 1; i < ((Component)this).transform.parent.childCount; i++)
		{
			Transform child = ((Component)this).transform.parent.GetChild(i);
			if (!((Object)(object)((Component)child).GetComponent<KeybindCategory>() != (Object)null))
			{
				UI_SettingsTweakKeyBind component = ((Component)child).GetComponent<UI_SettingsTweakKeyBind>();
				if (!((Object)(object)component == (Object)null))
				{
					keybinds.Add(component);
				}
				continue;
			}
			break;
		}
	}

	public void UpdateVisibility()
	{
		((Component)this).gameObject.SetActive(keybinds.Any((UI_SettingsTweakKeyBind x) => ((Behaviour)x).isActiveAndEnabled));
	}
}


using TMPro;
using UnityEngine;

public class KeybindSearch : MonoBehaviour
{
	public GameObject rootPanel;

	public TMP_InputField input;
}


using System;
using System.Collections.Generic;
using System.Linq;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.UI;

public class LifeInfographic : SingletonComponent<LifeInfographic>, IPrefabPreProcess
{
	[Serializable]
	public struct DamageSetting
	{
		public DamageType ForType;

		public string Display;

		public Sprite DamageSprite;
	}

	[Serializable]
	public struct EntityNameToItemDefinition
	{
		public string Name;

		public ItemDefinition ItemDefinition;
	}

	[NonSerialized]
	public PlayerLifeStory life;

	public GameObject container;

	public RawImage AttackerAvatarImage;

	public Image DamageSourceImage;

	public LifeInfographicStat[] Stats;

	public Animator[] AllAnimators;

	public GameObject WeaponRoot;

	public GameObject DistanceRoot;

	public GameObject DistanceDivider;

	public Image WeaponImage;

	public DamageSetting[] DamageDisplays;

	public Texture2D defaultAvatarTexture;

	public bool ShowDebugData;

	[Tooltip("Automatically filled in by prefab preprocess")]
	[ReadOnly]
	public EntityNameToItemDefinition[] EntityNameToItemDefinitions;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (bundling || !FileSystem.IsBundled)
		{
			EntityNameToItemDefinitions = BuildEntityNameToItemDefinitionTable();
		}
	}

	private static EntityNameToItemDefinition[] BuildEntityNameToItemDefinitionTable()
	{
		List<ItemDefinition> list = GetItemList();
		Dictionary<string, ItemDefinition> dictionary = new Dictionary<string, ItemDefinition>(StringComparer.OrdinalIgnoreCase);
		ItemModEntity itemModEntity = default(ItemModEntity);
		ThrownWeapon thrownWeapon = default(ThrownWeapon);
		ItemModDeployable itemModDeployable = default(ItemModDeployable);
		foreach (ItemDefinition item in list)
		{
			dictionary.TryAdd(item.shortname, item);
			try
			{
				if (((Component)item).TryGetComponent<ItemModEntity>(ref itemModEntity) && itemModEntity.entityPrefab.isValid)
				{
					GameObject val = itemModEntity.entityPrefab.Get();
					dictionary.TryAdd(((Object)val).name, item);
					if (val.TryGetComponent<ThrownWeapon>(ref thrownWeapon) && thrownWeapon.prefabToThrow.isValid)
					{
						dictionary.TryAdd(((Object)thrownWeapon.prefabToThrow.Get()).name, item);
					}
				}
				if (((Component)item).TryGetComponent<ItemModDeployable>(ref itemModDeployable) && itemModDeployable.entityPrefab != null && itemModDeployable.entityPrefab.isValid)
				{
					dictionary.TryAdd(((Object)itemModDeployable.entityPrefab.Get()).name, item);
				}
				ItemModProjectile[] components = ((Component)item).GetComponents<ItemModProjectile>();
				foreach (ItemModProjectile itemModProjectile in components)
				{
					if (itemModProjectile.projectileObject != null && itemModProjectile.projectileObject.isValid)
					{
						dictionary.TryAdd(((Object)itemModProjectile.projectileObject.Get()).name, item);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Invalid entity found in LifeInfographic.PreProcess - likely a corrupt prefab: " + item.shortname));
				Debug.LogError((object)ex);
			}
		}
		return dictionary.Select(delegate(KeyValuePair<string, ItemDefinition> kvp)
		{
			EntityNameToItemDefinition result = default(EntityNameToItemDefinition);
			result.Name = kvp.Key;
			result.ItemDefinition = kvp.Value;
			return result;
		}).OrderBy<EntityNameToItemDefinition, string>((EntityNameToItemDefinition x) => x.Name, StringComparer.OrdinalIgnoreCase).ToArray();
		static List<ItemDefinition> GetItemList()
		{
			return ItemManager.itemList;
		}
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public struct DamageSetting
{
	public DamageType ForType;

	public string Display;

	public Sprite DamageSprite;
}


using System;

[Serializable]
public struct EntityNameToItemDefinition
{
	public string Name;

	public ItemDefinition ItemDefinition;
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class LifeInfographicStat : MonoBehaviour
{
	public enum DataType
	{
		None,
		AliveTime_Short,
		SleepingTime_Short,
		KillerName,
		KillerWeapon,
		AliveTime_Long,
		KillerDistance,
		GenericStat,
		DistanceTravelledWalk,
		DistanceTravelledRun,
		DamageTaken,
		DamageHealed,
		WeaponInfo,
		SecondsWilderness,
		SecondsSwimming,
		SecondsInBase,
		SecondsInMonument,
		SecondsFlying,
		SecondsBoating,
		PlayersKilled,
		ScientistsKilled,
		AnimalsKilled,
		SecondsDriving
	}

	public enum WeaponInfoType
	{
		TotalShots,
		ShotsHit,
		ShotsMissed,
		AccuracyPercentage
	}

	public DataType dataSource;

	[Header("Generic Stats")]
	public string genericStatKey;

	[Header("Weapon Info")]
	public string targetWeaponName;

	public WeaponInfoType weaponInfoType;

	public TextMeshProUGUI targetText;

	public Image StatImage;
}


public enum DataType
{
	None,
	AliveTime_Short,
	SleepingTime_Short,
	KillerName,
	KillerWeapon,
	AliveTime_Long,
	KillerDistance,
	GenericStat,
	DistanceTravelledWalk,
	DistanceTravelledRun,
	DamageTaken,
	DamageHealed,
	WeaponInfo,
	SecondsWilderness,
	SecondsSwimming,
	SecondsInBase,
	SecondsInMonument,
	SecondsFlying,
	SecondsBoating,
	PlayersKilled,
	ScientistsKilled,
	AnimalsKilled,
	SecondsDriving
}


public enum WeaponInfoType
{
	TotalShots,
	ShotsHit,
	ShotsMissed,
	AccuracyPercentage
}


using System;
using Rust.UI;

public class LifeInfographicStatDynamicRow : LifeInfographicStat
{
	public RustText StatName;

	public void SetStatName(Phrase phrase)
	{
		StatName.SetPhrase(phrase, Array.Empty<object>());
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LifeInfographicStatWeapon : MonoBehaviour
{
	public RustText WeaponName;

	public RustText ShotsFired;

	public RustText ShotsHit;

	public RustText ShotsPercent;

	public Image WeaponIcon;
}


using UnityEngine;

public class LookAtFarmableAnimal : MonoBehaviour
{
	public CanvasGroup Group;

	public ChickenCoopStatusWidget Status;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LookatHealth : MonoBehaviour
{
	public interface IHealthBarName
	{
	}

	public static bool Enabled = true;

	public GameObject container;

	public RustText textHealth;

	public RustText textStability;

	public Image healthBar;

	public Image healthBarBG;

	public Color barBGColorNormal;

	public Color barBGColorUnstable;
}


public interface IHealthBarName
{
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LookAtIOEnt : MonoBehaviour
{
	[Serializable]
	public struct HandleSet
	{
		public IOEntity.IOType ForIO;

		public GameObjectRef handlePrefab;

		public GameObjectRef handleOccupiedPrefab;

		public GameObjectRef selectedHandlePrefab;

		public GameObjectRef pluggedHandlePrefab;
	}

	public RustText objectTitle;

	public RectTransform slotToolTip;

	public Text slotTitle;

	public RustText slotConnectionText;

	public RustText slotPowerText;

	public RustText powerText;

	public RustText passthroughText;

	public RustText chargeLeftText;

	public RustText capacityText;

	public RustText maxOutputText;

	public RustText activeOutputText;

	public RustText turretInterferenceText;

	public RustText creativeModeText;

	public IOEntityUISlotEntry[] inputEntries;

	public IOEntityUISlotEntry[] outputEntries;

	public Color NoPowerColor;

	public GameObject ShortCircuitWarning;

	public GameObject GravityWarning;

	public GameObject DistanceWarning;

	public GameObject LineOfSightWarning;

	public GameObject TooManyInputsWarning;

	public GameObject TooManyOutputsWarning;

	public GameObject BuildPrivilegeWarning;

	public GameObject InfinitePowerText;

	public CanvasGroup group;

	public HandleSet[] handleSets;

	public RectTransform clearNotification;

	public CanvasGroup wireInfoGroup;

	public RustText wireLengthText;

	public RustText wireClipsText;

	public RustText errorReasonTextTooFar;

	public RustText errorReasonTextNoSurface;

	public RawImage ConnectionTypeIcon;

	public Texture ElectricSprite;

	public Texture FluidSprite;

	public Texture IndustrialSprite;

	public GameObject IndustrialIcon;
}


using System;

[Serializable]
public struct HandleSet
{
	public IOEntity.IOType ForIO;

	public GameObjectRef handlePrefab;

	public GameObjectRef handleOccupiedPrefab;

	public GameObjectRef selectedHandlePrefab;

	public GameObjectRef pluggedHandlePrefab;
}


using UnityEngine;
using UnityEngine.UI;

public class LookAtPlant : MonoBehaviour
{
	public CanvasGroup group;

	public UIGenesDisplay GeneDisplay;

	public UIGenesDisplay GeneDisplay2;

	public Text TextPlant;

	public Image PlantIcon;

	public InfoBar Age;

	public InfoBar Stage;

	public InfoBar WaterIntake;

	public Text TextYieldLabel;

	public InfoBar Yield;

	public InfoBar Health;

	public InfoBar Light;

	public InfoBar WaterSaturation;

	public InfoBar Ground;

	public InfoBar Temperature;

	public InfoBar Overall;
}


using UnityEngine;
using UnityEngine.UI;

public class LookAtPlanter : MonoBehaviour
{
	public CanvasGroup group;

	public Text waterText;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LookatTooltip : MonoBehaviour
{
	public static bool Enabled = true;

	[NonSerialized]
	public BaseEntity currentlyLookingAt;

	public RustText textLabel;

	public RustText moreOptionsLabel;

	public Image icon;

	public Phrase moreOptionsDefaultPhrase;

	public CanvasGroup canvasGroup;

	public CanvasGroup infoGroup;

	public CanvasGroup minimiseGroup;

	[ClientVar(Saved = true, Help = "Changes the interaction crosshair visuals (0 = default, 1 = no texts, 2 = no texts and no icon)")]
	public static int crosshairMode = 0;
}


using UnityEngine;
using UnityEngine.UI;

public class LookAtWeaponRack : MonoBehaviour
{
	public CanvasGroup weaponInfoGroup;

	public CanvasGroup rotationGroup;

	public Text TextWeapon;

	public Image IconWeapon;

	public Image IconAmmo;

	public RawImage IconHorizontal;

	public RawImage IconVertical;

	public InfoBar AmmoBar;

	public InfoBar ConditionBar;

	public Color ValidRotationColor;

	public Color InvalidRotationColor;
}


using UnityEngine;
using UnityEngine.UI;

public class AboutYou : BaseMonoBehaviour
{
	public Text username;

	public RawImage avatar;

	public Text subtitle;

	public GameObject PremiumIcon;
}


using Rust.UI;
using UnityEngine;

public class ConnectionScreen : SingletonComponent<ConnectionScreen>
{
	public RustText statusText;

	public GameObject disconnectButton;

	public GameObject retryButton;

	public ServerBrowserInfo browserInfo;
}


using Rust.UI;
using UnityEngine;

public class UI_DemoItem : RustButton
{
	[HideInInspector]
	public UI_DemosMenuWindow demos;

	public int itemId;

	public RustText nameText;

	public RustText dateText;

	public RustText lengthText;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_DemosMenuWindow : UI_Window
{
	[SerializeField]
	private FlexVirtualScroll virtualScroll;

	[SerializeField]
	private GameObject deleteButton;

	[SerializeField]
	private GameObject playButton;
}


using UnityEngine;

public class DeveloperUI : MonoBehaviour
{
}


using UnityEngine;

public class DisableWithMainMenu : MonoBehaviour
{
}


using UnityEngine;

public class LanguageSelection : MonoBehaviour
{
	public GameObject buttonContainer;
}


