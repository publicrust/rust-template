using System;
using GenerateErosionJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;

public class GenerateErosion : ProceduralComponent
{
	public struct SplatPaintingData : IDisposable
	{
		public bool IsValid;

		public readonly NativeArray<float> HeightMapDelta;

		public readonly NativeArray<float> AngleMap;

		public SplatPaintingData(NativeArray<float> heightMapDelta, NativeArray<float> angleMap)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			HeightMapDelta = heightMapDelta;
			AngleMap = angleMap;
			IsValid = true;
		}

		public void Dispose()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			IsValid = false;
			if (HeightMapDelta.IsCreated)
			{
				HeightMapDelta.Dispose();
			}
			if (AngleMap.IsCreated)
			{
				AngleMap.Dispose();
			}
		}

		public void Dispose(JobHandle inputDeps)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			IsValid = false;
			if (HeightMapDelta.IsCreated)
			{
				HeightMapDelta.Dispose(inputDeps);
			}
			if (AngleMap.IsCreated)
			{
				AngleMap.Dispose(inputDeps);
			}
		}
	}

	public static SplatPaintingData splatPaintingData;

	public override void Process(uint seed)
	{
		if (!World.Networked)
		{
			GridErosion(seed);
		}
	}

	private static int GetBatchSize(int length)
	{
		int num = length / JobsUtility.JobWorkerCount;
		if (num < 64)
		{
			return 64;
		}
		return num;
	}

	private void GridErosion(uint seed)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0461: Unknown result type (might be due to invalid IL or missing references)
		//IL_0463: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0574: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_057d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0601: Unknown result type (might be due to invalid IL or missing references)
		//IL_0608: Unknown result type (might be due to invalid IL or missing references)
		//IL_060a: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0628: Unknown result type (might be due to invalid IL or missing references)
		//IL_062d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0636: Unknown result type (might be due to invalid IL or missing references)
		//IL_063b: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_067d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0682: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_0693: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0706: Unknown result type (might be due to invalid IL or missing references)
		//IL_0717: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0741: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0764: Unknown result type (might be due to invalid IL or missing references)
		//IL_0769: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0780: Unknown result type (might be due to invalid IL or missing references)
		//IL_079e: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07db: Unknown result type (might be due to invalid IL or missing references)
		//IL_07dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0803: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_081a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GridErosion", 0);
		try
		{
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			heightMap.Push();
			NativeArray<short> src = heightMap.src;
			NativeArray<short> dst = heightMap.dst;
			NativeArray<float> minTerrainHeightMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)0);
			NativeArray<float> waterMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeList<int> val2 = new NativeList<int>(heightMap.src.Length, AllocatorHandle.op_Implicit((Allocator)4));
			NativeArray<float4> fluxMap = new NativeArray<float4>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float2> velocityMap = new NativeArray<float2>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> val3 = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> copyTarget = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> angleMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)0);
			Debug.Assert(waterMap.Length == heightMap.src.Length);
			Debug.Assert(fluxMap.Length == heightMap.src.Length);
			Debug.Assert(velocityMap.Length == heightMap.src.Length);
			Debug.Assert(val3.Length == heightMap.src.Length);
			float num = TerrainMeta.Size.x / (float)heightMap.res * TerrainMeta.Size.z / (float)heightMap.res;
			float invGridCellSquareSize = 1f / num;
			float pipeLength = 1f;
			float pipeArea = 1f;
			JobHandle val4 = default(JobHandle);
			NativeArray<float> val5 = new NativeArray<float>(src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> val6 = new NativeArray<float>(val5, (Allocator)4);
			PrepareMapJob prepareMapJob = default(PrepareMapJob);
			prepareMapJob.HeightMapAsShort = src.AsReadOnly();
			prepareMapJob.HeightMapAsFloat = val5;
			prepareMapJob.OceanIndicesWriter = val2.AsParallelWriter();
			prepareMapJob.OceanLevel = WaterSystem.OceanLevel;
			prepareMapJob.TerrainPositionY = TerrainMeta.Position.y;
			prepareMapJob.TerrainSizeY = TerrainMeta.Size.y;
			val4 = IJobParallelForBatchExtensions.Schedule<PrepareMapJob>(prepareMapJob, src.Length, GetBatchSize(src.Length), val4);
			CalcMinHeightMapJob calcMinHeightMapJob = default(CalcMinHeightMapJob);
			calcMinHeightMapJob.TerrainHeightMap = val5.AsReadOnly();
			calcMinHeightMapJob.MinTerrainHeightMap = minTerrainHeightMap;
			calcMinHeightMapJob.HeightMapRes = TerrainMeta.HeightMap.res;
			calcMinHeightMapJob.TopologyMap = TerrainMeta.TopologyMap.src.AsReadOnly();
			calcMinHeightMapJob.TopologyMapRes = TerrainMeta.TopologyMap.res;
			calcMinHeightMapJob.OceanHeight = WaterSystem.OceanLevel;
			calcMinHeightMapJob.TerrainOneOverSizeX = TerrainMeta.OneOverSize.x;
			val4 = IJobParallelForExtensions.Schedule<CalcMinHeightMapJob>(calcMinHeightMapJob, val5.Length, GetBatchSize(val5.Length), val4);
			((JobHandle)(ref val4)).Complete();
			val4 = default(JobHandle);
			NativeArray<float> copyTarget2 = new NativeArray<float>(src.Length, (Allocator)4, (NativeArrayOptions)1);
			CopyArrayJob<float> copyArrayJob = default(CopyArrayJob<float>);
			copyArrayJob.CopyTarget = copyTarget2;
			copyArrayJob.CopySource = val5;
			CopyArrayJob<float> copyArrayJob2 = copyArrayJob;
			CopyArrayJob<float> copyArrayJob3 = new CopyArrayJob<float>
			{
				CopyTarget = val6,
				CopySource = val5
			};
			val4 = JobHandle.CombineDependencies(IJobExtensions.Schedule<CopyArrayJob<float>>(copyArrayJob2, val4), IJobExtensions.Schedule<CopyArrayJob<float>>(copyArrayJob3, val4));
			int num2 = 32;
			int num3 = 32;
			int num4 = (heightMap.res + num2 - 1) / num2;
			int num5 = (heightMap.res + num3 - 1) / num3;
			int num6 = num4 * num5;
			for (int i = 0; i < 512; i++)
			{
				RefillOceanJob refillOceanJob = default(RefillOceanJob);
				refillOceanJob.OceanIndices = val2.AsReadOnly();
				refillOceanJob.HeightMap = val5.AsReadOnly();
				refillOceanJob.OceanLevel = WaterSystem.OceanLevel;
				refillOceanJob.WaterMap = waterMap;
				RefillOceanJob refillOceanJob2 = refillOceanJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<RefillOceanJob>(ref refillOceanJob2, val2.Length, GetBatchSize(val2.Length), val4);
				WaterIncrementationJob waterIncrementationJob = default(WaterIncrementationJob);
				waterIncrementationJob.WaterMap = waterMap;
				waterIncrementationJob.WaterFillRate = 0.04f;
				waterIncrementationJob.DT = 0.06f;
				WaterIncrementationJob waterIncrementationJob2 = waterIncrementationJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<WaterIncrementationJob>(ref waterIncrementationJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
				CalculateOutputFluxJob calculateOutputFluxJob = default(CalculateOutputFluxJob);
				calculateOutputFluxJob.TerrainHeightMapFloatVal = val5.AsReadOnly();
				calculateOutputFluxJob.WaterMap = waterMap.AsReadOnly();
				calculateOutputFluxJob.FluxMap = fluxMap;
				calculateOutputFluxJob.Res = heightMap.res;
				calculateOutputFluxJob.DT = 0.06f;
				calculateOutputFluxJob.GridCellSquareSize = num;
				calculateOutputFluxJob.PipeLength = pipeLength;
				calculateOutputFluxJob.PipeArea = pipeArea;
				CalculateOutputFluxJob calculateOutputFluxJob2 = calculateOutputFluxJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<CalculateOutputFluxJob>(ref calculateOutputFluxJob2, fluxMap.Length, GetBatchSize(fluxMap.Length), val4);
				AdjustWaterHeightByFluxJob adjustWaterHeightByFluxJob = default(AdjustWaterHeightByFluxJob);
				adjustWaterHeightByFluxJob.WaterMap = waterMap;
				adjustWaterHeightByFluxJob.VelocityMap = velocityMap;
				adjustWaterHeightByFluxJob.FluxMap = fluxMap.AsReadOnly();
				adjustWaterHeightByFluxJob.Res = heightMap.res;
				adjustWaterHeightByFluxJob.DT = 0.06f;
				adjustWaterHeightByFluxJob.InvGridCellSquareSize = invGridCellSquareSize;
				AdjustWaterHeightByFluxJob adjustWaterHeightByFluxJob2 = adjustWaterHeightByFluxJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<AdjustWaterHeightByFluxJob>(ref adjustWaterHeightByFluxJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
				TileCalculateAngleMap tileCalculateAngleMap = default(TileCalculateAngleMap);
				tileCalculateAngleMap.AngleMap = angleMap;
				tileCalculateAngleMap.TerrainHeightMapSrcFloat = val5.AsReadOnly();
				tileCalculateAngleMap.NormY = heightMap.normY;
				tileCalculateAngleMap.Res = heightMap.res;
				tileCalculateAngleMap.TileSizeX = num2;
				tileCalculateAngleMap.TileSizeZ = num3;
				tileCalculateAngleMap.NumXTiles = num4;
				TileCalculateAngleMap tileCalculateAngleMap2 = tileCalculateAngleMap;
				val4 = IJobParallelForExtensions.ScheduleByRef<TileCalculateAngleMap>(ref tileCalculateAngleMap2, num6, num6 / JobsUtility.JobWorkerCount, val4);
				ErosionAndDepositionJob erosionAndDepositionJob = default(ErosionAndDepositionJob);
				erosionAndDepositionJob.SedimentMap = val3;
				erosionAndDepositionJob.MinTerrainHeightMap = minTerrainHeightMap.AsReadOnly();
				erosionAndDepositionJob.TerrainHeightMapSrcFloat = val5.AsReadOnly();
				erosionAndDepositionJob.TerrainHeightMapDstFloat = val6;
				erosionAndDepositionJob.WaterMap = waterMap;
				erosionAndDepositionJob.VelocityMap = velocityMap.AsReadOnly();
				erosionAndDepositionJob.AngleMap = angleMap.AsReadOnly();
				erosionAndDepositionJob.DT = 0.06f;
				ErosionAndDepositionJob erosionAndDepositionJob2 = erosionAndDepositionJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<ErosionAndDepositionJob>(ref erosionAndDepositionJob2, val3.Length, GetBatchSize(val3.Length), val4);
				copyArrayJob = default(CopyArrayJob<float>);
				copyArrayJob.CopyTarget = copyTarget;
				copyArrayJob.CopySource = val3;
				CopyArrayJob<float> copyArrayJob4 = copyArrayJob;
				val4 = IJobExtensions.ScheduleByRef<CopyArrayJob<float>>(ref copyArrayJob4, val4);
				copyArrayJob = default(CopyArrayJob<float>);
				copyArrayJob.CopyTarget = val5;
				copyArrayJob.CopySource = val6;
				CopyArrayJob<float> copyArrayJob5 = copyArrayJob;
				TransportSedimentJob transportSedimentJob = default(TransportSedimentJob);
				transportSedimentJob.SedimentMap = val3;
				transportSedimentJob.SedimentReadOnlyMap = copyTarget.AsReadOnly();
				transportSedimentJob.VelocityMap = velocityMap.AsReadOnly();
				transportSedimentJob.Res = heightMap.res;
				transportSedimentJob.DT = 0.06f;
				TransportSedimentJob transportSedimentJob2 = transportSedimentJob;
				val4 = JobHandle.CombineDependencies(IJobExtensions.ScheduleByRef<CopyArrayJob<float>>(ref copyArrayJob5, val4), IJobParallelForExtensions.ScheduleByRef<TransportSedimentJob>(ref transportSedimentJob2, val3.Length, GetBatchSize(val3.Length), val4));
				EvaporationJob evaporationJob = default(EvaporationJob);
				evaporationJob.WaterMap = waterMap;
				evaporationJob.DT = 0.06f;
				evaporationJob.EvaporationRate = 0.015f;
				EvaporationJob evaporationJob2 = evaporationJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<EvaporationJob>(ref evaporationJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
			}
			CopyBackFloatHeightToShortHeightJob copyBackFloatHeightToShortHeightJob = default(CopyBackFloatHeightToShortHeightJob);
			copyBackFloatHeightToShortHeightJob.HeightMapAsFloat = val5.AsReadOnly();
			copyBackFloatHeightToShortHeightJob.HeightMapAsShort = dst;
			copyBackFloatHeightToShortHeightJob.TerrainOneOverSizeY = TerrainMeta.OneOverSize.y;
			copyBackFloatHeightToShortHeightJob.TerrainPositionY = TerrainMeta.Position.y;
			CopyBackFloatHeightToShortHeightJob copyBackFloatHeightToShortHeightJob2 = copyBackFloatHeightToShortHeightJob;
			val4 = IJobParallelForExtensions.ScheduleByRef<CopyBackFloatHeightToShortHeightJob>(ref copyBackFloatHeightToShortHeightJob2, val5.Length, GetBatchSize(val5.Length), val4);
			NativeArray<float> val7 = new NativeArray<float>(val5.Length, (Allocator)4, (NativeArrayOptions)1);
			PopulateDeltaHeightJob populateDeltaHeightJob = default(PopulateDeltaHeightJob);
			populateDeltaHeightJob.HeightMapOriginal = copyTarget2.AsReadOnly();
			populateDeltaHeightJob.HeightMap = val5.AsReadOnly();
			populateDeltaHeightJob.DeltaHeightMap = val7;
			PopulateDeltaHeightJob populateDeltaHeightJob2 = populateDeltaHeightJob;
			val4 = IJobParallelForExtensions.ScheduleByRef<PopulateDeltaHeightJob>(ref populateDeltaHeightJob2, val7.Length, GetBatchSize(val7.Length), val4);
			minTerrainHeightMap.Dispose(val4);
			waterMap.Dispose(val4);
			fluxMap.Dispose(val4);
			velocityMap.Dispose(val4);
			val3.Dispose(val4);
			copyTarget.Dispose(val4);
			val5.Dispose(val4);
			val6.Dispose(val4);
			val2.Dispose(val4);
			copyTarget2.Dispose(val4);
			((JobHandle)(ref val4)).Complete();
			heightMap.Pop();
			splatPaintingData = new SplatPaintingData(val7, angleMap);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void OnDestroy()
	{
		if (splatPaintingData.IsValid)
		{
			splatPaintingData.Dispose();
		}
	}

	private void OldErosion(uint seed)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		int erosion_res = heightmap.res;
		float[] erosion = new float[erosion_res * erosion_res];
		int deposit_res = splatmap.res;
		float[] deposit = new float[deposit_res * deposit_res];
		Vector3 val = default(Vector3);
		for (float num = TerrainMeta.Position.z; num < TerrainMeta.Position.z + TerrainMeta.Size.z; num += 10f)
		{
			for (float num2 = TerrainMeta.Position.x; num2 < TerrainMeta.Position.x + TerrainMeta.Size.x; num2 += 10f)
			{
				((Vector3)(ref val))..ctor(num2, 0f, num);
				float num3 = (val.y = heightmap.GetHeight(val));
				if (val.y <= 15f)
				{
					continue;
				}
				Vector3 normal = heightmap.GetNormal(val);
				if (normal.y <= 0.01f || normal.y >= 0.99f)
				{
					continue;
				}
				Vector2 val2 = Vector3Ex.XZ2D(normal);
				Vector2 normalized = ((Vector2)(ref val2)).normalized;
				Vector2 val3 = normalized;
				float num4 = 0f;
				float num5 = 0f;
				for (int i = 0; i < 300; i++)
				{
					val.x += normalized.x;
					val.z += normalized.y;
					if (Vector3.Angle(Vector2.op_Implicit(normalized), Vector2.op_Implicit(val3)) > 90f)
					{
						break;
					}
					float num6 = TerrainMeta.NormalizeX(val.x);
					float num7 = TerrainMeta.NormalizeZ(val.z);
					int topology = topologyMap.GetTopology(num6, num7);
					if ((topology & 0xB4990) != 0)
					{
						break;
					}
					float height = heightmap.GetHeight(num6, num7);
					if (height > num3 + 8f)
					{
						break;
					}
					float num8 = Mathf.Min(height, num3);
					val.y = Mathf.Lerp(val.y, num8, 0.5f);
					normal = heightmap.GetNormal(val);
					Vector2 val4 = normalized;
					val2 = Vector3Ex.XZ2D(normal);
					val2 = Vector2.Lerp(val4, ((Vector2)(ref val2)).normalized, 0.5f);
					normalized = ((Vector2)(ref val2)).normalized;
					num3 = num8;
					float num9 = 0f;
					float num10 = 0f;
					if ((topology & 0x800400) == 0)
					{
						float num11 = Vector3.Angle(Vector3.up, normal);
						num9 = Mathf.InverseLerp(5f, 15f, num11);
						num10 = 1f;
						if ((topology & 0x8000) == 0)
						{
							num10 = num9;
						}
					}
					num4 = Mathf.MoveTowards(num4, num9, 0.05f);
					num5 = Mathf.MoveTowards(num5, num10, 0.05f);
					if ((topologyMap.GetTopology(num6, num7, 10f) & 2) == 0)
					{
						int num12 = Mathf.Clamp((int)(num6 * (float)erosion_res), 0, erosion_res - 1);
						int num13 = Mathf.Clamp((int)(num7 * (float)erosion_res), 0, erosion_res - 1);
						int num14 = Mathf.Clamp((int)(num6 * (float)deposit_res), 0, deposit_res - 1);
						int num15 = Mathf.Clamp((int)(num7 * (float)deposit_res), 0, deposit_res - 1);
						erosion[num13 * erosion_res + num12] += num4;
						deposit[num15 * deposit_res + num14] += num5;
					}
				}
			}
		}
		Parallel.For(1, erosion_res - 1, (Action<int>)delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			for (int j = 1; j < erosion_res - 1; j++)
			{
				float num16 = CalculateDelta(erosion, erosion_res, j, z, 1f, 0.8f, 0.6f);
				float delta = (0f - Mathf.Lerp(0f, 0.25f, num16)) * TerrainMeta.OneOverSize.y;
				heightmap.AddHeight(j, z, delta);
			}
		});
		Parallel.For(1, deposit_res - 1, (Action<int>)delegate(int z)
		{
			for (int k = 1; k < deposit_res - 1; k++)
			{
				float splat = splatmap.GetSplat(k, z, 2);
				float splat2 = splatmap.GetSplat(k, z, 4);
				if (splat > 0.1f || splat2 > 0.1f)
				{
					float num17 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.4f, 0.2f);
					num17 = Mathf.InverseLerp(1f, 3f, num17);
					num17 = Mathf.Lerp(0f, 0.5f, num17);
					splatmap.AddSplat(k, z, 128, num17);
				}
				else
				{
					float num18 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.2f, 0.1f);
					float num19 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.8f, 0.4f);
					num18 = Mathf.InverseLerp(1f, 3f, num18);
					num19 = Mathf.InverseLerp(1f, 3f, num19);
					num18 = Mathf.Lerp(0f, 1f, num18);
					num19 = Mathf.Lerp(0f, 1f, num19);
					splatmap.AddSplat(k, z, 1, num19 * 0.5f);
					splatmap.AddSplat(k, z, 64, num18 * 0.7f);
					splatmap.AddSplat(k, z, 128, num18 * 0.5f);
				}
			}
		});
		static float CalculateDelta(float[] data, int res, int x, int z, float cntr, float side, float diag)
		{
			int num20 = x - 1;
			int num21 = x + 1;
			int num22 = z - 1;
			int num23 = z + 1;
			side /= 4f;
			diag /= 4f;
			float num24 = data[z * res + x];
			float num25 = data[z * res + num20] + data[z * res + num21] + data[num23 * res + x] + data[num23 * res + x];
			float num26 = data[num22 * res + num20] + data[num22 * res + num21] + data[num23 * res + num20] + data[num23 * res + num21];
			return cntr * num24 + side * num25 + diag * num26;
		}
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;

public struct SplatPaintingData : IDisposable
{
	public bool IsValid;

	public readonly NativeArray<float> HeightMapDelta;

	public readonly NativeArray<float> AngleMap;

	public SplatPaintingData(NativeArray<float> heightMapDelta, NativeArray<float> angleMap)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		HeightMapDelta = heightMapDelta;
		AngleMap = angleMap;
		IsValid = true;
	}

	public void Dispose()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		IsValid = false;
		if (HeightMapDelta.IsCreated)
		{
			HeightMapDelta.Dispose();
		}
		if (AngleMap.IsCreated)
		{
			AngleMap.Dispose();
		}
	}

	public void Dispose(JobHandle inputDeps)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		IsValid = false;
		if (HeightMapDelta.IsCreated)
		{
			HeightMapDelta.Dispose(inputDeps);
		}
		if (AngleMap.IsCreated)
		{
			AngleMap.Dispose(inputDeps);
		}
	}
}


using System;
using System.Collections.Generic;
using GenerateErosionJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class GenerateErosionSplat : ProceduralComponent
{
	public override void Process(uint seed)
	{
		if (!World.Networked)
		{
			Debug.Assert(GenerateErosion.splatPaintingData.IsValid, "GenerateErosion.splatPaintingData is not populated, GenerateErosion likely missing from WorldSetup");
			if (GenerateErosion.splatPaintingData.IsValid)
			{
				PaintSplat();
			}
		}
	}

	private void PaintSplat()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(GenerateErosion.splatPaintingData.HeightMapDelta.IsCreated);
		Debug.Assert(GenerateErosion.splatPaintingData.AngleMap.IsCreated);
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		NativeArray<float> heightMapDelta = GenerateErosion.splatPaintingData.HeightMapDelta;
		NativeArray<float> angleMap = GenerateErosion.splatPaintingData.AngleMap;
		int res = TerrainMeta.HeightMap.res;
		Parallel.For(1, res - 1, (Action<int>)delegate(int z)
		{
			for (int i = 1; i < res - 1; i++)
			{
				angleMap[z * res + i] = TerrainMeta.HeightMap.GetSlope(i, z);
			}
		});
		splatMap.Push();
		NativeHashMap<int, int> val = default(NativeHashMap<int, int>);
		val..ctor(splatMap.num, AllocatorHandle.op_Implicit((Allocator)3));
		foreach (var (num3, num4) in TerrainSplat.GetType2IndexDic())
		{
			val.Add(num3, num4);
		}
		JobHandle val2 = default(JobHandle);
		PaintSplatJob paintSplatJob = default(PaintSplatJob);
		paintSplatJob.HeightMapDelta = heightMapDelta.AsReadOnly();
		paintSplatJob.HeightMapRes = TerrainMeta.HeightMap.res;
		paintSplatJob.AngleMapDeg = angleMap.AsReadOnly();
		paintSplatJob.TopologyMap = TerrainMeta.TopologyMap.src.AsReadOnly();
		paintSplatJob.TopologyMapRes = TerrainMeta.TopologyMap.res;
		paintSplatJob.SplatMap = splatMap.dst;
		paintSplatJob.SplatMapRes = splatMap.res;
		paintSplatJob.SplatNum = splatMap.num;
		paintSplatJob.SplatType2Index = val.AsReadOnly();
		paintSplatJob.TerrainOneOverSizeX = TerrainMeta.OneOverSize.x;
		PaintSplatJob paintSplatJob2 = paintSplatJob;
		val2 = IJobForExtensions.ScheduleByRef<PaintSplatJob>(ref paintSplatJob2, heightMapDelta.Length, val2);
		val.Dispose(val2);
		GenerateErosion.splatPaintingData.Dispose(val2);
		((JobHandle)(ref val2)).Complete();
		splatMap.Pop();
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateHeight : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_height")]
	public unsafe static extern void Native_GenerateHeight(short* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		short* unsafePtr = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.dst);
		int res = TerrainMeta.HeightMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		Native_GenerateHeight(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class GenerateOceanTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		TerrainTopologyMap topologymap = TerrainMeta.TopologyMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		NativeArray<int> dst = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = topologymap.Coordinate(i);
				float normZ = topologymap.Coordinate(z);
				int num = dst[z * res + i];
				if (heightmap.GetHeight01(normX, normZ) <= 0.5f)
				{
					if ((num & 0x810000) == 0)
					{
						dst[z * res + i] = num | 0x80;
					}
				}
				else
				{
					dst[z * res + i] = num & -129;
				}
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GeneratePowerlineLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;
	}

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Powerlines.Clear();
			TerrainMeta.Path.Powerlines.AddRange(World.GetPaths("Powerline"));
		}
		else
		{
			if (!World.Config.Powerlines)
			{
				return;
			}
			List<PathList> list = new List<PathList>();
			List<MonumentInfo> monuments = TerrainMeta.Path.Monuments;
			int[,] array = TerrainPath.CreatePowerlineCostmap(ref seed);
			PathFinder pathFinder = new PathFinder(array);
			int length = array.GetLength(0);
			List<PathSegment> list2 = new List<PathSegment>();
			List<PathNode> list3 = new List<PathNode>();
			List<PathNode> list4 = new List<PathNode>();
			List<PathFinder.Point> list5 = new List<PathFinder.Point>();
			List<PathFinder.Point> list6 = new List<PathFinder.Point>();
			List<PathFinder.Point> list7 = new List<PathFinder.Point>();
			foreach (PathList road in TerrainMeta.Path.Roads)
			{
				if (road.ProcgenStartNode == null || road.ProcgenEndNode == null || road.Hierarchy != 0)
				{
					continue;
				}
				int num = 1;
				for (PathFinder.Node node = road.ProcgenStartNode; node != null; node = node.next)
				{
					if (num % 8 == 0)
					{
						list5.Add(node.point);
					}
					num++;
				}
			}
			foreach (MonumentInfo item in monuments)
			{
				TerrainPathConnect[] componentsInChildren = ((Component)item).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Power)
					{
						PathFinder.Point pathFinderPoint = terrainPathConnect.GetPathFinderPoint(length);
						PathFinder.Node node2 = pathFinder.FindClosestWalkable(pathFinderPoint, 100000);
						if (node2 != null)
						{
							PathNode pathNode = new PathNode();
							pathNode.monument = item;
							pathNode.node = node2;
							list4.Add(pathNode);
						}
					}
				}
			}
			while (list4.Count != 0)
			{
				list7.Clear();
				list7.AddRange(list4.Select((PathNode x) => x.node.point));
				list6.Clear();
				list6.AddRange(list3.Select((PathNode x) => x.node.point));
				list6.AddRange(list5);
				PathFinder.Node node3 = pathFinder.FindPathUndirected(list6, list7, 100000);
				if (node3 == null)
				{
					PathNode copy = list4[0];
					list3.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)copy.monument));
					list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)copy.monument);
					continue;
				}
				PathSegment segment = new PathSegment();
				for (PathFinder.Node node4 = node3; node4 != null; node4 = node4.next)
				{
					if (node4 == node3)
					{
						segment.start = node4;
					}
					if (node4.next == null)
					{
						segment.end = node4;
					}
				}
				list2.Add(segment);
				PathNode copy2 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				list3.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)copy2.monument));
				list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)copy2.monument);
				int num2 = 1;
				for (PathFinder.Node node5 = node3; node5 != null; node5 = node5.next)
				{
					if (num2 % 8 == 0)
					{
						list5.Add(node5.point);
					}
					num2++;
				}
			}
			List<Vector3> list8 = new List<Vector3>();
			foreach (PathSegment item2 in list2)
			{
				for (PathFinder.Node node6 = item2.start; node6 != null; node6 = node6.next)
				{
					float num3 = ((float)node6.point.x + 0.5f) / (float)length;
					float num4 = ((float)node6.point.y + 0.5f) / (float)length;
					float height = TerrainMeta.HeightMap.GetHeight01(num3, num4);
					list8.Add(TerrainMeta.Denormalize(new Vector3(num3, height, num4)));
				}
				if (list8.Count != 0)
				{
					if (list8.Count >= 8)
					{
						PathList pathList = new PathList("Powerline " + (TerrainMeta.Path.Powerlines.Count + list.Count), list8.ToArray());
						pathList.Start = true;
						pathList.End = true;
						pathList.ProcgenStartNode = item2.start;
						pathList.ProcgenEndNode = item2.end;
						list.Add(pathList);
					}
					list8.Clear();
				}
			}
			foreach (PathList item3 in list)
			{
				item3.Path.RecalculateTangents();
			}
			TerrainMeta.Path.Powerlines.AddRange(list);
		}
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;
}


public class GeneratePowerlineTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailBranching : ProceduralComponent
{
	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 1
		};
	}

	public override void Process(uint seed)
	{
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_0528: Unknown result type (might be due to invalid IL or missing references)
		//IL_0534: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_0588: Unknown result type (might be due to invalid IL or missing references)
		//IL_058d: Unknown result type (might be due to invalid IL or missing references)
		//IL_058f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_059f: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_060d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_063a: Unknown result type (might be due to invalid IL or missing references)
		//IL_063e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0643: Unknown result type (might be due to invalid IL or missing references)
		//IL_066f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0674: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			return;
		}
		int num = Mathf.RoundToInt(40f);
		int num2 = Mathf.RoundToInt(53.333332f);
		int num3 = Mathf.RoundToInt(40f);
		int num4 = Mathf.RoundToInt(120f);
		float num5 = 120f * 120f;
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				select target).ToArray();
			foreach (TerrainPathConnect terrainPathConnect in array2)
			{
				pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(((Component)terrainPathConnect).transform.position, length));
			}
		}
		if (pathFinder.PushPointsAdditional.Count > 0)
		{
			pathFinder.PushDistance = 10;
			pathFinder.PushMultiplier = int.MaxValue;
		}
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		foreach (PathList rail2 in TerrainMeta.Path.Rails)
		{
			foreach (PathList rail3 in TerrainMeta.Path.Rails)
			{
				if (rail2 == rail3)
				{
					continue;
				}
				Vector3[] points = rail2.Path.Points;
				foreach (Vector3 val in points)
				{
					Vector3[] points2 = rail3.Path.Points;
					foreach (Vector3 val2 in points2)
					{
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < num5)
						{
							hashSet.Add(val);
							break;
						}
					}
				}
			}
		}
		foreach (PathList rail4 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path = rail4.Path;
			Vector3[] points3 = path.Points;
			Vector3[] tangents = path.Tangents;
			int num6 = path.MinIndex + 1 + 8;
			int num7 = path.MaxIndex - 1 - 8;
			for (int l = num6; l <= num7; l++)
			{
				list2.Clear();
				list3.Clear();
				list4.Clear();
				int num8 = SeedRandom.Range(ref seed, num3, num4);
				int num9 = SeedRandom.Range(ref seed, num, num2);
				int num10 = l;
				int num11 = l + num8;
				if (num11 >= num7)
				{
					continue;
				}
				Vector3 val4 = tangents[num10];
				Vector3 val5 = tangents[num11];
				if (Vector3.Angle(val4, val5) > 30f)
				{
					continue;
				}
				Vector3 val6 = points3[num10];
				Vector3 val7 = points3[num11];
				if (hashSet.Contains(val6) || hashSet.Contains(val7))
				{
					continue;
				}
				PathFinder.Point point = PathFinder.GetPoint(val6, length);
				PathFinder.Point point2 = PathFinder.GetPoint(val7, length);
				l += num9;
				PathFinder.Node node = pathFinder.FindPath(point, point2, 250000);
				if (node == null)
				{
					continue;
				}
				PathFinder.Node node2 = null;
				PathFinder.Node node3 = null;
				PathFinder.Node node4 = node;
				while (node4 != null && node4.next != null)
				{
					if (node4 == node.next)
					{
						node2 = node4;
					}
					if (node4.next.next == null)
					{
						node3 = node4;
					}
					node4 = node4.next;
				}
				if (node2 == null || node3 == null)
				{
					continue;
				}
				node = node2;
				node3.next = null;
				for (int m = 0; m < 8; m++)
				{
					int num12 = num10 + (m + 1 - 8);
					int num13 = num11 + m;
					list2.Add(points3[num12]);
					list3.Add(points3[num13]);
				}
				list4.AddRange(list2);
				for (PathFinder.Node node5 = node2; node5 != null; node5 = node5.next)
				{
					float normX = ((float)node5.point.x + 0.5f) / (float)length;
					float normZ = ((float)node5.point.y + 0.5f) / (float)length;
					float num14 = TerrainMeta.DenormalizeX(normX);
					float num15 = TerrainMeta.DenormalizeZ(normZ);
					float num16 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
					list4.Add(new Vector3(num14, num16, num15));
				}
				list4.AddRange(list3);
				int num17 = 8;
				int num18 = list4.Count - 1 - 8;
				Vector3 val8 = Vector3.Normalize(list4[num17 + 16] - list4[num17]);
				Vector3 val9 = Vector3.Normalize(list4[num18] - list4[num18 - 16]);
				Vector3 val10 = Vector3.Normalize(points3[num10 + 16] - points3[num10]);
				Vector3 val11 = Vector3.Normalize(points3[num11] - points3[(num11 - 16 + points3.Length) % points3.Length]);
				float num19 = Vector3.SignedAngle(val10, val8, Vector3.up);
				float num20 = 0f - Vector3.SignedAngle(val11, val9, Vector3.up);
				if (Mathf.Sign(num19) != Mathf.Sign(num20) || Mathf.Abs(num19) > 60f || Mathf.Abs(num20) > 60f)
				{
					continue;
				}
				Vector3 val12 = rot90 * val10;
				Vector3 val13 = rot90 * val11;
				if (num19 < 0f)
				{
					val12 = -val12;
				}
				if (num20 < 0f)
				{
					val13 = -val13;
				}
				for (int n = 0; n < 16; n++)
				{
					int num21 = n;
					int num22 = list4.Count - n - 1;
					float num23 = Mathf.InverseLerp(0f, 8f, (float)n);
					float num24 = Mathf.SmoothStep(0f, 2f, num23) * 4f;
					List<Vector3> list5 = list4;
					int j = num21;
					list5[j] += val12 * num24;
					list5 = list4;
					j = num22;
					list5[j] += val13 * num24;
				}
				bool flag = false;
				bool flag2 = false;
				foreach (Vector3 item in list4)
				{
					bool blocked = TerrainMeta.PlacementMap.GetBlocked(item);
					if (!flag2 && !flag && !blocked)
					{
						flag = true;
					}
					if (flag && !flag2 && blocked)
					{
						flag2 = true;
					}
					if (flag && flag2 && !blocked)
					{
						list4.Clear();
						break;
					}
				}
				if (list4.Count != 0)
				{
					if (list4.Count >= 2)
					{
						int number = TerrainMeta.Path.Rails.Count + list.Count;
						PathList pathList = CreateSegment(number, list4.ToArray());
						pathList.Start = false;
						pathList.End = false;
						pathList.ProcgenStartNode = node2;
						pathList.ProcgenEndNode = node3;
						list.Add(pathList);
					}
					l += num8;
				}
			}
		}
		foreach (PathList rail in list)
		{
			Func<int, float> filter = delegate(int i)
			{
				float num25 = Mathf.InverseLerp(0f, 8f, (float)i);
				float num26 = Mathf.InverseLerp((float)rail.Path.DefaultMaxIndex, (float)(rail.Path.DefaultMaxIndex - 8), (float)i);
				return Mathf.SmoothStep(0f, 1f, Mathf.Min(num25, num26));
			};
			rail.Path.Smoothen(32, new Vector3(1f, 0f, 1f), filter);
			rail.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter);
			rail.Path.Resample(7.5f);
			rail.Path.RecalculateTangents();
			rail.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 1
		};
	}

	public override void Process(uint seed)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0506: Unknown result type (might be due to invalid IL or missing references)
		//IL_0508: Unknown result type (might be due to invalid IL or missing references)
		//IL_050a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06be: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0857: Unknown result type (might be due to invalid IL or missing references)
		//IL_0865: Unknown result type (might be due to invalid IL or missing references)
		//IL_086a: Unknown result type (might be due to invalid IL or missing references)
		//IL_086f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0874: Unknown result type (might be due to invalid IL or missing references)
		//IL_0876: Unknown result type (might be due to invalid IL or missing references)
		//IL_087b: Unknown result type (might be due to invalid IL or missing references)
		//IL_087d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0882: Unknown result type (might be due to invalid IL or missing references)
		//IL_0804: Unknown result type (might be due to invalid IL or missing references)
		//IL_0809: Unknown result type (might be due to invalid IL or missing references)
		//IL_080b: Unknown result type (might be due to invalid IL or missing references)
		//IL_080d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0814: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_081b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0738: Unknown result type (might be due to invalid IL or missing references)
		//IL_073e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0893: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08da: Unknown result type (might be due to invalid IL or missing references)
		//IL_091f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_0928: Unknown result type (might be due to invalid IL or missing references)
		//IL_092d: Unknown result type (might be due to invalid IL or missing references)
		//IL_09e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a0f: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Rails.Clear();
			TerrainMeta.Path.Rails.AddRange(World.GetPaths("Rail"));
			{
				foreach (PathList rail in TerrainMeta.Path.Rails)
				{
					Func<int, float> filter = delegate(int i)
					{
						float num = Mathf.InverseLerp(0f, 8f, (float)i);
						float num2 = Mathf.InverseLerp((float)rail.Path.DefaultMaxIndex, (float)(rail.Path.DefaultMaxIndex - 8), (float)i);
						return Mathf.SmoothStep(0f, 1f, Mathf.Min(num, num2));
					};
					Vector3[] points = rail.Path.Points;
					for (int j = 1; j < points.Length - 1; j++)
					{
						Vector3 val = points[j];
						val.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(val), 1f);
						points[j] = val;
					}
					rail.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter);
					rail.Path.RecalculateTangents();
				}
				return;
			}
		}
		if (!World.Config.AboveGroundRails)
		{
			return;
		}
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		PathFinder pathFinder2 = new PathFinder(array);
		int length = array.GetLength(0);
		new List<PathSegment>();
		List<PathFinder.Point> list2 = new List<PathFinder.Point>();
		List<PathFinder.Point> list3 = new List<PathFinder.Point>();
		List<PathFinder.Point> list4 = new List<PathFinder.Point>();
		List<Vector3> list5 = new List<Vector3>();
		foreach (PathList rail3 in TerrainMeta.Path.Rails)
		{
			for (PathFinder.Node node = rail3.ProcgenStartNode; node != null; node = node.next)
			{
				list2.Add(node.point);
			}
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			pathFinder.PushPoint = monument.GetPathFinderPoint(length);
			pathFinder.PushRadius = (pathFinder.PushDistance = monument.GetPathFinderRadius(length));
			pathFinder.PushMultiplier = 50000;
			int num3 = int.MaxValue;
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				orderby DistanceToRail(((Component)target).transform.position)
				select target).ToArray();
			TerrainPathConnect[] array3 = array2;
			foreach (TerrainPathConnect terrainPathConnect in array3)
			{
				pathFinder.PushPointsAdditional.Clear();
				pathFinder.BlockedPointsAdditional.Clear();
				Vector3 val2 = ((Component)terrainPathConnect).transform.position;
				TerrainPathConnect[] array4 = array2;
				foreach (TerrainPathConnect terrainPathConnect2 in array4)
				{
					if (!((Object)(object)terrainPathConnect == (Object)(object)terrainPathConnect2))
					{
						Vector3 position = ((Component)terrainPathConnect2).transform.position;
						PathFinder.Point point = PathFinder.GetPoint(((Component)terrainPathConnect2).transform.position, length);
						pathFinder.PushPointsAdditional.Add(point);
						val2 += position;
					}
				}
				val2 /= (float)array2.Length;
				Vector3 val3;
				if (array2.Length <= 1)
				{
					val3 = ((Component)terrainPathConnect).transform.forward;
				}
				else
				{
					Vector3 val4 = ((Component)terrainPathConnect).transform.position - val2;
					val3 = ((Vector3)(ref val4)).normalized;
				}
				Vector3 val5 = val3;
				foreach (PathList item in list)
				{
					pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(item.Path.GetEndPoint(), length));
					PathFinder.Point point2 = PathFinder.GetPoint(item.Path.GetStartPoint(), length);
					Vector3[] points2 = item.Path.Points;
					for (int l = 0; l < points2.Length; l++)
					{
						PathFinder.Point point3 = PathFinder.GetPoint(points2[l], length);
						pathFinder.BlockedPointsAdditional.Add(point3);
						pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point3.x, point2.y));
						pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point2.x, point3.y));
						point2 = point3;
					}
					if (item.ProcgenStartNode != null)
					{
						PathFinder.Point point4 = item.ProcgenStartNode.point;
						for (PathFinder.Node node2 = item.ProcgenStartNode; node2 != null; node2 = node2.next)
						{
							PathFinder.Point point5 = node2.point;
							pathFinder.BlockedPointsAdditional.Add(point5);
							pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point5.x, point4.y));
							pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point4.x, point5.y));
							point4 = point5;
						}
					}
				}
				list5.Clear();
				Vector3 val6 = ((Component)terrainPathConnect).transform.position;
				Vector3 val7 = ((Component)terrainPathConnect).transform.forward * 7.5f;
				PathFinder.Point point6 = PathFinder.GetPoint(val6, length);
				for (int m = 0; (m < 8 && pathFinder.Heuristic(point6, list2) > 1) || (m < 16 && !pathFinder.IsWalkable(point6)); m++)
				{
					list5.Add(val6);
					val6 += val7;
					point6 = PathFinder.GetPoint(val6, length);
				}
				if (!pathFinder.IsWalkable(point6))
				{
					continue;
				}
				list3.Clear();
				list3.Add(point6);
				list4.Clear();
				list4.AddRange(list2);
				PathFinder.Node node3 = pathFinder.FindPathDirected(list3, list4, 250000);
				bool flag = false;
				if (node3 == null && list.Count > 0 && num3 != int.MaxValue)
				{
					PathList pathList = list[list.Count - 1];
					list4.Clear();
					for (int n = 0; n < pathList.Path.Points.Length; n++)
					{
						list4.Add(PathFinder.GetPoint(pathList.Path.Points[n], length));
					}
					node3 = pathFinder2.FindPathDirected(list3, list4, 250000);
					flag = true;
				}
				if (node3 == null)
				{
					continue;
				}
				PathFinder.Node node4 = null;
				PathFinder.Node node5 = null;
				PathFinder.Node node6 = node3;
				while (node6 != null && node6.next != null)
				{
					if (node6 == node3.next)
					{
						node4 = node6;
					}
					if (node6.next.next == null)
					{
						node5 = node6;
						node5.next = null;
					}
					node6 = node6.next;
				}
				for (PathFinder.Node node7 = node4; node7 != null; node7 = node7.next)
				{
					float normX = ((float)node7.point.x + 0.5f) / (float)length;
					float normZ = ((float)node7.point.y + 0.5f) / (float)length;
					float num4 = TerrainMeta.DenormalizeX(normX);
					float num5 = TerrainMeta.DenormalizeZ(normZ);
					float num6 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
					list5.Add(new Vector3(num4, num6, num5));
				}
				if (list5.Count < 1)
				{
					continue;
				}
				Vector3 val8 = list5[list5.Count - 1];
				Vector3 val9 = val5;
				PathList pathList2 = null;
				float num7 = float.MaxValue;
				int num8 = -1;
				if (!flag)
				{
					foreach (PathList rail4 in TerrainMeta.Path.Rails)
					{
						Vector3[] points3 = rail4.Path.Points;
						for (int num9 = 0; num9 < points3.Length; num9++)
						{
							float num10 = Vector3.Distance(val8, points3[num9]);
							if (num10 < num7)
							{
								num7 = num10;
								pathList2 = rail4;
								num8 = num9;
							}
						}
					}
				}
				else
				{
					foreach (PathList item2 in list)
					{
						Vector3[] points4 = item2.Path.Points;
						for (int num11 = 0; num11 < points4.Length; num11++)
						{
							float num12 = Vector3.Distance(val8, points4[num11]);
							if (num12 < num7)
							{
								num7 = num12;
								pathList2 = item2;
								num8 = num11;
							}
						}
					}
				}
				int num13 = 1;
				if (!flag)
				{
					Vector3 tangentByIndex = pathList2.Path.GetTangentByIndex(num8);
					num13 = ((Vector3.Angle(tangentByIndex, val9) < Vector3.Angle(-tangentByIndex, val9)) ? 1 : (-1));
					if (num3 != int.MaxValue)
					{
						GenericsUtil.Swap<int>(ref num3, ref num13);
						num13 = -num13;
					}
					else
					{
						num3 = num13;
					}
				}
				Vector3 val10 = Vector3.Normalize(pathList2.Path.GetPointByIndex(num8 + num13 * 8 * 2) - pathList2.Path.GetPointByIndex(num8));
				Vector3 val11 = rot90 * val10;
				if (!flag)
				{
					Vector3 val12 = Vector3.Normalize(list5[list5.Count - 1] - list5[Mathf.Max(0, list5.Count - 1 - 16)]);
					if (0f - Vector3.SignedAngle(val10, val12, Vector3.up) < 0f)
					{
						val11 = -val11;
					}
				}
				for (int num14 = 0; num14 < 8; num14++)
				{
					float num15 = Mathf.InverseLerp(7f, 0f, (float)num14);
					float num16 = Mathf.SmoothStep(0f, 2f, num15) * 4f;
					list5.Add(pathList2.Path.GetPointByIndex(num8 + num13 * num14) + val11 * num16);
				}
				if (list5.Count >= 2)
				{
					int number = TerrainMeta.Path.Rails.Count + list.Count;
					PathList rail2 = CreateSegment(number, list5.ToArray());
					rail2.Start = true;
					rail2.End = false;
					rail2.ProcgenStartNode = node4;
					rail2.ProcgenEndNode = node5;
					Func<int, float> filter2 = delegate(int i)
					{
						float num17 = Mathf.InverseLerp(0f, 8f, (float)i);
						float num18 = Mathf.InverseLerp((float)rail2.Path.DefaultMaxIndex, (float)(rail2.Path.DefaultMaxIndex - 8), (float)i);
						return Mathf.SmoothStep(0f, 1f, Mathf.Min(num17, num18));
					};
					rail2.Path.Smoothen(32, new Vector3(1f, 0f, 1f), filter2);
					rail2.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter2);
					rail2.Path.Resample(7.5f);
					rail2.Path.RecalculateTangents();
					list.Add(rail2);
				}
			}
		}
		foreach (PathList item3 in list)
		{
			item3.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
		static float DistanceToRail(Vector3 vec)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			float num19 = float.MaxValue;
			foreach (PathList rail5 in TerrainMeta.Path.Rails)
			{
				Vector3[] points5 = rail5.Path.Points;
				foreach (Vector3 val13 in points5)
				{
					num19 = Mathf.Min(num19, Vector3Ex.Magnitude2D(vec - val13));
				}
			}
			return num19;
		}
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public TerrainPathConnect target;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;

	public TerrainPathConnect origin;

	public TerrainPathConnect target;
}


using UnityEngine;

public class GenerateRailMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0f;

	public const bool SnapToTerrain = false;

	public Mesh RailMesh;

	public Mesh[] RailMeshes;

	public Material RailMaterial;

	public PhysicMaterial RailPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Expected O, but got Unknown
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		if (RailMeshes == null || RailMeshes.Length == 0)
		{
			RailMeshes = (Mesh[])(object)new Mesh[1] { RailMesh };
		}
		foreach (PathList rail in TerrainMeta.Path.Rails)
		{
			GameObject val = new GameObject(rail.Name);
			foreach (PathList.MeshObject item in rail.CreateMesh(RailMeshes, 0f, snapToTerrain: false, !rail.Path.Circular && !rail.Start, !rail.Path.Circular && !rail.End))
			{
				GameObject val2 = new GameObject("Rail Mesh");
				val2.transform.position = item.Position;
				val2.tag = "Railway";
				val2.layer = 16;
				val2.transform.SetParent(val.transform, true);
				val2.SetActive(false);
				MeshCollider obj = val2.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RailPhysicMaterial;
				obj.sharedMesh = item.Meshes[0];
				val2.AddComponent<AddToHeightMap>();
				val2.SetActive(true);
			}
			AddTrackSpline(val, rail);
		}
	}

	private void AddTrackSpline(GameObject rootGO, PathList rail)
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline trainTrackSpline = rootGO.AddComponent<TrainTrackSpline>();
		trainTrackSpline.aboveGroundSpawn = rail.Hierarchy == 2;
		trainTrackSpline.hierarchy = rail.Hierarchy;
		if (trainTrackSpline.aboveGroundSpawn)
		{
			TrainTrackSpline.SidingSplines.Add(trainTrackSpline);
		}
		Vector3[] array = (Vector3[])(object)new Vector3[rail.Path.Points.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = rail.Path.Points[i];
			array[i].y += 0.41f;
		}
		Vector3[] array2 = (Vector3[])(object)new Vector3[rail.Path.Tangents.Length];
		for (int j = 0; j < array.Length; j++)
		{
			array2[j] = rail.Path.Tangents[j];
		}
		trainTrackSpline.SetAll(array, array2, 0.25f);
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailRing : ProceduralComponent
{
	private class RingNode
	{
		public int attempts;

		public PathFinder.Point position;

		public PathFinder.Point direction;

		public RingNode next;

		public RingNode prev;

		public PathFinder.Node path;

		public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
		{
			position = new PathFinder.Point(pos_x, pos_y);
			direction = new PathFinder.Point(dir_x, dir_y);
			attempts = stepcount;
		}
	}

	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 250000;

	public int MinWorldSize;

	public override void Process(uint seed)
	{
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_082c: Unknown result type (might be due to invalid IL or missing references)
		//IL_093a: Unknown result type (might be due to invalid IL or missing references)
		//IL_095d: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked || World.Size < MinWorldSize || !World.Config.AboveGroundRails)
		{
			return;
		}
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		int num = length / 4;
		int num2 = 1;
		int stepcount = num / num2;
		int num3 = length / 2;
		int pos_x = num;
		int pos_x2 = length - num;
		int pos_y = num;
		int pos_y2 = length - num;
		int num4 = 0;
		int dir_x = -num2;
		int dir_x2 = num2;
		int dir_y = -num2;
		int dir_y2 = num2;
		List<RingNode> list = ((World.Size >= 5000) ? new List<RingNode>
		{
			new RingNode(num3, pos_y2, num4, dir_y, stepcount),
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, num3, dir_x, num4, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(num3, pos_y, num4, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, num3, dir_x2, num4, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		} : new List<RingNode>
		{
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		});
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				select target).ToArray();
			foreach (TerrainPathConnect terrainPathConnect in array2)
			{
				pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(((Component)terrainPathConnect).transform.position, length));
			}
		}
		if (pathFinder.PushPointsAdditional.Count > 0)
		{
			pathFinder.PushDistance = 10;
			pathFinder.PushMultiplier = int.MaxValue;
		}
		for (int j = 0; j < list.Count; j++)
		{
			RingNode ringNode = list[j];
			RingNode next = list[(j + 1) % list.Count];
			RingNode prev = list[(j - 1 + list.Count) % list.Count];
			ringNode.next = next;
			ringNode.prev = prev;
			while (!pathFinder.IsWalkableWithNeighbours(ringNode.position))
			{
				if (ringNode.attempts <= 0)
				{
					return;
				}
				ringNode.position += ringNode.direction;
				ringNode.attempts--;
			}
		}
		foreach (RingNode item in list)
		{
			item.path = pathFinder.FindPath(item.position, item.next.position, 250000);
		}
		bool flag = false;
		while (!flag)
		{
			flag = true;
			PathFinder.Point point = new PathFinder.Point(0, 0);
			foreach (RingNode item2 in list)
			{
				point += item2.position;
			}
			point /= list.Count;
			float num5 = float.MinValue;
			RingNode ringNode2 = null;
			foreach (RingNode item3 in list)
			{
				if (item3.path == null)
				{
					Vector2 val = new Vector2((float)(item3.position.x - point.x), (float)(item3.position.y - point.y));
					float num6 = ((Vector2)(ref val)).magnitude;
					if (item3.prev.path == null)
					{
						num6 *= 1.5f;
					}
					if (num6 > num5)
					{
						num5 = num6;
						ringNode2 = item3;
					}
				}
			}
			if (ringNode2 == null)
			{
				continue;
			}
			do
			{
				if (ringNode2.attempts <= 0)
				{
					return;
				}
				ringNode2.position += ringNode2.direction;
				ringNode2.attempts--;
			}
			while (!pathFinder.IsWalkableWithNeighbours(ringNode2.position));
			ringNode2.path = pathFinder.FindPath(ringNode2.position, ringNode2.next.position, 250000);
			ringNode2.prev.path = pathFinder.FindPath(ringNode2.prev.position, ringNode2.position, 250000);
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		for (int k = 0; k < list.Count; k++)
		{
			RingNode ringNode3 = list[k];
			RingNode ringNode4 = list[(k + 1) % list.Count];
			PathFinder.Node node = null;
			PathFinder.Node node2 = null;
			for (PathFinder.Node node3 = ringNode3.path; node3 != null; node3 = node3.next)
			{
				for (PathFinder.Node node4 = ringNode4.path; node4 != null; node4 = node4.next)
				{
					int num7 = Mathf.Abs(node3.point.x - node4.point.x);
					int num8 = Mathf.Abs(node3.point.y - node4.point.y);
					if (num7 <= 15 && num8 <= 15)
					{
						if (node == null || node3.cost > node.cost)
						{
							node = node3;
						}
						if (node2 == null || node4.cost < node2.cost)
						{
							node2 = node4;
						}
					}
				}
			}
			if (node != null && node2 != null)
			{
				PathFinder.Node node5 = pathFinder.FindPath(node.point, node2.point, 250000);
				if (node5 != null && node5.next != null)
				{
					node.next = node5.next;
					ringNode4.path = node2;
				}
			}
		}
		for (int l = 0; l < list.Count; l++)
		{
			RingNode ringNode5 = list[l];
			RingNode ringNode6 = list[(l + 1) % list.Count];
			PathFinder.Node node6 = null;
			PathFinder.Node node7 = null;
			for (PathFinder.Node node8 = ringNode5.path; node8 != null; node8 = node8.next)
			{
				for (PathFinder.Node node9 = ringNode6.path; node9 != null; node9 = node9.next)
				{
					int num9 = Mathf.Abs(node8.point.x - node9.point.x);
					int num10 = Mathf.Abs(node8.point.y - node9.point.y);
					if (num9 <= 1 && num10 <= 1)
					{
						if (node6 == null || node8.cost > node6.cost)
						{
							node6 = node8;
						}
						if (node7 == null || node9.cost < node7.cost)
						{
							node7 = node9;
						}
					}
				}
			}
			if (node6 != null && node7 != null)
			{
				node6.next = null;
				ringNode6.path = node7;
			}
		}
		PathFinder.Node node10 = null;
		PathFinder.Node node11 = null;
		foreach (RingNode item4 in list)
		{
			if (node10 == null)
			{
				node10 = item4.path;
				node11 = item4.path;
			}
			else
			{
				node11.next = item4.path;
			}
			while (node11.next != null)
			{
				node11 = node11.next;
			}
		}
		node11.next = new PathFinder.Node(node10.point, node10.cost, node10.heuristic);
		List<Vector3> list2 = new List<Vector3>();
		for (PathFinder.Node node12 = node10; node12 != null; node12 = node12.next)
		{
			float normX = ((float)node12.point.x + 0.5f) / (float)length;
			float normZ = ((float)node12.point.y + 0.5f) / (float)length;
			float num11 = TerrainMeta.DenormalizeX(normX);
			float num12 = TerrainMeta.DenormalizeZ(normZ);
			float num13 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
			list2.Add(new Vector3(num11, num13, num12));
		}
		if (list2.Count >= 2)
		{
			PathList pathList = new PathList("Rail " + TerrainMeta.Path.Rails.Count, list2.ToArray());
			pathList.Spline = true;
			pathList.Width = 4f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 32f;
			pathList.RandomScale = 1f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 524288;
			pathList.Splat = 128;
			pathList.Start = false;
			pathList.End = false;
			pathList.ProcgenStartNode = node10;
			pathList.ProcgenEndNode = node11;
			pathList.Path.Smoothen(32, new Vector3(1f, 0f, 1f));
			pathList.Path.Smoothen(64, new Vector3(0f, 1f, 0f));
			pathList.Path.Resample(7.5f);
			pathList.Path.RecalculateTangents();
			pathList.AdjustPlacementMap(20f);
			TerrainMeta.Path.Rails.Add(pathList);
		}
	}
}


private class RingNode
{
	public int attempts;

	public PathFinder.Point position;

	public PathFinder.Point direction;

	public RingNode next;

	public RingNode prev;

	public PathFinder.Node path;

	public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
	{
		position = new PathFinder.Point(pos_x, pos_y);
		direction = new PathFinder.Point(dir_x, dir_y);
		attempts = stepcount;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRailSiding : ProceduralComponent
{
	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rotRight = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rotLeft = Quaternion.Euler(0f, -90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 2
		};
	}

	public override void Process(uint seed)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			return;
		}
		int num = Mathf.RoundToInt(40f);
		int num2 = Mathf.RoundToInt(53.333332f);
		int num3 = Mathf.RoundToInt(13.333333f);
		int num4 = Mathf.RoundToInt(20f);
		float num5 = 16f * 16f;
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		new PathFinder(array);
		array.GetLength(0);
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		foreach (PathList rail in TerrainMeta.Path.Rails)
		{
			foreach (PathList rail2 in TerrainMeta.Path.Rails)
			{
				if (rail == rail2)
				{
					continue;
				}
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					Vector3[] points2 = rail2.Path.Points;
					foreach (Vector3 val2 in points2)
					{
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < num5)
						{
							hashSet.Add(val);
							break;
						}
					}
				}
			}
		}
		foreach (PathList rail3 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path = rail3.Path;
			Vector3[] points3 = path.Points;
			Vector3[] tangents = path.Tangents;
			int num6 = path.MinIndex + 1 + 16;
			int num7 = path.MaxIndex - 1 - 16;
			for (int k = num6; k <= num7; k++)
			{
				list2.Clear();
				list3.Clear();
				int num8 = SeedRandom.Range(ref seed, num3, num4);
				int num9 = SeedRandom.Range(ref seed, num, num2);
				int num10 = k;
				int num11 = k + num8;
				if (num11 >= num7)
				{
					continue;
				}
				Vector3 val4 = tangents[num10];
				Vector3 val5 = tangents[num11];
				if (Vector3.Angle(val4, val5) > 30f)
				{
					continue;
				}
				Vector3 val6 = tangents[num10];
				Vector3 val7 = tangents[num11];
				Vector3 val8 = Vector3.Normalize(points3[num10 + 8] - points3[num10]);
				Vector3 val9 = Vector3.Normalize(points3[num11] - points3[num11 - 8]);
				float num12 = Vector3.SignedAngle(val8, val6, Vector3.up);
				float num13 = 0f - Vector3.SignedAngle(val9, val7, Vector3.up);
				if (Mathf.Sign(num12) != Mathf.Sign(num13) || Mathf.Abs(num12) > 60f || Mathf.Abs(num13) > 60f)
				{
					continue;
				}
				float num14 = 5f;
				Quaternion val10 = ((num12 > 0f) ? rotRight : rotLeft);
				for (int l = num10 - 8; l <= num11 + 8; l++)
				{
					Vector3 val11 = points3[l];
					if (hashSet.Contains(val11))
					{
						list2.Clear();
						list3.Clear();
						break;
					}
					Vector3 val12 = tangents[l];
					Vector3 val13 = val10 * val12;
					if (l < num10 + 8)
					{
						float num15 = Mathf.InverseLerp((float)(num10 - 8), (float)num10, (float)l);
						float num16 = Mathf.SmoothStep(0f, 1f, num15) * num14;
						val11 += val13 * num16;
					}
					else if (l > num11 - 8)
					{
						float num17 = Mathf.InverseLerp((float)(num11 + 8), (float)num11, (float)l);
						float num18 = Mathf.SmoothStep(0f, 1f, num17) * num14;
						val11 += val13 * num18;
					}
					else
					{
						val11 += val13 * num14;
					}
					list2.Add(val11);
					list3.Add(val12);
				}
				if (list2.Count >= 2)
				{
					int number = TerrainMeta.Path.Rails.Count + list.Count;
					PathList pathList = CreateSegment(number, list2.ToArray());
					pathList.Start = false;
					pathList.End = false;
					list.Add(pathList);
					k += num8;
				}
				k += num9;
			}
		}
		foreach (PathList item in list)
		{
			item.Path.Resample(7.5f);
			item.Path.RecalculateTangents();
			item.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRailTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 8;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 64;

	public const int SmoothenXZ = 32;

	public const int TransitionSteps = 8;

	private float AdjustTerrainFade(float xn, float zn)
	{
		int topology = TerrainMeta.TopologyMap.GetTopology(xn, zn);
		if ((topology & 0x4000) != 0)
		{
			return 0f;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.5f;
		}
		return 1f;
	}

	private float SmoothenFilter(PathList path, int index)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float num = (path.Start ? Mathf.SmoothStep(0f, 1f, Mathf.InverseLerp(0f, 8f, (float)index)) : 1f);
		int topology = TerrainMeta.TopologyMap.GetTopology(path.Path.Points[index]);
		if ((topology & 0x4000) != 0)
		{
			return 0.1f * num;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.3f * num;
		}
		return num;
	}

	public override void Process(uint seed)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		for (int j = 0; j < 8; j++)
		{
			foreach (PathList rail in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				PathInterpolator path = rail.Path;
				Vector3[] points = path.Points;
				for (int k = 0; k < points.Length; k++)
				{
					Vector3 val = points[k];
					float num = heightMap.GetHeight(val);
					if ((topologyMap.GetTopology(val) & 0xC000) != 0)
					{
						num = Mathf.Max(num, WaterLevel.RaycastWaterColliders(val) + 2f);
					}
					if (rail.Start)
					{
						val.y = Mathf.SmoothStep(val.y, num, SmoothenFilter(rail, k));
					}
					else
					{
						val.y = num;
					}
					points[k] = val;
				}
				path.Smoothen(8, Vector3.up, (int i) => SmoothenFilter(rail, i));
				path.RecalculateTangents();
			}
			foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fademin = 0.125f;
				float fademax = Mathf.InverseLerp(8f, 0f, (float)j);
				item.AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => Mathf.Lerp(fademin, fademax, AdjustTerrainFade(xn, zn)));
				heightMap.Pop();
			}
		}
		foreach (PathList rail2 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path2 = rail2.Path;
			Vector3[] points2 = path2.Points;
			for (int l = 0; l < points2.Length; l++)
			{
				Vector3 val2 = points2[l];
				float height = heightMap.GetHeight(val2);
				if (rail2.Start)
				{
					val2.y = Mathf.SmoothStep(val2.y, height, SmoothenFilter(rail2, l));
				}
				else
				{
					val2.y = height;
				}
				points2[l] = val2;
			}
			path2.RecalculateTangents();
		}
	}
}


using System.Linq;

public class GenerateRailTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture();
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRailTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology();
		}
		MarkRailside();
		TerrainMeta.PlacementMap.Reset();
	}

	private void MarkRailside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 1572864, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x100000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverLayout : ProceduralComponent
{
	public const float Width = 8f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 16f;

	public const float OuterFade = 64f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = -0.5f;

	public const float TerrainOffset = -1.5f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_0714: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_076d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_080c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0811: Unknown result type (might be due to invalid IL or missing references)
		//IL_078b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0790: Unknown result type (might be due to invalid IL or missing references)
		//IL_0792: Unknown result type (might be due to invalid IL or missing references)
		//IL_0794: Unknown result type (might be due to invalid IL or missing references)
		//IL_0796: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_045d: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_060f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0611: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_0618: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0626: Unknown result type (might be due to invalid IL or missing references)
		//IL_0628: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		//IL_062f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0633: Unknown result type (might be due to invalid IL or missing references)
		//IL_063d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0642: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Rivers.Clear();
			TerrainMeta.Path.Rivers.AddRange(World.GetPaths("River"));
		}
		else
		{
			if (!World.Config.Rivers)
			{
				return;
			}
			List<PathList> list = new List<PathList>();
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
			TerrainBiomeMap biomeMap = TerrainMeta.BiomeMap;
			List<Vector3> list2 = new List<Vector3>();
			int num = 3;
			if (World.Size <= 4000)
			{
				num = 2;
			}
			Vector3[] array = (Vector3[])(object)new Vector3[4]
			{
				new Vector3(-1f, 0f, -1f),
				new Vector3(-1f, 0f, 1f),
				new Vector3(1f, 0f, -1f),
				new Vector3(1f, 0f, 1f)
			};
			Vector3 val2 = default(Vector3);
			Line val6 = default(Line);
			Vector3 val8 = default(Vector3);
			for (float num2 = TerrainMeta.Center.z + 250f; num2 < TerrainMeta.Max.z - 750f; num2 += 5f)
			{
				for (float num3 = TerrainMeta.Center.x + 250f; num3 < TerrainMeta.Max.x - 750f; num3 += 5f)
				{
					Vector3[] array2 = array;
					foreach (Vector3 val in array2)
					{
						((Vector3)(ref val2))..ctor(val.x * num3, 0f, val.z * num2);
						float num4 = (val2.y = heightMap.GetHeight(val2));
						if (val2.y <= 15f)
						{
							continue;
						}
						Vector3 normal = heightMap.GetNormal(val2);
						if (normal.y <= 0.01f || normal.y >= 0.99f)
						{
							continue;
						}
						bool flag = false;
						foreach (PathList item in list)
						{
							Vector3[] points = item.Path.Points;
							foreach (Vector3 val3 in points)
							{
								if (Vector3Ex.SqrMagnitude2D(val2 - val3) < 67600f)
								{
									flag = true;
									break;
								}
							}
							if (flag)
							{
								break;
							}
						}
						if (flag)
						{
							continue;
						}
						Vector2 val4 = Vector3Ex.XZ2D(normal);
						Vector2 normalized = ((Vector2)(ref val4)).normalized;
						float num5 = Vector3.Angle(Vector3.up, normal);
						list2.Add(val2);
						float baseRadius = 4f;
						int num6 = 0;
						for (int k = 0; k < 5000; k++)
						{
							int num7 = k * 4;
							Vector2 val5 = Vector2Ex.Rotate(normalized, Mathf.Sin((float)num7 * (MathF.PI / 180f) * 0.5f) * Mathf.InverseLerp(30f, 10f, num5) * 60f);
							val2.x += val5.x * 4f;
							val2.z += val5.y * 4f;
							bool flag2 = false;
							for (int l = 0; l < list2.Count - 10; l++)
							{
								((Line)(ref val6))..ctor(list2[l], list2[l + 1]);
								Vector3 val7 = ((Line)(ref val6)).ClosestPoint(val2);
								if (Vector3Ex.SqrMagnitude2D(val2 - val7) < 16900f)
								{
									flag2 = true;
									break;
								}
							}
							if (flag2)
							{
								break;
							}
							float height = heightMap.GetHeight(val2);
							if (height > num4 + 32f)
							{
								break;
							}
							float num8 = Mathf.Min(height, num4);
							float num9 = Mathf.Lerp(0.15f, 0.95f, Mathf.InverseLerp(10f, 0f, num8));
							val2.y = Mathf.Lerp(val2.y, num8, num9);
							float radius = PathList.GetRadius(num7, 0f, baseRadius, 0.75f, scaleWidthWithLength: true);
							float radius2 = PathList.GetRadius(num7, num7, baseRadius, 0.75f, scaleWidthWithLength: true);
							int num10 = Mathf.RoundToInt(radius2 / 4f);
							((Vector3)(ref val8))..ctor(val5.x, 0f, val5.y);
							Vector3 val9 = val8 * (radius * 1.5f);
							Vector3 val10 = val8 * (radius2 + 1f + 64f);
							Vector3 val11 = rot90 * val8;
							Vector3 val12 = val11 * (radius * 1.5f);
							Vector3 val13 = val11 * (radius2 + 1f + 64f);
							int topology = topologyMap.GetTopology(val2, radius + 1f + 64f);
							int num11 = topologyMap.GetTopology(val2) & topologyMap.GetTopology(val2 - val9) & topologyMap.GetTopology(val2 + val9) & topologyMap.GetTopology(val2 + val10) & topologyMap.GetTopology(val2 - val12) & topologyMap.GetTopology(val2 - val13) & topologyMap.GetTopology(val2 + val12) & topologyMap.GetTopology(val2 + val13);
							int topology2 = topologyMap.GetTopology(val2);
							int num12 = 3742724;
							int num13 = 128;
							int num14 = 128;
							if ((topology & num12) != 0)
							{
								break;
							}
							if ((num11 & num13) != 0)
							{
								list2.Add(val2);
								if (list2.Count >= 62)
								{
									PathList pathList = new PathList("River " + (TerrainMeta.Path.Rivers.Count + list.Count), list2.ToArray());
									pathList.Spline = true;
									pathList.Width = 8f;
									pathList.InnerPadding = 1f;
									pathList.OuterPadding = 1f;
									pathList.InnerFade = 16f;
									pathList.OuterFade = 64f;
									pathList.RandomScale = 0.75f;
									pathList.MeshOffset = -0.5f;
									pathList.TerrainOffset = -1.5f;
									pathList.Topology = 16384;
									pathList.Splat = 128;
									pathList.Start = true;
									pathList.End = true;
									list.Add(pathList);
								}
								break;
							}
							if ((topology2 & num14) != 0 || val2.y < 0f)
							{
								if (num6++ >= num10)
								{
									break;
								}
							}
							else if (num6 > 0)
							{
								break;
							}
							if (k % 4 == 0)
							{
								list2.Add(val2);
							}
							normal = heightMap.GetNormal(val2);
							num5 = Vector3.Angle(Vector3.up, normal);
							Vector2 val14 = normalized;
							val4 = Vector3Ex.XZ2D(normal);
							val4 = Vector2.Lerp(val14, ((Vector2)(ref val4)).normalized, 0.025f);
							normalized = ((Vector2)(ref val4)).normalized;
							num4 = num8;
						}
						list2.Clear();
					}
				}
			}
			list.Sort((PathList a, PathList b) => b.Path.Points.Length.CompareTo(a.Path.Points.Length));
			int num15 = (int)(World.Size / 16);
			bool[,] array3 = new bool[num15, num15];
			int num16 = 0;
			for (int m = 0; m < list.Count; m++)
			{
				PathList pathList2 = list[m];
				bool flag3 = biomeMap.GetBiomeMaxType(pathList2.Path.GetEndPoint()) == 16;
				if (num16 >= num && !flag3)
				{
					list.RemoveAt(m--);
					continue;
				}
				bool flag4 = false;
				for (int n = 0; n < m; n++)
				{
					PathList pathList3 = list[n];
					Vector3[] array2 = pathList2.Path.Points;
					foreach (Vector3 val15 in array2)
					{
						Vector3[] points = pathList3.Path.Points;
						foreach (Vector3 val16 in points)
						{
							Vector3 val17 = val15 - val16;
							if (((Vector3)(ref val17)).sqrMagnitude < 67600f)
							{
								list.RemoveAt(m--);
								flag4 = true;
							}
							if (flag4)
							{
								break;
							}
						}
						if (flag4)
						{
							break;
						}
					}
					if (flag4)
					{
						break;
					}
				}
				if (flag4)
				{
					continue;
				}
				for (int num17 = 0; num17 < pathList2.Path.Points.Length; num17++)
				{
					Vector3 val18 = pathList2.Path.Points[num17];
					int num18 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(val18.x) * (float)num15), 0, num15 - 1);
					int num19 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(val18.z) * (float)num15), 0, num15 - 1);
					if (array3[num19, num18])
					{
						list.RemoveAt(m--);
						flag4 = true;
						break;
					}
				}
				if (flag4)
				{
					continue;
				}
				int num20 = -1;
				int num21 = -1;
				for (int num22 = 0; num22 < pathList2.Path.Points.Length; num22++)
				{
					Vector3 val19 = pathList2.Path.Points[num22];
					int num23 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(val19.x) * (float)num15), 0, num15 - 1);
					int num24 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(val19.z) * (float)num15), 0, num15 - 1);
					if (num20 != -1)
					{
						array3[num24, num20] = true;
					}
					if (num21 != -1)
					{
						array3[num21, num23] = true;
					}
					array3[num24, num23] = true;
					num20 = num23;
					num21 = num24;
				}
				if (!flag3)
				{
					num16++;
				}
			}
			for (int num25 = 0; num25 < list.Count; num25++)
			{
				list[num25].Name = "River " + (TerrainMeta.Path.Rivers.Count + num25);
			}
			foreach (PathList item2 in list)
			{
				item2.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
				item2.Path.Smoothen(8, new Vector3(0f, 1f, 0f));
				item2.Path.Resample(7.5f);
				item2.Path.RecalculateTangents();
			}
			TerrainMeta.Path.Rivers.AddRange(list);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0.1f;

	public const bool SnapToTerrain = false;

	public Mesh RiverMesh;

	public Mesh RiverInteriorMesh;

	public Mesh RiverInteriorFrontCapMesh;

	public Mesh RiverInteriorBackCapMesh;

	public Mesh[] RiverMeshes;

	public Material RiverMaterial;

	public PhysicMaterial RiverPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		RiverMeshes = (Mesh[])(object)new Mesh[1] { RiverMesh };
		foreach (PathList river in TerrainMeta.Path.Rivers)
		{
			GameObject val = new GameObject(river.Name);
			List<PathList.MeshObject> list = river.CreateMesh(RiverMeshes, 0.1f, snapToTerrain: false, !river.Path.Circular, !river.Path.Circular, scaleWidthWithLength: true, topAligned: false, 4);
			for (int i = 0; i < list.Count; i++)
			{
				PathList.MeshObject meshObject = list[i];
				GameObject val2 = new GameObject("River Mesh");
				val2.transform.position = meshObject.Position;
				val2.tag = "River";
				val2.layer = 4;
				val2.transform.SetParent(val.transform, true);
				val2.SetActive(false);
				MeshCollider obj = val2.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RiverPhysicMaterial;
				obj.sharedMesh = meshObject.Meshes[0];
				val2.AddComponent<RiverInfo>();
				WaterBody waterBody = val2.AddComponent<WaterBody>();
				waterBody.Type = WaterBodyType.River;
				waterBody.FishingType = WaterBody.FishingTag.River;
				val2.AddComponent<AddToWaterMap>();
				val2.SetActive(true);
			}
		}
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRiverTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 1;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 8;

	public const int SmoothenXZ = 4;

	public override void Process(uint seed)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		for (int i = 0; i < 1; i++)
		{
			foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
			{
				if (!World.Networked)
				{
					PathInterpolator path = item.Path;
					path.Smoothen(8, Vector3.up);
					path.RecalculateTangents();
				}
			}
			foreach (PathList item2 in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fade = Mathf.InverseLerp(1f, 0f, (float)i);
				item2.AdjustTerrainHeight(intensity, fade, scaleWidthWithLength: true);
				heightMap.Pop();
			}
		}
	}
}


using System.Linq;

public class GenerateRiverTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture(scaleWidthWithLength: true);
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRiverTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology(scaleWidthWithLength: true);
		}
		MarkRiverside();
	}

	public void MarkRiverside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 49152, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x8000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRoadLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public InfrastructureType RoadType;

	public const float RoadWidth = 10f;

	public const float TrailWidth = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 100000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		PathList pathList = new PathList("Road " + number, points);
		if (RoadType == InfrastructureType.Road)
		{
			pathList.Spline = true;
			pathList.Width = 10f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 128;
			pathList.Hierarchy = 1;
		}
		else
		{
			float num = 0.4f;
			pathList.Spline = true;
			pathList.Width = 4f;
			pathList.InnerPadding = 1f * num;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 1;
			pathList.Hierarchy = 2;
		}
		return pathList;
	}

	public override void Process(uint seed)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0833: Unknown result type (might be due to invalid IL or missing references)
		//IL_0778: Unknown result type (might be due to invalid IL or missing references)
		//IL_0795: Unknown result type (might be due to invalid IL or missing references)
		//IL_0909: Unknown result type (might be due to invalid IL or missing references)
		//IL_092b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Roads.Clear();
			TerrainMeta.Path.Roads.AddRange(World.GetPaths("Road"));
			TerrainMeta.Path.AddRoad(TerrainMeta.Path.Roads, addToMaster: false);
			{
				foreach (PathList road in TerrainMeta.Path.Roads)
				{
					Vector3[] points = road.Path.Points;
					for (int i = 1; i < points.Length - 1; i++)
					{
						Vector3 val = points[i];
						val.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(val), 1f);
						points[i] = val;
					}
					road.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
					road.Path.RecalculateTangents();
				}
				return;
			}
		}
		if ((RoadType == InfrastructureType.Road && !World.Config.SideRoads) || (RoadType == InfrastructureType.Trail && !World.Config.Trails))
		{
			return;
		}
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRoadCostmap(ref seed, RoadType == InfrastructureType.Trail);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		List<PathSegment> list2 = new List<PathSegment>();
		List<PathNode> list3 = new List<PathNode>();
		List<PathNode> list4 = new List<PathNode>();
		List<PathNode> list5 = new List<PathNode>();
		List<PathFinder.Point> list6 = new List<PathFinder.Point>();
		List<PathFinder.Point> list7 = new List<PathFinder.Point>();
		List<PathFinder.Point> list8 = new List<PathFinder.Point>();
		foreach (PathList road2 in TerrainMeta.Path.Roads)
		{
			if (road2.ProcgenStartNode == null || road2.ProcgenEndNode == null)
			{
				continue;
			}
			int num = 1;
			for (PathFinder.Node node = road2.ProcgenStartNode; node != null; node = node.next)
			{
				if (num % 8 == 0)
				{
					list6.Add(node.point);
				}
				num++;
			}
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.Type == MonumentType.Roadside)
			{
				continue;
			}
			TerrainPathConnect[] componentsInChildren = ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true);
			foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
			{
				if (terrainPathConnect.Type == RoadType)
				{
					PathFinder.Point pathFinderPoint = terrainPathConnect.GetPathFinderPoint(length);
					PathFinder.Node node2 = pathFinder.FindClosestWalkable(pathFinderPoint, 100000);
					if (node2 != null)
					{
						PathNode pathNode = new PathNode();
						pathNode.monument = monument;
						pathNode.target = terrainPathConnect;
						pathNode.node = node2;
						list4.Add(pathNode);
					}
				}
			}
		}
		while (list4.Count != 0 || list5.Count != 0)
		{
			if (list4.Count == 0)
			{
				PathNode node3 = list5[0];
				list4.AddRange(list5.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument));
				list5.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument);
				pathFinder.PushPoint = node3.monument.GetPathFinderPoint(length);
				pathFinder.PushRadius = (pathFinder.PushDistance = node3.monument.GetPathFinderRadius(length));
				pathFinder.PushMultiplier = 50000;
			}
			list8.Clear();
			list8.AddRange(list4.Select((PathNode x) => x.node.point));
			list7.Clear();
			list7.AddRange(list3.Select((PathNode x) => x.node.point));
			list7.AddRange(list5.Select((PathNode x) => x.node.point));
			list7.AddRange(list6);
			PathFinder.Node node4 = pathFinder.FindPathUndirected(list7, list8, 100000);
			if (node4 == null)
			{
				PathNode node5 = list4[0];
				list5.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument));
				list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument);
				list5.Remove(node5);
				list3.Add(node5);
				continue;
			}
			PathSegment segment = new PathSegment();
			for (PathFinder.Node node6 = node4; node6 != null; node6 = node6.next)
			{
				if (node6 == node4)
				{
					segment.start = node6;
				}
				if (node6.next == null)
				{
					segment.end = node6;
				}
			}
			list2.Add(segment);
			PathNode node7 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			list5.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node7.monument));
			list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node7.monument);
			list5.Remove(node7);
			list3.Add(node7);
			PathNode pathNode2 = list5.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			if (pathNode2 != null)
			{
				list5.Remove(pathNode2);
				list3.Add(pathNode2);
			}
			int num2 = 1;
			for (PathFinder.Node node8 = node4; node8 != null; node8 = node8.next)
			{
				if (num2 % 8 == 0)
				{
					list6.Add(node8.point);
				}
				num2++;
			}
		}
		foreach (PathNode target in list3)
		{
			PathSegment pathSegment = list2.Find((PathSegment x) => x.start.point == target.node.point || x.end.point == target.node.point);
			if (pathSegment != null)
			{
				if (pathSegment.start.point == target.node.point)
				{
					PathFinder.Node node9 = target.node;
					PathFinder.Node start = pathFinder.Reverse(target.node);
					node9.next = pathSegment.start;
					pathSegment.start = start;
					pathSegment.origin = target.target;
				}
				else if (pathSegment.end.point == target.node.point)
				{
					pathSegment.end.next = target.node;
					pathSegment.end = pathFinder.FindEnd(target.node);
					pathSegment.target = target.target;
				}
			}
		}
		List<Vector3> list9 = new List<Vector3>();
		foreach (PathSegment item in list2)
		{
			bool start2 = false;
			bool end = false;
			for (PathFinder.Node node10 = item.start; node10 != null; node10 = node10.next)
			{
				float normX = ((float)node10.point.x + 0.5f) / (float)length;
				float normZ = ((float)node10.point.y + 0.5f) / (float)length;
				if (item.start == node10 && (Object)(object)item.origin != (Object)null)
				{
					start2 = true;
					normX = TerrainMeta.NormalizeX(((Component)item.origin).transform.position.x);
					normZ = TerrainMeta.NormalizeZ(((Component)item.origin).transform.position.z);
				}
				else if (item.end == node10 && (Object)(object)item.target != (Object)null)
				{
					end = true;
					normX = TerrainMeta.NormalizeX(((Component)item.target).transform.position.x);
					normZ = TerrainMeta.NormalizeZ(((Component)item.target).transform.position.z);
				}
				float num3 = TerrainMeta.DenormalizeX(normX);
				float num4 = TerrainMeta.DenormalizeZ(normZ);
				float num5 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
				list9.Add(new Vector3(num3, num5, num4));
			}
			if (list9.Count != 0)
			{
				if (list9.Count >= 2)
				{
					int number = TerrainMeta.Path.Roads.Count + list.Count;
					PathList pathList = CreateSegment(number, list9.ToArray());
					pathList.Start = start2;
					pathList.End = end;
					pathList.ProcgenStartNode = item.start;
					pathList.ProcgenEndNode = item.end;
					list.Add(pathList);
				}
				list9.Clear();
			}
		}
		foreach (PathList item2 in list)
		{
			item2.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
			item2.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
			item2.Path.Resample(7.5f);
			item2.Path.RecalculateTangents();
			item2.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.AddRoad(list);
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public TerrainPathConnect target;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;

	public TerrainPathConnect origin;

	public TerrainPathConnect target;
}


using UnityEngine;

public class GenerateRoadMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0f;

	public const bool SnapToTerrain = true;

	public Mesh RoadMesh;

	public Mesh[] RoadMeshes;

	public Material RoadMaterial;

	public Material RoadRingMaterial;

	public PhysicMaterial RoadPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected O, but got Unknown
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Expected O, but got Unknown
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		if (RoadMeshes == null || RoadMeshes.Length == 0)
		{
			RoadMeshes = (Mesh[])(object)new Mesh[1] { RoadMesh };
		}
		foreach (PathList road in TerrainMeta.Path.Roads)
		{
			if (road.Hierarchy >= 2)
			{
				continue;
			}
			GameObject val = new GameObject(road.Name);
			foreach (PathList.MeshObject item in road.CreateMesh(RoadMeshes, 0f, snapToTerrain: true, !road.Path.Circular, !road.Path.Circular))
			{
				GameObject val2 = new GameObject("Road Mesh");
				val2.transform.position = item.Position;
				val2.layer = 16;
				val2.tag = "IgnoreCollider";
				val2.transform.SetParent(val.transform, true);
				val2.SetActive(false);
				MeshCollider obj = val2.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RoadPhysicMaterial;
				obj.sharedMesh = item.Meshes[0];
				TagComponentEx.SetCustomTag(val2, GameObjectTag.Road, apply: true);
				val2.AddComponent<AddToHeightMap>();
				val2.SetActive(true);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRoadRing : ProceduralComponent
{
	private class RingNode
	{
		public int attempts;

		public PathFinder.Point position;

		public PathFinder.Point direction;

		public RingNode next;

		public RingNode prev;

		public PathFinder.Node path;

		public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
		{
			position = new PathFinder.Point(pos_x, pos_y);
			direction = new PathFinder.Point(dir_x, dir_y);
			attempts = stepcount;
		}
	}

	public const float Width = 12f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 250000;

	public int MinWorldSize;

	public override void Process(uint seed)
	{
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0771: Unknown result type (might be due to invalid IL or missing references)
		//IL_087e: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a1: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked || World.Size < MinWorldSize || !World.Config.MainRoads)
		{
			return;
		}
		int[,] array = TerrainPath.CreateRoadCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		int num = length / 4;
		int num2 = 1;
		int stepcount = num / num2;
		int num3 = length / 2;
		int pos_x = num;
		int pos_x2 = length - num;
		int pos_y = num;
		int pos_y2 = length - num;
		int num4 = 0;
		int dir_x = -num2;
		int dir_x2 = num2;
		int dir_y = -num2;
		int dir_y2 = num2;
		List<RingNode> list = ((World.Size >= 5000) ? new List<RingNode>
		{
			new RingNode(num3, pos_y2, num4, dir_y, stepcount),
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, num3, dir_x, num4, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(num3, pos_y, num4, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, num3, dir_x2, num4, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		} : new List<RingNode>
		{
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		});
		for (int i = 0; i < list.Count; i++)
		{
			RingNode ringNode = list[i];
			RingNode next = list[(i + 1) % list.Count];
			RingNode prev = list[(i - 1 + list.Count) % list.Count];
			ringNode.next = next;
			ringNode.prev = prev;
			while (!pathFinder.IsWalkable(ringNode.position))
			{
				if (ringNode.attempts <= 0)
				{
					return;
				}
				ringNode.position += ringNode.direction;
				ringNode.attempts--;
			}
		}
		foreach (RingNode item in list)
		{
			item.path = pathFinder.FindPath(item.position, item.next.position, 250000);
		}
		bool flag = false;
		while (!flag)
		{
			flag = true;
			PathFinder.Point point = new PathFinder.Point(0, 0);
			foreach (RingNode item2 in list)
			{
				point += item2.position;
			}
			point /= list.Count;
			float num5 = float.MinValue;
			RingNode ringNode2 = null;
			foreach (RingNode item3 in list)
			{
				if (item3.path == null)
				{
					Vector2 val = new Vector2((float)(item3.position.x - point.x), (float)(item3.position.y - point.y));
					float num6 = ((Vector2)(ref val)).magnitude;
					if (item3.prev.path == null)
					{
						num6 *= 1.5f;
					}
					if (num6 > num5)
					{
						num5 = num6;
						ringNode2 = item3;
					}
				}
			}
			if (ringNode2 == null)
			{
				continue;
			}
			do
			{
				if (ringNode2.attempts <= 0)
				{
					return;
				}
				ringNode2.position += ringNode2.direction;
				ringNode2.attempts--;
			}
			while (!pathFinder.IsWalkable(ringNode2.position));
			ringNode2.path = pathFinder.FindPath(ringNode2.position, ringNode2.next.position, 250000);
			ringNode2.prev.path = pathFinder.FindPath(ringNode2.prev.position, ringNode2.position, 250000);
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		for (int j = 0; j < list.Count; j++)
		{
			RingNode ringNode3 = list[j];
			RingNode ringNode4 = list[(j + 1) % list.Count];
			PathFinder.Node node = null;
			PathFinder.Node node2 = null;
			for (PathFinder.Node node3 = ringNode3.path; node3 != null; node3 = node3.next)
			{
				for (PathFinder.Node node4 = ringNode4.path; node4 != null; node4 = node4.next)
				{
					int num7 = Mathf.Abs(node3.point.x - node4.point.x);
					int num8 = Mathf.Abs(node3.point.y - node4.point.y);
					if (num7 <= 15 && num8 <= 15)
					{
						if (node == null || node3.cost > node.cost)
						{
							node = node3;
						}
						if (node2 == null || node4.cost < node2.cost)
						{
							node2 = node4;
						}
					}
				}
			}
			if (node != null && node2 != null)
			{
				PathFinder.Node node5 = pathFinder.FindPath(node.point, node2.point, 250000);
				if (node5 != null && node5.next != null)
				{
					node.next = node5.next;
					ringNode4.path = node2;
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			RingNode ringNode5 = list[k];
			RingNode ringNode6 = list[(k + 1) % list.Count];
			PathFinder.Node node6 = null;
			PathFinder.Node node7 = null;
			for (PathFinder.Node node8 = ringNode5.path; node8 != null; node8 = node8.next)
			{
				for (PathFinder.Node node9 = ringNode6.path; node9 != null; node9 = node9.next)
				{
					int num9 = Mathf.Abs(node8.point.x - node9.point.x);
					int num10 = Mathf.Abs(node8.point.y - node9.point.y);
					if (num9 <= 1 && num10 <= 1)
					{
						if (node6 == null || node8.cost > node6.cost)
						{
							node6 = node8;
						}
						if (node7 == null || node9.cost < node7.cost)
						{
							node7 = node9;
						}
					}
				}
			}
			if (node6 != null && node7 != null)
			{
				node6.next = null;
				ringNode6.path = node7;
			}
		}
		PathFinder.Node node10 = null;
		PathFinder.Node node11 = null;
		foreach (RingNode item4 in list)
		{
			if (node10 == null)
			{
				node10 = item4.path;
				node11 = item4.path;
			}
			else
			{
				node11.next = item4.path;
			}
			while (node11.next != null)
			{
				node11 = node11.next;
			}
		}
		node11.next = new PathFinder.Node(node10.point, node10.cost, node10.heuristic);
		List<Vector3> list2 = new List<Vector3>();
		for (PathFinder.Node node12 = node10; node12 != null; node12 = node12.next)
		{
			float normX = ((float)node12.point.x + 0.5f) / (float)length;
			float normZ = ((float)node12.point.y + 0.5f) / (float)length;
			float num11 = TerrainMeta.DenormalizeX(normX);
			float num12 = TerrainMeta.DenormalizeZ(normZ);
			float num13 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
			list2.Add(new Vector3(num11, num13, num12));
		}
		if (list2.Count >= 2)
		{
			PathList pathList = new PathList("Road " + TerrainMeta.Path.Roads.Count, list2.ToArray());
			pathList.Spline = true;
			pathList.Width = 12f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 128;
			pathList.Start = false;
			pathList.End = false;
			pathList.ProcgenStartNode = node10;
			pathList.ProcgenEndNode = node11;
			pathList.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
			pathList.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
			pathList.Path.Resample(7.5f);
			pathList.Path.RecalculateTangents();
			pathList.AdjustPlacementMap(24f);
			TerrainMeta.Path.AddRoad(pathList);
		}
	}
}


private class RingNode
{
	public int attempts;

	public PathFinder.Point position;

	public PathFinder.Point direction;

	public RingNode next;

	public RingNode prev;

	public PathFinder.Node path;

	public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
	{
		position = new PathFinder.Point(pos_x, pos_y);
		direction = new PathFinder.Point(dir_x, dir_y);
		attempts = stepcount;
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRoadTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 2;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 16;

	public const int SmoothenXZ = 4;

	private float SmoothenFilter(PathList path, int index)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		int topology = TerrainMeta.TopologyMap.GetTopology(path.Path.Points[index]);
		if ((topology & 0x80400) != 0)
		{
			return 0f;
		}
		if ((topology & 0x100000) != 0)
		{
			return 0.5f;
		}
		if ((topology & 0x4000) != 0)
		{
			return 0.1f;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.3f;
		}
		return 1f;
	}

	public override void Process(uint seed)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		for (int j = 0; j < 2; j++)
		{
			foreach (PathList road in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
			{
				PathInterpolator path = road.Path;
				Vector3[] points = path.Points;
				for (int k = 0; k < points.Length; k++)
				{
					Vector3 val = points[k];
					float num = heightMap.GetHeight(val);
					if ((topologyMap.GetTopology(val) & 0xC000) != 0)
					{
						num = Mathf.Max(num, WaterLevel.RaycastWaterColliders(val) + 2f);
					}
					val.y = num;
					points[k] = val;
				}
				path.Smoothen(8, Vector3.up, (int i) => SmoothenFilter(road, i));
				path.RecalculateTangents();
			}
			foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fade = Mathf.InverseLerp(2f, 0f, (float)j);
				item.AdjustTerrainHeight(intensity, fade);
				heightMap.Pop();
			}
			foreach (PathList item2 in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity2 = 1f;
				float num2 = Mathf.InverseLerp(2f, 0f, (float)j);
				item2.AdjustTerrainHeight(intensity2, num2 / 4f);
				heightMap.Pop();
			}
		}
		foreach (PathList road2 in TerrainMeta.Path.Roads)
		{
			PathInterpolator path2 = road2.Path;
			Vector3[] points2 = path2.Points;
			for (int l = 0; l < points2.Length; l++)
			{
				Vector3 val2 = points2[l];
				val2.y = heightMap.GetHeight(val2);
				points2[l] = val2;
			}
			path2.RecalculateTangents();
		}
	}
}


using System.Linq;

public class GenerateRoadTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture();
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRoadTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology();
		}
		MarkRoadside();
		TerrainMeta.PlacementMap.Reset();
	}

	private void MarkRoadside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 6144, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x1000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateSplat : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_splat")]
	public unsafe static extern void Native_GenerateSplat(byte* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float biomeAngle, short* heightmap, int heightres, byte* biomemap, int biomeres, int* topologymap, int topologyres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		byte* unsafePtr = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.SplatMap.dst);
		int res = TerrainMeta.SplatMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		byte* unsafePtr3 = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.src);
		int res3 = TerrainMeta.BiomeMap.res;
		int* unsafePtr4 = (int*)NativeArrayUnsafeUtility.GetUnsafePtr<int>(TerrainMeta.TopologyMap.src);
		int res4 = TerrainMeta.TopologyMap.res;
		Native_GenerateSplat(unsafePtr, res, position, size, seed, lootAxisAngle, biomeAxisAngle, unsafePtr2, res2, unsafePtr3, res3, unsafePtr4, res4);
	}
}


public class GenerateTerrainMesh : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		if (!World.Cached)
		{
			World.AddMap("terrain", TerrainMeta.HeightMap.ToByteArray());
		}
		TerrainMeta.HeightMap.ApplyToTerrain();
	}
}


public class GenerateTextures : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		if (!World.Cached)
		{
			World.AddMap("height", TerrainMeta.HeightMap.ToByteArray());
			World.AddMap("splat", TerrainMeta.SplatMap.ToByteArray());
			World.AddMap("biome", TerrainMeta.BiomeMap.ToByteArray());
			World.AddMap("topology", TerrainMeta.TopologyMap.ToByteArray());
			World.AddMap("alpha", TerrainMeta.AlphaMap.ToByteArray());
			World.AddMap("water", TerrainMeta.WaterMap.ToByteArray());
		}
		else
		{
			TerrainMeta.HeightMap.FromByteArray(World.GetMap("height"));
		}
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateTopology : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_topology")]
	public unsafe static extern void Native_GenerateTopology(int* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, short* heightmap, int heightres, byte* biomemap, int biomeres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		int* unsafePtr = (int*)NativeArrayUnsafeUtility.GetUnsafePtr<int>(TerrainMeta.TopologyMap.dst);
		int res = TerrainMeta.TopologyMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		byte* unsafePtr3 = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.src);
		int res3 = TerrainMeta.BiomeMap.res;
		Native_GenerateTopology(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic, unsafePtr2, res2, unsafePtr3, res3);
	}
}


public class GenerateWireMeshes : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		TerrainMeta.Path.CreateWires();
	}
}


using System;

public class PlaceCliffParameters : PrefabAttribute
{
	public int CutoffSlopeInitial = 10;

	public int CutoffSlopeRepeat = 10;

	public int MinTerrainHeight;

	public int MaxTerrainHeight = 500;

	public int MinCliffHeight;

	public int MaxCliffHeight = 500;

	public float MinCliffScale = 1f;

	public float MaxCliffScale = 2f;

	protected override Type GetIndexedType()
	{
		return typeof(PlaceCliffParameters);
	}
}


using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceCliffs : ProceduralComponent
{
	private class CliffPlacement
	{
		public int count;

		public int score;

		public Prefab prefab;

		public Vector3 pos = Vector3.zero;

		public Quaternion rot = Quaternion.identity;

		public Vector3 scale = Vector3.one;

		public CliffPlacement next;
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int RetryMultiplier = 1;

	[FormerlySerializedAs("CutoffSlope")]
	public int CutoffSlopeInitial = 10;

	public int CutoffSlopeRepeat = 10;

	[FormerlySerializedAs("MinHeight")]
	public int MinTerrainHeight;

	[FormerlySerializedAs("MaxHeight")]
	public int MaxTerrainHeight = 500;

	public int MinCliffHeight;

	public int MaxCliffHeight = 500;

	[FormerlySerializedAs("MinScale")]
	public float MinCliffScale = 1f;

	[FormerlySerializedAs("MaxScale")]
	public float MaxCliffScale = 2f;

	public int TargetCount = 8;

	public int TargetLength;

	public TerrainAnchorMode AnchorModeInitial = TerrainAnchorMode.MaximizeHeight;

	public TerrainAnchorMode AnchorModeRepeat = TerrainAnchorMode.MinimizeMovement;

	[InspectorFlags]
	public SpawnFilterMode FilterModeInitial = SpawnFilterMode.PivotPoint;

	[InspectorFlags]
	public SpawnFilterMode FilterModeRepeat = SpawnFilterMode.PivotPoint;

	private static float min_scale_delta = 0.1f;

	private static int max_scale_attempts = 10;

	private static int min_rotation = rotation_delta;

	private static int max_rotation = 60;

	private static int rotation_delta = 10;

	private static float offset_c = 0f;

	private static float offset_l = -0.75f;

	private static float offset_r = 0.75f;

	private static Vector3[] offsets = (Vector3[])(object)new Vector3[5]
	{
		new Vector3(offset_c, offset_c, offset_c),
		new Vector3(offset_l, offset_c, offset_c),
		new Vector3(offset_r, offset_c, offset_c),
		new Vector3(offset_c, offset_c, offset_l),
		new Vector3(offset_c, offset_c, offset_r)
	};

	public override void Process(uint seed)
	{
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Prefab[] array2 = array.Where((Prefab prefab) => (bool)prefab.Attribute.Find<DecorSocketMale>(prefab.ID) && (bool)prefab.Attribute.Find<DecorSocketFemale>(prefab.ID)).ToArray();
		if (array2 == null || array2.Length == 0)
		{
			return;
		}
		Prefab[] array3 = array.Where((Prefab prefab) => prefab.Attribute.Find<DecorSocketMale>(prefab.ID)).ToArray();
		if (array3 == null || array3.Length == 0)
		{
			return;
		}
		Prefab[] array4 = array.Where((Prefab prefab) => prefab.Attribute.Find<DecorSocketFemale>(prefab.ID)).ToArray();
		if (array4 == null || array4.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		int num3 = Mathf.RoundToInt(size.x * size.z * 0.001f * (float)RetryMultiplier);
		Vector3 val = default(Vector3);
		for (int i = 0; i < num3; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num);
			float num5 = SeedRandom.Range(ref seed, z, num2);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			Prefab random = array2.GetRandom(ref seed);
			PlaceCliffParameters placeCliffParameters = random.Attribute.Find<PlaceCliffParameters>(random.ID);
			int num7 = (placeCliffParameters ? placeCliffParameters.CutoffSlopeInitial : CutoffSlopeInitial);
			int num8 = (placeCliffParameters ? placeCliffParameters.MinTerrainHeight : MinTerrainHeight);
			int num9 = (placeCliffParameters ? placeCliffParameters.MaxTerrainHeight : MaxTerrainHeight);
			int num10 = (placeCliffParameters ? placeCliffParameters.MinCliffHeight : MinCliffHeight);
			int num11 = (placeCliffParameters ? placeCliffParameters.MaxCliffHeight : MaxCliffHeight);
			float num12 = (placeCliffParameters ? placeCliffParameters.MinCliffScale : MinCliffScale);
			float num13 = (placeCliffParameters ? placeCliffParameters.MaxCliffScale : MaxCliffScale);
			if ((FilterModeInitial & SpawnFilterMode.PivotPoint) != 0)
			{
				float factor = Filter.GetFactor(normX, normZ);
				if (factor * factor < num6)
				{
					continue;
				}
			}
			float height = heightMap.GetHeight(normX, normZ);
			if (height < (float)num8 || height > (float)num9)
			{
				continue;
			}
			Vector3 normal = heightMap.GetNormal(normX, normZ);
			if (Vector3.Angle(Vector3.up, normal) < (float)num7)
			{
				continue;
			}
			((Vector3)(ref val))..ctor(num4, height, num5);
			Quaternion val2 = QuaternionEx.LookRotationForcedUp(normal, Vector3.up);
			float num14 = Mathf.Max((num13 - num12) / (float)max_scale_attempts, min_scale_delta);
			for (float num15 = num13; num15 >= num12; num15 -= num14)
			{
				Vector3 pos = val;
				Quaternion rot = val2 * random.Object.transform.localRotation;
				Vector3 scale = num15 * random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorModeInitial, ((FilterModeInitial & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && !(pos.y < (float)num10) && !(pos.y > (float)num11) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterModeInitial & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					CliffPlacement cliffPlacement = PlaceMale(array3, ref seed, random, pos, rot, scale);
					CliffPlacement cliffPlacement2 = PlaceFemale(array4, ref seed, random, pos, rot, scale);
					World.AddPrefab("Decor", random, pos, rot, scale);
					while (cliffPlacement != null && cliffPlacement.prefab != null)
					{
						World.AddPrefab("Decor", cliffPlacement.prefab, cliffPlacement.pos, cliffPlacement.rot, cliffPlacement.scale);
						cliffPlacement = cliffPlacement.next;
						i++;
					}
					while (cliffPlacement2 != null && cliffPlacement2.prefab != null)
					{
						World.AddPrefab("Decor", cliffPlacement2.prefab, cliffPlacement2.pos, cliffPlacement2.rot, cliffPlacement2.scale);
						cliffPlacement2 = cliffPlacement2.next;
						i++;
					}
					break;
				}
			}
		}
	}

	private CliffPlacement PlaceMale(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Place<DecorSocketFemale, DecorSocketMale>(prefabs, ref seed, parentPrefab, parentPos, parentRot, parentScale);
	}

	private CliffPlacement PlaceFemale(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Place<DecorSocketMale, DecorSocketFemale>(prefabs, ref seed, parentPrefab, parentPos, parentRot, parentScale);
	}

	private CliffPlacement Place<ParentSocketType, ChildSocketType>(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale, int parentAngle = 0, int parentCount = 0, int parentScore = 0) where ParentSocketType : PrefabAttribute where ChildSocketType : PrefabAttribute
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0354: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		CliffPlacement cliffPlacement = null;
		if (parentAngle > 160 || parentAngle < -160)
		{
			return cliffPlacement;
		}
		int num = SeedRandom.Range(ref seed, 0, prefabs.Length);
		ParentSocketType val = parentPrefab.Attribute.Find<ParentSocketType>(parentPrefab.ID);
		Vector3 val2 = parentPos + parentRot * Vector3.Scale(val.worldPosition, parentScale);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		for (int i = 0; i < prefabs.Length; i++)
		{
			Prefab prefab = prefabs[(num + i) % prefabs.Length];
			if (prefab == parentPrefab)
			{
				continue;
			}
			ParentSocketType val3 = prefab.Attribute.Find<ParentSocketType>(prefab.ID);
			ChildSocketType val4 = prefab.Attribute.Find<ChildSocketType>(prefab.ID);
			bool flag = val3 != null;
			if (cliffPlacement != null && cliffPlacement.count > TargetCount && cliffPlacement.score > TargetLength && flag)
			{
				continue;
			}
			PlaceCliffParameters placeCliffParameters = prefab.Attribute.Find<PlaceCliffParameters>(prefab.ID);
			int num2 = (placeCliffParameters ? placeCliffParameters.CutoffSlopeRepeat : CutoffSlopeRepeat);
			int num3 = (placeCliffParameters ? placeCliffParameters.MinTerrainHeight : MinTerrainHeight);
			int num4 = (placeCliffParameters ? placeCliffParameters.MaxTerrainHeight : MaxTerrainHeight);
			int num5 = (placeCliffParameters ? placeCliffParameters.MinCliffHeight : MinCliffHeight);
			int num6 = (placeCliffParameters ? placeCliffParameters.MaxCliffHeight : MaxCliffHeight);
			float num7 = (placeCliffParameters ? placeCliffParameters.MinCliffScale : MinCliffScale);
			float num8 = (placeCliffParameters ? placeCliffParameters.MaxCliffScale : MaxCliffScale);
			float num9 = Mathf.Max((num8 - num7) / (float)max_scale_attempts, min_scale_delta);
			float num10 = num8;
			while (num10 >= num7)
			{
				int j;
				Vector3 scale;
				Quaternion rot;
				Vector3 pos;
				for (j = min_rotation; j <= max_rotation; j += rotation_delta)
				{
					for (int k = -1; k <= 1; k += 2)
					{
						Vector3[] array = offsets;
						foreach (Vector3 val5 in array)
						{
							scale = prefab.Object.transform.localScale * num10;
							rot = Quaternion.Euler(0f, (float)(k * j), 0f) * parentRot;
							pos = val2 - rot * (Vector3.Scale(val4.worldPosition, scale) + val5);
							float normX = TerrainMeta.NormalizeX(pos.x);
							float normZ = TerrainMeta.NormalizeZ(pos.z);
							if ((FilterModeRepeat & SpawnFilterMode.PivotPoint) != 0)
							{
								float factor = Filter.GetFactor(normX, normZ);
								if (factor * factor < 0.5f)
								{
									continue;
								}
							}
							float height = heightMap.GetHeight(normX, normZ);
							if (height < (float)num3 || height > (float)num4)
							{
								continue;
							}
							Vector3 normal = heightMap.GetNormal(normX, normZ);
							if (Vector3.Angle(Vector3.up, normal) < (float)num2)
							{
								continue;
							}
							prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
							if (!prefab.ApplyTerrainAnchors(ref pos, rot, scale, AnchorModeRepeat, ((FilterModeRepeat & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) || pos.y < (float)num5 || pos.y > (float)num6 || !prefab.ApplyTerrainChecks(pos, rot, scale, ((FilterModeRepeat & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) || !prefab.ApplyTerrainFilters(pos, rot, scale) || !prefab.ApplyWaterChecks(pos, rot, scale) || !prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale))
							{
								continue;
							}
							goto IL_0387;
						}
					}
				}
				num10 -= num9;
				continue;
				IL_0387:
				int parentAngle2 = parentAngle + j;
				int num11 = parentCount + 1;
				int num12 = parentScore + Mathf.CeilToInt(Vector3Ex.Distance2D(parentPos, pos));
				CliffPlacement cliffPlacement2 = null;
				if (flag)
				{
					cliffPlacement2 = Place<ParentSocketType, ChildSocketType>(prefabs, ref seed, prefab, pos, rot, scale, parentAngle2, num11, num12);
					if (cliffPlacement2 != null)
					{
						num11 = cliffPlacement2.count;
						num12 = cliffPlacement2.score;
					}
				}
				else
				{
					num12 *= 2;
				}
				if (cliffPlacement == null)
				{
					cliffPlacement = new CliffPlacement();
				}
				if (cliffPlacement.score < num12)
				{
					cliffPlacement.next = cliffPlacement2;
					cliffPlacement.count = num11;
					cliffPlacement.score = num12;
					cliffPlacement.prefab = prefab;
					cliffPlacement.pos = pos;
					cliffPlacement.rot = rot;
					cliffPlacement.scale = scale;
				}
				break;
			}
		}
		return cliffPlacement;
	}
}


using UnityEngine;

private class CliffPlacement
{
	public int count;

	public int score;

	public Prefab prefab;

	public Vector3 pos = Vector3.zero;

	public Quaternion rot = Quaternion.identity;

	public Vector3 scale = Vector3.one;

	public CliffPlacement next;
}


using UnityEngine;

public class PlaceCliffsUniform : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDistance = 10f;

	public float ObjectDithering = 5f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	private static int min_rotation_z = 0;

	private static int max_rotation_z = 12;

	private static int rotation_delta_z = 4;

	private static int min_rotation_x = 0;

	private static int max_rotation_x = 12;

	private static int rotation_delta_x = 2;

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (int num3 = 128; num3 > 0; num3 /= 2)
		{
			float num4 = ObjectDistance * (float)num3;
			for (float num5 = z; num5 < num2; num5 += num4)
			{
				for (float num6 = x; num6 < num; num6 += num4)
				{
					float num7 = num6 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
					float num8 = num5 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
					float normX = TerrainMeta.NormalizeX(num7);
					float normZ = TerrainMeta.NormalizeZ(num8);
					float num9 = SeedRandom.Value(ref seed);
					array.BubbleSort();
					if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
					{
						float factor = Filter.GetFactor(normX, normZ);
						if (factor * factor < num9)
						{
							continue;
						}
					}
					float height = heightMap.GetHeight(normX, normZ);
					Prefab[] array2 = array;
					foreach (Prefab prefab in array2)
					{
						((Vector3)(ref pos))..ctor(num7, height, num8);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						bool flag = false;
						Vector3 val = Vector3.zero;
						Quaternion rotation = Quaternion.identity;
						Vector3 scale2 = Vector3.zero;
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						for (int j = min_rotation_z; j <= max_rotation_z; j += rotation_delta_z)
						{
							for (int k = min_rotation_x; k <= max_rotation_x; k += rotation_delta_x)
							{
								for (int l = -1; l <= 1; l += 2)
								{
									for (int m = -1; m <= 1; m += 2)
									{
										Vector3 pos2 = pos;
										Quaternion val2 = rot * Quaternion.Euler((float)(m * k), 0f, (float)(l * j));
										Vector3 val3 = scale;
										if (prefab.ApplyTerrainFilters(pos2, val2, val3) && prefab.ApplyTerrainAnchors(ref pos2, val2, val3, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && prefab.ApplyTerrainChecks(pos2, val2, val3, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && prefab.ApplyWaterChecks(pos2, val2, val3) && prefab.ApplyEnvironmentVolumeChecks(pos2, val2, val3) && (!flag || val.y < pos2.y))
										{
											flag = true;
											val = pos2;
											rotation = val2;
											scale2 = val3;
										}
									}
								}
							}
						}
						if (flag)
						{
							prefab.SpawnedCount++;
							World.AddPrefab("Decor", prefab, val, rotation, scale2);
							break;
						}
					}
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorUniform : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDistance = 10f;

	public float ObjectDithering = 5f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (float num3 = z; num3 < num2; num3 += ObjectDistance)
		{
			for (float num4 = x; num4 < num; num4 += ObjectDistance)
			{
				float num5 = num4 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
				float num6 = num3 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
				float normX = TerrainMeta.NormalizeX(num5);
				float normZ = TerrainMeta.NormalizeZ(num6);
				float num7 = SeedRandom.Value(ref seed);
				Prefab random = array.GetRandom(ref seed);
				if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
				{
					float factor = Filter.GetFactor(normX, normZ);
					if (factor * factor < num7)
					{
						continue;
					}
				}
				float height = heightMap.GetHeight(normX, normZ);
				((Vector3)(ref pos))..ctor(num5, height, num6);
				Quaternion rot = random.Object.transform.localRotation;
				Vector3 scale = random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					World.AddPrefab("Decor", random, pos, rot, scale);
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorValueNoise : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public NoiseParameters Cluster = new NoiseParameters(2, 0.5f, 1f, 0f);

	public float ObjectDensity = 100f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		int num = Mathf.RoundToInt(ObjectDensity * size.x * size.z * 1E-06f);
		float x = position.x;
		float z = position.z;
		float num2 = position.x + size.x;
		float num3 = position.z + size.z;
		float num4 = SeedRandom.Range(ref seed, -1000000f, 1000000f);
		float num5 = SeedRandom.Range(ref seed, -1000000f, 1000000f);
		int octaves = Cluster.Octaves;
		float offset = Cluster.Offset;
		float frequency = Cluster.Frequency * 0.01f;
		float amplitude = Cluster.Amplitude;
		Vector3 pos = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num6 = SeedRandom.Range(ref seed, x, num2);
			float num7 = SeedRandom.Range(ref seed, z, num3);
			float normX = TerrainMeta.NormalizeX(num6);
			float normZ = TerrainMeta.NormalizeZ(num7);
			float num8 = SeedRandom.Value(ref seed);
			float factor = Filter.GetFactor(normX, normZ);
			Prefab random = array.GetRandom(ref seed);
			if (((FilterMode & SpawnFilterMode.PivotPoint) == 0 || !(factor <= 0f)) && !((offset + Noise.Turbulence(num4 + num6, num5 + num7, octaves, frequency, amplitude)) * factor * factor < num8))
			{
				float height = heightMap.GetHeight(normX, normZ);
				((Vector3)(ref pos))..ctor(num6, height, num7);
				Quaternion rot = random.Object.transform.localRotation;
				Vector3 scale = random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					World.AddPrefab("Decor", random, pos, rot, scale);
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorWhiteNoise : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDensity = 100f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		int num = Mathf.RoundToInt(ObjectDensity * size.x * size.z * 1E-06f);
		float x = position.x;
		float z = position.z;
		float num2 = position.x + size.x;
		float num3 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num2);
			float num5 = SeedRandom.Range(ref seed, z, num3);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			Prefab random = array.GetRandom(ref seed);
			if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
			{
				float factor = Filter.GetFactor(normX, normZ);
				if (factor * factor < num6)
				{
					continue;
				}
			}
			float height = heightMap.GetHeight(normX, normZ);
			((Vector3)(ref pos))..ctor(num4, height, num5);
			Quaternion rot = random.Object.transform.localRotation;
			Vector3 scale = random.Object.transform.localScale;
			random.ApplyDecorComponents(ref pos, ref rot, ref scale);
			if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
			{
				World.AddPrefab("Decor", random, pos, rot, scale);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class PlaceJungleVines : PlaceDecorUniform
{
	public override void Process(uint seed)
	{
		if (!Server.spawnVineTrees)
		{
			Debug.LogWarning((object)"server.spawnVineTrees is disabled, skipping vine spawn...");
		}
		else
		{
			base.Process(seed);
		}
	}
}


using UnityEngine;

public class PlaceMonument : ProceduralComponent
{
	public struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public SpawnFilter Filter;

	public GameObjectRef Monument;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		if (!Monument.isValid)
		{
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		SpawnInfo spawnInfo = default(SpawnInfo);
		int num3 = int.MinValue;
		Prefab<MonumentInfo> prefab = Prefab.Load<MonumentInfo>(Monument.resourceID, (GameManager)null, (PrefabAttribute.Library)null);
		Vector3 pos = default(Vector3);
		for (int i = 0; i < 10000; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num);
			float num5 = SeedRandom.Range(ref seed, z, num2);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			float factor = Filter.GetFactor(normX, normZ);
			if (factor * factor < num6)
			{
				continue;
			}
			float height = heightMap.GetHeight(normX, normZ);
			((Vector3)(ref pos))..ctor(num4, height, num5);
			Quaternion rot = prefab.Object.transform.localRotation;
			Vector3 scale = prefab.Object.transform.localScale;
			prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
			if ((!Object.op_Implicit((Object)(object)prefab.Component) || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyTerrainFilters(pos, rot, scale) && prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) && prefab.ApplyTerrainChecks(pos, rot, scale, Filter) && prefab.ApplyWaterChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
			{
				SpawnInfo spawnInfo2 = default(SpawnInfo);
				spawnInfo2.prefab = prefab;
				spawnInfo2.position = pos;
				spawnInfo2.rotation = rot;
				spawnInfo2.scale = scale;
				int num7 = -Mathf.RoundToInt(Vector3Ex.Magnitude2D(pos));
				if (num7 > num3)
				{
					num3 = num7;
					spawnInfo = spawnInfo2;
				}
			}
		}
		if (num3 != int.MinValue)
		{
			World.AddPrefab("Monument", spawnInfo.prefab, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
		}
	}
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonuments : ProceduralComponent
{
	public struct WorldSizeInfo
	{
		public int WorldSizeMin;

		public int WorldSizeMax;

		public int TargetCount;
	}

	public struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public bool dungeonEntrance;

		public Vector3 dungeonEntrancePos;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;

		public float minDistanceDungeonEntrance;

		public float maxDistanceDungeonEntrance;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public AnimationCurve TargetCountWorldSizeMultiplier = AnimationCurve.Constant(1000f, 6000f, 1f);

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	[Tooltip("Enable to only spawn these monuments when running as a nexus")]
	public bool NexusOnly;

	public const int GroupCandidates = 8;

	public const int IndividualCandidates = 8;

	public const int Attempts = 10000;

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_043f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0603: Unknown result type (might be due to invalid IL or missing references)
		//IL_0605: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_057e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0587: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		if (NexusOnly && !World.Nexus)
		{
			return;
		}
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			PathFinder pathFinder = null;
			List<PathFinder.Point> endList = null;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!text.Contains("underwater_lab") || World.Config.UnderwaterLabs)
				{
					Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(text, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
					array3.Shuffle(ref seed);
					list.AddRange(array3);
				}
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			Vector3 position = TerrainMeta.Position;
			Vector3 size = TerrainMeta.Size;
			float x = position.x;
			float z = position.z;
			float num = position.x + size.x;
			float num2 = position.z + size.z;
			int num3 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num4 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			int num5 = Mathf.RoundToInt((float)TargetCount * TargetCountWorldSizeMultiplier.Evaluate((float)World.Size));
			Vector3 pos = default(Vector3);
			for (int j = 0; j < 8; j++)
			{
				num3 = 0;
				list2.Clear();
				Prefab<MonumentInfo>[] array5 = array4;
				foreach (Prefab<MonumentInfo> prefab in array5)
				{
					MonumentInfo component = prefab.Component;
					if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component.DungeonEntrance;
					int num6 = (int)((!Object.op_Implicit((Object)(object)prefab.Parameters)) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
					int num7 = 100000 * num6 * num6 * num6 * num6;
					int num8 = 0;
					int num9 = 0;
					SpawnInfo item = default(SpawnInfo);
					for (int k = 0; k < 10000; k++)
					{
						float num10 = SeedRandom.Range(ref seed, x, num);
						float num11 = SeedRandom.Range(ref seed, z, num2);
						float normX = TerrainMeta.NormalizeX(num10);
						float normZ = TerrainMeta.NormalizeZ(num11);
						float num12 = SeedRandom.Value(ref seed);
						float factor = Filter.GetFactor(normX, normZ);
						if (factor * factor < num12)
						{
							continue;
						}
						float height = heightMap.GetHeight(normX, normZ);
						((Vector3)(ref pos))..ctor(num10, height, num11);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						Vector3 val = pos;
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab, pos, rot, scale, val);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType || (Object.op_Implicit((Object)(object)dungeonEntrance) && distanceInfo.minDistanceDungeonEntrance < dungeonEntrance.MinDistance))
						{
							continue;
						}
						int num13 = num7;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num13 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num13 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num13 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num13 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (num13 <= num9 || !prefab.ApplyTerrainFilters(pos, rot, scale) || !prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) || !component.CheckPlacement(pos, rot, scale))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val2 = pos + rot * Vector3.Scale(scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val3 = dungeonEntrance.SnapPosition(val2);
							pos += val3 - val2;
							if (!dungeonEntrance.IsValidSpawnPosition(val3))
							{
								continue;
							}
							val = val3;
						}
						if (!prefab.ApplyTerrainChecks(pos, rot, scale, Filter) || !prefab.ApplyWaterChecks(pos, rot, scale) || !prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale) || prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							continue;
						}
						bool flag = false;
						TerrainPathConnect[] componentsInChildren = prefab.Object.GetComponentsInChildren<TerrainPathConnect>(true);
						foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
						{
							if (terrainPathConnect.Type == InfrastructureType.Boat)
							{
								if (pathFinder == null)
								{
									int[,] array6 = TerrainPath.CreateBoatCostmap(4f);
									int length = array6.GetLength(0);
									pathFinder = new PathFinder(array6);
									endList = new List<PathFinder.Point>
									{
										new PathFinder.Point(0, 0),
										new PathFinder.Point(0, length / 2),
										new PathFinder.Point(0, length - 1),
										new PathFinder.Point(length / 2, 0),
										new PathFinder.Point(length / 2, length - 1),
										new PathFinder.Point(length - 1, 0),
										new PathFinder.Point(length - 1, length / 2),
										new PathFinder.Point(length - 1, length - 1)
									};
								}
								PathFinder.Point point = PathFinder.GetPoint(pos + rot * Vector3.Scale(scale, ((Component)terrainPathConnect).transform.localPosition), pathFinder.GetResolution(0));
								if (pathFinder.FindPathUndirected(new List<PathFinder.Point> { point }, endList, 100000) == null)
								{
									flag = true;
									break;
								}
							}
						}
						if (!flag)
						{
							SpawnInfo spawnInfo = default(SpawnInfo);
							spawnInfo.prefab = prefab;
							spawnInfo.position = pos;
							spawnInfo.rotation = rot;
							spawnInfo.scale = scale;
							if (Object.op_Implicit((Object)(object)dungeonEntrance))
							{
								spawnInfo.dungeonEntrance = true;
								spawnInfo.dungeonEntrancePos = val;
							}
							num9 = num13;
							item = spawnInfo;
							num8++;
							if (num8 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num9 > 0)
					{
						list2.Add(item);
						num3 += num9;
					}
					if (num5 > 0 && list2.Count >= num5)
					{
						break;
					}
				}
				if (num3 > num4)
				{
					num4 = num3;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item2 in list3)
			{
				World.AddPrefab("Monument", item2.prefab, item2.position, item2.rotation, item2.scale);
			}
		}
	}

	public DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale, Vector3 dungeonPos)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceDungeonEntrance = float.MaxValue;
		result.maxDistanceDungeonEntrance = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num = ((OBB)(ref val2)).SqrDistance(val);
				if (spawn.prefab.Folder == prefab.Folder)
				{
					if (num < result.minDistanceSameType)
					{
						result.minDistanceSameType = num;
					}
					if (num > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num;
					}
				}
				else
				{
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			foreach (SpawnInfo spawn2 in spawns)
			{
				if (spawn2.dungeonEntrance)
				{
					Vector3 val3 = spawn2.dungeonEntrancePos - dungeonPos;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < result.minDistanceDungeonEntrance)
					{
						result.minDistanceDungeonEntrance = sqrMagnitude;
					}
					if (sqrMagnitude > result.maxDistanceDungeonEntrance)
					{
						result.maxDistanceDungeonEntrance = sqrMagnitude;
					}
				}
			}
		}
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				float num2 = monument.SqrDistance(val);
				if (num2 < result.minDistanceDifferentType)
				{
					result.minDistanceDifferentType = num2;
				}
				if (num2 > result.maxDistanceDifferentType)
				{
					result.maxDistanceDifferentType = num2;
				}
			}
			foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
			{
				float num3 = dungeonGridEntrance.SqrDistance(dungeonPos);
				if (num3 < result.minDistanceDungeonEntrance)
				{
					result.minDistanceDungeonEntrance = num3;
				}
				if (num3 > result.maxDistanceDungeonEntrance)
				{
					result.maxDistanceDungeonEntrance = num3;
				}
			}
		}
		if (result.minDistanceSameType != float.MaxValue)
		{
			result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
		}
		if (result.maxDistanceSameType != float.MinValue)
		{
			result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
		}
		if (result.minDistanceDifferentType != float.MaxValue)
		{
			result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
		}
		if (result.maxDistanceDifferentType != float.MinValue)
		{
			result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
		}
		if (result.minDistanceDungeonEntrance != float.MaxValue)
		{
			result.minDistanceDungeonEntrance = Mathf.Sqrt(result.minDistanceDungeonEntrance);
		}
		if (result.maxDistanceDungeonEntrance != float.MinValue)
		{
			result.maxDistanceDungeonEntrance = Mathf.Sqrt(result.maxDistanceDungeonEntrance);
		}
		return result;
	}
}


public struct WorldSizeInfo
{
	public int WorldSizeMin;

	public int WorldSizeMax;

	public int TargetCount;
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public bool dungeonEntrance;

	public Vector3 dungeonEntrancePos;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;

	public float minDistanceDungeonEntrance;

	public float maxDistanceDungeonEntrance;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsOffshore : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public int MinDistanceFromTerrain = 100;

	public int MaxDistanceFromTerrain = 500;

	public int DistanceBetweenMonuments = 500;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	private const int Candidates = 10;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(array2[i], (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
				array3.Shuffle(ref seed);
				list.AddRange(array3);
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			Vector3 position = TerrainMeta.Position;
			Vector3 size = TerrainMeta.Size;
			float num = position.x - (float)MaxDistanceFromTerrain;
			float num2 = position.x - (float)MinDistanceFromTerrain;
			float num3 = position.x + size.x + (float)MinDistanceFromTerrain;
			float num4 = position.x + size.x + (float)MaxDistanceFromTerrain;
			float num5 = position.z - (float)MaxDistanceFromTerrain;
			float num6 = position.z - (float)MinDistanceFromTerrain;
			float num7 = position.z + size.z + (float)MinDistanceFromTerrain;
			float num8 = position.z + size.z + (float)MaxDistanceFromTerrain;
			int num9 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num10 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			Vector3 pos = default(Vector3);
			for (int j = 0; j < 10; j++)
			{
				num9 = 0;
				list2.Clear();
				Prefab<MonumentInfo>[] array5 = array4;
				foreach (Prefab<MonumentInfo> prefab in array5)
				{
					int num11 = (int)((!Object.op_Implicit((Object)(object)prefab.Parameters)) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
					int num12 = num11 * num11 * num11 * num11;
					for (int k = 0; k < 10000; k++)
					{
						float num13 = 0f;
						float num14 = 0f;
						switch (seed % 4)
						{
						case 0u:
							num13 = SeedRandom.Range(ref seed, num, num2);
							num14 = SeedRandom.Range(ref seed, num5, num8);
							break;
						case 1u:
							num13 = SeedRandom.Range(ref seed, num3, num4);
							num14 = SeedRandom.Range(ref seed, num5, num8);
							break;
						case 2u:
							num13 = SeedRandom.Range(ref seed, num, num4);
							num14 = SeedRandom.Range(ref seed, num5, num6);
							break;
						case 3u:
							num13 = SeedRandom.Range(ref seed, num, num4);
							num14 = SeedRandom.Range(ref seed, num7, num8);
							break;
						}
						float normX = TerrainMeta.NormalizeX(num13);
						float normZ = TerrainMeta.NormalizeZ(num14);
						float height = heightMap.GetHeight(normX, normZ);
						((Vector3)(ref pos))..ctor(num13, height, num14);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						if (!CheckRadius(list2, pos, DistanceBetweenMonuments))
						{
							prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
							if ((!Object.op_Implicit((Object)(object)prefab.Component) || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
							{
								SpawnInfo item = default(SpawnInfo);
								item.prefab = prefab;
								item.position = pos;
								item.rotation = rot;
								item.scale = scale;
								list2.Add(item);
								num9 += num12;
								break;
							}
						}
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num9 > num10)
				{
					num10 = num9;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item2 in list3)
			{
				World.AddPrefab("Monument", item2.prefab, item2.position, item2.rotation, item2.scale);
			}
		}
	}

	public bool CheckRadius(List<SpawnInfo> spawns, Vector3 pos, float radius)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = radius * radius;
		foreach (SpawnInfo spawn in spawns)
		{
			Vector3 val = spawn.position - pos;
			if (((Vector3)(ref val)).sqrMagnitude < num)
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

private struct SpawnInfo
{
	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsRailside : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	private class SpawnInfoGroup
	{
		public bool processed;

		public Prefab<MonumentInfo> prefab;

		public List<SpawnInfo> candidates;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public int PositionOffset = 100;

	public int TangentInterval = 100;

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	private const int GroupCandidates = 8;

	private const int IndividualCandidates = 8;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0836: Unknown result type (might be due to invalid IL or missing references)
		//IL_083d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_051f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0622: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064f: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0354: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0671: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0705: Unknown result type (might be due to invalid IL or missing references)
		//IL_070c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0691: Unknown result type (might be due to invalid IL or missing references)
		//IL_0698: Unknown result type (might be due to invalid IL or missing references)
		//IL_069f: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06db: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0722: Unknown result type (might be due to invalid IL or missing references)
		//IL_0729: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0740: Unknown result type (might be due to invalid IL or missing references)
		//IL_0747: Unknown result type (might be due to invalid IL or missing references)
		//IL_074e: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_076c: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			_ = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(array2[i], (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
				array3.Shuffle(ref seed);
				list.AddRange(array3);
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			SpawnInfoGroup[] array5 = new SpawnInfoGroup[array4.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				Prefab<MonumentInfo> prefab = array4[j];
				SpawnInfoGroup spawnInfoGroup = null;
				for (int k = 0; k < j; k++)
				{
					SpawnInfoGroup spawnInfoGroup2 = array5[k];
					Prefab<MonumentInfo> prefab2 = spawnInfoGroup2.prefab;
					if (prefab == prefab2)
					{
						spawnInfoGroup = spawnInfoGroup2;
						break;
					}
				}
				if (spawnInfoGroup == null)
				{
					spawnInfoGroup = new SpawnInfoGroup();
					spawnInfoGroup.prefab = array4[j];
					spawnInfoGroup.candidates = new List<SpawnInfo>();
				}
				array5[j] = spawnInfoGroup;
			}
			SpawnInfoGroup[] array6 = array5;
			foreach (SpawnInfoGroup spawnInfoGroup3 in array6)
			{
				if (spawnInfoGroup3.processed)
				{
					continue;
				}
				Prefab<MonumentInfo> prefab3 = spawnInfoGroup3.prefab;
				MonumentInfo component = prefab3.Component;
				if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
				{
					continue;
				}
				int num = 0;
				Vector3 val = Vector3.zero;
				Vector3 val2 = Vector3.zero;
				Vector3 val3 = Vector3.zero;
				TerrainPathConnect[] componentsInChildren = prefab3.Object.GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Rail)
					{
						switch (num)
						{
						case 0:
							val2 = ((Component)terrainPathConnect).transform.position;
							break;
						case 1:
							val3 = ((Component)terrainPathConnect).transform.position;
							break;
						}
						val += ((Component)terrainPathConnect).transform.position;
						num++;
					}
				}
				Vector3 val4 = val3 - val2;
				Vector3 normalized = ((Vector3)(ref val4)).normalized;
				val4 = rot90 * normalized;
				Vector3 normalized2 = ((Vector3)(ref val4)).normalized;
				if (num > 1)
				{
					val /= (float)num;
				}
				foreach (PathList rail in TerrainMeta.Path.Rails)
				{
					PathInterpolator path = rail.Path;
					float num2 = TangentInterval / 2;
					float num3 = 5f;
					float num4 = 5f;
					float num5 = path.StartOffset + num4;
					float num6 = path.Length - path.EndOffset - num4;
					for (float num7 = num5; num7 <= num6; num7 += num3)
					{
						Vector3 val5 = (rail.Spline ? path.GetPointCubicHermite(num7) : path.GetPoint(num7));
						val4 = path.GetPoint(num7 + num2) - path.GetPoint(num7 - num2);
						Vector3 normalized3 = ((Vector3)(ref val4)).normalized;
						for (int m = Mathf.RoundToInt((float)PositionOffset); m <= Mathf.CeilToInt((float)PositionOffset * 1.5f); m += 25)
						{
							for (int n = -1; n <= 1; n += 2)
							{
								Quaternion val6 = Quaternion.LookRotation((float)n * Vector3Ex.XZ3D(normalized3));
								Vector3 val7 = val5;
								Quaternion val8 = val6;
								Vector3 localScale = prefab3.Object.transform.localScale;
								val8 *= Quaternion.LookRotation(normalized);
								val7 -= val8 * (val + (float)m * normalized2);
								if (!(GetDistanceToAboveGroundRail(val7) < (float)PositionOffset * 0.5f))
								{
									SpawnInfo item = default(SpawnInfo);
									item.prefab = prefab3;
									item.position = val7;
									item.rotation = val8;
									item.scale = localScale;
									spawnInfoGroup3.candidates.Add(item);
								}
							}
						}
					}
				}
				spawnInfoGroup3.processed = true;
			}
			int num8 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num9 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			for (int num10 = 0; num10 < 8; num10++)
			{
				num8 = 0;
				list2.Clear();
				array5.Shuffle(ref seed);
				array6 = array5;
				foreach (SpawnInfoGroup spawnInfoGroup4 in array6)
				{
					Prefab<MonumentInfo> prefab4 = spawnInfoGroup4.prefab;
					MonumentInfo component2 = prefab4.Component;
					if ((Object)(object)component2 == (Object)null || World.Size < component2.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component2.DungeonEntrance;
					int num11 = (int)((!Object.op_Implicit((Object)(object)prefab4.Parameters)) ? PrefabPriority.Low : (prefab4.Parameters.Priority + 1));
					int num12 = 100000 * num11 * num11 * num11 * num11;
					int num13 = 0;
					int num14 = 0;
					SpawnInfo item2 = default(SpawnInfo);
					ListEx.Shuffle<SpawnInfo>(spawnInfoGroup4.candidates, ref seed);
					for (int num15 = 0; num15 < spawnInfoGroup4.candidates.Count; num15++)
					{
						SpawnInfo spawnInfo = spawnInfoGroup4.candidates[num15];
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab4, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType)
						{
							continue;
						}
						int num16 = num12;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num16 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num16 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num16 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num16 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (!component2.CheckPlacement(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale))
						{
							num16 /= 2;
						}
						if (num16 <= num14 || !prefab4.ApplyTerrainFilters(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) || !prefab4.ApplyTerrainAnchors(ref spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val9 = spawnInfo.position + spawnInfo.rotation * Vector3.Scale(spawnInfo.scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val10 = dungeonEntrance.SnapPosition(val9);
							ref Vector3 position = ref spawnInfo.position;
							position += val10 - val9;
							if (!dungeonEntrance.IsValidSpawnPosition(val10))
							{
								continue;
							}
						}
						if (prefab4.ApplyTerrainChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) && prefab4.ApplyWaterChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && prefab4.ApplyEnvironmentVolumeChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && !prefab4.CheckEnvironmentVolumes(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							num14 = num16;
							item2 = spawnInfo;
							num13++;
							if (num13 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num14 > 0)
					{
						list2.Add(item2);
						num8 += num14;
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num8 > num9)
				{
					num9 = num8;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item3 in list3)
			{
				World.AddPrefab("Monument", item3.prefab, item3.position, item3.rotation, item3.scale);
			}
		}
	}

	private DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (!prefab.Component.HasDungeonLink || (!monument.HasDungeonLink && monument.WantsDungeonLink))
				{
					float num = monument.SqrDistance(val);
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			if (result.minDistanceDifferentType != float.MaxValue)
			{
				result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
			}
			if (result.maxDistanceDifferentType != float.MinValue)
			{
				result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
			}
		}
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num2 = ((OBB)(ref val2)).SqrDistance(val);
				if (num2 < result.minDistanceSameType)
				{
					result.minDistanceSameType = num2;
				}
				if (num2 > result.maxDistanceSameType)
				{
					result.maxDistanceSameType = num2;
				}
			}
			if (prefab.Component.HasDungeonLink)
			{
				foreach (MonumentInfo monument2 in TerrainMeta.Path.Monuments)
				{
					if (monument2.HasDungeonLink || !monument2.WantsDungeonLink)
					{
						float num3 = monument2.SqrDistance(val);
						if (num3 < result.minDistanceSameType)
						{
							result.minDistanceSameType = num3;
						}
						if (num3 > result.maxDistanceSameType)
						{
							result.maxDistanceSameType = num3;
						}
					}
				}
				foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
				{
					float num4 = dungeonGridEntrance.SqrDistance(monumentPos);
					if (num4 < result.minDistanceSameType)
					{
						result.minDistanceSameType = num4;
					}
					if (num4 > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num4;
					}
				}
			}
			if (result.minDistanceSameType != float.MaxValue)
			{
				result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
			}
			if (result.maxDistanceSameType != float.MinValue)
			{
				result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
			}
		}
		return result;
	}

	private float GetDistanceToAboveGroundRail(Vector3 pos)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			foreach (PathList rail in TerrainMeta.Path.Rails)
			{
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					num = Mathf.Min(num, Vector3Ex.Distance2D(val, pos));
				}
			}
		}
		return num;
	}
}


using UnityEngine;

private struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;

private class SpawnInfoGroup
{
	public bool processed;

	public Prefab<MonumentInfo> prefab;

	public List<SpawnInfo> candidates;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsRoadside : ProceduralComponent
{
	public struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public PathInterpolator path;

		public int pathStartIndex;

		public int pathEndIndex;
	}

	public class SpawnInfoGroup
	{
		public bool processed;

		public Prefab<MonumentInfo> prefab;

		public List<SpawnInfo> candidates;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public enum RoadMode
	{
		SideRoadOrRingRoad,
		SideRoad,
		RingRoad,
		SideRoadOrDesireTrail,
		DesireTrail
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	public RoadMode RoadType;

	public const int GroupCandidates = 8;

	public const int IndividualCandidates = 8;

	public static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0783: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0735: Unknown result type (might be due to invalid IL or missing references)
		//IL_073a: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_0748: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_074f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_0762: Unknown result type (might be due to invalid IL or missing references)
		//IL_0767: Unknown result type (might be due to invalid IL or missing references)
		//IL_076c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0773: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f1: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			_ = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!text.Contains("tunnel-entrance") || World.Config.BelowGroundRails)
				{
					Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(text, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
					array3.Shuffle(ref seed);
					list.AddRange(array3);
				}
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			SpawnInfoGroup[] array5 = new SpawnInfoGroup[array4.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				Prefab<MonumentInfo> prefab = array4[j];
				SpawnInfoGroup spawnInfoGroup = null;
				for (int k = 0; k < j; k++)
				{
					SpawnInfoGroup spawnInfoGroup2 = array5[k];
					Prefab<MonumentInfo> prefab2 = spawnInfoGroup2.prefab;
					if (prefab == prefab2)
					{
						spawnInfoGroup = spawnInfoGroup2;
						break;
					}
				}
				if (spawnInfoGroup == null)
				{
					spawnInfoGroup = new SpawnInfoGroup();
					spawnInfoGroup.prefab = array4[j];
					spawnInfoGroup.candidates = new List<SpawnInfo>();
				}
				array5[j] = spawnInfoGroup;
			}
			SpawnInfoGroup[] array6 = array5;
			foreach (SpawnInfoGroup spawnInfoGroup3 in array6)
			{
				if (spawnInfoGroup3.processed)
				{
					continue;
				}
				Prefab<MonumentInfo> prefab3 = spawnInfoGroup3.prefab;
				MonumentInfo component = prefab3.Component;
				if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
				{
					continue;
				}
				int num = 0;
				Vector3 val = Vector3.zero;
				Vector3 val2 = Vector3.zero;
				_ = Vector3.zero;
				float num2 = 0f;
				TerrainPathConnect[] componentsInChildren = prefab3.Object.GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Road)
					{
						Vector3 val3 = Vector3Ex.XZ3D(((Component)terrainPathConnect).transform.position);
						val += val3;
						num2 += ((Vector3)(ref val3)).magnitude;
						if (num == 0)
						{
							val2 += val3;
						}
						if (num == 1)
						{
							val2 -= val3;
						}
						num++;
					}
				}
				val2 = ((Vector3)(ref val2)).normalized;
				_ = rot90 * val2;
				if (num > 1)
				{
					val /= (float)num;
					num2 /= (float)num;
				}
				foreach (PathList road in TerrainMeta.Path.Roads)
				{
					bool flag = false;
					switch (RoadType)
					{
					case RoadMode.SideRoadOrRingRoad:
						flag = road.Hierarchy == 0 || road.Hierarchy == 1;
						break;
					case RoadMode.SideRoad:
						flag = road.Hierarchy == 1;
						break;
					case RoadMode.RingRoad:
						flag = road.Hierarchy == 0;
						break;
					case RoadMode.SideRoadOrDesireTrail:
						flag = road.Hierarchy == 1 || road.Hierarchy == 2;
						break;
					case RoadMode.DesireTrail:
						flag = road.Hierarchy == 2;
						break;
					}
					if (!flag)
					{
						continue;
					}
					PathInterpolator path = road.Path;
					float num3 = 5f;
					float num4 = 5f;
					float num5 = path.StartOffset + num4 + num2;
					float num6 = path.Length - path.EndOffset - num4 - num2;
					for (float num7 = num5; num7 <= num6; num7 += num3)
					{
						float distance = num7 - num2;
						float distance2 = num7 + num2;
						int prevIndex = path.GetPrevIndex(distance);
						int nextIndex = path.GetNextIndex(distance2);
						Vector3 point = path.GetPoint(prevIndex);
						Vector3 point2 = path.GetPoint(nextIndex);
						Vector3 val4 = (point + point2) * 0.5f;
						Vector3 val5 = point2 - point;
						Vector3 normalized = ((Vector3)(ref val5)).normalized;
						for (int m = -1; m <= 1; m += 2)
						{
							Quaternion val6 = Quaternion.LookRotation((float)m * Vector3Ex.XZ3D(normalized));
							Vector3 val7 = val4;
							Quaternion val8 = val6;
							Vector3 localScale = prefab3.Object.transform.localScale;
							val8 *= Quaternion.LookRotation(val2);
							val7 -= val8 * val;
							SpawnInfo item = default(SpawnInfo);
							item.prefab = prefab3;
							item.position = val7;
							item.rotation = val8;
							item.scale = localScale;
							item.path = path;
							item.pathStartIndex = prevIndex;
							item.pathEndIndex = nextIndex;
							spawnInfoGroup3.candidates.Add(item);
						}
					}
				}
				spawnInfoGroup3.processed = true;
			}
			int num8 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num9 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			for (int n = 0; n < 8; n++)
			{
				num8 = 0;
				list2.Clear();
				array5.Shuffle(ref seed);
				array6 = array5;
				foreach (SpawnInfoGroup spawnInfoGroup4 in array6)
				{
					Prefab<MonumentInfo> prefab4 = spawnInfoGroup4.prefab;
					MonumentInfo component2 = prefab4.Component;
					if ((Object)(object)component2 == (Object)null || World.Size < component2.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component2.DungeonEntrance;
					int num10 = (int)((!Object.op_Implicit((Object)(object)prefab4.Parameters)) ? PrefabPriority.Low : (prefab4.Parameters.Priority + 1));
					int num11 = 100000 * num10 * num10 * num10 * num10;
					int num12 = 0;
					int num13 = 0;
					SpawnInfo item2 = default(SpawnInfo);
					ListEx.Shuffle<SpawnInfo>(spawnInfoGroup4.candidates, ref seed);
					for (int num14 = 0; num14 < spawnInfoGroup4.candidates.Count; num14++)
					{
						SpawnInfo spawnInfo = spawnInfoGroup4.candidates[num14];
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab4, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType)
						{
							continue;
						}
						int num15 = num11;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num15 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num15 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num15 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num15 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (num15 <= num13 || !prefab4.ApplyTerrainFilters(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) || !prefab4.ApplyTerrainAnchors(ref spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) || !component2.CheckPlacement(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val9 = spawnInfo.position + spawnInfo.rotation * Vector3.Scale(spawnInfo.scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val10 = dungeonEntrance.SnapPosition(val9);
							ref Vector3 position = ref spawnInfo.position;
							position += val10 - val9;
							if (!dungeonEntrance.IsValidSpawnPosition(val10))
							{
								continue;
							}
						}
						if (prefab4.ApplyTerrainChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) && prefab4.ApplyWaterChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && prefab4.ApplyEnvironmentVolumeChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && !prefab4.CheckEnvironmentVolumes(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							num13 = num15;
							item2 = spawnInfo;
							num12++;
							if (num12 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num13 > 0)
					{
						list2.Add(item2);
						num8 += num13;
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num8 > num9)
				{
					num9 = num8;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item3 in list3)
			{
				World.AddPrefab("Monument", item3.prefab, item3.position, item3.rotation, item3.scale);
			}
			HashSet<PathInterpolator> hashSet = new HashSet<PathInterpolator>();
			foreach (SpawnInfo item4 in list3)
			{
				item4.path.Straighten(item4.pathStartIndex, item4.pathEndIndex);
				hashSet.Add(item4.path);
			}
			foreach (PathInterpolator item5 in hashSet)
			{
				item5.RecalculateLength();
			}
		}
	}

	private DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (!prefab.Component.HasDungeonLink || (!monument.HasDungeonLink && monument.WantsDungeonLink))
				{
					float num = monument.SqrDistance(val);
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			if (result.minDistanceDifferentType != float.MaxValue)
			{
				result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
			}
			if (result.maxDistanceDifferentType != float.MinValue)
			{
				result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
			}
		}
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num2 = ((OBB)(ref val2)).SqrDistance(val);
				if (num2 < result.minDistanceSameType)
				{
					result.minDistanceSameType = num2;
				}
				if (num2 > result.maxDistanceSameType)
				{
					result.maxDistanceSameType = num2;
				}
			}
			if (prefab.Component.HasDungeonLink)
			{
				foreach (MonumentInfo monument2 in TerrainMeta.Path.Monuments)
				{
					if (monument2.HasDungeonLink || !monument2.WantsDungeonLink)
					{
						float num3 = monument2.SqrDistance(val);
						if (num3 < result.minDistanceSameType)
						{
							result.minDistanceSameType = num3;
						}
						if (num3 > result.maxDistanceSameType)
						{
							result.maxDistanceSameType = num3;
						}
					}
				}
				foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
				{
					float num4 = dungeonGridEntrance.SqrDistance(monumentPos);
					if (num4 < result.minDistanceSameType)
					{
						result.minDistanceSameType = num4;
					}
					if (num4 > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num4;
					}
				}
			}
			if (result.minDistanceSameType != float.MaxValue)
			{
				result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
			}
			if (result.maxDistanceSameType != float.MinValue)
			{
				result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
			}
		}
		return result;
	}
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public PathInterpolator path;

	public int pathStartIndex;

	public int pathEndIndex;
}


using System.Collections.Generic;

public class SpawnInfoGroup
{
	public bool processed;

	public Prefab<MonumentInfo> prefab;

	public List<SpawnInfo> candidates;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


public enum RoadMode
{
	SideRoadOrRingRoad,
	SideRoad,
	RingRoad,
	SideRoadOrDesireTrail,
	DesireTrail
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlacePowerlineObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	public PathList.SideObject[] Side;

	[FormerlySerializedAs("PowerlineObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> powerlines = TerrainMeta.Path.Powerlines;
		if (World.Networked)
		{
			foreach (PathList item in powerlines)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in powerlines)
		{
			PathList.BasicObject[] start = Start;
			foreach (PathList.BasicObject obj in start)
			{
				item2.TrimStart(obj);
			}
			start = End;
			foreach (PathList.BasicObject obj2 in start)
			{
				item2.TrimEnd(obj2);
			}
			start = Start;
			foreach (PathList.BasicObject obj3 in start)
			{
				item2.SpawnStart(ref seed, obj3);
			}
			start = End;
			foreach (PathList.BasicObject obj4 in start)
			{
				item2.SpawnEnd(ref seed, obj4);
			}
			PathList.PathObject[] path = Path;
			foreach (PathList.PathObject obj5 in path)
			{
				item2.SpawnAlong(ref seed, obj5);
			}
			PathList.SideObject[] side = Side;
			foreach (PathList.SideObject obj6 in side)
			{
				item2.SpawnSide(ref seed, obj6);
			}
			item2.ResetTrims();
		}
	}
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlaceRiverObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	[FormerlySerializedAs("RiversideObjects")]
	public PathList.SideObject[] Side;

	[FormerlySerializedAs("RiverObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> rivers = TerrainMeta.Path.Rivers;
		if (World.Networked)
		{
			foreach (PathList item in rivers)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in rivers)
		{
			PathList.BasicObject[] start = Start;
			foreach (PathList.BasicObject obj in start)
			{
				item2.TrimStart(obj);
			}
			start = End;
			foreach (PathList.BasicObject obj2 in start)
			{
				item2.TrimEnd(obj2);
			}
			start = Start;
			foreach (PathList.BasicObject obj3 in start)
			{
				item2.SpawnStart(ref seed, obj3);
			}
			PathList.PathObject[] path = Path;
			foreach (PathList.PathObject obj4 in path)
			{
				item2.SpawnAlong(ref seed, obj4);
			}
			PathList.SideObject[] side = Side;
			foreach (PathList.SideObject obj5 in side)
			{
				item2.SpawnSide(ref seed, obj5);
			}
			start = End;
			foreach (PathList.BasicObject obj6 in start)
			{
				item2.SpawnEnd(ref seed, obj6);
			}
			item2.ResetTrims();
		}
	}
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlaceRoadObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	[FormerlySerializedAs("RoadsideObjects")]
	public PathList.SideObject[] Side;

	[FormerlySerializedAs("RoadObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> roads = TerrainMeta.Path.Roads;
		if (World.Networked)
		{
			foreach (PathList item in roads)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in roads)
		{
			if (item2.Hierarchy < 2)
			{
				PathList.BasicObject[] start = Start;
				foreach (PathList.BasicObject obj in start)
				{
					item2.TrimStart(obj);
				}
				start = End;
				foreach (PathList.BasicObject obj2 in start)
				{
					item2.TrimEnd(obj2);
				}
				start = Start;
				foreach (PathList.BasicObject obj3 in start)
				{
					item2.SpawnStart(ref seed, obj3);
				}
				start = End;
				foreach (PathList.BasicObject obj4 in start)
				{
					item2.SpawnEnd(ref seed, obj4);
				}
				PathList.PathObject[] path = Path;
				foreach (PathList.PathObject obj5 in path)
				{
					item2.SpawnAlong(ref seed, obj5);
				}
				PathList.SideObject[] side = Side;
				foreach (PathList.SideObject obj6 in side)
				{
					item2.SpawnSide(ref seed, obj6);
				}
				item2.ResetTrims();
			}
		}
	}
}


using System.Collections.Generic;

public class ProcessMonumentNodes : ProceduralComponent
{
	public override void Process(uint seed)
	{
		List<MonumentNode> monumentNodes = SingletonComponent<WorldSetup>.Instance.MonumentNodes;
		if (!World.Cached)
		{
			for (int i = 0; i < monumentNodes.Count; i++)
			{
				monumentNodes[i].Process(ref seed);
			}
		}
		monumentNodes.Clear();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ProcessProceduralObjects : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		List<ProceduralObject> proceduralObjects = SingletonComponent<WorldSetup>.Instance.ProceduralObjects;
		if (!World.Cached)
		{
			for (int i = 0; i < proceduralObjects.Count; i++)
			{
				ProceduralObject proceduralObject = proceduralObjects[i];
				if (Object.op_Implicit((Object)(object)proceduralObject))
				{
					proceduralObject.Process();
				}
			}
		}
		proceduralObjects.Clear();
	}
}


public class ResetPlacementMap : ProceduralComponent
{
	public override void Process(uint seed)
	{
		TerrainMeta.PlacementMap.Reset();
	}
}


using UnityEngine;

public abstract class ProceduralObject : MonoBehaviour
{
	protected void Awake()
	{
		if (!((Object)(object)SingletonComponent<WorldSetup>.Instance == (Object)null))
		{
			if (SingletonComponent<WorldSetup>.Instance.ProceduralObjects == null)
			{
				Debug.LogError((object)"WorldSetup.Instance.ProceduralObjects is null.", (Object)(object)this);
			}
			else
			{
				SingletonComponent<WorldSetup>.Instance.ProceduralObjects.Add(this);
			}
		}
	}

	public abstract void Process();
}


using UnityEngine;

public class AddToAlphaMap : ProceduralObject
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public override void Process()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(((Component)this).transform, bounds);
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		TerrainMeta.AlphaMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
		{
			TerrainMeta.AlphaMap.SetAlpha(x, z, 0f);
		});
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class AddToHeightMap : ProceduralObject
{
	public bool DestroyGameObject;

	public void Apply()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		Collider component = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component.bounds;
		int num = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.x));
		int num2 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.x));
		int num3 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.z));
		int num4 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.z));
		Vector3 val = default(Vector3);
		Ray val2 = default(Ray);
		RaycastHit val3 = default(RaycastHit);
		for (int i = num3; i <= num4; i++)
		{
			float normZ = TerrainMeta.HeightMap.Coordinate(i);
			for (int j = num; j <= num2; j++)
			{
				float normX = TerrainMeta.HeightMap.Coordinate(j);
				((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), ((Bounds)(ref bounds)).max.y, TerrainMeta.DenormalizeZ(normZ));
				((Ray)(ref val2))..ctor(val, Vector3.down);
				if (component.Raycast(val2, ref val3, ((Bounds)(ref bounds)).size.y))
				{
					float num5 = TerrainMeta.NormalizeY(((RaycastHit)(ref val3)).point.y);
					float height = TerrainMeta.HeightMap.GetHeight01(j, i);
					if (num5 > height)
					{
						TerrainMeta.HeightMap.SetHeight(j, i, num5);
					}
				}
			}
		}
	}

	public override void Process()
	{
		Apply();
		if (DestroyGameObject)
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
		else
		{
			GameManager.Destroy((Component)(object)this);
		}
	}
}


using UnityEngine;

public class AddToWaterMap : ProceduralObject
{
	public bool automaticallyAddTerrainTopology;

	public override void Process()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		WaterBody component = ((Component)this).GetComponent<WaterBody>();
		Collider component2 = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component2.bounds;
		int mask = (((Object)(object)component != (Object)null) ? component.GetTopologyMask() : 0);
		float num = TerrainMeta.NormalizeY(((Bounds)(ref bounds)).max.y);
		int num2 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.x));
		int num3 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.x));
		int num4 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.z));
		int num5 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.z));
		bool flag = component2 is BoxCollider && ((Component)this).transform.rotation == Quaternion.identity;
		Vector3 val = default(Vector3);
		Ray val2 = default(Ray);
		RaycastHit val3 = default(RaycastHit);
		for (int i = num4; i <= num5; i++)
		{
			float normZ = TerrainMeta.WaterMap.Coordinate(i);
			for (int j = num2; j <= num3; j++)
			{
				float normX = TerrainMeta.WaterMap.Coordinate(j);
				((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), ((Bounds)(ref bounds)).max.y + 1f, TerrainMeta.DenormalizeZ(normZ));
				if (!flag)
				{
					((Ray)(ref val2))..ctor(val, Vector3.down);
					if (!component2.Raycast(val2, ref val3, ((Bounds)(ref bounds)).size.y + 1f + 1f))
					{
						continue;
					}
					num = TerrainMeta.NormalizeY(((RaycastHit)(ref val3)).point.y);
				}
				float height = TerrainMeta.HeightMap.GetHeight01(normX, normZ);
				if (num < height - TerrainMeta.OneOverSize.z)
				{
					continue;
				}
				if ((Object)(object)component != (Object)null)
				{
					if (automaticallyAddTerrainTopology)
					{
						TerrainMeta.TopologyMap.AddTopology(normX, normZ, mask);
					}
					if (component.Type == WaterBodyType.Lake && !TerrainMeta.TopologyMap.GetTopology(normX, normZ, 196608))
					{
						continue;
					}
				}
				if (!(TerrainMeta.WaterMap.GetHeight01(j, i) >= num))
				{
					TerrainMeta.WaterMap.SetHeight(j, i, num);
				}
			}
		}
		GameManager.Destroy((Component)(object)this);
	}
}


using Oxide.Core;
using UnityEngine;

public class TerrainGenerator : SingletonComponent<TerrainGenerator>
{
	public TerrainConfig config;

	private const float HeightMapRes = 1f;

	private const float SplatMapRes = 0.5f;

	private const float BaseMapRes = 0.01f;

	public static int GetHeightMapRes()
	{
		return Mathf.Min(4096, Mathf.ClosestPowerOfTwo((int)((float)World.Size * 1f))) + 1;
	}

	public static int GetSplatMapRes()
	{
		return Mathf.Min(2048, Mathf.NextPowerOfTwo((int)((float)World.Size * 0.5f)));
	}

	public static int GetBaseMapRes()
	{
		return Mathf.Min(2048, Mathf.NextPowerOfTwo((int)((float)World.Size * 0.01f)));
	}

	public GameObject CreateTerrain()
	{
		return CreateTerrain(GetHeightMapRes(), GetSplatMapRes());
	}

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("OnTerrainCreate", (object)this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3((float)World.Size, 1000f, (float)World.Size)
		}).GetComponent<Terrain>();
		((Component)component).transform.position = ((Component)this).transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = (MaterialType)3;
		component.materialTemplate = config.Material;
		((Component)component).gameObject.tag = ((Component)this).gameObject.tag;
		((Component)component).gameObject.layer = ((Component)this).gameObject.layer;
		((Collider)((Component)component).gameObject.GetComponent<TerrainCollider>()).sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = ((Component)component).gameObject.AddComponent<TerrainMeta>();
		((Component)component).gameObject.AddComponent<TerrainPhysics>();
		((Component)component).gameObject.AddComponent<TerrainColors>();
		((Component)component).gameObject.AddComponent<TerrainCollision>();
		((Component)component).gameObject.AddComponent<TerrainBiomeMap>();
		((Component)component).gameObject.AddComponent<TerrainAlphaMap>();
		((Component)component).gameObject.AddComponent<TerrainHeightMap>();
		((Component)component).gameObject.AddComponent<TerrainSplatMap>();
		((Component)component).gameObject.AddComponent<TerrainTopologyMap>();
		((Component)component).gameObject.AddComponent<TerrainWaterMap>();
		((Component)component).gameObject.AddComponent<TerrainPlacementMap>();
		((Component)component).gameObject.AddComponent<TerrainPath>();
		((Component)component).gameObject.AddComponent<TerrainTexturing>();
		((Component)component).gameObject.AddComponent<TerrainWaterFlowMap>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate((Object)(object)((Component)this).gameObject);
		return ((Component)component).gameObject;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Network;
using ProtoBuf;
using UnityEngine;

public class WorldNetworking
{
	private const int prefabsPerPacket = 100;

	private const int pathsPerPacket = 10;

	public static void OnMessageReceived(Message message)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Expected I4, but got Unknown
		WorldSerialization serialization = World.Serialization;
		WorldMessage val = message.read.Proto<WorldMessage>((WorldMessage)null);
		try
		{
			MessageType status = val.status;
			switch (status - 1)
			{
			case 0:
				SendWorldData(message.connection);
				return;
			}
			if (val.prefabs != null)
			{
				serialization.world.prefabs.AddRange(val.prefabs);
				val.prefabs.Clear();
			}
			if (val.paths != null)
			{
				serialization.world.paths.AddRange(val.paths);
				val.paths.Clear();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void SendWorldData(Connection connection)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		if (connection.hasRequestedWorld)
		{
			DebugEx.LogWarning((object)$"{connection} requested world data more than once", (StackTraceLogType)0);
			return;
		}
		connection.hasRequestedWorld = true;
		WorldSerialization serialization = World.Serialization;
		WorldMessage data = Pool.Get<WorldMessage>();
		for (int i = 0; i < serialization.world.prefabs.Count; i++)
		{
			if (data.prefabs != null && data.prefabs.Count >= 100)
			{
				data.status = (MessageType)2;
				SendWorldData(connection, ref data);
				data = Pool.Get<WorldMessage>();
			}
			if (data.prefabs == null)
			{
				data.prefabs = Pool.Get<List<PrefabData>>();
			}
			data.prefabs.Add(serialization.world.prefabs[i]);
		}
		for (int j = 0; j < serialization.world.paths.Count; j++)
		{
			if (data.paths != null && data.paths.Count >= 10)
			{
				data.status = (MessageType)2;
				SendWorldData(connection, ref data);
				data = Pool.Get<WorldMessage>();
			}
			if (data.paths == null)
			{
				data.paths = Pool.Get<List<PathData>>();
			}
			data.paths.Add(serialization.world.paths[j]);
		}
		if (data != null)
		{
			data.status = (MessageType)3;
			SendWorldData(connection, ref data);
		}
	}

	private static void SendWorldData(Connection connection, ref WorldMessage data)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
		obj.PacketID((Type)24);
		obj.Proto<WorldMessage>(data);
		obj.Send(new SendInfo(connection));
		if (data.prefabs != null)
		{
			data.prefabs.Clear();
		}
		if (data.paths != null)
		{
			data.paths.Clear();
		}
		data.Dispose();
		data = null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Threading;
using ConVar;
using Rust;
using UnityEngine;
using UnityEngine.Networking;

public class WorldSetup : SingletonComponent<WorldSetup>
{
	public bool AutomaticallySetup;

	public bool BypassProceduralSpawn;

	public bool ForceGenerateOceanPatrols;

	public GameObject terrain;

	public GameObject decorPrefab;

	public GameObject grassPrefab;

	public GameObject spawnPrefab;

	private TerrainMeta terrainMeta;

	public uint EditorSeed;

	public uint EditorSalt;

	public uint EditorSize;

	public string EditorUrl = string.Empty;

	public string EditorConfigFile = string.Empty;

	[TextArea]
	public string EditorConfigString = string.Empty;

	public List<ProceduralObject> ProceduralObjects = new List<ProceduralObject>();

	internal List<MonumentNode> MonumentNodes = new List<MonumentNode>();

	public void OnValidate()
	{
		if ((Object)(object)terrain == (Object)null)
		{
			Terrain val = Object.FindObjectOfType<Terrain>();
			if ((Object)(object)val != (Object)null)
			{
				terrain = ((Component)val).gameObject;
			}
		}
	}

	protected override void Awake()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Expected O, but got Unknown
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		((SingletonComponent)this).Awake();
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/world", null, null, useProbabilities: false, useWorldConfig: false);
		foreach (Prefab prefab in array)
		{
			if ((Object)(object)prefab.Object.GetComponent<BaseEntity>() != (Object)null)
			{
				prefab.SpawnEntity(Vector3.zero, Quaternion.identity).Spawn();
			}
			else
			{
				prefab.Spawn(Vector3.zero, Quaternion.identity);
			}
		}
		SingletonComponent[] array2 = Object.FindObjectsOfType<SingletonComponent>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].SingletonSetup();
		}
		if (Object.op_Implicit((Object)(object)terrain))
		{
			if (Object.op_Implicit((Object)(object)terrain.GetComponent<TerrainGenerator>()))
			{
				World.Procedural = true;
			}
			else
			{
				World.Procedural = false;
				terrainMeta = terrain.GetComponent<TerrainMeta>();
				terrainMeta.Init();
				terrainMeta.SetupComponents();
				terrainMeta.BindShaderProperties();
				terrainMeta.PostSetupComponents();
				World.InitSize(Mathf.RoundToInt(TerrainMeta.Size.x));
				CreateObject(decorPrefab);
				CreateObject(grassPrefab);
				CreateObject(spawnPrefab);
			}
		}
		World.Serialization = new WorldSerialization();
		World.Cached = false;
		World.CleanupOldFiles();
		World.SpawnedPrefabs.Clear();
		if (!string.IsNullOrEmpty(EditorConfigString))
		{
			ConVar.World.configString = EditorConfigString;
		}
		if (!string.IsNullOrEmpty(EditorConfigFile))
		{
			ConVar.World.configFile = EditorConfigFile;
		}
		if (AutomaticallySetup)
		{
			((MonoBehaviour)this).StartCoroutine(InitCoroutine());
		}
	}

	public void CreateObject(GameObject prefab)
	{
		if (!((Object)(object)prefab == (Object)null))
		{
			GameObject val = Object.Instantiate<GameObject>(prefab);
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(true);
			}
		}
	}

	public IEnumerator InitCoroutine(CancellationToken ct = default(CancellationToken))
	{
		if (World.CanLoadFromUrl())
		{
			Debug.Log((object)("Loading custom map from " + World.Url));
		}
		else
		{
			Debug.Log((object)("Generating procedural map of size " + World.Size + " with seed " + World.Seed));
		}
		World.Config = new WorldConfig();
		World.Config.LoadScriptableConfigs();
		if (!string.IsNullOrEmpty(ConVar.World.configString))
		{
			Debug.Log((object)"Loading custom world config from world.configstring convar");
			World.Config.LoadFromJsonString(ConVar.World.configString);
		}
		else if (!string.IsNullOrEmpty(ConVar.World.configFile))
		{
			string text = ConVar.Server.rootFolder + "/" + ConVar.World.configFile;
			Debug.Log((object)("Loading custom world config from world.configfile convar: " + text));
			World.Config.LoadFromJsonFile(text);
		}
		World.ResetTiming();
		ProceduralComponent[] components = ((Component)this).GetComponentsInChildren<ProceduralComponent>(true);
		Timing downloadTimer = Timing.Start("Downloading World");
		if (World.Procedural && !World.CanLoadFromDisk() && World.CanLoadFromUrl())
		{
			LoadingScreen.Update("DOWNLOADING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			UnityWebRequest request = UnityWebRequest.Get(World.Url);
			request.downloadHandler = (DownloadHandler)new DownloadHandlerBuffer();
			request.Send();
			float lastProgress = 0f;
			while (!request.isDone)
			{
				if (ct.IsCancellationRequested)
				{
					yield break;
				}
				float downloadProgress = request.downloadProgress;
				if (!Mathf.Approximately(downloadProgress, lastProgress))
				{
					lastProgress = downloadProgress;
					LoadingScreen.Update($"DOWNLOADING WORLD {downloadProgress * 100f:0.0}%");
				}
				yield return CoroutineEx.waitForEndOfFrame;
			}
			if (!request.isHttpError && !request.isNetworkError)
			{
				World.Serialization.Load(request.downloadHandler.data);
				World.Serialization.Save(World.MapFolderName + "/" + World.MapFileName);
				World.Cached = true;
			}
			else
			{
				CancelSetup("Couldn't Download Level: " + World.Name + " (" + request.error + ")");
			}
		}
		downloadTimer.End();
		Timing loadTimer = Timing.Start("Loading World");
		if (World.Procedural && !World.Cached && World.CanLoadFromDisk())
		{
			LoadingScreen.Update("LOADING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.Load(World.MapFolderName + "/" + World.MapFileName);
			World.Cached = true;
		}
		loadTimer.End();
		if (World.Cached && 10 != World.Serialization.Version)
		{
			Debug.LogWarning((object)("World cache version mismatch: " + 10u + " != " + World.Serialization.Version));
			World.Serialization.Clear();
			World.Cached = false;
			if (World.CanLoadFromUrl())
			{
				CancelSetup("World File Outdated: " + World.Name);
			}
		}
		if (World.Cached && string.IsNullOrEmpty(World.Checksum))
		{
			World.Checksum = World.Serialization.Checksum;
		}
		World.Timestamp = World.Serialization.Timestamp;
		if (World.Cached)
		{
			World.InitSize(World.Serialization.world.size);
		}
		if ((Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.Setup();
		}
		if (Object.op_Implicit((Object)(object)terrain))
		{
			TerrainGenerator component = terrain.GetComponent<TerrainGenerator>();
			if (Object.op_Implicit((Object)(object)component))
			{
				if (World.Cached)
				{
					int cachedHeightMapResolution = World.GetCachedHeightMapResolution();
					int cachedSplatMapResolution = World.GetCachedSplatMapResolution();
					terrain = component.CreateTerrain(cachedHeightMapResolution, cachedSplatMapResolution);
				}
				else
				{
					terrain = component.CreateTerrain();
				}
				terrainMeta = terrain.GetComponent<TerrainMeta>();
				terrainMeta.Init();
				terrainMeta.SetupComponents();
				CreateObject(decorPrefab);
				CreateObject(grassPrefab);
				CreateObject(spawnPrefab);
			}
		}
		Timing spawnTimer = Timing.Start("Spawning World");
		if (World.Cached)
		{
			LoadingScreen.Update("SPAWNING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			if (ct.IsCancellationRequested || (Object)(object)TerrainMeta.HeightMap == (Object)null)
			{
				yield break;
			}
			TerrainMeta.HeightMap.FromByteArray(World.GetMap("terrain"));
			TerrainMeta.SplatMap.FromByteArray(World.GetMap("splat"));
			TerrainMeta.BiomeMap.FromByteArray(World.GetMap("biome"));
			TerrainMeta.TopologyMap.FromByteArray(World.GetMap("topology"));
			TerrainMeta.AlphaMap.FromByteArray(World.GetMap("alpha"));
			TerrainMeta.WaterMap.FromByteArray(World.GetMap("water"));
			IEnumerator worldSpawn = World.Spawn(0.2f, LoadingScreen.Update, ct);
			while (worldSpawn.MoveNext())
			{
				if (ct.IsCancellationRequested)
				{
					yield break;
				}
				yield return worldSpawn.Current;
			}
			TerrainMeta.Path.Clear();
			TerrainMeta.Path.Roads.AddRange(World.GetPaths("Road"));
			TerrainMeta.Path.AddRoad(TerrainMeta.Path.Roads, addToMaster: false);
			TerrainMeta.Path.Rivers.AddRange(World.GetPaths("River"));
			TerrainMeta.Path.Powerlines.AddRange(World.GetPaths("Powerline"));
			TerrainMeta.Path.Rails.AddRange(World.GetPaths("Rail"));
		}
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (DungeonBaseLink dungeonBaseLink in TerrainMeta.Path.DungeonBaseLinks)
			{
				if ((Object)(object)dungeonBaseLink != (Object)null)
				{
					dungeonBaseLink.Initialize();
				}
			}
		}
		spawnTimer.End();
		Timing loadPrefabsTimer = Timing.Start("Loading Monument Prefabs");
		if (!World.Cached && World.Procedural)
		{
			FileSystemBackend backend = FileSystem.Backend;
			AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
			if (assetBundleBackend != null)
			{
				List<string> requiredAssetScenes = AssetSceneManifest.Current.MonumentScenes;
				IEnumerator worldSpawn = assetBundleBackend.LoadAssetScenes(requiredAssetScenes);
				bool wantsCancel = false;
				float lastProgress = 0f;
				while (worldSpawn.MoveNext())
				{
					if (!wantsCancel && ct.IsCancellationRequested)
					{
						wantsCancel = true;
						Debug.LogWarning((object)"Cancel was requested but must wait for asset scenes to finish loading");
					}
					float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress(requiredAssetScenes);
					if (!Mathf.Approximately(assetSceneProgress, lastProgress))
					{
						lastProgress = assetSceneProgress;
						LoadingScreen.Update($"Loading Monument Prefabs {assetSceneProgress * 100f:0.0}%");
					}
					yield return worldSpawn.Current;
				}
			}
		}
		loadPrefabsTimer.End();
		Timing procgenTimer = Timing.Start("Processing World");
		if (components.Length != 0)
		{
			for (int i = 0; i < components.Length; i++)
			{
				ProceduralComponent component2 = components[i];
				if (Object.op_Implicit((Object)(object)component2) && component2.ShouldRun())
				{
					if (ct.IsCancellationRequested)
					{
						yield break;
					}
					uint seed = (uint)(World.Seed + i);
					LoadingScreen.Update(component2.Description.ToUpper());
					yield return CoroutineEx.waitForEndOfFrame;
					yield return CoroutineEx.waitForEndOfFrame;
					yield return CoroutineEx.waitForEndOfFrame;
					Timing timing = Timing.Start(component2.Description);
					if (Object.op_Implicit((Object)(object)component2))
					{
						component2.Process(seed);
					}
					timing.End();
				}
			}
		}
		procgenTimer.End();
		Timing saveTimer = Timing.Start("Saving World");
		if (ConVar.World.cache && World.Procedural && !World.Cached)
		{
			LoadingScreen.Update("SAVING WORLD");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.world.size = World.Size;
			World.AddPaths(TerrainMeta.Path.Roads);
			World.AddPaths(TerrainMeta.Path.Rivers);
			World.AddPaths(TerrainMeta.Path.Powerlines);
			World.AddPaths(TerrainMeta.Path.Rails);
			World.Serialization.Save(World.MapFolderName + "/" + World.MapFileName);
		}
		saveTimer.End();
		Timing checksumTimer = Timing.Start("Calculating Checksum");
		if (string.IsNullOrEmpty(World.Serialization.Checksum))
		{
			LoadingScreen.Update("CALCULATING CHECKSUM");
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			yield return CoroutineEx.waitForEndOfFrame;
			World.Serialization.CalculateChecksum();
		}
		checksumTimer.End();
		if (string.IsNullOrEmpty(World.Checksum))
		{
			World.Checksum = World.Serialization.Checksum;
		}
		Timing oceanTimer = Timing.Start("Ocean Patrol Paths");
		LoadingScreen.Update("OCEAN PATROL PATHS");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if ((BaseBoat.generate_paths && (Object)(object)TerrainMeta.Path != (Object)null) || ForceGenerateOceanPatrols)
		{
			TerrainMeta.Path.OceanPatrolFar = BaseBoat.GenerateOceanPatrolPath(200f);
		}
		else
		{
			Debug.Log((object)"Skipping ocean patrol paths, baseboat.generate_paths == false");
		}
		oceanTimer.End();
		Timing finalizeTimer = Timing.Start("Finalizing World");
		LoadingScreen.Update("FINALIZING WORLD");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (Object.op_Implicit((Object)(object)terrainMeta))
		{
			if (World.Procedural)
			{
				terrainMeta.BindShaderProperties();
				terrainMeta.PostSetupComponents();
			}
			TerrainMargin.Create();
		}
		finalizeTimer.End();
		Timing cleaningTimer = Timing.Start("Cleaning Up");
		LoadingScreen.Update("CLEANING UP");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		List<string> invalidAssets = FileSystem.Backend.UnloadBundles("monuments");
		FileSystemBackend backend2 = FileSystem.Backend;
		AssetBundleBackend val = (AssetBundleBackend)(object)((backend2 is AssetBundleBackend) ? backend2 : null);
		if (val != null)
		{
			List<string> unloadableScenes = AssetSceneManifest.Current.UnloadableScenes;
			yield return val.UnloadAssetScenes(unloadableScenes, (Action<string, Dictionary<string, GameObject>>)delegate(string sceneName, Dictionary<string, GameObject> prefabs)
			{
				foreach (var (item, _) in prefabs)
				{
					invalidAssets.Add(item);
				}
			});
		}
		foreach (string item2 in invalidAssets)
		{
			GameManager.server.preProcessed.Invalidate(item2);
			GameManifest.Invalidate(item2);
			PrefabAttribute.server.Invalidate(StringPool.Get(item2));
		}
		Resources.UnloadUnusedAssets();
		cleaningTimer.End();
		LoadingScreen.Update("DONE");
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		yield return CoroutineEx.waitForEndOfFrame;
		if (Object.op_Implicit((Object)(object)this))
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
	}

	private void CancelSetup(string msg)
	{
		Debug.LogError((object)msg);
		Application.Quit();
	}
}


using UnityEngine;

public class ApplyTerrainModifiers : MonoBehaviour
{
	protected void Awake()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		TerrainModifier[] modifiers = null;
		if (component.isServer)
		{
			modifiers = PrefabAttribute.server.FindAll<TerrainModifier>(component.prefabID);
		}
		((Component)this).transform.ApplyTerrainModifiers(modifiers);
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class TerrainCarve : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap))
		{
			TerrainMeta.AlphaMap.SetAlpha(position, 0f, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightAdd : TerrainModifier
{
	public float Delta = 1f;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			TerrainMeta.HeightMap.AddHeight(position, opacity * Delta * TerrainMeta.OneOverSize.y, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightRaise : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			TerrainMeta.HeightMap.RaiseHeight(position, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainHeightSet : TerrainModifier
{
	public enum Mode
	{
		Set,
		Raise,
		Lower
	}

	public Mode HeightMode;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
		{
			switch (HeightMode)
			{
			case Mode.Set:
				TerrainMeta.HeightMap.SetHeight(position, opacity, radius, fade);
				break;
			case Mode.Raise:
				TerrainMeta.HeightMap.RaiseHeight(position, opacity, radius, fade);
				break;
			case Mode.Lower:
				TerrainMeta.HeightMap.LowerHeight(position, opacity, radius, fade);
				break;
			}
		}
	}
}


public enum Mode
{
	Set,
	Raise,
	Lower
}


using System;
using UnityEngine;

public abstract class TerrainModifier : PrefabAttribute
{
	public float Opacity = 1f;

	public float Radius;

	public float Fade;

	public void Apply(Vector3 pos, float scale)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		float opacity = Opacity;
		float radius = scale * Radius;
		float fade = scale * Fade;
		Apply(pos, opacity, radius, fade);
	}

	protected abstract void Apply(Vector3 position, float opacity, float radius, float fade);

	protected override Type GetIndexedType()
	{
		return typeof(TerrainModifier);
	}
}


using UnityEngine;

public static class TerrainModifierEx
{
	public static void ApplyTerrainModifiers(this Transform transform, TerrainModifier[] modifiers, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		foreach (TerrainModifier obj in modifiers)
		{
			Vector3 val = Vector3.Scale(obj.worldPosition, scale);
			Vector3 pos2 = pos + rot * val;
			float y = scale.y;
			obj.Apply(pos2, y);
		}
	}

	public static void ApplyTerrainModifiers(this Transform transform, TerrainModifier[] modifiers)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		transform.ApplyTerrainModifiers(modifiers, transform.position, transform.rotation, transform.lossyScale);
	}
}


using UnityEngine;

public class TerrainPlacementBlocked : TerrainModifier
{
	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)TerrainMeta.PlacementMap))
		{
			TerrainMeta.PlacementMap.SetBlocked(position, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainSplatRemove : TerrainModifier
{
	public Enum SplatType;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap) && !TerrainMeta.TopologyMap.GetTopology(position, 8388608))
		{
			TerrainMeta.SplatMap.RemoveSplat(position, (int)SplatType, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainSplatSet : TerrainModifier
{
	public Enum SplatType;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap))
		{
			TerrainMeta.SplatMap.SetSplat(position, (int)SplatType, opacity, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainTopologyAdd : TerrainModifier
{
	[InspectorFlags]
	public Enum TopologyType = (Enum)512;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			TerrainMeta.TopologyMap.AddTopology(position, (int)TopologyType, radius, fade);
		}
	}
}


using UnityEngine;

public class TerrainTopologySet : TerrainModifier
{
	[InspectorFlags]
	public Enum TopologyType = (Enum)512;

	protected override void Apply(Vector3 position, float opacity, float radius, float fade)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Expected I4, but got Unknown
		if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			TerrainMeta.TopologyMap.SetTopology(position, (int)TopologyType, radius, fade);
		}
	}
}


using UnityEngine;

public class Monument : TerrainPlacement
{
	public float Radius;

	public float Fade = 10f;

	public bool AutoCliffSplat = true;

	public bool AutoCliffTopology = true;

	public bool RemoveExistingTopology;

	protected void OnDrawGizmosSelected()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, Radius);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, Radius - Fade);
	}

	protected override void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool useBlendMap = blendmap.isValid;
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData blenddata = new TextureData(useBlendMap ? blendmap.Get() : null);
		float num = (useBlendMap ? extents.x : Radius);
		float num2 = (useBlendMap ? extents.z : Radius);
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - num, 0f, 0f - num2));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(num, 0f, 0f - num2));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - num, 0f, num2));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(num, 0f, num2));
		TerrainMeta.HeightMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_0176: Unknown result type (might be due to invalid IL or missing references)
			//IL_019e: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.HeightMap.Coordinate(z);
			float normX = TerrainMeta.HeightMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num3 = 1f;
			num3 = ((!useBlendMap) ? Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2)) : blenddata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z).w);
			if (num3 != 0f)
			{
				int num4 = Mathx.Min(x, z, TerrainMeta.HeightMap.res - 1 - x, TerrainMeta.HeightMap.res - 1 - z);
				if (num4 < 10)
				{
					num3 *= Mathf.SmoothStep(0f, 1f, Mathf.InverseLerp(0f, 10f, (float)num4));
				}
				if (num3 != 0f)
				{
					float num5 = TerrainMeta.NormalizeY(position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y);
					num5 = Mathf.SmoothStep(TerrainMeta.HeightMap.GetHeight01(x, z), num5, num3);
					TerrainMeta.HeightMap.SetHeight(x, z, num5);
				}
			}
		});
	}

	protected override void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool should0 = ShouldSplat(1);
		bool should1 = ShouldSplat(2);
		bool should2 = ShouldSplat(4);
		bool should3 = ShouldSplat(8);
		bool should4 = ShouldSplat(16);
		bool should5 = ShouldSplat(32);
		bool should6 = ShouldSplat(64);
		bool should7 = ShouldSplat(128);
		if (!should0 && !should1 && !should2 && !should3 && !should4 && !should5 && !should6 && !should7)
		{
			return;
		}
		TextureData splat0data = new TextureData(splatmap0.Get());
		TextureData splat1data = new TextureData(splatmap1.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.SplatMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
			//IL_0125: Unknown result type (might be due to invalid IL or missing references)
			//IL_014d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0152: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
			if (AutoCliffSplat)
			{
				GenerateCliffSplat.Process(x, z);
			}
			float normZ = TerrainMeta.SplatMap.Coordinate(z);
			float normX = TerrainMeta.SplatMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				Vector4 interpolatedVector = splat0data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				Vector4 interpolatedVector2 = splat1data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				if (!should0)
				{
					interpolatedVector.x = 0f;
				}
				if (!should1)
				{
					interpolatedVector.y = 0f;
				}
				if (!should2)
				{
					interpolatedVector.z = 0f;
				}
				if (!should3)
				{
					interpolatedVector.w = 0f;
				}
				if (!should4)
				{
					interpolatedVector2.x = 0f;
				}
				if (!should5)
				{
					interpolatedVector2.y = 0f;
				}
				if (!should6)
				{
					interpolatedVector2.z = 0f;
				}
				if (!should7)
				{
					interpolatedVector2.w = 0f;
				}
				TerrainMeta.SplatMap.SetSplatRaw(x, z, interpolatedVector, interpolatedVector2, num);
			}
		});
	}

	protected override void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		TextureData alphadata = new TextureData(alphamap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.AlphaMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.AlphaMap.Coordinate(z);
			float normX = TerrainMeta.AlphaMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				float w = alphadata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z).w;
				TerrainMeta.AlphaMap.SetAlpha(x, z, w, num);
			}
		});
	}

	protected override void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		bool should0 = ShouldBiome(1);
		bool should1 = ShouldBiome(2);
		bool should2 = ShouldBiome(4);
		bool should3 = ShouldBiome(8);
		bool should4 = ShouldBiome(16);
		if (!should0 && !should1 && !should2 && !should3 && !should4)
		{
			return;
		}
		TextureData biomedata = new TextureData(biomemap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.BiomeMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.BiomeMap.Coordinate(z);
			float normX = TerrainMeta.BiomeMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = Mathf.InverseLerp(Radius, Radius - Fade, Vector3Ex.Magnitude2D(val2));
			if (num != 0f)
			{
				Vector4 interpolatedVector = biomedata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				float num2 = interpolatedVector.x;
				float num3 = interpolatedVector.y;
				float num4 = interpolatedVector.z;
				float num5 = interpolatedVector.w;
				float biome = 1f - num2 - num3 - num4 - num5;
				if (!should0)
				{
					num2 = 0f;
				}
				if (!should1)
				{
					num3 = 0f;
				}
				if (!should2)
				{
					num4 = 0f;
				}
				if (!should3)
				{
					num5 = 0f;
				}
				if (!should4)
				{
					biome = 0f;
				}
				TerrainMeta.BiomeMap.SetBiomeRaw(x, z, num2, num3, num4, num5, biome, num);
			}
		});
	}

	protected override void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (Radius == 0f)
		{
			Radius = extents.x;
		}
		TextureData topologydata = new TextureData(topologymap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, 0f - Radius));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, 0f - Radius));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - Radius, 0f, Radius));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(Radius, 0f, Radius));
		TerrainMeta.TopologyMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00de: Expected I4, but got Unknown
			//IL_0103: Unknown result type (might be due to invalid IL or missing references)
			//IL_0108: Unknown result type (might be due to invalid IL or missing references)
			//IL_010e: Expected I4, but got Unknown
			float normZ = TerrainMeta.TopologyMap.Coordinate(z);
			float normX = TerrainMeta.TopologyMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			int interpolatedInt = topologydata.GetInterpolatedInt((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
			bool num = ShouldTopology(interpolatedInt);
			if (num && RemoveExistingTopology)
			{
				TerrainMeta.TopologyMap.RemoveTopology(x, z, (int)TopologyMask);
			}
			if (AutoCliffTopology)
			{
				GenerateCliffTopology.Process(x, z);
			}
			if (num)
			{
				TerrainMeta.TopologyMap.AddTopology(x, z, interpolatedInt & TopologyMask);
			}
		});
	}

	protected override void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}
}


using UnityEngine;

public class Mountain : TerrainPlacement
{
	public float Fade = 10f;

	public bool AutoCliffSplat;

	public bool AutoCliffTopology = true;

	protected void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.up * (0.5f * Fade);
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		Gizmos.DrawCube(((Component)this).transform.position + val, new Vector3(size.x, Fade, size.z));
		Gizmos.DrawWireCube(((Component)this).transform.position + val, new Vector3(size.x, Fade, size.z));
	}

	protected override void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.HeightMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.HeightMap.Coordinate(z);
			float normX = TerrainMeta.HeightMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				float num3 = TerrainMeta.NormalizeY(num);
				num3 = Mathx.SmoothMax(TerrainMeta.HeightMap.GetHeight01(x, z), num3, 0.1f);
				TerrainMeta.HeightMap.SetHeight(x, z, num3, num2);
			}
		});
	}

	protected override void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		bool should0 = ShouldSplat(1);
		bool should1 = ShouldSplat(2);
		bool should2 = ShouldSplat(4);
		bool should3 = ShouldSplat(8);
		bool should4 = ShouldSplat(16);
		bool should5 = ShouldSplat(32);
		bool should6 = ShouldSplat(64);
		bool should7 = ShouldSplat(128);
		if (!should0 && !should1 && !should2 && !should3 && !should4 && !should5 && !should6 && !should7)
		{
			return;
		}
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData splat0data = new TextureData(splatmap0.Get());
		TextureData splat1data = new TextureData(splatmap1.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.SplatMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0083: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_0127: Unknown result type (might be due to invalid IL or missing references)
			//IL_014f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_017c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0184: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_0282: Unknown result type (might be due to invalid IL or missing references)
			//IL_0284: Unknown result type (might be due to invalid IL or missing references)
			if (AutoCliffSplat)
			{
				GenerateCliffSplat.Process(x, z);
			}
			float normZ = TerrainMeta.SplatMap.Coordinate(z);
			float normX = TerrainMeta.SplatMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				Vector4 interpolatedVector = splat0data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				Vector4 interpolatedVector2 = splat1data.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				if (!should0)
				{
					interpolatedVector.x = 0f;
				}
				if (!should1)
				{
					interpolatedVector.y = 0f;
				}
				if (!should2)
				{
					interpolatedVector.z = 0f;
				}
				if (!should3)
				{
					interpolatedVector.w = 0f;
				}
				if (!should4)
				{
					interpolatedVector2.x = 0f;
				}
				if (!should5)
				{
					interpolatedVector2.y = 0f;
				}
				if (!should6)
				{
					interpolatedVector2.z = 0f;
				}
				if (!should7)
				{
					interpolatedVector2.w = 0f;
				}
				TerrainMeta.SplatMap.SetSplatRaw(x, z, interpolatedVector, interpolatedVector2, num2);
			}
		});
	}

	protected override void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}

	protected override void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		bool should0 = ShouldBiome(1);
		bool should1 = ShouldBiome(2);
		bool should2 = ShouldBiome(4);
		bool should3 = ShouldBiome(8);
		bool should4 = ShouldBiome(16);
		if (!should0 && !should1 && !should2 && !should3 && !should4)
		{
			return;
		}
		Vector3 position = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(Vector3.zero);
		TextureData heightdata = new TextureData(heightmap.Get());
		TextureData biomedata = new TextureData(biomemap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.BiomeMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_013b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0163: Unknown result type (might be due to invalid IL or missing references)
			//IL_0168: Unknown result type (might be due to invalid IL or missing references)
			//IL_0170: Unknown result type (might be due to invalid IL or missing references)
			//IL_0178: Unknown result type (might be due to invalid IL or missing references)
			float normZ = TerrainMeta.BiomeMap.Coordinate(z);
			float normX = TerrainMeta.BiomeMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			float num = position.y + offset.y + heightdata.GetInterpolatedHalf((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z) * size.y;
			float num2 = Mathf.InverseLerp(position.y, position.y + Fade, num);
			if (num2 != 0f)
			{
				Vector4 interpolatedVector = biomedata.GetInterpolatedVector((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
				float num3 = interpolatedVector.x;
				float num4 = interpolatedVector.y;
				float num5 = interpolatedVector.z;
				float num6 = interpolatedVector.w;
				float biome = 1f - num3 - num4 - num5 - num6;
				if (!should0)
				{
					num3 = 0f;
				}
				if (!should1)
				{
					num4 = 0f;
				}
				if (!should2)
				{
					num5 = 0f;
				}
				if (!should3)
				{
					num6 = 0f;
				}
				if (!should4)
				{
					biome = 0f;
				}
				TerrainMeta.BiomeMap.SetBiomeRaw(x, z, num3, num4, num5, num6, biome, num2);
			}
		});
	}

	protected override void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		TextureData topologydata = new TextureData(topologymap.Get());
		Vector3 v = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, 0f - extents.z));
		Vector3 v2 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, 0f - extents.z));
		Vector3 v3 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(0f - extents.x, 0f, extents.z));
		Vector3 v4 = ((Matrix4x4)(ref localToWorld)).MultiplyPoint3x4(offset + new Vector3(extents.x, 0f, extents.z));
		TerrainMeta.TopologyMap.ForEachParallel(v, v2, v3, v4, delegate(int x, int z)
		{
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_008f: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e7: Expected I4, but got Unknown
			if (AutoCliffTopology)
			{
				GenerateCliffTopology.Process(x, z);
			}
			float normZ = TerrainMeta.TopologyMap.Coordinate(z);
			float normX = TerrainMeta.TopologyMap.Coordinate(x);
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ));
			Vector3 val2 = ((Matrix4x4)(ref worldToLocal)).MultiplyPoint3x4(val) - offset;
			int interpolatedInt = topologydata.GetInterpolatedInt((val2.x + extents.x) / size.x, (val2.z + extents.z) / size.z);
			if (ShouldTopology(interpolatedInt))
			{
				TerrainMeta.TopologyMap.AddTopology(x, z, interpolatedInt & TopologyMask);
			}
		});
	}

	protected override void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
	}
}


using System;
using UnityEngine;

public abstract class TerrainPlacement : PrefabAttribute
{
	[ReadOnly]
	public Vector3 size = Vector3.zero;

	[ReadOnly]
	public Vector3 extents = Vector3.zero;

	[ReadOnly]
	public Vector3 offset = Vector3.zero;

	public bool HeightMap = true;

	public bool AlphaMap = true;

	public bool WaterMap;

	[InspectorFlags]
	public Enum SplatMask;

	[InspectorFlags]
	public Enum BiomeMask;

	[InspectorFlags]
	public Enum TopologyMask;

	[HideInInspector]
	public Texture2DRef heightmap;

	[HideInInspector]
	public Texture2DRef splatmap0;

	[HideInInspector]
	public Texture2DRef splatmap1;

	[HideInInspector]
	public Texture2DRef alphamap;

	[HideInInspector]
	public Texture2DRef biomemap;

	[HideInInspector]
	public Texture2DRef topologymap;

	[HideInInspector]
	public Texture2DRef watermap;

	[HideInInspector]
	public Texture2DRef blendmap;

	public void Apply(Matrix4x4 localToWorld, Matrix4x4 worldToLocal)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (ShouldHeight())
		{
			ApplyHeight(localToWorld, worldToLocal);
		}
		if (ShouldSplat())
		{
			ApplySplat(localToWorld, worldToLocal);
		}
		if (ShouldAlpha())
		{
			ApplyAlpha(localToWorld, worldToLocal);
		}
		if (ShouldBiome())
		{
			ApplyBiome(localToWorld, worldToLocal);
		}
		if (ShouldTopology())
		{
			ApplyTopology(localToWorld, worldToLocal);
		}
		if (ShouldWater())
		{
			ApplyWater(localToWorld, worldToLocal);
		}
	}

	protected bool ShouldHeight()
	{
		if (heightmap.isValid)
		{
			return HeightMap;
		}
		return false;
	}

	protected bool ShouldSplat(int id = -1)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Invalid comparison between Unknown and I4
		if (splatmap0.isValid && splatmap1.isValid)
		{
			return (SplatMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldAlpha()
	{
		if (alphamap.isValid)
		{
			return AlphaMap;
		}
		return false;
	}

	protected bool ShouldBiome(int id = -1)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (biomemap.isValid)
		{
			return (BiomeMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldTopology(int id = -1)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (topologymap.isValid)
		{
			return (TopologyMask & id) > 0;
		}
		return false;
	}

	protected bool ShouldWater()
	{
		if (watermap.isValid)
		{
			return WaterMap;
		}
		return false;
	}

	protected abstract void ApplyHeight(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplySplat(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyAlpha(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyBiome(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyTopology(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected abstract void ApplyWater(Matrix4x4 localToWorld, Matrix4x4 worldToLocal);

	protected override Type GetIndexedType()
	{
		return typeof(TerrainPlacement);
	}
}


using UnityEngine;

public static class TerrainPlacementEx
{
	public static void ApplyTerrainPlacements(this Transform transform, TerrainPlacement[] placements, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (placements.Length != 0)
		{
			for (int i = 0; i < placements.Length; i++)
			{
				TerrainPlacement terrainPlacement = placements[i];
				Vector3 val = pos + rot * Vector3.Scale(terrainPlacement.worldPosition, scale);
				Quaternion val2 = rot * terrainPlacement.worldRotation;
				Matrix4x4 localToWorld = Matrix4x4.TRS(val, val2, scale);
				Matrix4x4 inverse = ((Matrix4x4)(ref localToWorld)).inverse;
				placements[i].Apply(localToWorld, inverse);
			}
		}
	}

	public static void ApplyTerrainPlacements(this Transform transform, TerrainPlacement[] placements)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		transform.ApplyTerrainPlacements(placements, transform.position, transform.rotation, transform.lossyScale);
	}
}


using System.IO;
using Rust.Water5;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

[CreateAssetMenu(fileName = "New Ocean Settings", menuName = "Water5/Ocean Settings")]
public class OceanSettings : ScriptableObject
{
	[Header("Compute Shaders")]
	public ComputeShader waveSpectrumCompute;

	public ComputeShader fftCompute;

	public ComputeShader waveMergeCompute;

	public ComputeShader waveInitialSpectrum;

	[Header("Global Ocean Params")]
	public float[] octaveScales;

	public float lamda;

	public float windDirection;

	public float distanceAttenuationFactor;

	public float depthAttenuationFactor;

	[Header("Ocean Spectra")]
	public OceanSpectrumSettings[] spectrumSettings;

	[HideInInspector]
	public float[] spectrumRanges;

	public unsafe OceanDisplacementShort3[,,] LoadSimData()
	{
		OceanDisplacementShort3[,,] array = new OceanDisplacementShort3[spectrumSettings.Length, 72, 65536];
		string path = Application.streamingAssetsPath + "/" + ((Object)this).name + ".physicsdata.dat";
		if (!File.Exists(path))
		{
			Debug.Log((object)"Simulation Data not found");
			return array;
		}
		byte[] array2 = File.ReadAllBytes(path);
		fixed (byte* ptr2 = array2)
		{
			fixed (OceanDisplacementShort3* ptr = array)
			{
				UnsafeUtility.MemCpy((void*)ptr, (void*)ptr2, (long)array2.Length);
			}
		}
		return array;
	}

	internal unsafe NativeOceanDisplacementShort3 LoadNativeSimData()
	{
		NativeOceanDisplacementShort3 result = NativeOceanDisplacementShort3.Create(spectrumSettings.Length, 72, 65536);
		string path = Application.streamingAssetsPath + "/" + ((Object)this).name + ".physicsdata.dat";
		if (!File.Exists(path))
		{
			Debug.Log((object)"Simulation Data not found");
			return result;
		}
		byte[] array = File.ReadAllBytes(path);
		OceanDisplacementShort3* unsafePtr = result.GetUnsafePtr();
		fixed (byte* ptr = array)
		{
			UnsafeUtility.MemCpy((void*)unsafePtr, (void*)ptr, (long)array.Length);
		}
		return result;
	}
}


public enum WaterBodyType
{
	Ocean = 1,
	River = 2,
	Lake = 4,
	Pool = 8,
	Moonpool = 0x10,
	Radioactive = 0x20
}


using System;
using UnityEngine;

[ExecuteInEditMode]
public class WaterBody : MonoBehaviour
{
	[Flags]
	public enum FishingTag
	{
		MoonPool = 1,
		River = 2,
		Ocean = 4,
		Swamp = 8
	}

	public WaterBodyType Type = WaterBodyType.Lake;

	public Renderer Renderer;

	public Collider[] Triggers;

	public bool IsOcean;

	public FishingTag FishingType;

	public Transform Transform { get; private set; }

	private void Awake()
	{
		Transform = ((Component)this).transform;
	}

	private void OnEnable()
	{
		WaterSystem.RegisterBody(this);
	}

	private void OnDisable()
	{
		WaterSystem.UnregisterBody(this);
	}

	public void OnOceanLevelChanged(float newLevel)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		if (!IsOcean || Triggers == null || Triggers.Length == 0)
		{
			return;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				Vector3 position = ((Component)val).transform.position;
				position.y = newLevel;
				((Component)val).transform.position = position;
			}
		}
	}

	public float MinWaterLevel()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = ((Component)this).transform.position.y;
		if (Triggers == null || Triggers.Length == 0)
		{
			return num;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				float num2 = num;
				Bounds bounds = val.bounds;
				num = Mathf.Min(num2, ((Bounds)(ref bounds)).max.y);
			}
		}
		return num;
	}

	public float SqrDistance(Vector3 point)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Triggers == null || Triggers.Length == 0)
		{
			return num;
		}
		Collider[] triggers = Triggers;
		foreach (Collider val in triggers)
		{
			if (!((Object)(object)val == (Object)null))
			{
				MeshCollider val2 = (MeshCollider)(object)((val is MeshCollider) ? val : null);
				Vector3 val3;
				if ((Object)(object)val2 == (Object)null || val2.convex)
				{
					float num2 = num;
					val3 = val.ClosestPoint(point) - point;
					num = Mathf.Min(num2, ((Vector3)(ref val3)).sqrMagnitude);
				}
				else
				{
					float num3 = num;
					val3 = val.ClosestPointOnBounds(point) - point;
					num = Mathf.Min(num3, ((Vector3)(ref val3)).sqrMagnitude);
				}
			}
		}
		return num;
	}

	public int GetTopologyMask()
	{
		return Type switch
		{
			WaterBodyType.Lake => 65536, 
			WaterBodyType.Ocean => 128, 
			WaterBodyType.River => 16384, 
			WaterBodyType.Moonpool => 128, 
			WaterBodyType.Pool => 65536, 
			_ => 65536, 
		};
	}
}


using System;

[Flags]
public enum FishingTag
{
	MoonPool = 1,
	River = 2,
	Ocean = 4,
	Swamp = 8
}


using UnityEngine;

[RequireComponent(typeof(PostOpaqueDepth))]
[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class WaterCamera : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public class WaterCollision : MonoBehaviour
{
	private ListDictionary<Collider, List<Collider>> ignoredColliders;

	private HashSet<Collider> waterColliders;

	private WaterVisibilityGrid visibilityGrid;

	public const float IgnoreRadius = 0.01f;

	public WaterVisibilityGrid VisibilityGrid => visibilityGrid;

	public void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		waterColliders = new HashSet<Collider>();
		if (visibilityGrid != null)
		{
			visibilityGrid.Dispose();
		}
		visibilityGrid = new WaterVisibilityGrid();
	}

	private void OnDestroy()
	{
		visibilityGrid?.Dispose();
	}

	public void Clear()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (waterColliders.Count == 0)
		{
			return;
		}
		HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
		while (enumerator.MoveNext())
		{
			Enumerator<Collider> enumerator2 = ignoredColliders.Keys.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					Physics.IgnoreCollision(enumerator2.Current, enumerator.Current, false);
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if (waterColliders.Count != 0 && Object.op_Implicit((Object)(object)collider))
		{
			HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
			while (enumerator.MoveNext())
			{
				Physics.IgnoreCollision(collider, enumerator.Current, false);
			}
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(pos, radius))
		{
			return false;
		}
		return GamePhysics.CheckSphere<WaterVisibilityTrigger>(pos, radius, 262144, (QueryTriggerInteraction)2);
	}

	public void GetIgnore(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnore", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> val2 = new NativeList<int>(positions.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val3;
			if (visibilityGrid != null)
			{
				val3 = visibilityGrid.Check(positions, radii, val2);
			}
			else
			{
				GenerateAscSeqListJob generateAscSeqListJob = default(GenerateAscSeqListJob);
				generateAscSeqListJob.Values = val2;
				generateAscSeqListJob.Start = 0;
				generateAscSeqListJob.Step = 1;
				generateAscSeqListJob.Count = positions.Length;
				val3 = IJobExtensions.Schedule<GenerateAscSeqListJob>(generateAscSeqListJob, default(JobHandle));
			}
			((JobHandle)(ref val3)).Complete();
			if (!val2.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = positions;
				gatherJob.Indices = val2.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = val2.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				GamePhysics.CheckSpheres<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref results), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				Span<bool> values2 = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = val2.AsReadOnly();
				CollectionUtil.ScatterOutInplace(values2, ReadOnly<int>.op_Implicit(ref val4), defValue: false);
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetIgnoreIndirect(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> indices, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnoreIndirect", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> list = new NativeList<int>(indices.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val2 = default(JobHandle);
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.CheckIndirect(pos, radii, indices, list);
			}
			else
			{
				list.CopyFrom(in indices);
			}
			((JobHandle)(ref val2)).Complete();
			if (!list.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = pos;
				gatherJob.Indices = list.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = list.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				NativeArray<bool> val3 = default(NativeArray<bool>);
				val3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GamePhysics.CheckSpheres<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref val3), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				ReadOnlySpan<bool> from = NativeArray<bool>.op_Implicit(ref val3);
				Span<bool> to = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = list.AsReadOnly();
				CollectionUtil.ScatterTo(from, to, ReadOnly<int>.op_Implicit(ref val4));
				val3.Dispose();
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			list.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(Bounds bounds)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(bounds))
		{
			return false;
		}
		return GamePhysics.CheckBounds<WaterVisibilityTrigger>(bounds, 262144, (QueryTriggerInteraction)2);
	}

	public bool GetIgnore(Vector3 start, Vector3 end, float radius)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		WaterVisibilityGrid waterVisibilityGrid = visibilityGrid;
		if (waterVisibilityGrid != null && !waterVisibilityGrid.Check(start, end, radius))
		{
			return false;
		}
		return GamePhysics.CheckCapsule<WaterVisibilityTrigger>(start, end, radius, 262144, (QueryTriggerInteraction)2);
	}

	public void GetIgnoreIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("WaterCollision.GetIgnoreIndirect", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> list = new NativeList<int>(indices.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val2 = default(JobHandle);
			if (visibilityGrid != null)
			{
				val2 = visibilityGrid.CheckIndirect(starts, ends, radii, indices, list);
			}
			else
			{
				list.CopyFrom(in indices);
			}
			((JobHandle)(ref val2)).Complete();
			if (!list.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = starts;
				gatherJob.Indices = list.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<Vector3> results3 = default(NativeArray<Vector3>);
				results3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results3;
				gatherJob.Source = ends;
				gatherJob.Indices = list.AsReadOnly();
				GatherJob<Vector3> gatherJob3 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob3);
				NativeArray<float> results4 = default(NativeArray<float>);
				results4..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob4 = default(GatherJob<float>);
				gatherJob4.Results = results4;
				gatherJob4.Source = radii;
				gatherJob4.Indices = list.AsReadOnly();
				GatherJob<float> gatherJob5 = gatherJob4;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob5);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				NativeArray<bool> val3 = default(NativeArray<bool>);
				val3..ctor(list.Length, (Allocator)3, (NativeArrayOptions)0);
				GamePhysics.CheckCapsules<WaterVisibilityTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), results4.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref val3), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None, mitigateSpheres: true);
				ReadOnlySpan<bool> from = NativeArray<bool>.op_Implicit(ref val3);
				Span<bool> to = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = list.AsReadOnly();
				CollectionUtil.ScatterTo(from, to, ReadOnly<int>.op_Implicit(ref val4));
				val3.Dispose();
				values.Dispose();
				results4.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			list.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(RaycastHit hit)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (waterColliders.Contains(((RaycastHit)(ref hit)).collider))
		{
			return GetIgnore(((RaycastHit)(ref hit)).point);
		}
		return false;
	}

	public bool GetIgnore(Collider collider)
	{
		if (waterColliders.Count == 0 || !Object.op_Implicit((Object)(object)collider))
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (waterColliders.Count == 0 || !Object.op_Implicit((Object)(object)collider))
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> list = new List<Collider> { trigger };
				HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Physics.IgnoreCollision(collider, enumerator.Current, true);
				}
				ignoredColliders.Add(collider, list);
			}
			return;
		}
		List<Collider> list2 = ignoredColliders[collider];
		if (ignore)
		{
			if (!list2.Contains(trigger))
			{
				list2.Add(trigger);
			}
		}
		else if (list2.Contains(trigger))
		{
			list2.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if ((Object)(object)key == (Object)null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				HashSet<Collider>.Enumerator enumerator = waterColliders.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Physics.IgnoreCollision(key, enumerator.Current, false);
				}
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class WaterCullingVolume : MonoBehaviour
{
	public bool isDynamic;
}


using UnityEngine;

public class WaterDepthMask : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class WaterInteraction : MonoBehaviour
{
	[SerializeField]
	private Texture2D texture;

	[Range(0f, 1f)]
	public float Displacement = 1f;

	[Range(0f, 1f)]
	public float Disturbance = 0.5f;
}


public enum WaterQuality
{
	Low,
	Medium,
	High
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Water5;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using WaterSystemJobs;

[ExecuteInEditMode]
public class WaterSystem : MonoBehaviour
{
	[Serializable]
	public class RenderingSettings
	{
		[Serializable]
		public class SkyProbe
		{
			public float ProbeUpdateInterval = 1f;

			public bool TimeSlicing = true;
		}

		[Serializable]
		public class SSR
		{
			public float FresnelCutoff = 0.02f;

			public float ThicknessMin = 1f;

			public float ThicknessMax = 20f;

			public float ThicknessStartDist = 40f;

			public float ThicknessEndDist = 100f;
		}

		public Vector4[] TessellationQuality;

		public SkyProbe SkyReflections;

		public SSR ScreenSpaceReflections;
	}

	private static float oceanLevel = 0f;

	[Header("Ocean Settings")]
	public OceanSettings oceanSettings;

	public OceanSimulation oceanSimulation;

	public WaterQuality Quality = WaterQuality.High;

	public Material oceanMaterial;

	public RenderingSettings Rendering = new RenderingSettings();

	public ComputeShader oceanVFaceShader;

	public int patchSize = 100;

	public int patchCount = 4;

	public float patchScale = 1f;

	public static WaterSystem Instance { get; private set; }

	public static WaterCollision Collision { get; private set; }

	public static WaterBody Ocean { get; private set; }

	public static Material OceanMaterial => Instance?.oceanMaterial;

	public static ListHashSet<WaterCamera> WaterCameras { get; } = new ListHashSet<WaterCamera>();

	public static HashSet<WaterBody> WaterBodies { get; } = new HashSet<WaterBody>();

	public static HashSet<WaterDepthMask> DepthMasks { get; } = new HashSet<WaterDepthMask>();

	public static float WaveTime { get; private set; }

	public static ComputeShader OceanVFaceShader => Instance?.oceanVFaceShader;

	public static float OceanLevel
	{
		get
		{
			return oceanLevel;
		}
		set
		{
			value = Mathf.Max(value, 0f);
			if (!Mathf.Approximately(oceanLevel, value))
			{
				oceanLevel = value;
				UpdateOceanLevel();
			}
		}
	}

	public bool IsInitialized { get; private set; }

	public int Layer => ((Component)this).gameObject.layer;

	public int Reflections => Water.reflections;

	public float WindDirection => oceanSettings.windDirection;

	public float[] OctaveScales => oceanSettings.octaveScales;

	private void CheckInstance()
	{
		Instance = (((Object)(object)Instance != (Object)null) ? Instance : this);
		Collision = (((Object)(object)Collision != (Object)null) ? Collision : ((Component)this).GetComponent<WaterCollision>());
	}

	private void Awake()
	{
		CheckInstance();
	}

	private void OnEnable()
	{
		CheckInstance();
		oceanSimulation = new OceanSimulation(oceanSettings);
		IsInitialized = true;
	}

	private void OnDisable()
	{
		if (!Application.isPlaying || !Application.isQuitting)
		{
			oceanSimulation.Dispose();
			oceanSimulation = null;
			IsInitialized = false;
			Instance = null;
		}
	}

	private void Update()
	{
		TimeWarning val = TimeWarning.New("UpdateWaves", 0);
		try
		{
			UpdateOceanSimulation();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool Trace(Ray ray, out Vector3 position, float maxDist = 100f)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			position = Vector3.zero;
			return false;
		}
		if (Instance.oceanSimulation.Trace(ray, maxDist, out position) && TerrainMeta.TopologyMap.GetTopology(position, 384))
		{
			return true;
		}
		return false;
	}

	public static bool Trace(Ray ray, out Vector3 position, out Vector3 normal, float maxDist = 100f)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			position = Vector3.zero;
			normal = Vector3.zero;
			return false;
		}
		normal = Vector3.up;
		if (Instance.oceanSimulation.Trace(ray, maxDist, out position) && TerrainMeta.TopologyMap.GetTopology(position, 384))
		{
			return true;
		}
		return false;
	}

	public static JobHandle ScheduleTraceBatchDefer(NativeList<Ray> rays, NativeArray<float> maxDists, NativeArray<bool> hitResults, NativeArray<Vector3> hitPositions, NativeArray<Vector3> hitNormals, JobHandle inputDeps)
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Instance == (Object)null)
		{
			FillFalseJobDefer fillFalseJobDefer = default(FillFalseJobDefer);
			fillFalseJobDefer.rays = rays;
			fillFalseJobDefer.HitResults = hitResults;
			inputDeps = IJobParallelForDeferExtensions.Schedule<FillFalseJobDefer, Ray>(fillFalseJobDefer, rays, 256, inputDeps);
			return inputDeps;
		}
		inputDeps = Instance.oceanSimulation.TraceBatch(rays, maxDists, hitResults, hitPositions, inputDeps);
		AdjustByTopologyJob adjustByTopologyJob = default(AdjustByTopologyJob);
		adjustByTopologyJob.rays = rays;
		adjustByTopologyJob.hitResults = hitResults;
		adjustByTopologyJob.hitNormals = hitNormals;
		adjustByTopologyJob.hitPositions = hitPositions.AsReadOnly();
		adjustByTopologyJob.TopologyData = TerrainMeta.TopologyMap.src;
		adjustByTopologyJob.TopologyRes = TerrainMeta.TopologyMap.res;
		adjustByTopologyJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		adjustByTopologyJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		inputDeps = IJobParallelForDeferExtensions.Schedule<AdjustByTopologyJob, Ray>(adjustByTopologyJob, rays, 256, inputDeps);
		return inputDeps;
	}

	public static void GetHeightArray_Managed(Vector2[] pos, Vector2[] posUV, float[] shore, float[] terrainHeight, float[] waterHeight)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainTexturing.Instance != (Object)null)
		{
			for (int i = 0; i < posUV.Length; i++)
			{
				shore[i] = TerrainTexturing.Instance.GetCoarseDistanceToShore(posUV[i]);
			}
		}
		else
		{
			Array.Fill(shore, 0f, 0, posUV.Length);
		}
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			for (int j = 0; j < posUV.Length; j++)
			{
				terrainHeight[j] = TerrainMeta.HeightMap.GetHeightFast(posUV[j]);
			}
		}
		else
		{
			Array.Fill(terrainHeight, 0f, 0, posUV.Length);
		}
		if ((Object)(object)Instance != (Object)null && Object.op_Implicit((Object)(object)TerrainMeta.WaterMap) && Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
		{
			bool flag = false;
			for (int k = 0; k < posUV.Length; k++)
			{
				Vector2 val = posUV[k];
				float num = TerrainMeta.WaterMap.GetHeightFast(val);
				if (num < OceanLevel + Instance.oceanSimulation.MaxLevel() && TerrainMeta.TopologyMap.GetTopology(val.x, val.y, 384))
				{
					if (!flag)
					{
						Instance.oceanSimulation.GetHeightBatch(pos, waterHeight, shore, terrainHeight);
						flag = true;
					}
					float num2 = waterHeight[k] + OceanLevel;
					num = Mathf.Max(num, num2);
				}
				waterHeight[k] = num;
			}
		}
		else if ((Object)(object)Instance != (Object)null)
		{
			Instance.oceanSimulation.GetHeightBatch(pos, waterHeight, shore, terrainHeight);
			for (int l = 0; l < pos.Length; l++)
			{
				waterHeight[l] += OceanLevel;
			}
		}
		else
		{
			Array.Fill(waterHeight, OceanLevel, 0, pos.Length);
		}
	}

	public static void GetHeightArray(Vector2[] pos, Vector2[] posUV, float[] shore, float[] terrainHeight, float[] waterHeight)
	{
		GetHeightArray_Managed(pos, posUV, shore, terrainHeight, waterHeight);
	}

	public static void RegisterBody(WaterBody body)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (body.Type == WaterBodyType.Ocean)
		{
			if ((Object)(object)Ocean == (Object)null)
			{
				Ocean = body;
				body.Transform.position = Vector3Ex.WithY(body.Transform.position, OceanLevel);
			}
			else if ((Object)(object)Ocean != (Object)(object)body)
			{
				Debug.LogWarning((object)"[Water] Ocean body is already registered. Ignoring call because only one is allowed.");
				return;
			}
		}
		WaterBodies.Add(body);
	}

	public static void UnregisterBody(WaterBody body)
	{
		if ((Object)(object)body == (Object)(object)Ocean)
		{
			Ocean = null;
		}
		WaterBodies.Remove(body);
	}

	private static void UpdateOceanLevel()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Ocean != (Object)null)
		{
			Ocean.Transform.position = Vector3Ex.WithY(Ocean.Transform.position, OceanLevel);
		}
		foreach (WaterBody waterBody in WaterBodies)
		{
			waterBody.OnOceanLevelChanged(OceanLevel);
		}
	}

	private void UpdateOceanSimulation()
	{
		if (Water.scaled_time)
		{
			WaveTime += Time.deltaTime;
		}
		else
		{
			WaveTime = Time.realtimeSinceStartup;
		}
		if (Weather.ocean_time >= 0f)
		{
			WaveTime = Weather.ocean_time;
		}
		float beaufort = (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance) ? SingletonComponent<Climate>.Instance.WeatherState.OceanScale : 4f);
		oceanSimulation?.Update(WaveTime, Time.deltaTime, beaufort);
	}

	public void Refresh()
	{
		oceanSimulation.Dispose();
		oceanSimulation = new OceanSimulation(oceanSettings);
	}

	private void EditorInitialize()
	{
	}

	private void EditorShutdown()
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class RenderingSettings
{
	[Serializable]
	public class SkyProbe
	{
		public float ProbeUpdateInterval = 1f;

		public bool TimeSlicing = true;
	}

	[Serializable]
	public class SSR
	{
		public float FresnelCutoff = 0.02f;

		public float ThicknessMin = 1f;

		public float ThicknessMax = 20f;

		public float ThicknessStartDist = 40f;

		public float ThicknessEndDist = 100f;
	}

	public Vector4[] TessellationQuality;

	public SkyProbe SkyReflections;

	public SSR ScreenSpaceReflections;
}


using System;

[Serializable]
public class SkyProbe
{
	public float ProbeUpdateInterval = 1f;

	public bool TimeSlicing = true;
}


using System;

[Serializable]
public class SSR
{
	public float FresnelCutoff = 0.02f;

	public float ThicknessMin = 1f;

	public float ThicknessMax = 20f;

	public float ThicknessStartDist = 40f;

	public float ThicknessEndDist = 100f;
}


using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class WaterVisibilityGrid : ICoarseQueryGridProvider, IDisposable
{
	private CoarseQueryGrid _queryGrid;

	private const int CellSize = 8;

	private readonly ListHashSet<WaterVisibilityTrigger> _dynamicListSet;

	public WaterVisibilityGrid()
	{
		_queryGrid = new CoarseQueryGrid(8, (int)(World.Size + 1000), -5f);
		_dynamicListSet = new ListHashSet<WaterVisibilityTrigger>();
	}

	public CoarseQueryGrid GetQueryGrid()
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.PrepareForDynamicPopulate(_dynamicListSet.Count);
		Enumerator<WaterVisibilityTrigger> enumerator = _dynamicListSet.Values.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				WaterVisibilityTrigger current = enumerator.Current;
				if (!((Object)(object)current == (Object)null) && !((Object)(object)current.volume == (Object)null) && !((Object)(object)current.volume.trigger == (Object)null))
				{
					_queryGrid.AddDynamic(current.volume.trigger.bounds);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return _queryGrid;
	}

	public void AddTrigger(WaterVisibilityTrigger trigger)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (trigger.IsDynamic)
		{
			_dynamicListSet.Add(trigger);
		}
		else
		{
			_queryGrid.AddStatic(trigger.volume.trigger.bounds);
		}
	}

	public void RemoveTrigger(WaterVisibilityTrigger trigger)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (trigger.IsDynamic)
		{
			_dynamicListSet.Remove(trigger);
		}
		else
		{
			_queryGrid.RemoveStatic(trigger.volume.trigger.bounds);
		}
	}

	public bool Check(Bounds bounds)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(bounds);
	}

	public bool Check(Vector3 worldPosition, float radius)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(worldPosition, radius);
	}

	public JobHandle Check(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(positions, radii, results);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> positions, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJobIndirect(positions, radii, indices, results);
	}

	public bool Check(Vector3 start, Vector3 end, float radius)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJob(start, end, radius);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return GetQueryGrid().CheckJobIndirect(starts, ends, radii, indices, results);
	}

	public void Dispose()
	{
		_queryGrid.Dispose();
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class WaterVisibilityTrigger : EnvironmentVolumeTrigger
{
	public bool togglePhysics = true;

	public bool toggleVisuals = true;

	public bool IsDynamic;

	private long enteredTick;

	private static long ticks = 1L;

	private static SortedList<long, WaterVisibilityTrigger> tracker = new SortedList<long, WaterVisibilityTrigger>();

	public static void ResetTrackedTriggers()
	{
		ticks = 1L;
		tracker.Clear();
	}

	protected override void OnVolumeTriggerUpdate()
	{
		WaterSystem.Collision.VisibilityGrid.AddTrigger(this);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			WaterSystem.Collision.VisibilityGrid.RemoveTrigger(this);
		}
	}

	protected void OnDestroy()
	{
		if (!Application.isQuitting)
		{
			tracker.Remove(enteredTick);
		}
	}

	private void ToggleVisibility()
	{
	}

	private void ResetVisibility()
	{
	}

	private void ToggleCollision(Collider other)
	{
		if (togglePhysics && (Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.SetIgnore(other, base.volume.trigger);
		}
	}

	private void ResetCollision(Collider other)
	{
		if (togglePhysics && (Object)(object)WaterSystem.Collision != (Object)null)
		{
			WaterSystem.Collision.SetIgnore(other, base.volume.trigger, ignore: false);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		bool num = (Object)(object)((Component)other).gameObject.GetComponent<PlayerWalkMovement>() != (Object)null;
		bool flag = ((Component)other).gameObject.CompareTag("MainCamera");
		if ((num || flag) && !tracker.ContainsValue(this))
		{
			enteredTick = ticks++;
			tracker.Add(enteredTick, this);
			ToggleVisibility();
		}
		if (!flag && !other.isTrigger)
		{
			ToggleCollision(other);
		}
	}

	protected void OnTriggerExit(Collider other)
	{
		bool num = (Object)(object)((Component)other).gameObject.GetComponent<PlayerWalkMovement>() != (Object)null;
		bool flag = ((Component)other).gameObject.CompareTag("MainCamera");
		if ((num || flag) && tracker.ContainsValue(this))
		{
			tracker.Remove(enteredTick);
			if (tracker.Count > 0)
			{
				bool flag2 = false;
				foreach (WaterVisibilityTrigger value in tracker.Values)
				{
					if (value.toggleVisuals)
					{
						flag2 = true;
						break;
					}
				}
				if (flag2)
				{
					tracker.Values[tracker.Count - 1].ToggleVisibility();
				}
				else
				{
					ResetVisibility();
				}
			}
			else
			{
				ResetVisibility();
			}
		}
		if (!flag && !other.isTrigger)
		{
			ResetCollision(other);
		}
	}
}


using System;
using UnityEngine;

public class WaterCheck : PrefabAttribute
{
	public bool Rotate = true;

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0f, 0f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}

	public bool Check(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return pos.y <= WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
	}

	protected override Type GetIndexedType()
	{
		return typeof(WaterCheck);
	}
}


using UnityEngine;

public static class WaterCheckEx
{
	public static bool ApplyWaterChecks(this Transform transform, WaterCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		foreach (WaterCheck obj in anchors)
		{
			Vector3 val = Vector3.Scale(obj.worldPosition, scale);
			if (obj.Rotate)
			{
				val = rot * val;
			}
			Vector3 pos2 = pos + val;
			if (!obj.Check(pos2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class WaterCheckGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementDistance = 8f;

	public bool CheckRotate = true;
}


using UnityEngine;

[ExecuteInEditMode]
public class AdaptMeshToTerrain : MonoBehaviour
{
	public LayerMask LayerMask = LayerMask.op_Implicit(-1);

	public float RayHeight = 10f;

	public float RayMaxDistance = 20f;

	public float MinDisplacement = 0.01f;

	public float MaxDisplacement = 0.33f;

	[Range(8f, 64f)]
	public int PlaneResolution = 24;
}


using UnityEngine;

[ExecuteInEditMode]
public class AtmosphereVolume : MonoBehaviour
{
	public float MaxVisibleDistance = 750f;

	public float BoundsAttenuationDecay = 5f;

	public FogSettings FogSettings;
}


using System;
using UnityEngine;

[Serializable]
public struct FogSettings
{
	public Gradient ColorOverDaytime;

	public float Density;

	public float StartDistance;

	public float Height;

	public float HeightDensity;
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class AtmosphereVolumeRenderer : MonoBehaviour
{
	public FogMode Mode = (FogMode)3;

	public bool DistanceFog = true;

	public bool HeightFog = true;

	public AtmosphereVolume Volume;

	private static bool isSupported
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Invalid comparison between Unknown and I4
			if ((int)Application.platform != 0)
			{
				return (int)Application.platform != 1;
			}
			return false;
		}
	}
}


using System;
using UnityEngine.Rendering;

public class CommandBufferDesc
{
	public delegate void FillCommandBuffer(CommandBuffer cb);

	public CameraEvent CameraEvent { get; private set; }

	public int OrderId { get; private set; }

	public Action<CommandBuffer> FillDelegate { get; private set; }

	public CommandBufferDesc(CameraEvent cameraEvent, int orderId, FillCommandBuffer fill)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		CameraEvent = cameraEvent;
		OrderId = orderId;
		FillDelegate = fill.Invoke;
	}
}


using UnityEngine.Rendering;

public delegate void FillCommandBuffer(CommandBuffer cb);


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class CommandBufferManager : MonoBehaviour
{
}


using UnityEngine;

[ExecuteInEditMode]
public class DeferredDecal : MonoBehaviour
{
	public Mesh mesh;

	public Material material;

	public DeferredDecalQueue queue;

	public bool applyImmediately = true;
}


using UnityEngine;

[ExecuteInEditMode]
public class DeferredDecalRenderer : MonoBehaviour
{
}


using System;

[Serializable]
public enum DeferredDecalQueue
{
	Background,
	Foreground
}


using UnityEngine;

[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class BindRendererBounds : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class BindSubsurfaceProfile : MonoBehaviour
{
	public SubsurfaceProfile subsurfaceProfile;
}


using System;

[Serializable]
public struct SubsurfaceScatteringParams
{
	public enum Quality
	{
		Low,
		Medium,
		High
	}

	public bool enabled;

	public bool halfResolution;

	public float radiusScale;

	public static SubsurfaceScatteringParams Default = new SubsurfaceScatteringParams
	{
		enabled = true,
		halfResolution = true,
		radiusScale = 1f
	};
}


public enum Quality
{
	Low,
	Medium,
	High
}


using System;

[Serializable]
public struct ExtendGBufferParams
{
	public bool enabled;

	public static ExtendGBufferParams Default = new ExtendGBufferParams
	{
		enabled = false
	};
}


using System;
using UnityEngine;

[Serializable]
public struct ScreenSpaceRefractionParams
{
	[Range(0.001f, 1f)]
	public float screenWeightDistance;

	public static ScreenSpaceRefractionParams Default = new ScreenSpaceRefractionParams
	{
		screenWeightDistance = 0.1f
	};
}


using UnityEngine;

[RequireComponent(typeof(CommandBufferManager))]
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class DeferredExtension : MonoBehaviour
{
	public ExtendGBufferParams extendGBuffer = ExtendGBufferParams.Default;

	public SubsurfaceScatteringParams subsurfaceScattering = SubsurfaceScatteringParams.Default;

	public ScreenSpaceRefractionParams screenSpaceRefraction = ScreenSpaceRefractionParams.Default;

	public float depthScale = 100f;

	public bool debug;

	public bool forceToCameraResolution;

	public bool excludeMainLight;
}


using UnityEngine;

[RequireComponent(typeof(Renderer))]
[ExecuteInEditMode]
public class DeferredExtensionMesh : MonoBehaviour
{
	public SubsurfaceProfile subsurfaceProfile;
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(CommandBufferManager))]
[ExecuteInEditMode]
public class DeferredIndirectLightingPass : MonoBehaviour
{
}


using UnityEngine;

public class SeparableSSS
{
	private static Vector3 Gaussian(float variance, float r, Color falloffColor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < 3; i++)
		{
			float num = r / (0.001f + ((Color)(ref falloffColor))[i]);
			((Vector3)(ref zero))[i] = Mathf.Exp((0f - num * num) / (2f * variance)) / (6.28f * variance);
		}
		return zero;
	}

	private static Vector3 Profile(float r, Color falloffColor)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		return 0.1f * Gaussian(0.0484f, r, falloffColor) + 0.118f * Gaussian(0.187f, r, falloffColor) + 0.113f * Gaussian(0.567f, r, falloffColor) + 0.358f * Gaussian(1.99f, r, falloffColor) + 0.078f * Gaussian(7.41f, r, falloffColor);
	}

	public static void CalculateKernel(Color[] target, int targetStart, int targetSize, Color subsurfaceColor, Color falloffColor)
	{
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		int num = targetSize * 2 - 1;
		float num2 = ((num > 20) ? 3f : 2f);
		float num3 = 2f;
		Color[] array = (Color[])(object)new Color[num];
		float num4 = 2f * num2 / (float)(num - 1);
		for (int i = 0; i < num; i++)
		{
			float num5 = 0f - num2 + (float)i * num4;
			float num6 = ((num5 < 0f) ? (-1f) : 1f);
			array[i].a = num2 * num6 * Mathf.Abs(Mathf.Pow(num5, num3)) / Mathf.Pow(num2, num3);
		}
		for (int j = 0; j < num; j++)
		{
			float num7 = ((j > 0) ? Mathf.Abs(array[j].a - array[j - 1].a) : 0f);
			float num8 = ((j < num - 1) ? Mathf.Abs(array[j].a - array[j + 1].a) : 0f);
			Vector3 val = (num7 + num8) / 2f * Profile(array[j].a, falloffColor);
			array[j].r = val.x;
			array[j].g = val.y;
			array[j].b = val.z;
		}
		Color val2 = array[num / 2];
		for (int num9 = num / 2; num9 > 0; num9--)
		{
			array[num9] = array[num9 - 1];
		}
		array[0] = val2;
		Vector3 zero = Vector3.zero;
		for (int k = 0; k < num; k++)
		{
			zero.x += array[k].r;
			zero.y += array[k].g;
			zero.z += array[k].b;
		}
		for (int l = 0; l < num; l++)
		{
			array[l].r /= zero.x;
			array[l].g /= zero.y;
			array[l].b /= zero.z;
		}
		target[targetStart] = array[0];
		for (uint num10 = 0u; num10 < targetSize - 1; num10++)
		{
			target[targetStart + num10 + 1] = array[targetSize + num10];
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct SubsurfaceProfileData
{
	[Range(0.1f, 100f)]
	public float ScatterRadius;

	[ColorUsage(false, false)]
	public Color SubsurfaceColor;

	[ColorUsage(false, false)]
	public Color FalloffColor;

	[ColorUsage(false, true)]
	public Color TransmissionTint;

	public static SubsurfaceProfileData Default
	{
		get
		{
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			SubsurfaceProfileData result = default(SubsurfaceProfileData);
			result.ScatterRadius = 1.2f;
			result.SubsurfaceColor = new Color(0.48f, 0.41f, 0.28f);
			result.FalloffColor = new Color(1f, 0.37f, 0.3f);
			result.TransmissionTint = new Color(0.48f, 0.41f, 0.28f);
			return result;
		}
	}

	public static SubsurfaceProfileData Invalid
	{
		get
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			SubsurfaceProfileData result = default(SubsurfaceProfileData);
			result.ScatterRadius = 0f;
			result.SubsurfaceColor = Color.clear;
			result.FalloffColor = Color.clear;
			result.TransmissionTint = Color.clear;
			return result;
		}
	}
}


using UnityEngine;

public class SubsurfaceProfile : ScriptableObject
{
	private static SubsurfaceProfileTexture profileTexture = new SubsurfaceProfileTexture();

	public SubsurfaceProfileData Data = SubsurfaceProfileData.Default;

	private int id = -1;

	public static Texture2D Texture
	{
		get
		{
			if (profileTexture == null)
			{
				return null;
			}
			return profileTexture.Texture;
		}
	}

	public static Vector4[] TransmissionTints
	{
		get
		{
			if (profileTexture == null)
			{
				return null;
			}
			return profileTexture.TransmissionTints;
		}
	}

	public int Id
	{
		get
		{
			return id;
		}
		set
		{
			id = value;
		}
	}

	private void OnEnable()
	{
		profileTexture.AddProfile(this);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class SubsurfaceProfileTexture
{
	private struct SubsurfaceProfileEntry
	{
		public SubsurfaceProfileData data;

		public SubsurfaceProfile profile;

		public SubsurfaceProfileEntry(SubsurfaceProfileData data, SubsurfaceProfile profile)
		{
			this.data = data;
			this.profile = profile;
		}
	}

	public const int SUBSURFACE_PROFILE_COUNT = 16;

	public const int MAX_SUBSURFACE_PROFILES = 15;

	public const int SUBSURFACE_RADIUS_SCALE = 1024;

	public const int SUBSURFACE_KERNEL_SIZE = 3;

	private HashSet<SubsurfaceProfile> entries = new HashSet<SubsurfaceProfile>();

	private Texture2D texture;

	private Vector4[] transmissionTints = (Vector4[])(object)new Vector4[16];

	private const int KernelSize0 = 24;

	private const int KernelSize1 = 16;

	private const int KernelSize2 = 8;

	private const int KernelTotalSize = 49;

	private const int Width = 49;

	public Texture2D Texture
	{
		get
		{
			if ((Object)(object)texture == (Object)null)
			{
				CreateResources();
			}
			return texture;
		}
	}

	public Vector4[] TransmissionTints
	{
		get
		{
			if ((Object)(object)texture == (Object)null)
			{
				CreateResources();
			}
			return transmissionTints;
		}
	}

	public void AddProfile(SubsurfaceProfile profile)
	{
		entries.Add(profile);
		if (entries.Count > 15)
		{
			Debug.LogWarning((object)$"[SubsurfaceScattering] Maximum number of supported Subsurface Profiles has been reached ({entries.Count}/{15}). Please remove some.");
		}
		ReleaseResources();
	}

	public static Color Clamp(Color color, float min = 0f, float max = 1f)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Color result = default(Color);
		result.r = Mathf.Clamp(color.r, min, max);
		result.g = Mathf.Clamp(color.g, min, max);
		result.b = Mathf.Clamp(color.b, min, max);
		result.a = Mathf.Clamp(color.a, min, max);
		return result;
	}

	private void WriteKernel(ref Color[] pixels, ref Color[] kernel, int id, int y, in SubsurfaceProfileData data)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		Color val = Clamp(data.SubsurfaceColor);
		Color falloffColor = Clamp(data.FalloffColor, 0.009f);
		transmissionTints[id] = Color.op_Implicit(data.TransmissionTint);
		kernel[0] = val;
		kernel[0].a = data.ScatterRadius;
		SeparableSSS.CalculateKernel(kernel, 1, 24, val, falloffColor);
		SeparableSSS.CalculateKernel(kernel, 25, 16, val, falloffColor);
		SeparableSSS.CalculateKernel(kernel, 41, 8, val, falloffColor);
		int num = 49 * y;
		for (int i = 0; i < 49; i++)
		{
			Color val2 = kernel[i];
			val2.a *= ((i > 0) ? (data.ScatterRadius / 1024f) : 1f);
			pixels[num + i] = val2;
		}
	}

	private void CreateResources()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		if (entries.Count <= 0)
		{
			return;
		}
		int num = Mathf.Min(entries.Count, 15) + 1;
		ReleaseResources();
		texture = new Texture2D(49, num, (TextureFormat)17, false, true);
		((Object)texture).name = "SubsurfaceProfiles";
		((Texture)texture).wrapMode = (TextureWrapMode)1;
		((Texture)texture).filterMode = (FilterMode)1;
		Color[] pixels = texture.GetPixels(0);
		Color[] kernel = (Color[])(object)new Color[49];
		int num2 = num - 1;
		int id = 0;
		WriteKernel(ref pixels, ref kernel, id++, num2--, SubsurfaceProfileData.Default);
		foreach (SubsurfaceProfile entry in entries)
		{
			entry.Id = id;
			WriteKernel(ref pixels, ref kernel, id++, num2--, in entry.Data);
			if (num2 < 0)
			{
				break;
			}
		}
		texture.SetPixels(pixels, 0);
		texture.Apply(false, false);
	}

	public void ReleaseResources()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)texture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)texture);
			texture = null;
		}
		if (transmissionTints != null)
		{
			for (int i = 0; i < transmissionTints.Length; i++)
			{
				Vector4[] array = transmissionTints;
				int num = i;
				SubsurfaceProfileData @default = SubsurfaceProfileData.Default;
				array[num] = Color.op_Implicit(((Color)(ref @default.TransmissionTint)).linear);
			}
		}
	}
}


private struct SubsurfaceProfileEntry
{
	public SubsurfaceProfileData data;

	public SubsurfaceProfile profile;

	public SubsurfaceProfileEntry(SubsurfaceProfileData data, SubsurfaceProfile profile)
	{
		this.data = data;
		this.profile = profile;
	}
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Renderer))]
public class DeferredMeshDecal : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class DeferredMeshDecalRenderer : MonoBehaviour
{
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Environment Volume Properties")]
public class EnvironmentVolumeProperties : ScriptableObject
{
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Environment Volume Properties Collection")]
public class EnvironmentVolumePropertiesCollection : ScriptableObject
{
	[Serializable]
	public class EnvironmentMultiplier
	{
		public EnvironmentType Type;

		public float Multiplier;
	}

	[Serializable]
	public class OceanParameters
	{
		[Header("Lighting")]
		public AnimationCurve TransitionCurveLighting = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float DirectionalLightMultiplier = 0.25f;

		[Range(0f, 1f)]
		public float AmbientLightMultiplier;

		[Range(0f, 1f)]
		public float ReflectionMultiplier = 1f;

		[Header("Sun/Moon")]
		public AnimationCurve TransitionCurveSunMoon = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float SunMeshBrightnessMultiplier = 1f;

		[Range(0f, 1f)]
		public float MoonMeshBrightnessMultiplier = 1f;

		[Header("Atmosphere")]
		public AnimationCurve TransitionCurveAtmosphere = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float AtmosphereBrightnessMultiplier = 1f;

		[Header("Colors")]
		public AnimationCurve TransitionCurve = AnimationCurve.Linear(0f, 0f, 40f, 1f);

		[Range(0f, 1f)]
		public float LightColorMultiplier = 1f;

		public Color LightColor = Color.black;

		[Range(0f, 1f)]
		public float SunRayColorMultiplier = 1f;

		public Color SunRayColor = Color.black;

		[Range(0f, 1f)]
		public float MoonRayColorMultiplier = 1f;

		public Color MoonRayColor = Color.black;
	}

	public float TransitionSpeed = 1f;

	public LayerMask ReflectionMask = LayerMask.op_Implicit(1084293120);

	[Horizontal(1, 0)]
	public EnvironmentMultiplier[] ReflectionMultipliers;

	public float DefaultReflectionMultiplier = 1f;

	[Horizontal(1, 0)]
	public EnvironmentMultiplier[] AmbientMultipliers;

	public float DefaultAmbientMultiplier = 1f;

	public OceanParameters OceanOverrides;
}


using System;

[Serializable]
public class EnvironmentMultiplier
{
	public EnvironmentType Type;

	public float Multiplier;
}


using System;
using UnityEngine;

[Serializable]
public class OceanParameters
{
	[Header("Lighting")]
	public AnimationCurve TransitionCurveLighting = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float DirectionalLightMultiplier = 0.25f;

	[Range(0f, 1f)]
	public float AmbientLightMultiplier;

	[Range(0f, 1f)]
	public float ReflectionMultiplier = 1f;

	[Header("Sun/Moon")]
	public AnimationCurve TransitionCurveSunMoon = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float SunMeshBrightnessMultiplier = 1f;

	[Range(0f, 1f)]
	public float MoonMeshBrightnessMultiplier = 1f;

	[Header("Atmosphere")]
	public AnimationCurve TransitionCurveAtmosphere = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float AtmosphereBrightnessMultiplier = 1f;

	[Header("Colors")]
	public AnimationCurve TransitionCurve = AnimationCurve.Linear(0f, 0f, 40f, 1f);

	[Range(0f, 1f)]
	public float LightColorMultiplier = 1f;

	public Color LightColor = Color.black;

	[Range(0f, 1f)]
	public float SunRayColorMultiplier = 1f;

	public Color SunRayColor = Color.black;

	[Range(0f, 1f)]
	public float MoonRayColorMultiplier = 1f;

	public Color MoonRayColor = Color.black;
}


using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(DeferredIndirectLightingPass))]
[RequireComponent(typeof(CommandBufferManager))]
[ExecuteInEditMode]
public class SpatialEnvironmentVolumePass : MonoBehaviour
{
	private const CameraEvent VOLUME_RENDERING_CAMERA_EVENT = 6;

	private const int VOLUME_RENDERING_ORDER_ID = 1000;

	private static readonly int envVolumeBufferId = Shader.PropertyToID("_EnvVolumeBuffer");

	private static readonly int numberOfVolumesId = Shader.PropertyToID("_NumberOfEnvironmentVolumes");

	[SerializeField]
	private Mesh cubeMesh;

	[SerializeField]
	private Mesh sphereMesh;

	[SerializeField]
	private Mesh capsuleMesh;

	[SerializeField]
	private Shader shader;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	[SerializeField]
	private Shader copyToDepthBufferShader;

	public bool IsInitialized { get; private set; }
}


using UnityEngine;

public class FoliageDisplacement : MonoBehaviour, IClientComponent, ILOD
{
	public bool moving;

	public bool billboard;

	public Mesh mesh;

	public Material material;
}


using UnityEngine;

public class FoliageDisplacementManager : SingletonComponent<FoliageDisplacementManager>, IClientComponent
{
	[SerializeField]
	private Material clearDisplacementMat;
}


using UnityEngine;

[RequireComponent(typeof(MeshFilter))]
[ExecuteInEditMode]
[RequireComponent(typeof(MeshRenderer))]
public class Impostor : MonoBehaviour, IClientComponent, IPrefabPreProcess
{
	public ImpostorAsset asset;

	[Header("Baking")]
	public GameObject reference;

	public float angle;

	public int resolution = 1024;

	public int padding = 32;

	public bool spriteOutlineAsMesh;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	private void OnEnable()
	{
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


using System;
using UnityEngine;

public class ImpostorAsset : ScriptableObject
{
	[Serializable]
	public class TextureEntry
	{
		public string name;

		public Texture2D texture;

		public TextureEntry(string name, Texture2D texture)
		{
			this.name = name;
			this.texture = texture;
		}
	}

	public TextureEntry[] textures;

	public Vector2 size;

	public Vector2 pivot;

	public Mesh mesh;

	public Texture2D FindTexture(string name)
	{
		TextureEntry[] array = textures;
		foreach (TextureEntry textureEntry in array)
		{
			if (textureEntry.name == name)
			{
				return textureEntry.texture;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class TextureEntry
{
	public string name;

	public Texture2D texture;

	public TextureEntry(string name, Texture2D texture)
	{
		this.name = name;
		this.texture = texture;
	}
}


using UnityEngine;

public class ImpostorInstanceData
{
	public ImpostorBatch Batch;

	public int BatchIndex;

	private int hash;

	private Vector4 positionAndScale = Vector4.zero;

	public Renderer Renderer { get; private set; }

	public Mesh Mesh { get; private set; }

	public Material Material { get; private set; }

	public ImpostorInstanceData(Renderer renderer, Mesh mesh, Material material)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Renderer = renderer;
		Mesh = mesh;
		Material = material;
		hash = GenerateHashCode();
		Update();
	}

	public ImpostorInstanceData(Vector3 position, Vector3 scale, Mesh mesh, Material material)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		positionAndScale = new Vector4(position.x, position.y, position.z, scale.x);
		Mesh = mesh;
		Material = material;
		hash = GenerateHashCode();
		Update();
	}

	private int GenerateHashCode()
	{
		return (17 * 31 + ((object)Material).GetHashCode()) * 31 + ((object)Mesh).GetHashCode();
	}

	public override bool Equals(object obj)
	{
		ImpostorInstanceData impostorInstanceData = obj as ImpostorInstanceData;
		if ((Object)(object)impostorInstanceData.Material == (Object)(object)Material)
		{
			return (Object)(object)impostorInstanceData.Mesh == (Object)(object)Mesh;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return hash;
	}

	public Vector4 PositionAndScale()
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Renderer != (Object)null)
		{
			Transform transform = ((Component)Renderer).transform;
			Vector3 position = transform.position;
			Vector3 lossyScale = transform.lossyScale;
			float num = (Renderer.enabled ? lossyScale.x : (0f - lossyScale.x));
			positionAndScale = new Vector4(position.x, position.y, position.z, num);
		}
		return positionAndScale;
	}

	public void Update()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (Batch != null)
		{
			Batch.Positions[BatchIndex] = PositionAndScale();
			Batch.IsDirty = true;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ImpostorBatch : IPooled
{
	public FPNativeList<Vector4> Positions;

	private FPNativeList<uint> args;

	private Queue<int> recycle = new Queue<int>(32);

	public Mesh Mesh { get; private set; }

	public Material Material { get; private set; }

	public ComputeBuffer PositionBuffer { get; private set; }

	public ComputeBuffer ArgsBuffer { get; private set; }

	public bool IsDirty { get; set; }

	public int Count => Positions.Count;

	public bool Visible => Positions.Count - recycle.Count > 0;

	private ComputeBuffer SafeRelease(ComputeBuffer buffer)
	{
		if (buffer != null)
		{
			buffer.Release();
		}
		return null;
	}

	public void Initialize(Mesh mesh, Material material)
	{
		Mesh = mesh;
		Material = material;
		args[0] = Mesh.GetIndexCount(0);
		args[2] = Mesh.GetIndexStart(0);
		args[3] = Mesh.GetBaseVertex(0);
	}

	void IPooled.LeavePool()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		Positions = Pool.Get<FPNativeList<Vector4>>();
		args = Pool.Get<FPNativeList<uint>>();
		args.Resize(5);
		ArgsBuffer = new ComputeBuffer(1, args.Count * 4, (ComputeBufferType)256);
	}

	void IPooled.EnterPool()
	{
		recycle.Clear();
		Pool.Free<FPNativeList<Vector4>>(ref Positions);
		Pool.Free<FPNativeList<uint>>(ref args);
		PositionBuffer = SafeRelease(PositionBuffer);
		ArgsBuffer.Release();
		ArgsBuffer = null;
	}

	public void AddInstance(ImpostorInstanceData data)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		data.Batch = this;
		if (recycle.Count > 0)
		{
			data.BatchIndex = recycle.Dequeue();
			Positions[data.BatchIndex] = data.PositionAndScale();
		}
		else
		{
			data.BatchIndex = Positions.Count;
			Positions.Add(data.PositionAndScale());
		}
		IsDirty = true;
	}

	public void RemoveInstance(ImpostorInstanceData data)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		Positions[data.BatchIndex] = new Vector4(0f, 0f, 0f, -1f);
		recycle.Enqueue(data.BatchIndex);
		data.BatchIndex = 0;
		data.Batch = null;
		IsDirty = true;
	}

	public void UpdateBuffers()
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Expected O, but got Unknown
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		if (IsDirty)
		{
			bool flag = false;
			if (PositionBuffer == null || PositionBuffer.count != Positions.Count)
			{
				PositionBuffer = SafeRelease(PositionBuffer);
				PositionBuffer = new ComputeBuffer(Positions.Count, 16);
				flag = true;
			}
			PositionBuffer.SetData<Vector4>(Positions.Array, 0, 0, Positions.Count);
			if (flag)
			{
				args[1] = (uint)Positions.Count;
				ArgsBuffer.SetData<uint>(args.Array, 0, 0, args.Count);
			}
			IsDirty = false;
		}
	}
}


using UnityEngine;

[RequireComponent(typeof(Camera))]
public class ImpostorRenderer : MonoBehaviour
{
	public const string MainPassName = "DEFERRED";
}


using UnityEngine;

[RequireComponent(typeof(Light))]
public class ImpostorShadows : MonoBehaviour
{
}


using UnityEngine;

public class InstancedCameraComponent : MonoBehaviour
{
	public bool IsMirror;
}


using System;

public class InstancedEntityComponent : PrefabAttribute, IClientComponent
{
	public bool HideInsideNetworkRange;

	protected override Type GetIndexedType()
	{
		return typeof(InstancedEntityComponent);
	}
}


using System;
using Instancing;
using UnityEngine;

public class InstancedMeshFilter : PrefabAttribute, IClientComponent
{
	public MeshRenderer MeshRenderer;

	public RendererLOD RendererLOD;

	public MeshLOD MeshLOD;

	[NonSerialized]
	public InstancedMeshConfig Config;

	protected override Type GetIndexedType()
	{
		return typeof(InstancedMeshFilter);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class InstancedScheduler : SingletonComponent<InstancedScheduler>
{
	public ComputeShader CullShader;

	public ComputeShader SimplePostCullShader;

	public ComputeShader ClearBufferShader;

	public ComputeShader WriteIndirectArgsShader;

	public ComputeShader CopyMeshShader;

	public ConstructionSkin_ColourLookup ContainerColorLookup;

	public List<BuildingGrade> coloredSkins;
}


using System;

public class InstancingConfigComponent : PrefabAttribute, IClientComponent
{
	public bool DisableInstancing;

	protected override Type GetIndexedType()
	{
		return typeof(InstancingConfigComponent);
	}
}


using Instancing;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;

[BurstCompile]
public struct PostCullingJob : IJob
{
	[ReadOnly]
	public NativeArray<int> CountPerMesh;

	[ReadOnly]
	public int RendererCount;

	[ReadOnly]
	public NativeArray<InstancedRendererJobData> Renderers;

	[WriteOnly]
	public JobInt PostCullMeshCount;

	[WriteOnly]
	public JobInt PostCullShadowCount;

	public void Execute()
	{
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < RendererCount; i++)
		{
			InstancedRendererJobData instancedRendererJobData = Renderers[i];
			int num3 = CountPerMesh[i];
			if (instancedRendererJobData.HasShadow)
			{
				num2 += num3;
			}
			if (instancedRendererJobData.HasMesh)
			{
				num += num3;
			}
		}
		PostCullMeshCount.Value = num;
		PostCullShadowCount.Value = num2;
	}
}


using Unity.Mathematics;
using UnityEngine;

public static class Float4x4Ex
{
	public static float3 ToPosition(this float4x4 m)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return ((float4)(ref m.c3)).xyz;
	}

	public static Quaternion ToRotation(this float4x4 m)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.LookRotation(float3.op_Implicit(((float4)(ref m.c2)).xyz), float3.op_Implicit(((float4)(ref m.c1)).xyz));
	}
}


public class VirtualEntityScheduler
{
	public static VirtualEntityScheduler Instance { get; private set; } = new VirtualEntityScheduler();
}


using UnityEngine;

[ExecuteInEditMode]
public class LightCloneShadow : MonoBehaviour
{
	public bool cloneShadowMap;

	public bool cloneShadowMask;

	[Range(0f, 2f)]
	public int shadowMaskDownscale = 1;
}


using UnityEngine;

public class LiquidWobble : MonoBehaviour
{
	[Range(0f, 1f)]
	public float CurrentWaterLevelFraction;

	public float MinWaterLevel = -11f;

	public float MaxWaterLevel = 11f;

	public float MaxWobble = 0.03f;

	public float WobbleSpeed = 1f;

	public float Recovery = 1f;
}


using System;
using UnityEngine;

public struct MaterialPropertyDesc
{
	public int nameID;

	public Type type;

	public MaterialPropertyDesc(string name, Type type)
	{
		nameID = Shader.PropertyToID(name);
		this.type = type;
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class MeshTerrainRoot : MonoBehaviour, IClientComponent
{
	public GameObject TerrainBlendSearchRoot;

	public Mesh TerrainMeshAsset;

	public Material TerrainMaterial;

	public Vector3 TerrainPos;

	public Vector3 TerrainSize;
}


using UnityEngine;

public class PlanarReflectionCamera : MonoBehaviour
{
	public static PlanarReflectionCamera instance;

	public float updateRate = 1f;

	public float nearClipPlane = 0.3f;

	public float farClipPlane = 25f;

	public Color fogColor = Color.white;

	public float fogDensity = 0.1f;

	public Mesh waterPlaneMesh;

	public Material waterPlaneMaterial;
}


using UnityEngine;

public class ReflectionPlane : DecayEntity
{
	private static readonly int _ColorTexID = Shader.PropertyToID("_ColorTex");

	private static readonly int _DepthTexID = Shader.PropertyToID("_DepthTex");

	private static readonly int _ReflectionLerpID = Shader.PropertyToID("_ReflectionLerp");

	[Header("Reflection Plane")]
	public LayerMask layerMask = LayerMask.op_Implicit(-1);

	public float nearClip;

	public float farClip;

	public Material reflectionMaterial;

	public Renderer reflectionRenderer;

	public float maxDistance;

	public float fadeTime = 0.25f;
}


public class MorphCache : FacepunchBehaviour
{
}


using UnityEngine;

public class ObjectMotionVectorFix : MonoBehaviour
{
}


using UnityEngine;

[RequireComponent(typeof(CommandBufferManager))]
[ExecuteInEditMode]
public class PostOpaqueDepth : MonoBehaviour
{
	public RenderTexture postOpaqueDepth;

	public RenderTexture PostOpaque => postOpaqueDepth;
}


using UnityEngine;

public class QuadDecal : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class ReflectionProbeEx : MonoBehaviour
{
	[Serializable]
	public enum ConvolutionQuality
	{
		Lowest,
		Low,
		Medium,
		High,
		VeryHigh
	}

	[Serializable]
	public struct RenderListEntry
	{
		public Renderer renderer;

		public bool alwaysEnabled;

		public RenderListEntry(Renderer renderer, bool alwaysEnabled)
		{
			this.renderer = renderer;
			this.alwaysEnabled = alwaysEnabled;
		}
	}

	private struct CubemapSkyboxVertex
	{
		public float x;

		public float y;

		public float z;

		public Color color;

		public float tu;

		public float tv;

		public float tw;
	}

	private struct CubemapFaceMatrices
	{
		public Matrix4x4 worldToView;

		public Matrix4x4 viewToWorld;

		public CubemapFaceMatrices(Vector3 x, Vector3 y, Vector3 z)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
			worldToView = Matrix4x4.identity;
			((Matrix4x4)(ref worldToView))[0, 0] = ((Vector3)(ref x))[0];
			((Matrix4x4)(ref worldToView))[0, 1] = ((Vector3)(ref x))[1];
			((Matrix4x4)(ref worldToView))[0, 2] = ((Vector3)(ref x))[2];
			((Matrix4x4)(ref worldToView))[1, 0] = ((Vector3)(ref y))[0];
			((Matrix4x4)(ref worldToView))[1, 1] = ((Vector3)(ref y))[1];
			((Matrix4x4)(ref worldToView))[1, 2] = ((Vector3)(ref y))[2];
			((Matrix4x4)(ref worldToView))[2, 0] = ((Vector3)(ref z))[0];
			((Matrix4x4)(ref worldToView))[2, 1] = ((Vector3)(ref z))[1];
			((Matrix4x4)(ref worldToView))[2, 2] = ((Vector3)(ref z))[2];
			viewToWorld = ((Matrix4x4)(ref worldToView)).inverse;
		}
	}

	public ReflectionProbeRefreshMode refreshMode = (ReflectionProbeRefreshMode)1;

	public bool timeSlicing;

	public int resolution = 128;

	[InspectorName("HDR")]
	public bool hdr = true;

	public float shadowDistance;

	public ReflectionProbeClearFlags clearFlags = (ReflectionProbeClearFlags)1;

	public Color background = new Color(0.192f, 0.301f, 0.474f);

	public float nearClip = 0.3f;

	public float farClip = 1000f;

	public Transform attachToTarget;

	public Light directionalLight;

	public float textureMipBias = 2f;

	public bool highPrecision;

	public bool enableShadows;

	public ConvolutionQuality convolutionQuality;

	public List<RenderListEntry> staticRenderList = new List<RenderListEntry>();

	public Cubemap reflectionCubemap;

	public float reflectionIntensity = 1f;

	private Mesh blitMesh;

	private Mesh skyboxMesh;

	private static float[] octaVerts = new float[72]
	{
		0f, 1f, 0f, 0f, 0f, -1f, 1f, 0f, 0f, 0f,
		1f, 0f, 1f, 0f, 0f, 0f, 0f, 1f, 0f, 1f,
		0f, 0f, 0f, 1f, -1f, 0f, 0f, 0f, 1f, 0f,
		-1f, 0f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 1f,
		0f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 0f, 0f,
		1f, 1f, 0f, 0f, 0f, -1f, 0f, -1f, 0f, 0f,
		0f, 0f, 1f, 0f, -1f, 0f, 0f, 0f, -1f, -1f,
		0f, 0f
	};

	private static readonly CubemapFaceMatrices[] cubemapFaceMatrices = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, -1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, 1f))
	};

	private static readonly CubemapFaceMatrices[] cubemapFaceMatricesD3D11 = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, 1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, -1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, 1f, 0f), new Vector3(0f, 0f, 1f))
	};

	private static readonly CubemapFaceMatrices[] shadowCubemapFaceMatrices = new CubemapFaceMatrices[6]
	{
		new CubemapFaceMatrices(new Vector3(0f, 0f, 1f), new Vector3(0f, -1f, 0f), new Vector3(-1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f), new Vector3(1f, 0f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, 1f), new Vector3(0f, 1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, 0f, -1f), new Vector3(0f, -1f, 0f)),
		new CubemapFaceMatrices(new Vector3(1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, 1f)),
		new CubemapFaceMatrices(new Vector3(-1f, 0f, 0f), new Vector3(0f, -1f, 0f), new Vector3(0f, 0f, -1f))
	};

	private CubemapFaceMatrices[] platformCubemapFaceMatrices;

	private static readonly int[] tab32 = new int[32]
	{
		0, 9, 1, 10, 13, 21, 2, 29, 11, 14,
		16, 18, 22, 25, 3, 30, 8, 12, 20, 28,
		15, 17, 24, 7, 19, 27, 23, 6, 26, 5,
		4, 31
	};

	private void CreateMeshes()
	{
		if ((Object)(object)blitMesh == (Object)null)
		{
			blitMesh = CreateBlitMesh();
		}
		if ((Object)(object)skyboxMesh == (Object)null)
		{
			skyboxMesh = CreateSkyboxMesh();
		}
	}

	private void DestroyMeshes()
	{
		if ((Object)(object)blitMesh != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)blitMesh);
			blitMesh = null;
		}
		if ((Object)(object)skyboxMesh != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)skyboxMesh);
			skyboxMesh = null;
		}
	}

	private static Mesh CreateBlitMesh()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Expected O, but got Unknown
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		Mesh val = new Mesh();
		val.vertices = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(-1f, -1f, 0f),
			new Vector3(-1f, 1f, 0f),
			new Vector3(1f, 1f, 0f),
			new Vector3(1f, -1f, 0f)
		};
		val.uv = (Vector2[])(object)new Vector2[4]
		{
			new Vector2(0f, 0f),
			new Vector2(0f, 1f),
			new Vector2(1f, 1f),
			new Vector2(1f, 0f)
		};
		val.triangles = new int[6] { 0, 1, 2, 0, 2, 3 };
		return val;
	}

	private static CubemapSkyboxVertex SubDivVert(CubemapSkyboxVertex v1, CubemapSkyboxVertex v2)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = new Vector3(v1.x, v1.y, v1.z);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(v2.x, v2.y, v2.z);
		Vector3 val3 = Vector3.Normalize(Vector3.Lerp(val, val2, 0.5f));
		CubemapSkyboxVertex result = default(CubemapSkyboxVertex);
		result.x = (result.tu = val3.x);
		result.y = (result.tv = val3.y);
		result.z = (result.tw = val3.z);
		result.color = Color.white;
		return result;
	}

	private static void Subdivide(List<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
	{
		CubemapSkyboxVertex item = SubDivVert(v1, v2);
		CubemapSkyboxVertex item2 = SubDivVert(v2, v3);
		CubemapSkyboxVertex item3 = SubDivVert(v1, v3);
		destArray.Add(v1);
		destArray.Add(item);
		destArray.Add(item3);
		destArray.Add(item);
		destArray.Add(v2);
		destArray.Add(item2);
		destArray.Add(item2);
		destArray.Add(item3);
		destArray.Add(item);
		destArray.Add(v3);
		destArray.Add(item3);
		destArray.Add(item2);
	}

	private static void SubdivideYOnly(List<CubemapSkyboxVertex> destArray, CubemapSkyboxVertex v1, CubemapSkyboxVertex v2, CubemapSkyboxVertex v3)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Abs(v2.y - v1.y);
		float num2 = Mathf.Abs(v2.y - v3.y);
		float num3 = Mathf.Abs(v3.y - v1.y);
		CubemapSkyboxVertex cubemapSkyboxVertex;
		CubemapSkyboxVertex cubemapSkyboxVertex2;
		CubemapSkyboxVertex cubemapSkyboxVertex3;
		if (num < num2 && num < num3)
		{
			cubemapSkyboxVertex = v3;
			cubemapSkyboxVertex2 = v1;
			cubemapSkyboxVertex3 = v2;
		}
		else if (num2 < num && num2 < num3)
		{
			cubemapSkyboxVertex = v1;
			cubemapSkyboxVertex2 = v2;
			cubemapSkyboxVertex3 = v3;
		}
		else
		{
			cubemapSkyboxVertex = v2;
			cubemapSkyboxVertex2 = v3;
			cubemapSkyboxVertex3 = v1;
		}
		CubemapSkyboxVertex item = SubDivVert(cubemapSkyboxVertex, cubemapSkyboxVertex2);
		CubemapSkyboxVertex item2 = SubDivVert(cubemapSkyboxVertex, cubemapSkyboxVertex3);
		destArray.Add(cubemapSkyboxVertex);
		destArray.Add(item);
		destArray.Add(item2);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(item2.x - cubemapSkyboxVertex2.x, item2.y - cubemapSkyboxVertex2.y, item2.z - cubemapSkyboxVertex2.z);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(item.x - cubemapSkyboxVertex3.x, item.y - cubemapSkyboxVertex3.y, item.z - cubemapSkyboxVertex3.z);
		if (val.x * val.x + val.y * val.y + val.z * val.z > val2.x * val2.x + val2.y * val2.y + val2.z * val2.z)
		{
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(cubemapSkyboxVertex3);
			destArray.Add(item2);
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex3);
		}
		else
		{
			destArray.Add(item2);
			destArray.Add(item);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(item2);
			destArray.Add(cubemapSkyboxVertex2);
			destArray.Add(cubemapSkyboxVertex3);
		}
	}

	private static Mesh CreateSkyboxMesh()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Expected O, but got Unknown
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		List<CubemapSkyboxVertex> list = new List<CubemapSkyboxVertex>();
		for (int i = 0; i < 24; i++)
		{
			CubemapSkyboxVertex item = default(CubemapSkyboxVertex);
			Vector3 val = Vector3.Normalize(new Vector3(octaVerts[i * 3], octaVerts[i * 3 + 1], octaVerts[i * 3 + 2]));
			item.x = (item.tu = val.x);
			item.y = (item.tv = val.y);
			item.z = (item.tw = val.z);
			item.color = Color.white;
			list.Add(item);
		}
		for (int j = 0; j < 3; j++)
		{
			List<CubemapSkyboxVertex> list2 = new List<CubemapSkyboxVertex>(list.Count);
			list2.AddRange(list);
			int count = list2.Count;
			list.Clear();
			list.Capacity = count * 4;
			for (int k = 0; k < count; k += 3)
			{
				Subdivide(list, list2[k], list2[k + 1], list2[k + 2]);
			}
		}
		for (int l = 0; l < 2; l++)
		{
			List<CubemapSkyboxVertex> list3 = new List<CubemapSkyboxVertex>(list.Count);
			list3.AddRange(list);
			int count2 = list3.Count;
			float num = Mathf.Pow(0.5f, (float)l + 1f);
			list.Clear();
			list.Capacity = count2 * 4;
			for (int m = 0; m < count2; m += 3)
			{
				if (Mathf.Max(Mathf.Max(Mathf.Abs(list3[m].y), Mathf.Abs(list3[m + 1].y)), Mathf.Abs(list3[m + 2].y)) > num)
				{
					list.Add(list3[m]);
					list.Add(list3[m + 1]);
					list.Add(list3[m + 2]);
				}
				else
				{
					SubdivideYOnly(list, list3[m], list3[m + 1], list3[m + 2]);
				}
			}
		}
		Mesh val2 = new Mesh();
		Vector3[] array = (Vector3[])(object)new Vector3[list.Count];
		Vector2[] array2 = (Vector2[])(object)new Vector2[list.Count];
		int[] array3 = new int[list.Count];
		for (int n = 0; n < list.Count; n++)
		{
			array[n] = new Vector3(list[n].x, list[n].y, list[n].z);
			array2[n] = Vector2.op_Implicit(new Vector3(list[n].tu, list[n].tv));
			array3[n] = n;
		}
		val2.vertices = array;
		val2.uv = array2;
		val2.triangles = array3;
		return val2;
	}

	private bool InitializeCubemapFaceMatrices()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Invalid comparison between Unknown and I4
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Expected I4, but got Unknown
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		GraphicsDeviceType graphicsDeviceType = SystemInfo.graphicsDeviceType;
		if ((int)graphicsDeviceType != 2)
		{
			switch (graphicsDeviceType - 16)
			{
			case 1:
				platformCubemapFaceMatrices = cubemapFaceMatrices;
				break;
			case 2:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			case 5:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			case 0:
				platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
				break;
			default:
				platformCubemapFaceMatrices = null;
				break;
			}
		}
		else
		{
			platformCubemapFaceMatrices = cubemapFaceMatricesD3D11;
		}
		if (platformCubemapFaceMatrices == null)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogError((object)("[ReflectionProbeEx] Initialization failed. No cubemap ortho basis defined for " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString()));
			return false;
		}
		return true;
	}

	private int FastLog2(int value)
	{
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		return tab32[(uint)((long)value * 130329821L) >> 27];
	}

	private uint ReverseBits(uint bits)
	{
		bits = (bits << 16) | (bits >> 16);
		bits = ((bits & 0xFF00FF) << 8) | ((bits & 0xFF00FF00u) >> 8);
		bits = ((bits & 0xF0F0F0F) << 4) | ((bits & 0xF0F0F0F0u) >> 4);
		bits = ((bits & 0x33333333) << 2) | ((bits & 0xCCCCCCCCu) >> 2);
		bits = ((bits & 0x55555555) << 1) | ((bits & 0xAAAAAAAAu) >> 1);
		return bits;
	}

	private void SafeCreateMaterial(ref Material mat, Shader shader)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Expected O, but got Unknown
		if ((Object)(object)mat == (Object)null)
		{
			mat = new Material(shader);
		}
	}

	private void SafeCreateMaterial(ref Material mat, string shaderName)
	{
		if ((Object)(object)mat == (Object)null)
		{
			SafeCreateMaterial(ref mat, Shader.Find(shaderName));
		}
	}

	private void SafeCreateCubeRT(ref RenderTexture rt, string name, int size, int depth, bool mips, TextureDimension dim, FilterMode filter, RenderTextureFormat format, RenderTextureReadWrite readWrite = 1)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Expected O, but got Unknown
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Invalid comparison between Unknown and I4
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rt == (Object)null || !rt.IsCreated())
		{
			SafeDestroy<RenderTexture>(ref rt);
			rt = new RenderTexture(size, size, depth, format, readWrite)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).dimension = dim;
			if ((int)dim == 5)
			{
				rt.volumeDepth = 6;
			}
			rt.useMipMap = mips;
			rt.autoGenerateMips = false;
			((Texture)rt).filterMode = filter;
			((Texture)rt).anisoLevel = 0;
			rt.Create();
		}
	}

	private void SafeCreateCB(ref CommandBuffer cb, string name)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		if (cb == null)
		{
			cb = new CommandBuffer();
			cb.name = name;
		}
	}

	private void SafeDestroy<T>(ref T obj) where T : Object
	{
		if ((Object)(object)obj != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)obj);
			obj = default(T);
		}
	}

	private void SafeDispose<T>(ref T obj) where T : IDisposable
	{
		if (obj != null)
		{
			obj.Dispose();
			obj = default(T);
		}
	}
}


using System;

[Serializable]
public enum ConvolutionQuality
{
	Lowest,
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine;

[Serializable]
public struct RenderListEntry
{
	public Renderer renderer;

	public bool alwaysEnabled;

	public RenderListEntry(Renderer renderer, bool alwaysEnabled)
	{
		this.renderer = renderer;
		this.alwaysEnabled = alwaysEnabled;
	}
}


using UnityEngine;

private struct CubemapSkyboxVertex
{
	public float x;

	public float y;

	public float z;

	public Color color;

	public float tu;

	public float tv;

	public float tw;
}


using UnityEngine;

private struct CubemapFaceMatrices
{
	public Matrix4x4 worldToView;

	public Matrix4x4 viewToWorld;

	public CubemapFaceMatrices(Vector3 x, Vector3 y, Vector3 z)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		worldToView = Matrix4x4.identity;
		((Matrix4x4)(ref worldToView))[0, 0] = ((Vector3)(ref x))[0];
		((Matrix4x4)(ref worldToView))[0, 1] = ((Vector3)(ref x))[1];
		((Matrix4x4)(ref worldToView))[0, 2] = ((Vector3)(ref x))[2];
		((Matrix4x4)(ref worldToView))[1, 0] = ((Vector3)(ref y))[0];
		((Matrix4x4)(ref worldToView))[1, 1] = ((Vector3)(ref y))[1];
		((Matrix4x4)(ref worldToView))[1, 2] = ((Vector3)(ref y))[2];
		((Matrix4x4)(ref worldToView))[2, 0] = ((Vector3)(ref z))[0];
		((Matrix4x4)(ref worldToView))[2, 1] = ((Vector3)(ref z))[1];
		((Matrix4x4)(ref worldToView))[2, 2] = ((Vector3)(ref z))[2];
		viewToWorld = ((Matrix4x4)(ref worldToView)).inverse;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public static class CommandBufferEx
{
	public static void BlitArray(this CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Material mat, int slice, int pass = 0)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		cb.SetGlobalTexture("_Source", source);
		cb.SetGlobalFloat("_SourceMip", 0f);
		if (slice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)slice);
			cb.SetGlobalInt("_TargetSlice", slice);
		}
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitArray(this CommandBuffer cb, Mesh blitMesh, RenderTargetIdentifier source, Texture target, Material mat, int slice, int pass = 0)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		cb.SetRenderTarget(RenderTargetIdentifier.op_Implicit(target), 0, (CubemapFace)(-1), -1);
		cb.SetGlobalTexture("_Source", source);
		cb.SetGlobalFloat("_SourceMip", 0f);
		if (slice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)slice);
			cb.SetGlobalInt("_TargetSlice", slice);
		}
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitArrayMip(this CommandBuffer cb, Mesh blitMesh, Texture source, int sourceMip, int sourceSlice, Texture target, int targetMip, int targetSlice, Material mat, int pass = 0)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		int num = source.width >> sourceMip;
		int num2 = source.height >> sourceMip;
		Vector4 val = default(Vector4);
		((Vector4)(ref val))..ctor(1f / (float)num, 1f / (float)num2, (float)num, (float)num2);
		int num3 = target.width >> targetMip;
		int num4 = target.height >> targetMip;
		Vector4 val2 = default(Vector4);
		((Vector4)(ref val2))..ctor(1f / (float)num3, 1f / (float)num4, (float)num3, (float)num4);
		cb.SetGlobalTexture("_Source", RenderTargetIdentifier.op_Implicit(source));
		cb.SetGlobalVector("_Source_TexelSize", val);
		cb.SetGlobalVector("_Target_TexelSize", val2);
		cb.SetGlobalFloat("_SourceMip", (float)sourceMip);
		if (sourceSlice >= 0)
		{
			cb.SetGlobalFloat("_SourceSlice", (float)sourceSlice);
			cb.SetGlobalInt("_TargetSlice", targetSlice);
		}
		cb.SetRenderTarget(RenderTargetIdentifier.op_Implicit(target), targetMip, (CubemapFace)(-1), -1);
		cb.DrawMesh(blitMesh, Matrix4x4.identity, mat, 0, pass);
	}

	public static void BlitMip(this CommandBuffer cb, Mesh blitMesh, Texture source, Texture target, int mip, int slice, Material mat, int pass = 0)
	{
		cb.BlitArrayMip(blitMesh, source, mip, slice, target, mip, slice, mat, pass);
	}
}


using Rust.RenderPipeline.Runtime;
using UnityEngine;

[CreateAssetMenu(menuName = "Rendering/RustRendererFeatures/DecalsRendererFeature")]
public class DecalsRendererFeature : RustRendererFeature
{
	[SerializeField]
	private bool enableDeferredDecals = true;

	[SerializeField]
	private bool enableDeferredMeshDecals = true;

	public override void Create()
	{
	}

	public override void AddRenderPasses(RustRenderer renderer)
	{
	}
}


using Rust.RenderPipeline.Runtime;

public class DeferredDecalsRenderPass : RustRenderPass
{
}


using Rust.RenderPipeline.Runtime;

public class DeferredMeshDecalRenderPass : RustRenderPass
{
}


using Rust.RenderPipeline.Runtime;

public class SpatialEnvironmentVolumeDrawPass : RustRenderPass
{
}


using Rust.RenderPipeline.Runtime;
using UnityEngine;

[CreateAssetMenu(menuName = "Rendering/RustRendererFeatures/SpatialEnvironmentVolume")]
public class SpatialEnvironmentVolumeRendererFeature : RustRendererFeature
{
	[SerializeField]
	private Shader shader;

	[SerializeField]
	private Shader copyToDepthBufferShader;

	[SerializeField]
	private Mesh cubeMesh;

	[SerializeField]
	private Mesh sphereMesh;

	[SerializeField]
	private Mesh capsuleMesh;

	[SerializeField]
	private EnvironmentVolumePropertiesCollection environmentVolumeProperties;

	public override void Create()
	{
	}

	public override void AddRenderPasses(RustRenderer renderer)
	{
	}
}


using UnityEngine;

[ExecuteAlways]
[RequireComponent(typeof(Camera))]
public class SpatialBiomeFog : SingletonComponent<SpatialBiomeFog>
{
}


using UnityEngine;

public class TextureStreaming : SingletonComponent<MonoBehaviour>, IClientComponent
{
}


using UnityEngine;

[ExecuteInEditMode]
public class VolumeClouds : SingletonComponent<VolumeClouds>
{
	public struct NoiseOffsets
	{
		public Vector2 CoverageBase;

		public Vector2 CoverageDetailPerlin;

		public Vector2 CoverageDetailWorley;

		public static NoiseOffsets Default(VolumeCloudsWeatherLayerConfig cfg)
		{
			NoiseOffsets result = default(NoiseOffsets);
			result.CoverageBase.x = cfg.CoverageBase.Offset.x;
			result.CoverageBase.y = cfg.CoverageBase.Offset.y;
			result.CoverageDetailPerlin.x = cfg.CoverageDetailPerlin.Offset.x;
			result.CoverageDetailPerlin.y = cfg.CoverageDetailPerlin.Offset.y;
			result.CoverageDetailWorley.x = cfg.CoverageDetailWorley.Offset.x;
			result.CoverageDetailWorley.y = cfg.CoverageDetailWorley.Offset.y;
			return result;
		}

		private static Vector2 RandVector(ref uint seed)
		{
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			float num = SeedRandom.Range(++seed, -100f, 100f);
			float num2 = SeedRandom.Range(++seed, -100f, 100f);
			return new Vector2(num, num2);
		}

		public static NoiseOffsets Random(uint seed)
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			NoiseOffsets result = default(NoiseOffsets);
			result.CoverageBase = RandVector(ref seed);
			result.CoverageDetailPerlin = RandVector(ref seed);
			result.CoverageDetailWorley = RandVector(ref seed);
			return result;
		}
	}

	private static readonly int PID_DetailNoise = Shader.PropertyToID("_DetailNoise");

	private static readonly int PID_DetailScale = Shader.PropertyToID("_DetailScale");

	private static readonly int PID_Billows = Shader.PropertyToID("_Billows");

	private static readonly int PID_BillowsGamma = Shader.PropertyToID("_BillowsGamma");

	private static readonly int PID_BillowsFrequencyCurve = Shader.PropertyToID("_BillowsFrequencyCurve");

	private static readonly int PID_Wisps = Shader.PropertyToID("_Wisps");

	private static readonly int PID_WispsGamma = Shader.PropertyToID("_WispsGamma");

	private static readonly int PID_WispsFrequencyCurve = Shader.PropertyToID("_WispsFrequencyCurve");

	private static readonly int PID_DetailTypeDensityCurve = Shader.PropertyToID("_DetailTypeDensityCurve");

	private static readonly int PID_DetailTypeHeightTransition = Shader.PropertyToID("_DetailTypeHeightTransition");

	private static readonly int PID_WeatherMap = Shader.PropertyToID("_VolumeCloudsWeatherMap");

	private static readonly int PID_WeatherScale = Shader.PropertyToID("_VolumeCloudsWeatherMapScale");

	private static readonly int PID_Wind = Shader.PropertyToID("_VolumeCloudsWindVector");

	private static readonly int PID_Coverage = Shader.PropertyToID("_Coverage");

	private static readonly int PID_DensityScale = Shader.PropertyToID("_DensityScale");

	private static readonly int PID_DensityCurve = Shader.PropertyToID("_DensityCurve");

	private static readonly int PID_WispsDensitySoftening = Shader.PropertyToID("_WispsDensitySoftening");

	private static readonly int PID_MSIntensity = Shader.PropertyToID("_MSIntensity");

	private static readonly int PID_MSAbsorption = Shader.PropertyToID("_MSAbsorption");

	private static readonly int PID_MSMinDepth = Shader.PropertyToID("_MSMinDepth");

	private static readonly int PID_MSDepthFalloff = Shader.PropertyToID("_MSDepthFalloff");

	private static readonly int PID_Eccentricity = Shader.PropertyToID("_Eccentricity");

	private static readonly int PID_AmbientScatteringFalloff = Shader.PropertyToID("_AmbientScatteringFalloff");

	private static readonly int PID_ScatterBrightnessContrast = Shader.PropertyToID("_ScatterBrightnessContrast");

	private static readonly int PID_Absorption = Shader.PropertyToID("_Absorption");

	private static readonly int PID_CloudTypeTop = Shader.PropertyToID("_CloudTypeTop");

	private static readonly int PID_CloudTypeBottom = Shader.PropertyToID("_CloudTypeBottom");

	private static readonly int PID_MipDistance = Shader.PropertyToID("_MipDistance");

	private static readonly int PID_BlueNoise = Shader.PropertyToID("_BlueNoise");

	private static readonly int PID_CirrusOpaqueness = Shader.PropertyToID("_CirrusOpaqueness");

	private static readonly int PID_CirrusAbsorption = Shader.PropertyToID("_CirrusAbsorption");

	private static readonly int PID_CirrusEccentricity = Shader.PropertyToID("_CirrusEccentricity");

	private static readonly int PID_CirrusWeatherMap = Shader.PropertyToID("_CirrusWeatherMap");

	private static readonly int PID_CirrusWeatherMapScale = Shader.PropertyToID("_CirrusWeatherMapScale");

	private static readonly int PID_OutputTexture = Shader.PropertyToID("_OutputImage");

	private static readonly int PID_OutputImageSize = Shader.PropertyToID("_OutputImageSize");

	private static readonly int PID_CamPos = Shader.PropertyToID("_CamPos");

	private static readonly int PID_VolumeCloudTex = Shader.PropertyToID("_VolumeCloudTex");

	private static readonly int PID_VolumeCloudReflTex = Shader.PropertyToID("_VolumeCloudReflTex");

	private static readonly int PID_CloudTexSize = Shader.PropertyToID("_CloudTexSize");

	private static readonly int PID_FrameCount = Shader.PropertyToID("_FrameCount");

	private static readonly int PID_CamProjInv = Shader.PropertyToID("_CamProjInv");

	private static readonly int PID_StepCount = Shader.PropertyToID("_StepCount");

	private static readonly int PID_StepCountLow = Shader.PropertyToID("_StepCountLow");

	private static readonly int PID_VerticalProfileTopOffset = Shader.PropertyToID("_VerticalProfileTopOffset");

	private static readonly int PID_VerticalProfileTopScale = Shader.PropertyToID("_VerticalProfileTopScale");

	private static readonly int PID_VerticalProfileBottomOffset = Shader.PropertyToID("_VerticalProfileBottomOffset");

	private static readonly int PID_VerticalProfileBottomScale = Shader.PropertyToID("_VerticalProfileBottomScale");

	private static readonly int PID_WeatherScrollOffset = Shader.PropertyToID("_VolumeCloudsWeatherScrollOffset");

	private static readonly int PID_BlueNoiseOffset = Shader.PropertyToID("_BlueNoiseOffset");

	private static readonly int PID_RenderType = Shader.PropertyToID("_RenderType");

	private static readonly int PID_NumRadialLayers = Shader.PropertyToID("_NumRadialLayers");

	private static readonly int PID_LerpT = Shader.PropertyToID("_LerpT");

	private static readonly int PID_LerpSourceImage = Shader.PropertyToID("_LerpSourceImage");

	private static readonly int PID_LerpTargetImage = Shader.PropertyToID("_LerpTargetImage");

	private static readonly int PID_DepthBuffer = Shader.PropertyToID("_CloudDepthBuffer");

	private static readonly int PID_CamInvViewMatrix = Shader.PropertyToID("_CamInvViewMatrix");

	private static readonly int PID_PrevImage = Shader.PropertyToID("_PrevOutputImage");

	private static readonly int PID_LowResBuffer = Shader.PropertyToID("_LowResBuffer");

	private static readonly int PID_SizeDivisor = Shader.PropertyToID("_SizeDivisor");

	private static readonly int PID_ReprojectionMatrix = Shader.PropertyToID("_ReprojectionMatrix");

	private static readonly int PID_FirstFrame = Shader.PropertyToID("_FirstFrame");

	private static readonly int PID_CurrBlockOffsetX = Shader.PropertyToID("_CurrBlockOffsetX");

	private static readonly int PID_CurrBlockOffsetY = Shader.PropertyToID("_CurrBlockOffsetY");

	private static readonly int PID_ShadowInvViewProjMatrix = Shader.PropertyToID("_ShadowInvViewProjMatrix");

	private static readonly int PID_CloudShadowViewProj = Shader.PropertyToID("_CloudShadowViewProj");

	private static readonly int PID_CloudShadowMap = Shader.PropertyToID("_CloudShadowMap");

	private static readonly int PID_CloudShadowNearFar = Shader.PropertyToID("_CloudShadowNearFar");

	private static readonly int PID_SunColorScale = Shader.PropertyToID("_VolumeCloudsSunColorScale");

	private static readonly int PID_MoonColorScale = Shader.PropertyToID("_VolumeCloudsMoonColorScale");

	private static readonly int PID_AmbientColorScale = Shader.PropertyToID("_VolumeCloudsAmbientColorScale");

	private static readonly int PID_AmbientSaturation = Shader.PropertyToID("_VolumeCloudsAmbientSaturation");

	private static readonly int PID_MoonSaturation = Shader.PropertyToID("_VolumeCloudsMoonSaturation");

	private static readonly int PID_VolumeCloudsGroundRadius = Shader.PropertyToID("_VolumeCloudsGroundRadius");

	private static readonly int PID_CloudAmbientLight = Shader.PropertyToID("_CloudAmbientLight");

	private static readonly int PID_WindShear = Shader.PropertyToID("_WindShear");

	private static readonly int PID_ShadowDensityScale = Shader.PropertyToID("_VolumeCloudsShadowDensityScale");

	private static readonly int PID_AtmosphereShadowDensityScale = Shader.PropertyToID("_VolumeCloudsAtmosphereShadowDensityScale");

	private static readonly int PID_CloudHazeDensity = Shader.PropertyToID("_CloudHazeDensity");

	private static readonly int PID_CloudHazeHeightFalloff = Shader.PropertyToID("_CloudHazeHeightFalloff");

	private static readonly int PID_CloudHazeRampStartDistance = Shader.PropertyToID("_CloudHazeRampStartDistance");

	private static readonly int PID_CloudHazeRampEndDistance = Shader.PropertyToID("_CloudHazeRampEndDistance");

	private static readonly int PID_TODLerpValue = Shader.PropertyToID("_TOD_LerpValue");

	private static readonly int PID_HorizonBuffer = Shader.PropertyToID("_HorizonBuffer");

	private static readonly int PID_ApplySunContrast = Shader.PropertyToID("_VCloudsSunContrast");

	private static readonly int PID_ApplySunFogginess = Shader.PropertyToID("_VCloudsSunFogginess");

	private static readonly int PID_DetailScrollOffset = Shader.PropertyToID("_DetailScrollOffset");

	private int[,] PID_InstabilityParams;

	private int[,] PID_CoverageBaseParams;

	private int[,] PID_CoverageDetailParams;

	private int[,] PID_CoverageDetailWParams;

	private int[,] PID_RadialLayerParams;

	private int[,] PID_CurlNoiseParams;

	private void FetchShaderPropertyIDs()
	{
		char[] array = new char[4] { 'A', 'B', 'C', 'D' };
		PID_InstabilityParams = new int[4, 3];
		PID_CoverageBaseParams = new int[4, 3];
		PID_CoverageDetailParams = new int[4, 3];
		PID_CoverageDetailWParams = new int[4, 2];
		PID_RadialLayerParams = new int[3, 2];
		PID_CurlNoiseParams = new int[4, 1];
		for (int i = 0; i < 4; i++)
		{
			PID_InstabilityParams[i, 0] = Shader.PropertyToID($"_InstabilityParams{array[i]}0");
			PID_InstabilityParams[i, 1] = Shader.PropertyToID($"_InstabilityParams{array[i]}1");
			PID_InstabilityParams[i, 2] = Shader.PropertyToID($"_InstabilityParams{array[i]}2");
			PID_CoverageBaseParams[i, 0] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}0");
			PID_CoverageBaseParams[i, 1] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}1");
			PID_CoverageBaseParams[i, 2] = Shader.PropertyToID($"_CoverageBaseParams{array[i]}2");
			PID_CoverageDetailParams[i, 0] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}0");
			PID_CoverageDetailParams[i, 1] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}1");
			PID_CoverageDetailParams[i, 2] = Shader.PropertyToID($"_CoverageDetailParams{array[i]}2");
			PID_CoverageDetailWParams[i, 0] = Shader.PropertyToID($"_CoverageDetailWParams{array[i]}0");
			PID_CoverageDetailWParams[i, 1] = Shader.PropertyToID($"_CoverageDetailWParams{array[i]}1");
			PID_CurlNoiseParams[i, 0] = Shader.PropertyToID($"_CurlParams{array[i]}0");
		}
		for (int j = 0; j < 3; j++)
		{
			PID_RadialLayerParams[j, 0] = Shader.PropertyToID($"_RadialLayerParams{array[j]}0");
			PID_RadialLayerParams[j, 1] = Shader.PropertyToID($"_RadialLayerParams{array[j]}1");
		}
	}
}


using UnityEngine;

public struct NoiseOffsets
{
	public Vector2 CoverageBase;

	public Vector2 CoverageDetailPerlin;

	public Vector2 CoverageDetailWorley;

	public static NoiseOffsets Default(VolumeCloudsWeatherLayerConfig cfg)
	{
		NoiseOffsets result = default(NoiseOffsets);
		result.CoverageBase.x = cfg.CoverageBase.Offset.x;
		result.CoverageBase.y = cfg.CoverageBase.Offset.y;
		result.CoverageDetailPerlin.x = cfg.CoverageDetailPerlin.Offset.x;
		result.CoverageDetailPerlin.y = cfg.CoverageDetailPerlin.Offset.y;
		result.CoverageDetailWorley.x = cfg.CoverageDetailWorley.Offset.x;
		result.CoverageDetailWorley.y = cfg.CoverageDetailWorley.Offset.y;
		return result;
	}

	private static Vector2 RandVector(ref uint seed)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		float num = SeedRandom.Range(++seed, -100f, 100f);
		float num2 = SeedRandom.Range(++seed, -100f, 100f);
		return new Vector2(num, num2);
	}

	public static NoiseOffsets Random(uint seed)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		NoiseOffsets result = default(NoiseOffsets);
		result.CoverageBase = RandVector(ref seed);
		result.CoverageDetailPerlin = RandVector(ref seed);
		result.CoverageDetailWorley = RandVector(ref seed);
		return result;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Cirrus Config")]
public class VolumeCloudsCirrusConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig WeatherLayer = new VolumeCloudsWeatherLayerConfig();

	public float Opaqueness = 1f;

	public float Absorption = 0.2f;

	public float Eccentricity = 0.3f;

	public float CloudTextureGamma = 1f;

	public float CloudTextureScale = 1f;

	public void CopyWeatherGen(VolumeCloudsCirrusConfig copy)
	{
		WeatherLayer.CopyFrom(copy.WeatherLayer);
	}

	public void CopyFrom(VolumeCloudsCirrusConfig copy)
	{
		CopyWeatherGen(copy);
		Opaqueness = copy.Opaqueness;
		Absorption = copy.Absorption;
		Eccentricity = copy.Eccentricity;
		CloudTextureGamma = copy.CloudTextureGamma;
		CloudTextureScale = copy.CloudTextureScale;
	}

	public void Lerp(VolumeCloudsCirrusConfig a, VolumeCloudsCirrusConfig b, float t)
	{
		Opaqueness = Mathf.Lerp(a.Opaqueness, b.Opaqueness, t);
		Absorption = Mathf.Lerp(a.Absorption, b.Absorption, t);
		Eccentricity = Mathf.Lerp(a.Eccentricity, b.Eccentricity, t);
		CloudTextureGamma = Mathf.Lerp(a.CloudTextureGamma, b.CloudTextureGamma, t);
		CloudTextureScale = Mathf.Lerp(a.CloudTextureScale, b.CloudTextureScale, t);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Cloud Config")]
public class VolumeCloudsConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig WeatherLayer = new VolumeCloudsWeatherLayerConfig();

	[Header("Detail")]
	[Range(0f, 1f)]
	public float Billows = 1f;

	[Range(0f, 3f)]
	public float BillowsGamma = 2f;

	[Range(0f, 2f)]
	public float BillowsFrequencyCurve = 0.45f;

	[Range(0f, 1f)]
	public float Wisps = 1f;

	[Range(0f, 3f)]
	public float WispsGamma = 2f;

	[Range(0f, 2f)]
	public float WispsFrequencyCurve = 1f;

	[Range(0f, 2f)]
	public float DetailTypeDensityCurve = 0.25f;

	[Range(0.001f, 1f)]
	public float DetailTypeHeightTransition = 0.3f;

	[Range(0f, 2f)]
	public float CurlNoiseScale = 0.2f;

	public float CurlNoiseStrength = 50f;

	[Header("Density")]
	[Range(0f, 1f)]
	public float DensityScale = 0.05f;

	[Range(0f, 1f)]
	public float DensityCurve = 0.4f;

	[Range(0f, 1f)]
	public float WispsDensitySoftening = 0.3f;

	[Header("Multiple Scattering")]
	public float MSIntensity = 1f;

	[Range(0f, 1f)]
	public float MSAbsorption = 0.5f;

	[Range(0f, 2f)]
	public float MSDepthFalloff = 1f;

	[Range(0f, 1f)]
	public float MSMinDepth = 0.01f;

	[Header("Direct Scattering")]
	public Gradient SunColorScale;

	[Range(-1f, 1f)]
	public float SunEccentricity1 = 0.6f;

	[Range(-1f, 1f)]
	public float SunEccentricity2 = 0.2f;

	public Gradient MoonColorScale;

	[Range(-1f, 1f)]
	public float MoonEccentricity1 = 0.9f;

	[Range(-1f, 1f)]
	public float MoonEccentricity2 = 0.2f;

	[Range(0f, 2f)]
	public float MoonSaturation = 1f;

	[Range(0f, 3f)]
	public float DirectScatterBrightness = 1f;

	[Range(0f, 3f)]
	public float DirectScatterContrast = 1f;

	[Range(0f, 2f)]
	public float Absorption = 1f;

	[Header("Ambient Scattering")]
	public Gradient AmbientColorScale;

	[Range(0f, 1f)]
	public float AmbientSaturation = 0.6f;

	[Range(0f, 2f)]
	public float AmbientScatteringFalloff = 1f;

	[Range(0f, 3f)]
	public float AmbientScatterBrightness = 1f;

	[Range(0f, 3f)]
	public float AmbientScatterContrast = 1f;

	[Range(0f, 1f)]
	[Header("Other")]
	public float CoverageScale = 1f;

	[Range(0f, 1f)]
	public float CloudTypeTop = 1f;

	[Range(0f, 1f)]
	public float CloudTypeBottom;

	[Range(0f, 1f)]
	public float VerticalProfileTopEnd = 1f;

	[Range(0f, 1f)]
	public float VerticalProfileTopStart;

	[Range(0f, 1f)]
	public float VerticalProfileBottomStart = 1f;

	[Range(0f, 1f)]
	public float VerticalProfileBottomEnd;

	public float WindShear;

	public Vector2 WindVector = new Vector2(0f, 1f);

	[Range(0f, 1f)]
	public float ShadowDensityScale = 1f;

	[Range(0f, 1f)]
	public float AtmosphereShadowDensityScale = 1f;

	[Min(0f)]
	public float HazeDensity = 1f;

	[Min(0f)]
	public float HazeHeightFalloff = 0.035f;

	[Range(0f, 1f)]
	public float HorizonBuffer;

	public float EvalSunColorScale { get; set; }

	public float EvalMoonColorScale { get; set; }

	public float EvalAmbientColorScale { get; set; }

	public void CopyWeatherGen(VolumeCloudsConfig copy)
	{
		WeatherLayer.CopyFrom(copy.WeatherLayer);
	}

	public void CopyFrom(VolumeCloudsConfig copy)
	{
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		CopyWeatherGen(copy);
		Billows = copy.Billows;
		BillowsGamma = copy.BillowsGamma;
		BillowsFrequencyCurve = copy.BillowsFrequencyCurve;
		Wisps = copy.Wisps;
		WispsGamma = copy.WispsGamma;
		WispsFrequencyCurve = copy.WispsFrequencyCurve;
		DetailTypeDensityCurve = copy.DetailTypeDensityCurve;
		DetailTypeHeightTransition = copy.DetailTypeHeightTransition;
		CurlNoiseScale = copy.CurlNoiseScale;
		CurlNoiseStrength = copy.CurlNoiseStrength;
		DensityScale = copy.DensityScale;
		DensityCurve = copy.DensityCurve;
		WispsDensitySoftening = copy.WispsDensitySoftening;
		SunEccentricity1 = copy.SunEccentricity1;
		SunEccentricity2 = copy.SunEccentricity2;
		AmbientScatteringFalloff = copy.AmbientScatteringFalloff;
		Absorption = copy.Absorption;
		SunColorScale.SetKeys(copy.SunColorScale.colorKeys, copy.SunColorScale.alphaKeys);
		AmbientColorScale.SetKeys(copy.AmbientColorScale.colorKeys, copy.AmbientColorScale.alphaKeys);
		AmbientSaturation = copy.AmbientSaturation;
		CoverageScale = copy.CoverageScale;
		MSIntensity = copy.MSIntensity;
		MSAbsorption = copy.MSAbsorption;
		MSDepthFalloff = copy.MSDepthFalloff;
		MSMinDepth = copy.MSMinDepth;
		CloudTypeTop = copy.CloudTypeTop;
		CloudTypeBottom = copy.CloudTypeBottom;
		MoonColorScale.SetKeys(copy.MoonColorScale.colorKeys, copy.MoonColorScale.alphaKeys);
		MoonEccentricity1 = copy.MoonEccentricity1;
		MoonEccentricity2 = copy.MoonEccentricity2;
		MoonSaturation = copy.MoonSaturation;
		VerticalProfileTopEnd = copy.VerticalProfileTopEnd;
		VerticalProfileTopStart = copy.VerticalProfileTopStart;
		VerticalProfileBottomStart = copy.VerticalProfileBottomStart;
		VerticalProfileBottomEnd = copy.VerticalProfileBottomEnd;
		DirectScatterBrightness = copy.DirectScatterBrightness;
		DirectScatterContrast = copy.DirectScatterContrast;
		AmbientScatterBrightness = copy.AmbientScatterBrightness;
		AmbientScatterContrast = copy.AmbientScatterContrast;
		WindShear = copy.WindShear;
		WindVector = copy.WindVector;
		ShadowDensityScale = copy.ShadowDensityScale;
		AtmosphereShadowDensityScale = copy.AtmosphereShadowDensityScale;
		HazeDensity = copy.HazeDensity;
		HazeHeightFalloff = copy.HazeHeightFalloff;
		HorizonBuffer = copy.HorizonBuffer;
		EvalSunColorScale = copy.EvalSunColorScale;
		EvalMoonColorScale = copy.EvalMoonColorScale;
		EvalAmbientColorScale = copy.EvalAmbientColorScale;
	}

	public void Lerp(VolumeCloudsConfig a, VolumeCloudsConfig b, float t)
	{
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		Billows = Mathf.Lerp(a.Billows, b.Billows, t);
		BillowsGamma = Mathf.Lerp(a.BillowsGamma, b.BillowsGamma, t);
		BillowsFrequencyCurve = Mathf.Lerp(a.BillowsFrequencyCurve, b.BillowsFrequencyCurve, t);
		Wisps = Mathf.Lerp(a.Wisps, b.Wisps, t);
		WispsGamma = Mathf.Lerp(a.WispsGamma, b.WispsGamma, t);
		WispsFrequencyCurve = Mathf.Lerp(a.WispsFrequencyCurve, b.WispsFrequencyCurve, t);
		DetailTypeDensityCurve = Mathf.Lerp(a.DetailTypeDensityCurve, b.DetailTypeDensityCurve, t);
		DetailTypeHeightTransition = Mathf.Lerp(a.DetailTypeHeightTransition, b.DetailTypeHeightTransition, t);
		CurlNoiseScale = Mathf.Lerp(a.CurlNoiseScale, b.CurlNoiseScale, t);
		CurlNoiseStrength = Mathf.Lerp(a.CurlNoiseStrength, b.CurlNoiseStrength, t);
		DensityScale = Mathf.Lerp(a.DensityScale, b.DensityScale, t);
		DensityCurve = Mathf.Lerp(a.DensityCurve, b.DensityCurve, t);
		WispsDensitySoftening = Mathf.Lerp(a.WispsDensitySoftening, b.WispsDensitySoftening, t);
		MSIntensity = Mathf.Lerp(a.MSIntensity, b.MSIntensity, t);
		MSAbsorption = Mathf.Lerp(a.MSAbsorption, b.MSAbsorption, t);
		MSDepthFalloff = Mathf.Lerp(a.MSDepthFalloff, b.MSDepthFalloff, t);
		MSMinDepth = Mathf.Lerp(a.MSMinDepth, b.MSMinDepth, t);
		SunEccentricity1 = Mathf.Lerp(a.SunEccentricity1, b.SunEccentricity1, t);
		SunEccentricity2 = Mathf.Lerp(a.SunEccentricity2, b.SunEccentricity2, t);
		EvalAmbientColorScale = Mathf.Lerp(a.EvalAmbientColorScale, b.EvalAmbientColorScale, t);
		EvalSunColorScale = Mathf.Lerp(a.EvalSunColorScale, b.EvalSunColorScale, t);
		EvalMoonColorScale = Mathf.Lerp(a.EvalMoonColorScale, b.EvalMoonColorScale, t);
		AmbientSaturation = Mathf.Lerp(a.AmbientSaturation, b.AmbientSaturation, t);
		AmbientScatteringFalloff = Mathf.Lerp(a.AmbientScatteringFalloff, b.AmbientScatteringFalloff, t);
		Absorption = Mathf.Lerp(a.Absorption, b.Absorption, t);
		CoverageScale = Mathf.Lerp(a.CoverageScale, b.CoverageScale, t);
		CloudTypeTop = Mathf.Lerp(a.CloudTypeTop, b.CloudTypeTop, t);
		CloudTypeBottom = Mathf.Lerp(a.CloudTypeBottom, b.CloudTypeBottom, t);
		MoonEccentricity1 = Mathf.Lerp(a.MoonEccentricity1, b.MoonEccentricity1, t);
		MoonEccentricity2 = Mathf.Lerp(a.MoonEccentricity2, b.MoonEccentricity2, t);
		MoonSaturation = Mathf.Lerp(a.MoonSaturation, b.MoonSaturation, t);
		DirectScatterBrightness = Mathf.Lerp(a.DirectScatterBrightness, b.DirectScatterBrightness, t);
		DirectScatterContrast = Mathf.Lerp(a.DirectScatterContrast, b.DirectScatterContrast, t);
		AmbientScatterBrightness = Mathf.Lerp(a.AmbientScatterBrightness, b.AmbientScatterBrightness, t);
		AmbientScatterContrast = Mathf.Lerp(a.AmbientScatterContrast, b.AmbientScatterContrast, t);
		VerticalProfileTopStart = Mathf.Lerp(a.VerticalProfileTopStart, b.VerticalProfileTopStart, t);
		VerticalProfileTopEnd = Mathf.Lerp(a.VerticalProfileTopEnd, b.VerticalProfileTopEnd, t);
		VerticalProfileBottomStart = Mathf.Lerp(a.VerticalProfileBottomStart, b.VerticalProfileBottomStart, t);
		VerticalProfileBottomEnd = Mathf.Lerp(a.VerticalProfileBottomEnd, b.VerticalProfileBottomEnd, t);
		WindShear = Mathf.Lerp(a.WindShear, b.WindShear, t);
		WindVector = Vector2.Lerp(a.WindVector, b.WindVector, t);
		ShadowDensityScale = Mathf.Lerp(a.ShadowDensityScale, b.ShadowDensityScale, t);
		AtmosphereShadowDensityScale = Mathf.Lerp(a.AtmosphereShadowDensityScale, b.AtmosphereShadowDensityScale, t);
		HazeDensity = Mathf.Lerp(a.HazeDensity, b.HazeDensity, t);
		HazeHeightFalloff = Mathf.Lerp(a.HazeHeightFalloff, b.HazeHeightFalloff, t);
		HorizonBuffer = Mathf.Lerp(a.HorizonBuffer, b.HorizonBuffer, t);
	}
}


using System;
using System.Text;
using UnityEngine;

[Serializable]
public class VolumeCloudsNoiseLayerConfig
{
	[Range(0f, 6f)]
	public float Ceiling = 1f;

	[Range(-5f, 1f)]
	public float Floor;

	public Vector2 Frequency = Vector2.one;

	public Vector3 Offset = Vector3.zero;

	public int Octaves = 1;

	public float Rotation;

	[Range(0.001f, 10f)]
	public float Exponent = 1f;

	public void CopyFrom(VolumeCloudsNoiseLayerConfig copy)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Floor = copy.Floor;
		Ceiling = copy.Ceiling;
		Frequency = copy.Frequency;
		Offset = copy.Offset;
		Octaves = copy.Octaves;
		Rotation = copy.Rotation;
		Exponent = copy.Exponent;
	}

	public void Lerp(VolumeCloudsNoiseLayerConfig a, VolumeCloudsNoiseLayerConfig b, float t)
	{
		Floor = Mathf.SmoothStep(a.Floor, b.Floor, t);
		Ceiling = Mathf.SmoothStep(a.Ceiling, b.Ceiling, t);
		Frequency.x = Mathf.SmoothStep(a.Frequency.x, b.Frequency.x, t);
		Frequency.y = Mathf.SmoothStep(a.Frequency.y, b.Frequency.y, t);
		Offset.x = Mathf.SmoothStep(a.Offset.x, b.Offset.x, t);
		Offset.y = Mathf.SmoothStep(a.Offset.y, b.Offset.y, t);
		Offset.z = Mathf.SmoothStep(a.Offset.z, b.Offset.z, t);
		Rotation = Mathf.SmoothStep(a.Rotation, b.Rotation, t);
		Exponent = Mathf.SmoothStep(a.Exponent, b.Exponent, t);
	}

	public void Output(StringBuilder sb, Vector2 ofs)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		sb.AppendLine($"Ceiling: {Ceiling}");
		sb.AppendLine($"Floor: {Floor}");
		sb.AppendLine($"Freq: {Frequency}");
		sb.AppendLine($"Offset: {ofs}");
		sb.AppendLine($"Octaves: {Octaves}");
		sb.AppendLine($"Exp: {Exponent}");
	}
}


using System;
using UnityEngine;

[Serializable]
public class VolumeCloudsCurlNoiseConfig
{
	public Vector2 Frequency = Vector2.one;

	public float Strength;

	public int Octaves = 1;

	public void CopyFrom(VolumeCloudsCurlNoiseConfig copy)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Frequency = copy.Frequency;
		Strength = copy.Strength;
		Octaves = copy.Octaves;
	}
}


using System;
using System.Text;

[Serializable]
public class VolumeCloudsWeatherLayerConfig
{
	public VolumeCloudsNoiseLayerConfig Instability = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageBase = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageDetailPerlin = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsNoiseLayerConfig CoverageDetailWorley = new VolumeCloudsNoiseLayerConfig();

	public VolumeCloudsCurlNoiseConfig Curl = new VolumeCloudsCurlNoiseConfig();

	public void CopyFrom(VolumeCloudsWeatherLayerConfig copy)
	{
		Instability.CopyFrom(copy.Instability);
		CoverageBase.CopyFrom(copy.CoverageBase);
		CoverageDetailPerlin.CopyFrom(copy.CoverageDetailPerlin);
		CoverageDetailWorley.CopyFrom(copy.CoverageDetailWorley);
		Curl.CopyFrom(copy.Curl);
	}

	public void Output(StringBuilder sb, VolumeClouds.NoiseOffsets ofs)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		sb.AppendLine("Cov base:");
		CoverageBase.Output(sb, ofs.CoverageBase);
		sb.AppendLine("Cov dp:");
		CoverageDetailPerlin.Output(sb, ofs.CoverageDetailPerlin);
		sb.AppendLine("Cov dw:");
		CoverageDetailWorley.Output(sb, ofs.CoverageDetailWorley);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Volume Clouds/Storm Layer Config")]
public class VolumeCloudsRadialWeatherLayerConfig : ScriptableObject
{
	public VolumeCloudsWeatherLayerConfig Weather = new VolumeCloudsWeatherLayerConfig();

	public bool Enabled;

	public float Radius;

	public Vector2 Offset;

	public float Falloff;

	public float Blend;

	public bool FollowCamera;

	public void CopyFrom(VolumeCloudsRadialWeatherLayerConfig copy)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Enabled = copy.Enabled;
		Radius = copy.Radius;
		Offset = copy.Offset;
		Falloff = copy.Falloff;
		Blend = copy.Blend;
		FollowCamera = copy.FollowCamera;
	}
}


using UnityEngine;

public class ClothWindModify : FacepunchBehaviour
{
	public Cloth cloth;

	private Vector3 initialClothForce;

	public Vector3 worldWindScale = Vector3.one;

	public Vector3 turbulenceScale = Vector3.one;
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(WindZone))]
public class WindZoneEx : MonoBehaviour
{
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(WindZone))]
public class WindZoneExManager : MonoBehaviour
{
	private enum TestMode
	{
		Disabled,
		Low
	}

	public float maxAccumMain = 4f;

	public float maxAccumTurbulence = 4f;

	public float globalMainScale = 1f;

	public float globalTurbulenceScale = 1f;

	public Transform testPosition;
}


private enum TestMode
{
	Disabled,
	Low
}


public enum RgbColor
{
	Default,
	BuildingPrivilege,
	Cold,
	Hot,
	Hurt,
	Healed,
	Irradiated,
	Comforted
}


using System.ComponentModel;
using UnityEngine;

public class RgbEffects : SingletonComponent<RgbEffects>
{
	[ClientVar(Help = "Enables RGB lighting effects (supports SteelSeries and Razer)", Saved = true)]
	public static bool Enabled = true;

	[ClientVar(Help = "Controls how RGB values are mapped to LED lights on SteelSeries devices", Saved = true)]
	public static Vector3 ColorCorrection_SteelSeries = new Vector3(1.5f, 1.5f, 1.5f);

	[ClientVar(Help = "Controls how RGB values are mapped to LED lights on Razer devices", Saved = true)]
	public static Vector3 ColorCorrection_Razer = new Vector3(3f, 3f, 3f);

	[ClientVar(Help = "Brightness of colors, from 0 to 1 (note: may affect color accuracy)", Saved = true)]
	public static float Brightness = 1f;

	public Color defaultColor;

	public Color buildingPrivilegeColor;

	public Color coldColor;

	public Color hotColor;

	public Color hurtColor;

	public Color healedColor;

	public Color irradiatedColor;

	public Color comfortedColor;

	[EditorBrowsable(EditorBrowsableState.Never)]
	[ClientVar(Name = "static")]
	public static void ConVar_Static(Arg args)
	{
	}

	[EditorBrowsable(EditorBrowsableState.Never)]
	[ClientVar(Name = "pulse")]
	public static void ConVar_Pulse(Arg args)
	{
	}
}


using System;
using System.Net;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Network;
using Rust;
using Rust.Platform.Common;

public class RustPlatformHooks : IPlatformHooks
{
	public static readonly RustPlatformHooks Instance = new RustPlatformHooks();

	public uint SteamAppId => Defines.appID;

	public ServerParameters? ServerParameters
	{
		get
		{
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			if (Net.sv == null)
			{
				return null;
			}
			IPAddress iPAddress = null;
			if (!string.IsNullOrEmpty(ConVar.Server.ip))
			{
				iPAddress = IPAddress.Parse(ConVar.Server.ip);
			}
			if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
			{
				ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
			}
			return new ServerParameters("rust", "Rust", 2597.ToString(), Net.sv.secure, CommandLine.HasSwitch("-sdrnet"), iPAddress, (ushort)Net.sv.port, (ushort)ConVar.Server.queryport);
		}
	}

	public void Abort()
	{
		Application.Quit();
	}

	public void OnItemDefinitionsChanged()
	{
		ItemManager.InvalidateWorkshopSkinCache();
	}

	public void AuthSessionValidated(ulong userId, ulong ownerUserId, AuthResponse response, string rawResponse)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnSteamAuth(userId, ownerUserId, rawResponse);
		SingletonComponent<ServerMgr>.Instance.OnValidateAuthTicketResponse(userId, ownerUserId, response);
	}
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

[RequireComponent(typeof(VideoPlayer))]
public class SafeVideoPlayer : MonoBehaviour
{
	[SerializeField]
	private VideoPlayer _videoPlayer;

	[SerializeField]
	private RawImage _outputImage;

	[SerializeField]
	private string primaryURL;

	[SerializeField]
	private string fallbackURL;
}


using UnityEngine;

public class SendMessageToEntityOnAnimationFinish : StateMachineBehaviour
{
	public string messageToSendToEntity;

	public float repeatRate = 0.1f;

	private const float lastMessageSent = 0f;

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (0f + repeatRate > Time.time || animator.IsInTransition(layerIndex) || ((AnimatorStateInfo)(ref stateInfo)).normalizedTime < 1f)
		{
			return;
		}
		for (int i = 0; i < animator.layerCount; i++)
		{
			if (i != layerIndex)
			{
				if (animator.IsInTransition(i))
				{
					return;
				}
				AnimatorStateInfo currentAnimatorStateInfo = animator.GetCurrentAnimatorStateInfo(i);
				if (((AnimatorStateInfo)(ref currentAnimatorStateInfo)).speed > 0f && ((AnimatorStateInfo)(ref currentAnimatorStateInfo)).normalizedTime < 1f)
				{
					return;
				}
			}
		}
		BaseEntity baseEntity = ((Component)animator).gameObject.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			((Component)baseEntity).SendMessage(messageToSendToEntity, (SendMessageOptions)1);
		}
	}
}


public enum AntiHackType
{
	None,
	NoClip,
	SpeedHack,
	FlyHack,
	ProjectileHack,
	MeleeHack,
	EyeHack,
	AttackHack,
	ReloadHack,
	CooldownHack,
	InsideTerrain,
	InsideGeometry,
	EffectHack,
	Ticks
}


using System;
using System.Collections.Generic;
using AntiHackJobs;
using ConVar;
using Epic.OnlineServices.Reports;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public static class AntiHack
{
	public struct Batch
	{
		public int PlayerIndex;

		public int Count;

		public bool Force;

		public bool ExcludeVehicleLayer;
	}

	private class GroupedLog : IPooled
	{
		public float firstLogTime;

		public string playerName;

		public AntiHackType antiHackType;

		public string message;

		public Vector3 averagePos;

		public int num;

		public GroupedLog()
		{
		}

		public GroupedLog(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			SetInitial(playerName, antiHackType, message, pos);
		}

		public void EnterPool()
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			firstLogTime = 0f;
			playerName = string.Empty;
			antiHackType = AntiHackType.None;
			averagePos = Vector3.zero;
			num = 0;
		}

		public void LeavePool()
		{
		}

		public void SetInitial(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			firstLogTime = Time.unscaledTime;
			this.playerName = playerName;
			this.antiHackType = antiHackType;
			this.message = message;
			averagePos = pos;
			num = 1;
		}

		public bool TryGroup(string playerName, AntiHackType antiHackType, string message, Vector3 pos, float maxDistance)
		{
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (antiHackType != this.antiHackType || playerName != this.playerName || message != this.message)
			{
				return false;
			}
			if (Vector3.SqrMagnitude(averagePos - pos) > maxDistance * maxDistance)
			{
				return false;
			}
			Vector3 val = averagePos * (float)num;
			averagePos = (val + pos) / (float)(num + 1);
			num++;
			return true;
		}
	}

	private const int movement_mask = 1503731969;

	private const int vehicle_mask = 8192;

	private const int grounded_mask = 1503764737;

	private const int player_mask = 131072;

	private static Collider[] buffer = (Collider[])(object)new Collider[4];

	private static Dictionary<ulong, int> kicks = new Dictionary<ulong, int>();

	private static Dictionary<ulong, int> bans = new Dictionary<ulong, int>();

	private const float LOG_GROUP_SECONDS = 60f;

	private static Queue<GroupedLog> groupedLogs = new Queue<GroupedLog>();

	private static NativeArray<float> DeltaTimes;

	private static NativeArray<bool> FindIndexWorkBuffer;

	private static NativeList<int> ValidIndexAccum1;

	private static NativeList<int> ValidIndexAccum2;

	private static NativeList<int> InvalidIndices;

	private static NativeList<Vector3> From;

	private static NativeList<Vector3> To;

	private static NativeList<Batch> Batches;

	private static NativeList<int> LayerMasks;

	private static NativeArray<float> PlayerRadii;

	private static NativeList<int> ToOverlapIndices;

	private static NativeList<Matrix4x4> Matrices;

	private static NativeList<Vector3> ToOverlapFrom;

	private static NativeList<Vector3> ToOverlapTo;

	private static NativeList<int> ToOverlapLayerMasks;

	private static NativeList<int> RaycastIndices;

	private static NativeList<RaycastCommand> RaycastRays;

	private static NativeList<SpherecastCommand> RaycastSpheres;

	private static NativeList<int> TraceIndices;

	private static NativeList<RaycastCommand> TraceRays;

	private static NativeList<SpherecastCommand> TraceSpheres;

	private static NativeArray<RaycastHit> RaycastHits;

	private static NativeArray<ColliderHit> ColliderHits;

	private static NativeArray<bool> TerrainIgnoreVolumeHits;

	private static NativeArray<int> QueryToBatchMap;

	private static BufferList<Collider> Colliders;

	public static RaycastHit isInsideRayHit;

	private static RaycastHit[] isInsideMeshRaycastHits = (RaycastHit[])(object)new RaycastHit[64];

	public static bool TestNoClipping(BasePlayer ply, Vector3 oldPos, Vector3 newPos, float radius, float backtracking, out Collider col, bool vehicleLayer = false, BaseEntity ignoreEntity = null, bool forceCast = false)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		int num = 1503731969;
		if (!vehicleLayer)
		{
			num &= -8193;
		}
		Vector3 val = newPos - oldPos;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = oldPos - normalized * backtracking;
		val = newPos - val2;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Ray val3 = default(Ray);
		((Ray)(ref val3))..ctor(val2, normalized);
		if (GamePhysics.CheckCapsule(oldPos, newPos, radius, num, (QueryTriggerInteraction)1))
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			GamePhysics.OverlapCapsule(oldPos, newPos, radius, list, num, (QueryTriggerInteraction)1);
			bool recheck = false;
			bool recheckTerrain = false;
			for (int i = 0; i < list.Count; i++)
			{
				Collider val4 = list[i];
				if (IsColliderBlocking(val4, ply, forceCast, ignoreEntity, ref recheck, ref recheckTerrain))
				{
					col = val4;
					Pool.FreeUnmanaged<Collider>(ref list);
					return true;
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
			if (recheck || recheckTerrain)
			{
				if (!recheckTerrain && (Object)(object)ignoreEntity == (Object)null)
				{
					RaycastHit val5 = default(RaycastHit);
					bool result = Physics.Raycast(val3, ref val5, magnitude + radius, num, (QueryTriggerInteraction)1) || Physics.SphereCast(val3, radius, ref val5, magnitude, num, (QueryTriggerInteraction)1);
					col = ((RaycastHit)(ref val5)).collider;
					return result;
				}
				RaycastHit hitInfo;
				bool result2 = GamePhysics.Trace(val3, 0f, out hitInfo, magnitude + radius, num, (QueryTriggerInteraction)1, ignoreEntity) || GamePhysics.Trace(val3, radius, out hitInfo, magnitude, num, (QueryTriggerInteraction)1, ignoreEntity);
				col = ((RaycastHit)(ref hitInfo)).collider;
				return result2;
			}
		}
		col = null;
		return false;
	}

	private static bool IsColliderBlocking(Collider collider, BasePlayer ply, bool forceCast, BaseEntity ignoreEntity, ref bool recheck, ref bool recheckTerrain)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (collider is TerrainCollider)
		{
			recheckTerrain = true;
			return false;
		}
		if ((LayerMask.op_Implicit(collider.excludeLayers) & 0x1000) == 4096)
		{
			return false;
		}
		BaseEntity baseEntity = collider.ToBaseEntity();
		if (((1 << ((Component)collider).gameObject.layer) & 0x2000) > 0)
		{
			if (baseEntity is HotAirBalloon && Time.time - ply.unparentTime <= 5f)
			{
				return false;
			}
			recheck = true;
			return false;
		}
		if (GamePhysics.CompareEntity(baseEntity, ignoreEntity))
		{
			return false;
		}
		if (forceCast)
		{
			recheck = true;
			return false;
		}
		if ((Object)(object)baseEntity != (Object)null && baseEntity.ShouldUseCastNoClipChecks())
		{
			recheck = true;
			return false;
		}
		if (ply.GetParentEntity() is ElevatorLift)
		{
			recheck = true;
			return false;
		}
		return true;
	}

	public static void TestAreNoClipping(ReadOnlySpan<BasePlayer> players, ReadOnly<Vector3> fromPos, ReadOnly<Vector3> toPos, ReadOnly<Batch> batches, NativeList<int> foundIndices, Span<Collider> foundColls)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0548: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0454: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_0457: Unknown result type (might be due to invalid IL or missing references)
		//IL_045c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0460: Unknown result type (might be due to invalid IL or missing references)
		//IL_0465: Unknown result type (might be due to invalid IL or missing references)
		//IL_0467: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_046c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_0478: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048a: Unknown result type (might be due to invalid IL or missing references)
		//IL_048c: Unknown result type (might be due to invalid IL or missing references)
		//IL_048e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07df: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05db: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0652: Unknown result type (might be due to invalid IL or missing references)
		//IL_0657: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_0827: Unknown result type (might be due to invalid IL or missing references)
		//IL_0828: Unknown result type (might be due to invalid IL or missing references)
		//IL_074e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0913: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_0925: Unknown result type (might be due to invalid IL or missing references)
		//IL_085b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0860: Unknown result type (might be due to invalid IL or missing references)
		//IL_0866: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0873: Unknown result type (might be due to invalid IL or missing references)
		//IL_0875: Unknown result type (might be due to invalid IL or missing references)
		//IL_088d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0680: Unknown result type (might be due to invalid IL or missing references)
		//IL_0691: Unknown result type (might be due to invalid IL or missing references)
		//IL_0692: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TestAreNoClipping", 0);
		try
		{
			float noclip_backtracking = ConVar.AntiHack.noclip_backtracking;
			float num = BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin);
			NativeListEx.Expand(ref LayerMasks, fromPos.Length, copyContents: false);
			BuildLayerMasksJob buildLayerMasksJob = default(BuildLayerMasksJob);
			buildLayerMasksJob.LayerMasks = LayerMasks;
			buildLayerMasksJob.Batches = batches;
			buildLayerMasksJob.DefaultMask = 1503731969;
			buildLayerMasksJob.NoVehiclesMask = 1503723777;
			BuildLayerMasksJob buildLayerMasksJob2 = buildLayerMasksJob;
			IJobExtensions.RunByRef<BuildLayerMasksJob>(ref buildLayerMasksJob2);
			NativeArrayEx.Expand(ref PlayerRadii, fromPos.Length, (NativeArrayOptions)0, copyContents: false);
			FillJob<float> fillJob = default(FillJob<float>);
			fillJob.Values = PlayerRadii;
			fillJob.Value = num;
			FillJob<float> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<float>>(ref fillJob2);
			NativeArrayEx.Expand(ref TerrainIgnoreVolumeHits, fromPos.Length, (NativeArrayOptions)0, copyContents: false);
			GamePhysics.CheckCapsules(fromPos, toPos, PlayerRadii.AsReadOnly(), LayerMasks.AsReadOnly(), TerrainIgnoreVolumeHits, (QueryTriggerInteraction)1, GamePhysics.MasksToValidate.Terrain);
			NativeListEx.Expand(ref ToOverlapIndices, fromPos.Length, copyContents: false);
			GatherHitIndicesJob gatherHitIndicesJob = default(GatherHitIndicesJob);
			gatherHitIndicesJob.Results = ToOverlapIndices;
			gatherHitIndicesJob.Hits = TerrainIgnoreVolumeHits.GetSubArray(0, fromPos.Length).AsReadOnly();
			GatherHitIndicesJob gatherHitIndicesJob2 = gatherHitIndicesJob;
			IJobExtensions.RunByRef<GatherHitIndicesJob>(ref gatherHitIndicesJob2);
			if (ToOverlapIndices.IsEmpty)
			{
				return;
			}
			NativeArrayEx.Expand(ref QueryToBatchMap, fromPos.Length, (NativeArrayOptions)0, copyContents: false);
			BuildBatchLookupMapJob buildBatchLookupMapJob = default(BuildBatchLookupMapJob);
			buildBatchLookupMapJob.Lookup = QueryToBatchMap;
			buildBatchLookupMapJob.Batches = batches;
			BuildBatchLookupMapJob buildBatchLookupMapJob2 = buildBatchLookupMapJob;
			IJobExtensions.RunByRef<BuildBatchLookupMapJob>(ref buildBatchLookupMapJob2);
			ToOverlapFrom.Resize(ToOverlapIndices.Length, (NativeArrayOptions)0);
			GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
			gatherJob.Results = ToOverlapFrom.AsArray();
			gatherJob.Source = fromPos;
			gatherJob.Indices = ToOverlapIndices.AsReadOnly();
			GatherJob<Vector3> gatherJob2 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
			ToOverlapTo.Resize(ToOverlapIndices.Length, (NativeArrayOptions)0);
			gatherJob = default(GatherJob<Vector3>);
			gatherJob.Results = ToOverlapTo.AsArray();
			gatherJob.Source = toPos;
			gatherJob.Indices = ToOverlapIndices.AsReadOnly();
			GatherJob<Vector3> gatherJob3 = gatherJob;
			IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob3);
			ToOverlapLayerMasks.Resize(ToOverlapIndices.Length, (NativeArrayOptions)0);
			GatherJob<int> gatherJob4 = default(GatherJob<int>);
			gatherJob4.Results = ToOverlapLayerMasks.AsArray();
			gatherJob4.Source = LayerMasks.AsReadOnly();
			gatherJob4.Indices = ToOverlapIndices.AsReadOnly();
			GatherJob<int> gatherJob5 = gatherJob4;
			IJobExtensions.RunByRef<GatherJob<int>>(ref gatherJob5);
			ColliderHits.Expand<ColliderHit>(ToOverlapLayerMasks.Length * 16, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
			GamePhysics.OverlapCapsules(ToOverlapFrom.AsReadOnly(), ToOverlapTo.AsReadOnly(), PlayerRadii.GetSubArray(0, ToOverlapLayerMasks.Length).AsReadOnly(), ToOverlapLayerMasks.AsReadOnly(), ColliderHits, 16, (QueryTriggerInteraction)1, GamePhysics.MasksToValidate.Terrain);
			NativeListEx.Expand(ref TraceIndices, ToOverlapIndices.Length, copyContents: false);
			TraceRays.Expand<RaycastCommand>(ToOverlapIndices.Length, copyContents: false);
			NativeListEx.Expand(ref RaycastIndices, ToOverlapIndices.Length, copyContents: false);
			RaycastRays.Expand<RaycastCommand>(ToOverlapIndices.Length, copyContents: false);
			TimeWarning val2 = TimeWarning.New("FilterOverlapResults", 0);
			try
			{
				bool flag = false;
				QueryParameters val9 = default(QueryParameters);
				RaycastCommand val10 = default(RaycastCommand);
				for (int i = 0; i < ToOverlapIndices.Length; i++)
				{
					int num2 = ToOverlapIndices[i];
					int num3 = QueryToBatchMap[num2];
					Batch batch = batches[num3];
					if (flag)
					{
						if (foundColls[batch.PlayerIndex] != null)
						{
							continue;
						}
						flag = false;
					}
					BasePlayer ply = players[batch.PlayerIndex];
					bool force = batch.Force;
					bool recheck = false;
					bool recheckTerrain = false;
					Collider val3 = null;
					for (int j = 0; j < 16; j++)
					{
						int num4 = i * 16 + j;
						ColliderHit val4 = ColliderHits[num4];
						if (((ColliderHit)(ref val4)).instanceID == 0)
						{
							break;
						}
						Collider collider = ((ColliderHit)(ref val4)).collider;
						if (IsColliderBlocking(collider, ply, force, null, ref recheck, ref recheckTerrain))
						{
							flag = true;
							val3 = collider;
							break;
						}
					}
					int playerIndex = batch.PlayerIndex;
					if (flag)
					{
						foundIndices.Add(ref playerIndex);
						foundColls[playerIndex] = val3;
					}
					else if (recheck || recheckTerrain)
					{
						Vector3 val5 = ToOverlapFrom[i];
						Vector3 val6 = ToOverlapTo[i];
						Vector3 val7 = val6 - val5;
						Vector3 normalized = ((Vector3)(ref val7)).normalized;
						Vector3 val8 = val5 - normalized * noclip_backtracking;
						val7 = val6 - val8;
						float magnitude = ((Vector3)(ref val7)).magnitude;
						new Ray(val8, normalized);
						int num5 = ToOverlapLayerMasks[i];
						((QueryParameters)(ref val9))..ctor(num5, false, (QueryTriggerInteraction)1, false);
						((RaycastCommand)(ref val10))..ctor(val8, normalized, val9, magnitude + num);
						if (recheckTerrain)
						{
							TraceIndices.AddNoResize(num2);
							TraceRays.AddNoResize(val10);
						}
						else
						{
							RaycastIndices.AddNoResize(num2);
							RaycastRays.AddNoResize(val10);
						}
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			if (!TraceIndices.IsEmpty)
			{
				RaycastHits.Expand<RaycastHit>(TraceIndices.Length * 16, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
				GamePhysics.TraceRays(TraceRays.AsArray(), RaycastHits, 16, traceWater: false);
				val2 = TimeWarning.New("GatherRays", 0);
				try
				{
					int num6 = 0;
					TraceSpheres.Expand<SpherecastCommand>(TraceIndices.Length, copyContents: false);
					SpherecastCommand val12 = default(SpherecastCommand);
					for (int k = 0; k < TraceIndices.Length; k++)
					{
						if (!RecordNoclip(RaycastHits[k * 16], TraceIndices[k], batches, foundIndices, foundColls))
						{
							TraceIndices[num6++] = TraceIndices[k];
							RaycastCommand val11 = TraceRays[k];
							((SpherecastCommand)(ref val12))..ctor(((RaycastCommand)(ref val11)).from, num, ((RaycastCommand)(ref val11)).direction, val11.queryParameters, ((RaycastCommand)(ref val11)).distance - num);
							TraceSpheres.Add(ref val12);
						}
					}
					TraceIndices.Resize(num6, (NativeArrayOptions)0);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				if (!TraceIndices.IsEmpty)
				{
					GamePhysics.TraceSpheres(TraceSpheres.AsArray(), RaycastHits, 16, traceWater: false);
					TimeWarning val13 = TimeWarning.New("GatherSpheres", 0);
					try
					{
						for (int l = 0; l < TraceIndices.Length; l++)
						{
							RecordNoclip(RaycastHits[l * 16], TraceIndices[l], batches, foundIndices, foundColls);
						}
					}
					finally
					{
						((IDisposable)val13)?.Dispose();
					}
				}
			}
			if (RaycastIndices.IsEmpty)
			{
				return;
			}
			if (!TraceIndices.IsEmpty)
			{
				TimeWarning val14 = TimeWarning.New("SkipDupeRaycasts", 0);
				try
				{
					int num7 = 0;
					for (int m = 0; m < RaycastIndices.Length; m++)
					{
						int num8 = RaycastIndices[m];
						int num9 = QueryToBatchMap[num8];
						if (foundColls[batches[num9].PlayerIndex] == null)
						{
							int num10 = num7++;
							RaycastIndices[num10] = num8;
							RaycastRays[num10] = RaycastRays[m];
						}
					}
					RaycastIndices.Resize(num7, (NativeArrayOptions)0);
					RaycastRays.Resize(num7, (NativeArrayOptions)0);
				}
				finally
				{
					((IDisposable)val14)?.Dispose();
				}
			}
			if (!RaycastIndices.IsEmpty)
			{
				TimeWarning val15 = TimeWarning.New("RayCasts", 0);
				try
				{
					RaycastHits.Expand<RaycastHit>(RaycastIndices.Length, (NativeArrayOptions)0, copyContents: false, usePowerOfTwo: false);
					JobHandle val16 = RaycastCommand.ScheduleBatch(RaycastRays.AsArray(), RaycastHits, 1, default(JobHandle));
					((JobHandle)(ref val16)).Complete();
					int num11 = 0;
					RaycastSpheres.Expand<SpherecastCommand>(RaycastIndices.Length, copyContents: false);
					SpherecastCommand val18 = default(SpherecastCommand);
					for (int n = 0; n < RaycastIndices.Length; n++)
					{
						if (!RecordNoclip(RaycastHits[n], RaycastIndices[n], batches, foundIndices, foundColls))
						{
							RaycastIndices[num11++] = RaycastIndices[n];
							RaycastCommand val17 = RaycastRays[n];
							((SpherecastCommand)(ref val18))..ctor(((RaycastCommand)(ref val17)).from, num, ((RaycastCommand)(ref val17)).direction, val17.queryParameters, ((RaycastCommand)(ref val17)).distance - num);
							RaycastSpheres.AddNoResize(val18);
						}
					}
					RaycastIndices.Resize(num11, (NativeArrayOptions)0);
				}
				finally
				{
					((IDisposable)val15)?.Dispose();
				}
			}
			if (RaycastIndices.IsEmpty)
			{
				return;
			}
			TimeWarning val19 = TimeWarning.New("SphereCasts", 0);
			try
			{
				JobHandle val20 = SpherecastCommand.ScheduleBatch(RaycastSpheres.AsArray(), RaycastHits, 1, default(JobHandle));
				((JobHandle)(ref val20)).Complete();
				for (int num12 = 0; num12 < RaycastIndices.Length; num12++)
				{
					RecordNoclip(RaycastHits[num12], RaycastIndices[num12], batches, foundIndices, foundColls);
				}
			}
			finally
			{
				((IDisposable)val19)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static bool RecordNoclip(RaycastHit hit, int queryIndex, ReadOnly<Batch> batches, NativeList<int> foundIndices, Span<Collider> foundColls)
		{
			bool num13 = ((RaycastHit)(ref hit)).colliderInstanceID != 0;
			if (num13)
			{
				int num14 = QueryToBatchMap[queryIndex];
				int playerIndex2 = batches[num14].PlayerIndex;
				if (foundColls[playerIndex2] == null)
				{
					foundIndices.Add(ref playerIndex2);
					foundColls[playerIndex2] = ((RaycastHit)(ref hit)).collider;
				}
			}
			return num13;
		}
	}

	public static void Cycle()
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.unscaledTime - 60f;
		if (groupedLogs.Count <= 0)
		{
			return;
		}
		GroupedLog groupedLog = groupedLogs.Peek();
		while (groupedLog.firstLogTime <= num)
		{
			GroupedLog groupedLog2 = groupedLogs.Dequeue();
			LogToConsole(groupedLog2.playerName, groupedLog2.antiHackType, $"{groupedLog2.message} (x{groupedLog2.num})", groupedLog2.averagePos);
			Pool.Free<GroupedLog>(ref groupedLog2);
			if (groupedLogs.Count != 0)
			{
				groupedLog = groupedLogs.Peek();
				continue;
			}
			break;
		}
	}

	public static void ResetTimer(BasePlayer ply)
	{
		ply.lastViolationTime = Time.realtimeSinceStartup;
		ply.lastMovementViolationTime = Time.realtimeSinceStartup;
	}

	public static bool ShouldIgnore(BasePlayer ply)
	{
		TimeWarning val = TimeWarning.New("AntiHack.ShouldIgnore", 0);
		try
		{
			if (ply.IsFlying)
			{
				ply.lastAdminCheatTime = Time.realtimeSinceStartup;
			}
			else if ((ply.IsAdmin || ply.IsDeveloper) && ply.lastAdminCheatTime == 0f)
			{
				ply.lastAdminCheatTime = Time.realtimeSinceStartup;
			}
			if (ply.IsAdmin)
			{
				if (ConVar.AntiHack.userlevel < 1)
				{
					return true;
				}
				if (ConVar.AntiHack.admincheat && ply.UsedAdminCheat())
				{
					return true;
				}
			}
			if (ply.IsDeveloper)
			{
				if (ConVar.AntiHack.userlevel < 2)
				{
					return true;
				}
				if (ConVar.AntiHack.admincheat && ply.UsedAdminCheat())
				{
					return true;
				}
			}
			if (ply.IsSpectating())
			{
				return true;
			}
			if (ply.isInvisible)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool ValidateMove(BasePlayer ply, TickInterpolator ticks, float deltaTime, in BasePlayer.CachedState initialState)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.ValidateMove", 0);
		try
		{
			if (ShouldIgnore(ply))
			{
				return true;
			}
			bool flag = deltaTime > ConVar.AntiHack.maxdeltatime;
			bool flag2 = deltaTime < ConVar.AntiHack.tick_buffer_server_lag_threshold && ConVar.AntiHack.tick_buffer_preventions && (float)ply.rawTickCount >= ConVar.AntiHack.tick_buffer_reject_threshold * (float)Player.tickrate_cl;
			if (IsNoClipping(ply, ticks, deltaTime, out var collider))
			{
				if (flag)
				{
					return false;
				}
				Analytics.Azure.OnNoclipViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count, collider);
				AddViolation(ply, AntiHackType.NoClip, ConVar.AntiHack.noclip_penalty * ticks.Length, ((Component)collider).gameObject);
				if (ConVar.AntiHack.noclip_reject)
				{
					return false;
				}
			}
			if (IsSpeeding(ply, ticks, deltaTime, in initialState))
			{
				if (flag)
				{
					return false;
				}
				Analytics.Azure.OnSpeedhackViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count);
				AddViolation(ply, AntiHackType.SpeedHack, ConVar.AntiHack.speedhack_penalty * ticks.Length);
				if (ConVar.AntiHack.speedhack_reject)
				{
					return false;
				}
			}
			if (IsFlying(ply, ticks, deltaTime, in initialState))
			{
				if (flag)
				{
					return false;
				}
				Analytics.Azure.OnFlyhackViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count);
				AddViolation(ply, AntiHackType.FlyHack, ConVar.AntiHack.flyhack_penalty * ticks.Length);
				if (ConVar.AntiHack.flyhack_reject && !(ply.lastGroundedPosition == default(Vector3)) && Vector3.Distance(ply.lastGroundedPosition, ((Component)ply).transform.position) <= 10f)
				{
					Collider col;
					bool num = TestNoClipping(ply, ((Component)ply).transform.position, ply.lastGroundedPosition, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out col);
					Vector3 val2 = ply.lastGroundedPosition + new Vector3(0f, BasePlayer.GetRadius(), 0f);
					Vector3 val3 = ply.lastGroundedPosition + new Vector3(0f, ply.GetHeight() - BasePlayer.GetRadius(), 0f);
					if (!num && !Physics.CheckCapsule(val2, val3, BasePlayer.GetRadius(), 1537286401))
					{
						ply.MovePosition(ply.lastGroundedPosition);
						ply.ClientRPC(RpcTarget.Player("ForcePositionTo", ply), ((Component)ply).transform.position);
						ply.violationLevel = 0f;
					}
				}
			}
			if (flag2)
			{
				Log(ply, AntiHackType.Ticks, $"Player had too many ticks buffered ({ply.rawTickCount})", logToAnalytics: false);
				Analytics.Azure.OnTickViolation(ply, ticks.CurrentPoint, ticks.EndPoint, ticks.Count);
				return false;
			}
			if (ConVar.AntiHack.serverside_fall_damage)
			{
				bool num2 = (Object)(object)((Component)ply).transform.parent == (Object)null;
				Matrix4x4 val4 = (num2 ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
				Vector3 oldPos = (num2 ? ticks.StartPoint : ((Matrix4x4)(ref val4)).MultiplyPoint3x4(ticks.StartPoint));
				Vector3 newPos = (num2 ? ticks.EndPoint : ((Matrix4x4)(ref val4)).MultiplyPoint3x4(ticks.EndPoint));
				TestServerSideFallDamage(ply, oldPos, newPos, deltaTime);
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void InitInternalState(int initCap)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		DisposeInternalState();
		DeltaTimes = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		FindIndexWorkBuffer = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ValidIndexAccum1 = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ValidIndexAccum2 = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		InvalidIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		From = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		To = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		Batches = new NativeList<Batch>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		LayerMasks = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		PlayerRadii = new NativeArray<float>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ToOverlapIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		Matrices = new NativeList<Matrix4x4>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ToOverlapFrom = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ToOverlapTo = new NativeList<Vector3>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		ToOverlapLayerMasks = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastRays = new NativeList<RaycastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastSpheres = new NativeList<SpherecastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		TraceIndices = new NativeList<int>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		TraceRays = new NativeList<RaycastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		TraceSpheres = new NativeList<SpherecastCommand>(initCap, AllocatorHandle.op_Implicit((Allocator)4));
		RaycastHits = new NativeArray<RaycastHit>(initCap, (Allocator)4, (NativeArrayOptions)0);
		ColliderHits = new NativeArray<ColliderHit>(initCap, (Allocator)4, (NativeArrayOptions)0);
		TerrainIgnoreVolumeHits = new NativeArray<bool>(initCap, (Allocator)4, (NativeArrayOptions)0);
		QueryToBatchMap = new NativeArray<int>(initCap, (Allocator)4, (NativeArrayOptions)0);
		Colliders = new BufferList<Collider>(initCap);
	}

	public static void DisposeInternalState()
	{
		NativeArrayEx.SafeDispose(ref DeltaTimes);
		NativeArrayEx.SafeDispose(ref FindIndexWorkBuffer);
		NativeListEx.SafeDispose(ref ValidIndexAccum1);
		NativeListEx.SafeDispose(ref ValidIndexAccum2);
		NativeListEx.SafeDispose(ref InvalidIndices);
		From.SafeDispose<Vector3>();
		To.SafeDispose<Vector3>();
		NativeListEx.SafeDispose(ref Batches);
		NativeListEx.SafeDispose(ref LayerMasks);
		NativeArrayEx.SafeDispose(ref PlayerRadii);
		NativeListEx.SafeDispose(ref ToOverlapIndices);
		Matrices.SafeDispose<Matrix4x4>();
		ToOverlapFrom.SafeDispose<Vector3>();
		ToOverlapTo.SafeDispose<Vector3>();
		NativeListEx.SafeDispose(ref ToOverlapLayerMasks);
		NativeListEx.SafeDispose(ref RaycastIndices);
		RaycastRays.SafeDispose<RaycastCommand>();
		RaycastSpheres.SafeDispose<SpherecastCommand>();
		NativeListEx.SafeDispose(ref TraceIndices);
		TraceRays.SafeDispose<RaycastCommand>();
		TraceSpheres.SafeDispose<SpherecastCommand>();
		RaycastHits.SafeDispose<RaycastHit>();
		ColliderHits.SafeDispose<ColliderHit>();
		NativeArrayEx.SafeDispose(ref TerrainIgnoreVolumeHits);
		NativeArrayEx.SafeDispose(ref QueryToBatchMap);
		Colliders = null;
	}

	internal static void ValidateMoves(ReadOnlySpan<BasePlayer> players, TickInterpolatorCache.ReadOnlyState tickCache, NativeArray<BasePlayer.CachedState> stateCache, ReadOnly<int> indices, NativeArray<BasePlayer.PositionChange> results)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0378: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_0447: Unknown result type (might be due to invalid IL or missing references)
		//IL_044c: Unknown result type (might be due to invalid IL or missing references)
		//IL_044e: Unknown result type (might be due to invalid IL or missing references)
		//IL_046c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0471: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0542: Unknown result type (might be due to invalid IL or missing references)
		//IL_0547: Unknown result type (might be due to invalid IL or missing references)
		//IL_054c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0551: Unknown result type (might be due to invalid IL or missing references)
		//IL_0554: Unknown result type (might be due to invalid IL or missing references)
		//IL_0559: Unknown result type (might be due to invalid IL or missing references)
		//IL_0568: Unknown result type (might be due to invalid IL or missing references)
		//IL_056a: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06de: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_059a: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0711: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0613: Unknown result type (might be due to invalid IL or missing references)
		//IL_0627: Unknown result type (might be due to invalid IL or missing references)
		//IL_062c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0631: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_0651: Unknown result type (might be due to invalid IL or missing references)
		//IL_0656: Unknown result type (might be due to invalid IL or missing references)
		//IL_065b: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_0678: Unknown result type (might be due to invalid IL or missing references)
		//IL_0698: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_080a: Unknown result type (might be due to invalid IL or missing references)
		//IL_080f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0811: Unknown result type (might be due to invalid IL or missing references)
		//IL_0816: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_091f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0924: Unknown result type (might be due to invalid IL or missing references)
		//IL_0843: Unknown result type (might be due to invalid IL or missing references)
		//IL_0848: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_0796: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0875: Unknown result type (might be due to invalid IL or missing references)
		//IL_087a: Unknown result type (might be due to invalid IL or missing references)
		//IL_087f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0884: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08da: Unknown result type (might be due to invalid IL or missing references)
		//IL_08dc: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.ValidateMoves", 0);
		try
		{
			NativeArrayEx.Expand(ref DeltaTimes, players.Length, (NativeArrayOptions)0, copyContents: false);
			NativeListEx.Expand(ref ValidIndexAccum1, indices.Length, copyContents: false);
			NativeListEx.Expand(ref ValidIndexAccum2, indices.Length, copyContents: false);
			ValidIndexAccum1.Clear();
			ValidIndexAccum2.Clear();
			TimeWarning val2 = TimeWarning.New("ShouldIgnore", 0);
			try
			{
				Enumerator<int> enumerator = indices.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						int current = enumerator.Current;
						BasePlayer basePlayer = players[current];
						if (ShouldIgnore(basePlayer))
						{
							results[current] = BasePlayer.PositionChange.Valid;
							continue;
						}
						ValidIndexAccum1.Add(ref current);
						DeltaTimes[current] = basePlayer.TickDeltaTime;
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeListEx.Expand(ref InvalidIndices, ValidIndexAccum1.Length, copyContents: false);
			InvalidIndices.Clear();
			if (Colliders.Capacity < players.Length)
			{
				Colliders.Resize(players.Length);
			}
			AreNoClipping(players, tickCache, DeltaTimes.AsReadOnly(), ValidIndexAccum1.AsReadOnly(), InvalidIndices, Colliders.Buffer);
			NativeArrayEx.Expand(ref FindIndexWorkBuffer, players.Length, (NativeArrayOptions)0, copyContents: false);
			FindValidIndicesJob findValidIndicesJob = default(FindValidIndicesJob);
			findValidIndicesJob.ValidIndices = ValidIndexAccum2;
			findValidIndicesJob.WorkBuffer = FindIndexWorkBuffer;
			findValidIndicesJob.InvalidIndices = InvalidIndices.AsReadOnly();
			findValidIndicesJob.AllIndices = ValidIndexAccum1.AsReadOnly();
			FindValidIndicesJob findValidIndicesJob2 = findValidIndicesJob;
			IJobExtensions.RunByRef<FindValidIndicesJob>(ref findValidIndicesJob2);
			val2 = TimeWarning.New("NoClipRejections", 0);
			Enumerator<int> enumerator2;
			try
			{
				enumerator2 = InvalidIndices.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current2 = enumerator2.Current;
						if (DeltaTimes[current2] > ConVar.AntiHack.maxdeltatime)
						{
							results[current2] = BasePlayer.PositionChange.Invalid;
							continue;
						}
						BasePlayer obj = players[current2];
						Vector3 startPoint = TickInterpolatorCache.GetStartPoint(tickCache, current2);
						Vector3 endPoint = TickInterpolatorCache.GetEndPoint(tickCache, current2);
						TickInterpolatorCache.PlayerInfo playerInfo = tickCache.Infos[current2];
						Analytics.Azure.OnNoclipViolation(obj, startPoint, endPoint, playerInfo.Count, Colliders[current2]);
						AddViolation(obj, AntiHackType.NoClip, ConVar.AntiHack.noclip_penalty * playerInfo.Length, ((Component)Colliders[current2]).gameObject);
						if (ConVar.AntiHack.noclip_reject)
						{
							results[current2] = BasePlayer.PositionChange.Invalid;
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			Array.Clear(Colliders.Buffer, 0, Colliders.Capacity);
			NativeList<int> validIndexAccum = ValidIndexAccum2;
			NativeList<int> validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			InvalidIndices.Clear();
			enumerator2 = ValidIndexAccum1.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					int current3 = enumerator2.Current;
					BasePlayer obj2 = players[current3];
					float deltaTime = DeltaTimes[current3];
					BasePlayer.CachedState initialState = stateCache[current3];
					TickInterpolator tickInterpolator = obj2.TickInterpolator;
					if (IsSpeeding(obj2, tickInterpolator, deltaTime, in initialState))
					{
						InvalidIndices.Add(ref current3);
					}
					else
					{
						ValidIndexAccum2.Add(ref current3);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			val2 = TimeWarning.New("IsSpeedingRejections", 0);
			try
			{
				enumerator2 = InvalidIndices.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current4 = enumerator2.Current;
						if (DeltaTimes[current4] > ConVar.AntiHack.maxdeltatime)
						{
							results[current4] = BasePlayer.PositionChange.Invalid;
							continue;
						}
						BasePlayer obj3 = players[current4];
						Vector3 startPoint2 = TickInterpolatorCache.GetStartPoint(tickCache, current4);
						Vector3 endPoint2 = TickInterpolatorCache.GetEndPoint(tickCache, current4);
						TickInterpolatorCache.PlayerInfo playerInfo2 = tickCache.Infos[current4];
						Analytics.Azure.OnSpeedhackViolation(obj3, startPoint2, endPoint2, playerInfo2.Count);
						AddViolation(obj3, AntiHackType.SpeedHack, ConVar.AntiHack.speedhack_penalty * playerInfo2.Length);
						if (ConVar.AntiHack.speedhack_reject)
						{
							results[current4] = BasePlayer.PositionChange.Invalid;
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeList<int> validIndexAccum3 = ValidIndexAccum2;
			validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum3;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			InvalidIndices.Clear();
			enumerator2 = ValidIndexAccum1.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					int current5 = enumerator2.Current;
					BasePlayer obj4 = players[current5];
					float deltaTime2 = DeltaTimes[current5];
					BasePlayer.CachedState initialState2 = stateCache[current5];
					TickInterpolator tickInterpolator2 = obj4.TickInterpolator;
					if (IsFlying(obj4, tickInterpolator2, deltaTime2, in initialState2))
					{
						InvalidIndices.Add(ref current5);
					}
					else
					{
						ValidIndexAccum2.Add(ref current5);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			val2 = TimeWarning.New("IsFlyingRejections", 0);
			try
			{
				enumerator2 = InvalidIndices.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current6 = enumerator2.Current;
						if (DeltaTimes[current6] > ConVar.AntiHack.maxdeltatime)
						{
							results[current6] = BasePlayer.PositionChange.Invalid;
							continue;
						}
						BasePlayer basePlayer2 = players[current6];
						Vector3 startPoint3 = TickInterpolatorCache.GetStartPoint(tickCache, current6);
						Vector3 endPoint3 = TickInterpolatorCache.GetEndPoint(tickCache, current6);
						TickInterpolatorCache.PlayerInfo playerInfo3 = tickCache.Infos[current6];
						Analytics.Azure.OnFlyhackViolation(basePlayer2, startPoint3, endPoint3, playerInfo3.Count);
						AddViolation(basePlayer2, AntiHackType.FlyHack, ConVar.AntiHack.flyhack_penalty * playerInfo3.Length);
						if (!ConVar.AntiHack.flyhack_reject)
						{
							continue;
						}
						if (basePlayer2.lastGroundedPosition == default(Vector3))
						{
							ValidIndexAccum2.Add(ref current6);
						}
						else if (Vector3.Distance(basePlayer2.lastGroundedPosition, ((Component)basePlayer2).transform.position) <= 10f)
						{
							Collider col;
							bool num = TestNoClipping(basePlayer2, ((Component)basePlayer2).transform.position, basePlayer2.lastGroundedPosition, BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin), ConVar.AntiHack.noclip_backtracking, out col);
							Vector3 val3 = basePlayer2.lastGroundedPosition + new Vector3(0f, BasePlayer.GetRadius(), 0f);
							Vector3 val4 = basePlayer2.lastGroundedPosition + new Vector3(0f, basePlayer2.GetHeight() - BasePlayer.GetRadius(), 0f);
							if (!num && !Physics.CheckCapsule(val3, val4, BasePlayer.GetRadius(), 1537286401))
							{
								basePlayer2.MovePosition(basePlayer2.lastGroundedPosition);
								basePlayer2.ClientRPC(RpcTarget.Player("ForcePositionTo", basePlayer2), ((Component)basePlayer2).transform.position);
								basePlayer2.violationLevel = 0f;
							}
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeList<int> validIndexAccum4 = ValidIndexAccum2;
			validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum4;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			InvalidIndices.Clear();
			val2 = TimeWarning.New("TickOverflowValidation", 0);
			try
			{
				enumerator2 = ValidIndexAccum1.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current7 = enumerator2.Current;
						BasePlayer basePlayer3 = players[current7];
						if (DeltaTimes[current7] < ConVar.AntiHack.tick_buffer_server_lag_threshold && ConVar.AntiHack.tick_buffer_preventions && (float)basePlayer3.rawTickCount >= ConVar.AntiHack.tick_buffer_reject_threshold * (float)Player.tickrate_cl)
						{
							Log(basePlayer3, AntiHackType.Ticks, $"Player had too many ticks buffered ({basePlayer3.rawTickCount})", logToAnalytics: false);
							Vector3 startPoint4 = TickInterpolatorCache.GetStartPoint(tickCache, current7);
							Vector3 endPoint4 = TickInterpolatorCache.GetEndPoint(tickCache, current7);
							Analytics.Azure.OnTickViolation(basePlayer3, startPoint4, endPoint4, tickCache.Infos[current7].Count);
							results[current7] = BasePlayer.PositionChange.Invalid;
						}
						else
						{
							ValidIndexAccum2.Add(ref current7);
						}
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NativeList<int> validIndexAccum5 = ValidIndexAccum2;
			validIndexAccum2 = ValidIndexAccum1;
			ValidIndexAccum1 = validIndexAccum5;
			ValidIndexAccum2 = validIndexAccum2;
			ValidIndexAccum2.Clear();
			if (ConVar.AntiHack.serverside_fall_damage)
			{
				TimeWarning val5 = TimeWarning.New("ServerSideFallDamageScope", 0);
				try
				{
					enumerator2 = ValidIndexAccum1.GetEnumerator();
					try
					{
						while (enumerator2.MoveNext())
						{
							int current8 = enumerator2.Current;
							BasePlayer basePlayer4 = players[current8];
							float deltaTime3 = DeltaTimes[current8];
							Vector3 startPoint5 = TickInterpolatorCache.GetStartPoint(tickCache, current8);
							Vector3 endPoint5 = TickInterpolatorCache.GetEndPoint(tickCache, current8);
							bool num2 = (Object)(object)((Component)basePlayer4).transform.parent == (Object)null;
							Matrix4x4 val6 = (num2 ? Matrix4x4.identity : ((Component)basePlayer4).transform.parent.localToWorldMatrix);
							Vector3 oldPos = (num2 ? startPoint5 : ((Matrix4x4)(ref val6)).MultiplyPoint3x4(startPoint5));
							Vector3 newPos = (num2 ? endPoint5 : ((Matrix4x4)(ref val6)).MultiplyPoint3x4(endPoint5));
							TestServerSideFallDamage(basePlayer4, oldPos, newPos, deltaTime3);
						}
					}
					finally
					{
						((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			val2 = TimeWarning.New("MarkPositionsValid", 0);
			try
			{
				enumerator2 = ValidIndexAccum1.GetEnumerator();
				try
				{
					while (enumerator2.MoveNext())
					{
						int current9 = enumerator2.Current;
						results[current9] = BasePlayer.PositionChange.Valid;
					}
				}
				finally
				{
					((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void ValidateAgainstTerrain(PlayerCache playerCache)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("ValidateAgainstTerrain", 0);
		try
		{
			int num = Time.frameCount % ConVar.AntiHack.terrain_timeslice;
			ValidEnumerator<BasePlayer> enumerator = playerCache.ValidPlayers.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					int num2 = (int)(current.net.ID.Value % (ulong)ConVar.AntiHack.terrain_timeslice);
					if (num == num2 && !ShouldIgnore(current))
					{
						bool flag = false;
						if (IsInsideTerrain(current))
						{
							flag = true;
							AddViolation(current, AntiHackType.InsideTerrain, ConVar.AntiHack.terrain_penalty);
						}
						else if (ConVar.AntiHack.terrain_check_geometry && IsInsideMesh(current.eyes.position))
						{
							flag = true;
							AddViolation(current, AntiHackType.InsideGeometry, ConVar.AntiHack.terrain_penalty);
							Log(current, AntiHackType.InsideGeometry, "Seems to be clipped inside " + ((Object)((RaycastHit)(ref isInsideRayHit)).collider).name);
						}
						if (flag && ConVar.AntiHack.terrain_kill)
						{
							Analytics.Azure.OnTerrainHackViolation(current);
							current.Hurt(1000f, DamageType.Suicide, current, useProtection: false);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void ValidateEyeHistory(BasePlayer ply)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.ValidateEyeHistory", 0);
		try
		{
			for (int i = 0; i < ply.eyeHistory.Count; i++)
			{
				Vector3 val2 = ply.eyeHistory[i];
				if (ply.tickHistory.Distance(ply, val2) > ConVar.AntiHack.eye_history_forgiveness)
				{
					AddViolation(ply, AntiHackType.EyeHack, ConVar.AntiHack.eye_history_penalty);
					Analytics.Azure.OnEyehackViolation(ply, val2);
				}
			}
			ply.eyeHistory.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsInsideTerrain(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return TestInsideTerrain(((Component)ply).transform.position);
	}

	public static bool TestInsideTerrain(Vector3 pos)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.TestInsideTerrain", 0);
		try
		{
			if (!Object.op_Implicit((Object)(object)TerrainMeta.Terrain))
			{
				return false;
			}
			if (!Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				return false;
			}
			if (!Object.op_Implicit((Object)(object)TerrainMeta.Collision))
			{
				return false;
			}
			float terrain_padding = ConVar.AntiHack.terrain_padding;
			float height = TerrainMeta.HeightMap.GetHeight(pos);
			if (pos.y > height - terrain_padding)
			{
				return false;
			}
			float num = TerrainMeta.Position.y + TerrainMeta.Terrain.SampleHeight(pos);
			if (pos.y > num - terrain_padding)
			{
				return false;
			}
			if (TerrainMeta.Collision.GetIgnore(pos))
			{
				return false;
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsInsideMesh(Vector3 pos)
	{
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.AntiHack.mesh_inside_check_distance <= 0f)
		{
			return false;
		}
		bool queriesHitBackfaces = Physics.queriesHitBackfaces;
		if (ConVar.AntiHack.use_legacy_mesh_inside_check)
		{
			Physics.queriesHitBackfaces = true;
			if (Physics.Raycast(pos, Vector3.up, ref isInsideRayHit, ConVar.AntiHack.mesh_inside_check_distance, 65536))
			{
				Physics.queriesHitBackfaces = queriesHitBackfaces;
				return Vector3.Dot(Vector3.up, ((RaycastHit)(ref isInsideRayHit)).normal) > 0f;
			}
			Physics.queriesHitBackfaces = queriesHitBackfaces;
			return false;
		}
		Physics.queriesHitBackfaces = true;
		int num = Physics.RaycastNonAlloc(pos, Vector3.up, isInsideMeshRaycastHits, ConVar.AntiHack.mesh_inside_check_distance, 65536);
		Physics.queriesHitBackfaces = queriesHitBackfaces;
		SortHitsByDistance(isInsideMeshRaycastHits, num);
		Collider val = null;
		ColliderInfo colliderInfo = default(ColliderInfo);
		for (int i = 0; i < num; i++)
		{
			RaycastHit val2 = isInsideMeshRaycastHits[i];
			if (((Component)((RaycastHit)(ref val2)).collider).TryGetComponent<ColliderInfo>(ref colliderInfo) && colliderInfo.HasFlag(ColliderInfo.Flags.AllowBuildInsideMesh))
			{
				continue;
			}
			if (Vector3.Dot(Vector3.up, ((RaycastHit)(ref val2)).normal) > 0f)
			{
				if ((Object)(object)val != (Object)(object)((RaycastHit)(ref val2)).collider)
				{
					isInsideRayHit = val2;
					return true;
				}
			}
			else
			{
				val = ((RaycastHit)(ref val2)).collider;
			}
		}
		return false;
	}

	private static void SortHitsByDistance(RaycastHit[] hits, int maxLength)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < maxLength - 1; i++)
		{
			int num = i;
			for (int j = i + 1; j < maxLength; j++)
			{
				if (((RaycastHit)(ref hits[j])).distance < ((RaycastHit)(ref hits[num])).distance)
				{
					num = j;
				}
			}
			if (num != i)
			{
				RaycastHit val = hits[i];
				hits[i] = hits[num];
				hits[num] = val;
			}
		}
	}

	public static bool IsNoClipping(BasePlayer ply, TickInterpolator ticks, float deltaTime, out Collider collider)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		collider = null;
		TimeWarning val = TimeWarning.New("AntiHack.IsNoClipping", 0);
		try
		{
			ply.vehiclePauseTime = Mathf.Max(0f, ply.vehiclePauseTime - deltaTime);
			ply.forceCastTime = Mathf.Max(0f, ply.forceCastTime - deltaTime);
			if (ConVar.AntiHack.noclip_protection <= 0)
			{
				return false;
			}
			ticks.Reset();
			if (!ticks.HasNext())
			{
				return false;
			}
			bool flag = (Object)(object)((Component)ply).transform.parent == (Object)null;
			Matrix4x4 val2 = (flag ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
			Vector3 val3 = (flag ? ticks.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.StartPoint));
			Vector3 val4 = (flag ? ticks.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.EndPoint));
			Vector3 val5 = BasePlayer.NoClipOffset();
			float radius = BasePlayer.NoClipRadius(ConVar.AntiHack.noclip_margin);
			float noclip_backtracking = ConVar.AntiHack.noclip_backtracking;
			bool vehicleLayer = ply.vehiclePauseTime <= 0f && !ply.isMounted;
			bool forceCast = ply.forceCastTime > 0f;
			int num = ConVar.AntiHack.noclip_protection;
			if (deltaTime < ConVar.AntiHack.tick_buffer_server_lag_threshold && ConVar.AntiHack.tick_buffer_preventions && (float)ply.rawTickCount >= ConVar.AntiHack.tick_buffer_noclip_threshold * (float)Player.tickrate_cl)
			{
				num = Mathf.Min(2, ConVar.AntiHack.noclip_protection);
			}
			if (num >= 3)
			{
				float num2 = Mathf.Max(ConVar.AntiHack.noclip_stepsize, 0.1f);
				int num3 = Mathf.Max(ConVar.AntiHack.noclip_maxsteps, 1);
				num2 = Mathf.Max(ticks.Length / (float)num3, num2);
				while (ticks.MoveNext(num2))
				{
					val4 = (flag ? ticks.CurrentPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.CurrentPoint));
					if (TestNoClipping(ply, val3 + val5, val4 + val5, radius, noclip_backtracking, out collider, vehicleLayer, null, forceCast))
					{
						return true;
					}
					val3 = val4;
				}
			}
			else if (TestNoClipping(ply, val3 + val5, val4 + val5, radius, noclip_backtracking, out collider, vehicleLayer, null, forceCast))
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void AreNoClipping(ReadOnlySpan<BasePlayer> players, TickInterpolatorCache.ReadOnlyState tickCache, ReadOnly<float> deltaTimes, ReadOnly<int> indices, NativeList<int> foundIndices, Span<Collider> colliders)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.AreNoClipping", 0);
		try
		{
			Enumerator<int> enumerator = indices.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					int current = enumerator.Current;
					BasePlayer basePlayer = players[current];
					float num = deltaTimes[current];
					basePlayer.vehiclePauseTime = Mathf.Max(0f, basePlayer.vehiclePauseTime - num);
					basePlayer.forceCastTime = Mathf.Max(0f, basePlayer.forceCastTime - num);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			if (ConVar.AntiHack.noclip_protection <= 0)
			{
				return;
			}
			int num2 = Mathf.Max(ConVar.AntiHack.noclip_maxsteps, 1);
			TimeWarning val2 = TimeWarning.New("GatherBatches", 0);
			try
			{
				NativeListEx.Expand(ref ToOverlapIndices, indices.Length, copyContents: false);
				GatherPlayersWithTicksJob gatherPlayersWithTicksJob = default(GatherPlayersWithTicksJob);
				gatherPlayersWithTicksJob.ValidIndices = ToOverlapIndices;
				gatherPlayersWithTicksJob.TickCache = tickCache;
				gatherPlayersWithTicksJob.Indices = indices;
				GatherPlayersWithTicksJob gatherPlayersWithTicksJob2 = gatherPlayersWithTicksJob;
				IJobExtensions.RunByRef<GatherPlayersWithTicksJob>(ref gatherPlayersWithTicksJob2);
				TimeWarning val3 = TimeWarning.New("GatherPlayerInfo", 0);
				try
				{
					NativeListEx.Expand(ref Batches, ToOverlapIndices.Length, copyContents: false);
					Matrices.Expand<Matrix4x4>(ToOverlapIndices.Length, copyContents: false);
					Enumerator<int> enumerator2 = ToOverlapIndices.GetEnumerator();
					try
					{
						while (enumerator2.MoveNext())
						{
							int current2 = enumerator2.Current;
							BasePlayer basePlayer2 = players[current2];
							Transform parent = ((Component)basePlayer2).transform.parent;
							Matrix4x4 val4 = (((Object)(object)parent == (Object)null) ? Matrix4x4.zero : parent.localToWorldMatrix);
							Matrices.AddNoResize(val4);
							bool excludeVehicleLayer = basePlayer2.vehiclePauseTime <= 0f && !basePlayer2.isMounted;
							bool force = basePlayer2.forceCastTime > 0f;
							Batches.AddNoResize(new Batch
							{
								PlayerIndex = current2,
								Count = (int)basePlayer2.rawTickCount,
								Force = force,
								ExcludeVehicleLayer = excludeVehicleLayer
							});
						}
					}
					finally
					{
						((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				From.Expand<Vector3>(ToOverlapIndices.Length * num2, copyContents: false);
				To.Expand<Vector3>(ToOverlapIndices.Length * num2, copyContents: false);
				GatherNoClipBatchesJob gatherNoClipBatchesJob = default(GatherNoClipBatchesJob);
				gatherNoClipBatchesJob.From = From;
				gatherNoClipBatchesJob.To = To;
				gatherNoClipBatchesJob.Batches = Batches.AsArray();
				gatherNoClipBatchesJob.TickCache = tickCache;
				gatherNoClipBatchesJob.Indices = ToOverlapIndices.AsReadOnly();
				gatherNoClipBatchesJob.Matrices = Matrices.AsReadOnly();
				gatherNoClipBatchesJob.DeltaTimes = deltaTimes;
				gatherNoClipBatchesJob.MaxSteps = num2;
				gatherNoClipBatchesJob.DefaultStepSize = Mathf.Max(ConVar.AntiHack.noclip_stepsize, 0.1f);
				gatherNoClipBatchesJob.DefaultProtection = ConVar.AntiHack.noclip_protection;
				gatherNoClipBatchesJob.MaxTickCount = ConVar.AntiHack.tick_buffer_noclip_threshold * (float)Player.tickrate_cl;
				gatherNoClipBatchesJob.LagThreshold = ConVar.AntiHack.tick_buffer_server_lag_threshold;
				gatherNoClipBatchesJob.TickBufferPrevention = ConVar.AntiHack.tick_buffer_preventions;
				GatherNoClipBatchesJob gatherNoClipBatchesJob2 = gatherNoClipBatchesJob;
				IJobExtensions.RunByRef<GatherNoClipBatchesJob>(ref gatherNoClipBatchesJob2);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			foundIndices.Clear();
			if (!Batches.IsEmpty)
			{
				TestAreNoClipping(players, From.AsReadOnly(), To.AsReadOnly(), Batches.AsReadOnly(), foundIndices, colliders);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool IsSpeeding(BasePlayer ply, TickInterpolator ticks, float deltaTime, in BasePlayer.CachedState initialState)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.IsSpeeding", 0);
		try
		{
			ply.speedhackPauseTime = Mathf.Max(0f, ply.speedhackPauseTime - deltaTime);
			ply.speedhackExtraSpeedTime = Mathf.Max(0f, ply.speedhackExtraSpeedTime - deltaTime);
			if (ConVar.AntiHack.speedhack_protection <= 0)
			{
				return false;
			}
			bool num = (Object)(object)((Component)ply).transform.parent == (Object)null;
			Matrix4x4 val2 = (num ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
			Vector3 val3 = (num ? ticks.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.StartPoint));
			Vector3 val4 = (num ? ticks.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.EndPoint));
			float running = 1f;
			float ducking = 0f;
			float crawling = 0f;
			bool flag = false;
			if (ConVar.AntiHack.speedhack_protection >= 2)
			{
				bool flag2 = ply.IsRunning();
				bool flag3 = ply.IsDucked();
				flag = initialState.IsSwimming;
				bool num2 = ply.IsCrawling();
				running = (flag2 ? 1f : 0f);
				ducking = ((flag3 || flag) ? 1f : 0f);
				crawling = (num2 ? 1f : 0f);
			}
			float speed = ply.GetSpeed(running, ducking, crawling, initialState.IsSwimming);
			Vector3 val5 = val4 - val3;
			float num3 = ((flag && ConVar.AntiHack.speedhack_protection >= 3) ? ((Vector3)(ref val5)).magnitude : Vector3Ex.Magnitude2D(val5));
			float num4 = deltaTime * speed;
			if (!flag && num3 > num4)
			{
				Vector3 val6 = (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap) ? TerrainMeta.HeightMap.GetNormal(val3) : Vector3.up);
				float num5 = Mathf.Max(0f, Vector3.Dot(Vector3Ex.XZ3D(val6), Vector3Ex.XZ3D(val5))) * ConVar.AntiHack.speedhack_slopespeed * deltaTime;
				num3 = Mathf.Max(0f, num3 - num5);
			}
			float num6 = Mathf.Max((ply.speedhackPauseTime > 0f) ? ConVar.AntiHack.speedhack_forgiveness_inertia : ConVar.AntiHack.speedhack_forgiveness, 0.1f);
			float num7 = num6 + Mathf.Max(ConVar.AntiHack.speedhack_forgiveness, 0.1f);
			ply.speedhackDistance = Mathf.Clamp(ply.speedhackDistance, 0f - num7, num7);
			float num8 = ((ply.speedhackExtraSpeedTime > 0f) ? (ply.speedhackExtraSpeed * deltaTime) : 0f);
			ply.speedhackDistance = Mathf.Clamp(ply.speedhackDistance - num4 - num8, 0f - num7, num7);
			if (ply.speedhackDistance > num6)
			{
				return true;
			}
			ply.speedhackDistance = Mathf.Clamp(ply.speedhackDistance + num3, 0f - num7, num7);
			if (ply.speedhackDistance > num6)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool IsFlying(BasePlayer ply, TickInterpolator ticks, float deltaTime, in BasePlayer.CachedState initialState)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AntiHack.IsFlying", 0);
		try
		{
			ply.flyhackPauseTime = Mathf.Max(0f, ply.flyhackPauseTime - deltaTime);
			if (ConVar.AntiHack.flyhack_protection <= 0)
			{
				return false;
			}
			ticks.Reset();
			if (!ticks.HasNext())
			{
				return false;
			}
			bool flag = (Object)(object)((Component)ply).transform.parent == (Object)null;
			Matrix4x4 val2 = (flag ? Matrix4x4.identity : ((Component)ply).transform.parent.localToWorldMatrix);
			Vector3 oldPos = (flag ? ticks.StartPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.StartPoint));
			Vector3 newPos = (flag ? ticks.EndPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.EndPoint));
			BasePlayer.CachedState? playerState = null;
			if (ConVar.AntiHack.flyhack_usecachedstate)
			{
				playerState = initialState;
			}
			if (ConVar.AntiHack.flyhack_protection >= 3)
			{
				float num = Mathf.Max(ConVar.AntiHack.flyhack_stepsize, 0.1f);
				int num2 = Mathf.Max(ConVar.AntiHack.flyhack_maxsteps, 1);
				num = Mathf.Max(ticks.Length / (float)num2, num);
				while (ticks.MoveNext(num))
				{
					newPos = (flag ? ticks.CurrentPoint : ((Matrix4x4)(ref val2)).MultiplyPoint3x4(ticks.CurrentPoint));
					if (TestFlying(ply, oldPos, newPos, verifyGrounded: true, in playerState))
					{
						return true;
					}
					playerState = null;
					oldPos = newPos;
				}
			}
			else if (ConVar.AntiHack.flyhack_protection >= 2)
			{
				if (TestFlying(ply, oldPos, newPos, verifyGrounded: true, in playerState))
				{
					return true;
				}
			}
			else if (TestFlying(ply, oldPos, newPos, verifyGrounded: false, in playerState))
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static bool TestFlying(BasePlayer ply, Vector3 oldPos, Vector3 newPos, bool verifyGrounded, in BasePlayer.CachedState? playerState)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		bool isInAir = ply.isInAir;
		if (!ply.isInAir)
		{
			ply.lastGroundedPosition = oldPos;
		}
		ply.isInAir = false;
		ply.isOnPlayer = false;
		if (verifyGrounded)
		{
			float flyhack_extrusion = ConVar.AntiHack.flyhack_extrusion;
			Vector3 val = (oldPos + newPos) * 0.5f;
			if (!ply.OnLadder())
			{
				bool num;
				if (!playerState.HasValue)
				{
					num = WaterLevel.Test(val - new Vector3(0f, flyhack_extrusion, 0f), waves: true, volumes: true, ply);
				}
				else
				{
					BasePlayer.CachedState value = playerState.Value;
					num = IsInWaterCached(in value.WaterInfo, oldPos - new Vector3(0f, flyhack_extrusion, 0f), ply);
				}
				if (num)
				{
					if (ply.waterDelay <= 0f)
					{
						ply.waterDelay = 0.3f;
					}
				}
				else if ((EnvironmentManager.Get(val) & EnvironmentType.Elevator) == 0)
				{
					float flyhack_margin = ConVar.AntiHack.flyhack_margin;
					float radius = BasePlayer.GetRadius();
					float height = BasePlayer.GetHeight(ducked: false);
					Vector3 val2 = val + new Vector3(0f, radius - flyhack_extrusion, 0f);
					Vector3 val3 = val + new Vector3(0f, height - radius, 0f);
					float num2 = radius - flyhack_margin;
					ply.isInAir = !Physics.CheckCapsule(val2, val3, num2, 1503764737, (QueryTriggerInteraction)1);
					if (ply.isInAir)
					{
						int num3 = Physics.OverlapCapsuleNonAlloc(val2, val3, num2, buffer, 131072, (QueryTriggerInteraction)1);
						for (int i = 0; i < num3; i++)
						{
							BasePlayer basePlayer = ((Component)buffer[i]).gameObject.ToBaseEntity() as BasePlayer;
							if (!((Object)(object)basePlayer == (Object)null) && !((Object)(object)basePlayer == (Object)(object)ply) && !basePlayer.isInAir && !basePlayer.isOnPlayer && !basePlayer.TriggeredAntiHack() && !basePlayer.IsSleeping())
							{
								ply.isOnPlayer = true;
								ply.isInAir = false;
								break;
							}
						}
						for (int j = 0; j < buffer.Length; j++)
						{
							buffer[j] = null;
						}
					}
				}
			}
		}
		else
		{
			ply.isInAir = !ply.OnLadder() && !ply.IsSwimming() && !ply.IsOnGround();
		}
		if (ply.isInAir)
		{
			bool flag = false;
			Vector3 val4 = newPos - oldPos;
			float num4 = Mathf.Abs(val4.y);
			float num5 = Vector3Ex.Magnitude2D(val4);
			if (val4.y >= 0f)
			{
				ply.flyhackDistanceVertical += val4.y;
				flag = true;
			}
			if (num4 < num5)
			{
				ply.flyhackDistanceHorizontal += num5;
				flag = true;
			}
			if (flag)
			{
				float num6 = Mathf.Max((ply.flyhackPauseTime > 0f) ? ConVar.AntiHack.flyhack_forgiveness_vertical_inertia : ConVar.AntiHack.flyhack_forgiveness_vertical, 0f);
				float num7 = BasePlayer.GetJumpHeight() + num6;
				if (ply.flyhackDistanceVertical > num7)
				{
					return true;
				}
				float num8 = Mathf.Max((ply.flyhackPauseTime > 0f) ? ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia : ConVar.AntiHack.flyhack_forgiveness_horizontal, 0f);
				float num9 = 5f + num8;
				if (ply.flyhackDistanceHorizontal > num9)
				{
					return true;
				}
			}
		}
		else
		{
			if (isInAir)
			{
				ply.lastInAirTime = Time.realtimeSinceStartup;
			}
			ply.flyhackDistanceVertical = 0f;
			ply.flyhackDistanceHorizontal = 0f;
		}
		return false;
		static bool IsInWaterCached(in WaterLevel.WaterInfo cachedInfo, Vector3 adjustedPos, BasePlayer player)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			if (!cachedInfo.isValid)
			{
				return WaterLevel.Test(in cachedInfo, volumes: true, adjustedPos, player);
			}
			return true;
		}
	}

	public static bool TestServerSideFallDamage(BasePlayer ply, Vector3 oldPos, Vector3 newPos, float deltaTime)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		if (ply.waterDelay >= 0f)
		{
			ply.waterDelay -= deltaTime;
		}
		if (ply.isInAir)
		{
			Vector3 val = newPos - oldPos;
			if (val.y < 0f)
			{
				if (ply.timeInAir == 0f)
				{
					ply.initialVelocity = ply.estimatedVelocity;
					ply.fallingDistance = ply.GetHeight();
					ply.timeInAir = 1f;
				}
				ply.timeInAir += deltaTime;
				ply.fallingDistance += val.y;
				if (ply.estimatedVelocity.y < ply.fallingVelocity)
				{
					ply.fallingVelocity = ply.estimatedVelocity.y;
				}
				ply.fallingVelocity = ply.estimatedVelocity.y;
			}
		}
		else if (ply.waterDelay <= 0f)
		{
			if (ply.OnLadder() || ply.IsSwimming())
			{
				ResetServerFall(ply);
				return false;
			}
			float num = 0f - Mathf.Sqrt(Mathf.Abs(0f - ((Vector3)(ref ply.initialVelocity)).magnitude * ((Vector3)(ref ply.initialVelocity)).magnitude + 2f * Physics.gravity.y * ply.fallingDistance) * 1.4f);
			if (ply.fallingVelocity < 0f || (num < 0f && ply.timeInAir > 0f))
			{
				float num2 = Mathf.Max(Mathf.Abs(num), Mathf.Abs(ply.fallingVelocity));
				ply.ApplyFallDamageFromVelocity(0f - num2);
				ResetServerFall(ply);
			}
		}
		return false;
	}

	public static void ResetServerFall(BasePlayer ply)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		ply.fallingVelocity = 0f;
		ply.fallingDistance = 0f;
		ply.timeInAir = 0f;
		ply.initialVelocity = default(Vector3);
	}

	public static bool TestIsBuildingInsideSomething(Construction.Target target, Vector3 deployPos)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.AntiHack.build_inside_check <= 0)
		{
			return false;
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.IsInBounds(deployPos))
			{
				return false;
			}
		}
		if (IsInsideMesh(deployPos) && IsInsideMesh(((Ray)(ref target.ray)).origin))
		{
			LogToConsoleBatched(target.player, AntiHackType.InsideGeometry, "Tried to build while clipped inside " + ((Object)((RaycastHit)(ref isInsideRayHit)).collider).name, 25f);
			if (ConVar.AntiHack.build_inside_check > 1)
			{
				return true;
			}
		}
		return false;
	}

	public static void FadeViolations(BasePlayer ply, float deltaTime)
	{
		if (Time.realtimeSinceStartup - ply.lastViolationTime > ConVar.AntiHack.relaxationpause)
		{
			ply.violationLevel = Mathf.Max(0f, ply.violationLevel - ConVar.AntiHack.relaxationrate * deltaTime);
		}
	}

	public static void EnforceViolations(BasePlayer ply)
	{
		if (ConVar.AntiHack.enforcementlevel > 0 && ply.violationLevel > ConVar.AntiHack.maxviolation)
		{
			if (ConVar.AntiHack.debuglevel >= 1)
			{
				LogToConsole(ply, ply.lastViolationType, "Enforcing (violation of " + ply.violationLevel + ")");
			}
			string reason = ply.lastViolationType.ToString() + " Violation Level " + ply.violationLevel;
			if (ConVar.AntiHack.enforcementlevel > 1)
			{
				Kick(ply, reason);
			}
			else
			{
				Kick(ply, reason);
			}
		}
	}

	public static void Log(BasePlayer ply, AntiHackType type, string message, bool logToAnalytics = true)
	{
		if (ConVar.AntiHack.debuglevel > 1)
		{
			LogToConsole(ply, type, message);
		}
		if (logToAnalytics)
		{
			Analytics.Azure.OnAntihackViolation(ply, type, message);
		}
		LogToEAC(ply, type, message);
	}

	public static void LogToConsoleBatched(BasePlayer ply, AntiHackType type, string message, float maxDistance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		string playerName = ((object)ply).ToString();
		Vector3 position = ((Component)ply).transform.position;
		foreach (GroupedLog groupedLog2 in groupedLogs)
		{
			if (groupedLog2.TryGroup(playerName, type, message, position, maxDistance))
			{
				return;
			}
		}
		GroupedLog groupedLog = Pool.Get<GroupedLog>();
		groupedLog.SetInitial(playerName, type, message, position);
		groupedLogs.Enqueue(groupedLog);
	}

	private static void LogToConsole(BasePlayer ply, AntiHackType type, string message)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[7]
		{
			((object)ply)?.ToString(),
			" ",
			type.ToString(),
			": ",
			message,
			" at ",
			null
		};
		Vector3 position = ((Component)ply).transform.position;
		obj[6] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
		Debug.LogWarning((object)string.Concat(obj));
	}

	private static void LogToConsole(string plyName, AntiHackType type, string message, Vector3 pos)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		string[] obj = new string[7]
		{
			plyName,
			" ",
			type.ToString(),
			": ",
			message,
			" at ",
			null
		};
		Vector3 val = pos;
		obj[6] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
		Debug.LogWarning((object)string.Concat(obj));
	}

	private static void LogToEAC(BasePlayer ply, AntiHackType type, string message)
	{
		if (ConVar.AntiHack.reporting)
		{
			EACServer.SendPlayerBehaviorReport((PlayerReportsCategory)2, ply.UserIDString, type.ToString() + ": " + message);
		}
	}

	public static void AddViolation(BasePlayer ply, AntiHackType type, float amount, GameObject gameObject = null)
	{
		if (Interface.CallHook("OnPlayerViolation", (object)ply, (object)type, (object)amount, (object)gameObject) != null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("AntiHack.AddViolation", 0);
		try
		{
			ply.lastViolationType = type;
			ply.lastViolationTime = Time.realtimeSinceStartup;
			ply.violationLevel += amount;
			if (type == AntiHackType.NoClip || type == AntiHackType.FlyHack || type == AntiHackType.SpeedHack || type == AntiHackType.InsideGeometry || type == AntiHackType.InsideTerrain || type == AntiHackType.Ticks)
			{
				ply.lastMovementViolationTime = Time.realtimeSinceStartup;
			}
			if ((ConVar.AntiHack.debuglevel >= 2 && amount > 0f) || (ConVar.AntiHack.debuglevel >= 3 && type != AntiHackType.NoClip) || ConVar.AntiHack.debuglevel >= 4)
			{
				string text = "Added violation of " + amount + " in frame " + Time.frameCount + " (now has " + ply.violationLevel + ")";
				if ((Object)(object)gameObject != (Object)null)
				{
					text = text + " " + ((Object)gameObject).name;
					BaseEntity baseEntity = gameObject.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null)
					{
						text = text + " (entity: " + baseEntity.ShortPrefabName + ")";
					}
				}
				LogToConsole(ply, type, text);
			}
			EnforceViolations(ply);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void Kick(BasePlayer ply, string reason)
	{
		AddRecord(ply, kicks);
		ply.Kick(reason);
	}

	public static void Ban(BasePlayer ply, string reason)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		AddRecord(ply, bans);
		ConsoleSystem.Run(Option.Server, "ban", new object[2]
		{
			ply.userID.Get(),
			reason
		});
	}

	private static void AddRecord(BasePlayer ply, Dictionary<ulong, int> records)
	{
		if (records.ContainsKey(ply.userID))
		{
			records[ply.userID]++;
		}
		else
		{
			records.Add(ply.userID, 1);
		}
	}

	public static int GetKickRecord(BasePlayer ply)
	{
		return GetRecord(ply, kicks);
	}

	public static int GetBanRecord(BasePlayer ply)
	{
		return GetRecord(ply, bans);
	}

	private static int GetRecord(BasePlayer ply, Dictionary<ulong, int> records)
	{
		if (!records.ContainsKey(ply.userID))
		{
			return 0;
		}
		return records[ply.userID];
	}
}


public struct Batch
{
	public int PlayerIndex;

	public int Count;

	public bool Force;

	public bool ExcludeVehicleLayer;
}


using Facepunch;
using UnityEngine;

private class GroupedLog : IPooled
{
	public float firstLogTime;

	public string playerName;

	public AntiHackType antiHackType;

	public string message;

	public Vector3 averagePos;

	public int num;

	public GroupedLog()
	{
	}

	public GroupedLog(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		SetInitial(playerName, antiHackType, message, pos);
	}

	public void EnterPool()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		firstLogTime = 0f;
		playerName = string.Empty;
		antiHackType = AntiHackType.None;
		averagePos = Vector3.zero;
		num = 0;
	}

	public void LeavePool()
	{
	}

	public void SetInitial(string playerName, AntiHackType antiHackType, string message, Vector3 pos)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		firstLogTime = Time.unscaledTime;
		this.playerName = playerName;
		this.antiHackType = antiHackType;
		this.message = message;
		averagePos = pos;
		num = 1;
	}

	public bool TryGroup(string playerName, AntiHackType antiHackType, string message, Vector3 pos, float maxDistance)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (antiHackType != this.antiHackType || playerName != this.playerName || message != this.message)
		{
			return false;
		}
		if (Vector3.SqrMagnitude(averagePos - pos) > maxDistance * maxDistance)
		{
			return false;
		}
		Vector3 val = averagePos * (float)num;
		averagePos = (val + pos) / (float)(num + 1);
		num++;
		return true;
	}
}


using System;
using System.Collections;
using ConVar;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Networking;

public static class Auth_CentralizedBans
{
	[JsonModel]
	private class BanPayload
	{
		public ulong steamId;

		public string reason;

		public long expiryDate;

		public bool isMute;
	}

	private static readonly BanPayload payloadData = new BanPayload();

	public static IEnumerator Run(Connection connection)
	{
		int num = default(int);
		UnityWebRequest ownerRequest = default(UnityWebRequest);
		UnityWebRequest userRequest = default(UnityWebRequest);
		while (true)
		{
			object obj = Interface.CallHook("OnCentralizedBanCheck", (object)connection);
			if (obj != null)
			{
				break;
			}
			string text2;
			switch (num)
			{
			default:
				yield break;
			case 0:
				connection.authStatusCentralizedBans = string.Empty;
				if (!connection.active || connection.rejected)
				{
					yield break;
				}
				if (string.IsNullOrWhiteSpace(Server.bansServerEndpoint) || !Server.bansServerEndpoint.StartsWith("http"))
				{
					connection.authStatusCentralizedBans = "ok";
					yield break;
				}
				if (!Server.bansServerEndpoint.EndsWith("/") && !Server.bansServerEndpoint.EndsWith("="))
				{
					Server.bansServerEndpoint += "/";
				}
				if (connection.ownerid != 0L && connection.ownerid != connection.userid)
				{
					string text = Server.bansServerEndpoint + connection.ownerid;
					ownerRequest = UnityWebRequest.Get(text);
					ownerRequest.timeout = Server.bansServerTimeout;
					yield return ownerRequest.SendWebRequest();
					break;
				}
				goto IL_0186;
			case 1:
				if (CheckIfPlayerBanned(connection.ownerid, connection, ownerRequest))
				{
					connection.authStatusCentralizedBans = "banned_account_owner";
					yield break;
				}
				ownerRequest = null;
				goto IL_0186;
			case 2:
				{
					if (CheckIfPlayerBanned(connection.userid, connection, userRequest))
					{
						connection.authStatusCentralizedBans = "banned_account_player";
					}
					else
					{
						connection.authStatusCentralizedBans = "ok";
					}
					yield break;
				}
				IL_0186:
				text2 = Server.bansServerEndpoint + connection.userid;
				userRequest = UnityWebRequest.Get(text2);
				userRequest.timeout = Server.bansServerTimeout;
				yield return userRequest.SendWebRequest();
				break;
			}
		}
	}

	private static bool CheckIfPlayerBanned(ulong steamId, Connection connection, UnityWebRequest request)
	{
		if (request.isNetworkError)
		{
			Debug.LogError((object)("Failed to check centralized bans due to a network error (" + request.error + ")"));
			if (Server.bansServerFailureMode == 1)
			{
				Reject("Centralized Ban Error: Network Error");
				return true;
			}
			return false;
		}
		if (request.responseCode == 404)
		{
			return false;
		}
		if (request.isHttpError)
		{
			Debug.LogError((object)$"Failed to check centralized bans due to a server error ({request.responseCode}: {request.error})");
			if (Server.bansServerFailureMode == 1)
			{
				Reject("Centralized Ban Error: Server Error");
				return true;
			}
			return false;
		}
		try
		{
			payloadData.steamId = 0uL;
			payloadData.reason = null;
			payloadData.expiryDate = 0L;
			payloadData.isMute = false;
			JsonUtility.FromJsonOverwrite(request.downloadHandler.text, (object)payloadData);
			if (payloadData.expiryDate > 0 && Epoch.Current >= payloadData.expiryDate)
			{
				return false;
			}
			if (payloadData.steamId != steamId)
			{
				Debug.LogError((object)$"Failed to check centralized bans due to SteamID mismatch (expected {steamId}, got {payloadData.steamId})");
				if (Server.bansServerFailureMode == 1)
				{
					Reject("Centralized Ban Error: SteamID Mismatch");
					return true;
				}
				return false;
			}
			string text = payloadData.reason ?? "no reason given";
			string text2 = ((payloadData.expiryDate > 0) ? (" for " + NumberExtensions.FormatSecondsLong(payloadData.expiryDate - Epoch.Current)) : "");
			if (payloadData.isMute)
			{
				PlayerState val = SingletonComponent<ServerMgr>.Instance.playerStateManager.Get(steamId);
				val.chatMuted = true;
				if (payloadData.expiryDate > 0)
				{
					val.chatMuteExpiryTimestamp = payloadData.expiryDate;
				}
				else
				{
					val.chatMuteExpiryTimestamp = 0.0;
				}
			}
			else
			{
				Reject("You are banned from this server" + text2 + " (" + text + ")");
			}
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to check centralized bans due to a malformed response: " + request.downloadHandler.text));
			Debug.LogException(ex);
			if (Server.bansServerFailureMode == 1)
			{
				Reject("Centralized Ban Error: Malformed Response");
				return true;
			}
			return false;
		}
		void Reject(string reason)
		{
			ConnectionAuth.Reject(connection, reason);
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
	}
}


[JsonModel]
private class BanPayload
{
	public ulong steamId;

	public string reason;

	public long expiryDate;

	public bool isMute;
}


using System.Collections;
using Network;

public static class Auth_EAC
{
	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusEAC = string.Empty;
		if (connection.active && !connection.rejected)
		{
			EACServer.OnJoinGame(connection);
			while (connection.active && !connection.rejected && connection.authStatusEAC == string.Empty)
			{
				yield return null;
			}
		}
	}
}


using System;
using System.Collections;
using System.Threading.Tasks;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using Network;
using UnityEngine;

public static class Auth_Nexus
{
	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusNexus = string.Empty;
		if (!connection.active || connection.rejected)
		{
			yield break;
		}
		if (!NexusServer.Started)
		{
			connection.authStatusNexus = "ok";
			yield break;
		}
		Task<NexusLoginResult> loginTask = NexusServer.Login(connection.userid);
		yield return (object)new WaitUntil((Func<bool>)(() => loginTask.IsCompleted));
		if (loginTask.IsFaulted || loginTask.IsCanceled)
		{
			Reject("Nexus login failure");
			if (loginTask.Exception != null)
			{
				Debug.LogException((Exception)loginTask.Exception);
			}
			connection.authStatusNexus = "nexus_login_fail";
			yield break;
		}
		NexusLoginResult result = loginTask.Result;
		if (((NexusLoginResult)(ref result)).IsRedirect)
		{
			string text = ((((NexusLoginResult)(ref result)).AssignedZoneKey == null) ? null : NexusServer.FindZone(((NexusLoginResult)(ref result)).AssignedZoneKey)?.ConnectionProtocol());
			ConsoleNetwork.SendClientCommandImmediate(connection, "nexus.redirect", ((NexusLoginResult)(ref result)).RedirectIpAddress, ((NexusLoginResult)(ref result)).RedirectGamePort, text ?? "");
			Reject("Redirecting to another zone...");
			connection.authStatusNexus = "nexus_login_redirect";
			yield break;
		}
		if (((NexusLoginResult)(ref result)).AssignedZoneKey == null)
		{
			string spawnZoneKey;
			NexusZoneDetails spawnZone;
			try
			{
				spawnZoneKey = ZoneController.Instance.ChooseSpawnZone(connection.userid, isAlreadyAssignedToThisZone: false);
				if (string.IsNullOrWhiteSpace(spawnZoneKey))
				{
					throw new Exception("ZoneController did not choose a spawn zone (returned '" + (spawnZoneKey ?? "<null>") + "')");
				}
				spawnZone = NexusServer.FindZone(spawnZoneKey);
				if (spawnZone == null)
				{
					throw new Exception("ZoneController picked a spawn zone which we don't know about (" + spawnZoneKey + ")");
				}
			}
			catch (Exception ex)
			{
				Reject("Nexus spawn - exception while choosing spawn zone");
				Debug.LogException(ex);
				connection.authStatusNexus = "nexus_zone_pick_fail";
				yield break;
			}
			Task assignTask = NexusServer.AssignInitialZone(connection.userid, spawnZoneKey);
			yield return (object)new WaitUntil((Func<bool>)(() => assignTask.IsCompleted));
			if (assignTask.IsFaulted || assignTask.IsCanceled)
			{
				Reject("Nexus spawn - exception while registering transfer to spawn zone");
				if (assignTask.Exception != null)
				{
					Debug.LogException((Exception)assignTask.Exception);
				}
				connection.authStatusNexus = "nexus_zone_transfer_fail";
				yield break;
			}
			if (spawnZoneKey != NexusServer.ZoneKey)
			{
				ConsoleNetwork.SendClientCommandImmediate(connection, "nexus.redirect", spawnZone.IpAddress, spawnZone.GamePort, spawnZone.ConnectionProtocol());
				Reject("Redirecting to another zone...");
				connection.authStatusNexus = "nexus_zone_redirect";
				yield break;
			}
		}
		if (NexusServer.TryGetPlayer(connection.userid, out var player))
		{
			Variable val = default(Variable);
			if (!player.TryGetVariable("appKey", ref val) || (int)val.Type != 1 || string.IsNullOrWhiteSpace(val.GetAsString()))
			{
				player.SetVariable("appKey", Guid.NewGuid().ToString("N"), false, false);
			}
		}
		else
		{
			Debug.LogWarning((object)$"Couldn't find NexusPlayer for {connection.userid}, skipping setting up their app key");
		}
		connection.authStatusNexus = "ok";
		void Reject(string reason)
		{
			ConnectionAuth.Reject(connection, reason);
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
	}
}


using System;
using System.Collections;
using System.Threading.Tasks;
using ConVar;
using Network;
using UnityEngine;

public static class Auth_PremiumServer
{
	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusPremiumServer = string.Empty;
		if (!connection.active || connection.rejected)
		{
			yield break;
		}
		if (!Server.premium)
		{
			connection.authStatusPremiumServer = "ok";
			yield break;
		}
		Task<PremiumUtil.PremiumCheckResult> checkTask = PremiumUtil.CheckIfPlayerIsPremium(connection.userid);
		yield return (object)new WaitUntil((Func<bool>)(() => checkTask.IsCompleted));
		if (checkTask.IsFaulted || checkTask.IsCanceled)
		{
			Reject(connection, "Failed to validate premium status: Faulted/Canceled");
			if (checkTask.Exception != null)
			{
				Debug.LogException((Exception)checkTask.Exception);
			}
			connection.authStatusNexus = "premium_error";
		}
		else if (!checkTask.Result.IsPremium)
		{
			Reject(connection, checkTask.Result.FailReason ?? "Failed to validate premium status: Unknown Fail Reason");
			connection.authStatusPremiumServer = "account_not_premium";
		}
		else
		{
			connection.authStatusPremiumServer = "ok";
			connection.lastPremiumCheckTime = Time.realtimeSinceStartupAsDouble;
		}
	}

	private static void Reject(Connection connection, string reason)
	{
		ConnectionAuth.Reject(connection, reason);
		PlatformService.Instance.EndPlayerSession(connection.userid);
	}
}


using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using ConVar;
using Facepunch;
using Network;
using UnityEngine;

public static class Auth_Steam
{
	internal static List<Connection> waitingList = new List<Connection>();

	public static IEnumerator Run(Connection connection)
	{
		connection.authStatusSteam = string.Empty;
		if (!connection.active || connection.rejected)
		{
			yield break;
		}
		if (!PlatformService.Instance.BeginPlayerSession(connection.userid, connection.token))
		{
			ConnectionAuth.Reject(connection, "Steam Auth Failed");
			yield break;
		}
		waitingList.Add(connection);
		Stopwatch timeout = Stopwatch.StartNew();
		while (timeout.Elapsed.TotalSeconds < 30.0 && connection.active && !(connection.authStatusSteam != string.Empty))
		{
			yield return null;
		}
		waitingList.Remove(connection);
		if (connection.active)
		{
			if (connection.authStatusSteam.Length == 0)
			{
				ConnectionAuth.Reject(connection, "Steam Auth Timeout: No auth response");
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam == "banned")
			{
				ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam == "gamebanned")
			{
				ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam == "vacbanned")
			{
				ConnectionAuth.Reject(connection, "Steam Auth: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else if (connection.authStatusSteam != "ok")
			{
				ConnectionAuth.Reject(connection, "Steam Auth Failed", "Steam Auth Error: " + connection.authStatusSteam);
				PlatformService.Instance.EndPlayerSession(connection.userid);
			}
			else
			{
				string text = (Server.censorplayerlist ? RandomUsernames.Get(connection.userid + (ulong)Random.Range(0, 100000)) : connection.username);
				PlatformService.Instance.UpdatePlayerSession(connection.userid, text);
			}
		}
	}

	public static bool ValidateConnecting(ulong steamid, ulong ownerSteamID, AuthResponse response)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Invalid comparison between Unknown and I4
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Invalid comparison between Unknown and I4
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Invalid comparison between Unknown and I4
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Invalid comparison between Unknown and I4
		Connection val = waitingList.Find((Connection x) => x.userid == steamid);
		if (val == null)
		{
			return false;
		}
		val.ownerid = ownerSteamID;
		if (ServerUsers.Is(ownerSteamID, ServerUsers.UserGroup.Banned) || ServerUsers.Is(steamid, ServerUsers.UserGroup.Banned))
		{
			val.authStatusSteam = "banned";
			return true;
		}
		if ((int)response == 2)
		{
			val.authStatusSteam = "ok";
			return true;
		}
		if ((int)response == 3)
		{
			val.authStatusSteam = "vacbanned";
			return true;
		}
		if ((int)response == 4)
		{
			val.authStatusSteam = "gamebanned";
			return true;
		}
		if ((int)response == 1 && !Server.strictauth_steam && val.authLevel == 0 && val.os != "editor")
		{
			Debug.LogWarning((object)("Steam Auth Timeout: AuthResponse.TimedOut for " + steamid + " / " + ownerSteamID + " - bypassing since strictauth_steam is false"));
			val.authStatusSteam = "ok";
			return true;
		}
		val.authStatusSteam = ((object)(AuthResponse)(ref response)/*cast due to .constrained prefix*/).ToString();
		return true;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Newtonsoft.Json.Linq;
using Oxide.Core;
using UnityEngine;

public class ConnectionAuth : MonoBehaviour
{
	[NonSerialized]
	public static List<Connection> m_AuthConnection = new List<Connection>();

	private static RealTimeSince _sinceClientRequirementRefresh;

	private static (int, int)? _clientRequirementCache;

	private static string _clientVersionMismatchMessage;

	public bool IsAuthed(ulong iSteamID)
	{
		if (Object.op_Implicit((Object)(object)BasePlayer.FindByID(iSteamID)))
		{
			return true;
		}
		if (SingletonComponent<ServerMgr>.Instance.connectionQueue.IsJoining(iSteamID))
		{
			return true;
		}
		if (SingletonComponent<ServerMgr>.Instance.connectionQueue.IsQueued(iSteamID))
		{
			return true;
		}
		return false;
	}

	public static void Reject(Connection connection, string strReason, string strReasonPrivate = null)
	{
		DebugEx.Log((object)(((object)connection).ToString() + " Rejecting connection - " + (string.IsNullOrEmpty(strReasonPrivate) ? strReason : strReasonPrivate)), (StackTraceLogType)0);
		Net.sv.Kick(connection, strReason, false);
		m_AuthConnection.Remove(connection);
	}

	public static void OnDisconnect(Connection connection)
	{
		m_AuthConnection.Remove(connection);
	}

	public void Approve(Connection connection)
	{
		m_AuthConnection.Remove(connection);
		SingletonComponent<ServerMgr>.Instance.connectionQueue.Join(connection);
	}

	public void OnNewConnection(Connection connection)
	{
		connection.connected = false;
		if (connection.token == null || connection.token.Length < 32)
		{
			Reject(connection, "Invalid Token");
			return;
		}
		if (connection.userid == 0L)
		{
			Reject(connection, "Invalid SteamID");
			return;
		}
		if (connection.protocol != 2597)
		{
			if (!DeveloperList.Contains(connection.userid))
			{
				Reject(connection, "Incompatible Version");
				return;
			}
			DebugEx.Log((object)("Not kicking " + connection.userid + " for incompatible protocol (is a developer)"), (StackTraceLogType)0);
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Banned))
		{
			ServerUsers.User user = ServerUsers.Get(connection.userid);
			string text = user?.notes ?? "no reason given";
			string text2 = ((user != null && user.expiry > 0) ? (" for " + NumberExtensions.FormatSecondsLong(user.expiry - Epoch.Current)) : "");
			Reject(connection, "You are banned from this server" + text2 + " (" + text + ")");
			return;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Moderator))
		{
			DebugEx.Log((object)(((object)connection).ToString() + " has auth level 1"), (StackTraceLogType)0);
			connection.authLevel = 1u;
		}
		if (ServerUsers.Is(connection.userid, ServerUsers.UserGroup.Owner))
		{
			DebugEx.Log((object)(((object)connection).ToString() + " has auth level 2"), (StackTraceLogType)0);
			connection.authLevel = 2u;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			DebugEx.Log((object)(((object)connection).ToString() + " is a developer"), (StackTraceLogType)0);
			connection.authLevel = 3u;
		}
		if (Interface.CallHook("IOnUserApprove", (object)connection) == null)
		{
			m_AuthConnection.Add(connection);
			((MonoBehaviour)this).StartCoroutine(AuthorisationRoutine(connection));
		}
	}

	public IEnumerator AuthorisationRoutine(Connection connection)
	{
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_Steam.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_EAC.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_CentralizedBans.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_Nexus.Run(connection));
		yield return ((MonoBehaviour)this).StartCoroutine(Auth_PremiumServer.Run(connection));
		if (connection.rejected || !connection.active)
		{
			yield break;
		}
		if (IsAuthed(connection.userid))
		{
			Reject(connection, "You are already connected as a player!");
			yield break;
		}
		if (connection.authLevel == 0)
		{
			(int, int)? minClientRequirement = GetMinClientRequirement();
			if (minClientRequirement.HasValue && (connection.clientChangeset < minClientRequirement.Value.Item1 || connection.clientBuildTime < minClientRequirement.Value.Item2))
			{
				Reject(connection, GetClientVersionMismatchMessage());
				yield break;
			}
		}
		Approve(connection);
	}

	private static (int Changeset, int BuildTime)? GetMinClientRequirement()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Invalid comparison between Unknown and I4
		if (RealTimeSince.op_Implicit(_sinceClientRequirementRefresh) < 10f)
		{
			return _clientRequirementCache;
		}
		_sinceClientRequirementRefresh = RealTimeSince.op_Implicit(0f);
		_clientRequirementCache = null;
		try
		{
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.Branch : null);
			}
			if (obj == null)
			{
				obj = "";
			}
			string text = (string)obj;
			if (!string.IsNullOrWhiteSpace(text))
			{
				JObject obj2 = Application.Manifest?.Metadata;
				object obj3;
				if (obj2 == null)
				{
					obj3 = null;
				}
				else
				{
					JToken obj4 = obj2["ClientVersions"];
					obj3 = ((obj4 != null) ? obj4[(object)text] : null);
				}
				JToken val = (JToken)obj3;
				if (val != null && (int)val.Type == 1)
				{
					int item = val.Value<int>((object)"Changeset");
					int item2 = val.Value<int>((object)"Timestamp");
					_clientRequirementCache = (item, item2);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			_clientRequirementCache = null;
		}
		return _clientRequirementCache;
	}

	private static string GetClientVersionMismatchMessage()
	{
		if (!string.IsNullOrEmpty(_clientVersionMismatchMessage))
		{
			return _clientVersionMismatchMessage;
		}
		BuildInfo current = BuildInfo.Current;
		object obj;
		if (current == null)
		{
			obj = null;
		}
		else
		{
			ScmInfo scm = current.Scm;
			obj = ((scm != null) ? scm.Branch : null);
		}
		if (obj == null)
		{
			obj = "unknown";
		}
		string text = (string)obj;
		string text2 = text.ToLowerInvariant();
		string clientVersionMismatchMessage = ((text2 == "release") ? "Client update required. Close Rust and apply update from Steam." : ((!(text2 == "main")) ? ("Client update required. Apply \"Rust - Staging Branch\" (" + text + " beta) update from Steam.") : "Client update required. Apply \"Rust - Staging Branch\" update from Steam."));
		_clientVersionMismatchMessage = clientVersionMismatchMessage;
		return _clientVersionMismatchMessage;
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using UnityEngine;

public class ConnectionQueue
{
	private class ReservedServerSlot : IPooled
	{
		public ulong UserId;

		public float Expiry;

		public void EnterPool()
		{
		}

		public void LeavePool()
		{
			UserId = 0uL;
			Expiry = 0f;
		}
	}

	public List<Connection> queue = new List<Connection>();

	public List<Connection> joining = new List<Connection>();

	private List<ReservedServerSlot> reservedSlots = new List<ReservedServerSlot>();

	private float nextCleanupReservedSlots;

	public float nextMessageTime;

	public int ReservedCount => reservedSlots.Count;

	public int Queued => queue.Count;

	public int Joining => joining.Count;

	public bool IsServerFull => SingletonComponent<ServerMgr>.Instance.AvailableSlots - Joining <= 0;

	public void SkipQueue(ulong userid)
	{
		for (int i = 0; i < queue.Count; i++)
		{
			Connection val = queue[i];
			if (val.userid == userid)
			{
				JoinGame(val);
				break;
			}
		}
	}

	internal void Join(Connection connection)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnConnectionQueue", (object)connection) == null)
		{
			nextMessageTime = 0f;
			if ((Queued == 0 && !IsServerFull) || CanJumpQueue(connection))
			{
				JoinGame(connection);
				return;
			}
			connection.state = (State)2;
			queue.Add(connection);
		}
	}

	public void Cycle(int availableSlots)
	{
		if (Interface.CallHook("OnQueueCycle", (object)availableSlots) != null)
		{
			return;
		}
		if (Time.realtimeSinceStartup > nextCleanupReservedSlots)
		{
			nextCleanupReservedSlots = Time.realtimeSinceStartup + 1f;
			CleanupExpiredReservedSlots();
		}
		if (queue.Count != 0)
		{
			SendQueueUpdates();
			if (!IsServerFull)
			{
				JoinGame(queue[0]);
			}
		}
	}

	public void SendQueueUpdates()
	{
		if (!(nextMessageTime > Time.realtimeSinceStartup))
		{
			nextMessageTime = Time.realtimeSinceStartup + 10f;
			for (int i = 0; i < queue.Count; i++)
			{
				SendQueueUpdate(queue[i], i);
			}
		}
	}

	public void SendQueueUpdate(Connection c, int position)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnQueueUpdate", (object)c, (object)position) == null)
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)26);
			obj.UInt16((ushort)Queued);
			obj.UInt16((ushort)position);
			obj.Send(new SendInfo(c));
		}
	}

	public void RemoveConnection(Connection connection)
	{
		if (Interface.CallHook("OnConnectionDequeue", (object)connection) == null)
		{
			if (queue.Remove(connection))
			{
				nextMessageTime = 0f;
			}
			joining.Remove(connection);
		}
	}

	public void TryAddReservedSlot(Connection connection)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Invalid comparison between Unknown and I4
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Invalid comparison between Unknown and I4
		if (connection.canReserveSlot && ((int)connection.state == 4 || (int)connection.state == 3))
		{
			AddReservation(connection.userid);
		}
	}

	private void JoinGame(Connection connection)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		queue.Remove(connection);
		connection.state = (State)3;
		RemoveReservedSlot(connection.userid);
		nextMessageTime = 0f;
		joining.Add(connection);
		SingletonComponent<ServerMgr>.Instance.JoinGame(connection);
	}

	public void JoinedGame(Connection connection)
	{
		RemoveConnection(connection);
	}

	private void AddReservation(ulong userId)
	{
		ReservedServerSlot reservedServerSlot = FindQueueSpot(userId);
		if (reservedServerSlot == null)
		{
			reservedServerSlot = Pool.Get<ReservedServerSlot>();
			reservedSlots.Add(reservedServerSlot);
		}
		reservedServerSlot.UserId = userId;
		reservedServerSlot.Expiry = Time.realtimeSinceStartup + (float)Server.rejoin_delay;
	}

	private void CleanupExpiredReservedSlots()
	{
		if (reservedSlots.Count == 0)
		{
			return;
		}
		float realtimeSinceStartup = Time.realtimeSinceStartup;
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			ReservedServerSlot reservedServerSlot = reservedSlots[i];
			if (realtimeSinceStartup > reservedServerSlot.Expiry)
			{
				reservedSlots.RemoveAt(i);
				i--;
				Pool.Free<ReservedServerSlot>(ref reservedServerSlot);
			}
		}
	}

	private ReservedServerSlot FindQueueSpot(ulong userId)
	{
		foreach (ReservedServerSlot reservedSlot in reservedSlots)
		{
			if (reservedSlot.UserId == userId)
			{
				return reservedSlot;
			}
		}
		return null;
	}

	private void RemoveReservedSlot(ulong userId)
	{
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			ReservedServerSlot reservedServerSlot = reservedSlots[i];
			if (reservedServerSlot.UserId == userId)
			{
				reservedSlots.RemoveAt(i);
				i--;
				Pool.Free<ReservedServerSlot>(ref reservedServerSlot);
			}
		}
	}

	private bool CanJumpQueue(Connection connection)
	{
		object obj = Interface.CallHook("CanBypassQueue", (object)connection);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (DeveloperList.Contains(connection.userid))
		{
			return true;
		}
		ServerUsers.User user = ServerUsers.Get(connection.userid);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			return true;
		}
		if (user != null && user.group == ServerUsers.UserGroup.SkipQueue)
		{
			return true;
		}
		for (int i = 0; i < reservedSlots.Count; i++)
		{
			if (reservedSlots[i].UserId == connection.userid && reservedSlots[i].Expiry > Time.realtimeSinceStartup)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsQueued(ulong userid)
	{
		for (int i = 0; i < queue.Count; i++)
		{
			if (queue[i].userid == userid)
			{
				return true;
			}
		}
		return false;
	}

	public bool IsJoining(ulong userid)
	{
		for (int i = 0; i < joining.Count; i++)
		{
			if (joining[i].userid == userid)
			{
				return true;
			}
		}
		return false;
	}
}


using Facepunch;

private class ReservedServerSlot : IPooled
{
	public ulong UserId;

	public float Expiry;

	public void EnterPool()
	{
	}

	public void LeavePool()
	{
		UserId = 0uL;
		Expiry = 0f;
	}
}


using System;
using System.Collections.Concurrent;
using System.IO;
using ConVar;
using Epic.OnlineServices;
using Epic.OnlineServices.AntiCheatCommon;
using Epic.OnlineServices.AntiCheatServer;
using Epic.OnlineServices.Connect;
using Epic.OnlineServices.Reports;
using Network;
using Oxide.Core;
using UnityEngine;

public static class EACServer
{
	private static AntiCheatServerInterface Interface = null;

	private static ReportsInterface Reports = null;

	private static ConcurrentDictionary<uint, Connection> client2connection = new ConcurrentDictionary<uint, Connection>();

	private static ConcurrentDictionary<Connection, uint> connection2client = new ConcurrentDictionary<Connection, uint>();

	private static ConcurrentDictionary<Connection, AntiCheatCommonClientAuthStatus> connection2status = new ConcurrentDictionary<Connection, AntiCheatCommonClientAuthStatus>();

	private static uint clientHandleCounter = 0u;

	private static bool CanEnableGameplayData
	{
		get
		{
			if (Server.official)
			{
				return Server.stats;
			}
			return false;
		}
	}

	private static bool CanSendAnalytics
	{
		get
		{
			if (CanEnableGameplayData)
			{
				return (Handle)(object)Interface != (Handle)null;
			}
			return false;
		}
	}

	private static bool CanSendReports => (Handle)(object)Reports != (Handle)null;

	private static IntPtr GenerateCompatibilityClient()
	{
		return (IntPtr)(++clientHandleCounter);
	}

	public static void Encrypt(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		uint count = (uint)dst.Count;
		dst = new ArraySegment<byte>(dst.Array, dst.Offset, 0);
		if (!((Handle)(object)Interface != (Handle)null))
		{
			return;
		}
		IntPtr client = GetClient(connection);
		if (client != IntPtr.Zero)
		{
			ProtectMessageOptions val = default(ProtectMessageOptions);
			((ProtectMessageOptions)(ref val)).ClientHandle = client;
			((ProtectMessageOptions)(ref val)).Data = src;
			((ProtectMessageOptions)(ref val)).OutBufferSizeBytes = count;
			ProtectMessageOptions val2 = val;
			uint count2 = default(uint);
			Result val3 = Interface.ProtectMessage(ref val2, dst, ref count2);
			if ((int)val3 == 0)
			{
				dst = new ArraySegment<byte>(dst.Array, dst.Offset, (int)count2);
			}
			else
			{
				Debug.LogWarning((object)("[EAC] ProtectMessage failed: " + ((object)(Result)(ref val3)/*cast due to .constrained prefix*/).ToString()));
			}
		}
	}

	public static void Decrypt(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		uint count = (uint)dst.Count;
		dst = new ArraySegment<byte>(dst.Array, dst.Offset, 0);
		if (!((Handle)(object)Interface != (Handle)null))
		{
			return;
		}
		IntPtr client = GetClient(connection);
		if (client != IntPtr.Zero)
		{
			UnprotectMessageOptions val = default(UnprotectMessageOptions);
			((UnprotectMessageOptions)(ref val)).ClientHandle = client;
			((UnprotectMessageOptions)(ref val)).Data = src;
			((UnprotectMessageOptions)(ref val)).OutBufferSizeBytes = count;
			UnprotectMessageOptions val2 = val;
			uint count2 = default(uint);
			Result val3 = Interface.UnprotectMessage(ref val2, dst, ref count2);
			if ((int)val3 == 0)
			{
				dst = new ArraySegment<byte>(dst.Array, dst.Offset, (int)count2);
			}
			else
			{
				Debug.LogWarning((object)("[EAC] UnprotectMessage failed: " + ((object)(Result)(ref val3)/*cast due to .constrained prefix*/).ToString()));
			}
		}
	}

	private static IntPtr GetClient(Connection connection)
	{
		connection2client.TryGetValue(connection, out var value);
		return (IntPtr)value;
	}

	private static Connection GetConnection(IntPtr client)
	{
		client2connection.TryGetValue((uint)(int)client, out var value);
		return value;
	}

	public static bool IsAuthenticated(Connection connection)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Invalid comparison between Unknown and I4
		connection2status.TryGetValue(connection, out var value);
		return (int)value == 2;
	}

	private static void OnAuthenticatedLocal(Connection connection)
	{
		if (!Server.strictauth_eac && connection.authStatusEAC == string.Empty)
		{
			connection.authStatusEAC = "ok";
		}
		connection2status[connection] = (AntiCheatCommonClientAuthStatus)1;
	}

	private static void OnAuthenticatedRemote(Connection connection)
	{
		if (Server.strictauth_eac && connection.authStatusEAC == string.Empty)
		{
			connection.authStatusEAC = "ok";
		}
		connection2status[connection] = (AntiCheatCommonClientAuthStatus)2;
	}

	private static void OnVerifyIdToken(ref VerifyIdTokenCallbackInfo data)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.anticheattoken)
		{
			Debug.LogWarning((object)"[EAC] Verify ID token skipped: server.anticheattoken == false");
			return;
		}
		IntPtr client = (IntPtr)((VerifyIdTokenCallbackInfo)(ref data)).ClientData;
		Connection connection = GetConnection(client);
		if (connection == null)
		{
			Debug.LogError((object)("[EAC] Verify ID token for invalid client: " + client));
			return;
		}
		if (connection.IsDevelopmentBuild())
		{
			Debug.LogWarning((object)("[EAC] Verify ID token skipped for unprotected client: " + ((object)connection).ToString()));
			return;
		}
		if ((int)((VerifyIdTokenCallbackInfo)(ref data)).ResultCode != 0)
		{
			Result resultCode = ((VerifyIdTokenCallbackInfo)(ref data)).ResultCode;
			string text = "Verify ID token " + ((object)(Result)(ref resultCode)/*cast due to .constrained prefix*/).ToString();
			Debug.Log((object)$"[EAC] Kicking {connection.userid} / {connection.username} ({text})");
			connection.authStatusEAC = "eactoken";
			Net.sv.Kick(connection, "EAC: " + text, false);
			return;
		}
		string text2 = ((object)((VerifyIdTokenCallbackInfo)(ref data)).AccountId).ToString();
		string text3 = connection.userid.ToString();
		if (text2 != text3)
		{
			string text4 = "Verify ID token account mismatch with " + text2 + " != " + text3;
			Debug.Log((object)$"[EAC] Kicking {connection.userid} / {connection.username} ({text4})");
			connection.authStatusEAC = "eactoken";
			Net.sv.Kick(connection, "EAC: " + text4, false);
		}
	}

	private static void OnClientAuthStatusChanged(ref OnClientAuthStatusChangedCallbackInfo data)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Invalid comparison between Unknown and I4
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Invalid comparison between Unknown and I4
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Expected O, but got Unknown
		TimeWarning val = TimeWarning.New("AntiCheatKickPlayer", 10);
		try
		{
			IntPtr clientHandle = ((OnClientAuthStatusChangedCallbackInfo)(ref data)).ClientHandle;
			Connection connection = GetConnection(clientHandle);
			if (connection == null)
			{
				Debug.LogError((object)("[EAC] Status update for invalid client: " + clientHandle));
			}
			else if ((int)((OnClientAuthStatusChangedCallbackInfo)(ref data)).ClientAuthStatus == 1)
			{
				OnAuthenticatedLocal(connection);
				SetClientNetworkStateOptions val2 = default(SetClientNetworkStateOptions);
				((SetClientNetworkStateOptions)(ref val2)).ClientHandle = clientHandle;
				((SetClientNetworkStateOptions)(ref val2)).IsNetworkActive = false;
				SetClientNetworkStateOptions val3 = val2;
				Interface.SetClientNetworkState(ref val3);
			}
			else if ((int)((OnClientAuthStatusChangedCallbackInfo)(ref data)).ClientAuthStatus == 2)
			{
				OnAuthenticatedRemote(connection);
				IdToken val4 = default(IdToken);
				((IdToken)(ref val4)).ProductUserId = ProductUserId.FromString(Utf8String.op_Implicit(connection.anticheatId));
				((IdToken)(ref val4)).JsonWebToken = Utf8String.op_Implicit(connection.anticheatToken);
				IdToken val5 = val4;
				EOS.VerifyIdToken(clientHandle, val5, new OnVerifyIdTokenCallback(OnVerifyIdToken));
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void OnClientActionRequired(ref OnClientActionRequiredCallbackInfo data)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Invalid comparison between Unknown and I4
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Invalid comparison between Unknown and I4
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Invalid comparison between Unknown and I4
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Invalid comparison between Unknown and I4
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("OnClientActionRequired", 10);
		try
		{
			IntPtr clientHandle = ((OnClientActionRequiredCallbackInfo)(ref data)).ClientHandle;
			Connection connection = GetConnection(clientHandle);
			if (connection == null)
			{
				Debug.LogError((object)("[EAC] Status update for invalid client: " + clientHandle));
			}
			else
			{
				if ((int)((OnClientActionRequiredCallbackInfo)(ref data)).ClientAction != 1)
				{
					return;
				}
				Utf8String actionReasonDetailsString = ((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonDetailsString;
				if (connection.IsDevelopmentBuild())
				{
					Debug.LogWarning((object)("[EAC] Remove player action skipped for unprotected client: " + ((object)connection).ToString()));
					return;
				}
				Debug.Log((object)$"[EAC] Kicking {connection.userid} / {connection.username} ({actionReasonDetailsString})");
				connection.authStatusEAC = "eac";
				Net.sv.Kick(connection, Utf8String.op_Implicit(Utf8String.op_Implicit("EAC: ") + actionReasonDetailsString), false);
				Interface.CallHook("OnPlayerKicked", (object)connection, (object)actionReasonDetailsString.ToString());
				if ((int)((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonCode == 10 || (int)((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonCode == 9)
				{
					connection.authStatusEAC = "eacbanned";
					ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + connection.username + " (banned by anticheat)");
					Interface.CallHook("OnPlayerBanned", (object)connection, (object)actionReasonDetailsString.ToString());
					if ((int)((OnClientActionRequiredCallbackInfo)(ref data)).ActionReasonCode == 10)
					{
						Entity.DeleteBy(connection.userid);
					}
				}
				UnregisterClientOptions val2 = default(UnregisterClientOptions);
				((UnregisterClientOptions)(ref val2)).ClientHandle = clientHandle;
				UnregisterClientOptions val3 = val2;
				Interface.UnregisterClient(ref val3);
				client2connection.TryRemove((uint)(int)clientHandle, out var _);
				connection2client.TryRemove(connection, out var _);
				connection2status.TryRemove(connection, out var _);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void SendToClient(ref OnMessageToClientCallbackInfo data)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		IntPtr clientHandle = ((OnMessageToClientCallbackInfo)(ref data)).ClientHandle;
		Connection connection = GetConnection(clientHandle);
		if (connection == null)
		{
			Debug.LogError((object)("[EAC] Network packet for invalid client: " + clientHandle));
			return;
		}
		NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
		obj.PacketID((Type)22);
		obj.UInt32((uint)((OnMessageToClientCallbackInfo)(ref data)).MessageData.Count);
		((Stream)(object)obj).Write(((OnMessageToClientCallbackInfo)(ref data)).MessageData.Array, ((OnMessageToClientCallbackInfo)(ref data)).MessageData.Offset, ((OnMessageToClientCallbackInfo)(ref data)).MessageData.Count);
		obj.Send(new SendInfo(connection));
	}

	public static void DoStartup()
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Expected O, but got Unknown
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Expected O, but got Unknown
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Expected O, but got Unknown
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv.secure && !Application.isEditor)
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
			AddNotifyClientActionRequiredOptions val = default(AddNotifyClientActionRequiredOptions);
			AddNotifyClientAuthStatusChangedOptions val2 = default(AddNotifyClientAuthStatusChangedOptions);
			AddNotifyMessageToClientOptions val3 = default(AddNotifyMessageToClientOptions);
			BeginSessionOptions val4 = default(BeginSessionOptions);
			((BeginSessionOptions)(ref val4)).LocalUserId = null;
			((BeginSessionOptions)(ref val4)).EnableGameplayData = CanEnableGameplayData;
			((BeginSessionOptions)(ref val4)).RegisterTimeoutSeconds = 20u;
			((BeginSessionOptions)(ref val4)).ServerName = Utf8String.op_Implicit(Server.hostname);
			BeginSessionOptions val5 = val4;
			LogGameRoundStartOptions val6 = default(LogGameRoundStartOptions);
			((LogGameRoundStartOptions)(ref val6)).LevelName = Utf8String.op_Implicit(World.Name);
			LogGameRoundStartOptions val7 = val6;
			EOS.Initialize(true, Server.anticheatid, Server.anticheatkey, Server.rootFolder + "/Log.EAC.txt");
			Interface = EOS.Interface.GetAntiCheatServerInterface();
			Interface.AddNotifyClientActionRequired(ref val, (object)null, new OnClientActionRequiredCallback(OnClientActionRequired));
			Interface.AddNotifyClientAuthStatusChanged(ref val2, (object)null, new OnClientAuthStatusChangedCallback(OnClientAuthStatusChanged));
			Interface.AddNotifyMessageToClient(ref val3, (object)null, new OnMessageToClientCallback(SendToClient));
			Interface.BeginSession(ref val5);
			Interface.LogGameRoundStart(ref val7);
		}
		else
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
		}
	}

	public static void DoUpdate()
	{
		if (Net.sv.secure && !Application.isEditor)
		{
			EOS.Tick();
		}
	}

	public static void DoShutdown()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv.secure && !Application.isEditor)
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
			if ((Handle)(object)Interface != (Handle)null)
			{
				Debug.Log((object)"EasyAntiCheat Server Shutting Down");
				EndSessionOptions val = default(EndSessionOptions);
				Interface.EndSession(ref val);
				Interface = null;
				EOS.Shutdown();
			}
		}
		else
		{
			client2connection.Clear();
			connection2client.Clear();
			connection2status.Clear();
		}
	}

	public static void OnLeaveGame(Connection connection)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		AntiCheatCommonClientAuthStatus value3;
		if (Net.sv.secure && !Application.isEditor)
		{
			if ((Handle)(object)Interface != (Handle)null)
			{
				IntPtr client = GetClient(connection);
				if (client != IntPtr.Zero)
				{
					UnregisterClientOptions val = default(UnregisterClientOptions);
					((UnregisterClientOptions)(ref val)).ClientHandle = client;
					UnregisterClientOptions val2 = val;
					Interface.UnregisterClient(ref val2);
					client2connection.TryRemove((uint)(int)client, out var _);
				}
				connection2client.TryRemove(connection, out var _);
				connection2status.TryRemove(connection, out value3);
			}
		}
		else
		{
			connection2status.TryRemove(connection, out value3);
		}
	}

	public static void OnJoinGame(Connection connection)
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Invalid comparison between Unknown and I4
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv.secure && !Application.isEditor)
		{
			if (!((Handle)(object)Interface != (Handle)null))
			{
				return;
			}
			IntPtr intPtr = GenerateCompatibilityClient();
			if (intPtr == IntPtr.Zero)
			{
				Debug.LogError((object)("[EAC] GenerateCompatibilityClient returned invalid client: " + intPtr));
				return;
			}
			RegisterClientOptions val = default(RegisterClientOptions);
			((RegisterClientOptions)(ref val)).ClientHandle = intPtr;
			((RegisterClientOptions)(ref val)).UserId = ProductUserId.FromString(Utf8String.op_Implicit(connection.anticheatId));
			((RegisterClientOptions)(ref val)).IpAddress = Utf8String.op_Implicit(connection.IPAddressWithoutPort());
			((RegisterClientOptions)(ref val)).ClientType = (AntiCheatCommonClientType)(connection.IsDevelopmentBuild() ? 1 : 0);
			((RegisterClientOptions)(ref val)).ClientPlatform = (AntiCheatCommonClientPlatform)((connection.os == "windows") ? 1 : ((connection.os == "linux") ? 3 : ((connection.os == "mac") ? 2 : 0)));
			RegisterClientOptions val2 = val;
			if ((int)((RegisterClientOptions)(ref val2)).ClientType == 1)
			{
				Debug.LogWarning((object)("[EAC] Joining game as unprotected client: " + ((object)connection).ToString()));
			}
			SetClientDetailsOptions val3 = default(SetClientDetailsOptions);
			((SetClientDetailsOptions)(ref val3)).ClientHandle = intPtr;
			((SetClientDetailsOptions)(ref val3)).ClientFlags = (AntiCheatCommonClientFlags)((connection.authLevel != 0) ? 1 : 0);
			SetClientDetailsOptions val4 = val3;
			Interface.RegisterClient(ref val2);
			Interface.SetClientDetails(ref val4);
			client2connection.TryAdd((uint)(int)intPtr, connection);
			connection2client.TryAdd(connection, (uint)(int)intPtr);
			connection2status.TryAdd(connection, (AntiCheatCommonClientAuthStatus)0);
		}
		else
		{
			connection2status.TryAdd(connection, (AntiCheatCommonClientAuthStatus)0);
			OnAuthenticatedLocal(connection);
			OnAuthenticatedRemote(connection);
		}
	}

	public static void OnStartLoading(Connection connection)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Handle)(object)Interface != (Handle)null)
		{
			IntPtr client = GetClient(connection);
			if (client != IntPtr.Zero)
			{
				SetClientNetworkStateOptions val = default(SetClientNetworkStateOptions);
				((SetClientNetworkStateOptions)(ref val)).ClientHandle = client;
				((SetClientNetworkStateOptions)(ref val)).IsNetworkActive = false;
				SetClientNetworkStateOptions val2 = val;
				Interface.SetClientNetworkState(ref val2);
			}
		}
	}

	public static void OnFinishLoading(Connection connection)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if ((Handle)(object)Interface != (Handle)null)
		{
			IntPtr client = GetClient(connection);
			if (client != IntPtr.Zero)
			{
				SetClientNetworkStateOptions val = default(SetClientNetworkStateOptions);
				((SetClientNetworkStateOptions)(ref val)).ClientHandle = client;
				((SetClientNetworkStateOptions)(ref val)).IsNetworkActive = true;
				SetClientNetworkStateOptions val2 = val;
				Interface.SetClientNetworkState(ref val2);
			}
		}
	}

	public static void OnMessageReceived(Message message)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		IntPtr client = GetClient(message.connection);
		byte[] array = default(byte[]);
		int count = default(int);
		if (client == IntPtr.Zero)
		{
			Debug.LogError((object)("EAC network packet from invalid connection: " + message.connection.userid));
		}
		else if (message.read.TemporaryBytesWithSize(ref array, ref count))
		{
			ReceiveMessageFromClientOptions val = default(ReceiveMessageFromClientOptions);
			((ReceiveMessageFromClientOptions)(ref val)).ClientHandle = client;
			((ReceiveMessageFromClientOptions)(ref val)).Data = new ArraySegment<byte>(array, 0, count);
			ReceiveMessageFromClientOptions val2 = val;
			Interface.ReceiveMessageFromClient(ref val2);
		}
	}

	public static void LogPlayerUseWeapon(BasePlayer player, BaseProjectile weapon)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && player.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerShooting", 0);
			try
			{
				Vector3 networkPosition = player.GetNetworkPosition();
				Quaternion networkRotation = player.GetNetworkRotation();
				Item item = weapon.GetItem();
				string text = ((item != null) ? item.info.shortname : "unknown");
				LogPlayerUseWeaponOptions val2 = default(LogPlayerUseWeaponOptions);
				LogPlayerUseWeaponData value = default(LogPlayerUseWeaponData);
				((LogPlayerUseWeaponData)(ref value)).PlayerHandle = GetClient(player.net.connection);
				Vec3f value2 = default(Vec3f);
				((Vec3f)(ref value2)).x = networkPosition.x;
				((Vec3f)(ref value2)).y = networkPosition.y;
				((Vec3f)(ref value2)).z = networkPosition.z;
				((LogPlayerUseWeaponData)(ref value)).PlayerPosition = value2;
				Quat value3 = default(Quat);
				((Quat)(ref value3)).w = networkRotation.w;
				((Quat)(ref value3)).x = networkRotation.x;
				((Quat)(ref value3)).y = networkRotation.y;
				((Quat)(ref value3)).z = networkRotation.z;
				((LogPlayerUseWeaponData)(ref value)).PlayerViewRotation = value3;
				((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit(text);
				((LogPlayerUseWeaponOptions)(ref val2)).UseWeaponData = value;
				Interface.LogPlayerUseWeapon(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void LogPlayerSpawn(BasePlayer player)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && player.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerSpawn", 0);
			try
			{
				LogPlayerSpawnOptions val2 = default(LogPlayerSpawnOptions);
				((LogPlayerSpawnOptions)(ref val2)).SpawnedPlayerHandle = GetClient(player.net.connection);
				Interface.LogPlayerSpawn(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void LogPlayerDespawn(BasePlayer player)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && player.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerDespawn", 0);
			try
			{
				LogPlayerDespawnOptions val2 = default(LogPlayerDespawnOptions);
				((LogPlayerDespawnOptions)(ref val2)).DespawnedPlayerHandle = GetClient(player.net.connection);
				Interface.LogPlayerDespawn(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void LogPlayerTakeDamage(BasePlayer player, HitInfo info, bool wasWounded)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		if (!CanSendAnalytics || !((Object)(object)info.Initiator != (Object)null) || !(info.Initiator is BasePlayer))
		{
			return;
		}
		BasePlayer basePlayer = info.Initiator.ToPlayer();
		if (player.net.connection == null || basePlayer.net.connection == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EAC.LogPlayerTakeDamage", 0);
		try
		{
			LogPlayerTakeDamageOptions val2 = default(LogPlayerTakeDamageOptions);
			LogPlayerUseWeaponData value = default(LogPlayerUseWeaponData);
			((LogPlayerTakeDamageOptions)(ref val2)).AttackerPlayerHandle = GetClient(basePlayer.net.connection);
			((LogPlayerTakeDamageOptions)(ref val2)).VictimPlayerHandle = GetClient(player.net.connection);
			((LogPlayerTakeDamageOptions)(ref val2)).DamageTaken = info.damageTypes.Total();
			Vec3f value2 = default(Vec3f);
			((Vec3f)(ref value2)).x = info.HitPositionWorld.x;
			((Vec3f)(ref value2)).y = info.HitPositionWorld.y;
			((Vec3f)(ref value2)).z = info.HitPositionWorld.z;
			((LogPlayerTakeDamageOptions)(ref val2)).DamagePosition = value2;
			((LogPlayerTakeDamageOptions)(ref val2)).IsCriticalHit = info.isHeadshot;
			if (player.IsDead())
			{
				((LogPlayerTakeDamageOptions)(ref val2)).DamageResult = (AntiCheatCommonPlayerTakeDamageResult)(wasWounded ? 5 : 4);
			}
			else if (player.IsWounded())
			{
				((LogPlayerTakeDamageOptions)(ref val2)).DamageResult = (AntiCheatCommonPlayerTakeDamageResult)3;
			}
			if ((Object)(object)info.Weapon != (Object)null)
			{
				Item item = info.Weapon.GetItem();
				if (item != null)
				{
					((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit(item.info.shortname);
				}
				else
				{
					((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit("unknown");
				}
			}
			else
			{
				((LogPlayerUseWeaponData)(ref value)).WeaponName = Utf8String.op_Implicit("unknown");
			}
			Vector3 position = basePlayer.eyes.position;
			Quaternion rotation = basePlayer.eyes.rotation;
			Vector3 position2 = player.eyes.position;
			Quaternion rotation2 = player.eyes.rotation;
			value2 = default(Vec3f);
			((Vec3f)(ref value2)).x = position.x;
			((Vec3f)(ref value2)).y = position.y;
			((Vec3f)(ref value2)).z = position.z;
			((LogPlayerTakeDamageOptions)(ref val2)).AttackerPlayerPosition = value2;
			Quat value3 = default(Quat);
			((Quat)(ref value3)).w = rotation.w;
			((Quat)(ref value3)).x = rotation.x;
			((Quat)(ref value3)).y = rotation.y;
			((Quat)(ref value3)).z = rotation.z;
			((LogPlayerTakeDamageOptions)(ref val2)).AttackerPlayerViewRotation = value3;
			value2 = default(Vec3f);
			((Vec3f)(ref value2)).x = position2.x;
			((Vec3f)(ref value2)).y = position2.y;
			((Vec3f)(ref value2)).z = position2.z;
			((LogPlayerTakeDamageOptions)(ref val2)).VictimPlayerPosition = value2;
			value3 = default(Quat);
			((Quat)(ref value3)).w = rotation2.w;
			((Quat)(ref value3)).x = rotation2.x;
			((Quat)(ref value3)).y = rotation2.y;
			((Quat)(ref value3)).z = rotation2.z;
			((LogPlayerTakeDamageOptions)(ref val2)).VictimPlayerViewRotation = value3;
			((LogPlayerTakeDamageOptions)(ref val2)).PlayerUseWeaponData = value;
			Interface.LogPlayerTakeDamage(ref val2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	internal static void LogPlayerTick(Networkable playerNet, in BasePlayer.CachedState tickState)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		if (!CanSendAnalytics || playerNet == null || playerNet.connection == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("EAC.LogPlayerTick", 0);
		try
		{
			LogPlayerTickOptions val2 = default(LogPlayerTickOptions);
			((LogPlayerTickOptions)(ref val2)).PlayerHandle = GetClient(playerNet.connection);
			Vector3 center = tickState.Center;
			Vec3f value = default(Vec3f);
			((Vec3f)(ref value)).x = center.x;
			((Vec3f)(ref value)).y = center.y;
			((Vec3f)(ref value)).z = center.z;
			((LogPlayerTickOptions)(ref val2)).PlayerPosition = value;
			Vector3 eyePos = tickState.EyePos;
			value = default(Vec3f);
			((Vec3f)(ref value)).x = eyePos.x;
			((Vec3f)(ref value)).y = eyePos.y;
			((Vec3f)(ref value)).z = eyePos.z;
			((LogPlayerTickOptions)(ref val2)).PlayerViewPosition = value;
			Quaternion eyeRot = tickState.EyeRot;
			Quat value2 = default(Quat);
			((Quat)(ref value2)).w = eyeRot.w;
			((Quat)(ref value2)).x = eyeRot.x;
			((Quat)(ref value2)).y = eyeRot.y;
			((Quat)(ref value2)).z = eyeRot.z;
			((LogPlayerTickOptions)(ref val2)).PlayerViewRotation = value2;
			((LogPlayerTickOptions)(ref val2)).PlayerHealth = tickState.Health;
			if (tickState.IsDucking)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 1);
			}
			if (tickState.IsMounted)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 3);
			}
			if (tickState.IsCrawling)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 2);
			}
			if (tickState.IsSwimming)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 4);
			}
			if (!tickState.IsOnGround)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 5);
			}
			if (tickState.IsOnLadder)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 7);
			}
			if (tickState.IsFlying)
			{
				((LogPlayerTickOptions)(ref val2)).PlayerMovementState = (AntiCheatCommonPlayerMovementState)(((LogPlayerTickOptions)(ref val2)).PlayerMovementState | 6);
			}
			Interface.LogPlayerTick(ref val2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static void LogPlayerRevive(BasePlayer source, BasePlayer target)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendAnalytics && target.net.connection != null && (Object)(object)source != (Object)null && source.net.connection != null)
		{
			TimeWarning val = TimeWarning.New("EAC.LogPlayerRevive", 0);
			try
			{
				LogPlayerReviveOptions val2 = default(LogPlayerReviveOptions);
				((LogPlayerReviveOptions)(ref val2)).RevivedPlayerHandle = GetClient(target.net.connection);
				((LogPlayerReviveOptions)(ref val2)).ReviverPlayerHandle = GetClient(source.net.connection);
				Interface.LogPlayerRevive(ref val2);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	public static void SendPlayerBehaviorReport(BasePlayer reporter, PlayerReportsCategory reportCategory, string reportedID, string reportText)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendReports)
		{
			SendPlayerBehaviorReportOptions val = default(SendPlayerBehaviorReportOptions);
			((SendPlayerBehaviorReportOptions)(ref val)).ReportedUserId = ProductUserId.FromString(Utf8String.op_Implicit(reportedID));
			((SendPlayerBehaviorReportOptions)(ref val)).ReporterUserId = ProductUserId.FromString(Utf8String.op_Implicit(reporter.UserIDString));
			((SendPlayerBehaviorReportOptions)(ref val)).Category = reportCategory;
			((SendPlayerBehaviorReportOptions)(ref val)).Message = Utf8String.op_Implicit(reportText);
			SendPlayerBehaviorReportOptions val2 = val;
			Reports.SendPlayerBehaviorReport(ref val2, (object)null, (OnSendPlayerBehaviorReportCompleteCallback)null);
		}
	}

	public static void SendPlayerBehaviorReport(PlayerReportsCategory reportCategory, string reportedID, string reportText)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (CanSendReports)
		{
			SendPlayerBehaviorReportOptions val = default(SendPlayerBehaviorReportOptions);
			((SendPlayerBehaviorReportOptions)(ref val)).ReportedUserId = ProductUserId.FromString(Utf8String.op_Implicit(reportedID));
			((SendPlayerBehaviorReportOptions)(ref val)).Category = reportCategory;
			((SendPlayerBehaviorReportOptions)(ref val)).Message = Utf8String.op_Implicit(reportText);
			SendPlayerBehaviorReportOptions val2 = val;
			Reports.SendPlayerBehaviorReport(ref val2, (object)null, (OnSendPlayerBehaviorReportCompleteCallback)null);
		}
	}
}


using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using ConVar;
using UnityEngine;

public static class MapUploader
{
	private static readonly HttpClient Http = new HttpClient();

	public static bool IsUploaded { get; private set; }

	public static string OriginalName { get; private set; }

	public static string OriginalMapFileName { get; private set; }

	public static string OriginalSaveFileName { get; private set; }

	public static bool IsImageUploaded { get; private set; }

	public static string ImageUrl { get; private set; }

	public static async Task UploadMap()
	{
		if (IsUploaded)
		{
			Debug.Log((object)"[Rust.MapCache] Map was already uploaded!");
			return;
		}
		if (!World.Procedural)
		{
			Debug.Log((object)"[Rust.MapCache] Server is not using a procedural map, will not upload to backend");
			return;
		}
		if (World.CanLoadFromUrl())
		{
			Debug.Log((object)"[Rust.MapCache] server.levelurl appears to have already been set, not uploading map to backend");
			return;
		}
		string mapFileName = World.MapFileName;
		string fullPath = Path.GetFullPath(Path.Join((ReadOnlySpan<char>)World.MapFolderName, (ReadOnlySpan<char>)mapFileName));
		if (!File.Exists(fullPath))
		{
			Debug.LogWarning((object)("[Rust.MapCache] Map file was not found: " + fullPath));
			return;
		}
		try
		{
			using FileStream fs = File.OpenRead(fullPath);
			string text = await UploadMapImpl(fs, mapFileName);
			if (text != null)
			{
				OriginalName = World.Name;
				OriginalMapFileName = World.MapFileName;
				OriginalSaveFileName = World.SaveFileName;
				Server.levelurl = text;
				World.Url = text;
				IsUploaded = true;
				Debug.Log((object)("[Rust.MapCache] Map uploaded to backend: " + text));
			}
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"[Rust.MapCache] Failed to upload map to backend: {arg}");
		}
	}

	private static async Task<string> UploadMapImpl(Stream stream, string mapFileName)
	{
		if (stream == null)
		{
			throw new ArgumentNullException("stream");
		}
		if (string.IsNullOrWhiteSpace(mapFileName))
		{
			throw new ArgumentNullException("mapFileName");
		}
		if (!stream.CanRead || !stream.CanSeek)
		{
			throw new ArgumentException("Stream must be readable and seekable.", "stream");
		}
		string requestUri = "https://api.facepunch.com/api/public/rust-map-upload/" + mapFileName;
		for (int i = 0; i < 10; i++)
		{
			try
			{
				stream.Seek(0L, SeekOrigin.Begin);
				using MemoryStream streamCopy = new MemoryStream();
				await stream.CopyToAsync(streamCopy);
				streamCopy.Position = 0L;
				HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Put, requestUri);
				try
				{
					request.Content = (HttpContent)new StreamContent((Stream)streamCopy);
					HttpResponseMessage response = await Http.SendAsync(request);
					try
					{
						if (response.IsSuccessStatusCode)
						{
							string text = await response.Content.ReadAsStringAsync();
							if (string.IsNullOrWhiteSpace(text) || !text.StartsWith("http"))
							{
								throw new Exception("Backend sent an invalid success response when uploading the map.");
							}
							return text;
						}
						int statusCode = (int)response.StatusCode;
						if (statusCode >= 400 && statusCode <= 499)
						{
							Debug.LogError((object)("[Rust.MapCache] Backend refused our map upload request: " + await response.Content.ReadAsStringAsync()));
							return null;
						}
						response.EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)response)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)request)?.Dispose();
				}
			}
			catch (Exception arg)
			{
				Debug.LogWarning((object)$"[Rust.MapCache] Failed to upload map file: {arg}");
				await Task.Delay(1000 + i * 5000);
			}
		}
		Debug.LogError((object)"[Rust.MapCache] Unable to upload map file!");
		return null;
	}

	public static async void UploadMapImage(byte[] image)
	{
		if (IsImageUploaded)
		{
			Debug.Log((object)"[Rust.MapCache-Images] Image was already uploaded!");
			return;
		}
		string mapFileName = World.MapFileName;
		try
		{
			string text = await UploadMapImageImpl(image, mapFileName);
			if (text != null)
			{
				ImageUrl = text;
				IsImageUploaded = true;
				Debug.Log((object)("[Rust.MapCache-Images] Image uploaded to backend: " + text));
			}
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"[Rust.MapCache-Images] Failed to upload image to backend: {arg}");
		}
	}

	private static async Task<string> UploadMapImageImpl(byte[] image, string mapFileName)
	{
		if (image == null)
		{
			throw new ArgumentNullException("image");
		}
		if (string.IsNullOrWhiteSpace(mapFileName))
		{
			throw new ArgumentNullException("mapFileName");
		}
		if (image.Length == 0)
		{
			throw new ArgumentException("Empty image", "image");
		}
		string requestUri = "https://api.facepunch.com/api/public/rust-map-image-upload/" + mapFileName;
		for (int i = 0; i < 10; i++)
		{
			try
			{
				HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Put, requestUri);
				try
				{
					request.Content = (HttpContent)new ByteArrayContent(image);
					request.Content.Headers.ContentType = new MediaTypeHeaderValue("image/jpeg");
					HttpResponseMessage response = await Http.SendAsync(request);
					try
					{
						if (response.IsSuccessStatusCode)
						{
							string text = await response.Content.ReadAsStringAsync();
							if (string.IsNullOrWhiteSpace(text) || !text.StartsWith("http"))
							{
								throw new Exception("Backend sent an invalid success response when uploading the map image");
							}
							return text;
						}
						int statusCode = (int)response.StatusCode;
						if (statusCode >= 400 && statusCode <= 499)
						{
							Debug.LogError((object)("[Rust.MapCache-Images] Backend refused our image upload request: " + await response.Content.ReadAsStringAsync()));
							return null;
						}
						response.EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)response)?.Dispose();
					}
				}
				finally
				{
					((IDisposable)request)?.Dispose();
				}
			}
			catch (Exception arg)
			{
				Debug.LogWarning((object)$"[Rust.MapCache-Images] Failed to upload map file: {arg}");
				await Task.Delay(1000 + i * 5000);
			}
		}
		Debug.LogError((object)"[Rust.MapCache-Images] Unable to upload image!");
		return null;
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using ProtoBuf.Nexus;
using Rust;
using UnityEngine;

public class NexusClanBackend : IClanBackend, IDisposable
{
	private readonly Dictionary<long, NexusClanWrapper> _clanWrappers;

	private IClanChangeSink _changeSink;

	private NexusClanChatCollector _chatCollector;

	private NexusClanEventHandler _eventHandler;

	private NexusZoneClient _client;

	public NexusClanBackend()
	{
		_clanWrappers = new Dictionary<long, NexusClanWrapper>();
	}

	public ValueTask Initialize(IClanChangeSink changeSink)
	{
		if (!NexusServer.Started)
		{
			throw new InvalidOperationException("Cannot use the Nexus clan backend when nexus is not enabled on this server!");
		}
		_clanWrappers.Clear();
		_changeSink = changeSink;
		_chatCollector = new NexusClanChatCollector(changeSink);
		_eventHandler = new NexusClanEventHandler(this, changeSink);
		_client = NexusServer.ZoneClient;
		_client.ClanEventListener = (INexusClanEventListener)(object)_eventHandler;
		((MonoBehaviour)Global.Runner).StartCoroutine(BroadcastClanChatBatches());
		return default(ValueTask);
	}

	public void Dispose()
	{
		_clanWrappers.Clear();
		_changeSink = null;
		_chatCollector = null;
		_eventHandler = null;
		NexusZoneClient client = _client;
		if (((client != null) ? client.ClanEventListener : null) != null)
		{
			_client.ClanEventListener = null;
		}
		_client = null;
	}

	public async ValueTask<ClanValueResult<IClan>> Get(long clanId)
	{
		NexusClanResult<NexusClan> val = await _client.GetClan(clanId);
		NexusClan clan = default(NexusClan);
		if (val.IsSuccess && val.TryGetResponse(ref clan))
		{
			return ClanValueResult<IClan>.op_Implicit((IClan)(object)Wrap(clan));
		}
		return ClanValueResult<IClan>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public bool TryGet(long clanId, out IClan clan)
	{
		NexusClan clan2 = default(NexusClan);
		if (!_client.TryGetClan(clanId, ref clan2))
		{
			clan = null;
			return false;
		}
		clan = (IClan)(object)Wrap(clan2);
		return true;
	}

	public async ValueTask<ClanValueResult<IClan>> GetByMember(ulong steamId)
	{
		NexusClanResult<NexusClan> val = await _client.GetClanByMember(NexusClanUtil.GetPlayerId(steamId));
		NexusClan clan = default(NexusClan);
		if (val.IsSuccess && val.TryGetResponse(ref clan))
		{
			return ClanValueResult<IClan>.op_Implicit((IClan)(object)Wrap(clan));
		}
		return ClanValueResult<IClan>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanValueResult<IClan>> Create(ulong leaderSteamId, string name)
	{
		ClanCreateParameters val = default(ClanCreateParameters);
		((ClanCreateParameters)(ref val)).ClanName = name;
		((ClanCreateParameters)(ref val)).ClanNameNormalized = name.ToLowerInvariant().Normalize(NormalizationForm.FormKC);
		((ClanCreateParameters)(ref val)).LeaderPlayerId = NexusClanUtil.GetPlayerId(leaderSteamId);
		((ClanCreateParameters)(ref val)).LeaderRoleName = "Leader";
		((ClanCreateParameters)(ref val)).LeaderRoleVariables = NexusClanUtil.DefaultLeaderVariables;
		((ClanCreateParameters)(ref val)).MemberRoleName = "Member";
		ClanCreateParameters val2 = val;
		NexusClanResult<NexusClan> val3 = await _client.CreateClan(val2);
		NexusClan clan = default(NexusClan);
		if (val3.IsSuccess && val3.TryGetResponse(ref clan))
		{
			return ClanValueResult<IClan>.op_Implicit((IClan)(object)Wrap(clan));
		}
		return ClanValueResult<IClan>.op_Implicit(val3.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanValueResult<List<ClanInvitation>>> ListInvitations(ulong steamId)
	{
		NexusClanResult<List<ClanInvitation>> val = await _client.ListClanInvitations(NexusClanUtil.GetPlayerId(steamId));
		List<ClanInvitation> source = default(List<ClanInvitation>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			List<ClanInvitation> list = source.Select(delegate(ClanInvitation i)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0037: Unknown result type (might be due to invalid IL or missing references)
				ClanInvitation result = default(ClanInvitation);
				result.ClanId = ((ClanInvitation)(ref i)).ClanId;
				result.Recruiter = NexusClanUtil.GetSteamId(((ClanInvitation)(ref i)).RecruiterPlayerId);
				result.Timestamp = ((ClanInvitation)(ref i)).Timestamp;
				return result;
			}).ToList();
			return new ClanValueResult<List<ClanInvitation>>(list);
		}
		return ClanValueResult<List<ClanInvitation>>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanValueResult<List<ClanLeaderboardEntry>>> GetLeaderboard(int limit = 100)
	{
		NexusClanResult<List<ClanLeaderboardEntry>> val = await _client.GetClanLeaderboard(limit);
		List<ClanLeaderboardEntry> source = default(List<ClanLeaderboardEntry>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			List<ClanLeaderboardEntry> list = source.Select(delegate(ClanLeaderboardEntry c)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0032: Unknown result type (might be due to invalid IL or missing references)
				ClanLeaderboardEntry result = default(ClanLeaderboardEntry);
				result.ClanId = ((ClanLeaderboardEntry)(ref c)).ClanId;
				result.Name = ((ClanLeaderboardEntry)(ref c)).Name;
				result.Score = ((ClanLeaderboardEntry)(ref c)).Score;
				return result;
			}).ToList();
			return new ClanValueResult<List<ClanLeaderboardEntry>>(list);
		}
		return ClanValueResult<List<ClanLeaderboardEntry>>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public void HandleClanChatBatch(ClanChatBatchRequest request)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (_changeSink == null)
		{
			return;
		}
		foreach (Message message in request.messages)
		{
			_changeSink.ClanChatMessage(message.clanId, new ClanChatEntry
			{
				SteamId = message.userId,
				Message = message.text,
				Name = message.name,
				Time = message.timestamp
			});
		}
	}

	private IEnumerator BroadcastClanChatBatches()
	{
		while (_chatCollector != null && NexusServer.Started)
		{
			List<Message> list = Pool.Get<List<Message>>();
			_chatCollector.TakeMessages(list);
			if (list.Count > 0)
			{
				SendClanChatBatch(list);
			}
			else
			{
				Pool.Free<Message>(ref list, false);
			}
			yield return CoroutineEx.waitForSecondsRealtime(Nexus.clanClatBatchDuration);
		}
		static async void SendClanChatBatch(List<Message> messages)
		{
			Request val = Pool.Get<Request>();
			val.isFireAndForget = true;
			val.clanChatBatch = Pool.Get<ClanChatBatchRequest>();
			val.clanChatBatch.messages = messages;
			try
			{
				(await NexusServer.BroadcastRpc(val))?.Dispose();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
	}

	public void UpdateWrapper(long clanId)
	{
		NexusClanWrapper value;
		lock (_clanWrappers)
		{
			if (!_clanWrappers.TryGetValue(clanId, out value))
			{
				return;
			}
		}
		value.UpdateValuesInternal();
	}

	public void RemoveWrapper(long clanId)
	{
		lock (_clanWrappers)
		{
			_clanWrappers.Remove(clanId);
		}
	}

	private NexusClanWrapper Wrap(NexusClan clan)
	{
		lock (_clanWrappers)
		{
			if (_clanWrappers.TryGetValue(clan.ClanId, out var value) && value.Internal == clan)
			{
				return value;
			}
			value = new NexusClanWrapper(clan, _chatCollector);
			_clanWrappers[clan.ClanId] = value;
			return value;
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;

public class NexusClanChatCollector
{
	private readonly IClanChangeSink _external;

	private readonly List<Message> _messagesBuffer;

	public NexusClanChatCollector(IClanChangeSink external)
	{
		_external = external ?? throw new ArgumentNullException("external");
		_messagesBuffer = new List<Message>();
	}

	public void TakeMessages(List<Message> messages)
	{
		foreach (Message item in _messagesBuffer)
		{
			messages.Add(item);
		}
		_messagesBuffer.Clear();
	}

	public void OnClanChatMessage(long clanId, ClanChatEntry entry)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Message val = Pool.Get<Message>();
		val.clanId = clanId;
		val.userId = entry.SteamId;
		val.name = entry.Name;
		val.text = entry.Message;
		val.timestamp = entry.Time;
		_messagesBuffer.Add(val);
		_external.ClanChatMessage(clanId, entry);
	}
}


using System;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;

public class NexusClanEventHandler : INexusClanEventListener
{
	private readonly NexusClanBackend _backend;

	private readonly IClanChangeSink _changeSink;

	public NexusClanEventHandler(NexusClanBackend backend, IClanChangeSink changeSink)
	{
		_backend = backend ?? throw new ArgumentNullException("backend");
		_changeSink = changeSink ?? throw new ArgumentNullException("changeSink");
	}

	public void OnDisbanded(in ClanDisbandedEvent args)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		IClanChangeSink changeSink = _changeSink;
		ClanDisbandedEvent val = args;
		changeSink.ClanDisbanded(((ClanDisbandedEvent)(ref val)).ClanId);
		val = args;
		foreach (string member in ((ClanDisbandedEvent)(ref val)).Members)
		{
			ulong steamId = NexusClanUtil.GetSteamId(member);
			_changeSink.MembershipChanged(steamId, (long?)null);
		}
	}

	public void OnInvitation(in ClanInvitedEvent args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ClanInvitedEvent val = args;
		ulong steamId = NexusClanUtil.GetSteamId(((ClanInvitedEvent)(ref val)).PlayerId);
		IClanChangeSink changeSink = _changeSink;
		val = args;
		changeSink.InvitationCreated(steamId, ((ClanInvitedEvent)(ref val)).ClanId);
	}

	public void OnJoined(in ClanJoinedEvent args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ClanJoinedEvent val = args;
		ulong steamId = NexusClanUtil.GetSteamId(((ClanJoinedEvent)(ref val)).PlayerId);
		IClanChangeSink changeSink = _changeSink;
		val = args;
		changeSink.MembershipChanged(steamId, (long?)((ClanJoinedEvent)(ref val)).ClanId);
	}

	public void OnKicked(in ClanKickedEvent args)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		ClanKickedEvent val = args;
		ulong steamId = NexusClanUtil.GetSteamId(((ClanKickedEvent)(ref val)).PlayerId);
		_changeSink.MembershipChanged(steamId, (long?)null);
	}

	public void OnChanged(in ClanChangedEvent args)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		NexusClanBackend backend = _backend;
		ClanChangedEvent val = args;
		backend.UpdateWrapper(((ClanChangedEvent)(ref val)).ClanId);
		IClanChangeSink changeSink = _changeSink;
		val = args;
		changeSink.ClanChanged(((ClanChangedEvent)(ref val)).ClanId, (ClanDataSource)(-1));
	}

	public void OnUnload(in long clanId)
	{
		_backend.RemoveWrapper(clanId);
	}

	void INexusClanEventListener.OnDisbanded(in ClanDisbandedEvent args)
	{
		OnDisbanded(in args);
	}

	void INexusClanEventListener.OnInvitation(in ClanInvitedEvent args)
	{
		OnInvitation(in args);
	}

	void INexusClanEventListener.OnJoined(in ClanJoinedEvent args)
	{
		OnJoined(in args);
	}

	void INexusClanEventListener.OnKicked(in ClanKickedEvent args)
	{
		OnKicked(in args);
	}

	void INexusClanEventListener.OnChanged(in ClanChangedEvent args)
	{
		OnChanged(in args);
	}

	void INexusClanEventListener.OnUnload(in long clanId)
	{
		OnUnload(in clanId);
	}
}


using System;
using System.Collections.Generic;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using UnityEngine;

public static class NexusClanUtil
{
	public const string MotdVariable = "motd";

	public const string MotdAuthorVariable = "motd_author";

	public const string LogoVariable = "logo";

	public const string ColorVariable = "color";

	public const string CanSetLogoVariable = "can_set_logo";

	public const string CanSetMotdVariable = "can_set_motd";

	public const string CanSetPlayerNotesVariable = "can_set_player_notes";

	public const string PlayerNoteVariable = "notes";

	public static readonly List<VariableUpdate> DefaultLeaderVariables = new List<VariableUpdate>
	{
		new VariableUpdate("can_set_logo", bool.TrueString, (bool?)null, (bool?)null),
		new VariableUpdate("can_set_motd", bool.TrueString, (bool?)null, (bool?)null),
		new VariableUpdate("can_set_player_notes", bool.TrueString, (bool?)null, (bool?)null)
	};

	private static readonly Memoized<string, ulong> SteamIdToPlayerId = new Memoized<string, ulong>((Func<ulong, string>)((ulong steamId) => steamId.ToString("G")));

	public static string GetPlayerId(ulong steamId)
	{
		return SteamIdToPlayerId.Get(steamId);
	}

	public static string GetPlayerId(ulong? steamId)
	{
		if (!steamId.HasValue)
		{
			return null;
		}
		return SteamIdToPlayerId.Get(steamId.Value);
	}

	public static ulong GetSteamId(string playerId)
	{
		return ulong.Parse(playerId);
	}

	public static ulong? TryGetSteamId(string playerId)
	{
		if (!ulong.TryParse(playerId, out var result))
		{
			return null;
		}
		return result;
	}

	public static void GetMotd(this NexusClan clan, out string motd, out long motdTimestamp, out ulong motdAuthor)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Invalid comparison between Unknown and I4
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Invalid comparison between Unknown and I4
		Variable val = default(Variable);
		Variable val2 = default(Variable);
		if (!clan.TryGetVariable("motd", ref val) || !clan.TryGetVariable("motd_author", ref val2) || (int)val.Type != 1 || (int)val2.Type != 1)
		{
			motd = null;
			motdTimestamp = 0L;
			motdAuthor = 0uL;
		}
		else
		{
			motd = val.GetAsString();
			motdTimestamp = val.LastUpdated * 1000;
			motdAuthor = GetSteamId(val2.GetAsString());
		}
	}

	public static void GetBanner(this NexusClan clan, out byte[] logo, out Color32 color)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Invalid comparison between Unknown and I4
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Variable val = default(Variable);
		logo = ((clan.TryGetVariable("logo", ref val) && (int)val.Type == 0) ? val.GetAsBinary() : null);
		Variable val2 = default(Variable);
		color = ((clan.TryGetVariable("color", ref val2) && (int)val2.Type == 1) ? ColorEx.FromInt32(int.Parse(val2.GetAsString())) : Color32.op_Implicit(Color.white));
	}

	public static ClanRole ToClanRole(this NexusClanRole role)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = role.Rank == 1;
		ClanRole result = default(ClanRole);
		result.RoleId = role.RoleId;
		result.Rank = role.Rank;
		result.Name = role.Name;
		result.CanInvite = flag || role.CanInvite;
		result.CanKick = flag || role.CanKick;
		result.CanPromote = flag || role.CanPromote;
		result.CanDemote = flag || role.CanDemote;
		Variable variable = default(Variable);
		result.CanSetLogo = flag || (role.TryGetVariable("can_set_logo", ref variable) && ParseFlag(variable));
		Variable variable2 = default(Variable);
		result.CanSetMotd = flag || (role.TryGetVariable("can_set_motd", ref variable2) && ParseFlag(variable2));
		Variable variable3 = default(Variable);
		result.CanSetPlayerNotes = flag || (role.TryGetVariable("can_set_player_notes", ref variable3) && ParseFlag(variable3));
		result.CanAccessLogs = flag || role.CanAccessLogs;
		result.CanAccessScoreEvents = flag || role.CanAccessScoreEvents;
		return result;
	}

	public static ClanMember ToClanMember(this NexusClanMember member)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		Variable val = default(Variable);
		member.TryGetVariable("notes", ref val);
		ClanMember result = default(ClanMember);
		result.SteamId = GetSteamId(member.PlayerId);
		result.RoleId = member.RoleId;
		result.Joined = member.Joined * 1000;
		result.LastSeen = member.LastSeen * 1000;
		result.Notes = ((val != null) ? val.GetAsString() : null);
		result.NotesTimestamp = ((val != null) ? val.LastUpdated : 0);
		return result;
	}

	public static ClanInvite ToClanInvite(this ClanInvite invite)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		ClanInvite result = default(ClanInvite);
		result.SteamId = GetSteamId(((ClanInvite)(ref invite)).PlayerId);
		result.Recruiter = GetSteamId(((ClanInvite)(ref invite)).RecruiterPlayerId);
		result.Timestamp = ((ClanInvite)(ref invite)).Created * 1000;
		return result;
	}

	public static ClanResult ToClanResult(this NexusClanResultCode result)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected I4, but got Unknown
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		return (ClanResult)((int)result switch
		{
			0 => 0, 
			1 => 1, 
			2 => 3, 
			3 => 4, 
			4 => 5, 
			5 => 9, 
			6 => 10, 
			7 => 11, 
			8 => 12, 
			9 => 13, 
			10 => 14, 
			11 => 15, 
			_ => throw new NotSupportedException($"Cannot map NexusClanResultCode {result} to ClanResult"), 
		});
	}

	public static ClanRoleParameters ToRoleParameters(this ClanRole role)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		ClanRoleParameters result = default(ClanRoleParameters);
		((ClanRoleParameters)(ref result)).Name = role.Name;
		((ClanRoleParameters)(ref result)).CanInvite = role.CanInvite;
		((ClanRoleParameters)(ref result)).CanKick = role.CanKick;
		((ClanRoleParameters)(ref result)).CanPromote = role.CanPromote;
		((ClanRoleParameters)(ref result)).CanDemote = role.CanDemote;
		((ClanRoleParameters)(ref result)).CanAccessLogs = role.CanAccessLogs;
		((ClanRoleParameters)(ref result)).CanAccessScoreEvents = role.CanAccessScoreEvents;
		((ClanRoleParameters)(ref result)).Variables = new List<VariableUpdate>(3)
		{
			FlagVariable("can_set_logo", role.CanSetLogo),
			FlagVariable("can_set_motd", role.CanSetMotd),
			FlagVariable("can_set_player_notes", role.CanSetPlayerNotes)
		};
		return result;
	}

	public static VariableUpdate FlagVariable(string key, bool value)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return new VariableUpdate(key, value ? bool.TrueString : bool.FalseString, (bool?)null, (bool?)null);
	}

	private static bool ParseFlag(Variable variable, bool defaultValue = false)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		if (variable == null || (int)variable.Type != 1 || !bool.TryParse(variable.GetAsString(), out var result))
		{
			return false;
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Facepunch.Extend;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using UnityEngine;

public class NexusClanWrapper : IClan
{
	private const int MaxChatScrollback = 20;

	public readonly NexusClan Internal;

	private readonly NexusClanChatCollector _chatCollector;

	private readonly List<ClanRole> _roles;

	private readonly List<ClanMember> _members;

	private readonly List<ClanInvite> _invites;

	private readonly List<ClanChatEntry> _chatHistory;

	private RealTimeSince _sinceLastRefresh;

	public long ClanId => Internal.ClanId;

	public string Name => Internal.Name;

	public long Created => Internal.Created;

	public ulong Creator => NexusClanUtil.GetSteamId(Internal.Creator);

	public string Motd { get; private set; }

	public long MotdTimestamp { get; private set; }

	public ulong MotdAuthor { get; private set; }

	public byte[] Logo { get; private set; }

	public Color32 Color { get; private set; }

	public long Score => Internal.Score;

	public IReadOnlyList<ClanRole> Roles => _roles;

	public IReadOnlyList<ClanMember> Members => _members;

	public int MaxMemberCount { get; private set; }

	public IReadOnlyList<ClanInvite> Invites => _invites;

	public NexusClanWrapper(NexusClan clan, NexusClanChatCollector chatCollector)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		Internal = clan ?? throw new ArgumentNullException("clan");
		_chatCollector = chatCollector ?? throw new ArgumentNullException("chatCollector");
		_roles = new List<ClanRole>();
		_members = new List<ClanMember>();
		_invites = new List<ClanInvite>();
		_chatHistory = new List<ClanChatEntry>(20);
		_sinceLastRefresh = RealTimeSince.op_Implicit(0f);
		UpdateValuesInternal();
	}

	public void UpdateValuesInternal()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		Internal.GetMotd(out var motd, out var motdTimestamp, out var motdAuthor);
		Motd = motd;
		MotdTimestamp = motdTimestamp;
		MotdAuthor = motdAuthor;
		Internal.GetBanner(out var logo, out var color);
		Logo = logo;
		Color = color;
		List.Resize<ClanRole>(_roles, Internal.Roles.Count);
		for (int i = 0; i < _roles.Count; i++)
		{
			_roles[i] = Internal.Roles[i].ToClanRole();
		}
		List.Resize<ClanMember>(_members, Internal.Members.Count);
		for (int j = 0; j < _members.Count; j++)
		{
			_members[j] = Internal.Members[j].ToClanMember();
		}
		MaxMemberCount = Internal.MaxMemberCount;
		List.Resize<ClanInvite>(_invites, Internal.Invites.Count);
		for (int k = 0; k < _invites.Count; k++)
		{
			_invites[k] = Internal.Invites[k].ToClanInvite();
		}
	}

	public async ValueTask RefreshIfStale()
	{
		if (RealTimeSince.op_Implicit(_sinceLastRefresh) > 30f)
		{
			_sinceLastRefresh = RealTimeSince.op_Implicit(0f);
			try
			{
				await Internal.Refresh();
				UpdateValuesInternal();
			}
			catch (Exception ex)
			{
				Debug.LogError((object)$"Failed to refresh nexus clan ID {ClanId}");
				Debug.LogException(ex);
			}
		}
	}

	public async ValueTask<ClanValueResult<ClanLogs>> GetLogs(int limit, ulong bySteamId)
	{
		NexusClanResult<List<ClanLogEntry>> val = await Internal.GetLogs(NexusClanUtil.GetPlayerId(bySteamId), limit);
		List<ClanLogEntry> source = default(List<ClanLogEntry>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			ClanLogs val2 = default(ClanLogs);
			val2.ClanId = ClanId;
			val2.Entries = source.Select(delegate(ClanLogEntry e)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				ClanLogEntry result = default(ClanLogEntry);
				result.Timestamp = ((ClanLogEntry)(ref e)).Timestamp * 1000;
				result.EventKey = ((ClanLogEntry)(ref e)).EventKey;
				result.Arg1 = ((ClanLogEntry)(ref e)).Arg1;
				result.Arg2 = ((ClanLogEntry)(ref e)).Arg2;
				result.Arg3 = ((ClanLogEntry)(ref e)).Arg3;
				result.Arg4 = ((ClanLogEntry)(ref e)).Arg4;
				return result;
			}).ToList();
			return ClanValueResult<ClanLogs>.op_Implicit(val2);
		}
		return ClanValueResult<ClanLogs>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public async ValueTask<ClanResult> UpdateLastSeen(ulong steamId)
	{
		return (await Internal.UpdateLastSeen(NexusClanUtil.GetPlayerId(steamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SetMotd(string newMotd, ulong bySteamId)
	{
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetMotd))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(2)
		{
			new VariableUpdate("motd", newMotd, (bool?)null, (bool?)null),
			new VariableUpdate("motd_author", playerId, (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_motd";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId;
		((ClanVariablesUpdate)(ref val)).Arg2 = newMotd;
		return (await @internal.UpdateVariables(val)).ToClanResult();
	}

	public async ValueTask<ClanResult> SetLogo(byte[] newLogo, ulong bySteamId)
	{
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetLogo))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(1)
		{
			new VariableUpdate("logo", (Memory<byte>)newLogo, (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_logo";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId;
		return (await @internal.UpdateVariables(val)).ToClanResult();
	}

	public async ValueTask<ClanResult> SetColor(Color32 newColor, ulong bySteamId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetLogo))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(1)
		{
			new VariableUpdate("color", ColorEx.ToInt32(newColor).ToString("G"), (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_color";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId;
		((ClanVariablesUpdate)(ref val)).Arg2 = ColorEx.ToHex(newColor);
		return (await @internal.UpdateVariables(val)).ToClanResult();
	}

	public async ValueTask<ClanResult> Invite(ulong steamId, ulong bySteamId)
	{
		return (await Internal.Invite(NexusClanUtil.GetPlayerId(steamId), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> CancelInvite(ulong steamId, ulong bySteamId)
	{
		return (await Internal.CancelInvite(NexusClanUtil.GetPlayerId(steamId), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> AcceptInvite(ulong steamId)
	{
		return (await Internal.AcceptInvite(NexusClanUtil.GetPlayerId(steamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> Kick(ulong steamId, ulong bySteamId)
	{
		return (await Internal.Kick(NexusClanUtil.GetPlayerId(steamId), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SetPlayerRole(ulong steamId, int newRoleId, ulong bySteamId)
	{
		return (await Internal.SetPlayerRole(NexusClanUtil.GetPlayerId(steamId), newRoleId, NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SetPlayerNotes(ulong steamId, string notes, ulong bySteamId)
	{
		if (!CheckRole(bySteamId, (ClanRole r) => r.CanSetPlayerNotes))
		{
			return (ClanResult)5;
		}
		string playerId = NexusClanUtil.GetPlayerId(steamId);
		string playerId2 = NexusClanUtil.GetPlayerId(bySteamId);
		NexusClan @internal = Internal;
		ClanVariablesUpdate val = default(ClanVariablesUpdate);
		((ClanVariablesUpdate)(ref val)).Variables = new List<VariableUpdate>(1)
		{
			new VariableUpdate("notes", notes, (bool?)null, (bool?)null)
		};
		((ClanVariablesUpdate)(ref val)).EventKey = "set_notes";
		((ClanVariablesUpdate)(ref val)).Arg1 = playerId2;
		((ClanVariablesUpdate)(ref val)).Arg2 = playerId;
		((ClanVariablesUpdate)(ref val)).Arg3 = notes;
		return (await @internal.UpdatePlayerVariables(playerId, val)).ToClanResult();
	}

	public async ValueTask<ClanResult> CreateRole(ClanRole role, ulong bySteamId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return (await Internal.CreateRole(role.ToRoleParameters(), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> UpdateRole(ClanRole role, ulong bySteamId)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		return (await Internal.UpdateRole(role.RoleId, role.ToRoleParameters(), NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> SwapRoleRanks(int roleIdA, int roleIdB, ulong bySteamId)
	{
		return (await Internal.SwapRoleRanks(roleIdA, roleIdB, NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> DeleteRole(int roleId, ulong bySteamId)
	{
		return (await Internal.DeleteRole(roleId, NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanResult> Disband(ulong bySteamId)
	{
		return (await Internal.Disband(NexusClanUtil.GetPlayerId(bySteamId))).ToClanResult();
	}

	public async ValueTask<ClanValueResult<ClanScoreEvents>> GetScoreEvents(int limit, ulong bySteamId)
	{
		NexusClanResult<List<ClanScoreEventEntry>> val = await Internal.GetScoreEvents(NexusClanUtil.GetPlayerId(bySteamId), limit);
		List<ClanScoreEventEntry> source = default(List<ClanScoreEventEntry>);
		if (val.IsSuccess && val.TryGetResponse(ref source))
		{
			ClanScoreEvents val2 = default(ClanScoreEvents);
			val2.ClanId = ClanId;
			val2.ScoreEvents = source.Select(delegate(ClanScoreEventEntry e)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_0097: Unknown result type (might be due to invalid IL or missing references)
				ClanScoreEvent result = default(ClanScoreEvent);
				result.Timestamp = ((ClanScoreEventEntry)(ref e)).Timestamp * 1000;
				result.Type = (ClanScoreEventType)((ClanScoreEventEntry)(ref e)).Type;
				result.Score = ((ClanScoreEventEntry)(ref e)).Score;
				result.Multiplier = ((ClanScoreEventEntry)(ref e)).Multiplier;
				result.SteamId = NexusClanUtil.TryGetSteamId(((ClanScoreEventEntry)(ref e)).PlayerId);
				result.OtherSteamId = NexusClanUtil.TryGetSteamId(((ClanScoreEventEntry)(ref e)).OtherPlayerId);
				result.OtherClanId = ((ClanScoreEventEntry)(ref e)).OtherClanId;
				result.Arg1 = ((ClanScoreEventEntry)(ref e)).Arg1;
				result.Arg2 = ((ClanScoreEventEntry)(ref e)).Arg2;
				return result;
			}).ToList();
			return ClanValueResult<ClanScoreEvents>.op_Implicit(val2);
		}
		return ClanValueResult<ClanScoreEvents>.op_Implicit(val.ResultCode.ToClanResult());
	}

	public ValueTask<ClanResult> AddScoreEvent(ClanScoreEvent scoreEvent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected I4, but got Unknown
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		NexusClan @internal = Internal;
		NewClanScoreEventEntry val = default(NewClanScoreEventEntry);
		((NewClanScoreEventEntry)(ref val)).Type = (int)scoreEvent.Type;
		((NewClanScoreEventEntry)(ref val)).Score = scoreEvent.Score;
		((NewClanScoreEventEntry)(ref val)).Multiplier = scoreEvent.Multiplier;
		((NewClanScoreEventEntry)(ref val)).PlayerId = NexusClanUtil.GetPlayerId(scoreEvent.SteamId);
		((NewClanScoreEventEntry)(ref val)).OtherPlayerId = NexusClanUtil.GetPlayerId(scoreEvent.OtherSteamId);
		((NewClanScoreEventEntry)(ref val)).OtherClanId = scoreEvent.OtherClanId;
		((NewClanScoreEventEntry)(ref val)).Arg1 = scoreEvent.Arg1;
		((NewClanScoreEventEntry)(ref val)).Arg2 = scoreEvent.Arg2;
		@internal.AddScoreEvent(val);
		return new ValueTask<ClanResult>((ClanResult)1);
	}

	public ValueTask<ClanValueResult<ClanChatScrollback>> GetChatScrollback()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatHistory)
		{
			ClanChatScrollback val = default(ClanChatScrollback);
			val.ClanId = ClanId;
			val.Entries = _chatHistory.ToList();
			return new ValueTask<ClanValueResult<ClanChatScrollback>>(ClanValueResult<ClanChatScrollback>.op_Implicit(val));
		}
	}

	public ValueTask<ClanResult> SendChatMessage(string name, string message, ulong bySteamId)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		if (!List.TryFindWith<ClanMember, ulong>((IReadOnlyCollection<ClanMember>)_members, (Func<ClanMember, ulong>)((ClanMember m) => m.SteamId), bySteamId, (IEqualityComparer<ulong>)null).HasValue)
		{
			return new ValueTask<ClanResult>((ClanResult)0);
		}
		string message2 = default(string);
		if (!ClanValidator.ValidateChatMessage(message, ref message2))
		{
			return new ValueTask<ClanResult>((ClanResult)6);
		}
		ClanChatEntry val = default(ClanChatEntry);
		val.SteamId = bySteamId;
		val.Name = name;
		val.Message = message2;
		val.Time = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
		ClanChatEntry entry = val;
		AddScrollback(in entry);
		_chatCollector.OnClanChatMessage(ClanId, entry);
		return new ValueTask<ClanResult>((ClanResult)1);
	}

	public void AddScrollback(in ClanChatEntry entry)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		lock (_chatHistory)
		{
			if (_chatHistory.Count >= 20)
			{
				_chatHistory.RemoveAt(0);
			}
			_chatHistory.Add(entry);
		}
	}

	private bool CheckRole(ulong steamId, Func<ClanRole, bool> roleTest)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		ClanMember? val = List.TryFindWith<ClanMember, ulong>((IReadOnlyCollection<ClanMember>)_members, (Func<ClanMember, ulong>)((ClanMember m) => m.SteamId), steamId, (IEqualityComparer<ulong>)null);
		if (!val.HasValue)
		{
			return false;
		}
		ClanRole? val2 = List.TryFindWith<ClanRole, int>((IReadOnlyCollection<ClanRole>)_roles, (Func<ClanRole, int>)((ClanRole r) => r.RoleId), val.Value.RoleId, (IEqualityComparer<int>)null);
		if (!val2.HasValue)
		{
			return false;
		}
		if (val2.Value.Rank != 1)
		{
			return roleTest(val2.Value);
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using UnityEngine;

public class BasicZoneController : ZoneController
{
	public BasicZoneController(NexusZoneClient zoneClient)
		: base(zoneClient)
	{
	}

	public override string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone)
	{
		if (ZoneClient.Zone.IsStarterZone())
		{
			return ZoneClient.Zone.Key;
		}
		string key = ZoneClient.Zone.Key;
		List<NexusZoneDetails> list = Pool.Get<List<NexusZoneDetails>>();
		GetStarterZones(list);
		if (list.Count > 0)
		{
			int index = Random.Range(0, list.Count);
			key = list[index].Key;
		}
		Pool.FreeUnmanaged<NexusZoneDetails>(ref list);
		return key;
	}

	private void GetStarterZones(List<NexusZoneDetails> zones)
	{
		NexusZoneClient zoneClient = ZoneClient;
		object obj;
		if (zoneClient == null)
		{
			obj = null;
		}
		else
		{
			NexusDetails nexus = zoneClient.Nexus;
			obj = ((nexus != null) ? nexus.Zones : null);
		}
		if (obj == null)
		{
			return;
		}
		foreach (NexusZoneDetails zone in ZoneClient.Nexus.Zones)
		{
			if (zone.IsStarterZone())
			{
				zones.Add(zone);
			}
		}
	}
}


using UnityEngine;

public class NexusCleanupOnShutdown : MonoBehaviour
{
	public void OnDestroy()
	{
		NexusServer.Shutdown();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Sqlite;

public class NexusDB : Database
{
	public int JournalCount { get; private set; }

	public DateTimeOffset? OldestJournal { get; private set; }

	public int TransferredCount { get; private set; }

	public void Initialize()
	{
		if (!((Database)this).TableExists("seen"))
		{
			((Database)this).Execute("CREATE TABLE seen (id BLOB PRIMARY KEY)");
		}
		if (!((Database)this).TableExists("journal"))
		{
			((Database)this).Execute("CREATE TABLE journal (id BLOB PRIMARY KEY, time INTEGER, data BLOB)");
		}
		else
		{
			JournalCount = ((Database)this).Query<int>("SELECT COUNT(*) FROM journal");
			if (JournalCount > 0)
			{
				long seconds = ((Database)this).Query<long>("SELECT MIN(time) FROM journal");
				OldestJournal = DateTimeOffset.FromUnixTimeSeconds(seconds);
			}
			else
			{
				OldestJournal = null;
			}
		}
		if (!((Database)this).TableExists("transferred"))
		{
			((Database)this).Execute("CREATE TABLE transferred (id INTEGER PRIMARY KEY)");
		}
		else
		{
			TransferredCount = ((Database)this).Query<int>("SELECT COUNT(*) FROM transferred");
		}
	}

	public bool Seen(Guid id)
	{
		((Database)this).Execute<Guid>("INSERT INTO seen(id) VALUES(?) ON CONFLICT DO NOTHING", id);
		return ((Database)this).AffectedRows > 0;
	}

	public bool SeenJournaled(Guid id, byte[] data)
	{
		long num = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
		((Database)this).BeginTransaction();
		try
		{
			((Database)this).Execute<Guid>("INSERT INTO seen(id) VALUES(?) ON CONFLICT DO NOTHING", id);
			if (((Database)this).AffectedRows <= 0)
			{
				((Database)this).Commit();
				return false;
			}
			((Database)this).Execute<Guid, long, byte[]>("INSERT INTO journal(id, time, data) VALUES(?, ?, ?)", id, num, data);
			JournalCount++;
			if (!OldestJournal.HasValue)
			{
				OldestJournal = DateTimeOffset.UtcNow;
			}
			((Database)this).Commit();
			return true;
		}
		catch
		{
			((Database)this).Rollback();
			throw;
		}
	}

	public List<(Guid Id, long Time, byte[] Data)> ReadJournal()
	{
		IntPtr intPtr = ((Database)this).Prepare("SELECT id, time, data FROM journal ORDER BY time ASC");
		return ((Database)this).ExecuteAndReadQueryResults<(Guid, long, byte[])>(intPtr, (Func<IntPtr, (Guid, long, byte[])>)ReadJournalRow).ToList();
	}

	private static (Guid, long, byte[]) ReadJournalRow(IntPtr stmHandle)
	{
		Guid columnValue = Database.GetColumnValue<Guid>(stmHandle, 0);
		long columnValue2 = Database.GetColumnValue<long>(stmHandle, 1);
		byte[] columnValue3 = Database.GetColumnValue<byte[]>(stmHandle, 2);
		return (columnValue, columnValue2, columnValue3);
	}

	public void ClearJournal()
	{
		((Database)this).Execute("DELETE FROM journal");
		JournalCount = 0;
		OldestJournal = null;
	}

	public void MarkTransferred(HashSet<NetworkableId> entityIds)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		if (entityIds == null || entityIds.Count == 0)
		{
			return;
		}
		IntPtr intPtr = ((Database)this).Prepare("INSERT INTO transferred(id) VALUES(?) ON CONFLICT DO NOTHING");
		try
		{
			((Database)this).BeginTransaction();
			try
			{
				foreach (NetworkableId entityId in entityIds)
				{
					Database.Bind<ulong>(intPtr, 1, entityId.Value);
					((Database)this).ExecuteQuery(intPtr);
				}
				((Database)this).Commit();
				TransferredCount += entityIds.Count;
			}
			catch
			{
				((Database)this).Rollback();
				throw;
			}
		}
		finally
		{
			((Database)this).Complete(intPtr);
		}
	}

	public List<NetworkableId> ReadTransferred()
	{
		IntPtr intPtr = ((Database)this).Prepare("SELECT id FROM transferred");
		return ((Database)this).ExecuteAndReadQueryResults<NetworkableId>(intPtr, (Func<IntPtr, NetworkableId>)((IntPtr h) => new NetworkableId((ulong)Database.GetColumnValue<uint>(h, 0)))).ToList();
	}

	public void ClearTransferred()
	{
		((Database)this).Execute("DELETE FROM transferred");
		TransferredCount = 0;
	}
}


using Facepunch.Nexus.Models;
using UnityEngine;

public static class NexusExtensions
{
	public static Vector2 Position(this ZoneDetails zone)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)zone.PositionX, (float)zone.PositionY);
	}

	public static Vector2 Position(this NexusZoneDetails zone)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2((float)zone.PositionX, (float)zone.PositionY);
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;

public class NexusRpcResult : IDisposable, IPooled
{
	public readonly Dictionary<string, Response> Responses;

	public NexusRpcResult()
	{
		Responses = new Dictionary<string, Response>(StringComparer.InvariantCultureIgnoreCase);
	}

	public void Dispose()
	{
		NexusRpcResult nexusRpcResult = this;
		Pool.Free<NexusRpcResult>(ref nexusRpcResult);
	}

	public void EnterPool()
	{
		foreach (KeyValuePair<string, Response> response in Responses)
		{
			response.Value.Dispose();
		}
		Responses.Clear();
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Nexus;
using Facepunch.Nexus.Logging;
using Facepunch.Nexus.Models;
using Facepunch.Sqlite;
using Network;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class NexusServer
{
	private struct ZonePlayerManifest
	{
		public RealTimeSince Received;

		public List<ulong> UserIds;
	}

	private struct PendingCall
	{
		public bool IsBroadcast;

		public RealTimeUntil TimeUntilTimeout;

		public TaskCompletionSource<bool> Completion;

		public NexusRpcResult Result;
	}

	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static NexusErrorHandler <>9__26_0;

		public static Func<NexusZoneDetails, string> <>9__29_0;

		public static Comparison<(string Zone, FerryStatus Status)> <>9__45_1;

		public static Func<NexusZoneDetails, string> <>9__50_0;

		public static Func<NexusZoneDetails, int> <>9__63_0;

		public static Func<NexusZoneDetails, string> <>9__85_0;

		public static Func<NexusZoneDetails, string> <>9__96_1;

		public static Func<NexusZoneDetails, string> <>9__103_0;

		internal void <Initialize>b__26_0(BaseNexusClient _, Exception ex)
		{
			Debug.LogException(ex);
		}

		internal string <FindZone>b__29_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal int <UpdateFerryStatuses>b__45_1((string Zone, FerryStatus Status) a, (string Zone, FerryStatus Status) b)
		{
			return a.Status.timestamp.CompareTo(b.Status.timestamp);
		}

		internal string <TryGetIslandPosition>b__50_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal int <HandleMessage>b__63_0(NexusZoneDetails z)
		{
			return z.Id;
		}

		internal string <ZoneRpc>b__85_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal string <RefreshZoneStatus>b__96_1(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal string <TransferEntityImpl>b__103_0(NexusZoneDetails z)
		{
			return z.Key;
		}

		internal string <.cctor>b__113_0(ulong i)
		{
			return i.ToString("G");
		}
	}

	private static bool _isRefreshingCompanion;

	private static RealTimeSince _lastCompanionRefresh;

	private static readonly Memoized<string, ulong> SteamIdToString = new Memoized<string, ulong>((Func<ulong, string>)((ulong i) => i.ToString("G")));

	private static readonly MemoryStream WriterStream = new MemoryStream();

	private static NexusDB _database;

	private static readonly Dictionary<string, List<(string Zone, FerryStatus Status)>> FerryEntries = new Dictionary<string, List<(string, FerryStatus)>>(StringComparer.InvariantCultureIgnoreCase);

	private static bool _updatingFerries;

	private static int _cyclesWithoutFerry;

	private static float _zoneContactRadius;

	private static Dictionary<string, NexusIsland> _existingIslands;

	private const int MapRenderVersion = 5;

	private static readonly HashSet<ulong> PlayerManifest = new HashSet<ulong>();

	private static readonly Dictionary<string, ZonePlayerManifest> ZonePlayerManifests = new Dictionary<string, ZonePlayerManifest>(StringComparer.InvariantCultureIgnoreCase);

	private static RealTimeSince _lastPlayerManifestBroadcast;

	private static bool _playerManifestDirty;

	private static RealTimeSince _lastPlayerManifestRebuild;

	private static readonly Dictionary<Uuid, PendingCall> PendingCalls = new Dictionary<Uuid, PendingCall>();

	private static RealTimeSince _sinceLastRpcTimeoutCheck = RealTimeSince.op_Implicit(0f);

	private static readonly Dictionary<string, ServerStatus> ZoneStatuses = new Dictionary<string, ServerStatus>(StringComparer.InvariantCultureIgnoreCase);

	private static bool _isRefreshingZoneStatus;

	private static RealTimeSince _lastZoneStatusRefresh;

	private static DateTimeOffset? _lastUnsavedTransfer;

	private const string CopyFromKey = "$copyFrom";

	public static NexusZoneClient ZoneClient { get; private set; }

	public static bool Started { get; private set; }

	public static bool FailedToStart { get; private set; }

	public static int? NexusId
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			ZoneDetails zone = zoneClient.Zone;
			if (zone == null)
			{
				return null;
			}
			return zone.NexusId;
		}
	}

	public static string ZoneKey
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			ZoneDetails zone = zoneClient.Zone;
			if (zone == null)
			{
				return null;
			}
			return zone.Key;
		}
	}

	public static long? LastReset
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			NexusDetails nexus = zoneClient.Nexus;
			if (nexus == null)
			{
				return null;
			}
			return nexus.LastReset;
		}
	}

	public static List<NexusZoneDetails> Zones
	{
		get
		{
			NexusZoneClient zoneClient = ZoneClient;
			if (zoneClient == null)
			{
				return null;
			}
			NexusDetails nexus = zoneClient.Nexus;
			if (nexus == null)
			{
				return null;
			}
			return nexus.Zones;
		}
	}

	public static bool NeedsJournalFlush
	{
		get
		{
			if (Started && _database.OldestJournal.HasValue)
			{
				return (DateTimeOffset.UtcNow - _database.OldestJournal.Value).TotalSeconds >= (double)Nexus.transferFlushTime;
			}
			return false;
		}
	}

	private static int RpcResponseTtl => Nexus.messageLockDuration * 4;

	public static bool NeedTransferFlush
	{
		get
		{
			if (Started && _lastUnsavedTransfer.HasValue)
			{
				return (DateTimeOffset.UtcNow - _lastUnsavedTransfer.Value).TotalSeconds >= (double)Nexus.transferFlushTime;
			}
			return false;
		}
	}

	private static void RefreshCompanionVariables()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (!_isRefreshingCompanion && !(RealTimeSince.op_Implicit(_lastCompanionRefresh) < 60f))
		{
			RefreshCompanionVariablesImpl();
		}
		static async void RefreshCompanionVariablesImpl()
		{
			_ = 3;
			try
			{
				_isRefreshingCompanion = true;
				_lastCompanionRefresh = RealTimeSince.op_Implicit(0f);
				await ZoneClient.SetZoneVariable("protocol", Net.sv.ProtocolId, false, false);
				if (CompanionServer.Server.IsEnabled)
				{
					string text = await App.GetPublicIPAsync();
					string appPort = App.port.ToString("G", CultureInfo.InvariantCulture);
					await ZoneClient.SetZoneVariable("appIp", text ?? "", false, false);
					await ZoneClient.SetZoneVariable("appPort", appPort, false, false);
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)"Failed to set up Rust companion nexus zone variables");
				Debug.LogException(ex);
			}
			finally
			{
				_isRefreshingCompanion = false;
			}
		}
	}

	public static IEnumerator Initialize()
	{
		if (Started)
		{
			Debug.LogError((object)"NexusServer was already started");
			yield break;
		}
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient != null)
		{
			((BaseNexusClient)zoneClient).Dispose();
		}
		ZoneClient = null;
		NexusDB database = _database;
		if (database != null)
		{
			((Database)database).Close();
		}
		_database = null;
		ZoneController.Instance = null;
		Started = false;
		FailedToStart = true;
		if (string.IsNullOrWhiteSpace(Nexus.endpoint) || !Nexus.endpoint.StartsWith("http") || string.IsNullOrWhiteSpace(Nexus.secretKey))
		{
			Debug.Log((object)"Nexus endpoint and/or secret key is not set, not starting nexus connection");
			FailedToStart = false;
			yield break;
		}
		GameObject val = new GameObject("NexusCleanupOnShutdown");
		val.AddComponent<NexusCleanupOnShutdown>();
		Object.DontDestroyOnLoad((Object)val);
		try
		{
			_database = new NexusDB();
			((Database)_database).Open($"{ConVar.Server.rootFolder}/nexus.{271}.db", true);
			_database.Initialize();
		}
		catch (Exception ex2)
		{
			Debug.LogException(ex2);
			yield break;
		}
		ZoneClient = new NexusZoneClient((INexusLogger)(object)NexusServerLogger.Instance, Nexus.endpoint, Nexus.secretKey, Nexus.messageLockDuration);
		NexusZoneClient zoneClient2 = ZoneClient;
		object obj = <>c.<>9__26_0;
		if (obj == null)
		{
			NexusErrorHandler val2 = delegate(BaseNexusClient _, Exception ex)
			{
				Debug.LogException(ex);
			};
			<>c.<>9__26_0 = val2;
			obj = (object)val2;
		}
		((BaseNexusClient)zoneClient2).OnError += (NexusErrorHandler)obj;
		Task startTask = ((BaseNexusClient)ZoneClient).Start();
		yield return (object)new WaitUntil((Func<bool>)(() => startTask.IsCompleted));
		if (startTask.Exception != null)
		{
			Debug.LogException((Exception)startTask.Exception);
			yield break;
		}
		if (string.IsNullOrWhiteSpace(ZoneKey))
		{
			Debug.LogError((object)"Zone name is not available after nexus initialization");
			yield break;
		}
		Debug.Log((object)$"Connected as zone '{ZoneKey}' in Nexus {ZoneClient.Zone.NexusName} (id={ZoneClient.Zone.NexusId})");
		ZoneController.Instance = BuildZoneController(Nexus.zoneController);
		if (ZoneController.Instance == null)
		{
			Debug.LogError((object)(string.IsNullOrWhiteSpace(Nexus.zoneController) ? "Zone controller was not specified (nexus.zoneController convar)" : ("Zone controller is not supported: " + Nexus.zoneController)));
			yield break;
		}
		Variable cfgVariable2 = default(Variable);
		if (ZoneClient.TryGetNexusVariable("server.cfg", ref cfgVariable2))
		{
			Debug.Log((object)"Running server.cfg from nexus variable");
			RunConsoleConfig(cfgVariable2);
		}
		Variable cfgVariable3 = default(Variable);
		if (ZoneClient.TryGetZoneVariable("server.cfg", ref cfgVariable3))
		{
			Debug.Log((object)"Running server.cfg from zone variable");
			RunConsoleConfig(cfgVariable3);
		}
		if (string.IsNullOrWhiteSpace(ConVar.World.configString) && string.IsNullOrWhiteSpace(ConVar.World.configFile))
		{
			Debug.Log((object)"Attempting to pull world config from the nexus");
			string worldConfigString;
			try
			{
				worldConfigString = GetWorldConfigString();
			}
			catch (Exception ex3)
			{
				Debug.LogException(ex3);
				yield break;
			}
			Debug.Log((object)("Will use world config from nexus: " + worldConfigString));
			ConVar.World.configString = worldConfigString;
		}
		else
		{
			Debug.LogWarning((object)"World config convar(s) are already set, will not pull world config from nexus");
		}
		Started = true;
		FailedToStart = false;
		static void RunConsoleConfig(Variable cfgVariable)
		{
			//IL_0004: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Invalid comparison between Unknown and I4
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			if (cfgVariable != null && (int)cfgVariable.Type == 1)
			{
				string asString = cfgVariable.GetAsString();
				if (!string.IsNullOrWhiteSpace(asString))
				{
					ConsoleSystem.RunFile(Option.Server, asString);
				}
			}
		}
	}

	public static void Shutdown()
	{
		Started = false;
		FailedToStart = false;
		_existingIslands?.Clear();
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient != null)
		{
			((BaseNexusClient)zoneClient).Dispose();
		}
		ZoneClient = null;
		NexusDB database = _database;
		if (database != null)
		{
			((Database)database).Close();
		}
		_database = null;
	}

	public static void Update()
	{
		if (Started)
		{
			ReadIncomingMessages();
			CheckForRpcTimeouts();
			RefreshZoneStatus();
			UpdatePlayerManifest();
			RefreshCompanionVariables();
		}
	}

	public static NexusZoneDetails FindZone(string zoneKey)
	{
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient == null)
		{
			return null;
		}
		NexusDetails nexus = zoneClient.Nexus;
		if (nexus == null)
		{
			return null;
		}
		List<NexusZoneDetails> zones = nexus.Zones;
		if (zones == null)
		{
			return null;
		}
		return List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), zoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
	}

	public static Task<NexusLoginResult> Login(ulong steamId)
	{
		return ZoneClient.PlayerLogin(SteamIdToString.Get(steamId));
	}

	public static void Logout(ulong steamId)
	{
		NexusZoneClient zoneClient = ZoneClient;
		if (zoneClient != null)
		{
			zoneClient.PlayerLogout(SteamIdToString.Get(steamId));
		}
	}

	public static bool TryGetPlayer(ulong steamId, out NexusPlayer player)
	{
		if (!Started)
		{
			player = null;
			return false;
		}
		return ZoneClient.TryGetPlayer(SteamIdToString.Get(steamId), ref player);
	}

	public static Task AssignInitialZone(ulong steamId, string zoneKey)
	{
		return ZoneClient.Assign(steamId.ToString("G"), zoneKey);
	}

	private static ZoneController BuildZoneController(string name)
	{
		if (name.ToLowerInvariant() == "basic")
		{
			return new BasicZoneController(ZoneClient);
		}
		return null;
	}

	public static void PostGameSaved()
	{
		_database?.ClearJournal();
		_database?.ClearTransferred();
		_lastUnsavedTransfer = null;
	}

	public static async void UpdateFerries()
	{
		if (ZoneClient == null || _updatingFerries)
		{
			return;
		}
		try
		{
			_updatingFerries = true;
			await UpdateFerriesImpl();
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			_updatingFerries = false;
		}
	}

	private static async Task UpdateFerriesImpl()
	{
		if (ZoneClient == null)
		{
			return;
		}
		Request obj = Pool.Get<Request>();
		obj.ferryStatus = Pool.Get<FerryStatusRequest>();
		using (NexusRpcResult statusResponse = await BroadcastRpc(obj))
		{
			UpdateFerryStatuses(statusResponse);
		}
		string zone = ZoneKey;
		Variable val = default(Variable);
		List<(string, FerryStatus)> value;
		if (ZoneClient.TryGetZoneVariable("ferry", ref val) && (int)val.Type == 1 && TryParseFerrySchedule(zone, val.GetAsString(), out var schedule))
		{
			if (FerryEntries.TryGetValue(zone, out var entries) && entries.Count > 1)
			{
				for (int i = 1; i < entries.Count; i++)
				{
					(string, FerryStatus) tuple = entries[i];
					await RetireFerry(tuple.Item1, tuple.Item2.entityId, tuple.Item2.timestamp);
				}
			}
			if (entries != null && entries.Count > 0)
			{
				_cyclesWithoutFerry = 0;
				(string, FerryStatus) tuple2 = entries[0];
				if (!tuple2.Item2.schedule.SequenceEqual<string>(schedule, StringComparer.InvariantCultureIgnoreCase))
				{
					await UpdateFerrySchedule(tuple2.Item1, tuple2.Item2.entityId, tuple2.Item2.timestamp, schedule);
				}
			}
			else
			{
				if (entries != null && entries.Count != 0)
				{
					return;
				}
				_cyclesWithoutFerry++;
				if (_cyclesWithoutFerry < 5)
				{
					return;
				}
				_cyclesWithoutFerry = 0;
				BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/nexus/ferry/nexusferry.entity.prefab");
				if (!(baseEntity is NexusFerry nexusFerry))
				{
					Debug.LogError((object)"Failed to spawn nexus ferry!");
					if ((Object)(object)baseEntity != (Object)null)
					{
						Object.Destroy((Object)(object)baseEntity);
					}
				}
				else
				{
					nexusFerry.Initialize(zone, schedule);
					nexusFerry.Spawn();
				}
			}
		}
		else if (FerryEntries.TryGetValue(zone, out value) && value.Count > 0)
		{
			_cyclesWithoutFerry = 0;
			foreach (var item in value)
			{
				await RetireFerry(item.Item1, item.Item2.entityId, item.Item2.timestamp);
			}
		}
		else
		{
			_cyclesWithoutFerry = 0;
		}
	}

	public static bool TryGetFerryStatus(string ownerZone, out string currentZone, out FerryStatus status)
	{
		if (!FerryEntries.TryGetValue(ownerZone, out List<(string, FerryStatus)> value) || value.Count < 1)
		{
			currentZone = null;
			status = null;
			return false;
		}
		(currentZone, status) = value[0];
		return true;
	}

	private static Task RetireFerry(string zone, NetworkableId entityId, long timestamp)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Request val = Pool.Get<Request>();
		val.ferryRetire = Pool.Get<FerryRetireRequest>();
		val.ferryRetire.entityId = entityId;
		val.ferryRetire.timestamp = timestamp;
		return ZoneRpc(zone, val);
	}

	private static Task UpdateFerrySchedule(string zone, NetworkableId entityId, long timestamp, List<string> schedule)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Request val = Pool.Get<Request>();
		val.ferryUpdateSchedule = Pool.Get<FerryUpdateScheduleRequest>();
		val.ferryUpdateSchedule.entityId = entityId;
		val.ferryUpdateSchedule.timestamp = timestamp;
		val.ferryUpdateSchedule.schedule = List.ShallowClonePooled<string>(schedule);
		return ZoneRpc(zone, val);
	}

	private static bool TryParseFerrySchedule(string zone, string scheduleString, out List<string> entries)
	{
		if (!NexusUtil.TryParseFerrySchedule(zone, scheduleString, out var entries2))
		{
			entries = null;
			return false;
		}
		List<string> list = entries2.ToList();
		foreach (string item in list)
		{
			if (FindZone(item) == null)
			{
				Debug.LogError((object)("Ferry schedule for '" + zone + "' lists an invalid zone '" + item + "': " + scheduleString));
				entries = null;
				return false;
			}
		}
		entries = list;
		return true;
	}

	private static void UpdateFerryStatuses(NexusRpcResult statusResponse)
	{
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		foreach (KeyValuePair<string, List<(string, FerryStatus)>> ferryEntry in FerryEntries)
		{
			List<(string, FerryStatus)> value = ferryEntry.Value;
			foreach (var item in value)
			{
				item.Item2.Dispose();
			}
			Pool.FreeUnmanaged<(string, FerryStatus)>(ref value);
		}
		FerryEntries.Clear();
		foreach (KeyValuePair<string, Response> response in statusResponse.Responses)
		{
			FerryStatusResponse ferryStatus = response.Value.ferryStatus;
			if (ferryStatus?.statuses == null)
			{
				continue;
			}
			foreach (FerryStatus status in ferryStatus.statuses)
			{
				AddFerryStatus(response.Key, status);
			}
		}
		string zoneKey = ZoneKey;
		Enumerator<NexusFerry> enumerator5 = NexusFerry.All.GetEnumerator();
		try
		{
			while (enumerator5.MoveNext())
			{
				NexusFerry current3 = enumerator5.Current;
				AddFerryStatus(zoneKey, current3.GetStatus());
			}
		}
		finally
		{
			((IDisposable)enumerator5/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (List<(string, FerryStatus)> value3 in FerryEntries.Values)
		{
			if (value3.Count > 1)
			{
				value3.Sort(((string Zone, FerryStatus Status) a, (string Zone, FerryStatus Status) b) => a.Status.timestamp.CompareTo(b.Status.timestamp));
			}
		}
		static void AddFerryStatus(string currentZone, FerryStatus status)
		{
			if (!FerryEntries.TryGetValue(status.ownerZone, out List<(string, FerryStatus)> value2))
			{
				value2 = Pool.Get<List<(string, FerryStatus)>>();
				FerryEntries.Add(status.ownerZone, value2);
			}
			value2.Add((currentZone, status.Copy()));
		}
	}

	public static void UpdateIslands()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Invalid comparison between Unknown and I4
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		if (ZoneClient == null)
		{
			return;
		}
		Variable val = default(Variable);
		if (ZoneClient.TryGetNexusVariable("map.contactRadius", ref val) && (int)val.Type == 1 && float.TryParse(val.GetAsString(), out var result))
		{
			_zoneContactRadius = result;
		}
		else
		{
			_zoneContactRadius = Nexus.defaultZoneContactRadius;
		}
		if (_existingIslands == null)
		{
			_existingIslands = new Dictionary<string, NexusIsland>();
		}
		HashSet<NexusIsland> hashSet = Pool.Get<HashSet<NexusIsland>>();
		hashSet.Clear();
		if (_existingIslands.Count == 0)
		{
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (enumerator.Current is NexusIsland nexusIsland)
					{
						if (string.IsNullOrEmpty(nexusIsland.ZoneKey) || _existingIslands.ContainsKey(nexusIsland.ZoneKey))
						{
							hashSet.Add(nexusIsland);
						}
						else
						{
							_existingIslands.Add(nexusIsland.ZoneKey, nexusIsland);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		Dictionary<string, NexusZoneDetails> dictionary = Pool.Get<Dictionary<string, NexusZoneDetails>>();
		dictionary.Clear();
		foreach (NexusZoneDetails zone in ZoneClient.Nexus.Zones)
		{
			if (TryGetZoneStatus(zone.Key, out var status) && status.IsOnline)
			{
				dictionary.Add(zone.Key, zone);
			}
		}
		foreach (KeyValuePair<string, NexusZoneDetails> item in dictionary)
		{
			if (item.Key == ZoneKey)
			{
				continue;
			}
			if (!IsCloseTo(item.Value))
			{
				if (_existingIslands.TryGetValue(item.Key, out var value))
				{
					hashSet.Add(value);
				}
				continue;
			}
			var (val2, val3) = CalculateIslandTransform(item.Value);
			if (_existingIslands.TryGetValue(item.Key, out var value2) && (Object)(object)value2 != (Object)null)
			{
				((Component)value2).transform.SetPositionAndRotation(val2, val3);
			}
			else
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/nexus/island/nexusisland.prefab", val2, val3);
				if (!(baseEntity is NexusIsland nexusIsland2))
				{
					baseEntity.Kill();
					Debug.LogError((object)"Failed to spawn nexus island entity!");
					continue;
				}
				nexusIsland2.ZoneKey = item.Key;
				nexusIsland2.Spawn();
				_existingIslands[item.Key] = nexusIsland2;
				value2 = nexusIsland2;
			}
			value2.SetFlag(BaseEntity.Flags.Reserved1, TryGetZoneStatus(item.Key, out var status2) && status2.IsFull);
		}
		foreach (KeyValuePair<string, NexusIsland> existingIsland in _existingIslands)
		{
			if (!dictionary.ContainsKey(existingIsland.Key))
			{
				hashSet.Add(existingIsland.Value);
			}
		}
		foreach (NexusIsland item2 in hashSet)
		{
			if (item2 != null)
			{
				if (item2.ZoneKey != null)
				{
					_existingIslands.Remove(item2.ZoneKey);
				}
				item2.Kill();
			}
		}
		hashSet.Clear();
		Pool.FreeUnmanaged<NexusIsland>(ref hashSet);
		dictionary.Clear();
		Pool.FreeUnmanaged<string, NexusZoneDetails>(ref dictionary);
	}

	public static bool TryGetIsland(string zoneKey, out NexusIsland island)
	{
		if (_existingIslands == null)
		{
			island = null;
			return false;
		}
		if (_existingIslands.TryGetValue(zoneKey, out island))
		{
			return (Object)(object)island != (Object)null;
		}
		return false;
	}

	public static bool TryGetIslandPosition(string zoneKey, out Vector3 position)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		NexusZoneDetails val = List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), zoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
		if (val == null)
		{
			position = Vector3.zero;
			return false;
		}
		(position, _) = CalculateIslandTransform(val);
		return true;
	}

	private static (Vector3, Quaternion) CalculateIslandTransform(NexusZoneDetails otherZone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		Bounds worldBounds = GetWorldBounds();
		float num = Mathf.Max(((Bounds)(ref worldBounds)).extents.x, ((Bounds)(ref worldBounds)).extents.z) * 1.5f;
		float num2 = Vector2Ex.AngleFromTo(ZoneClient.Zone.Position(), otherZone.Position());
		Vector3 val = TerrainMeta.Center + Quaternion.Euler(0f, num2, 0f) * Vector3.right * num;
		Vector3 val2 = Vector3Ex.WithY(((Bounds)(ref worldBounds)).ClosestPoint(val), TerrainMeta.Center.y);
		Vector3 val3 = TerrainMeta.Center - val2;
		Quaternion item = Quaternion.LookRotation(((Vector3)(ref val3)).normalized);
		return (Vector3Ex.WithY(val2, WaterSystem.OceanLevel), item);
	}

	public static Bounds GetWorldBounds()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = (((Object)(object)SingletonComponent<ValidBounds>.Instance != (Object)null) ? ((Bounds)(ref SingletonComponent<ValidBounds>.Instance.worldBounds)).extents : (Vector3.one * float.MaxValue));
		val.x = Mathf.Min(val.x, (float)World.Size * 1.5f);
		val.y = 0.01f;
		val.z = Mathf.Min(val.z, (float)World.Size * 1.5f);
		val.x = Mathf.Min((float)World.Size * Nexus.islandSpawnDistance, val.x * 0.9f);
		val.z = Mathf.Min((float)World.Size * Nexus.islandSpawnDistance, val.z * 0.9f);
		return new Bounds(Vector3.zero, val * 2f);
	}

	private static bool IsCloseTo(NexusZoneDetails otherZone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return Vector2.Distance(ZoneClient.Zone.Position(), otherZone.Position()) <= _zoneContactRadius;
	}

	private static void ReadIncomingMessages()
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		NexusMessage val = default(NexusMessage);
		while (ZoneClient.TryReceiveMessage(ref val))
		{
			if (!((NexusMessage)(ref val)).IsBinary)
			{
				Debug.LogWarning((object)"Received a nexus message that's not binary, ignoring");
				ZoneClient.AcknowledgeMessage(ref val);
				continue;
			}
			byte[] asBinary;
			Packet val2;
			try
			{
				asBinary = ((NexusMessage)(ref val)).AsBinary;
				val2 = ReadPacket(asBinary);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				ZoneClient.AcknowledgeMessage(ref val);
				continue;
			}
			bool num = !RequiresJournaling(val2) || _database.SeenJournaled(Uuid.op_Implicit(((NexusMessage)(ref val)).Id), asBinary);
			ZoneClient.AcknowledgeMessage(ref val);
			if (!num)
			{
				Debug.LogWarning((object)"Already saw this nexus message, ignoring");
				val2.Dispose();
			}
			else
			{
				HandleMessage(((NexusMessage)(ref val)).Id, val2);
			}
		}
	}

	public static void RestoreUnsavedState()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (Started)
		{
			ReplayJournaledMessages();
			DeleteTransferredEntities();
			ConsoleSystem.Run(Option.Server, "server.save", Array.Empty<object>());
		}
	}

	private static void ReplayJournaledMessages()
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		List<(Guid, long, byte[])> list = _database.ReadJournal();
		if (list.Count == 0)
		{
			Debug.Log((object)"No messages found in the nexus message journal");
			return;
		}
		Debug.Log((object)$"Replaying {list.Count} nexus messages from the journal");
		foreach (var (guid, seconds, data) in list)
		{
			try
			{
				Debug.Log((object)$"Replaying message ID {guid}, received {DateTimeOffset.FromUnixTimeSeconds(seconds):R}");
				Packet packet = ReadPacket(data);
				HandleMessage(Uuid.op_Implicit(guid), packet);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		Debug.Log((object)$"Finished replaying {list.Count} nexus messages from the journal");
	}

	private static void DeleteTransferredEntities()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		List<NetworkableId> list = _database.ReadTransferred();
		if (list.Count == 0)
		{
			Debug.Log((object)"No entities found in the transferred list");
			return;
		}
		foreach (NetworkableId item in list)
		{
			try
			{
				BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(item);
				if (!((Object)(object)baseNetworkable == (Object)null))
				{
					Debug.Log((object)$"Found {baseNetworkable}, killing it because it was transferred away");
					baseNetworkable.Kill();
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		Debug.Log((object)$"Finished making sure {list.Count} entities do not exist");
	}

	private static bool RequiresJournaling(Packet packet)
	{
		if (packet.request == null || !packet.request.isFireAndForget)
		{
			return false;
		}
		return packet.request.transfer != null;
	}

	public static async void UploadMapImage(bool force = false)
	{
		_ = 1;
		try
		{
			int valueOrDefault = (World.Config?.JsonString?.GetHashCode()).GetValueOrDefault();
			string key = $"{2597}##{271}##{World.Name}##{World.Size}##{World.Seed}##{World.Salt}##{Nexus.mapImageScale}##{valueOrDefault}##{5}";
			if (!force && (await ZoneClient.CheckUploadedMap()).Key == key)
			{
				Debug.Log((object)"Nexus already has this map's image uploaded, will not render and upload again");
				return;
			}
			Debug.Log((object)"Rendering map image to upload to nexus...");
			int oceanMargin = 0;
			int imageWidth;
			int imageHeight;
			Color background;
			byte[] array = MapImageRenderer.Render(out imageWidth, out imageHeight, out background, Nexus.mapImageScale, lossy: false, transparent: true, oceanMargin);
			Debug.Log((object)"Uploading map image to nexus...");
			await ZoneClient.UploadMap(key, array);
			Debug.Log((object)"Map image was updated in the nexus");
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void HandleMessage(Uuid id, Packet packet)
	{
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (packet.protocol != 271)
			{
				Debug.LogWarning((object)"Received a nexus message with wrong protocol, ignoring");
				return;
			}
			NexusZoneDetails val = List.FindWith<NexusZoneDetails, int>((IReadOnlyCollection<NexusZoneDetails>)ZoneClient.Nexus.Zones, (Func<NexusZoneDetails, int>)((NexusZoneDetails z) => z.Id), packet.sourceZone, (IEqualityComparer<int>)null);
			if (val == null)
			{
				Debug.LogWarning((object)$"Received a nexus message from unknown zone ID {packet.sourceZone}, ignoring");
			}
			else if (packet.request != null)
			{
				HandleRpcInvocation(val, id, packet.request);
			}
			else if (packet.response != null)
			{
				HandleRpcResponse(val, id, packet.response);
			}
			else
			{
				Debug.LogWarning((object)"Received a nexus message without the request or request sections set, ignoring");
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			if (packet != null)
			{
				packet.Dispose();
			}
		}
	}

	private static Packet ReadPacket(byte[] data)
	{
		return Packet.Deserialize(data);
	}

	private static Task SendRequestImpl(Uuid id, Request request, string toZoneKey, int? ttl = null)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Packet val = Pool.Get<Packet>();
		val.protocol = 271u;
		val.sourceZone = ZoneClient.Zone.ZoneId;
		val.request = request;
		return SendPacket(id, val, toZoneKey, ttl);
	}

	private static async void SendResponseImpl(Response response, string toZoneKey, int? ttl = null)
	{
		try
		{
			Packet val = Pool.Get<Packet>();
			val.protocol = 271u;
			val.sourceZone = ZoneClient.Zone.ZoneId;
			val.response = response;
			await SendPacket(Uuid.Generate(), val, toZoneKey, ttl);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static Task SendPacket(Uuid id, Packet packet, string toZoneKey, int? ttl = null)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		WriterStream.SetLength(0L);
		WriterStream.Position = 0L;
		ProtoStreamExtensions.WriteToStream((IProto)(object)packet, (Stream)WriterStream, false, 2097152);
		Memory<byte> memory = new Memory<byte>(WriterStream.GetBuffer(), 0, (int)WriterStream.Length);
		packet.Dispose();
		return ZoneClient.SendMessage(toZoneKey, id, memory, ttl);
	}

	public static bool IsOnline(ulong userId)
	{
		RebuildPlayerManifestIfDirty();
		if (!PlayerManifest.Contains(userId))
		{
			return ServerPlayers.IsOnline(userId);
		}
		return true;
	}

	public static void AddZonePlayerManifest(string zoneKey, List<ulong> userIds)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (ZonePlayerManifests.TryGetValue(zoneKey, out var value))
		{
			if (value.UserIds != null)
			{
				Pool.FreeUnmanaged<ulong>(ref value.UserIds);
			}
			ZonePlayerManifests.Remove(zoneKey);
		}
		ZonePlayerManifests.Add(zoneKey, new ZonePlayerManifest
		{
			Received = RealTimeSince.op_Implicit(0f),
			UserIds = List.ShallowClonePooled<ulong>(userIds)
		});
	}

	private static void UpdatePlayerManifest()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_lastPlayerManifestBroadcast) >= Nexus.playerManifestInterval)
		{
			_lastPlayerManifestBroadcast = RealTimeSince.op_Implicit(0f);
			BroadcastPlayerManifest();
		}
		if (RealTimeSince.op_Implicit(_lastPlayerManifestRebuild) > Nexus.playerManifestInterval)
		{
			_playerManifestDirty = true;
		}
		RebuildPlayerManifestIfDirty();
	}

	private static async void BroadcastPlayerManifest()
	{
		try
		{
			Request obj = Pool.Get<Request>();
			obj.isFireAndForget = true;
			obj.playerManifest = Pool.Get<PlayerManifestRequest>();
			obj.playerManifest.userIds = Pool.Get<List<ulong>>();
			ServerPlayers.GetAll(obj.playerManifest.userIds);
			await BroadcastRpc(obj);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void RebuildPlayerManifestIfDirty()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if (!_playerManifestDirty)
		{
			return;
		}
		_playerManifestDirty = false;
		_lastPlayerManifestRebuild = RealTimeSince.op_Implicit(0f);
		RemoveInvalidPlayerManifests();
		PlayerManifest.Clear();
		foreach (ZonePlayerManifest value in ZonePlayerManifests.Values)
		{
			foreach (ulong userId in value.UserIds)
			{
				PlayerManifest.Add(userId);
			}
		}
	}

	private static void RemoveInvalidPlayerManifests()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		List<string> list = Pool.Get<List<string>>();
		foreach (KeyValuePair<string, ZonePlayerManifest> zonePlayerManifest in ZonePlayerManifests)
		{
			if (FindZone(zonePlayerManifest.Key) == null || RealTimeSince.op_Implicit(zonePlayerManifest.Value.Received) > Nexus.playerManifestInterval * 3f)
			{
				list.Add(zonePlayerManifest.Key);
			}
		}
		foreach (string item in list)
		{
			if (ZonePlayerManifests.TryGetValue(item, out var value))
			{
				ZonePlayerManifests.Remove(item);
				if (value.UserIds != null)
				{
					Pool.FreeUnmanaged<ulong>(ref value.UserIds);
				}
			}
		}
		Pool.FreeUnmanaged<string>(ref list);
	}

	public static async Task<Response> ZoneRpc(string zone, Request request, float timeoutAfter = 30f)
	{
		if (string.IsNullOrEmpty(zone))
		{
			throw new ArgumentNullException("zone");
		}
		if (string.Equals(zone, ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			return HandleRpcInvocationImpl(List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), ZoneKey, (IEqualityComparer<string>)null), Uuid.Empty, request);
		}
		using NexusRpcResult nexusRpcResult = await CallRpcImpl(zone, request, timeoutAfter, throwOnTimeout: true);
		Response val = nexusRpcResult.Responses[zone];
		if (!string.IsNullOrWhiteSpace(val.status?.errorMessage))
		{
			throw new Exception(val.status.errorMessage);
		}
		return val.Copy();
	}

	public static Task<NexusRpcResult> BroadcastRpc(Request request, float timeoutAfter = 30f)
	{
		return CallRpcImpl(null, request, timeoutAfter, throwOnTimeout: false);
	}

	private static async Task<NexusRpcResult> CallRpcImpl(string zone, Request request, float timeoutAfter, bool throwOnTimeout)
	{
		Uuid id = Uuid.Generate();
		TaskCompletionSource<bool> tcs = new TaskCompletionSource<bool>();
		NexusRpcResult result = Pool.Get<NexusRpcResult>();
		try
		{
			float actualTimeout = timeoutAfter * Nexus.rpcTimeoutMultiplier;
			await SendRequestImpl(id, request, zone, (int)actualTimeout + RpcResponseTtl);
			PendingCalls.Add(id, new PendingCall
			{
				IsBroadcast = string.IsNullOrWhiteSpace(zone),
				TimeUntilTimeout = RealTimeUntil.op_Implicit(actualTimeout),
				Completion = tcs,
				Result = result
			});
			bool flag = await tcs.Task;
			if (throwOnTimeout && !flag)
			{
				throw new TimeoutException("Nexus RPC invocation timed out");
			}
		}
		catch
		{
			Pool.Free<NexusRpcResult>(ref result);
			throw;
		}
		return result;
	}

	private static void HandleRpcInvocation(NexusZoneDetails from, Uuid id, Request request)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		Response val = HandleRpcInvocationImpl(from, id, request);
		if (val != null)
		{
			SendResponseImpl(val, from.Key, RpcResponseTtl);
		}
	}

	private static Response HandleRpcInvocationImpl(NexusZoneDetails from, Uuid id, Request request)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (!Handle<TransferRequest, TransferHandler>(request.transfer, from, id, request, out var response) && !Handle<PingRequest, PingHandler>(request.ping, from, id, request, out response) && !Handle<SpawnOptionsRequest, SpawnOptionsHandler>(request.spawnOptions, from, id, request, out response) && !Handle<SleepingBagRespawnRequest, RespawnAtBagHandler>(request.respawnAtBag, from, id, request, out response) && !Handle<SleepingBagDestroyRequest, DestroyBagHandler>(request.destroyBag, from, id, request, out response) && !Handle<FerryStatusRequest, FerryStatusHandler>(request.ferryStatus, from, id, request, out response) && !Handle<FerryRetireRequest, FerryRetireHandler>(request.ferryRetire, from, id, request, out response) && !Handle<FerryUpdateScheduleRequest, FerryUpdateScheduleHandler>(request.ferryUpdateSchedule, from, id, request, out response) && !Handle<ClanChatBatchRequest, ClanChatBatchHandler>(request.clanChatBatch, from, id, request, out response) && !Handle<PlayerManifestRequest, PlayerManifestHandler>(request.playerManifest, from, id, request, out response))
		{
			Debug.LogError((object)"Received a nexus RPC invocation with a missing or unsupported request, ignoring");
			return null;
		}
		return response;
	}

	private static bool Handle<TProto, THandler>(TProto proto, NexusZoneDetails from, Uuid id, Request request, out Response response) where TProto : class where THandler : BaseNexusRequestHandler<TProto>, new()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (proto == null)
		{
			response = null;
			return false;
		}
		THandler val = Pool.Get<THandler>();
		val.Initialize(from, id, request.isFireAndForget, proto);
		val.Execute();
		response = val.Response;
		Pool.Free<THandler>(ref val);
		return true;
	}

	private static void HandleRpcResponse(NexusZoneDetails from, Uuid id, Response response)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		if (!PendingCalls.TryGetValue(response.id, out var value))
		{
			Debug.LogWarning((object)"Received an unexpected nexus RPC response (likely timed out), ignoring");
			return;
		}
		if (!value.Result.Responses.ContainsKey(from.Key))
		{
			value.Result.Responses.Add(from.Key, response.Copy());
		}
		int num;
		if (!value.IsBroadcast)
		{
			num = 1;
		}
		else
		{
			NexusZoneClient zoneClient = ZoneClient;
			int? obj;
			if (zoneClient == null)
			{
				obj = null;
			}
			else
			{
				NexusDetails nexus = zoneClient.Nexus;
				obj = ((nexus == null) ? ((int?)null) : nexus.Zones?.Count);
			}
			int? num2 = obj;
			num = num2.GetValueOrDefault() - 1;
		}
		int num3 = num;
		if (value.Result.Responses.Count >= num3)
		{
			PendingCalls.Remove(id);
			value.Completion.TrySetResult(result: true);
		}
	}

	private static void CheckForRpcTimeouts()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		if (RealTimeSince.op_Implicit(_sinceLastRpcTimeoutCheck) < 1f)
		{
			return;
		}
		_sinceLastRpcTimeoutCheck = RealTimeSince.op_Implicit(0f);
		List<(Uuid, PendingCall)> list = Pool.Get<List<(Uuid, PendingCall)>>();
		foreach (KeyValuePair<Uuid, PendingCall> pendingCall in PendingCalls)
		{
			Uuid key = pendingCall.Key;
			PendingCall value = pendingCall.Value;
			if (RealTimeUntil.op_Implicit(value.TimeUntilTimeout) <= 0f)
			{
				list.Add((key, value));
			}
		}
		foreach (var item3 in list)
		{
			Uuid item = item3.Item1;
			PendingCall item2 = item3.Item2;
			PendingCalls.Remove(item);
			item2.Completion.TrySetResult(result: false);
		}
		Pool.FreeUnmanaged<(Uuid, PendingCall)>(ref list);
	}

	private static void RefreshZoneStatus()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (!_isRefreshingZoneStatus && !(RealTimeSince.op_Implicit(_lastZoneStatusRefresh) < Nexus.pingInterval))
		{
			RefreshZoneStatusImpl();
		}
		static async void RefreshZoneStatusImpl()
		{
			try
			{
				_isRefreshingZoneStatus = true;
				_lastZoneStatusRefresh = RealTimeSince.op_Implicit(0f);
				Request obj = Pool.Get<Request>();
				obj.ping = Pool.Get<PingRequest>();
				using (NexusRpcResult nexusRpcResult = await BroadcastRpc(obj))
				{
					List<string> list = Pool.Get<List<string>>();
					foreach (string key in ZoneStatuses.Keys)
					{
						if (List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), key, (IEqualityComparer<string>)null) == null)
						{
							list.Add(key);
						}
					}
					foreach (string item in list)
					{
						ZoneStatuses.Remove(item);
					}
					Pool.FreeUnmanaged<string>(ref list);
					foreach (KeyValuePair<string, Response> response in nexusRpcResult.Responses)
					{
						if (string.IsNullOrWhiteSpace(response.Key))
						{
							Debug.LogWarning((object)"Received a ping response for a zone with a null key");
						}
						else if (response.Value?.ping == null)
						{
							Debug.LogWarning((object)("Received a ping response from '" + response.Key + "' but the data was null"));
						}
						else
						{
							ZoneStatuses[response.Key] = new ServerStatus
							{
								IsOnline = true,
								LastSeen = RealTimeSince.op_Implicit(0f),
								Players = response.Value.ping.players,
								MaxPlayers = response.Value.ping.maxPlayers,
								QueuedPlayers = response.Value.ping.queuedPlayers
							};
						}
					}
					foreach (NexusZoneDetails zone in Zones)
					{
						if (!nexusRpcResult.Responses.ContainsKey(zone.Key))
						{
							if (ZoneStatuses.TryGetValue(zone.Key, out var value))
							{
								ZoneStatuses[zone.Key] = new ServerStatus
								{
									IsOnline = false,
									LastSeen = value.LastSeen,
									Players = value.Players,
									MaxPlayers = value.MaxPlayers,
									QueuedPlayers = value.QueuedPlayers
								};
							}
							else
							{
								ZoneStatuses[zone.Key] = new ServerStatus
								{
									IsOnline = false
								};
							}
						}
					}
				}
				_lastZoneStatusRefresh = RealTimeSince.op_Implicit(0f);
			}
			finally
			{
				_isRefreshingZoneStatus = false;
			}
			OnZoneStatusesRefreshed();
		}
	}

	public static bool TryGetZoneStatus(string zone, out ServerStatus status)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		if (!Started)
		{
			status = default(ServerStatus);
			return false;
		}
		if (string.Equals(zone, ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			status = new ServerStatus
			{
				IsOnline = true,
				LastSeen = RealTimeSince.op_Implicit(0f),
				Players = BasePlayer.activePlayerList.Count,
				MaxPlayers = ConVar.Server.maxplayers,
				QueuedPlayers = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued
			};
			return true;
		}
		return ZoneStatuses.TryGetValue(zone, out status);
	}

	private static void OnZoneStatusesRefreshed()
	{
		UpdateIslands();
		UpdateFerries();
	}

	public static async Task TransferEntity(BaseEntity entity, string toZoneKey, string method, bool includeFerry = true)
	{
		try
		{
			await TransferEntityImpl(FindRootEntity(entity, includeFerry), toZoneKey, method, ZoneKey, toZoneKey);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)ex);
		}
	}

	public static async Task TransferEntityImpl(BaseEntity rootEntity, string toZoneKey, string method, string from, string to)
	{
		if ((Object)(object)rootEntity == (Object)null)
		{
			throw new ArgumentNullException("rootEntity");
		}
		if (string.IsNullOrWhiteSpace(toZoneKey))
		{
			throw new ArgumentNullException("toZoneKey");
		}
		if (string.Equals(toZoneKey, ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			throw new ArgumentException("Attempted to transfer a player to the current server's zone", "toZoneKey");
		}
		NexusZoneDetails toZone = List.FindWith<NexusZoneDetails, string>((IReadOnlyCollection<NexusZoneDetails>)ZoneClient.Nexus.Zones, (Func<NexusZoneDetails, string>)((NexusZoneDetails z) => z.Key), toZoneKey, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
		if (toZone == null)
		{
			throw new ArgumentException("Target zone (" + toZoneKey + ") was not found in the nexus", "toZoneKey");
		}
		BuildTransferRequest(rootEntity, method, from, to, out var request, out var networkables, out var players, out var playerIds);
		HashSet<NetworkableId> transferEntityIds = Pool.Get<HashSet<NetworkableId>>();
		transferEntityIds.Clear();
		foreach (BaseNetworkable item in networkables)
		{
			if (item.net != null && ((NetworkableId)(ref item.net.ID)).IsValid)
			{
				transferEntityIds.Add(item.net.ID);
			}
		}
		foreach (BaseNetworkable item2 in networkables)
		{
			if (item2.net != null && ((NetworkableId)(ref item2.net.ID)).IsValid)
			{
				transferEntityIds.Add(item2.net.ID);
			}
			if (item2 is BaseEntity baseEntity)
			{
				baseEntity.SetFlag(BaseEntity.Flags.Transferring, b: true);
			}
		}
		try
		{
			if (playerIds.Count > 0)
			{
				await ZoneClient.RegisterTransfers(toZoneKey, (IEnumerable<string>)playerIds);
			}
			await SendRequestImpl(Uuid.Generate(), request, toZoneKey, null);
		}
		catch
		{
			foreach (BaseNetworkable item3 in networkables)
			{
				if ((Object)(object)item3 != (Object)null && item3 is BaseEntity baseEntity2)
				{
					baseEntity2.SetFlag(BaseEntity.Flags.Transferring, b: false);
				}
			}
			throw;
		}
		foreach (BasePlayer item4 in players)
		{
			if ((Object)(object)item4 != (Object)null && item4.IsConnected)
			{
				ConsoleNetwork.SendClientCommandImmediate(item4.net.connection, "nexus.redirect", toZone.IpAddress, toZone.GamePort, toZone.ConnectionProtocol());
				item4.limitNetworking = true;
				item4.EnableSaving(wants: false);
				((FacepunchBehaviour)item4).Invoke((Action)item4.KickAfterServerTransfer, 1f);
			}
		}
		for (int num = networkables.Count - 1; num >= 0; num--)
		{
			try
			{
				BaseNetworkable baseNetworkable = networkables[num];
				if ((Object)(object)baseNetworkable != (Object)null)
				{
					if (baseNetworkable is BaseEntity entity)
					{
						UnparentUnknown(entity, transferEntityIds);
					}
					if (baseNetworkable is BasePlayer basePlayer && players.Contains(basePlayer))
					{
						basePlayer.SetParent(null, worldPositionStays: true);
					}
					else
					{
						baseNetworkable.Kill();
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		_database.MarkTransferred(transferEntityIds);
		transferEntityIds.Clear();
		Pool.FreeUnmanaged<NetworkableId>(ref transferEntityIds);
		Pool.FreeUnmanaged<BaseNetworkable>(ref networkables);
		Pool.FreeUnmanaged<BasePlayer>(ref players);
		Pool.FreeUnmanaged<string>(ref playerIds);
		_lastUnsavedTransfer = DateTimeOffset.UtcNow;
	}

	private static void UnparentUnknown(BaseEntity entity, HashSet<NetworkableId> knownEntityIds)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		foreach (BaseEntity child in entity.children)
		{
			if (knownEntityIds.Contains(child.net.ID))
			{
				UnparentUnknown(child, knownEntityIds);
			}
			else
			{
				list.Add(child);
			}
		}
		foreach (BaseEntity item in list)
		{
			Debug.Log((object)$"Unparenting {entity}", (Object)(object)entity);
			item.SetParent(null, worldPositionStays: true, sendImmediate: true);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	public static void BuildTransferRequest(BaseEntity rootEntity, string method, string from, string to, out Request request, out List<BaseNetworkable> networkables, out List<BasePlayer> players, out List<string> playerIds)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		List<BaseNetworkable> entitiesList = (networkables = Pool.Get<List<BaseNetworkable>>());
		List<BasePlayer> playerList = (players = Pool.Get<List<BasePlayer>>());
		List<string> playerIdsList = (playerIds = Pool.Get<List<string>>());
		request = Pool.Get<Request>();
		request.isFireAndForget = true;
		request.transfer = Pool.Get<TransferRequest>();
		request.transfer.method = method;
		request.transfer.from = from;
		request.transfer.to = to;
		List<Entity> serializedEntities = (request.transfer.entities = Pool.Get<List<Entity>>());
		List<PlayerSecondaryData> secondaryData = (request.transfer.secondaryData = Pool.Get<List<PlayerSecondaryData>>());
		Queue<BaseNetworkable> pendingEntities = Pool.Get<Queue<BaseNetworkable>>();
		pendingEntities.Clear();
		HashSet<NetworkableId> seenEntityIds = Pool.Get<HashSet<NetworkableId>>();
		seenEntityIds.Clear();
		pendingEntities.Enqueue(rootEntity);
		seenEntityIds.Add(rootEntity.net.ID);
		while (pendingEntities.Count > 0)
		{
			BaseNetworkable baseNetworkable = pendingEntities.Dequeue();
			Entity val = null;
			if (CanTransferEntity(baseNetworkable))
			{
				val = AddEntity(baseNetworkable);
			}
			foreach (BaseEntity child in baseNetworkable.children)
			{
				if ((Object)(object)child != (Object)null && seenEntityIds.Add(child.net.ID))
				{
					pendingEntities.Enqueue(child);
				}
			}
			if (baseNetworkable is BaseMountable baseMountable)
			{
				BasePlayer mounted = baseMountable.GetMounted();
				if ((Object)(object)mounted != (Object)null && seenEntityIds.Add(mounted.net.ID))
				{
					pendingEntities.Enqueue(mounted);
				}
			}
			if (val != null)
			{
				val.InspectUids((UidInspector<ulong>)ScanForAdditionalEntities);
			}
		}
		seenEntityIds.Clear();
		Pool.FreeUnmanaged<NetworkableId>(ref seenEntityIds);
		pendingEntities.Clear();
		Pool.FreeUnmanaged<BaseNetworkable>(ref pendingEntities);
		Entity AddEntity(BaseNetworkable entity)
		{
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			BaseNetworkable.SaveInfo saveInfo = default(BaseNetworkable.SaveInfo);
			saveInfo.forDisk = true;
			saveInfo.forTransfer = true;
			saveInfo.msg = Pool.Get<Entity>();
			BaseNetworkable.SaveInfo info = saveInfo;
			entity.Save(info);
			if (entity == rootEntity && info.msg.parent != null)
			{
				info.msg.parent.Dispose();
				info.msg.parent = null;
				if (info.msg.baseEntity != null)
				{
					Vector3 pos = default(Vector3);
					Quaternion val2 = default(Quaternion);
					((Component)rootEntity).transform.GetPositionAndRotation(ref pos, ref val2);
					info.msg.baseEntity.pos = pos;
					info.msg.baseEntity.rot = ((Quaternion)(ref val2)).eulerAngles;
				}
			}
			serializedEntities.Add(info.msg);
			entitiesList.Add(entity);
			if (entity is BasePlayer basePlayer && ((object)basePlayer).GetType() == typeof(BasePlayer) && (ulong)basePlayer.userID > uint.MaxValue)
			{
				playerList.Add(basePlayer);
				playerIdsList.Add(basePlayer.UserIDString);
				secondaryData.Add(basePlayer.SaveSecondaryData());
			}
			return info.msg;
		}
		void ScanForAdditionalEntities(UidType type, ref ulong uid)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			NetworkableId val3 = default(NetworkableId);
			((NetworkableId)(ref val3))..ctor(uid);
			if ((int)type == 0 && ((NetworkableId)(ref val3)).IsValid && seenEntityIds.Add(val3))
			{
				BaseNetworkable baseNetworkable2 = BaseNetworkable.serverEntities.Find(val3);
				if ((Object)(object)baseNetworkable2 != (Object)null)
				{
					pendingEntities.Enqueue(baseNetworkable2);
				}
			}
		}
	}

	private static bool CanTransferEntity(BaseNetworkable networkable)
	{
		if ((Object)(object)networkable == (Object)null)
		{
			return false;
		}
		if (networkable is BaseEntity { enableSaving: false })
		{
			return false;
		}
		if (networkable is BasePlayer basePlayer && !basePlayer.IsAlive())
		{
			return false;
		}
		return true;
	}

	public static BaseEntity FindRootEntity(BaseEntity startEntity, bool includeFerry)
	{
		BaseEntity baseEntity = startEntity;
		BaseEntity parent2;
		while (TryGetParent(baseEntity, out parent2) && (includeFerry || !(parent2 is NexusFerry)))
		{
			baseEntity = parent2;
		}
		return baseEntity;
		static bool TryGetParent(BaseEntity entity, out BaseEntity parent)
		{
			BaseEntity parentEntity = entity.GetParentEntity();
			if ((Object)(object)parentEntity != (Object)null && parentEntity.enableSaving)
			{
				parent = parentEntity;
				return true;
			}
			if (entity is BasePlayer basePlayer)
			{
				BaseMountable mounted = basePlayer.GetMounted();
				if ((Object)(object)mounted != (Object)null && mounted.enableSaving)
				{
					parent = mounted;
					return true;
				}
			}
			parent = null;
			return false;
		}
	}

	private static string GetWorldConfigString()
	{
		List<string> stack = Pool.Get<List<string>>();
		JObject worldConfigImpl = GetWorldConfigImpl(ZoneKey, stack);
		Pool.FreeUnmanaged<string>(ref stack);
		if (worldConfigImpl == null)
		{
			return null;
		}
		return ((JToken)worldConfigImpl).ToString((Formatting)0, Array.Empty<JsonConverter>());
	}

	private static JObject GetWorldConfigImpl(string zoneKey, List<string> stack)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Invalid comparison between Unknown and I4
		if (stack.Count > 20)
		{
			throw new Exception("Cannot load world config from nexus - there is a cyclic dependency between zones (" + string.Join(" -> ", stack) + ")");
		}
		bool required = stack.Count > 0;
		if (!TryGetWorldConfigObject(zoneKey, required, out var cfg, out var error))
		{
			throw new Exception(error + " (" + string.Join(" -> ", stack) + ")");
		}
		JToken val = default(JToken);
		if (!cfg.TryGetValue("$copyFrom", ref val))
		{
			return cfg;
		}
		if ((int)val.Type != 8)
		{
			throw new Exception("Cannot get world config from nexus - zone '" + zoneKey + "' has a $copyFrom, but its value is not a string");
		}
		stack.Add(zoneKey);
		JObject obj = MergeInto(GetWorldConfigImpl(val.ToObject<string>(), stack), cfg);
		obj.Remove("$copyFrom");
		return obj;
	}

	private static bool TryGetWorldConfigObject(string zoneKey, bool required, out JObject cfg, out string error)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Invalid comparison between Unknown and I4
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Expected O, but got Unknown
		cfg = null;
		NexusZoneClient zoneClient = ZoneClient;
		object obj;
		if (zoneClient == null)
		{
			obj = null;
		}
		else
		{
			NexusDetails nexus = zoneClient.Nexus;
			obj = ((nexus != null) ? nexus.Zones : null);
		}
		if (obj == null)
		{
			error = "Cannot get world config from nexus - nexus server isn't started";
			return false;
		}
		NexusZoneDetails val = FindZone(zoneKey);
		if (val == null)
		{
			error = "Cannot get world config for nexus zone '" + zoneKey + "' - zone was not found";
			return false;
		}
		if (!((Dictionary<string, VariableData>)(object)val.Variables).TryGetValue("world.cfg", out VariableData value))
		{
			if (required)
			{
				error = "Cannot get world config for nexus zone '" + zoneKey + "' - world.cfg variable not found but is required by another zone";
				return false;
			}
			cfg = new JObject();
			error = null;
			return true;
		}
		if ((int)((VariableData)(ref value)).Type != 1 || string.IsNullOrWhiteSpace(((VariableData)(ref value)).Value))
		{
			error = "Cannot get world config for nexus zone '" + zoneKey + "' - world.cfg variable is empty or not a string";
			return false;
		}
		try
		{
			cfg = JObject.Parse(((VariableData)(ref value)).Value);
			error = null;
			return true;
		}
		catch (Exception ex)
		{
			error = "Cannot get world config for nexus zone '" + zoneKey + "' - failed to parse: `" + ((VariableData)(ref value)).Value + "` (" + ex.Message + ")";
			return false;
		}
	}

	private static JObject MergeInto(JObject baseObject, JObject sourceObject)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Expected O, but got Unknown
		JObject val = new JObject(baseObject);
		foreach (KeyValuePair<string, JToken> item in sourceObject)
		{
			val[item.Key] = item.Value;
		}
		return val;
	}
}


using System.Collections.Generic;

private struct ZonePlayerManifest
{
	public RealTimeSince Received;

	public List<ulong> UserIds;
}


using System.Threading.Tasks;

private struct PendingCall
{
	public bool IsBroadcast;

	public RealTimeUntil TimeUntilTimeout;

	public TaskCompletionSource<bool> Completion;

	public NexusRpcResult Result;
}


public struct ServerStatus
{
	public bool IsOnline;

	public RealTimeSince LastSeen;

	public int Players;

	public int MaxPlayers;

	public int QueuedPlayers;

	public bool IsFull => Players + QueuedPlayers >= MaxPlayers;
}


using System;
using ConVar;
using Facepunch.Nexus.Logging;
using UnityEngine;

public class NexusServerLogger : INexusLogger
{
	public static NexusServerLogger Instance { get; } = new NexusServerLogger();

	private NexusServerLogger()
	{
	}

	public void Log(NexusLogLevel level, string message, Exception exception = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Invalid comparison between Unknown and I4
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Invalid comparison between Unknown and I4
		if (!Nexus.logging)
		{
			return;
		}
		if ((int)level != 1)
		{
			if ((int)level == 2)
			{
				Debug.LogError((object)message);
			}
			else
			{
				Debug.Log((object)message);
			}
		}
		else
		{
			Debug.LogWarning((object)message);
		}
		if (exception != null)
		{
			Debug.LogException(exception);
		}
	}
}


public static class NexusVariables
{
	public static readonly string Blueprints = $"blueprints.{5}";
}


using System;
using Facepunch.Nexus;
using UnityEngine;

public abstract class ZoneController
{
	protected readonly NexusZoneClient ZoneClient;

	public static ZoneController Instance { get; set; }

	protected ZoneController(NexusZoneClient zoneClient)
	{
		ZoneClient = zoneClient ?? throw new ArgumentNullException("zoneClient");
	}

	public abstract string ChooseSpawnZone(ulong steamId, bool isAlreadyAssignedToThisZone);

	public virtual (Vector3 Position, Quaternion Rotation, bool PreserveY) ChooseTransferDestination(string sourceZone, string method, string from, string to, Vector3 position, Quaternion rotation)
	{
		switch (method)
		{
		case "console":
			return ChooseConsoleTransferDestination(sourceZone);
		case "ferry":
			return ChooseFerryTransferDestination(sourceZone);
		case "ocean":
			return ChooseOceanTransferDestination(sourceZone);
		default:
			Debug.LogError((object)("Unhandled transfer method '" + method + "', using default destination"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
	}

	protected virtual (Vector3, Quaternion, bool) ChooseConsoleTransferDestination(string sourceZone)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer.SpawnPoint spawnPoint = ServerMgr.FindSpawnPoint(null, 0uL);
		return (spawnPoint.pos, spawnPoint.rot, false);
	}

	protected virtual (Vector3, Quaternion, bool) ChooseFerryTransferDestination(string sourceZone)
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if (!NexusServer.TryGetIsland(sourceZone, out var island))
		{
			return ChooseTransferFallbackDestination(sourceZone);
		}
		if (!island.TryFindPosition(out var position))
		{
			Debug.LogWarning((object)("Couldn't find a destination position for source zone '" + sourceZone + "'"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
		return (position, ((Component)island).transform.rotation, true);
	}

	protected virtual (Vector3, Quaternion, bool) ChooseOceanTransferDestination(string sourceZone)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (!NexusServer.TryGetIsland(sourceZone, out var island))
		{
			Debug.LogWarning((object)("Couldn't find nexus island for source zone '" + sourceZone + "'"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
		if (!island.TryFindPosition(out var position))
		{
			Debug.LogWarning((object)("Couldn't find a destination position for source zone '" + sourceZone + "'"));
			return ChooseTransferFallbackDestination(sourceZone);
		}
		return (position, ((Component)island).transform.rotation, true);
	}

	protected virtual (Vector3, Quaternion, bool) ChooseTransferFallbackDestination(string sourceZone)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		Bounds worldBounds = NexusServer.GetWorldBounds();
		float num = Mathf.Max(((Bounds)(ref worldBounds)).extents.x, ((Bounds)(ref worldBounds)).extents.z);
		Vector3 position;
		Vector3 val = (NexusServer.TryGetIslandPosition(sourceZone, out position) ? (position + new Vector3((float)Random.Range(-1, 1), 0f, (float)Random.Range(-1, 1)) * 100f) : (Vector3Ex.XZ3D(Random.insideUnitCircle) * num * 0.75f));
		Vector3 val2 = Vector3Ex.WithY(val, WaterLevel.GetWaterSurface(val, waves: false, volumes: false));
		Vector3 val3 = Vector3Ex.WithY(TerrainMeta.Center, val2.y) - val2;
		Quaternion item = Quaternion.LookRotation(((Vector3)(ref val3)).normalized, Vector3.up);
		return (val2, item, true);
	}

	public virtual bool CanRespawnAcrossZones(BasePlayer player)
	{
		return true;
	}
}


using System;
using Facepunch;
using Network;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class PlayerStateManager
{
	private readonly MruDictionary<ulong, PlayerState> _cache;

	private readonly UserPersistance _persistence;

	public int CacheSize
	{
		get
		{
			return _cache.Capacity;
		}
		set
		{
			_cache.SetCapacity(value);
		}
	}

	public int CacheCount => _cache.Count;

	public long CacheEvictions => _cache.EvictionCount;

	public PlayerStateManager(UserPersistance persistence)
	{
		_cache = new MruDictionary<ulong, PlayerState>(10000, (Action<ulong, PlayerState>)FreeOldState);
		_persistence = persistence;
	}

	public PlayerState Get(ulong playerId)
	{
		TimeWarning val = TimeWarning.New("PlayerStateManager.Get", 0);
		try
		{
			PlayerState result = default(PlayerState);
			if (_cache.TryGetValue(playerId, ref result))
			{
				return result;
			}
			byte[] playerState = _persistence.GetPlayerState(playerId);
			PlayerState val2;
			if (playerState != null && playerState.Length != 0)
			{
				try
				{
					val2 = PlayerState.Deserialize(playerState);
					OnPlayerStateLoaded(val2);
					_cache.Add(playerId, val2);
					return val2;
				}
				catch (Exception arg)
				{
					Debug.LogError((object)$"Failed to load player state for {playerId}: {arg}");
				}
			}
			val2 = Pool.Get<PlayerState>();
			_cache.Add(playerId, val2);
			return val2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Save(ulong playerId)
	{
		PlayerState state = default(PlayerState);
		if (_cache.TryGetValue(playerId, ref state))
		{
			SaveState(playerId, state);
		}
	}

	private void SaveState(ulong playerId, PlayerState state)
	{
		TimeWarning val = TimeWarning.New("PlayerStateManager.SaveState", 0);
		try
		{
			byte[] state2 = ProtoStreamExtensions.ToProtoBytes((IProto)(object)state);
			_persistence.SetPlayerState(playerId, state2);
		}
		catch (Exception arg)
		{
			Debug.LogError((object)$"Failed to save player state for {playerId}: {arg}");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FreeOldState(ulong playerId, PlayerState state)
	{
		SaveState(playerId, state);
		state.Dispose();
	}

	public void Reset(ulong playerId)
	{
		_cache.Remove(playerId);
		_persistence.ResetPlayerState(playerId);
	}

	private void OnPlayerStateLoaded(PlayerState state)
	{
		state.unHostileTimestamp = Math.Min(state.unHostileTimestamp, TimeEx.currentTimestamp + 1800.0);
	}
}


using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using UnityEngine;

public static class PremiumUtil
{
	public struct PremiumCheckResult
	{
		public bool IsPremium;

		public bool Exception;

		public bool ShowException;

		public string FailReason;

		public PremiumCheckResult(bool isPremium, string failReason = null)
		{
			IsPremium = isPremium;
			FailReason = failReason;
			Exception = false;
			ShowException = true;
		}
	}

	[JsonModel]
	public class PremiumStatusResult
	{
		public long RequiredValueUsdCents;

		public long ValueUsdCents;

		[JsonIgnore]
		public bool Exception;

		[JsonIgnore]
		public bool IsPremium
		{
			get
			{
				if (ValueUsdCents >= RequiredValueUsdCents)
				{
					return RequiredValueUsdCents != 0;
				}
				return false;
			}
		}
	}

	[JsonModel]
	private class PremiumCheckRequest
	{
		public List<ulong> SteamIds { get; set; }
	}

	[JsonModel]
	private class PremiumCheckResponse
	{
		public Dictionary<ulong, bool> Results { get; set; }
	}

	public const string KickReason = "premium_account_required";

	public static readonly Phrase KickPhrase = new Phrase("premium.kick_phrase", "Your account must have premium status to play on this server.");

	public static string PremiumStatusEndpoint = "https://rust-premium.facepunch.com/api/premium/status";

	private static readonly HttpClient Http = new HttpClient();

	public static async Task<PremiumCheckResult> CheckIfPlayerIsPremium(ulong steamId)
	{
		try
		{
			List<ulong> players = Pool.Get<List<ulong>>();
			players.Add(steamId);
			Dictionary<ulong, bool> obj = await CheckIfPlayersArePremium(players);
			Pool.FreeUnmanaged<ulong>(ref players);
			if (!obj.TryGetValue(steamId, out var value))
			{
				Debug.LogError((object)$"Failed to check if user {steamId} is premium due to user not being in the results");
				return new PremiumCheckResult(isPremium: false, "Failed to validate premium status: Missing User in Results");
			}
			if (!value)
			{
				return new PremiumCheckResult(isPremium: false, "premium_account_required");
			}
			return new PremiumCheckResult(isPremium: true);
		}
		catch (HttpRequestException val)
		{
			Debug.LogError((object)$"Failed to check if user {steamId} is premium due to a network error");
			Debug.LogException((Exception)val);
			PremiumCheckResult result = new PremiumCheckResult(isPremium: false, "Failed to validate premium status: Network Error");
			result.Exception = true;
			result.ShowException = false;
			return result;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)$"Failed to check if user {steamId} is premium due to an exception");
			Debug.LogException(ex);
			PremiumCheckResult result = new PremiumCheckResult(isPremium: false, "Failed to validate premium status: Exception");
			result.Exception = true;
			return result;
		}
	}

	public static async Task<Dictionary<ulong, bool>> CheckIfPlayersArePremium(List<ulong> steamIds)
	{
		if (steamIds == null)
		{
			throw new ArgumentNullException("steamIds");
		}
		if (steamIds.Count == 0)
		{
			throw new ArgumentException("SteamIDs list cannot be empty", "steamIds");
		}
		string text = JsonConvert.SerializeObject((object)new PremiumCheckRequest
		{
			SteamIds = steamIds
		});
		HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Post, Server.premiumVerifyEndpoint);
		try
		{
			request.Content = (HttpContent)new StringContent(text, Encoding.UTF8, "application/json");
			HttpResponseMessage response = await Http.SendAsync(request);
			try
			{
				response.EnsureSuccessStatusCode();
				string text2 = await response.Content.ReadAsStringAsync();
				PremiumCheckResponse premiumCheckResponse = JsonConvert.DeserializeObject<PremiumCheckResponse>(text2);
				if (premiumCheckResponse?.Results == null || premiumCheckResponse.Results.Count != steamIds.Count)
				{
					throw new Exception("Premium verify endpoint returned malformed response: " + text2);
				}
				return premiumCheckResponse.Results;
			}
			finally
			{
				((IDisposable)response)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)request)?.Dispose();
		}
	}
}


public struct PremiumCheckResult
{
	public bool IsPremium;

	public bool Exception;

	public bool ShowException;

	public string FailReason;

	public PremiumCheckResult(bool isPremium, string failReason = null)
	{
		IsPremium = isPremium;
		FailReason = failReason;
		Exception = false;
		ShowException = true;
	}
}


using Newtonsoft.Json;

[JsonModel]
public class PremiumStatusResult
{
	public long RequiredValueUsdCents;

	public long ValueUsdCents;

	[JsonIgnore]
	public bool Exception;

	[JsonIgnore]
	public bool IsPremium
	{
		get
		{
			if (ValueUsdCents >= RequiredValueUsdCents)
			{
				return RequiredValueUsdCents != 0;
			}
			return false;
		}
	}
}


using System.Collections.Generic;

[JsonModel]
private class PremiumCheckRequest
{
	public List<ulong> SteamIds { get; set; }
}


using System.Collections.Generic;

[JsonModel]
private class PremiumCheckResponse
{
	public Dictionary<ulong, bool> Results { get; set; }
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Models;
using Facepunch.Network;
using Facepunch.Ping;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Ionic.Crc;
using Network;
using Network.Visibility;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Ai.Gen2;
using SilentOrbit.ProtocolBuffers;
using Steamworks;
using UnityEngine;

public class ServerMgr : SingletonComponent<ServerMgr>, IServerCallback
{
	public const string BYPASS_PROCEDURAL_SPAWN_PREF = "bypassProceduralSpawn";

	private ConnectionAuth auth;

	public UserPersistance persistance;

	public PlayerStateManager playerStateManager;

	private AIThinkManager.QueueType aiTick;

	private Stopwatch methodTimer = new Stopwatch();

	private Stopwatch updateTimer = new Stopwatch();

	private RealTimeSinceEx sinceLastPremiumRecheck = 0.0;

	private List<ulong> bannedPlayerNotices = new List<ulong>();

	private string _AssemblyHash;

	public IEnumerator restartCoroutine;

	public static readonly Phrase SERVER_RESTARTING = new Phrase("server.restarting", "Server Restarting!");

	public static readonly Phrase RESTART_INTERRUPTED_PHRASE = new Phrase("server.restart_interrupted", "Server Restart interrupted!");

	public ConnectionQueue connectionQueue = new ConnectionQueue();

	public TimeAverageValueLookup<Type> packetHistory = new TimeAverageValueLookup<Type>();

	public TimeAverageValueLookup<uint> rpcHistory = new TimeAverageValueLookup<uint>();

	private Stopwatch timer = new Stopwatch();

	public bool runFrameUpdate { get; private set; }

	public static int FrameCount { get; private set; }

	public int AvailableSlots => ConVar.Server.maxplayers - BasePlayer.activePlayerList.Count - connectionQueue.ReservedCount;

	private string AssemblyHash
	{
		get
		{
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Expected O, but got Unknown
			if (_AssemblyHash == null)
			{
				string location = typeof(ServerMgr).Assembly.Location;
				if (!string.IsNullOrEmpty(location))
				{
					byte[] array = File.ReadAllBytes(location);
					CRC32 val = new CRC32();
					val.SlurpBlock(array, 0, array.Length);
					_AssemblyHash = val.Crc32Result.ToString("x");
				}
				else
				{
					_AssemblyHash = "il2cpp";
				}
			}
			return _AssemblyHash;
		}
	}

	public bool Restarting => restartCoroutine != null;

	public bool Initialize(bool loadSave = true, string saveFile = "", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)
	{
		Interface.CallHook("OnServerInitialize");
		persistance = new UserPersistance(ConVar.Server.rootFolder);
		playerStateManager = new PlayerStateManager(persistance);
		TutorialIsland.GenerateIslandSpawnPoints(loadingSave: true);
		BasePlayer.InitInternalState();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			TimeWarning val = TimeWarning.New("SpawnHandler.UpdateDistributions", 0);
			try
			{
				SingletonComponent<SpawnHandler>.Instance.UpdateDistributions();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (loadSave)
		{
			World.LoadedFromSave = true;
			World.LoadedFromSave = (skipInitialSpawn = SaveRestore.Load(saveFile, allowOutOfDateSaves));
		}
		else
		{
			SaveRestore.SaveCreatedTime = DateTime.UtcNow;
			World.LoadedFromSave = false;
		}
		if (!World.LoadedFromSave)
		{
			SaveRestore.SpawnMapEntities(SaveRestore.FindMapEntities());
		}
		SaveRestore.InitializeWipeId();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			TimeWarning val;
			if (!skipInitialSpawn)
			{
				val = TimeWarning.New("SpawnHandler.InitialSpawn", 200);
				try
				{
					SingletonComponent<SpawnHandler>.Instance.InitialSpawn();
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			val = TimeWarning.New("SpawnHandler.StartSpawnTick", 200);
			try
			{
				SingletonComponent<SpawnHandler>.Instance.StartSpawnTick();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		CreateImportantEntities();
		auth = ((Component)this).GetComponent<ConnectionAuth>();
		Analytics.Azure.Initialize();
		return World.LoadedFromSave;
	}

	public void OpenConnection(bool useSteamServer = true)
	{
		if (ConVar.Server.queryport <= 0 || ConVar.Server.queryport == ConVar.Server.port)
		{
			ConVar.Server.queryport = Math.Max(ConVar.Server.port, RCon.Port) + 1;
		}
		Net.sv.ip = ConVar.Server.ip;
		Net.sv.port = ConVar.Server.port;
		Net.sv.encryption = ConVar.Server.encryption;
		int num = Application.Manifest?.Features?.MinimumSecureEncryption ?? 2;
		if (CommandLine.HasSwitch("-insecure"))
		{
			Net.sv.secure = false;
			Net.sv.encryption = Mathf.Clamp(ConVar.Server.encryption, 0, 1);
		}
		if (Net.sv.secure && Net.sv.encryption < num)
		{
			Debug.LogWarning((object)$"A server requires a minimum 'encryption' value of {num} to be secure and visible in the server browser. To remain secure, increase your 'encryption' convar to {num} and restart your server.");
			Net.sv.secure = false;
		}
		if (useSteamServer)
		{
			StartSteamServer();
		}
		else
		{
			PlatformService.Instance.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		}
		if (!Net.sv.Start((IServerCallback)(object)this))
		{
			Debug.LogWarning((object)"Couldn't Start Server.");
			CloseConnection();
			return;
		}
		((BaseNetwork)Net.sv).cryptography = (INetworkCryptography)(object)new NetworkCryptographyServer();
		EACServer.DoStartup();
		((MonoBehaviour)this).InvokeRepeating("DoTick", 1f, 1f / (float)ConVar.Server.tickrate);
		((MonoBehaviour)this).InvokeRepeating("DoHeartbeat", 1f, 1f);
		runFrameUpdate = true;
		ConsoleSystem.OnReplicatedVarChanged += OnReplicatedVarChanged;
		Interface.CallHook("IOnServerInitialized");
	}

	public void CloseConnection()
	{
		if (persistance != null)
		{
			persistance.Dispose();
			persistance = null;
		}
		EACServer.DoShutdown();
		Net.sv.callbackHandler = null;
		TimeWarning val = TimeWarning.New("sv.Stop", 0);
		try
		{
			Net.sv.Stop("Shutting Down");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("RCon.Shutdown", 0);
		try
		{
			RCon.Shutdown();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("PlatformService.Shutdown", 0);
		try
		{
			IPlatformService instance = PlatformService.Instance;
			if (instance != null)
			{
				instance.Shutdown();
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("CompanionServer.Shutdown", 0);
		try
		{
			CompanionServer.Server.Shutdown();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("NexusServer.Shutdown", 0);
		try
		{
			NexusServer.Shutdown();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		val = TimeWarning.New("ServerOcclusion.Dispose", 0);
		try
		{
			if (ServerOcclusion.OcclusionEnabled)
			{
				ServerOcclusion.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		ConsoleSystem.OnReplicatedVarChanged -= OnReplicatedVarChanged;
		BasePlayer.DisposeInternalState();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			CloseConnection();
		}
	}

	private void OnApplicationQuit()
	{
		Application.isQuitting = true;
		CloseConnection();
	}

	private void CreateImportantEntities()
	{
		CreateImportantEntity<EnvSync>("assets/bundled/prefabs/system/net_env.prefab");
		CreateImportantEntity<CommunityEntity>("assets/bundled/prefabs/system/server/community.prefab");
		CreateImportantEntity<ResourceDepositManager>("assets/bundled/prefabs/system/server/resourcedepositmanager.prefab");
		CreateImportantEntity<RelationshipManager>("assets/bundled/prefabs/system/server/relationship_manager.prefab");
		if (Clan.enabled)
		{
			CreateImportantEntity<ClanManager>("assets/bundled/prefabs/system/server/clan_manager.prefab");
		}
		CreateImportantEntity<TreeManager>("assets/bundled/prefabs/system/tree_manager.prefab");
		CreateImportantEntity<GlobalNetworkHandler>("assets/bundled/prefabs/system/net_global.prefab");
		CreateImportantEntity<CopyPasteEntity>("assets/bundled/prefabs/system/copy_paste.prefab");
		CreateImportantEntity<BuriedItems>("assets/bundled/prefabs/system/server/buried_items.prefab");
	}

	public void CreateImportantEntity<T>(string prefabName) where T : BaseEntity
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)BaseNetworkable.serverEntities.OfType<T>().FirstOrDefault()))
		{
			Debug.LogWarning((object)("Missing " + typeof(T).Name + " - creating"));
			BaseEntity baseEntity = GameManager.server.CreateEntity(prefabName);
			if ((Object)(object)baseEntity == (Object)null)
			{
				Debug.LogWarning((object)"Couldn't create");
			}
			else
			{
				baseEntity.Spawn();
			}
		}
	}

	private void StartSteamServer()
	{
		PlatformService.Instance.Initialize((IPlatformHooks)(object)RustPlatformHooks.Instance);
		((MonoBehaviour)this).InvokeRepeating("UpdateServerInformation", 2f, 30f);
		((MonoBehaviour)this).InvokeRepeating("UpdateItemDefinitions", 10f, 3600f);
		DebugEx.Log((object)"SteamServer Initialized", (StackTraceLogType)0);
	}

	private void UpdateItemDefinitions()
	{
		Debug.Log((object)"Checking for new Steam Item Definitions..");
		PlatformService.Instance.RefreshItemDefinitions();
	}

	internal void OnValidateAuthTicketResponse(ulong SteamId, ulong OwnerId, AuthResponse Status)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Invalid comparison between Unknown and I4
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Invalid comparison between Unknown and I4
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Invalid comparison between Unknown and I4
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Invalid comparison between Unknown and I4
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if (Auth_Steam.ValidateConnecting(SteamId, OwnerId, Status))
		{
			return;
		}
		Connection val = ((IEnumerable<Connection>)Net.sv.connections).FirstOrDefault((Func<Connection, bool>)((Connection x) => x.userid == SteamId));
		if (val == null)
		{
			Debug.LogWarning((object)$"Steam gave us a {Status} ticket response for unconnected id {SteamId}");
		}
		else if ((int)Status == 2)
		{
			Debug.LogWarning((object)$"Steam gave us a 'ok' ticket response for already connected id {SteamId}");
		}
		else if ((int)Status != 1)
		{
			if (((int)Status == 4 || (int)Status == 3) && !bannedPlayerNotices.Contains(SteamId))
			{
				Interface.CallHook("IOnPlayerBanned", (object)val, (object)Status);
				ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=#fff>SERVER</color> Kicking " + StringEx.EscapeRichText(val.username, false) + " (banned by anticheat)");
				bannedPlayerNotices.Add(SteamId);
			}
			Debug.Log((object)$"Kicking {val.ipaddress}/{val.userid}/{val.username} (Steam Status \"{((object)(AuthResponse)(ref Status)/*cast due to .constrained prefix*/).ToString()}\")");
			val.authStatusSteam = ((object)(AuthResponse)(ref Status)/*cast due to .constrained prefix*/).ToString();
			Net.sv.Kick(val, "Steam: " + ((object)(AuthResponse)(ref Status)/*cast due to .constrained prefix*/).ToString(), false);
		}
	}

	private void Update()
	{
		if (!runFrameUpdate)
		{
			return;
		}
		updateTimer.Restart();
		FrameCount = Time.frameCount;
		Manifest manifest = Application.Manifest;
		if (manifest != null && manifest.Features.ServerAnalytics)
		{
			try
			{
				PerformanceLogging.server.OnFrame();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		TimeWarning val = TimeWarning.New("ServerMgr.Update", 500);
		try
		{
			try
			{
				TimeWarning val2 = TimeWarning.New("EACServer.DoUpdate", 100);
				try
				{
					EACServer.DoUpdate();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex2)
			{
				Debug.LogWarning((object)"Server Exception: EACServer.DoUpdate");
				Debug.LogException(ex2, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BuriedItems.DoUpdate", 100);
				try
				{
					if (Object.op_Implicit((Object)(object)BuriedItems.Instance))
					{
						BuriedItems.Instance.DoUpdate();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex3)
			{
				Debug.LogWarning((object)"Server Exception: BuriedItems.DoUpdate");
				Debug.LogException(ex3, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("PlatformService.Update", 100);
				try
				{
					PlatformService.Instance.Update();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex4)
			{
				Debug.LogWarning((object)"Server Exception: Platform Service Update");
				Debug.LogException(ex4, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BaseMountable.PlayerSyncCycle", 0);
				try
				{
					BaseMountable.PlayerSyncCycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex5)
			{
				Debug.LogWarning((object)"Server Exception: BaseMountable Player Sync Cycle");
				Debug.LogException(ex5, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Net.sv.Cycle", 100);
				try
				{
					methodTimer.Restart();
					((BaseNetwork)Net.sv).Cycle();
					RuntimeProfiler.Net_Cycle = methodTimer.Elapsed;
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex6)
			{
				Debug.LogWarning((object)"Server Exception: Network Cycle");
				Debug.LogException(ex6, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("ServerBuildingManager.Cycle", 0);
				try
				{
					BuildingManager.server.Cycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex7)
			{
				Debug.LogWarning((object)"Server Exception: Building Manager");
				Debug.LogException(ex7, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BasePlayer.ServerCycle", 0);
				try
				{
					bool batchsynctransforms = Physics.batchsynctransforms;
					bool autosynctransforms = Physics.autosynctransforms;
					if (batchsynctransforms && autosynctransforms)
					{
						Physics.autoSyncTransforms = false;
					}
					if (!Physics.autoSyncTransforms)
					{
						methodTimer.Restart();
						Physics.SyncTransforms();
						RuntimeProfiler.Physics_SyncTransforms = methodTimer.Elapsed;
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("CameraRendererManager.Tick", 100);
						try
						{
							CameraRendererManager instance = SingletonComponent<CameraRendererManager>.Instance;
							if ((Object)(object)instance != (Object)null)
							{
								methodTimer.Restart();
								instance.Tick();
								RuntimeProfiler.Companion_Tick = methodTimer.Elapsed;
							}
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex8)
					{
						Debug.LogWarning((object)"Server Exception: CameraRendererManager.Tick");
						Debug.LogException(ex8, (Object)(object)this);
					}
					methodTimer.Restart();
					BasePlayer.ServerCycle(Time.deltaTime);
					RuntimeProfiler.BasePlayer_ServerCycle = methodTimer.Elapsed;
					try
					{
						TimeWarning val3 = TimeWarning.New("FlameTurret.BudgetedUpdate", 0);
						try
						{
							((ObjectWorkQueue<FlameTurret>)FlameTurret.updateFlameTurretQueueServer).RunQueue(0.25);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex9)
					{
						Debug.LogWarning((object)"Server Exception: FlameTurret.BudgetedUpdate");
						Debug.LogException(ex9, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("AutoTurret.BudgetedUpdate", 0);
						try
						{
							((PersistentObjectWorkQueue<AutoTurret>)AutoTurret.updateAutoTurretScanQueue).RunList((double)AutoTurret.auto_turret_budget_ms);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex10)
					{
						Debug.LogWarning((object)"Server Exception: AutoTurret.BudgetedUpdate");
						Debug.LogException(ex10, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("GunTrap.BudgetedUpdate", 0);
						try
						{
							((PersistentObjectWorkQueue<GunTrap>)GunTrap.updateGunTrapWorkQueue).RunList((double)GunTrap.gun_trap_budget_ms);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex11)
					{
						Debug.LogWarning((object)"Server Exception: GunTrap.BudgetedUpdate");
						Debug.LogException(ex11, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("BaseFishingRod.BudgetedUpdate", 0);
						try
						{
							((ObjectWorkQueue<BaseFishingRod>)BaseFishingRod.updateFishingRodQueue).RunQueue(1.0);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex12)
					{
						Debug.LogWarning((object)"Server Exception: BaseFishingRod.BudgetedUpdate");
						Debug.LogException(ex12, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("DroppedItem.BudgetedUpdate", 0);
						try
						{
							((PersistentObjectWorkQueue<DroppedItem>)DroppedItem.underwaterStatusQueue).RunList((double)DroppedItem.underwater_drag_budget_ms);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex13)
					{
						Debug.LogWarning((object)"Server Exception: DroppedItem.BudgetedUpdate");
						Debug.LogException(ex13, (Object)(object)this);
					}
					try
					{
						TimeWarning val3 = TimeWarning.New("ItemModFoodSpoiling.BudgetedUpdate", 0);
						try
						{
							if (ConVar.Server.foodSpoiling)
							{
								((PersistentObjectWorkQueue<Item>)ItemModFoodSpoiling.foodSpoilItems).RunList((double)ConVar.Server.foodSpoilingBudgetMs);
							}
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex14)
					{
						Debug.LogWarning((object)"Server Exception: ItemModFoodSpoiling.BudgetedUpdate");
						Debug.LogException(ex14, (Object)(object)this);
					}
					if (batchsynctransforms && autosynctransforms)
					{
						Physics.autoSyncTransforms = true;
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex15)
			{
				Debug.LogWarning((object)"Server Exception: Player Update");
				Debug.LogException(ex15, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("connectionQueue.Cycle", 0);
				try
				{
					connectionQueue.Cycle(AvailableSlots);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex16)
			{
				Debug.LogWarning((object)"Server Exception: Connection Queue");
				Debug.LogException(ex16, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("IOEntity.ProcessQueue", 0);
				try
				{
					IOEntity.ProcessQueue();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex17)
			{
				Debug.LogWarning((object)"Server Exception: IOEntity.ProcessQueue");
				Debug.LogException(ex17, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("NpcManagers.Tick", 0);
				try
				{
					if ((Object)(object)SingletonComponent<NpcFireManager>.Instance != (Object)null)
					{
						SingletonComponent<NpcFireManager>.Instance.Tick();
					}
					if ((Object)(object)SingletonComponent<NpcNoiseManager>.Instance != (Object)null)
					{
						SingletonComponent<NpcNoiseManager>.Instance.Tick();
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex18)
			{
				Debug.LogWarning((object)"Server Exception: NpcManagers.Tick");
				Debug.LogException(ex18, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("FSMComponent.BudgetedUpdate", 0);
				try
				{
					((PersistentObjectWorkQueue<FSMComponent>)FSMComponent.workQueue).RunList(0.5);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex19)
			{
				Debug.LogWarning((object)"Server Exception: FSMComponent.BudgetedUpdate");
				Debug.LogException(ex19, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("LimitedTurnNavAgent.TickSteering", 0);
				try
				{
					LimitedTurnNavAgent.TickSteering();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex20)
			{
				Debug.LogWarning((object)"Server Exception: LimitedTurnNavAgent.TickSteering");
				Debug.LogException(ex20, (Object)(object)this);
			}
			if (!AI.spliceupdates)
			{
				aiTick = AIThinkManager.QueueType.Human;
			}
			else
			{
				aiTick = ((aiTick == AIThinkManager.QueueType.Human) ? AIThinkManager.QueueType.Animal : AIThinkManager.QueueType.Human);
			}
			if (aiTick == AIThinkManager.QueueType.Human)
			{
				try
				{
					TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessQueue", 0);
					try
					{
						AIThinkManager.ProcessQueue(AIThinkManager.QueueType.Human);
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				catch (Exception ex21)
				{
					Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessQueue");
					Debug.LogException(ex21, (Object)(object)this);
				}
				if (!AI.spliceupdates)
				{
					aiTick = AIThinkManager.QueueType.Animal;
				}
			}
			if (aiTick == AIThinkManager.QueueType.Animal)
			{
				try
				{
					TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessAnimalQueue", 0);
					try
					{
						AIThinkManager.ProcessQueue(AIThinkManager.QueueType.Animal);
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				catch (Exception ex22)
				{
					Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessAnimalQueue");
					Debug.LogException(ex22, (Object)(object)this);
				}
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessPetQueue", 0);
				try
				{
					AIThinkManager.ProcessQueue(AIThinkManager.QueueType.Pets);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex23)
			{
				Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessPetQueue");
				Debug.LogException(ex23, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("AIThinkManager.ProcessPetMovementQueue", 0);
				try
				{
					BasePet.ProcessMovementQueue();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex24)
			{
				Debug.LogWarning((object)"Server Exception: AIThinkManager.ProcessPetMovementQueue");
				Debug.LogException(ex24, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BaseSculpture.ProcessGridUpdates", 0);
				try
				{
					BaseSculpture.ProcessGridUpdates();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex25)
			{
				Debug.LogWarning((object)"Server Exception: BaseSculpture.ProcessGridUpdates");
				Debug.LogException(ex25, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("GrowableEntity.BudgetedUpdate", 0);
				try
				{
					((ObjectWorkQueue<GrowableEntity>)GrowableEntity.growableEntityUpdateQueue).RunQueue((double)GrowableEntity.framebudgetms);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex26)
			{
				Debug.LogWarning((object)"Server Exception: GrowableEntity.BudgetedUpdate");
				Debug.LogException(ex26, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("BasePlayer.BudgetedLifeStoryUpdate", 0);
				try
				{
					((ObjectWorkQueue<BasePlayer>)BasePlayer.lifeStoryQueue).RunQueue((double)BasePlayer.lifeStoryFramebudgetms);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex27)
			{
				Debug.LogWarning((object)"Server Exception: BasePlayer.BudgetedLifeStoryUpdate");
				Debug.LogException(ex27, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("JunkPileWater.UpdateNearbyPlayers", 0);
				try
				{
					((ObjectWorkQueue<JunkPileWater>)JunkPileWater.junkpileWaterWorkQueue).RunQueue((double)JunkPileWater.framebudgetms);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex28)
			{
				Debug.LogWarning((object)"Server Exception: JunkPileWater.UpdateNearbyPlayers");
				Debug.LogException(ex28, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("IndustrialEntity.RunQueue", 0);
				try
				{
					if (!SaveRestore.IsSaving || !ConVar.Server.pauseindustrialduringsave)
					{
						((ObjectWorkQueue<IndustrialEntity>)IndustrialEntity.Queue).RunQueue((double)ConVar.Server.industrialFrameBudgetMs);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex29)
			{
				Debug.LogWarning((object)"Server Exception: IndustrialEntity.RunQueue");
				Debug.LogException(ex29, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Hopper.WorkQueue", 0);
				try
				{
					((PersistentObjectWorkQueue<Hopper>)Hopper.WorkQueue).RunList((double)ConVar.Server.hopperAnimationBudgetMs);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex30)
			{
				Debug.LogWarning((object)"Server Exception: Hopper.WorkQueue");
				Debug.LogException(ex30, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("AntiHack.Cycle", 0);
				try
				{
					AntiHack.Cycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex31)
			{
				Debug.LogWarning((object)"Server Exception: AntiHack.Cycle");
				Debug.LogException(ex31, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("TreeManager.SendPendingTrees", 0);
				try
				{
					TreeManager.server.SendPendingTrees();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex32)
			{
				Debug.LogWarning((object)"Server Exception: TreeManager.SendPendingTrees");
				Debug.LogException(ex32, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("ChickenCoop.CoopWorkQueue", 0);
				try
				{
					((ObjectWorkQueue<ChickenCoop>)ChickenCoop.CoopWorkQueue).RunQueue(0.10000000149011612);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex33)
			{
				Debug.LogWarning((object)"Server Exception: ChickenCoop.CoopWorkQueue");
				Debug.LogException(ex33, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("FarmableAnimal.NeedsWorkQueue", 0);
				try
				{
					((ObjectWorkQueue<FarmableAnimal>)FarmableAnimal.NeedsWorkQueue).RunQueue(0.10000000149011612);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex34)
			{
				Debug.LogWarning((object)"Server Exception: FarmableAnimal.NeedsWorkQueue");
				Debug.LogException(ex34, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Chicken.EggWorkQueue", 0);
				try
				{
					((ObjectWorkQueue<Chicken>)Chicken.EggWorkQueue).RunQueue(0.10000000149011612);
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex35)
			{
				Debug.LogWarning((object)"Server Exception: Chicken.EggWorkQueue");
				Debug.LogException(ex35, (Object)(object)this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		RuntimeProfiler.ServerMgr_Update = updateTimer.Elapsed;
	}

	private void LateUpdate()
	{
		if (!runFrameUpdate)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("ServerMgr.LateUpdate", 500);
		try
		{
			if (!SteamNetworking.steamnagleflush)
			{
				return;
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Connection.Flush", 0);
				try
				{
					for (int i = 0; i < Net.sv.connections.Count; i++)
					{
						Net.sv.Flush(Net.sv.connections[i]);
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)"Server Exception: Connection.Flush");
				Debug.LogException(ex, (Object)(object)this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void FixedUpdate()
	{
		TimeWarning val = TimeWarning.New("ServerMgr.FixedUpdate", 0);
		try
		{
			try
			{
				TimeWarning val2 = TimeWarning.New("BaseMountable.FixedUpdateCycle", 0);
				try
				{
					BaseMountable.FixedUpdateCycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex)
			{
				Debug.LogWarning((object)"Server Exception: Mountable Cycle");
				Debug.LogException(ex, (Object)(object)this);
			}
			try
			{
				TimeWarning val2 = TimeWarning.New("Buoyancy.Cycle", 0);
				try
				{
					Buoyancy.Cycle();
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
			}
			catch (Exception ex2)
			{
				Debug.LogWarning((object)"Server Exception: Buoyancy Cycle");
				Debug.LogException(ex2, (Object)(object)this);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void DoTick()
	{
		Interface.CallHook("OnTick");
		RCon.Update();
		CompanionServer.Server.Update();
		NexusServer.Update();
		for (int i = 0; i < Net.sv.connections.Count; i++)
		{
			Connection val = Net.sv.connections[i];
			if (!val.isAuthenticated && !(val.GetSecondsConnected() < (float)ConVar.Server.authtimeout))
			{
				Net.sv.Kick(val, "Authentication Timed Out", false);
			}
		}
		float num = Mathf.Max(ConVar.Server.premiumRecheckInterval, 60f);
		if (ConVar.Server.premium && (double)sinceLastPremiumRecheck > (double)num)
		{
			sinceLastPremiumRecheck = 0.0;
			RecheckPremiumStatus();
		}
	}

	private void DoHeartbeat()
	{
		ItemManager.Heartbeat();
	}

	private void RecheckPremiumStatus()
	{
		float num = Mathf.Clamp(ConVar.Server.premiumRecheckMinSeconds, 60f, 1800f);
		double num2 = Time.realtimeSinceStartupAsDouble - (double)num;
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection connection in Net.sv.connections)
		{
			if (connection.connected && connection.lastPremiumCheckTime < num2)
			{
				list.Add(connection);
			}
		}
		if (list.Count == 0)
		{
			Pool.FreeUnmanaged<Connection>(ref list);
			return;
		}
		list.Sort((Connection x, Connection y) => x.lastPremiumCheckTime.CompareTo(y.lastPremiumCheckTime));
		int num3 = Mathf.Clamp(ConVar.Server.premiumRecheckMaxBatchSize, 10, 500);
		if (list.Count > num3)
		{
			list.RemoveRange(num3, list.Count - num3);
		}
		RecheckPremiumStatusImpl(list);
		static async void RecheckPremiumStatusImpl(List<Connection> connections)
		{
			try
			{
				List<ulong> steamIds = Pool.Get<List<ulong>>();
				foreach (Connection connection2 in connections)
				{
					steamIds.Add(connection2.userid);
				}
				Dictionary<ulong, bool> dictionary = await PremiumUtil.CheckIfPlayersArePremium(steamIds);
				Pool.FreeUnmanaged<ulong>(ref steamIds);
				double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
				foreach (Connection connection3 in connections)
				{
					if (connection3.connected)
					{
						if (!dictionary.TryGetValue(connection3.userid, out var value))
						{
							Debug.LogWarning((object)$"Missing premium status for {connection3.userid}");
						}
						else
						{
							connection3.lastPremiumCheckTime = realtimeSinceStartupAsDouble;
							if (!value && BasePlayer.TryFindByID(connection3.userid, out var basePlayer))
							{
								basePlayer.Kick("premium_account_required", reserveSlot: false);
							}
						}
					}
				}
				Pool.FreeUnmanaged<Connection>(ref connections);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)"Error rechecking premium status for connected players");
				Debug.LogException(ex);
			}
		}
	}

	private static BaseGameMode Gamemode()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (!((Object)(object)activeGameMode != (Object)null))
		{
			return null;
		}
		return activeGameMode;
	}

	public static string GamemodeName()
	{
		return Gamemode()?.shortname ?? "rust";
	}

	public static string GamemodeTitle()
	{
		return Gamemode()?.gamemodeTitle ?? "Survival";
	}

	private void UpdateServerInformation()
	{
		if (!SteamServer.IsValid)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateServerInformation", 0);
		try
		{
			SteamServer.ServerName = ConVar.Server.hostname;
			SteamServer.MaxPlayers = ConVar.Server.maxplayers;
			SteamServer.Passworded = false;
			SteamServer.MapName = World.GetServerBrowserMapName();
			string text = "stok";
			if (Restarting)
			{
				text = "strst";
			}
			string text2 = $"born{Epoch.FromDateTime(SaveRestore.SaveCreatedTime)}";
			string text3 = $"gm{GamemodeName()}";
			if (text3 != "gmrust" && text3 != "gmvanilla")
			{
				ConVar.Server.tags = ConVar.Server.tags.Replace("vanilla", "");
			}
			string text4 = (ConVar.Server.pve ? ",pve" : string.Empty);
			string text5 = ConVar.Server.tags?.Trim(',') ?? "";
			string text6 = ((!string.IsNullOrWhiteSpace(text5)) ? ("," + text5) : "");
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj == null)
			{
				obj = "0";
			}
			string text7 = (string)obj;
			string text8 = (ConVar.Server.premium ? ",premium" : "");
			string text9 = PingEstimater.GetCachedClosestRegion().Code;
			if (!string.IsNullOrEmpty(ConVar.Server.ping_region_code_override))
			{
				text9 = ConVar.Server.ping_region_code_override;
			}
			SteamServer.GameTags = ServerTagCompressor.CompressTags($"mp{ConVar.Server.maxplayers},cp{BasePlayer.activePlayerList.Count},pt{Net.sv.ProtocolId},qp{SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued},$r{text9},v{2597}{text4}{text6},{text2},{text3},cs{text7}{text8},ts{RelationshipManager.maxTeamSize}");
			if (ConVar.Server.description != null && ConVar.Server.description.Length > 100)
			{
				string[] array = StringEx.SplitToChunks(ConVar.Server.description, 100).ToArray();
				for (int i = 0; i < 16; i++)
				{
					if (i < array.Length)
					{
						SteamServer.SetKey($"description_{i:00}", array[i]);
					}
					else
					{
						SteamServer.SetKey($"description_{i:00}", string.Empty);
					}
				}
			}
			else
			{
				SteamServer.SetKey("description_0", ConVar.Server.description);
				for (int j = 1; j < 16; j++)
				{
					SteamServer.SetKey($"description_{j:00}", string.Empty);
				}
			}
			SteamServer.SetKey("hash", AssemblyHash);
			SteamServer.SetKey("status", text);
			string text10 = World.Seed.ToString();
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			if ((Object)(object)activeGameMode != (Object)null && (!activeGameMode.ingameMap || activeGameMode.fogOfWar))
			{
				text10 = "0";
			}
			SteamServer.SetKey("world.seed", text10);
			SteamServer.SetKey("world.size", World.Size.ToString());
			SteamServer.SetKey("pve", ConVar.Server.pve.ToString());
			SteamServer.SetKey("headerimage", ConVar.Server.headerimage);
			SteamServer.SetKey("logoimage", ConVar.Server.logoimage);
			SteamServer.SetKey("url", ConVar.Server.url);
			SteamServer.SetKey("map_image_url", MapUploader.ImageUrl);
			if (!string.IsNullOrWhiteSpace(ConVar.Server.favoritesEndpoint))
			{
				SteamServer.SetKey("favendpoint", ConVar.Server.favoritesEndpoint);
			}
			SteamServer.SetKey("gmn", GamemodeName());
			SteamServer.SetKey("gmt", GamemodeTitle());
			SteamServer.SetKey("uptime", ((int)Time.realtimeSinceStartup).ToString());
			SteamServer.SetKey("gc_mb", Performance.report.memoryAllocations.ToString());
			SteamServer.SetKey("gc_cl", Performance.report.memoryCollections.ToString());
			SteamServer.SetKey("ram_sys", (Performance.report.memoryUsageSystem / 1000000).ToString());
			SteamServer.SetKey("fps", Performance.report.frameRate.ToString());
			SteamServer.SetKey("fps_avg", Performance.report.frameRateAverage.ToString("0.00"));
			SteamServer.SetKey("ent_cnt", BaseNetworkable.serverEntities.Count.ToString());
			SteamServer.SetKey("build", BuildInfo.Current.Scm.ChangeId);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		Interface.CallHook("OnServerInformationUpdated");
	}

	public void OnDisconnected(string strReason, Connection connection)
	{
		Analytics.Azure.OnPlayerDisconnected(connection, strReason);
		GlobalNetworkHandler.server.OnClientDisconnected(connection);
		connectionQueue.TryAddReservedSlot(connection);
		connectionQueue.RemoveConnection(connection);
		ConnectionAuth.OnDisconnect(connection);
		if (connection.authStatusSteam == "ok")
		{
			PlatformService.Instance.EndPlayerSession(connection.userid);
		}
		EACServer.OnLeaveGame(connection);
		BasePlayer basePlayer = connection.player as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			Interface.CallHook("OnPlayerDisconnected", (object)basePlayer, (object)strReason);
			basePlayer.OnDisconnected();
		}
		if (connection.authStatusNexus == "ok")
		{
			NexusServer.Logout(connection.userid);
		}
	}

	public static void OnEnterVisibility(Connection connection, Group group)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)19);
			obj.GroupID(group.ID);
			obj.Send(new SendInfo(connection));
		}
	}

	public static void OnLeaveVisibility(Connection connection, Group group)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)20);
			obj.GroupID(group.ID);
			obj.Send(new SendInfo(connection));
			NetWrite obj2 = ((BaseNetwork)Net.sv).StartWrite();
			obj2.PacketID((Type)8);
			obj2.GroupID(group.ID);
			obj2.Send(new SendInfo(connection));
		}
	}

	public static BasePlayer.SpawnPoint FindSpawnPoint(BasePlayer forPlayer = null, ulong teamId = 0uL)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnFindSpawnPoint", (object)forPlayer, (object)teamId);
		if (obj is BasePlayer.SpawnPoint)
		{
			return (BasePlayer.SpawnPoint)obj;
		}
		bool flag = false;
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				BasePlayer.SpawnPoint spawnPoint = new BasePlayer.SpawnPoint();
				if (forPlayer.CurrentTutorialAllowance > BasePlayer.TutorialItemAllowance.Level1_HatchetPickaxe)
				{
					spawnPoint.pos = currentTutorialIsland.MidMissionSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.MidMissionSpawnPoint.rotation;
				}
				else
				{
					spawnPoint.pos = currentTutorialIsland.InitialSpawnPoint.position;
					spawnPoint.rot = currentTutorialIsland.InitialSpawnPoint.rotation;
				}
				return spawnPoint;
			}
		}
		BaseGameMode baseGameMode = Gamemode();
		if (Object.op_Implicit((Object)(object)baseGameMode) && baseGameMode.useCustomSpawns)
		{
			BasePlayer.SpawnPoint playerSpawn = baseGameMode.GetPlayerSpawn(forPlayer);
			if (playerSpawn != null)
			{
				return playerSpawn;
			}
		}
		if ((Object)(object)SingletonComponent<SpawnHandler>.Instance != (Object)null && !flag)
		{
			BasePlayer.SpawnPoint spawnPointForTeam = SpawnHandler.GetSpawnPointForTeam(teamId);
			if (spawnPointForTeam != null)
			{
				spawnPointForTeam.isProcedualSpawn = true;
				return spawnPointForTeam;
			}
			BasePlayer.SpawnPoint spawnPoint2 = SpawnHandler.GetSpawnPoint();
			if (spawnPoint2 != null)
			{
				spawnPoint2.isProcedualSpawn = true;
				return spawnPoint2;
			}
		}
		BasePlayer.SpawnPoint spawnPoint3 = new BasePlayer.SpawnPoint();
		if ((Object)(object)forPlayer != (Object)null && forPlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland2 = forPlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland2 != (Object)null)
			{
				spawnPoint3.pos = currentTutorialIsland2.InitialSpawnPoint.position;
				spawnPoint3.rot = currentTutorialIsland2.InitialSpawnPoint.rotation;
				return spawnPoint3;
			}
		}
		GameObject[] array = GameObject.FindGameObjectsWithTag("spawnpoint");
		if (array.Length != 0)
		{
			GameObject val = array[Random.Range(0, array.Length)];
			spawnPoint3.pos = val.transform.position;
			spawnPoint3.rot = val.transform.rotation;
		}
		else
		{
			Debug.Log((object)"Couldn't find an appropriate spawnpoint for the player - so spawning at camera");
			if ((Object)(object)MainCamera.mainCamera != (Object)null)
			{
				spawnPoint3.pos = MainCamera.position;
				spawnPoint3.rot = MainCamera.rotation;
			}
		}
		RaycastHit val2 = default(RaycastHit);
		if (Physics.Raycast(new Ray(spawnPoint3.pos, Vector3.down), ref val2, 32f, 1537286401))
		{
			spawnPoint3.pos = ((RaycastHit)(ref val2)).point;
		}
		return spawnPoint3;
	}

	public void JoinGame(Connection connection)
	{
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		Approval val = Pool.Get<Approval>();
		try
		{
			uint num = (uint)Net.sv.encryption;
			if (num > 1 && connection.os == "editor" && DeveloperList.Contains(connection.ownerid))
			{
				num = 1u;
			}
			if (num > 1 && !Net.sv.secure)
			{
				num = 1u;
			}
			val.level = Application.loadedLevelName;
			val.levelConfig = World.Config.JsonString;
			val.levelTransfer = World.Transfer;
			val.levelUrl = World.Url;
			val.levelSeed = World.Seed;
			val.levelSize = World.Size;
			val.checksum = World.Checksum;
			val.hostname = ConVar.Server.hostname;
			val.official = ConVar.Server.official;
			val.encryption = num;
			val.version = BuildInfo.Current.Scm.Branch + "#" + BuildInfo.Current.Scm.ChangeId;
			val.nexus = World.Nexus;
			val.nexusEndpoint = Nexus.endpoint;
			val.nexusId = NexusServer.NexusId.GetValueOrDefault();
			NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
			val2.PacketID((Type)3);
			ProtoStreamExtensions.WriteToStream((IProto)(object)val, (Stream)(object)val2, false, 2097152);
			val2.Send(new SendInfo(connection));
			connection.encryptionLevel = num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		connection.connected = true;
	}

	internal void Shutdown()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("IOnServerShutdown");
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Server Shutting Down");
		}
		ConsoleSystem.Run(Option.Server, "server.save", Array.Empty<object>());
		ConsoleSystem.Run(Option.Server, "server.writecfg", Array.Empty<object>());
	}

	private static void ShowToastToAllClients(GameTip.Styles style, Phrase phrase, bool overlay = false, params string[] arguments)
	{
		ConsoleNetwork.BroadcastToAllClients("gametip.showtoast_translated", (int)style, phrase.token, phrase.english, overlay, arguments);
	}

	private IEnumerator ServerRestartWarning(string info, int iSeconds)
	{
		if (iSeconds < 0)
		{
			yield break;
		}
		for (int i = iSeconds; i > 0; i--)
		{
			if (i == iSeconds || i % 60 == 0 || (i < 300 && i % 30 == 0) || (i < 60 && i % 10 == 0) || i < 10)
			{
				ConsoleNetwork.BroadcastToAllClients("baseplayer.showserverrestartwarning", i, info);
				Debug.Log((object)$"Restarting in {i} seconds");
			}
			yield return CoroutineEx.waitForSeconds(1f);
		}
		ShowToastToAllClients(GameTip.Styles.Server_Event, SERVER_RESTARTING, false);
		yield return CoroutineEx.waitForSeconds(2f);
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int j = 0; j < array.Length; j++)
		{
			array[j].Kick("Server Restarting");
		}
		yield return CoroutineEx.waitForSeconds(1f);
		ConsoleSystem.Run(Option.Server, "quit", Array.Empty<object>());
	}

	public static void RestartServer(string strNotice, int iSeconds)
	{
		if ((Object)(object)SingletonComponent<ServerMgr>.Instance == (Object)null)
		{
			return;
		}
		if (SingletonComponent<ServerMgr>.Instance.restartCoroutine != null)
		{
			if (Interface.CallHook("OnServerRestartInterrupt") != null)
			{
				return;
			}
			ShowToastToAllClients(GameTip.Styles.Server_Event, RESTART_INTERRUPTED_PHRASE, false);
			((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StopCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = null;
		}
		if (Interface.CallHook("OnServerRestart", (object)strNotice, (object)iSeconds) == null)
		{
			SingletonComponent<ServerMgr>.Instance.restartCoroutine = SingletonComponent<ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);
			((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(SingletonComponent<ServerMgr>.Instance.restartCoroutine);
			SingletonComponent<ServerMgr>.Instance.UpdateServerInformation();
		}
	}

	public static void SendReplicatedVars(string filter)
	{
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection connection in Net.sv.connections)
		{
			if (connection.connected)
			{
				list.Add(connection);
			}
		}
		List<Command> list2 = Pool.Get<List<Command>>();
		foreach (Command item in Server.Replicated)
		{
			if (item.FullName.StartsWith(filter))
			{
				list2.Add(item);
			}
		}
		val.PacketID((Type)25);
		val.Int32(list2.Count);
		foreach (Command item2 in list2)
		{
			val.String(item2.FullName, false);
			val.String(item2.String, false);
		}
		val.Send(new SendInfo(list));
		Pool.FreeUnmanaged<Command>(ref list2);
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	public static void SendReplicatedVars(Connection connection)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		List<Command> replicated = Server.Replicated;
		val.PacketID((Type)25);
		val.Int32(replicated.Count);
		foreach (Command item in replicated)
		{
			val.String(item.FullName, false);
			val.String(item.String, false);
		}
		val.Send(new SendInfo(connection));
	}

	private static void OnReplicatedVarChanged(string fullName, string value)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
		List<Connection> list = Pool.Get<List<Connection>>();
		foreach (Connection connection in Net.sv.connections)
		{
			if (connection.connected)
			{
				list.Add(connection);
			}
		}
		val.PacketID((Type)25);
		val.Int32(1);
		val.String(fullName, false);
		val.String(value, false);
		val.Send(new SendInfo(list));
		Pool.FreeUnmanaged<Connection>(ref list);
	}

	void IServerCallback.RequestSave(Stream stream)
	{
		SaveRestore.RequestSave(stream);
	}

	void IServerCallback.AddOnSaveCallback(Action<Stream> callback)
	{
		SaveRestore.AddOnSaveCallback(callback);
	}

	void IServerCallback.RemoveOnSaveCallback(Action<Stream> callback)
	{
		SaveRestore.RemoveOnSaveCallback(callback);
	}

	ServerInfo IServerCallback.GetServerInfo()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		ServerInfo result = default(ServerInfo);
		result.NetworkVersion = 2597;
		BuildInfo current = BuildInfo.Current;
		object obj;
		if (current == null)
		{
			obj = null;
		}
		else
		{
			ScmInfo scm = current.Scm;
			obj = ((scm != null) ? scm.ChangeId : null);
		}
		if (obj == null)
		{
			obj = "0";
		}
		result.Changeset = (string)obj;
		result.Hostname = ConVar.Server.hostname;
		result.Seed = World.Seed;
		result.WorldSize = World.Size;
		result.Level = LevelManager.CurrentLevelName;
		result.LevelUrl = World.Url;
		result.Checksum = World.Checksum;
		return result;
	}

	private void Log(Exception e)
	{
		if (Global.developer > 0)
		{
			Debug.LogException(e);
		}
	}

	public void OnNetworkMessage(Message packet)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0417: Unknown result type (might be due to invalid IL or missing references)
		//IL_0587: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Invalid comparison between Unknown and I4
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected I4, but got Unknown
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Expected I4, but got Unknown
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0481: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Server.packetlog_enabled)
		{
			packetHistory.Increment(packet.type);
		}
		if (PacketProfiler.enabled)
		{
			PacketProfiler.LogInbound(packet.type, (int)((Stream)(object)packet.read).Length);
		}
		Type type = packet.type;
		if ((int)type != 4)
		{
			switch (type - 9)
			{
			default:
				switch (type - 18)
				{
				case 0:
				{
					if (packet.connection.GetPacketsPerSecond(packet.type) >= 1)
					{
						Net.sv.Kick(packet.connection, "Packet Flooding: User Information", packet.connection.connected);
						return;
					}
					TimeWarning val = TimeWarning.New("GiveUserInformation", 20);
					try
					{
						OnGiveUserInformation(packet);
					}
					catch (Exception e4)
					{
						Log(e4);
						Net.sv.Kick(packet.connection, "Invalid Packet: User Information", false);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
					packet.connection.AddPacketsPerSecond(packet.type);
					return;
				}
				case 4:
				{
					TimeWarning val = TimeWarning.New("OnEACMessage", 20);
					try
					{
						EACServer.OnMessageReceived(packet);
						return;
					}
					catch (Exception e6)
					{
						Log(e6);
						Net.sv.Kick(packet.connection, "Invalid Packet: EAC", false);
						return;
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				case 6:
				{
					if (!World.Transfer || !packet.connection.connected)
					{
						return;
					}
					if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_world)
					{
						Net.sv.Kick(packet.connection, "Packet Flooding: World", packet.connection.connected);
						return;
					}
					TimeWarning val = TimeWarning.New("OnWorldMessage", 20);
					try
					{
						WorldNetworking.OnMessageReceived(packet);
						return;
					}
					catch (Exception e5)
					{
						Log(e5);
						Net.sv.Kick(packet.connection, "Invalid Packet: World", false);
						return;
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
				}
				case 3:
				{
					if (!packet.connection.connected)
					{
						return;
					}
					if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_voice)
					{
						Net.sv.Kick(packet.connection, "Packet Flooding: Disconnect Reason", packet.connection.connected);
						return;
					}
					TimeWarning val = TimeWarning.New("OnPlayerVoice", 20);
					try
					{
						OnPlayerVoice(packet);
					}
					catch (Exception e3)
					{
						Log(e3);
						Net.sv.Kick(packet.connection, "Invalid Packet: Player Voice", false);
					}
					finally
					{
						((IDisposable)val)?.Dispose();
					}
					packet.connection.AddPacketsPerSecond(packet.type);
					return;
				}
				}
				break;
			case 0:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_rpc)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: RPC Message", false);
					return;
				}
				TimeWarning val = TimeWarning.New("OnRPCMessage", 20);
				try
				{
					OnRPCMessage(packet);
				}
				catch (Exception e8)
				{
					Log(e8);
					Net.sv.Kick(packet.connection, "Invalid Packet: RPC Message", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 3:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_command)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: Client Command", packet.connection.connected);
					return;
				}
				TimeWarning val = TimeWarning.New("OnClientCommand", 20);
				try
				{
					ConsoleNetwork.OnClientCommand(packet);
				}
				catch (Exception e7)
				{
					Log(e7);
					Net.sv.Kick(packet.connection, "Invalid Packet: Client Command", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 5:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= 1)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: Disconnect Reason", packet.connection.connected);
					return;
				}
				TimeWarning val = TimeWarning.New("ReadDisconnectReason", 20);
				try
				{
					ReadDisconnectReason(packet);
					Net.sv.Disconnect(packet.connection);
				}
				catch (Exception e2)
				{
					Log(e2);
					Net.sv.Kick(packet.connection, "Invalid Packet: Disconnect Reason", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 6:
			{
				if (!packet.connection.connected)
				{
					return;
				}
				if (packet.connection.GetPacketsPerSecond(packet.type) >= (ulong)ConVar.Server.maxpacketspersecond_tick)
				{
					Net.sv.Kick(packet.connection, "Packet Flooding: Player Tick", packet.connection.connected);
					return;
				}
				TimeWarning val = TimeWarning.New("OnPlayerTick", 20);
				try
				{
					OnPlayerTick(packet);
				}
				catch (Exception e)
				{
					Log(e);
					Net.sv.Kick(packet.connection, "Invalid Packet: Player Tick", false);
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
				packet.connection.AddPacketsPerSecond(packet.type);
				return;
			}
			case 1:
			case 2:
			case 4:
				break;
			}
			ProcessUnhandledPacket(packet);
		}
		else
		{
			if (!packet.connection.connected)
			{
				return;
			}
			if (packet.connection.GetPacketsPerSecond(packet.type) >= 1)
			{
				Net.sv.Kick(packet.connection, "Packet Flooding: Client Ready", packet.connection.connected);
				return;
			}
			TimeWarning val = TimeWarning.New("ClientReady", 20);
			try
			{
				ClientReady(packet);
			}
			catch (Exception e9)
			{
				Log(e9);
				Net.sv.Kick(packet.connection, "Invalid Packet: Client Ready", false);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
			packet.connection.AddPacketsPerSecond(packet.type);
		}
	}

	public void ProcessUnhandledPacket(Message packet)
	{
		if (Global.developer > 0)
		{
			Debug.LogWarning((object)("[SERVER][UNHANDLED] " + ((object)(Type)(ref packet.type)/*cast due to .constrained prefix*/).ToString()));
		}
		Net.sv.Kick(packet.connection, "Sent Unhandled Message", false);
	}

	public void ReadDisconnectReason(Message packet)
	{
		string text = packet.read.String(4096, false);
		string text2 = ((object)packet.connection).ToString();
		if (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))
		{
			Interface.CallHook("OnClientDisconnect", (object)packet.connection, (object)text);
			DebugEx.Log((object)(text2 + " disconnecting: " + text), (StackTraceLogType)0);
		}
	}

	private BasePlayer SpawnPlayerSleeping(Connection connection)
	{
		BasePlayer basePlayer = BasePlayer.FindSleeping(connection.userid);
		if ((Object)(object)basePlayer == (Object)null)
		{
			return null;
		}
		if (!basePlayer.IsSleeping())
		{
			Debug.LogWarning((object)"Player spawning into sleeper that isn't sleeping!");
			basePlayer.Kill();
			return null;
		}
		basePlayer.PlayerInit(connection);
		basePlayer.inventory.SendSnapshot();
		DebugEx.Log((object)(((object)basePlayer.net.connection).ToString() + " joined [" + basePlayer.net.connection.os + "/" + basePlayer.net.connection.ownerid + "]"), (StackTraceLogType)0);
		return basePlayer;
	}

	public BasePlayer SpawnNewPlayer(Connection connection)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(connection.userid);
		BasePlayer.SpawnPoint spawnPoint = FindSpawnPoint(null, playerTeam?.teamID ?? 0);
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", spawnPoint.pos, spawnPoint.rot).ToPlayer();
		if (Interface.CallHook("OnPlayerSpawn", (object)basePlayer, (object)connection) != null)
		{
			return (BasePlayer)(object)spawnPoint;
		}
		basePlayer.health = 0f;
		basePlayer.lifestate = BaseCombatEntity.LifeState.Dead;
		basePlayer.ResetLifeStateOnSpawn = false;
		basePlayer.limitNetworking = true;
		if (connection == null)
		{
			basePlayer.EnableTransferProtection();
		}
		basePlayer.Spawn();
		basePlayer.limitNetworking = false;
		if (connection != null)
		{
			basePlayer.PlayerInit(connection);
			PooledList<SleepingBag> val = SleepingBag.FindForPlayer(basePlayer.userID);
			try
			{
				bool flag = Application.isEditor || (((List<SleepingBag>)(object)val).Count == 0 && !basePlayer.hasPreviousLife);
				if (Object.op_Implicit((Object)(object)BaseGameMode.GetActiveGameMode(serverside: true)))
				{
					BaseGameMode.GetActiveGameMode(serverside: true).OnNewPlayer(basePlayer, flag);
				}
				else if (flag)
				{
					basePlayer.Respawn();
				}
				DebugEx.Log((object)$"{basePlayer.displayName} with steamid {basePlayer.userID.Get()} joined from ip {basePlayer.net.connection.ipaddress}", (StackTraceLogType)0);
				DebugEx.Log((object)$"\tNetworkId {basePlayer.userID.Get()} is {basePlayer.net.ID} ({basePlayer.displayName})", (StackTraceLogType)0);
				if (basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
				{
					DebugEx.Log((object)$"\t{basePlayer} is sharing the account {basePlayer.net.connection.ownerid}", (StackTraceLogType)0);
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (playerTeam != null && playerTeam.usePartySpawn && spawnPoint.isProcedualSpawn && playerTeam.firstSpawnLocation == default(Vector3))
		{
			playerTeam.firstSpawnLocation = spawnPoint.pos;
		}
		return basePlayer;
	}

	private void ClientReady(Message packet)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Invalid comparison between Unknown and I4
		if ((int)packet.connection.state != 3)
		{
			Net.sv.Kick(packet.connection, "Invalid connection state", false);
			return;
		}
		ClientReady val = packet.read.Proto<ClientReady>((ClientReady)null);
		try
		{
			foreach (ClientInfo item in val.clientInfo)
			{
				Interface.CallHook("OnPlayerSetInfo", (object)packet.connection, (object)item.name, (object)item.value);
				packet.connection.info.Set(item.name, item.value);
			}
			packet.connection.globalNetworking = val.globalNetworking;
			connectionQueue.JoinedGame(packet.connection);
			Analytics.Azure.OnPlayerConnected(packet.connection);
			AddPartyMembersToTeam(packet.connection, val.party);
			TimeWarning val2 = TimeWarning.New("ClientReady", 0);
			try
			{
				TimeWarning val3 = TimeWarning.New("SpawnPlayerSleeping", 0);
				BasePlayer basePlayer;
				try
				{
					basePlayer = SpawnPlayerSleeping(packet.connection);
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				if ((Object)(object)basePlayer == (Object)null)
				{
					val3 = TimeWarning.New("SpawnNewPlayer", 0);
					try
					{
						basePlayer = SpawnNewPlayer(packet.connection);
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
				}
				basePlayer.SendRespawnOptions();
				basePlayer.LoadClanInfo();
				if ((Object)(object)basePlayer != (Object)null)
				{
					Util.SendSignedInNotification(basePlayer);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		SendReplicatedVars(packet.connection);
	}

	private void AddPartyMembersToTeam(Connection connection, PartyData party)
	{
		if (party == null || party.members == null || party.members.Count == 0)
		{
			return;
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindByJoinKey(party.joinKey);
		if (playerTeam != null)
		{
			if (!RelationshipManager.ServerInstance.IsPlayerInTeam(connection.userid))
			{
				playerTeam.AddPlayer(connection.userid);
			}
			return;
		}
		foreach (PartyMemberData member in party.members)
		{
			if (!RelationshipManager.ServerInstance.IsPlayerInTeam(member.steamId))
			{
				SingletonComponent<ServerMgr>.Instance.persistance.SetDefaultPlayerName(member.steamId, member.name);
				if (playerTeam == null)
				{
					playerTeam = RelationshipManager.ServerInstance.CreatePartyTeam(party.joinKey);
				}
				playerTeam.AddPlayer(member.steamId);
				if (playerTeam.members.Count == 1 || member.isLeader)
				{
					playerTeam.teamLeader = member.steamId;
				}
			}
		}
	}

	private void OnRPCMessage(Message packet)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		timer.Restart();
		NetworkableId uid = packet.read.EntityID();
		uint num = packet.read.UInt32();
		if (ConVar.Server.rpclog_enabled)
		{
			rpcHistory.Increment(num);
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(uid) as BaseEntity;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.SendDemoTransientEntity();
			baseEntity.SV_RPCMessage(num, packet);
			if (timer.Elapsed > RuntimeProfiler.RpcWarningThreshold)
			{
				LagSpikeProfiler.RPC(timer.Elapsed, packet, baseEntity, num);
			}
		}
	}

	private void OnPlayerTick(Message packet)
	{
		BasePlayer basePlayer = packet.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.OnReceivedTick(packet.read);
		}
	}

	private void OnPlayerVoice(Message packet)
	{
		BasePlayer basePlayer = packet.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.OnReceivedVoice(packet.read.BytesWithSize(10485760u, false));
		}
	}

	private void OnGiveUserInformation(Message packet)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if ((int)packet.connection.state != 0)
		{
			Net.sv.Kick(packet.connection, "Invalid connection state", false);
			return;
		}
		packet.connection.state = (State)1;
		if (packet.read.UInt8() != 228)
		{
			Net.sv.Kick(packet.connection, "Invalid Connection Protocol", false);
			return;
		}
		packet.connection.userid = packet.read.UInt64();
		packet.connection.protocol = packet.read.UInt32();
		packet.connection.os = packet.read.String(128, false);
		packet.connection.username = packet.read.String(256, false);
		if (string.IsNullOrEmpty(packet.connection.os))
		{
			throw new Exception("Invalid OS");
		}
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Net.sv.Kick(packet.connection, "Invalid Username", false);
			return;
		}
		packet.connection.username = packet.connection.username.Replace('\n', ' ').Replace('\r', ' ').Replace('\t', ' ')
			.Trim();
		if (string.IsNullOrEmpty(packet.connection.username))
		{
			Net.sv.Kick(packet.connection, "Invalid Username", false);
			return;
		}
		string text = string.Empty;
		string branch = ConVar.Server.branch;
		if (packet.read.Unread >= 4)
		{
			text = packet.read.String(128, false);
		}
		Interface.CallHook("OnClientAuth", (object)packet.connection);
		if (branch != string.Empty && branch != text)
		{
			DebugEx.Log((object)("Kicking " + ((object)packet.connection)?.ToString() + " - their branch is '" + text + "' not '" + branch + "'"), (StackTraceLogType)0);
			Net.sv.Kick(packet.connection, "Wrong Steam Beta: Requires '" + branch + "' branch!", false);
		}
		else if (packet.connection.protocol > 2597)
		{
			DebugEx.Log((object)("Kicking " + ((object)packet.connection)?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2597), (StackTraceLogType)0);
			Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Server update required!", false);
		}
		else if (packet.connection.protocol < 2597)
		{
			DebugEx.Log((object)("Kicking " + ((object)packet.connection)?.ToString() + " - their protocol is " + packet.connection.protocol + " not " + 2597), (StackTraceLogType)0);
			Net.sv.Kick(packet.connection, "Wrong Connection Protocol: Client update required!", false);
		}
		else
		{
			packet.connection.token = packet.read.BytesWithSize(512u, false);
			if (packet.connection.token == null || packet.connection.token.Length < 1)
			{
				Net.sv.Kick(packet.connection, "Invalid Token", false);
				return;
			}
			packet.connection.anticheatId = packet.read.StringRaw(128, false);
			packet.connection.anticheatToken = packet.read.StringRaw(2048, false);
			packet.connection.clientChangeset = packet.read.Int32();
			packet.connection.clientBuildTime = packet.read.Int64();
			auth.OnNewConnection(packet.connection);
		}
	}
}


using System;
using System.IO;
using System.Linq;
using Facepunch;
using Rust;
using UnityEngine;
using UnityEngine.Profiling;

public class ServerPerformance : BaseMonoBehaviour
{
	public static ulong deaths;

	public static ulong spawns;

	public static ulong position_changes;

	private string fileName;

	private int lastFrame;

	private void Start()
	{
		if (Profiler.supported && CommandLine.HasSwitch("-perf"))
		{
			fileName = "perfdata." + DateTime.Now.ToString() + ".txt";
			fileName = fileName.Replace('\\', '-');
			fileName = fileName.Replace('/', '-');
			fileName = fileName.Replace(' ', '_');
			fileName = fileName.Replace(':', '.');
			lastFrame = Time.frameCount;
			File.WriteAllText(fileName, "MemMono,MemUnity,Frame,PlayerCount,Sleepers,CollidersDisabled,BehavioursDisabled,GameObjects,Colliders,RigidBodies,BuildingBlocks,nwSend,nwRcv,cnInit,cnApp,cnRej,deaths,spawns,poschange\r\n");
			((FacepunchBehaviour)this).InvokeRepeating((Action)WriteLine, 1f, 60f);
		}
	}

	private void WriteLine()
	{
		Rust.GC.Collect();
		uint monoUsedSize = Profiler.GetMonoUsedSize();
		uint usedHeapSize = Profiler.usedHeapSize;
		int count = BasePlayer.activePlayerList.Count;
		int count2 = BasePlayer.sleepingPlayerList.Count;
		int num = Object.FindObjectsOfType<GameObject>().Length;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		int num5 = 0;
		int num6 = 0;
		int num7 = Time.frameCount - lastFrame;
		File.AppendAllText(fileName, monoUsedSize + "," + usedHeapSize + "," + num7 + "," + count + "," + count2 + "," + NetworkSleep.totalCollidersDisabled + "," + NetworkSleep.totalBehavioursDisabled + "," + num + "," + Object.FindObjectsOfType<Collider>().Length + "," + Object.FindObjectsOfType<Rigidbody>().Length + "," + Object.FindObjectsOfType<BuildingBlock>().Length + "," + num2 + "," + num3 + "," + num4 + "," + num5 + "," + num6 + "," + deaths + "," + spawns + "," + position_changes + "\r\n");
		lastFrame = Time.frameCount;
		deaths = 0uL;
		spawns = 0uL;
		position_changes = 0uL;
	}

	public static void DoReport()
	{
		string text = "report." + DateTime.Now.ToString() + ".txt";
		text = text.Replace('\\', '-');
		text = text.Replace('/', '-');
		text = text.Replace(' ', '_');
		text = text.Replace(':', '.');
		File.WriteAllText(text, "Report Generated " + DateTime.Now.ToString() + "\r\n");
		string filename = text;
		Object[] objects = (Object[])(object)Object.FindObjectsOfType<Transform>();
		ComponentReport(filename, "All Objects", objects);
		string filename2 = text;
		objects = (Object[])(object)Object.FindObjectsOfType<BaseEntity>();
		ComponentReport(filename2, "Entities", objects);
		string filename3 = text;
		objects = (Object[])(object)Object.FindObjectsOfType<Rigidbody>();
		ComponentReport(filename3, "Rigidbodies", objects);
		string filename4 = text;
		objects = (Object[])(object)(from x in Object.FindObjectsOfType<Collider>()
			where !x.enabled
			select x).ToArray();
		ComponentReport(filename4, "Disabled Colliders", objects);
		string filename5 = text;
		objects = (Object[])(object)(from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).ToArray();
		ComponentReport(filename5, "Enabled Colliders", objects);
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.DumpReport(text);
		}
	}

	public static string WorkoutPrefabName(GameObject obj)
	{
		if ((Object)(object)obj == (Object)null)
		{
			return "null";
		}
		string text = (obj.activeSelf ? "" : " (inactive)");
		BaseEntity baseEntity = obj.ToBaseEntity();
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			return baseEntity.PrefabName + text;
		}
		return ((Object)obj).name + text;
	}

	public static void ComponentReport(string filename, string Title, Object[] objects)
	{
		File.AppendAllText(filename, "\r\n\r\n" + Title + ":\r\n\r\n");
		foreach (IGrouping<string, Object> item in from x in objects
			group x by WorkoutPrefabName(((Component)((x is Component) ? x : null)).gameObject) into x
			orderby x.Count() descending
			select x)
		{
			File.AppendAllText(filename, "\t" + WorkoutPrefabName(((Component)/*isinst with value type is only supported in some contexts*/).gameObject) + " - " + item.Count() + "\r\n");
		}
		File.AppendAllText(filename, "\r\nTotal: " + objects.Count() + "\r\n\r\n\r\n");
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class ServerPlayers
{
	private static readonly HashSet<ulong> OnlineUserIdSet = new HashSet<ulong>();

	private static int _currentFrame;

	public static bool IsOnline(ulong userId)
	{
		RebuildIfNecessary();
		return OnlineUserIdSet.Contains(userId);
	}

	public static void GetAll(List<ulong> userIds)
	{
		RebuildIfNecessary();
		foreach (ulong item in OnlineUserIdSet)
		{
			userIds.Add(item);
		}
	}

	private static void RebuildIfNecessary()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		int frameCount = Time.frameCount;
		if (frameCount == _currentFrame)
		{
			return;
		}
		_currentFrame = frameCount;
		OnlineUserIdSet.Clear();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				OnlineUserIdSet.Add(current.userID);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Rust;
using UnityEngine;

public static class ServerSubscriptions
{
	private static readonly Memoized<string, string> FoundationGrade = new Memoized<string, string>((Func<string, string>)((string s) => s.Replace("Block", "").ToLower()));

	private static readonly Memoized<string, string> FoundationType = new Memoized<string, string>((Func<string, string>)((string s) => (!s.Contains("foundation.triangle")) ? "s" : "t"));

	public static void StartSubscribeFeed()
	{
		InvokeHandler.InvokeRepeating((Behaviour)(object)Global.Runner, (Action)SendPlayerPositions, 0f, 0.2f);
		InvokeHandler.InvokeRepeating((Behaviour)(object)Global.Runner, (Action)SendFoundations, 0f, 5f);
	}

	public static void StopSubscribeFeed()
	{
		InvokeHandler.CancelInvoke((Behaviour)(object)Global.Runner, (Action)SendPlayerPositions);
		InvokeHandler.CancelInvoke((Behaviour)(object)Global.Runner, (Action)SendFoundations);
	}

	private static void SendFoundations()
	{
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isServerStarted || !RCon.HasSubscribers)
		{
			return;
		}
		ListDictionary<uint, BuildingManager.Building> buildingDictionary = BuildingManager.server.buildingDictionary;
		StringBuilder stringBuilder = Pool.Get<StringBuilder>();
		Vector3 val = default(Vector3);
		Quaternion val2 = default(Quaternion);
		foreach (KeyValuePair<uint, BuildingManager.Building> item in buildingDictionary)
		{
			Enumerator<BuildingBlock> enumerator2 = item.Value.buildingBlocks.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BuildingBlock current = enumerator2.Current;
					if (((Object)current).name.Contains("foundation") && !((Object)current).name.Contains("foundation.steps"))
					{
						((Component)current).gameObject.transform.GetPositionAndRotation(ref val, ref val2);
						stringBuilder.AppendJoin(',', FoundationGrade.Get(current.grade.ToString()), FoundationType.Get(((Object)current).name), val.x.ToString("0.00"), val.y.ToString("0.00"), val.z.ToString("0.00"), ((Quaternion)(ref val2)).eulerAngles.y.ToString("0.0"), ((Bounds)(ref current.bounds)).size.x);
						stringBuilder.Append("\n");
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
		}
		try
		{
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Remove(stringBuilder.Length - 1, 1);
			}
			RCon.SendMessageToSubscribers(stringBuilder.ToString(), -64002);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		Pool.FreeUnmanaged(ref stringBuilder);
	}

	private static void SendPlayerPositions()
	{
		if (!Application.isServerStarted || !RCon.HasSubscribers)
		{
			return;
		}
		try
		{
			TextTable val = Pool.Get<TextTable>();
			try
			{
				val.ShouldPadColumns = false;
				ConVar.Server.GetPlayerListPosTable(val);
				RCon.SendMessageToSubscribers(val.ToJson(true), -64001);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch.Math;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Oxide.Core;
using UnityEngine;

public static class ServerUsers
{
	public enum UserGroup
	{
		None,
		Owner,
		Moderator,
		Banned,
		SkipQueue
	}

	[JsonModel]
	public class User
	{
		public ulong steamid;

		[JsonConverter(typeof(StringEnumConverter))]
		public UserGroup group;

		public string username;

		public string notes;

		public long expiry;

		[JsonIgnore]
		public bool IsExpired
		{
			get
			{
				if (expiry > 0)
				{
					return Epoch.Current > expiry;
				}
				return false;
			}
		}
	}

	private static StringBuilder sb = new StringBuilder(65536);

	public static Dictionary<ulong, User> users = new Dictionary<ulong, User>();

	public static void Remove(ulong uid)
	{
		Interface.CallHook("OnServerUserRemove", (object)uid);
		users.Remove(uid);
	}

	public static void Set(ulong uid, UserGroup group, string username, string notes, long expiry = -1L)
	{
		Remove(uid);
		User value = new User
		{
			steamid = uid,
			group = group,
			username = username,
			notes = notes,
			expiry = expiry
		};
		Interface.CallHook("OnServerUserSet", (object)uid, (object)group, (object)username, (object)notes, (object)expiry);
		users.Add(uid, value);
	}

	public static User Get(ulong uid)
	{
		if (!users.TryGetValue(uid, out var value))
		{
			return null;
		}
		if (!value.IsExpired)
		{
			return value;
		}
		Remove(uid);
		return null;
	}

	public static bool Is(ulong uid, UserGroup group)
	{
		User user = Get(uid);
		if (user == null)
		{
			return false;
		}
		return user.group == group;
	}

	public static IEnumerable<User> GetAll(UserGroup group)
	{
		return from x in users.Values
			where x.@group == @group
			where !x.IsExpired
			select x;
	}

	public static void Clear()
	{
		users.Clear();
	}

	public static void Load()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		Clear();
		string serverFolder = Server.GetServerFolder("cfg");
		Option server;
		if (File.Exists(serverFolder + "/bans.cfg"))
		{
			string text = File.ReadAllText(serverFolder + "/bans.cfg");
			if (!string.IsNullOrEmpty(text))
			{
				Debug.Log((object)("Running " + serverFolder + "/bans.cfg"));
				server = Option.Server;
				ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text);
			}
		}
		if (File.Exists(serverFolder + "/users.cfg"))
		{
			string text2 = File.ReadAllText(serverFolder + "/users.cfg");
			if (!string.IsNullOrEmpty(text2))
			{
				Debug.Log((object)("Running " + serverFolder + "/users.cfg"));
				server = Option.Server;
				ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text2);
			}
		}
	}

	public static void Save()
	{
		foreach (ulong item in (from kv in users
			where kv.Value.IsExpired
			select kv.Key).ToList())
		{
			Remove(item);
		}
		string serverFolder = Server.GetServerFolder("cfg");
		sb.Clear();
		foreach (User item2 in GetAll(UserGroup.Banned))
		{
			if (!(item2.notes == "EAC"))
			{
				sb.Append("banid ");
				sb.Append(item2.steamid);
				sb.Append(' ');
				StringBuilderExtensions.QuoteSafe(sb, item2.username);
				sb.Append(' ');
				StringBuilderExtensions.QuoteSafe(sb, item2.notes);
				sb.Append(' ');
				sb.Append(item2.expiry);
				sb.Append("\r\n");
			}
		}
		File.WriteAllText(serverFolder + "/bans.cfg", sb.ToString());
		sb.Clear();
		foreach (User item3 in GetAll(UserGroup.Owner))
		{
			sb.Append("ownerid ");
			sb.Append(item3.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item3.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item3.notes);
			sb.Append("\r\n");
		}
		foreach (User item4 in GetAll(UserGroup.Moderator))
		{
			sb.Append("moderatorid ");
			sb.Append(item4.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item4.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item4.notes);
			sb.Append("\r\n");
		}
		foreach (User item5 in GetAll(UserGroup.SkipQueue))
		{
			sb.Append("skipqueueid ");
			sb.Append(item5.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item5.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item5.notes);
			sb.Append("\r\n");
		}
		File.WriteAllText(serverFolder + "/users.cfg", sb.ToString());
	}

	public static string BanListString(bool bHeader = false)
	{
		List<User> list = GetAll(UserGroup.Banned).ToList();
		sb.Clear();
		if (bHeader)
		{
			if (list.Count == 0)
			{
				return "ID filter list: empty\n";
			}
			if (list.Count == 1)
			{
				sb.Append("ID filter list: 1 entry\n");
			}
			else
			{
				sb.Append($"ID filter list: {list.Count} entries\n");
			}
		}
		int num = 1;
		foreach (User item in list)
		{
			sb.Append(num);
			sb.Append(' ');
			sb.Append(item.steamid);
			sb.Append(" : ");
			if (item.expiry > 0)
			{
				double num2 = (double)(item.expiry - Epoch.Current) / 60.0;
				sb.Append(num2.ToString("F3"));
				sb.Append(" min");
			}
			else
			{
				sb.Append("permanent");
			}
			sb.Append('\n');
			num++;
		}
		return sb.ToString();
	}

	public static string BanListStringEx()
	{
		IEnumerable<User> all = GetAll(UserGroup.Banned);
		sb.Clear();
		int num = 1;
		foreach (User item in all)
		{
			sb.Append(num);
			sb.Append(' ');
			sb.Append(item.steamid);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item.username);
			sb.Append(' ');
			StringBuilderExtensions.QuoteSafe(sb, item.notes);
			sb.Append(' ');
			sb.Append(item.expiry);
			sb.Append('\n');
			num++;
		}
		return sb.ToString();
	}
}


public enum UserGroup
{
	None,
	Owner,
	Moderator,
	Banned,
	SkipQueue
}


using Facepunch.Math;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

[JsonModel]
public class User
{
	public ulong steamid;

	[JsonConverter(typeof(StringEnumConverter))]
	public UserGroup group;

	public string username;

	public string notes;

	public long expiry;

	[JsonIgnore]
	public bool IsExpired
	{
		get
		{
			if (expiry > 0)
			{
				return Epoch.Current > expiry;
			}
			return false;
		}
	}
}


