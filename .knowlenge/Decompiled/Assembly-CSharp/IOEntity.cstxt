using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.Assertions;

public class IOEntity : DecayEntity
{
	public enum IOType
	{
		Electric,
		Fluidic,
		Kinetic,
		Generic,
		Industrial
	}

	public enum QueueType
	{
		ElectricLowPriority,
		ElectricHighPriority,
		Fluidic,
		Kinetic,
		Generic,
		Industrial
	}

	[Serializable]
	public class IORef
	{
		public EntityRef entityRef;

		public IOEntity ioEnt;

		public void Init()
		{
			if ((Object)(object)ioEnt != (Object)null && !entityRef.IsValid(serverside: true))
			{
				entityRef.Set(ioEnt);
			}
			if (entityRef.IsValid(serverside: true))
			{
				ioEnt = ((Component)entityRef.Get(serverside: true)).GetComponent<IOEntity>();
			}
		}

		public void InitClient()
		{
			if (entityRef.IsValid(serverside: false) && (Object)(object)ioEnt == (Object)null)
			{
				ioEnt = ((Component)entityRef.Get(serverside: false)).GetComponent<IOEntity>();
			}
		}

		public IOEntity Get(bool isServer = true)
		{
			if ((Object)(object)ioEnt == (Object)null && entityRef.IsValid(isServer))
			{
				ioEnt = entityRef.Get(isServer) as IOEntity;
			}
			return ioEnt;
		}

		public void Clear()
		{
			IOEntity iOEntity = ioEnt;
			ioEnt = null;
			entityRef.Set(null);
			Interface.CallHook("OnIORefCleared", (object)this, (object)iOEntity);
		}

		public void Set(IOEntity newIOEnt)
		{
			entityRef.Set(newIOEnt);
		}
	}

	[Serializable]
	public class IOSlot
	{
		public string niceName;

		public IOType type;

		public IORef connectedTo;

		public int connectedToSlot;

		public IOHandlePriority importance;

		public float ArrowOffset;

		public Vector3[] linePoints;

		public LineAnchor[] lineAnchors;

		public float[] slackLevels;

		public Vector3 worldSpaceLineEndRotation;

		[HideInInspector]
		public Vector3 originPosition;

		[HideInInspector]
		public Vector3 originRotation;

		public ClientIOLine line;

		public Vector3 handlePosition;

		public Vector3 handleDirection;

		public bool rootConnectionsOnly;

		public bool mainPowerSlot;

		public WireTool.WireColour wireColour;

		public float lineThickness;

		public void Clear()
		{
			if (connectedTo == null)
			{
				connectedTo = new IORef();
			}
			else
			{
				connectedTo.Clear();
			}
			connectedToSlot = 0;
			linePoints = null;
			lineAnchors = null;
		}

		public void Preserve(ref SprayCan.IOPreserveInfo target)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			target.connectedTo = connectedTo.Get();
			target.connectedToSlot = connectedToSlot;
			target.linePoints = linePoints;
			target.slackLevels = slackLevels;
			target.lineAnchors = lineAnchors;
			target.worldSpaceLineEndRotation = worldSpaceLineEndRotation;
			target.originPosition = originPosition;
			target.originRotation = originRotation;
			target.wireColour = wireColour;
		}

		public void Restore(SprayCan.IOPreserveInfo from)
		{
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			connectedTo.Set(from.connectedTo);
			connectedToSlot = from.connectedToSlot;
			linePoints = from.linePoints;
			slackLevels = from.slackLevels;
			lineAnchors = from.lineAnchors;
			worldSpaceLineEndRotation = from.worldSpaceLineEndRotation;
			originPosition = from.originPosition;
			originRotation = from.originRotation;
			wireColour = from.wireColour;
		}

		public bool IsConnected()
		{
			return (Object)(object)connectedTo.Get() != (Object)null;
		}
	}

	private struct FrameTiming
	{
		public string PrefabName;

		public double Time;
	}

	public struct LineAnchor
	{
		public EntityRef<Door> entityRef;

		public string boneName;

		public int index;

		public Vector3 position;

		public LineAnchor(WireLineAnchorInfo info)
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			entityRef = new EntityRef<Door>(info.parentID);
			boneName = info.boneName;
			index = (int)info.index;
			position = info.position;
		}

		public WireLineAnchorInfo ToInfo()
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Expected O, but got Unknown
			return new WireLineAnchorInfo
			{
				parentID = entityRef.Get(serverside: true).net.ID,
				boneName = boneName,
				index = index,
				position = position
			};
		}
	}

	public struct ContainerInputOutput
	{
		public IIndustrialStorage Storage;

		public int SlotIndex;

		public int MaxStackSize;

		public int ParentStorage;

		public int IndustrialSiblingCount;
	}

	[Header("IOEntity")]
	public Transform debugOrigin;

	public ItemDefinition sourceItem;

	[NonSerialized]
	public int lastResetIndex;

	[ServerVar]
	[Help("How many milliseconds to budget for processing high priority electric io entities per server frame (monuments)")]
	public static float frameBudgetElectricHighPriorityMs = 1f;

	[Help("How many milliseconds to budget for processing low priority io entities per server frame (player placed)")]
	[ServerVar]
	public static float frameBudgetElectricLowPriorityMs = 0.5f;

	[Help("How many milliseconds to budget for processing fluid io entities per server frame")]
	[ServerVar]
	public static float frameBudgetFluidMs = 0.25f;

	[Help("How many milliseconds to budget for processing kinetic io entities per server frame (monuments)")]
	[ServerVar]
	public static float frameBudgetKineticMs = 1f;

	[Help("How many milliseconds to budget for processing generic io entities per server frame (unused for now)")]
	[ServerVar]
	public static float frameBudgetGenericMs = 1f;

	[ServerVar]
	[Help("How many milliseconds to budget for processing industrial entities per server frame")]
	public static float frameBudgetIndustrialMs = 0.25f;

	[ServerVar]
	public static float responsetime = 0.1f;

	[ServerVar]
	public static int backtracking = 8;

	[ServerVar(Help = "Print out what is taking so long in the IO frame budget")]
	public static bool debugBudget = false;

	[ServerVar(Help = "Ignore frames with a lower ms than this while debugBudget is active")]
	public static float debugBudgetThreshold = 2f;

	private static bool _infinitePower = false;

	public const Flags Flag_ShortCircuit = Flags.Reserved7;

	public const Flags Flag_HasPower = Flags.Reserved8;

	public IOSlot[] inputs;

	public IOSlot[] outputs;

	public IOType ioType;

	public static Dictionary<QueueType, Queue<IOEntity>> _processQueues = new Dictionary<QueueType, Queue<IOEntity>>
	{
		{
			QueueType.ElectricHighPriority,
			new Queue<IOEntity>()
		},
		{
			QueueType.ElectricLowPriority,
			new Queue<IOEntity>()
		},
		{
			QueueType.Fluidic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Kinetic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Generic,
			new Queue<IOEntity>()
		},
		{
			QueueType.Industrial,
			new Queue<IOEntity>()
		}
	};

	public static Dictionary<QueueType, string> _processQueueProfilerString = new Dictionary<QueueType, string>
	{
		{
			QueueType.ElectricHighPriority,
			"HighPriorityElectric"
		},
		{
			QueueType.ElectricLowPriority,
			"LowPriorityElectric"
		},
		{
			QueueType.Fluidic,
			"Fluid"
		},
		{
			QueueType.Kinetic,
			"Kinetic"
		},
		{
			QueueType.Generic,
			"Generic"
		},
		{
			QueueType.Industrial,
			"Industrial"
		}
	};

	private static List<FrameTiming> timings = new List<FrameTiming>();

	public int cachedOutputsUsed;

	public int lastPassthroughEnergy;

	public int lastEnergy;

	public int currentEnergy;

	private int changedCount;

	private float lastChangeTime;

	public float lastUpdateTime;

	public int lastUpdateBlockedFrame;

	public bool ensureOutputsUpdated;

	public const int MaxContainerSourceCount = 32;

	private List<Collider> spawnedColliders = new List<Collider>();

	public virtual bool IsGravitySource => false;

	[ReplicatedVar(Help = "All player placed electrical entities will receive full power without needing to be plugged into anything")]
	public static bool infiniteIoPower
	{
		get
		{
			return _infinitePower;
		}
		set
		{
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (_infinitePower == value)
			{
				return;
			}
			_infinitePower = value;
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					if (!(enumerator.Current is IOEntity iOEntity) || iOEntity.GetQueueType() != 0)
					{
						continue;
					}
					if (infiniteIoPower)
					{
						iOEntity.ApplyInfinitePower();
						continue;
					}
					iOEntity.MarkDirtyForceUpdateOutputs();
					bool flag = false;
					IOSlot[] array = iOEntity.inputs;
					for (int i = 0; i < array.Length; i++)
					{
						if ((Object)(object)array[i].connectedTo.Get() != (Object)null)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						for (int j = 0; j < iOEntity.inputs.Length; j++)
						{
							iOEntity.UpdateFromInput(0, j);
						}
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
	}

	protected virtual bool PreventDuplicatesInQueue => false;

	private bool HasBlockedUpdatedOutputsThisFrame => Time.frameCount == lastUpdateBlockedFrame;

	public virtual bool BlockFluidDraining => false;

	protected virtual float LiquidPassthroughGravityThreshold => 1f;

	protected virtual bool DisregardGravityRestrictionsOnLiquid => false;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("IOEntity.OnRpcMessage", 0);
		try
		{
			if (rpc == 4161541566u && (Object)(object)player != (Object)null)
			{
				Assert.IsTrue(player.isServer, "SV_RPC Message is using a clientside player!");
				if (Global.developer > 2)
				{
					Debug.Log((object)("SV_RPCMessage: " + ((object)player)?.ToString() + " - Server_RequestData "));
				}
				TimeWarning val2 = TimeWarning.New("Server_RequestData", 0);
				try
				{
					TimeWarning val3 = TimeWarning.New("Conditions", 0);
					try
					{
						if (!RPC_Server.CallsPerSecond.Test(4161541566u, "Server_RequestData", this, player, 10uL))
						{
							return true;
						}
						if (!RPC_Server.IsVisible.Test(4161541566u, "Server_RequestData", this, player, 6f))
						{
							return true;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					try
					{
						val3 = TimeWarning.New("Call", 0);
						try
						{
							RPCMessage rPCMessage = default(RPCMessage);
							rPCMessage.connection = msg.connection;
							rPCMessage.player = player;
							rPCMessage.read = msg.read;
							RPCMessage msg2 = rPCMessage;
							Server_RequestData(msg2);
						}
						finally
						{
							((IDisposable)val3)?.Dispose();
						}
					}
					catch (Exception ex)
					{
						Debug.LogException(ex);
						player.Kick("RPC Error in Server_RequestData");
					}
				}
				finally
				{
					((IDisposable)val2)?.Dispose();
				}
				return true;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}

	public override void ResetState()
	{
		base.ResetState();
		if (base.isServer)
		{
			lastResetIndex = 0;
			cachedOutputsUsed = 0;
			lastPassthroughEnergy = 0;
			lastEnergy = 0;
			currentEnergy = 0;
			lastUpdateTime = 0f;
			ensureOutputsUpdated = false;
		}
		ClearIndustrialPreventBuilding();
	}

	public Phrase GetDisplayName()
	{
		if (!((Object)(object)sourceItem != (Object)null))
		{
			return Phrase.op_Implicit(base.ShortPrefabName);
		}
		return sourceItem.displayName;
	}

	public virtual bool IsRootEntity()
	{
		return false;
	}

	public IOEntity FindGravitySource(ref Vector3 worldHandlePosition, int depth, bool ignoreSelf)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0)
		{
			return null;
		}
		if (!ignoreSelf && IsGravitySource)
		{
			worldHandlePosition = ((Component)this).transform.TransformPoint(outputs[0].handlePosition);
			return this;
		}
		IOSlot[] array = inputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get(base.isServer);
			if ((Object)(object)iOEntity != (Object)null)
			{
				if (iOEntity.IsGravitySource)
				{
					worldHandlePosition = ((Component)iOEntity).transform.TransformPoint(iOEntity.outputs[0].handlePosition);
					return iOEntity;
				}
				iOEntity = iOEntity.FindGravitySource(ref worldHandlePosition, depth - 1, ignoreSelf: false);
				if ((Object)(object)iOEntity != (Object)null)
				{
					worldHandlePosition = ((Component)iOEntity).transform.TransformPoint(iOEntity.outputs[0].handlePosition);
					return iOEntity;
				}
			}
		}
		return null;
	}

	public virtual void SetFuelType(ItemDefinition def, IOEntity source)
	{
	}

	public virtual bool WantsPower(int inputIndex)
	{
		return true;
	}

	public virtual bool AllowWireConnections()
	{
		if ((Object)(object)((Component)this).GetComponentInParent<BaseVehicle>() != (Object)null)
		{
			return false;
		}
		return true;
	}

	public virtual bool WantsPassthroughPower()
	{
		return true;
	}

	public virtual int ConsumptionAmount()
	{
		return 1;
	}

	public virtual bool ShouldDrainBattery(IOEntity battery)
	{
		return ioType == battery.ioType;
	}

	public virtual bool ShouldBlockCircuit(IOEntity battery)
	{
		return false;
	}

	public virtual int MaximalPowerOutput()
	{
		return 0;
	}

	public virtual bool AllowDrainFrom(int outputSlot)
	{
		return true;
	}

	public QueueType GetQueueType()
	{
		switch (ioType)
		{
		case IOType.Electric:
			if ((Object)(object)sourceItem == (Object)null)
			{
				return QueueType.ElectricHighPriority;
			}
			return QueueType.ElectricLowPriority;
		case IOType.Fluidic:
			return QueueType.Fluidic;
		case IOType.Kinetic:
			return QueueType.Kinetic;
		case IOType.Generic:
			return QueueType.Generic;
		case IOType.Industrial:
			return QueueType.Industrial;
		default:
			return QueueType.ElectricLowPriority;
		}
	}

	public static float GetFrameBudgetForQueue(QueueType type)
	{
		return type switch
		{
			QueueType.ElectricLowPriority => frameBudgetElectricLowPriorityMs, 
			QueueType.ElectricHighPriority => frameBudgetElectricHighPriorityMs, 
			QueueType.Fluidic => frameBudgetFluidMs, 
			QueueType.Kinetic => frameBudgetKineticMs, 
			QueueType.Generic => frameBudgetGenericMs, 
			QueueType.Industrial => frameBudgetIndustrialMs, 
			_ => frameBudgetElectricLowPriorityMs, 
		};
	}

	public virtual bool IsPowered()
	{
		return HasFlag(Flags.Reserved8);
	}

	public bool IsConnectedToAnySlot(IOEntity entity, int slot, int depth, bool defaultReturn = false)
	{
		if (depth > 0 && slot < inputs.Length)
		{
			IOEntity iOEntity = inputs[slot].connectedTo.Get();
			if ((Object)(object)iOEntity != (Object)null)
			{
				if ((Object)(object)iOEntity == (Object)(object)entity)
				{
					return true;
				}
				if (ConsiderConnectedTo(entity))
				{
					return true;
				}
				if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IsConnectedTo(IOEntity entity, int slot, int depth, bool defaultReturn = false)
	{
		if (depth > 0 && slot < inputs.Length)
		{
			IOSlot iOSlot = inputs[slot];
			if (iOSlot.mainPowerSlot)
			{
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null)
				{
					if ((Object)(object)iOEntity == (Object)(object)entity)
					{
						return true;
					}
					if (ConsiderConnectedTo(entity))
					{
						return true;
					}
					if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	public bool IsConnectedTo(IOEntity entity, int depth, bool defaultReturn = false)
	{
		if (depth > 0)
		{
			for (int i = 0; i < inputs.Length; i++)
			{
				IOSlot iOSlot = inputs[i];
				if (!iOSlot.mainPowerSlot)
				{
					continue;
				}
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null)
				{
					if ((Object)(object)iOEntity == (Object)(object)entity)
					{
						return true;
					}
					if (ConsiderConnectedTo(entity))
					{
						return true;
					}
					if (iOEntity.IsConnectedTo(entity, depth - 1, defaultReturn))
					{
						return true;
					}
				}
			}
			return false;
		}
		return defaultReturn;
	}

	protected virtual bool ConsiderConnectedTo(IOEntity entity)
	{
		return false;
	}

	[RPC_Server.CallsPerSecond(10uL)]
	[RPC_Server]
	[RPC_Server.IsVisible(6f)]
	private void Server_RequestData(RPCMessage msg)
	{
		BasePlayer player = msg.player;
		int slot = msg.read.Int32();
		bool input = msg.read.Int32() == 1;
		SendAdditionalData(player, slot, input);
	}

	public virtual void SendAdditionalData(BasePlayer player, int slot, bool input)
	{
		int passthroughAmountForAnySlot = GetPassthroughAmountForAnySlot(slot, input);
		ClientRPC(RpcTarget.Player("Client_ReceiveAdditionalData", player), currentEnergy, passthroughAmountForAnySlot, 0f, 0f);
	}

	protected int GetPassthroughAmountForAnySlot(int slot, bool isInputSlot)
	{
		int result = 0;
		if (isInputSlot)
		{
			if (slot >= 0 && slot < inputs.Length)
			{
				IOSlot iOSlot = inputs[slot];
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if ((Object)(object)iOEntity != (Object)null && iOSlot.connectedToSlot >= 0 && iOSlot.connectedToSlot < iOEntity.outputs.Length)
				{
					result = iOEntity.GetPassthroughAmount(inputs[slot].connectedToSlot);
				}
			}
		}
		else if (slot >= 0 && slot < outputs.Length)
		{
			result = GetPassthroughAmount(slot);
		}
		return result;
	}

	public static void ProcessQueue()
	{
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Expected O, but got Unknown
		if (debugBudget)
		{
			timings.Clear();
		}
		double realtimeSinceStartupAsDouble = Time.realtimeSinceStartupAsDouble;
		foreach (KeyValuePair<QueueType, Queue<IOEntity>> processQueue in _processQueues)
		{
			double num = Time.realtimeSinceStartup;
			double num2 = GetFrameBudgetForQueue(processQueue.Key) / 1000f;
			while (processQueue.Value.Count > 0 && Time.realtimeSinceStartupAsDouble < num + num2 && !processQueue.Value.Peek().HasBlockedUpdatedOutputsThisFrame)
			{
				double realtimeSinceStartupAsDouble2 = Time.realtimeSinceStartupAsDouble;
				IOEntity iOEntity = processQueue.Value.Dequeue();
				if (iOEntity.IsValid())
				{
					iOEntity.UpdateOutputs();
				}
				if (debugBudget)
				{
					timings.Add(new FrameTiming
					{
						PrefabName = iOEntity.ShortPrefabName,
						Time = (Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble2) * 1000.0
					});
				}
			}
		}
		if (debugBudget)
		{
			double num3 = Time.realtimeSinceStartupAsDouble - realtimeSinceStartupAsDouble;
			double num4 = (double)debugBudgetThreshold / 1000.0;
			if (num3 > num4)
			{
				TextTable val = new TextTable();
				val.AddColumns(new string[2] { "Prefab Name", "Time (in ms)" });
				foreach (FrameTiming timing in timings)
				{
					string[] obj = new string[2] { timing.PrefabName, null };
					double time = timing.Time;
					obj[1] = time.ToString();
					val.AddRow(obj);
				}
				val.AddRow(new string[2]
				{
					"Total time",
					(num3 * 1000.0).ToString()
				});
				Debug.Log((object)((object)val).ToString());
			}
		}
		AutoTurret.ProcessInterferenceQueue();
	}

	[ServerVar(ServerAdmin = true)]
	public static void DebugQueue(Arg arg)
	{
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<QueueType, Queue<IOEntity>> processQueue in _processQueues)
		{
			QueueType key = processQueue.Key;
			Queue<IOEntity> value = processQueue.Value;
			stringBuilder.AppendLine($"{key} queue size: {value.Count}");
			if (value.Count == 0)
			{
				continue;
			}
			var list = (from e in value
				group e by e.PrefabName into g
				select new
				{
					PrefabName = g.Key,
					Count = g.Count(),
					Entities = g.ToList()
				} into g
				orderby g.Count descending
				select g).Take(10).ToList();
			stringBuilder.AppendLine("-----Top queue occupants-----");
			foreach (var item in list)
			{
				IOEntity iOEntity = item.Entities.First();
				stringBuilder.AppendLine($"[{item.Count} times] {iOEntity.PrefabName} @ {((Component)iOEntity).transform.position}");
			}
			if (list.Count > 0)
			{
				IOEntity iOEntity2 = list.First().Entities.First();
				stringBuilder.AppendLine("-----Showing top entity-----");
				stringBuilder.AppendLine($"Entity type: {iOEntity2.ioType}");
				stringBuilder.AppendLine("Entity prefab: " + iOEntity2.PrefabName);
				stringBuilder.AppendLine($"Entity net id: {iOEntity2.net.ID}");
				stringBuilder.AppendLine($"Entity position: teleportpos {((Component)iOEntity2).transform.position}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	public virtual void ResetIOState()
	{
	}

	public virtual void Init()
	{
		for (int i = 0; i < outputs.Length; i++)
		{
			IOSlot iOSlot = outputs[i];
			iOSlot.connectedTo.Init();
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				int connectedToSlot = iOSlot.connectedToSlot;
				if (connectedToSlot < 0 || connectedToSlot >= iOSlot.connectedTo.Get().inputs.Length)
				{
					Debug.LogError((object)("Slot IOR Error: " + ((Object)this).name + " setting up inputs for " + ((Object)iOSlot.connectedTo.Get()).name + " slot : " + iOSlot.connectedToSlot));
				}
				else
				{
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedTo.Set(this);
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedToSlot = i;
					iOSlot.connectedTo.Get().inputs[iOSlot.connectedToSlot].connectedTo.Init();
				}
			}
		}
		UpdateUsedOutputs();
		if (IsRootEntity())
		{
			((FacepunchBehaviour)this).Invoke((Action)MarkDirtyForceUpdateOutputs, Random.Range(1f, 1f));
		}
		ApplyInfinitePower();
	}

	private void ApplyInfinitePower()
	{
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			for (int i = 0; i < inputs.Length; i++)
			{
				UpdateFromInput(999, 0);
			}
		}
	}

	internal override void DoServerDestroy()
	{
		if (base.isServer)
		{
			Shutdown();
		}
		base.DoServerDestroy();
	}

	public void ClearConnections()
	{
		List<IOEntity> list = Pool.Get<List<IOEntity>>();
		List<IOEntity> list2 = Pool.Get<List<IOEntity>>();
		IOSlot[] array = inputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity = null;
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOEntity = iOSlot.connectedTo.Get();
				if (iOSlot.type == IOType.Industrial)
				{
					list2.Add(iOEntity);
				}
				IOSlot[] array2 = iOSlot.connectedTo.Get().outputs;
				foreach (IOSlot iOSlot2 in array2)
				{
					if ((Object)(object)iOSlot2.connectedTo.Get() != (Object)null && iOSlot2.connectedTo.Get().EqualNetID((BaseNetworkable)this))
					{
						iOSlot2.Clear();
					}
				}
			}
			iOSlot.Clear();
			if (Object.op_Implicit((Object)(object)iOEntity))
			{
				iOEntity.SendNetworkUpdate();
			}
		}
		array = outputs;
		foreach (IOSlot iOSlot3 in array)
		{
			if ((Object)(object)iOSlot3.connectedTo.Get() != (Object)null)
			{
				list.Add(iOSlot3.connectedTo.Get());
				if (iOSlot3.type == IOType.Industrial)
				{
					list2.Add(list[list.Count - 1]);
				}
				IOSlot[] array2 = iOSlot3.connectedTo.Get().inputs;
				foreach (IOSlot iOSlot4 in array2)
				{
					if ((Object)(object)iOSlot4.connectedTo.Get() != (Object)null && iOSlot4.connectedTo.Get().EqualNetID((BaseNetworkable)this))
					{
						iOSlot4.Clear();
					}
				}
			}
			if (Object.op_Implicit((Object)(object)iOSlot3.connectedTo.Get()))
			{
				iOSlot3.connectedTo.Get().UpdateFromInput(0, iOSlot3.connectedToSlot);
			}
			iOSlot3.Clear();
		}
		SendNetworkUpdate();
		foreach (IOEntity item in list)
		{
			if ((Object)(object)item != (Object)null)
			{
				item.MarkDirty();
				item.SendNetworkUpdate();
			}
		}
		for (int k = 0; k < inputs.Length; k++)
		{
			UpdateFromInput(0, k);
		}
		foreach (IOEntity item2 in list2)
		{
			if ((Object)(object)item2 != (Object)null)
			{
				item2.NotifyIndustrialNetworkChanged();
			}
			item2.RefreshIndustrialPreventBuilding();
		}
		Pool.FreeUnmanaged<IOEntity>(ref list);
		Pool.FreeUnmanaged<IOEntity>(ref list2);
		RefreshIndustrialPreventBuilding();
	}

	public void Shutdown()
	{
		SendChangedToRoot(forceUpdate: true);
		ClearConnections();
	}

	public void MarkDirtyForceUpdateOutputs()
	{
		ensureOutputsUpdated = true;
		MarkDirty();
	}

	public void UpdateUsedOutputs()
	{
		cachedOutputsUsed = 0;
		IOSlot[] array = outputs;
		for (int i = 0; i < array.Length; i++)
		{
			IOEntity iOEntity = array[i].connectedTo.Get();
			if ((Object)(object)iOEntity != (Object)null && !iOEntity.IsDestroyed)
			{
				cachedOutputsUsed++;
			}
		}
	}

	public virtual void MarkDirty()
	{
		if (!base.isClient)
		{
			UpdateUsedOutputs();
			TouchIOState();
		}
	}

	public virtual int DesiredPower(int inputIndex = 0)
	{
		if (!inputs[inputIndex].mainPowerSlot)
		{
			return 0;
		}
		int num = ConsumptionAmount();
		if (IsFlickering())
		{
			return num;
		}
		if (currentEnergy < num)
		{
			return 0;
		}
		return num;
	}

	public virtual int CalculateCurrentEnergy(int inputAmount, int inputSlot)
	{
		return inputAmount;
	}

	public virtual int GetCurrentEnergy()
	{
		return Mathf.Clamp(currentEnergy - ConsumptionAmount(), 0, currentEnergy);
	}

	public virtual int GetPassthroughAmount(int outputSlot = 0)
	{
		if (outputSlot < 0 || outputSlot >= outputs.Length)
		{
			return 0;
		}
		int num = ((cachedOutputsUsed == 0) ? 1 : cachedOutputsUsed);
		return GetCurrentEnergy() / num;
	}

	public virtual void UpdateHasPower(int inputAmount, int inputSlot)
	{
		SetFlag(Flags.Reserved8, inputAmount >= ConsumptionAmount() && inputAmount > 0, recursive: false, networkupdate: false);
	}

	public void TouchInternal()
	{
		int num = GetPassthroughAmount();
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			num = 999;
		}
		bool num2 = lastPassthroughEnergy != num;
		lastPassthroughEnergy = num;
		if (num2)
		{
			IOStateChanged(currentEnergy, 0);
			ensureOutputsUpdated = true;
		}
		if (!PreventDuplicatesInQueue || !_processQueues[GetQueueType()].Contains(this))
		{
			_processQueues[GetQueueType()].Enqueue(this);
		}
	}

	public virtual void UpdateFromInput(int inputAmount, int inputSlot)
	{
		if (Interface.CallHook("OnInputUpdate", (object)this, (object)inputAmount, (object)inputSlot) != null)
		{
			return;
		}
		if (inputs[inputSlot].type != ioType || inputs[inputSlot].type == IOType.Industrial)
		{
			IOStateChanged(inputAmount, inputSlot);
			return;
		}
		UpdateHasPower(inputAmount, inputSlot);
		lastEnergy = currentEnergy;
		currentEnergy = CalculateCurrentEnergy(inputAmount, inputSlot);
		int num = GetPassthroughAmount();
		if (infiniteIoPower && GetQueueType() == QueueType.ElectricLowPriority)
		{
			num = 999;
		}
		bool flag = lastPassthroughEnergy != num;
		lastPassthroughEnergy = num;
		if (currentEnergy != lastEnergy || flag)
		{
			IOStateChanged(inputAmount, inputSlot);
			ensureOutputsUpdated = true;
		}
		_processQueues[GetQueueType()].Enqueue(this);
	}

	public virtual void TouchIOState()
	{
		if (!base.isClient)
		{
			TouchInternal();
		}
	}

	public virtual void SendIONetworkUpdate()
	{
		SendNetworkUpdate_Flags();
	}

	public bool IsFlickering()
	{
		if (changedCount > 5)
		{
			return Time.realtimeSinceStartup - lastChangeTime < 1f;
		}
		return false;
	}

	public virtual void IOStateChanged(int inputAmount, int inputSlot)
	{
		if (Time.realtimeSinceStartup - lastChangeTime > 1f)
		{
			changedCount = 1;
		}
		else
		{
			changedCount++;
		}
		lastChangeTime = Time.realtimeSinceStartup;
	}

	public virtual void OnCircuitChanged(bool forceUpdate)
	{
		if (forceUpdate)
		{
			MarkDirtyForceUpdateOutputs();
		}
	}

	public virtual void SendChangedToRoot(bool forceUpdate)
	{
		List<IOEntity> existing = Pool.Get<List<IOEntity>>();
		SendChangedToRootRecursive(forceUpdate, ref existing);
		Pool.FreeUnmanaged<IOEntity>(ref existing);
	}

	public virtual void SendChangedToRootRecursive(bool forceUpdate, ref List<IOEntity> existing)
	{
		bool flag = IsRootEntity();
		if (existing.Contains(this))
		{
			return;
		}
		existing.Add(this);
		bool flag2 = false;
		for (int i = 0; i < inputs.Length; i++)
		{
			IOSlot iOSlot = inputs[i];
			if (!iOSlot.mainPowerSlot)
			{
				continue;
			}
			IOEntity iOEntity = iOSlot.connectedTo.Get();
			if (!((Object)(object)iOEntity == (Object)null) && !existing.Contains(iOEntity))
			{
				flag2 = true;
				if (forceUpdate)
				{
					iOEntity.ensureOutputsUpdated = true;
				}
				iOEntity.SendChangedToRootRecursive(forceUpdate, ref existing);
			}
		}
		if (flag)
		{
			forceUpdate = forceUpdate && !flag2;
			OnCircuitChanged(forceUpdate);
		}
	}

	public void NotifyIndustrialNetworkChanged()
	{
		List<IOEntity> list = Pool.Get<List<IOEntity>>();
		OnIndustrialNetworkChanged();
		NotifyIndustrialNetworkChanged(list, input: true, 128);
		list.Clear();
		NotifyIndustrialNetworkChanged(list, input: false, 128);
		Pool.FreeUnmanaged<IOEntity>(ref list);
	}

	private void NotifyIndustrialNetworkChanged(List<IOEntity> existing, bool input, int maxDepth)
	{
		if (maxDepth <= 0 || existing.Contains(this))
		{
			return;
		}
		if (existing.Count != 0)
		{
			OnIndustrialNetworkChanged();
		}
		existing.Add(this);
		IOSlot[] array = (input ? inputs : outputs);
		foreach (IOSlot iOSlot in array)
		{
			if (iOSlot.type == IOType.Industrial && (Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				iOSlot.connectedTo.Get().NotifyIndustrialNetworkChanged(existing, input, maxDepth - 1);
			}
		}
	}

	protected virtual void OnIndustrialNetworkChanged()
	{
	}

	public bool ShouldUpdateOutputs()
	{
		if (Time.realtimeSinceStartup - lastUpdateTime < responsetime)
		{
			lastUpdateBlockedFrame = Time.frameCount;
			_processQueues[GetQueueType()].Enqueue(this);
			return false;
		}
		lastUpdateTime = Time.realtimeSinceStartup;
		SendIONetworkUpdate();
		if (outputs.Length == 0)
		{
			ensureOutputsUpdated = false;
			return false;
		}
		return true;
	}

	public virtual void UpdateOutputs()
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnOutputUpdate", (object)this) != null || !ShouldUpdateOutputs() || !ensureOutputsUpdated)
		{
			return;
		}
		ensureOutputsUpdated = false;
		TimeWarning val = TimeWarning.New("ProcessIOOutputs", 0);
		try
		{
			for (int i = 0; i < outputs.Length; i++)
			{
				IOSlot iOSlot = outputs[i];
				bool flag = true;
				IOEntity iOEntity = iOSlot.connectedTo.Get();
				if (!((Object)(object)iOEntity != (Object)null))
				{
					continue;
				}
				if (ioType == IOType.Fluidic && !DisregardGravityRestrictionsOnLiquid && !iOEntity.DisregardGravityRestrictionsOnLiquid)
				{
					TimeWarning val2 = TimeWarning.New("FluidOutputProcessing", 0);
					try
					{
						if (!iOEntity.AllowLiquidPassthrough(this, ((Component)this).transform.TransformPoint(iOSlot.handlePosition)))
						{
							flag = false;
						}
					}
					finally
					{
						((IDisposable)val2)?.Dispose();
					}
				}
				int passthroughAmount = GetPassthroughAmount(i);
				iOEntity.UpdateFromInput(flag ? passthroughAmount : 0, iOSlot.connectedToSlot);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Spawn()
	{
		base.Spawn();
		if (!Application.isLoadingSave)
		{
			Init();
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		Init();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		Init();
	}

	public override void Save(SaveInfo info)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.ioEntity = Pool.Get<IOEntity>();
		info.msg.ioEntity.inputs = Pool.Get<List<IOConnection>>();
		info.msg.ioEntity.outputs = Pool.Get<List<IOConnection>>();
		IOSlot[] array = inputs;
		foreach (IOSlot iOSlot in array)
		{
			IOConnection val = Pool.Get<IOConnection>();
			val.connectedID = iOSlot.connectedTo.entityRef.uid;
			val.connectedToSlot = iOSlot.connectedToSlot;
			val.niceName = iOSlot.niceName;
			val.type = (int)iOSlot.type;
			val.inUse = ((NetworkableId)(ref val.connectedID)).IsValid;
			val.colour = (int)iOSlot.wireColour;
			val.lineThickness = iOSlot.lineThickness;
			val.originPosition = iOSlot.originPosition;
			val.originRotation = iOSlot.originRotation;
			info.msg.ioEntity.inputs.Add(val);
		}
		array = outputs;
		foreach (IOSlot iOSlot2 in array)
		{
			IOConnection val2 = Pool.Get<IOConnection>();
			val2.connectedID = iOSlot2.connectedTo.entityRef.uid;
			val2.connectedToSlot = iOSlot2.connectedToSlot;
			val2.niceName = iOSlot2.niceName;
			val2.type = (int)iOSlot2.type;
			val2.inUse = ((NetworkableId)(ref val2.connectedID)).IsValid;
			val2.colour = (int)iOSlot2.wireColour;
			val2.worldSpaceRotation = iOSlot2.worldSpaceLineEndRotation;
			val2.lineThickness = iOSlot2.lineThickness;
			val2.originPosition = iOSlot2.originPosition;
			val2.originRotation = iOSlot2.originRotation;
			if (iOSlot2.linePoints != null)
			{
				val2.linePointList = Pool.Get<List<LineVec>>();
				for (int j = 0; j < iOSlot2.linePoints.Length; j++)
				{
					Vector3 val3 = iOSlot2.linePoints[j];
					LineVec val4 = Pool.Get<LineVec>();
					val4.vec = Vector4.op_Implicit(val3);
					if (iOSlot2.slackLevels.Length > j)
					{
						val4.vec.w = iOSlot2.slackLevels[j];
					}
					val2.linePointList.Add(val4);
				}
			}
			if (iOSlot2.slackLevels != null)
			{
				val2.slackLevels = iOSlot2.slackLevels.ToList();
			}
			if (iOSlot2.lineAnchors != null)
			{
				val2.lineAnchorList = Pool.Get<List<WireLineAnchorInfo>>();
				for (int k = 0; k < iOSlot2.lineAnchors.Length; k++)
				{
					if (iOSlot2.lineAnchors[k].entityRef.IsValid(serverside: true))
					{
						WireLineAnchorInfo item = iOSlot2.lineAnchors[k].ToInfo();
						val2.lineAnchorList.Add(item);
					}
				}
			}
			info.msg.ioEntity.outputs.Add(val2);
		}
	}

	public virtual float IOInput(IOEntity from, IOType inputType, float inputAmount, int slot = 0)
	{
		IOSlot[] array = outputs;
		foreach (IOSlot iOSlot in array)
		{
			if ((Object)(object)iOSlot.connectedTo.Get() != (Object)null)
			{
				inputAmount = iOSlot.connectedTo.Get().IOInput(this, iOSlot.type, inputAmount, iOSlot.connectedToSlot);
			}
		}
		return inputAmount;
	}

	public bool Disconnect(int index, bool isInput)
	{
		if (index >= (isInput ? inputs.Length : outputs.Length))
		{
			return false;
		}
		IOSlot iOSlot = (isInput ? inputs[index] : outputs[index]);
		if ((Object)(object)iOSlot.connectedTo.Get() == (Object)null)
		{
			return false;
		}
		IOEntity iOEntity = iOSlot.connectedTo.Get();
		IOSlot obj = (isInput ? iOEntity.outputs[iOSlot.connectedToSlot] : iOEntity.inputs[iOSlot.connectedToSlot]);
		if (isInput)
		{
			UpdateFromInput(0, index);
		}
		else if (Object.op_Implicit((Object)(object)iOEntity))
		{
			iOEntity.UpdateFromInput(0, iOSlot.connectedToSlot);
		}
		iOSlot.Clear();
		obj.Clear();
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdateImmediate();
		RefreshIndustrialPreventBuilding();
		if ((Object)(object)iOEntity != (Object)null)
		{
			iOEntity.RefreshIndustrialPreventBuilding();
		}
		if (isInput && (Object)(object)iOEntity != (Object)null)
		{
			iOEntity.SendChangedToRoot(forceUpdate: true);
		}
		else if (!isInput)
		{
			IOSlot[] array = inputs;
			foreach (IOSlot iOSlot2 in array)
			{
				if (iOSlot2.mainPowerSlot && Object.op_Implicit((Object)(object)iOSlot2.connectedTo.Get()))
				{
					iOSlot2.connectedTo.Get().SendChangedToRoot(forceUpdate: true);
				}
			}
		}
		iOEntity.SendNetworkUpdateImmediate();
		if (ioType == IOType.Industrial)
		{
			NotifyIndustrialNetworkChanged();
		}
		if ((Object)(object)iOEntity != (Object)null && iOEntity.ioType == IOType.Industrial)
		{
			iOEntity.NotifyIndustrialNetworkChanged();
		}
		return true;
	}

	public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex)
	{
		ConnectTo(entity, outputIndex, inputIndex, new List<Vector3>(), new List<float>(), new LineAnchor[0]);
	}

	public void ConnectTo(IOEntity entity, int outputIndex, int inputIndex, List<Vector3> points, List<float> slackLevels, LineAnchor[] lineAnchors, WireTool.WireColour colour = WireTool.WireColour.Gray)
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		IOSlot obj = entity.inputs[inputIndex];
		obj.connectedTo.Set(this);
		obj.connectedToSlot = outputIndex;
		obj.wireColour = colour;
		obj.connectedTo.Init();
		IOSlot obj2 = outputs[outputIndex];
		obj2.connectedTo.Set(entity);
		obj2.connectedToSlot = inputIndex;
		obj2.linePoints = points.ToArray();
		obj2.slackLevels = slackLevels.ToArray();
		obj2.lineAnchors = lineAnchors;
		obj2.wireColour = colour;
		obj2.connectedTo.Init();
		obj2.worldSpaceLineEndRotation = ((Component)entity).transform.TransformDirection(entity.inputs[inputIndex].handleDirection);
		obj2.originPosition = ((Component)this).transform.position;
		Quaternion rotation = ((Component)this).transform.rotation;
		obj2.originRotation = ((Quaternion)(ref rotation)).eulerAngles;
		MarkDirtyForceUpdateOutputs();
		SendNetworkUpdate();
		entity.SendNetworkUpdate();
		SendChangedToRoot(forceUpdate: true);
		RefreshIndustrialPreventBuilding();
	}

	public void FindContainerSource(List<ContainerInputOutput> found, int depth, bool input, List<IOEntity> ignoreList, int parentId = -1, int stackSize = 0)
	{
		if (depth <= 0 || found.Count >= 32)
		{
			return;
		}
		int num = 0;
		int num2 = 1;
		IOSlot[] array;
		if (!input)
		{
			num2 = 0;
			array = outputs;
			for (int i = 0; i < array.Length; i++)
			{
				if (array[i].type == IOType.Industrial)
				{
					num2++;
				}
			}
		}
		List<int> list = Pool.Get<List<int>>();
		array = (input ? inputs : outputs);
		foreach (IOSlot iOSlot in array)
		{
			num++;
			if (iOSlot.type != IOType.Industrial)
			{
				continue;
			}
			IOEntity iOEntity = iOSlot.connectedTo.Get(base.isServer);
			if (!((Object)(object)iOEntity != (Object)null) || ignoreList.Contains(iOEntity))
			{
				continue;
			}
			int num3 = -1;
			if (iOEntity is IIndustrialStorage storage2)
			{
				num = iOSlot.connectedToSlot;
				if (GetExistingCount(storage2) < 2)
				{
					found.Add(new ContainerInputOutput
					{
						SlotIndex = num,
						Storage = storage2,
						ParentStorage = parentId,
						MaxStackSize = stackSize / num2
					});
					num3 = found.Count - 1;
					list.Add(num3);
				}
			}
			else
			{
				ignoreList.Add(iOEntity);
			}
			if ((!(iOEntity is IIndustrialStorage) || iOEntity is IndustrialStorageAdaptor) && !(iOEntity is IndustrialConveyor) && (Object)(object)iOEntity != (Object)null)
			{
				iOEntity.FindContainerSource(found, depth - 1, input, ignoreList, (num3 == -1) ? parentId : num3, stackSize / num2);
			}
		}
		int count = list.Count;
		foreach (int item in list)
		{
			ContainerInputOutput value = found[item];
			value.IndustrialSiblingCount = count;
			found[item] = value;
		}
		Pool.FreeUnmanaged<int>(ref list);
		int GetExistingCount(IIndustrialStorage storage)
		{
			int num4 = 0;
			foreach (ContainerInputOutput item2 in found)
			{
				if (item2.Storage == storage)
				{
					num4++;
				}
			}
			return num4;
		}
	}

	public virtual bool AllowLiquidPassthrough(IOEntity fromSource, Vector3 sourceWorldPosition, bool forPlacement = false)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (fromSource.DisregardGravityRestrictionsOnLiquid || DisregardGravityRestrictionsOnLiquid)
		{
			return true;
		}
		if (inputs.Length == 0)
		{
			return false;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(inputs[0].handlePosition);
		float num = sourceWorldPosition.y - val.y;
		if (num > 0f)
		{
			return true;
		}
		if (Mathf.Abs(num) < LiquidPassthroughGravityThreshold)
		{
			return true;
		}
		return false;
	}

	public override void Load(LoadInfo info)
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.ioEntity == null)
		{
			return;
		}
		if (!info.fromDisk && info.msg.ioEntity.inputs != null)
		{
			int count = info.msg.ioEntity.inputs.Count;
			if (inputs.Length != count)
			{
				inputs = new IOSlot[count];
			}
			for (int i = 0; i < count; i++)
			{
				if (inputs[i] == null)
				{
					inputs[i] = new IOSlot();
				}
				IOConnection val = info.msg.ioEntity.inputs[i];
				inputs[i].connectedTo = new IORef();
				inputs[i].connectedTo.entityRef.uid = val.connectedID;
				if (base.isClient)
				{
					inputs[i].connectedTo.InitClient();
				}
				inputs[i].connectedToSlot = val.connectedToSlot;
				inputs[i].niceName = val.niceName;
				inputs[i].type = (IOType)val.type;
				inputs[i].wireColour = (WireTool.WireColour)val.colour;
				inputs[i].lineThickness = val.lineThickness;
				inputs[i].originPosition = val.originPosition;
				inputs[i].originRotation = val.originRotation;
			}
		}
		if (info.msg.ioEntity.outputs != null)
		{
			int count2 = info.msg.ioEntity.outputs.Count;
			IOSlot[] array = null;
			if (outputs.Length != count2 && count2 > 0)
			{
				array = outputs;
				outputs = new IOSlot[count2];
				for (int j = 0; j < array.Length; j++)
				{
					if (j < count2)
					{
						outputs[j] = array[j];
					}
				}
			}
			for (int k = 0; k < count2; k++)
			{
				if (outputs[k] == null)
				{
					outputs[k] = new IOSlot();
				}
				IOConnection val2 = info.msg.ioEntity.outputs[k];
				if (val2.linePointList == null || val2.linePointList.Count == 0 || !((NetworkableId)(ref val2.connectedID)).IsValid)
				{
					outputs[k].Clear();
				}
				outputs[k].connectedTo = new IORef();
				outputs[k].connectedTo.entityRef.uid = val2.connectedID;
				if (base.isClient)
				{
					outputs[k].connectedTo.InitClient();
				}
				outputs[k].connectedToSlot = val2.connectedToSlot;
				outputs[k].niceName = val2.niceName;
				outputs[k].type = (IOType)val2.type;
				outputs[k].wireColour = (WireTool.WireColour)val2.colour;
				outputs[k].worldSpaceLineEndRotation = val2.worldSpaceRotation;
				outputs[k].lineThickness = val2.lineThickness;
				outputs[k].originPosition = (info.fromCopy ? ((Component)this).transform.position : val2.originPosition);
				IOSlot obj = outputs[k];
				Vector3 originRotation;
				if (!info.fromCopy)
				{
					originRotation = val2.originRotation;
				}
				else
				{
					Quaternion rotation = ((Component)this).transform.rotation;
					originRotation = ((Quaternion)(ref rotation)).eulerAngles;
				}
				obj.originRotation = originRotation;
				if (!info.fromDisk && !base.isClient)
				{
					continue;
				}
				List<LineVec> list = val2.linePointList ?? new List<LineVec>();
				if (outputs[k].linePoints == null || outputs[k].linePoints.Length != list.Count)
				{
					outputs[k].linePoints = (Vector3[])(object)new Vector3[list.Count];
				}
				if (outputs[k].slackLevels == null || outputs[k].slackLevels.Length != list.Count)
				{
					outputs[k].slackLevels = new float[list.Count];
				}
				for (int l = 0; l < list.Count; l++)
				{
					outputs[k].linePoints[l] = Vector4.op_Implicit(list[l].vec);
					outputs[k].slackLevels[l] = list[l].vec.w;
				}
				List<WireLineAnchorInfo> list2 = val2.lineAnchorList ?? new List<WireLineAnchorInfo>();
				if (outputs[k].lineAnchors == null || outputs[k].lineAnchors.Length != list2.Count)
				{
					outputs[k].lineAnchors = new LineAnchor[list2.Count];
				}
				for (int m = 0; m < list2.Count; m++)
				{
					WireLineAnchorInfo val3 = list2[m];
					if (((NetworkableId)(ref val3.parentID)).IsValid)
					{
						LineAnchor lineAnchor = new LineAnchor(val3);
						outputs[k].lineAnchors[m] = lineAnchor;
					}
				}
			}
		}
		RefreshIndustrialPreventBuilding();
	}

	public int GetConnectedInputCount()
	{
		int num = 0;
		IOSlot[] array = inputs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].connectedTo.Get(base.isServer) != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public int GetConnectedOutputCount()
	{
		int num = 0;
		IOSlot[] array = outputs;
		for (int i = 0; i < array.Length; i++)
		{
			if ((Object)(object)array[i].connectedTo.Get(base.isServer) != (Object)null)
			{
				num++;
			}
		}
		return num;
	}

	public bool HasConnections()
	{
		if (GetConnectedInputCount() <= 0)
		{
			return GetConnectedOutputCount() > 0;
		}
		return true;
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		ClearIndustrialPreventBuilding();
	}

	public void RefreshIndustrialPreventBuilding()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		ClearIndustrialPreventBuilding();
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		CapsuleCollider val5 = default(CapsuleCollider);
		ColliderInfo_Pipe colliderInfo_Pipe = default(ColliderInfo_Pipe);
		for (int i = 0; i < outputs.Length; i++)
		{
			IOSlot iOSlot = outputs[i];
			if (iOSlot.type != IOType.Industrial || iOSlot.linePoints == null || iOSlot.linePoints.Length <= 1)
			{
				continue;
			}
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(iOSlot.linePoints[0]);
			for (int j = 1; j < iOSlot.linePoints.Length; j++)
			{
				Vector3 val2 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(iOSlot.linePoints[j]);
				Vector3 pos = Vector3.Lerp(val2, val, 0.5f);
				float num = Vector3.Distance(val2, val);
				Vector3 val3 = val2 - val;
				Quaternion val4;
				if (!(((Vector3)(ref val3)).normalized != Vector3.zero))
				{
					val4 = Quaternion.identity;
				}
				else
				{
					val3 = val2 - val;
					val4 = Quaternion.LookRotation(((Vector3)(ref val3)).normalized);
				}
				Quaternion rot = val4;
				GameObject obj = base.gameManager.CreatePrefab("assets/prefabs/misc/ioentitypreventbuilding.prefab", pos, rot);
				obj.transform.SetParent(((Component)this).transform);
				if (obj.TryGetComponent<CapsuleCollider>(ref val5))
				{
					val5.height = num + val5.radius;
					spawnedColliders.Add((Collider)(object)val5);
				}
				if (obj.TryGetComponent<ColliderInfo_Pipe>(ref colliderInfo_Pipe))
				{
					colliderInfo_Pipe.OutputSlotIndex = i;
					colliderInfo_Pipe.ParentEntity = this;
				}
				val = val2;
			}
		}
	}

	private void ClearIndustrialPreventBuilding()
	{
		foreach (Collider spawnedCollider in spawnedColliders)
		{
			base.gameManager.Retire(((Component)spawnedCollider).gameObject);
		}
		spawnedColliders.Clear();
	}
}
