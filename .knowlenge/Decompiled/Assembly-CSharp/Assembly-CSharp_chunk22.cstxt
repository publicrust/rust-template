using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using ConVar;
using Network;
using ProtoBuf;
using Rust;
using UnityEngine;

public static class Azure
{
	public enum ResourceMode
	{
		Produced,
		Consumed
	}

	private static class EventIds
	{
		public const string EntityBuilt = "entity_built";

		public const string EntityPickup = "entity_pickup";

		public const string EntityDamage = "entity_damage";

		public const string PlayerRespawn = "player_respawn";

		public const string ExplosiveLaunched = "explosive_launch";

		public const string Explosion = "explosion";

		public const string ItemEvent = "item_event";

		public const string EntitySum = "entity_sum";

		public const string ItemSum = "item_sum";

		public const string ItemDespawn = "item_despawn";

		public const string ItemDropped = "item_drop";

		public const string ItemPickup = "item_pickup";

		public const string AntihackViolation = "antihack_violation";

		public const string AntihackViolationDetailed = "antihack_violation_detailed";

		public const string PlayerConnect = "player_connect";

		public const string PlayerDisconnect = "player_disconnect";

		public const string ConsumableUsed = "consumeable_used";

		public const string MedUsed = "med_used";

		public const string ResearchStarted = "research_start";

		public const string BlueprintLearned = "blueprint_learned";

		public const string TeamChanged = "team_change";

		public const string EntityAuthChange = "auth_change";

		public const string VendingOrderChanged = "vending_changed";

		public const string VendingSale = "vending_sale";

		public const string ChatMessage = "chat";

		public const string BlockUpgrade = "block_upgrade";

		public const string BlockDemolish = "block_demolish";

		public const string ItemRepair = "item_repair";

		public const string EntityRepair = "entity_repair";

		public const string ItemSkinned = "item_skinned";

		public const string EntitySkinned = "entity_skinned";

		public const string ItemAggregate = "item_aggregate";

		public const string CodelockChanged = "code_change";

		public const string CodelockEntered = "code_enter";

		public const string SleepingBagAssign = "sleeping_bag_assign";

		public const string FallDamage = "fall_damage";

		public const string PlayerWipeIdSet = "player_wipe_id_set";

		public const string ServerInfo = "server_info";

		public const string UnderwaterCrateUntied = "crate_untied";

		public const string VehiclePurchased = "vehicle_purchase";

		public const string NPCVendor = "npc_vendor";

		public const string BlueprintsOnline = "blueprint_aggregate_online";

		public const string PlayerPositions = "player_positions";

		public const string ProjectileInvalid = "projectile_invalid";

		public const string ItemDefinitions = "item_definitions";

		public const string KeycardSwiped = "keycard_swiped";

		public const string EntitySpawned = "entity_spawned";

		public const string EntityKilled = "entity_killed";

		public const string HackableCrateStarted = "hackable_crate_started";

		public const string HackableCrateEnded = "hackable_crate_ended";

		public const string StashHidden = "stash_hidden";

		public const string StashRevealed = "stash_reveal";

		public const string EntityManifest = "entity_manifest";

		public const string LootEntity = "loot_entity";

		public const string OnlineTeams = "online_teams";

		public const string Gambling = "gambing";

		public const string BuildingBlockColor = "building_block_color";

		public const string MissionComplete = "mission_complete";

		public const string PlayerPinged = "player_pinged";

		public const string BagUnclaim = "bag_unclaim";

		public const string SteamAuth = "steam_auth";

		public const string ParachuteUsed = "parachute_used";

		public const string MountEntity = "mount";

		public const string DismountEntity = "dismount";

		public const string BurstToggle = "burst_toggle";

		public const string TutorialStarted = "tutorial_started";

		public const string TutorialCompleted = "tutorial_completed";

		public const string TutorialQuit = "tutorial_quit";

		public const string BaseInteraction = "base_interaction";

		public const string PlayerDeath = "player_death";

		public const string CarShredded = "car_shredded";

		public const string PlayerTick = "player_tick";

		public const string WallpaperPlaced = "wallpaper_placed";

		public const string StartFish = "fishing_start";

		public const string FailedFish = "fishing_failed";

		public const string CaughtFish = "fishing_caught";

		public const string InjureStateChange = "injure_state";

		public const string LifeStoryEnd = "life_story_end";

		public const string ServerRPC = "server_rpc";
	}

	private struct SimpleItemAmount
	{
		public string ItemName;

		public int Amount;

		public ulong Skin;

		public float Condition;

		public SimpleItemAmount(Item item)
		{
			ItemName = item.info.shortname;
			Amount = item.amount;
			Skin = item.skin;
			Condition = item.conditionNormalized;
		}
	}

	private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
	{
		public ulong UserId;

		public int ProjectileId;

		public FiredProjectileKey(ulong userId, int projectileId)
		{
			UserId = userId;
			ProjectileId = projectileId;
		}

		public bool Equals(FiredProjectileKey other)
		{
			if (other.UserId == UserId)
			{
				return other.ProjectileId == ProjectileId;
			}
			return false;
		}
	}

	private class PendingFiredProjectile : IPooled
	{
		public EventRecord Record;

		public BasePlayer.FiredProjectile FiredProjectile;

		public bool Hit;

		public void EnterPool()
		{
			Hit = false;
			Record = null;
			FiredProjectile = null;
		}

		public void LeavePool()
		{
		}
	}

	[JsonModel]
	private struct EntitySumItem
	{
		public uint PrefabId;

		public int Count;

		public int Grade;
	}

	private struct EntityKey : IEquatable<EntityKey>
	{
		public uint PrefabId;

		public int Grade;

		public bool Equals(EntityKey other)
		{
			if (PrefabId == other.PrefabId)
			{
				return Grade == other.Grade;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
		}
	}

	private class PendingItemsData : IPooled
	{
		public PendingItemsKey Key;

		public int amount;

		public string category;

		public void EnterPool()
		{
			Key = default(PendingItemsKey);
			amount = 0;
			category = null;
		}

		public void LeavePool()
		{
		}
	}

	private struct PendingItemsKey : IEquatable<PendingItemsKey>
	{
		public string Item;

		public bool Consumed;

		public string Entity;

		public string Category;

		public NetworkableId EntityId;

		public bool Equals(PendingItemsKey other)
		{
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
			{
				return Category == other.Category;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
		}
	}

	[JsonModel]
	private class PlayerAggregate : IPooled
	{
		public string UserId;

		public Vector3 Position;

		public Vector3 Direction;

		public List<string> Hotbar = new List<string>();

		public List<string> Worn = new List<string>();

		public string ActiveItem;

		public string Biome;

		public void EnterPool()
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			UserId = null;
			Position = default(Vector3);
			Direction = default(Vector3);
			Hotbar.Clear();
			Worn.Clear();
			ActiveItem = null;
			Biome = null;
		}

		public void LeavePool()
		{
		}
	}

	[JsonModel]
	private class TeamInfo : IPooled
	{
		public List<string> online = new List<string>();

		public List<string> offline = new List<string>();

		public int member_count;

		public void EnterPool()
		{
			online.Clear();
			offline.Clear();
			member_count = 0;
		}

		public void LeavePool()
		{
		}
	}

	private static Dictionary<FiredProjectileKey, PendingFiredProjectile> trackedProjectiles = new Dictionary<FiredProjectileKey, PendingFiredProjectile>();

	private static Dictionary<int, string> geneCache = new Dictionary<int, string>();

	public static int MaxMSPerFrame = 5;

	private static Dictionary<PendingItemsKey, PendingItemsData> pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();

	public static bool GameplayAnalytics => GameplayAnalyticsConVar;

	public static void Initialize()
	{
		PushItemDefinitions();
		PushEntityManifest();
		((MonoBehaviour)SingletonComponent<ServerMgr>.Instance).StartCoroutine(AggregateLoop());
	}

	private static void PushServerInfo()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("server_info").AddField("seed", World.Seed).AddField("size", World.Size)
				.AddField("url", World.Url)
				.AddField("ip_convar", Net.sv.ip)
				.AddField("port_convar", Net.sv.port)
				.AddField("net_protocol", Net.sv.ProtocolId)
				.AddField("protocol_network", 2597)
				.AddField("protocol_save", 271);
			BuildInfo current = BuildInfo.Current;
			EventRecord eventRecord2 = eventRecord.AddField("changeset", ((current != null) ? current.Scm.ChangeId : null) ?? "0").AddField("unity_version", Application.unityVersion);
			BuildInfo current2 = BuildInfo.Current;
			SubmitPoint(eventRecord2.AddField("branch", ((current2 != null) ? current2.Scm.Branch : null) ?? "empty").AddField("server_tags", ConVar.Server.tags).AddField("device_id", SystemInfo.deviceUniqueIdentifier)
				.AddField("network_id", Net.sv.GetLastUIDGiven()));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void PushItemDefinitions()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)GameManifest.Current == (Object)null)
			{
				return;
			}
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj == null)
			{
				return;
			}
			SubmitPoint(EventRecord.New("item_definitions").AddObject("items", from x in ItemManager.itemDictionary
				select x.Value into x
				select new
				{
					item_id = x.itemid,
					shortname = x.shortname,
					craft_time = (x.Blueprint?.GetCraftTime() ?? 0f),
					workbench = (x.Blueprint?.GetWorkbenchLevel() ?? 0),
					category = x.category.ToString(),
					display_name = x.displayName.english,
					despawn_rarity = x.despawnRarity,
					ingredients = (from y in x.Blueprint?.GetIngredients()
						select new
						{
							shortname = y.itemDef.shortname,
							amount = (int)y.amount
						})
				}).AddField("changeset", BuildInfo.Current.Scm.ChangeId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void PushEntityManifest()
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)GameManifest.Current == (Object)null)
			{
				return;
			}
			BuildInfo current = BuildInfo.Current;
			object obj;
			if (current == null)
			{
				obj = null;
			}
			else
			{
				ScmInfo scm = current.Scm;
				obj = ((scm != null) ? scm.ChangeId : null);
			}
			if (obj != null)
			{
				EventRecord eventRecord = EventRecord.New("entity_manifest").AddObject("entities", GameManifest.Current.entities.Select((string x) => new
				{
					shortname = Path.GetFileNameWithoutExtension(x),
					prefab_id = StringPool.Get(x.ToLower())
				}));
				BuildInfo current2 = BuildInfo.Current;
				SubmitPoint(eventRecord.AddField("changeset", ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor"));
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void SubmitPoint(EventRecord point)
	{
		point.Submit();
	}

	public static void OnFiredProjectile(BasePlayer player, BasePlayer.FiredProjectile projectile, Guid projectileGroupId)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord record = EventRecord.New("entity_damage").AddField("start_pos", projectile.position).AddField("start_vel", projectile.initialVelocity)
				.AddField("velocity_inherit", projectile.inheritedVelocity)
				.AddField("ammo_item", projectile.itemDef?.shortname)
				.AddField("weapon", (BaseNetworkable)projectile.weaponSource)
				.AddField("projectile_group", projectileGroupId)
				.AddField("projectile_id", projectile.id)
				.AddField("attacker", (BaseNetworkable)player)
				.AddField("look_dir", player.tickViewAngles)
				.AddField("model_state", (player.modelStateTick ?? player.modelState).flags)
				.AddField("burst_mode", projectile.weaponSource?.HasFlag(BaseEntity.Flags.Reserved6) ?? false);
			PendingFiredProjectile pendingFiredProjectile = Pool.Get<PendingFiredProjectile>();
			pendingFiredProjectile.Record = record;
			pendingFiredProjectile.FiredProjectile = projectile;
			trackedProjectiles[new FiredProjectileKey(player.userID, projectile.id)] = pendingFiredProjectile;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFiredProjectileRemoved(BasePlayer player, BasePlayer.FiredProjectile projectile)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			FiredProjectileKey key = new FiredProjectileKey(player.userID, projectile.id);
			if (!trackedProjectiles.TryGetValue(key, out var value))
			{
				return;
			}
			if (!value.Hit)
			{
				EventRecord record = value.Record;
				if (projectile.updates.Count > 0)
				{
					record.AddObject("projectile_updates", projectile.updates);
				}
				SubmitPoint(record);
			}
			Pool.Free<PendingFiredProjectile>(ref value);
			trackedProjectiles.Remove(key);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnQuarryItem(ResourceMode mode, string item, int amount, MiningQuarry sourceEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			AddPendingItems(sourceEntity, item, amount, "quarry", mode == ResourceMode.Consumed);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExcavatorProduceItem(Item item, BaseEntity sourceEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			AddPendingItems(sourceEntity, item.info.shortname, item.amount, "excavator", consumed: false);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExcavatorConsumeFuel(Item item, int amount, BaseEntity dieselEngine)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Consumed, "excavator", item.info.shortname, amount, dieselEngine, null, safezone: false, null, 0uL);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCraftItem(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "craft", item, amount, null, null, inSafezone, workbench, player?.userID ?? ((EncryptedValue<ulong>)0uL));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCraftMaterialConsumed(string item, int amount, BasePlayer player, BaseEntity workbench, bool inSafezone, string targetItem)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(safezone: inSafezone, workbench: workbench, targetItem: targetItem, mode: ResourceMode.Consumed, category: "craft", itemName: item, amount: amount, sourceEntity: null, tool: null, steamId: player?.userID ?? ((EncryptedValue<ulong>)0uL));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnConsumableUsed(BasePlayer player, Item item)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("consumeable_used").AddField("player", (BaseNetworkable)player).AddField("item", item));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntitySpawned(BaseEntity entity)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			trackedSpawnedIds.Add(entity.net.ID);
			SubmitPoint(EventRecord.New("entity_spawned").AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void TryLogEntityKilled(BaseNetworkable entity)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity.IsValid() && trackedSpawnedIds.Contains(entity.net.ID))
			{
				SubmitPoint(EventRecord.New("entity_killed").AddField("entity", entity));
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMedUsed(string itemName, BasePlayer player, BasePlayer target)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("med_used").AddField("player", (BaseNetworkable)player).AddField("target", (BaseNetworkable)target)
				.AddField("item_name", itemName));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCodelockChanged(BasePlayer player, CodeLock codeLock, string oldCode, string newCode, bool isGuest)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("code_change").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
				.AddField("old_code", oldCode)
				.AddField("new_code", newCode)
				.AddField("is_guest", isGuest));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCodeLockEntered(BasePlayer player, CodeLock codeLock, bool isGuest)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("code_enter").AddField("player", (BaseNetworkable)player).AddField("codelock", (BaseNetworkable)codeLock)
				.AddField("is_guest", isGuest));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTeamChanged(string change, ulong teamId, ulong teamLeader, ulong user, List<ulong> members)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		try
		{
			if (members != null)
			{
				foreach (ulong member in members)
				{
					list.Add(member);
				}
			}
			SubmitPoint(EventRecord.New("team_change").AddField("team_leader", teamLeader).AddField("team", teamId)
				.AddField("target_user", user)
				.AddField("change", change)
				.AddObject("users", list)
				.AddField("member_count", members.Count));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
		Pool.FreeUnmanaged<ulong>(ref list);
	}

	public static void OnEntityAuthChanged(BaseEntity entity, BasePlayer player, IEnumerable<ulong> authedList, string change, ulong targetUser)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("auth_change").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
				.AddField("target", targetUser)
				.AddObject("auth_list", authedList)
				.AddField("change", change));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSleepingBagAssigned(BasePlayer player, SleepingBag bag, ulong targetUser)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("sleeping_bag_assign").AddField("entity", (BaseNetworkable)bag).AddField("player", (BaseNetworkable)player)
				.AddField("target", targetUser));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFallDamage(BasePlayer player, float velocity, float damage)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fall_damage").AddField("player", (BaseNetworkable)player).AddField("velocity", velocity)
				.AddField("damage", damage));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnResearchStarted(BasePlayer player, BaseEntity entity, Item item, int scrapCost)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("research_start").AddField("player", (BaseNetworkable)player).AddField("item", item.info.shortname)
				.AddField("scrap", scrapCost)
				.AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBlueprintLearned(BasePlayer player, ItemDefinition item, string reason, int scrapCost, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("blueprint_learned").AddField("player", (BaseNetworkable)player).AddField("item", item.shortname)
				.AddField("reason", reason)
				.AddField("entity", (BaseNetworkable)entity)
				.AddField("scrap_cost", scrapCost));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemRecycled(string item, int amount, Recycler recycler)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Consumed, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnRecyclerItemProduced(string item, int amount, Recycler recycler, Item sourceItem)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "recycler", item, amount, recycler, null, safezone: false, null, recycler.LastLootedBy, null, sourceItem);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnGatherItem(string item, int amount, BaseEntity sourceEntity, BasePlayer player, AttackEntity weapon = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			LogResource(ResourceMode.Produced, "gather", item, amount, sourceEntity, weapon, safezone: false, null, player.userID);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFirstLooted(BaseEntity entity, BasePlayer player)
	{
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity is LootContainer lootContainer)
			{
				LogItemsLooted(player, entity, lootContainer.inventory);
				SubmitPoint(EventRecord.New("loot_entity").AddField("entity", (BaseNetworkable)entity).AddField("player", (BaseNetworkable)player)
					.AddField("monument", GetMonument(entity))
					.AddField("biome", GetBiome(((Component)entity).transform.position)));
			}
			else if (entity is LootableCorpse { containers: var containers })
			{
				foreach (ItemContainer container in containers)
				{
					LogItemsLooted(player, entity, container);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLootContainerDestroyed(LootContainer entity, BasePlayer player, AttackEntity weapon)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (entity.DropsLoot && (Object)(object)player != (Object)null && Vector3.Distance(((Component)entity).transform.position, ((Component)player).transform.position) < 50f && entity.inventory?.itemList != null && entity.inventory.itemList.Count > 0)
			{
				LogItemsLooted(player, entity, entity.inventory, weapon);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityDestroyed(BaseNetworkable entity)
	{
		TryLogEntityKilled(entity);
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (!(entity is LootContainer { FirstLooterId: 0uL } lootContainer))
			{
				return;
			}
			foreach (Item item in lootContainer.inventory.itemList)
			{
				OnItemDespawn(lootContainer, item, 3, lootContainer.LastLootedBy);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityBuilt(BaseEntity entity, BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("entity_built").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity);
			if (entity is SleepingBag)
			{
				int sleepingBagCount = SleepingBag.GetSleepingBagCount(player.userID);
				eventRecord.AddField("bags_active", sleepingBagCount);
				eventRecord.AddField("max_sleeping_bags", ConVar.Server.max_sleeping_bags);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("mount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
				.AddField("seat", (BaseNetworkable)seat));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnDismountEntity(BasePlayer player, BaseEntity seat, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("dismount").AddField("player", (BaseNetworkable)player).AddField("vehicle", (BaseNetworkable)vehicle)
				.AddField("seat", (BaseNetworkable)seat));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnKeycardSwiped(BasePlayer player, CardReader cardReader)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("keycard_swiped").AddField("player", (BaseNetworkable)player).AddField("card_level", cardReader.accessLevel)
				.AddField("entity", (BaseNetworkable)cardReader));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLockedCrateStarted(BasePlayer player, HackableLockedCrate crate)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("hackable_crate_started").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)crate));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnLockedCrateFinished(ulong player, HackableLockedCrate crate)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("hackable_crate_ended").AddField("player_steamid", player).AddField("entity", (BaseNetworkable)crate));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStashHidden(BasePlayer player, StashContainer entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("stash_hidden").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("owner", entity.OwnerID));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStashRevealed(BasePlayer player, StashContainer entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("stash_reveal").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("owner", entity.OwnerID));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnAntihackViolation(BasePlayer player, AntiHackType type, string message)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("antihack_violation").AddField("player", (BaseNetworkable)player).AddField("violation_type", (int)type)
				.AddField("violation", type.ToString())
				.AddField("message", message);
			if (BuildInfo.Current != null)
			{
				eventRecord.AddField("changeset", BuildInfo.Current.Scm.ChangeId).AddField("network", 2597);
			}
			switch (type)
			{
			case AntiHackType.SpeedHack:
				eventRecord.AddField("speedhack_protection", ConVar.AntiHack.speedhack_protection).AddField("speedhack_forgiveness", ConVar.AntiHack.speedhack_forgiveness).AddField("speedhack_forgiveness_inertia", ConVar.AntiHack.speedhack_forgiveness_inertia)
					.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_penalty)
					.AddField("speedhack_penalty", ConVar.AntiHack.speedhack_reject)
					.AddField("speedhack_slopespeed", ConVar.AntiHack.speedhack_slopespeed);
				break;
			case AntiHackType.NoClip:
				eventRecord.AddField("noclip_protection", ConVar.AntiHack.noclip_protection).AddField("noclip_penalty", ConVar.AntiHack.noclip_penalty).AddField("noclip_maxsteps", ConVar.AntiHack.noclip_maxsteps)
					.AddField("noclip_margin_dismount", ConVar.AntiHack.noclip_margin_dismount)
					.AddField("noclip_margin", ConVar.AntiHack.noclip_margin)
					.AddField("noclip_backtracking", ConVar.AntiHack.noclip_backtracking)
					.AddField("noclip_reject", ConVar.AntiHack.noclip_reject)
					.AddField("noclip_stepsize", ConVar.AntiHack.noclip_stepsize);
				break;
			case AntiHackType.ProjectileHack:
				eventRecord.AddField("projectile_anglechange", ConVar.AntiHack.projectile_anglechange).AddField("projectile_backtracking", ConVar.AntiHack.projectile_backtracking).AddField("projectile_clientframes", ConVar.AntiHack.projectile_clientframes)
					.AddField("projectile_damagedepth", ConVar.AntiHack.projectile_damagedepth)
					.AddField("projectile_desync", ConVar.AntiHack.projectile_desync)
					.AddField("projectile_forgiveness", ConVar.AntiHack.projectile_forgiveness)
					.AddField("projectile_impactspawndepth", ConVar.AntiHack.projectile_impactspawndepth)
					.AddField("projectile_losforgiveness", ConVar.AntiHack.projectile_losforgiveness)
					.AddField("projectile_penalty", ConVar.AntiHack.projectile_penalty)
					.AddField("projectile_positionoffset", ConVar.AntiHack.projectile_positionoffset)
					.AddField("projectile_protection", ConVar.AntiHack.projectile_protection)
					.AddField("projectile_serverframes", ConVar.AntiHack.projectile_serverframes)
					.AddField("projectile_terraincheck", ConVar.AntiHack.projectile_terraincheck)
					.AddField("projectile_trajectory", ConVar.AntiHack.projectile_trajectory)
					.AddField("projectile_vehiclecheck", ConVar.AntiHack.projectile_vehiclecheck)
					.AddField("projectile_velocitychange", ConVar.AntiHack.projectile_velocitychange);
				break;
			case AntiHackType.InsideTerrain:
				eventRecord.AddField("terrain_check_geometry", ConVar.AntiHack.terrain_check_geometry).AddField("terrain_kill", ConVar.AntiHack.terrain_kill).AddField("terrain_padding", ConVar.AntiHack.terrain_padding)
					.AddField("terrain_penalty", ConVar.AntiHack.terrain_penalty)
					.AddField("terrain_protection", ConVar.AntiHack.terrain_protection)
					.AddField("terrain_timeslice", ConVar.AntiHack.terrain_timeslice);
				break;
			case AntiHackType.MeleeHack:
				eventRecord.AddField("melee_backtracking", ConVar.AntiHack.melee_backtracking).AddField("melee_clientframes", ConVar.AntiHack.melee_clientframes).AddField("melee_forgiveness", ConVar.AntiHack.melee_forgiveness)
					.AddField("melee_losforgiveness", ConVar.AntiHack.melee_losforgiveness)
					.AddField("melee_penalty", ConVar.AntiHack.melee_penalty)
					.AddField("melee_protection", ConVar.AntiHack.melee_protection)
					.AddField("melee_serverframes", ConVar.AntiHack.melee_serverframes)
					.AddField("melee_terraincheck", ConVar.AntiHack.melee_terraincheck)
					.AddField("melee_vehiclecheck", ConVar.AntiHack.melee_vehiclecheck);
				break;
			case AntiHackType.FlyHack:
				eventRecord.AddField("flyhack_extrusion", ConVar.AntiHack.flyhack_extrusion).AddField("flyhack_forgiveness_horizontal", ConVar.AntiHack.flyhack_forgiveness_horizontal).AddField("flyhack_forgiveness_horizontal_inertia", ConVar.AntiHack.flyhack_forgiveness_horizontal_inertia)
					.AddField("flyhack_forgiveness_vertical", ConVar.AntiHack.flyhack_forgiveness_vertical)
					.AddField("flyhack_forgiveness_vertical_inertia", ConVar.AntiHack.flyhack_forgiveness_vertical_inertia)
					.AddField("flyhack_margin", ConVar.AntiHack.flyhack_margin)
					.AddField("flyhack_maxsteps", ConVar.AntiHack.flyhack_maxsteps)
					.AddField("flyhack_penalty", ConVar.AntiHack.flyhack_penalty)
					.AddField("flyhack_protection", ConVar.AntiHack.flyhack_protection)
					.AddField("flyhack_reject", ConVar.AntiHack.flyhack_reject);
				break;
			case AntiHackType.EyeHack:
				eventRecord.AddField("eye_clientframes", ConVar.AntiHack.eye_clientframes).AddField("eye_forgiveness", ConVar.AntiHack.eye_forgiveness).AddField("eye_history_forgiveness", ConVar.AntiHack.eye_history_forgiveness)
					.AddField("eye_history_penalty", ConVar.AntiHack.eye_history_penalty)
					.AddField("eye_losradius", ConVar.AntiHack.eye_losradius)
					.AddField("eye_noclip_backtracking", ConVar.AntiHack.eye_noclip_backtracking)
					.AddField("eye_noclip_cutoff", ConVar.AntiHack.eye_noclip_cutoff)
					.AddField("eye_penalty", ConVar.AntiHack.eye_penalty)
					.AddField("eye_protection", ConVar.AntiHack.eye_protection)
					.AddField("eye_serverframes", ConVar.AntiHack.eye_serverframes)
					.AddField("eye_terraincheck", ConVar.AntiHack.eye_terraincheck)
					.AddField("eye_vehiclecheck", ConVar.AntiHack.eye_vehiclecheck);
				break;
			case AntiHackType.AttackHack:
				eventRecord.AddField("maxdesync", ConVar.AntiHack.maxdesync);
				break;
			case AntiHackType.Ticks:
				eventRecord.AddField("max_distance", ConVar.AntiHack.tick_max_distance).AddField("max_distance_falling", ConVar.AntiHack.tick_max_distance_falling).AddField("max_distance_parented", ConVar.AntiHack.tick_max_distance_parented)
					.AddField("tick_buffer_noclip_threshold", ConVar.AntiHack.tick_buffer_noclip_threshold)
					.AddField("tick_buffer_reject_threshold", ConVar.AntiHack.tick_buffer_reject_threshold);
				break;
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEyehackViolation(BasePlayer player, Vector3 eyePos)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 6)
				.AddField("eye_pos", eyePos));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnNoclipViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount, Collider collider)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 1)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("collider_name", ((Object)collider).name));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFlyhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 3)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnProjectileHackViolation(BasePlayer.FiredProjectile projectile)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if (!projectile.invalid)
			{
				FiredProjectileKey key = new FiredProjectileKey(projectile.attacker.userID, projectile.id);
				if (trackedProjectiles.TryGetValue(key, out var value))
				{
					projectile.invalid = true;
					value.Record.AddField("projectile_invalid", value: true).AddObject("updates", projectile.updates);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSpeedhackViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 2)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("distance", Vector3.Distance(startPos, endPos))
				.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTickViolation(BasePlayer player, Vector3 startPos, Vector3 endPos, int tickCount)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 13)
				.AddField("start_pos", startPos)
				.AddField("end_pos", endPos)
				.AddField("tick_count", tickCount)
				.AddField("distance", Vector3.Distance(startPos, endPos))
				.AddField("distance_2d", Vector3Ex.Distance2D(startPos, endPos)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTerrainHackViolation(BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("antihack_violation_detailed").AddField("player", (BaseNetworkable)player).AddField("violation_type", 10)
				.AddField("seed", World.Seed)
				.AddField("size", World.Size)
				.AddField("map_url", World.Url)
				.AddField("map_checksum", World.Checksum));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityTakeDamage(HitInfo info, bool isDeath)
	{
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_0426: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0463: Unknown result type (might be due to invalid IL or missing references)
		//IL_047a: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0615: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			BasePlayer initiatorPlayer = info.InitiatorPlayer;
			BasePlayer basePlayer = info.HitEntity as BasePlayer;
			if (((Object)(object)info.Initiator == (Object)null && !isDeath) || (((Object)(object)initiatorPlayer == (Object)null || initiatorPlayer.IsNpc || initiatorPlayer.IsBot) && ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc || basePlayer.IsBot)))
			{
				return;
			}
			EventRecord eventRecord = null;
			float value = -1f;
			float value2 = -1f;
			if ((Object)(object)initiatorPlayer != (Object)null)
			{
				if (info.IsProjectile())
				{
					FiredProjectileKey key = new FiredProjectileKey(initiatorPlayer.userID, info.ProjectileID);
					if (trackedProjectiles.TryGetValue(key, out var value3))
					{
						eventRecord = value3.Record;
						value = Vector3.Distance(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
						value = Vector3Ex.Distance2D(info.HitPositionWorld, value3.FiredProjectile.initialPosition);
						value3.Hit = info.DidHit;
						if (eventRecord != null && value3.FiredProjectile.updates.Count > 0)
						{
							eventRecord.AddObject("projectile_updates", value3.FiredProjectile.updates);
						}
						if (eventRecord != null && value3.FiredProjectile.simulatedPositions.Count > 0)
						{
							eventRecord.AddObject("simulated_position", value3.FiredProjectile.simulatedPositions);
						}
						if (eventRecord != null)
						{
							eventRecord.AddField("partial_time", value3.FiredProjectile.partialTime);
							eventRecord.AddField("desync_lifetime", value3.FiredProjectile.desyncLifeTime);
							eventRecord.AddField("startpoint_mismatch", value3.FiredProjectile.startPointMismatch);
							eventRecord.AddField("endpoint_mismatch", value3.FiredProjectile.endPointMismatch);
							eventRecord.AddField("entity_distance", value3.FiredProjectile.entityDistance);
							eventRecord.AddField("position_offset", value3.FiredProjectile.initialPositionOffset);
						}
						trackedProjectiles.Remove(key);
						Pool.Free<PendingFiredProjectile>(ref value3);
					}
				}
				else
				{
					value = Vector3.Distance(info.HitNormalWorld, initiatorPlayer.eyes.position);
					value2 = Vector3Ex.Distance2D(info.HitNormalWorld, initiatorPlayer.eyes.position);
				}
			}
			if (eventRecord == null)
			{
				eventRecord = EventRecord.New("entity_damage");
			}
			eventRecord.AddField("is_headshot", info.isHeadshot).AddField("victim", (BaseNetworkable)info.HitEntity).AddField("damage", info.damageTypes.Total())
				.AddField("damage_type", info.damageTypes.GetMajorityDamageType().ToString())
				.AddField("pos_world", info.HitPositionWorld)
				.AddField("pos_local", info.HitPositionLocal)
				.AddField("point_start", info.PointStart)
				.AddField("point_end", info.PointEnd)
				.AddField("normal_world", info.HitNormalWorld)
				.AddField("normal_local", info.HitNormalLocal)
				.AddField("distance_cl", info.ProjectileDistance)
				.AddField("distance", value)
				.AddField("distance_2d", value2);
			if ((Object)(object)info.HitEntity != (Object)null && (Object)(object)info.HitEntity.model != (Object)null)
			{
				eventRecord.AddField("pos_local_model", ((Component)info.HitEntity.model).transform.InverseTransformPoint(info.HitPositionWorld));
			}
			if (!info.IsProjectile())
			{
				eventRecord.AddField("weapon", (BaseNetworkable)info.Weapon);
				eventRecord.AddField("attacker", (BaseNetworkable)info.Initiator);
			}
			if (info.HitBone != 0)
			{
				eventRecord.AddField("bone", info.HitBone).AddField("bone_name", info.boneName).AddField("hit_area", (int)info.boneArea);
			}
			if (info.ProjectileID != 0)
			{
				eventRecord.AddField("projectile_integrity", info.ProjectileIntegrity).AddField("projectile_hits", info.ProjectileHits).AddField("trajectory_mismatch", info.ProjectileTrajectoryMismatch)
					.AddField("travel_time", info.ProjectileTravelTime)
					.AddField("projectile_velocity", info.ProjectileVelocity)
					.AddField("projectile_prefab", ((Object)info.ProjectilePrefab).name);
			}
			if ((Object)(object)initiatorPlayer != (Object)null && !info.IsProjectile())
			{
				eventRecord.AddField("attacker_eye_pos", initiatorPlayer.eyes.position);
				eventRecord.AddField("attacker_eye_dir", initiatorPlayer.eyes.BodyForward());
				if (((object)initiatorPlayer).GetType() == typeof(BasePlayer))
				{
					eventRecord.AddField("attacker_life", initiatorPlayer.respawnId);
				}
			}
			else if ((Object)(object)initiatorPlayer != (Object)null)
			{
				eventRecord.AddObject("attacker_worn", initiatorPlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddObject("attacker_hotbar", initiatorPlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
			}
			if ((Object)(object)basePlayer != (Object)null)
			{
				eventRecord.AddField("victim_life", basePlayer.respawnId);
				eventRecord.AddObject("victim_worn", basePlayer.inventory.containerWear.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddObject("victim_hotbar", basePlayer.inventory.containerBelt.itemList.Select((Item x) => new SimpleItemAmount(x)));
				eventRecord.AddField("victim_view_dir", basePlayer.tickViewAngles);
				eventRecord.AddField("victim_eye_pos", basePlayer.eyes.position);
				eventRecord.AddField("victim_eye_dir", basePlayer.eyes.BodyForward());
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerRespawned(BasePlayer player, BaseEntity targetEntity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_respawn").AddField("player", (BaseNetworkable)player).AddField("bag", (BaseNetworkable)targetEntity)
				.AddField("life_id", player.respawnId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExplosiveLaunched(BasePlayer player, BaseEntity explosive, BaseEntity launcher = null)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("explosive_launch").AddField("player", (BaseNetworkable)player).AddField("explosive", (BaseNetworkable)explosive)
				.AddField("explosive_velocity", explosive.GetWorldVelocity());
			Vector3 worldVelocity = explosive.GetWorldVelocity();
			EventRecord eventRecord2 = eventRecord.AddField("explosive_direction", ((Vector3)(ref worldVelocity)).normalized);
			if ((Object)(object)launcher != (Object)null)
			{
				eventRecord2.AddField("launcher", (BaseNetworkable)launcher);
			}
			SubmitPoint(eventRecord2);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnExplosion(TimedExplosive explosive)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("explosion").AddField("entity", (BaseNetworkable)explosive));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemDespawn(BaseEntity itemContainer, Item item, int dropReason, ulong userId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("item_despawn").AddField("entity", (BaseNetworkable)itemContainer).AddField("item", item)
				.AddField("drop_reason", dropReason);
			if (userId != 0L)
			{
				eventRecord.AddField("player_userid", userId);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemDropped(BasePlayer player, WorldItem entity, DroppedItem.DropReasonEnum dropReason)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_drop").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("item", entity.GetItem())
				.AddField("drop_reason", (int)dropReason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemPickup(BasePlayer player, WorldItem entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("item", entity.GetItem()));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerConnected(Connection connection)
	{
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
			SubmitPoint(EventRecord.New("player_connect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
				.AddField("username", connection.username)
				.AddField("ip", connection.ipaddress));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerDisconnected(Connection connection, string reason)
	{
		try
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(connection.userid);
			SubmitPoint(EventRecord.New("player_disconnect").AddField("player_userid", userWipeId).AddField("steam_id", connection.userid)
				.AddField("username", connection.username)
				.AddField("reason", reason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityPickedUp(BasePlayer player, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_pickup").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnChatMessage(BasePlayer player, string message, int channel)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("chat").AddField("player", (BaseNetworkable)player).AddField("message", message)
				.AddField("channel", channel));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnVendingMachineOrderChanged(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, bool added)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
			SubmitPoint(EventRecord.New("vending_changed").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
				.AddField("sell_item", itemDefinition.shortname)
				.AddField("sell_amount", sellAmount)
				.AddField("buy_item", itemDefinition2.shortname)
				.AddField("buy_amount", buyAmount)
				.AddField("is_selling_bp", sellingBp)
				.AddField("is_buying_bp", buyingBp)
				.AddField("change", added ? "added" : "removed"));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuyFromVendingMachine(BasePlayer player, VendingMachine vendingMachine, int sellItemId, int sellAmount, bool sellingBp, int buyItemId, int buyAmount, bool buyingBp, int numberOfTransactions, float discount, BaseEntity drone = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(sellItemId);
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(buyItemId);
			SubmitPoint(EventRecord.New("vending_sale").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vendingMachine)
				.AddField("sell_item", itemDefinition.shortname)
				.AddField("sell_amount", sellAmount)
				.AddField("buy_item", itemDefinition2.shortname)
				.AddField("buy_amount", buyAmount)
				.AddField("transactions", numberOfTransactions)
				.AddField("is_selling_bp", sellingBp)
				.AddField("is_buying_bp", buyingBp)
				.AddField("drone_terminal", (BaseNetworkable)drone)
				.AddField("discount", discount));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnNPCVendor(BasePlayer player, NPCTalking vendor, int scrapCost, string action)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("npc_vendor").AddField("player", (BaseNetworkable)player).AddField("vendor", (BaseNetworkable)vendor)
				.AddField("scrap_amount", scrapCost)
				.AddField("action", action));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static void LogItemsLooted(BasePlayer looter, BaseEntity entity, ItemContainer container, AttackEntity tool = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			if ((Object)(object)entity == (Object)null || container == null)
			{
				return;
			}
			foreach (Item item in container.itemList)
			{
				if (item != null)
				{
					string shortname = item.info.shortname;
					int amount = item.amount;
					ulong steamId = looter?.userID ?? ((EncryptedValue<ulong>)0uL);
					LogResource(ResourceMode.Produced, "loot", shortname, amount, entity, tool, safezone: false, null, steamId);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void LogResource(ResourceMode mode, string category, string itemName, int amount, BaseEntity sourceEntity = null, AttackEntity tool = null, bool safezone = false, BaseEntity workbench = null, ulong steamId = 0uL, string sourceEntityPrefab = null, Item sourceItem = null, string targetItem = null)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("item_event").AddField("item_mode", mode.ToString()).AddField("category", category)
				.AddField("item_name", itemName)
				.AddField("amount", amount);
			if ((Object)(object)sourceEntity != (Object)null)
			{
				eventRecord.AddField("entity", (BaseNetworkable)sourceEntity);
				string biome = GetBiome(((Component)sourceEntity).transform.position);
				if (biome != null)
				{
					eventRecord.AddField("biome", biome);
				}
				if (IsOcean(((Component)sourceEntity).transform.position))
				{
					eventRecord.AddField("ocean", value: true);
				}
				string monument = GetMonument(sourceEntity);
				if (monument != null)
				{
					eventRecord.AddField("monument", monument);
				}
			}
			if (sourceEntityPrefab != null)
			{
				eventRecord.AddField("entity_prefab", sourceEntityPrefab);
			}
			if ((Object)(object)tool != (Object)null)
			{
				eventRecord.AddField("tool", (BaseNetworkable)tool);
			}
			if (safezone)
			{
				eventRecord.AddField("safezone", value: true);
			}
			if ((Object)(object)workbench != (Object)null)
			{
				eventRecord.AddField("workbench", (BaseNetworkable)workbench);
			}
			if (sourceEntity is GrowableEntity plant)
			{
				eventRecord.AddField("genes", GetGenesAsString(plant));
			}
			if (sourceItem != null)
			{
				eventRecord.AddField("source_item", sourceItem.info.shortname);
			}
			if (targetItem != null)
			{
				eventRecord.AddField("target_item", targetItem);
			}
			if (steamId != 0L)
			{
				string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(steamId);
				eventRecord.AddField("player_userid", userWipeId);
				eventRecord.AddField("player_steamid", steamId);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSkinChanged(BasePlayer player, RepairBench repairBench, Item item, ulong workshopId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
				.AddField("item", item)
				.AddField("new_skin", workshopId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntitySkinChanged(BasePlayer player, BaseNetworkable entity, int newSkin)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_skinned").AddField("player", (BaseNetworkable)player).AddField("entity", entity)
				.AddField("new_skin", newSkin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnItemRepaired(BasePlayer player, BaseEntity repairBench, Item itemToRepair, float conditionBefore, float maxConditionBefore)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("item_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)repairBench)
				.AddField("item", itemToRepair)
				.AddField("old_condition", conditionBefore)
				.AddField("old_max_condition", maxConditionBefore)
				.AddField("max_condition", itemToRepair.maxConditionNormalized));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnEntityRepaired(BasePlayer player, BaseEntity entity, float healthBefore, float healthAfter)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("entity_repair").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("healing", healthAfter - healthBefore)
				.AddField("health_before", healthBefore)
				.AddField("health_after", healthAfter));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockUpgraded(BasePlayer player, BuildingBlock buildingBlock, BuildingGrade.Enum targetGrade, uint targetColor, ulong targetSkin)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("block_upgrade").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock)
				.AddField("old_grade", (int)buildingBlock.grade)
				.AddField("new_grade", (int)targetGrade)
				.AddField("color", targetColor)
				.AddField("biome", GetBiome(((Component)buildingBlock).transform.position))
				.AddField("skin_old", buildingBlock.skinID)
				.AddField("skin", targetSkin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockDemolished(BasePlayer player, StabilityEntity buildingBlock)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("block_demolish").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)buildingBlock));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerInitializedWipeId(ulong userId, string wipeId)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_wipe_id_set").AddField("user_id", userId).AddField("player_wipe_id", wipeId));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFreeUnderwaterCrate(BasePlayer player, FreeableLootContainer freeableLootContainer)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("crate_untied").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)freeableLootContainer));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnVehiclePurchased(BasePlayer player, BaseEntity vehicle)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("vehicle_purchase").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)vehicle)
				.AddField("price", (BaseNetworkable)vehicle));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnMissionComplete(BasePlayer player, BaseMission mission, BaseMission.MissionFailReason? failReason = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("mission_complete").AddField("player", (BaseNetworkable)player).AddField("mission", mission.shortname);
			if (failReason.HasValue)
			{
				eventRecord.AddField("mission_succeed", value: false).AddField("fail_reason", failReason.Value.ToString());
			}
			else
			{
				eventRecord.AddField("mission_succeed", value: true);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnGamblingResult(BasePlayer player, BaseEntity entity, int scrapPaid, int scrapRecieved, Guid? gambleGroupId = null)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("gambing").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity)
				.AddField("scrap_input", scrapPaid)
				.AddField("scrap_output", scrapRecieved);
			if (gambleGroupId.HasValue)
			{
				eventRecord.AddField("gamble_grouping", gambleGroupId.Value);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerPinged(BasePlayer player, BasePlayer.PingType type, bool wasViaWheel)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("pingType", (int)type)
				.AddField("viaWheel", wasViaWheel));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBagUnclaimed(BasePlayer player, SleepingBag bag)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("bag_unclaim").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)bag));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnSteamAuth(ulong userId, ulong ownerUserId, string authResponse)
	{
		try
		{
			SubmitPoint(EventRecord.New("steam_auth").AddField("user", userId).AddField("owner", ownerUserId)
				.AddField("response", authResponse)
				.AddField("server_port", Net.sv.port)
				.AddField("network_mode", Net.sv.ProtocolId)
				.AddField("player_count", BasePlayer.activePlayerList.Count)
				.AddField("max_players", ConVar.Server.maxplayers)
				.AddField("hostname", ConVar.Server.hostname)
				.AddField("secure", Net.sv.secure));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBuildingBlockColorChanged(BasePlayer player, BuildingBlock block, uint oldColor, uint newColor)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_pinged").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)block)
				.AddField("color_old", oldColor)
				.AddField("color_new", newColor)
				.AddField("biome", GetBiome(((Component)block).transform.position)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBurstModeToggled(BasePlayer player, BaseProjectile gun, bool state)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("burst_toggle").AddField("player", (BaseNetworkable)player).AddField("weapon", (BaseNetworkable)gun)
				.AddField("enabled", state));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnParachuteUsed(BasePlayer player, float distanceTravelled, float deployHeight, float timeInAir)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("parachute_used").AddField("player", (BaseNetworkable)player).AddField("distanceTravelled", distanceTravelled)
				.AddField("deployHeight", deployHeight)
				.AddField("timeInAir", timeInAir));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialStarted(BasePlayer player)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_started").AddField("player", (BaseNetworkable)player));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialCompleted(BasePlayer player, float timeElapsed)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_completed").AddField("player", (BaseNetworkable)player).AddLegacyTimespan("duration", TimeSpan.FromSeconds(timeElapsed)));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnTutorialQuit(BasePlayer player, string activeMissionName)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("tutorial_quit").AddField("player", (BaseNetworkable)player).AddField("activeMissionName", activeMissionName));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnBaseInteract(BasePlayer player, BaseEntity entity)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("base_interaction").AddField("player", (BaseNetworkable)player).AddField("entity", (BaseNetworkable)entity));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerDeath(BasePlayer player, BasePlayer killer)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("player_death").AddField("player", (BaseNetworkable)player).AddField("killer", (BaseNetworkable)killer));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCarShredded(MagnetLiftable car, List<Item> produced)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			EventRecord eventRecord = EventRecord.New("car_shredded").AddField("player", (BaseNetworkable)car.associatedPlayer).AddField("car", (BaseNetworkable)car.GetBaseEntity());
			foreach (Item item in produced)
			{
				eventRecord.AddField("item_" + item.info.shortname, item);
			}
			SubmitPoint(eventRecord);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerTick(BasePlayer player, Vector3 pos, in BasePlayer.CachedState tickState)
	{
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		if (GameplayTickAnalyticsConVar)
		{
			if (TickLogging.tickUploader.NeedsCreation())
			{
				BuildInfo current = BuildInfo.Current;
				bool num = (current.Scm.Branch != null && current.Scm.Branch == "experimental/release") || current.Scm.Branch == "release";
				bool isEditor = Application.isEditor;
				string text = ((num && !isEditor) ? "release" : (isEditor ? "editor" : "staging"));
				TickLogging.tickUploader = AzureAnalyticsUploader.Create("player_ticks_" + text, TimeSpan.FromSeconds(TickLogging.tick_uploader_lifetime), AnalyticsDocumentMode.CSV);
			}
			TickLogging.tickUploader.Append(EventRecord.New("player_tick").AddField("player_steamid", player.UserIDString).AddField("modelstate", (player.modelStateTick ?? player.modelState).flags)
				.AddField("heldentity", ((Object)(object)player.GetHeldEntity() != (Object)null) ? player.GetHeldEntity().ShortPrefabName : "")
				.AddField("pitch", player.tickViewAngles.x)
				.AddField("yaw", player.tickViewAngles.y)
				.AddField("pos_x", pos.x)
				.AddField("pos_y", pos.y)
				.AddField("pos_z", pos.z)
				.AddField("eye_pos_x", tickState.EyePos.x)
				.AddField("eye_pos_y", tickState.EyePos.y)
				.AddField("eye_pos_z", tickState.EyePos.z)
				.AddField("mouse_delta_x", player.tickMouseDelta.x)
				.AddField("mouse_delta_y", player.tickMouseDelta.y)
				.AddField("mouse_delta_z", player.tickMouseDelta.z)
				.AddField("parented", player.HasParent())
				.AddField("mounted", player.isMounted)
				.AddField("admin", player.IsAdmin || player.IsDeveloper)
				.AddField("water_factor", tickState.WaterFactor)
				.AddField("Timestamp", DateTime.UtcNow));
		}
	}

	public static void OnWallpaperPlaced(BasePlayer player, BuildingBlock buildingBlock, ulong skinID, int side, bool reskin)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("wallpaper_placed").AddField("player", (BaseNetworkable)player).AddField("buildingBlock", (BaseNetworkable)buildingBlock)
				.AddField("skin", skinID)
				.AddField("side", side)
				.AddField("reskin", reskin));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnStartFish(BasePlayer player, Item lure, Vector3 targetPos)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_start").AddField("player", (BaseNetworkable)player).AddField("lure", lure)
				.AddField("target_pos", targetPos));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnFailedFish(BasePlayer player, BaseFishingRod.FailReason reason)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_failed").AddField("player", (BaseNetworkable)player).AddField("fail_reason", (int)reason));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnCaughtFish(BasePlayer player, Item item)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("fishing_caught").AddField("player", (BaseNetworkable)player).AddField("item", item));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerChangeInjureState(BasePlayer player, BasePlayer.InjureState oldState, BasePlayer.InjureState newState)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("injure_state").AddField("player", (BaseNetworkable)player).AddField("old_state", (int)oldState)
				.AddField("new_state", (int)newState));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnPlayerLifeStoryEnd(BasePlayer player, PlayerLifeStory lifeStory)
	{
		if (!GameplayAnalytics)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("life_story_end").AddField("player", (BaseNetworkable)player).AddField("time_born", lifeStory.timeBorn)
				.AddField("time_died", lifeStory.timeDied)
				.AddField("meters_walked", lifeStory.metersWalked)
				.AddField("meters_ran", lifeStory.metersRun)
				.AddField("seconds_alive", lifeStory.secondsAlive)
				.AddField("seconds_in_base", lifeStory.secondsInBase)
				.AddField("seconds_in_wilderness", lifeStory.secondsWilderness)
				.AddField("seconds_in_monument", lifeStory.secondsInMonument)
				.AddField("seconds_driving", lifeStory.secondsDriving)
				.AddField("seconds_flying", lifeStory.secondsFlying)
				.AddField("seconds_boating", lifeStory.secondsBoating)
				.AddField("seconds_sleeping", lifeStory.secondsSleeping)
				.AddField("seconds_swimming", lifeStory.secondsSwimming)
				.AddField("total_damage_taken", lifeStory.totalDamageTaken)
				.AddField("total_healed", lifeStory.totalHealing)
				.AddField("killed_players", lifeStory.killedPlayers)
				.AddField("killed_animals", lifeStory.killedAnimals)
				.AddField("killed_scientists", lifeStory.killedScientists)
				.AddObject("death_info", lifeStory.deathInfo)
				.AddObject("weapon_stats", lifeStory.weaponStats));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	public static void OnServerRPC(BasePlayer player, uint nameID, byte[] data, int length)
	{
		if (!GameplayAnalytics || !GameplayRpcAnalyticsConVar)
		{
			return;
		}
		try
		{
			SubmitPoint(EventRecord.New("server_rpc").AddField("player", (BaseNetworkable)player).AddField("rpc", StringPool.Get(nameID))
				.AddField("data", data)
				.AddField("length", length));
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private static string GetGenesAsString(GrowableEntity plant)
	{
		int key = GrowableGeneEncoding.EncodeGenesToInt(plant.Genes);
		if (!geneCache.TryGetValue(key, out var value))
		{
			return string.Join("", from x in plant.Genes.Genes
				group x by x.GetDisplayCharacter() into x
				orderby x.Key
				select x.Count() + x.Key);
		}
		return value;
	}

	private static string GetMonument(BaseEntity entity)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null)
		{
			return null;
		}
		SpawnGroup spawnGroup = null;
		if (entity is BaseCorpse baseCorpse)
		{
			spawnGroup = baseCorpse.spawnGroup;
		}
		if ((Object)(object)spawnGroup == (Object)null)
		{
			SpawnPointInstance component = ((Component)entity).GetComponent<SpawnPointInstance>();
			if ((Object)(object)component != (Object)null)
			{
				spawnGroup = component.parentSpawnPointUser as SpawnGroup;
			}
		}
		if ((Object)(object)spawnGroup != (Object)null)
		{
			if (!string.IsNullOrEmpty(spawnGroup.category))
			{
				return spawnGroup.category;
			}
			if ((Object)(object)spawnGroup.Monument != (Object)null)
			{
				return ((Object)spawnGroup.Monument).name;
			}
		}
		MonumentInfo monumentInfo = TerrainMeta.Path.FindMonumentWithBoundsOverlap(((Component)entity).transform.position);
		if ((Object)(object)monumentInfo != (Object)null)
		{
			return ((Object)monumentInfo).name;
		}
		return null;
	}

	private static string GetBiome(Vector3 position)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected I4, but got Unknown
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Invalid comparison between Unknown and I4
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Invalid comparison between Unknown and I4
		string result = null;
		Enum val = (Enum)TerrainMeta.BiomeMap.GetBiomeMaxType(position);
		switch (val - 1)
		{
		default:
			if ((int)val != 8)
			{
				if ((int)val == 16)
				{
					result = "jungle";
				}
			}
			else
			{
				result = "arctic";
			}
			break;
		case 0:
			result = "arid";
			break;
		case 1:
			result = "grass";
			break;
		case 3:
			result = "tundra";
			break;
		case 2:
			break;
		}
		return result;
	}

	private static bool IsOcean(Vector3 position)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.TopologyMap.GetTopology(position) == 128;
	}

	private static IEnumerator AggregateLoop()
	{
		int loop = 0;
		while (!Application.isQuitting)
		{
			yield return CoroutineEx.waitForSecondsRealtime(60f);
			if (GameplayAnalytics)
			{
				yield return TryCatch(AggregatePlayers(blueprints: false, positions: true));
				if (loop % 60 == 0)
				{
					PushServerInfo();
					yield return TryCatch(AggregateEntitiesAndItems());
					yield return TryCatch(AggregatePlayers(blueprints: true));
					yield return TryCatch(AggregateTeams());
					Dictionary<PendingItemsKey, PendingItemsData> dict = pendingItems;
					pendingItems = new Dictionary<PendingItemsKey, PendingItemsData>();
					yield return PushPendingItemsLoopAsync(dict);
				}
				loop++;
			}
		}
	}

	private static IEnumerator TryCatch(IEnumerator coroutine)
	{
		while (true)
		{
			try
			{
				if (!coroutine.MoveNext())
				{
					break;
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				break;
			}
			yield return coroutine.Current;
		}
	}

	private static IEnumerator AggregateEntitiesAndItems()
	{
		List<BaseNetworkable> entityQueue = new List<BaseNetworkable>();
		entityQueue.Clear();
		int totalCount = BaseNetworkable.serverEntities.Count;
		entityQueue.AddRange(BaseNetworkable.serverEntities);
		Dictionary<string, int> itemDict = new Dictionary<string, int>();
		Dictionary<EntityKey, int> entityDict = new Dictionary<EntityKey, int>();
		yield return null;
		Debug.Log((object)"Starting to aggregate entities & items...");
		DateTime startTime = DateTime.UtcNow;
		Stopwatch watch = Stopwatch.StartNew();
		foreach (BaseNetworkable entity in entityQueue)
		{
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
			if ((Object)(object)entity == (Object)null || entity.IsDestroyed)
			{
				continue;
			}
			EntityKey entityKey = default(EntityKey);
			entityKey.PrefabId = entity.prefabID;
			EntityKey key = entityKey;
			if (entity is BuildingBlock buildingBlock)
			{
				key.Grade = (int)(buildingBlock.grade + 1);
			}
			entityDict.TryGetValue(key, out var value);
			entityDict[key] = value + 1;
			if (!(entity is LootContainer) && !(entity is BasePlayer { IsNpc: not false }) && !(entity is NPCPlayer))
			{
				if (entity is BasePlayer basePlayer2)
				{
					AddItemsToDict(basePlayer2.inventory.containerMain, itemDict);
					AddItemsToDict(basePlayer2.inventory.containerBelt, itemDict);
					AddItemsToDict(basePlayer2.inventory.containerWear, itemDict);
				}
				else if (entity is IItemContainerEntity itemContainerEntity)
				{
					AddItemsToDict(itemContainerEntity.inventory, itemDict);
				}
				else if (entity is DroppedItemContainer { inventory: not null } droppedItemContainer)
				{
					AddItemsToDict(droppedItemContainer.inventory, itemDict);
				}
			}
		}
		Debug.Log((object)$"Took {Math.Round(DateTime.UtcNow.Subtract(startTime).TotalSeconds, 1)}s to aggregate {totalCount} entities & items...");
		_ = DateTime.UtcNow;
		SubmitPoint(EventRecord.New("entity_sum").AddObject("counts", entityDict.Select(delegate(KeyValuePair<EntityKey, int> x)
		{
			EntitySumItem result = default(EntitySumItem);
			result.PrefabId = x.Key.PrefabId;
			result.Grade = x.Key.Grade;
			result.Count = x.Value;
			return result;
		})));
		yield return null;
		SubmitPoint(EventRecord.New("item_sum").AddObject("counts", itemDict));
		yield return null;
	}

	private static void AddItemsToDict(ItemContainer container, Dictionary<string, int> dict)
	{
		if (container == null || container.itemList == null)
		{
			return;
		}
		foreach (Item item in container.itemList)
		{
			string shortname = item.info.shortname;
			dict.TryGetValue(shortname, out var value);
			dict[shortname] = value + item.amount;
			if (item.contents != null)
			{
				AddItemsToDict(item.contents, dict);
			}
		}
	}

	private static IEnumerator PushPendingItemsLoopAsync(Dictionary<PendingItemsKey, PendingItemsData> dict)
	{
		Stopwatch watch = Stopwatch.StartNew();
		foreach (PendingItemsData value in dict.Values)
		{
			try
			{
				LogResource(value.Key.Consumed ? ResourceMode.Consumed : ResourceMode.Produced, value.category, value.Key.Item, value.amount, null, null, safezone: false, null, 0uL, value.Key.Entity);
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
			PendingItemsData pendingItemsData = value;
			Pool.Free<PendingItemsData>(ref pendingItemsData);
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		dict.Clear();
	}

	public static void AddPendingItems(BaseEntity entity, string itemName, int amount, string category, bool consumed = true, bool perEntity = false)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		PendingItemsKey pendingItemsKey = default(PendingItemsKey);
		pendingItemsKey.Entity = entity.ShortPrefabName;
		pendingItemsKey.Category = category;
		pendingItemsKey.Item = itemName;
		pendingItemsKey.Consumed = consumed;
		pendingItemsKey.EntityId = (NetworkableId)(perEntity ? entity.net.ID : default(NetworkableId));
		PendingItemsKey key = pendingItemsKey;
		if (!pendingItems.TryGetValue(key, out var value))
		{
			value = Pool.Get<PendingItemsData>();
			value.Key = key;
			value.category = category;
			pendingItems[key] = value;
		}
		value.amount += amount;
	}

	private static IEnumerator AggregatePlayers(bool blueprints = false, bool positions = false)
	{
		Stopwatch watch = Stopwatch.StartNew();
		Dictionary<int, int> playerBps = (blueprints ? new Dictionary<int, int>() : null);
		List<PlayerAggregate> playerPositions = (positions ? Pool.Get<List<PlayerAggregate>>() : null);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((Object)(object)current == (Object)null || current.IsDestroyed)
				{
					continue;
				}
				if (blueprints)
				{
					foreach (int unlockedItem in current.PersistantPlayerInfo.unlockedItems)
					{
						playerBps.TryGetValue(unlockedItem, out var value);
						playerBps[unlockedItem] = value + 1;
					}
				}
				if (positions)
				{
					PlayerAggregate playerAggregate = Pool.Get<PlayerAggregate>();
					playerAggregate.UserId = current.UserIDString;
					playerAggregate.Position = ((Component)current).transform.position;
					Quaternion bodyRotation = current.eyes.bodyRotation;
					playerAggregate.Direction = ((Quaternion)(ref bodyRotation)).eulerAngles;
					foreach (Item item in current.inventory.containerBelt.itemList)
					{
						playerAggregate.Hotbar.Add(item.info.shortname);
					}
					foreach (Item item2 in current.inventory.containerWear.itemList)
					{
						playerAggregate.Worn.Add(item2.info.shortname);
					}
					playerAggregate.ActiveItem = current.GetActiveItem()?.info.shortname;
					playerAggregate.Biome = GetBiome(((Component)current).transform.position);
					playerPositions.Add(playerAggregate);
				}
				if (watch.ElapsedMilliseconds > MaxMSPerFrame)
				{
					yield return null;
					watch.Restart();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (blueprints)
		{
			SubmitPoint(EventRecord.New("blueprint_aggregate_online").AddObject("blueprints", playerBps.Select((KeyValuePair<int, int> x) => new
			{
				Key = ItemManager.FindItemDefinition(x.Key).shortname,
				value = x.Value
			})));
		}
		if (positions)
		{
			SubmitPoint(EventRecord.New("player_positions").AddObject("positions", playerPositions).AddObject("player_count", playerPositions.Count));
			Pool.Free<PlayerAggregate>(ref playerPositions, true);
		}
	}

	private static IEnumerator AggregateTeams()
	{
		yield return null;
		HashSet<ulong> teamIds = new HashSet<ulong>();
		int inTeam = 0;
		int notInTeam = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if ((Object)(object)current != (Object)null && !current.IsDestroyed && current.currentTeam != 0L)
				{
					teamIds.Add(current.currentTeam);
					inTeam++;
				}
				else
				{
					notInTeam++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		yield return null;
		Stopwatch watch = Stopwatch.StartNew();
		List<TeamInfo> teams = Pool.Get<List<TeamInfo>>();
		foreach (ulong item in teamIds)
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindTeam(item);
			if (playerTeam == null || !((playerTeam.members != null) & (playerTeam.members.Count > 0)))
			{
				continue;
			}
			TeamInfo teamInfo = Pool.Get<TeamInfo>();
			teams.Add(teamInfo);
			foreach (ulong member in playerTeam.members)
			{
				BasePlayer basePlayer = RelationshipManager.FindByID(member);
				if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsDestroyed && basePlayer.IsConnected && !basePlayer.IsSleeping())
				{
					teamInfo.online.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
				else
				{
					teamInfo.offline.Add(SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(member));
				}
			}
			teamInfo.member_count = teamInfo.online.Count + teamInfo.offline.Count;
			if (watch.ElapsedMilliseconds > MaxMSPerFrame)
			{
				yield return null;
				watch.Restart();
			}
		}
		SubmitPoint(EventRecord.New("online_teams").AddObject("teams", teams).AddField("users_in_team", inTeam)
			.AddField("users_not_in_team", notInTeam));
		foreach (TeamInfo item2 in teams)
		{
			TeamInfo current4 = item2;
			Pool.Free<TeamInfo>(ref current4);
		}
		Pool.Free<TeamInfo>(ref teams, false);
	}
}


public enum ResourceMode
{
	Produced,
	Consumed
}


private static class EventIds
{
	public const string EntityBuilt = "entity_built";

	public const string EntityPickup = "entity_pickup";

	public const string EntityDamage = "entity_damage";

	public const string PlayerRespawn = "player_respawn";

	public const string ExplosiveLaunched = "explosive_launch";

	public const string Explosion = "explosion";

	public const string ItemEvent = "item_event";

	public const string EntitySum = "entity_sum";

	public const string ItemSum = "item_sum";

	public const string ItemDespawn = "item_despawn";

	public const string ItemDropped = "item_drop";

	public const string ItemPickup = "item_pickup";

	public const string AntihackViolation = "antihack_violation";

	public const string AntihackViolationDetailed = "antihack_violation_detailed";

	public const string PlayerConnect = "player_connect";

	public const string PlayerDisconnect = "player_disconnect";

	public const string ConsumableUsed = "consumeable_used";

	public const string MedUsed = "med_used";

	public const string ResearchStarted = "research_start";

	public const string BlueprintLearned = "blueprint_learned";

	public const string TeamChanged = "team_change";

	public const string EntityAuthChange = "auth_change";

	public const string VendingOrderChanged = "vending_changed";

	public const string VendingSale = "vending_sale";

	public const string ChatMessage = "chat";

	public const string BlockUpgrade = "block_upgrade";

	public const string BlockDemolish = "block_demolish";

	public const string ItemRepair = "item_repair";

	public const string EntityRepair = "entity_repair";

	public const string ItemSkinned = "item_skinned";

	public const string EntitySkinned = "entity_skinned";

	public const string ItemAggregate = "item_aggregate";

	public const string CodelockChanged = "code_change";

	public const string CodelockEntered = "code_enter";

	public const string SleepingBagAssign = "sleeping_bag_assign";

	public const string FallDamage = "fall_damage";

	public const string PlayerWipeIdSet = "player_wipe_id_set";

	public const string ServerInfo = "server_info";

	public const string UnderwaterCrateUntied = "crate_untied";

	public const string VehiclePurchased = "vehicle_purchase";

	public const string NPCVendor = "npc_vendor";

	public const string BlueprintsOnline = "blueprint_aggregate_online";

	public const string PlayerPositions = "player_positions";

	public const string ProjectileInvalid = "projectile_invalid";

	public const string ItemDefinitions = "item_definitions";

	public const string KeycardSwiped = "keycard_swiped";

	public const string EntitySpawned = "entity_spawned";

	public const string EntityKilled = "entity_killed";

	public const string HackableCrateStarted = "hackable_crate_started";

	public const string HackableCrateEnded = "hackable_crate_ended";

	public const string StashHidden = "stash_hidden";

	public const string StashRevealed = "stash_reveal";

	public const string EntityManifest = "entity_manifest";

	public const string LootEntity = "loot_entity";

	public const string OnlineTeams = "online_teams";

	public const string Gambling = "gambing";

	public const string BuildingBlockColor = "building_block_color";

	public const string MissionComplete = "mission_complete";

	public const string PlayerPinged = "player_pinged";

	public const string BagUnclaim = "bag_unclaim";

	public const string SteamAuth = "steam_auth";

	public const string ParachuteUsed = "parachute_used";

	public const string MountEntity = "mount";

	public const string DismountEntity = "dismount";

	public const string BurstToggle = "burst_toggle";

	public const string TutorialStarted = "tutorial_started";

	public const string TutorialCompleted = "tutorial_completed";

	public const string TutorialQuit = "tutorial_quit";

	public const string BaseInteraction = "base_interaction";

	public const string PlayerDeath = "player_death";

	public const string CarShredded = "car_shredded";

	public const string PlayerTick = "player_tick";

	public const string WallpaperPlaced = "wallpaper_placed";

	public const string StartFish = "fishing_start";

	public const string FailedFish = "fishing_failed";

	public const string CaughtFish = "fishing_caught";

	public const string InjureStateChange = "injure_state";

	public const string LifeStoryEnd = "life_story_end";

	public const string ServerRPC = "server_rpc";
}


private struct SimpleItemAmount
{
	public string ItemName;

	public int Amount;

	public ulong Skin;

	public float Condition;

	public SimpleItemAmount(Item item)
	{
		ItemName = item.info.shortname;
		Amount = item.amount;
		Skin = item.skin;
		Condition = item.conditionNormalized;
	}
}


using System;

private struct FiredProjectileKey : IEquatable<FiredProjectileKey>
{
	public ulong UserId;

	public int ProjectileId;

	public FiredProjectileKey(ulong userId, int projectileId)
	{
		UserId = userId;
		ProjectileId = projectileId;
	}

	public bool Equals(FiredProjectileKey other)
	{
		if (other.UserId == UserId)
		{
			return other.ProjectileId == ProjectileId;
		}
		return false;
	}
}


private class PendingFiredProjectile : IPooled
{
	public EventRecord Record;

	public BasePlayer.FiredProjectile FiredProjectile;

	public bool Hit;

	public void EnterPool()
	{
		Hit = false;
		Record = null;
		FiredProjectile = null;
	}

	public void LeavePool()
	{
	}
}


[JsonModel]
private struct EntitySumItem
{
	public uint PrefabId;

	public int Count;

	public int Grade;
}


using System;

private struct EntityKey : IEquatable<EntityKey>
{
	public uint PrefabId;

	public int Grade;

	public bool Equals(EntityKey other)
	{
		if (PrefabId == other.PrefabId)
		{
			return Grade == other.Grade;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (17 * 23 + PrefabId.GetHashCode()) * 31 + Grade.GetHashCode();
	}
}


private class PendingItemsData : IPooled
{
	public PendingItemsKey Key;

	public int amount;

	public string category;

	public void EnterPool()
	{
		Key = default(PendingItemsKey);
		amount = 0;
		category = null;
	}

	public void LeavePool()
	{
	}
}


using System;

private struct PendingItemsKey : IEquatable<PendingItemsKey>
{
	public string Item;

	public bool Consumed;

	public string Entity;

	public string Category;

	public NetworkableId EntityId;

	public bool Equals(PendingItemsKey other)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		if (Item == other.Item && Entity == other.Entity && EntityId == other.EntityId && Consumed == other.Consumed)
		{
			return Category == other.Category;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((((17 * 23 + Item.GetHashCode()) * 31 + Consumed.GetHashCode()) * 37 + Entity.GetHashCode()) * 47 + Category.GetHashCode()) * 53 + ((object)(NetworkableId)(ref EntityId)/*cast due to .constrained prefix*/).GetHashCode();
	}
}


using System.Collections.Generic;
using UnityEngine;

[JsonModel]
private class PlayerAggregate : IPooled
{
	public string UserId;

	public Vector3 Position;

	public Vector3 Direction;

	public List<string> Hotbar = new List<string>();

	public List<string> Worn = new List<string>();

	public string ActiveItem;

	public string Biome;

	public void EnterPool()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		UserId = null;
		Position = default(Vector3);
		Direction = default(Vector3);
		Hotbar.Clear();
		Worn.Clear();
		ActiveItem = null;
		Biome = null;
	}

	public void LeavePool()
	{
	}
}


using System.Collections.Generic;

[JsonModel]
private class TeamInfo : IPooled
{
	public List<string> online = new List<string>();

	public List<string> offline = new List<string>();

	public int member_count;

	public void EnterPool()
	{
		online.Clear();
		offline.Clear();
		member_count = 0;
	}

	public void LeavePool()
	{
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;
using Cysharp.Text;
using Network;
using Rust;
using Steamworks;
using UnityEngine;

public class AzureWebInterface
{
	public static readonly AzureWebInterface client = new AzureWebInterface(isClient: true);

	public static readonly AzureWebInterface server = new AzureWebInterface(isClient: false);

	private AzureAnalyticsUploader GameplayBulkUploader;

	public bool IsClient;

	public int MaxRetries = 1;

	public int FlushSize = 1000;

	public TimeSpan FlushDelay = TimeSpan.FromSeconds(30.0);

	private DateTime nextFlush;

	private ConcurrentQueue<EventRecord> uploadQueue = new ConcurrentQueue<EventRecord>();

	private HttpClient HttpClient = new HttpClient();

	private static readonly MediaTypeHeaderValue JsonContentType = new MediaTypeHeaderValue("application/json")
	{
		CharSet = Encoding.UTF8.WebName
	};

	public int PendingCount => uploadQueue.Count;

	public AzureWebInterface(bool isClient)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		IsClient = isClient;
		Task.Run((Func<Task?>)UploadSchedulingThread);
	}

	public void EnqueueEvent(EventRecord point)
	{
		if (!IsClient && !string.IsNullOrEmpty(GetContainerUrl()))
		{
			if (GameplayBulkUploader.NeedsCreation())
			{
				GameplayBulkUploader = AzureAnalyticsUploader.Create("gameplay_events", TimeSpan.FromMinutes(5.0));
				GameplayBulkUploader.UseJsonDataObject = true;
			}
			GameplayBulkUploader.Append(point);
		}
		else
		{
			point.MarkSubmitted();
			uploadQueue.Enqueue(point);
		}
	}

	private async Task UploadSchedulingThread()
	{
		while (!Application.isQuitting)
		{
			try
			{
				DateTime utcNow = DateTime.UtcNow;
				if (uploadQueue.IsEmpty || (uploadQueue.Count < FlushSize && nextFlush > utcNow))
				{
					await Task.Delay(1000);
					continue;
				}
				nextFlush = utcNow.Add(FlushDelay);
				List<EventRecord> list = Pool.Get<List<EventRecord>>();
				EventRecord result;
				while (uploadQueue.TryDequeue(out result))
				{
					list.Add(result);
				}
				Task.Run(async delegate
				{
					await UploadAsync(list);
				});
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				await Task.Delay(1000);
			}
		}
	}

	private void SerializeEvents(List<EventRecord> records, MemoryStream stream)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Utf8ValueStringBuilder writer = ZString.CreateUtf8StringBuilder();
		try
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("[");
			foreach (EventRecord record in records)
			{
				if (num > 0)
				{
					((Utf8ValueStringBuilder)(ref writer)).Append(',');
				}
				record.SerializeAsJson(ref writer);
				num++;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("]");
			((Utf8ValueStringBuilder)(ref writer)).WriteTo((Stream)stream);
		}
		finally
		{
			((Utf8ValueStringBuilder)(ref writer)).Dispose();
		}
	}

	private async Task UploadAsync(List<EventRecord> records, bool useStoredAuthTicket = false)
	{
		if (!(IsClient ? (Application.Manifest?.Features?.ClientAnalytics == true) : (Application.Manifest?.Features?.ServerAnalytics == true)))
		{
			Pool.Free<EventRecord>(ref records, true);
			return;
		}
		if (records.Count == 0)
		{
			Pool.Free<EventRecord>(ref records, false);
			return;
		}
		MemoryStream stream = Pool.Get<MemoryStream>();
		stream.Position = 0L;
		stream.SetLength(0L);
		try
		{
			SerializeEvents(records, stream);
			AuthTicket ticket = null;
			for (int attempt = 0; attempt < MaxRetries; attempt++)
			{
				try
				{
					ByteArrayContent content = new ByteArrayContent(stream.GetBuffer(), 0, (int)stream.Length);
					try
					{
						((HttpContent)content).Headers.ContentType = JsonContentType;
						if (!string.IsNullOrEmpty(AnalyticsSecret))
						{
							((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsSecret);
						}
						else
						{
							((HttpHeaders)((HttpContent)content).Headers).Add(AnalyticsHeader, AnalyticsPublicKey);
						}
						if (!IsClient)
						{
							((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-IP", Net.sv.ip);
							((HttpHeaders)((HttpContent)content).Headers).Add("X-SERVER-PORT", Net.sv.port.ToString());
						}
						(await HttpClient.PostAsync(IsClient ? ClientAnalyticsUrl : ServerAnalyticsUrl, (HttpContent)(object)content)).EnsureSuccessStatusCode();
					}
					finally
					{
						((IDisposable)content)?.Dispose();
					}
				}
				catch (Exception ex)
				{
					HttpRequestException val = (HttpRequestException)(object)((ex is HttpRequestException) ? ex : null);
					if (val != null)
					{
						Debug.Log((object)("HTTP Error when uploading analytics: " + ((Exception)(object)val).Message));
					}
					else
					{
						Debug.LogException(ex);
					}
					goto IL_02ae;
				}
				break;
				IL_02ae:
				if (ticket != null)
				{
					try
					{
						ticket.Cancel();
					}
					catch (Exception ex2)
					{
						Debug.LogError((object)("Failed to cancel auth ticket in analytics: " + ex2.ToString()));
					}
				}
			}
		}
		catch (Exception ex3)
		{
			if (IsClient)
			{
				Debug.LogWarning((object)ex3.ToString());
			}
			else
			{
				Debug.LogException(ex3);
			}
		}
		finally
		{
			Pool.Free<EventRecord>(ref records, true);
			Pool.FreeUnmanaged(ref stream);
		}
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Auto)]
private struct <<UploadSchedulingThread>b__0>d : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder <>t__builder;

	public <>c__DisplayClass15_0 <>4__this;

	private TaskAwaiter <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		<>c__DisplayClass15_0 <>c__DisplayClass15_ = <>4__this;
		try
		{
			TaskAwaiter awaiter;
			if (num != 0)
			{
				awaiter = <>c__DisplayClass15_.<>4__this.UploadAsync(<>c__DisplayClass15_.list).GetAwaiter();
				if (!awaiter.IsCompleted)
				{
					num = (<>1__state = 0);
					<>u__1 = awaiter;
					<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
					return;
				}
			}
			else
			{
				awaiter = <>u__1;
				<>u__1 = default(TaskAwaiter);
				num = (<>1__state = -1);
			}
			awaiter.GetResult();
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult();
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		<>t__builder.SetStateMachine(stateMachine);
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}


using Facepunch.Rust;

public static class AzureAnalyticsUploaderEx
{
	public static bool NeedsCreation(this AzureAnalyticsUploader uploader)
	{
		return uploader?.TryFlush() ?? true;
	}
}


public enum AnalyticsDocumentMode
{
	JSON,
	CSV
}


using System;
using System.Collections.Concurrent;
using System.IO;
using System.IO.Compression;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Identity;
using Azure.Storage.Blobs;
using Azure.Storage.Blobs.Models;
using Azure.Storage.Blobs.Specialized;
using ConVar;
using Cysharp.Text;
using Facepunch;
using Facepunch.Rust;
using UnityEngine;

public class AzureAnalyticsUploader : IPooled
{
	public static bool UsePooling = false;

	public static int SmallBufferSendLimit = 16384;

	public static ClientSecretCredential Credential;

	private ConcurrentQueue<EventRecord> queue = new ConcurrentQueue<EventRecord>();

	private BlobClient _blobClient;

	private Stream Stream;

	private GZipStream ZipStream;

	private Utf8ValueStringBuilder Writer;

	private bool disposed;

	private BlobOpenWriteOptions blobWriteOptions = new BlobOpenWriteOptions
	{
		HttpHeaders = new BlobHttpHeaders
		{
			ContentEncoding = "gzip"
		}
	};

	public TimeSpan LoopDelay { get; set; }

	public DateTime Expiry { get; private set; }

	public bool StrictMode { get; set; }

	public AnalyticsDocumentMode DocumentMode { get; private set; }

	public bool UseJsonDataObject { get; set; }

	public AzureAnalyticsUploader()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_002c: Expected O, but got Unknown
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		Writer = ZString.CreateUtf8StringBuilder();
	}

	public void EnterPool()
	{
		disposed = true;
	}

	private void Initialize()
	{
		LoopDelay = TimeSpan.FromMilliseconds(250.0);
		Expiry = DateTime.MinValue;
		StrictMode = false;
		UseJsonDataObject = false;
		DocumentMode = AnalyticsDocumentMode.JSON;
		EmptyUploadQueue();
		_blobClient = null;
		Stream = null;
		ZipStream = null;
		disposed = false;
	}

	public void LeavePool()
	{
		Initialize();
	}

	public bool TryFlush()
	{
		if (Expiry >= DateTime.UtcNow)
		{
			return false;
		}
		disposed = true;
		return true;
	}

	public static AzureAnalyticsUploader Create(string table, TimeSpan timeout, AnalyticsDocumentMode mode = AnalyticsDocumentMode.JSON)
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Expected O, but got Unknown
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Expected O, but got Unknown
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Expected O, but got Unknown
		AzureAnalyticsUploader azureAnalyticsUploader;
		if (UsePooling)
		{
			azureAnalyticsUploader = Pool.Get<AzureAnalyticsUploader>();
		}
		else
		{
			azureAnalyticsUploader = new AzureAnalyticsUploader();
			azureAnalyticsUploader.Initialize();
		}
		azureAnalyticsUploader.Expiry = DateTime.UtcNow + timeout;
		azureAnalyticsUploader.DocumentMode = mode;
		if (string.IsNullOrEmpty(Analytics.GetContainerUrl()))
		{
			Debug.Log((object)"No analytics_bulk_container_url or analytics_bulk_connection_string set, disabling bulk uploader.");
			azureAnalyticsUploader.disposed = true;
			return azureAnalyticsUploader;
		}
		string text = ((mode == AnalyticsDocumentMode.JSON) ? ".json" : ".csv");
		string text2 = Path.Combine(table, Server.server_id, Guid.NewGuid().ToString("N") + text + ".gz");
		BlobContainerClient val;
		if (!string.IsNullOrEmpty(Analytics.BulkUploadConnectionString))
		{
			val = new BlobContainerClient(new Uri(Analytics.BulkUploadConnectionString), (BlobClientOptions)null);
		}
		else
		{
			if (string.IsNullOrEmpty(Analytics.AzureTenantId) || string.IsNullOrEmpty(Analytics.AzureClientId) || string.IsNullOrEmpty(Analytics.AzureClientSecret))
			{
				Debug.Log((object)"analytics_bulk_container_url set but missing Azure AD credentials, disabling bulk uploader.");
				azureAnalyticsUploader.disposed = true;
				return azureAnalyticsUploader;
			}
			if (Credential == null)
			{
				Credential = new ClientSecretCredential(Analytics.AzureTenantId, Analytics.AzureClientId, Analytics.AzureClientSecret);
			}
			val = new BlobContainerClient(new Uri(Analytics.BulkContainerUrl), (TokenCredential)(object)Credential, (BlobClientOptions)null);
		}
		azureAnalyticsUploader._blobClient = val.GetBlobClient(text2);
		Task.Run((Func<Task?>)azureAnalyticsUploader.UploadThread);
		return azureAnalyticsUploader;
	}

	public void Append(EventRecord record)
	{
		if (disposed)
		{
			if (StrictMode)
			{
				throw new Exception("Trying to append to a disposed uploader: make sure to dispose the uploader properly!");
			}
			record.MarkSubmitted();
			Pool.Free<EventRecord>(ref record);
		}
		else
		{
			queue.Enqueue(record);
		}
	}

	private async Task CreateBlobAsync()
	{
		CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
		cancellationTokenSource.CancelAfter(TimeSpan.FromSeconds(10.0));
		blobWriteOptions.HttpHeaders.ContentType = ((DocumentMode == AnalyticsDocumentMode.JSON) ? "application/json" : "text/csv");
		try
		{
			Stream = await _blobClient.OpenWriteAsync(true, blobWriteOptions, cancellationTokenSource.Token);
		}
		catch (RequestFailedException val)
		{
			RequestFailedException val2 = val;
			switch (val2.Status)
			{
			case 403:
				Debug.Log((object)("Access denied to container " + ((BlobBaseClient)_blobClient).BlobContainerName + ", disabling bulk uploader."));
				break;
			case 404:
				Debug.Log((object)("Container " + ((BlobBaseClient)_blobClient).BlobContainerName + " doesn't exist, disabling bulk uploader."));
				break;
			default:
				Debug.Log((object)$"Unknown error when opening Azure container, status code: {val2.Status}, disabling bulk uploader.");
				Debug.LogException((Exception)(object)val2);
				break;
			}
			EmptyUploadQueue();
			return;
		}
		ZipStream = new GZipStream(Stream, CompressionLevel.Fastest);
		((Utf8ValueStringBuilder)(ref Writer)).Clear();
	}

	private async Task UploadThread()
	{
		try
		{
			_ = 2;
			try
			{
				while (!disposed || !queue.IsEmpty)
				{
					EventRecord record;
					while (queue.TryDequeue(out record))
					{
						if (Stream == null)
						{
							await CreateBlobAsync();
							if (Stream == null)
							{
								record.MarkSubmitted();
								Pool.Free<EventRecord>(ref record);
								continue;
							}
						}
						((Utf8ValueStringBuilder)(ref Writer)).Clear();
						if (DocumentMode == AnalyticsDocumentMode.JSON)
						{
							record.SerializeAsJson(ref Writer, UseJsonDataObject);
						}
						else if (DocumentMode == AnalyticsDocumentMode.CSV)
						{
							record.SerializeAsCSV(ref Writer);
						}
						((Utf8ValueStringBuilder)(ref Writer)).AppendLine();
						if (((Utf8ValueStringBuilder)(ref Writer)).Length > SmallBufferSendLimit)
						{
							await ((Utf8ValueStringBuilder)(ref Writer)).WriteToAsync((Stream)ZipStream);
						}
						else
						{
							((Utf8ValueStringBuilder)(ref Writer)).WriteTo((Stream)ZipStream);
						}
						record.MarkSubmitted();
						Pool.Free<EventRecord>(ref record);
					}
					await Task.Delay(LoopDelay);
				}
			}
			catch (Exception ex)
			{
				disposed = true;
				Debug.LogException(ex);
				EmptyUploadQueue();
			}
		}
		finally
		{
			await DisposeStreamsAsync();
			if (UsePooling)
			{
				AzureAnalyticsUploader azureAnalyticsUploader = this;
				Pool.Free<AzureAnalyticsUploader>(ref azureAnalyticsUploader);
			}
		}
	}

	private void EmptyUploadQueue()
	{
		EventRecord result;
		while (queue.TryDequeue(out result))
		{
			result.MarkSubmitted();
			Pool.Free<EventRecord>(ref result);
		}
	}

	private async Task DisposeStreamsAsync()
	{
		if (ZipStream != null)
		{
			await ZipStream.DisposeAsync();
			ZipStream = null;
		}
		if (Stream != null)
		{
			await Stream.DisposeAsync();
			Stream = null;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using Cysharp.Text;
using Facepunch;
using Facepunch.Rust;
using Newtonsoft.Json;
using UnityEngine;

public class EventRecord : IPooled
{
	public static readonly long TicksToNS = 1000000000 / Stopwatch.Frequency;

	public DateTime Timestamp;

	[NonSerialized]
	public bool IsServer;

	public List<EventRecordField> Data = new List<EventRecordField>();

	public int TimesCreated;

	public int TimesSubmitted;

	public static readonly Guid SessionId = Guid.NewGuid();

	public string EventType { get; private set; }

	public void EnterPool()
	{
		Timestamp = default(DateTime);
		EventType = null;
		IsServer = false;
		foreach (EventRecordField datum in Data)
		{
			MemoryStream bytes = datum.Bytes;
			if (bytes != null)
			{
				Pool.FreeUnmanaged(ref bytes);
			}
		}
		Data.Clear();
	}

	public void LeavePool()
	{
	}

	public static EventRecord CSV()
	{
		EventRecord eventRecord = Pool.Get<EventRecord>();
		eventRecord.IsServer = true;
		eventRecord.TimesCreated++;
		return eventRecord;
	}

	public static EventRecord New(string type, bool isServer = true)
	{
		EventRecord eventRecord = Pool.Get<EventRecord>();
		eventRecord.EventType = type;
		eventRecord.AddField("type", type);
		eventRecord.AddField("guid", Guid.NewGuid());
		BuildInfo current = BuildInfo.Current;
		bool num = (current.Scm.Branch != null && current.Scm.Branch == "experimental/release") || current.Scm.Branch == "release";
		bool isEditor = Application.isEditor;
		string value = ((num && !isEditor) ? "release" : (isEditor ? "editor" : "staging"));
		eventRecord.AddField("environment", value);
		eventRecord.IsServer = isServer;
		if (isServer && SaveRestore.WipeId != null)
		{
			eventRecord.AddField("wipe_id", SaveRestore.WipeId);
		}
		eventRecord.AddField("frame_count", ServerMgr.FrameCount);
		eventRecord.Timestamp = DateTime.UtcNow;
		eventRecord.TimesCreated++;
		return eventRecord;
	}

	public EventRecord AddObject(string key, object data)
	{
		if (data == null)
		{
			return this;
		}
		Data.Add(new EventRecordField(key)
		{
			String = JsonConvert.SerializeObject(data),
			IsObject = true
		});
		return this;
	}

	public EventRecord SetTimestamp(DateTime timestamp)
	{
		Timestamp = timestamp;
		return this;
	}

	public EventRecord AddField(string key, DateTime time)
	{
		Data.Add(new EventRecordField(key)
		{
			DateTime = time
		});
		return this;
	}

	public EventRecord AddField(string key, bool value)
	{
		Data.Add(new EventRecordField(key)
		{
			String = (value ? "true" : "false")
		});
		return this;
	}

	public EventRecord AddField(string key, string value)
	{
		Data.Add(new EventRecordField(key)
		{
			String = value
		});
		return this;
	}

	public EventRecord AddField(string key, byte value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, sbyte value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, short value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, ushort value)
	{
		return AddField(key, (int)value);
	}

	public EventRecord AddField(string key, int value)
	{
		return AddField(key, (long)value);
	}

	public EventRecord AddField(string key, uint value)
	{
		return AddField(key, (long)value);
	}

	public EventRecord AddField(string key, ulong value)
	{
		return AddField(key, (long)value);
	}

	[Obsolete("Char not supported, either cast to int or string", true)]
	public EventRecord AddField(string key, char value)
	{
		throw new NotImplementedException();
	}

	public EventRecord AddField(string key, float value)
	{
		return AddField(key, (double)value);
	}

	public EventRecord AddField(string key, long value)
	{
		Data.Add(new EventRecordField(key)
		{
			Number = value
		});
		return this;
	}

	public EventRecord AddField(string key, double value)
	{
		Data.Add(new EventRecordField(key)
		{
			Float = value
		});
		return this;
	}

	public EventRecord AddField(string key, TimeSpan value)
	{
		Data.Add(new EventRecordField(key)
		{
			Number = value.Ticks * TicksToNS
		});
		return this;
	}

	public EventRecord AddLegacyTimespan(string key, TimeSpan value)
	{
		Data.Add(new EventRecordField(key)
		{
			Float = value.TotalSeconds
		});
		return this;
	}

	public EventRecord AddField(string key, Guid value)
	{
		Data.Add(new EventRecordField(key)
		{
			Guid = value
		});
		return this;
	}

	public EventRecord AddField(string key, Vector3 value)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Data.Add(new EventRecordField(key)
		{
			Vector = value
		});
		return this;
	}

	public EventRecord AddField(string key, string key2, byte[] bytes)
	{
		EventRecordField item = new EventRecordField(key, key2);
		item.Bytes = Pool.Get<MemoryStream>();
		item.Bytes.Write(bytes);
		Data.Add(item);
		return this;
	}

	public EventRecord AddField(string key, string key2, MemoryStream bytes)
	{
		EventRecordField item = new EventRecordField(key, key2);
		item.Bytes = Pool.Get<MemoryStream>();
		item.Bytes.Write(bytes.GetBuffer(), (int)bytes.Position, (int)bytes.Length);
		Data.Add(item);
		return this;
	}

	public EventRecord AddField(string key, BaseNetworkable entity)
	{
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_037e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)entity == (Object)null || entity.net == null)
		{
			return this;
		}
		if (entity is BasePlayer { IsNpc: false, IsBot: false } basePlayer)
		{
			string userWipeId = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(basePlayer.userID);
			AddField(key, "_userid", userWipeId);
			AddField(key, "_steamid", basePlayer.UserIDString);
			AddField(key, "_modelstate", (basePlayer.modelStateTick ?? basePlayer.modelState).flags);
			AddField(key, "_tickViewAngles", basePlayer.tickViewAngles);
			AddField(key, "_mouse_delta", basePlayer.tickMouseDelta);
			AddField(key, "_heldentity", ((Object)(object)basePlayer.GetHeldEntity() != (Object)null) ? basePlayer.GetHeldEntity().ShortPrefabName : "");
			AddField(key, "_mounted", Object.op_Implicit((Object)(object)basePlayer.GetMounted()));
			AddField(key, "_parented", basePlayer.HasParent());
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				AddField(key, "_admin", value: true);
			}
		}
		if (entity is BaseEntity { skinID: not 0uL } baseEntity)
		{
			AddField(key, "_skin", baseEntity.skinID);
		}
		if (entity is BaseProjectile baseProjectile)
		{
			Item item = baseProjectile.GetItem();
			if (item != null && (item.contents?.itemList?.Count).GetValueOrDefault() > 0)
			{
				List<string> list = Pool.Get<List<string>>();
				foreach (Item item2 in item.contents.itemList)
				{
					list.Add(item2.info.shortname);
				}
				AddObject(key + "_inventory", list);
				Pool.FreeUnmanaged<string>(ref list);
			}
		}
		if (entity is DroppedItem droppedItem && droppedItem.DroppedTime != default(DateTime) && droppedItem.DroppedTime >= DateTime.UnixEpoch)
		{
			string userWipeId2 = SingletonComponent<ServerMgr>.Instance.persistance.GetUserWipeId(droppedItem.DroppedBy);
			AddField("dropped_at", ((DateTimeOffset)droppedItem.DroppedTime).ToUnixTimeMilliseconds());
			AddField("dropped_by", userWipeId2);
			AddField("dropped_by_steam_id", droppedItem.DroppedBy);
		}
		if (entity is Door door)
		{
			AddField(key, "_building_id", door.buildingID);
		}
		if (entity is CodeLock codeLock && (Object)(object)codeLock.GetParentEntity() != (Object)null && codeLock.GetParentEntity() is DecayEntity entity2)
		{
			AddField("parent", (BaseNetworkable)entity2);
		}
		if (entity is BuildingBlock buildingBlock)
		{
			AddField(key, "_grade", (int)buildingBlock.grade);
			AddField(key, "_building_id", (int)buildingBlock.buildingID);
		}
		AddField(key, "_prefab", entity.ShortPrefabName);
		AddField(key, "_pos", ((Component)entity).transform.position);
		Quaternion rotation = ((Component)entity).transform.rotation;
		AddField(key, "_rot", ((Quaternion)(ref rotation)).eulerAngles);
		AddField(key, "_id", entity.net.ID.Value);
		return this;
	}

	public EventRecord AddField(string key, Item item)
	{
		if (item == null)
		{
			return this;
		}
		AddField(key, "_name", item.info.shortname);
		AddField(key, "_amount", item.amount);
		AddField(key, "_skin", item.skin);
		AddField(key, "_condition", item.conditionNormalized);
		return this;
	}

	public void MarkSubmitted()
	{
		TimesSubmitted++;
		if (TimesCreated != TimesSubmitted)
		{
			Debug.LogError((object)$"EventRecord pooling error: event has been submitted ({TimesSubmitted}) a different amount of times than it was created ({TimesCreated})");
		}
	}

	public void Submit()
	{
		if (IsServer)
		{
			Analytics.AzureWebInterface.server.EnqueueEvent(this);
		}
	}

	public void SerializeAsCSV(ref Utf8ValueStringBuilder writer)
	{
		if (Data.Count == 0)
		{
			return;
		}
		bool flag = false;
		foreach (EventRecordField datum in Data)
		{
			if (flag)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(',');
			}
			else
			{
				flag = true;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append('"');
			datum.Serialize(ref writer, AnalyticsDocumentMode.CSV);
			((Utf8ValueStringBuilder)(ref writer)).Append('"');
		}
	}

	public void SerializeAsJson(ref Utf8ValueStringBuilder writer, bool useDataObject = true)
	{
		((Utf8ValueStringBuilder)(ref writer)).Append("{\"Timestamp\":\"");
		((Utf8ValueStringBuilder)(ref writer)).Append(Timestamp, StandardFormats.DateTime_ISO);
		bool flag = false;
		if (useDataObject)
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("\",\"Data\":{");
		}
		else
		{
			((Utf8ValueStringBuilder)(ref writer)).Append("\"");
			flag = true;
		}
		foreach (EventRecordField datum in Data)
		{
			if (flag)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(',');
			}
			else
			{
				flag = true;
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("\"");
			((Utf8ValueStringBuilder)(ref writer)).Append(datum.Key1);
			if (datum.Key2 != null)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(datum.Key2);
			}
			((Utf8ValueStringBuilder)(ref writer)).Append("\":");
			if (!datum.IsObject)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append('"');
			}
			datum.Serialize(ref writer, AnalyticsDocumentMode.JSON);
			if (!datum.IsObject)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append("\"");
			}
		}
		if (useDataObject)
		{
			((Utf8ValueStringBuilder)(ref writer)).Append('}');
		}
		((Utf8ValueStringBuilder)(ref writer)).Append('}');
	}

	public EventRecord AddField(byte value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(short value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(ushort value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(int value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(uint value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(ulong value)
	{
		return AddField((long)value);
	}

	public EventRecord AddField(float value)
	{
		return AddField((double)value);
	}

	[Obsolete("Char not supported, either cast to int or string")]
	public EventRecord AddField(char value)
	{
		throw new NotImplementedException();
	}

	public EventRecord AddField(long value)
	{
		Data.Add(new EventRecordField
		{
			Number = value
		});
		return this;
	}

	public EventRecord AddField(double value)
	{
		Data.Add(new EventRecordField
		{
			Float = value
		});
		return this;
	}

	public EventRecord AddField(string value)
	{
		Data.Add(new EventRecordField
		{
			String = value
		});
		return this;
	}

	public EventRecord AddField(bool value)
	{
		Data.Add(new EventRecordField
		{
			String = (value ? "true" : "false")
		});
		return this;
	}

	public EventRecord AddField(DateTime value)
	{
		Data.Add(new EventRecordField
		{
			DateTime = value
		});
		return this;
	}

	public EventRecord AddField(TimeSpan value)
	{
		Data.Add(new EventRecordField
		{
			Number = value.Ticks * TicksToNS
		});
		return this;
	}

	public EventRecord AddField(Guid value)
	{
		Data.Add(new EventRecordField
		{
			Guid = value
		});
		return this;
	}

	public EventRecord AddField(Vector3 vector)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Data.Add(new EventRecordField
		{
			Vector = vector
		});
		return this;
	}

	public EventRecord AddField(byte[] bytes)
	{
		return AddField(null, null, bytes);
	}

	public EventRecord AddField(MemoryStream bytes)
	{
		return AddField(null, null, bytes);
	}

	public EventRecord AddField(string key1, string key2, byte value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, short value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, ushort value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, int value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, uint value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, ulong value)
	{
		return AddField(key1, key2, (long)value);
	}

	public EventRecord AddField(string key1, string key2, float value)
	{
		return AddField(key1, key2, (double)value);
	}

	[Obsolete("Char not supported, either cast to int or string")]
	public EventRecord AddField(string key1, string key2, char value)
	{
		throw new NotImplementedException();
	}

	public EventRecord AddField(string key1, string key2, long value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Number = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, double value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Float = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, string value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			String = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, bool value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			String = (value ? "true" : "false")
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, DateTime value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			DateTime = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, TimeSpan value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Number = value.Ticks * TicksToNS
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, Guid value)
	{
		Data.Add(new EventRecordField(key1, key2)
		{
			Guid = value
		});
		return this;
	}

	public EventRecord AddField(string key1, string key2, Vector3 vector)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Data.Add(new EventRecordField(key1, key2)
		{
			Vector = vector
		});
		return this;
	}

	public EventRecord AddField(string key, byte[] bytes)
	{
		return AddField(key, null, bytes);
	}

	public EventRecord AddField(string key, MemoryStream bytes)
	{
		return AddField(key, null, bytes);
	}
}


using System;
using System.Buffers;
using System.IO;
using Cysharp.Text;
using Facepunch.Rust;
using UnityEngine;

public struct EventRecordField
{
	public string Key1;

	public string Key2;

	public string String;

	public long? Number;

	public double? Float;

	public Vector3? Vector;

	public Guid? Guid;

	public DateTime DateTime;

	public bool IsObject;

	public MemoryStream Bytes;

	public EventRecordField(string key1)
	{
		Key1 = key1;
		Key2 = null;
		String = null;
		Number = null;
		Float = null;
		Vector = null;
		Guid = null;
		IsObject = false;
		DateTime = default(DateTime);
		Bytes = null;
	}

	public EventRecordField(string key1, string key2)
	{
		Key1 = key1;
		Key2 = key2;
		String = null;
		Number = null;
		Float = null;
		Vector = null;
		Guid = null;
		IsObject = false;
		DateTime = default(DateTime);
		Bytes = null;
	}

	public void Serialize(ref Utf8ValueStringBuilder writer, AnalyticsDocumentMode format)
	{
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		if (String != null)
		{
			if (IsObject)
			{
				((Utf8ValueStringBuilder)(ref writer)).Append(String);
				return;
			}
			string @string = String;
			int length = String.Length;
			for (int i = 0; i < length; i++)
			{
				char c = @string[i];
				if (c == '\\' && format == AnalyticsDocumentMode.JSON)
				{
					((Utf8ValueStringBuilder)(ref writer)).Append("\\\\");
					continue;
				}
				switch (c)
				{
				case '"':
					if (format == AnalyticsDocumentMode.JSON)
					{
						((Utf8ValueStringBuilder)(ref writer)).Append("\\\"");
					}
					else
					{
						((Utf8ValueStringBuilder)(ref writer)).Append("\"\"");
					}
					break;
				case '\n':
					((Utf8ValueStringBuilder)(ref writer)).Append("\\n");
					break;
				case '\r':
					((Utf8ValueStringBuilder)(ref writer)).Append("\\r");
					break;
				case '\t':
					((Utf8ValueStringBuilder)(ref writer)).Append("\\t");
					break;
				default:
					((Utf8ValueStringBuilder)(ref writer)).Append(c);
					break;
				}
			}
		}
		else if (Float.HasValue)
		{
			Span<char> destination = stackalloc char[128];
			Float.Value.TryFormat(destination, out var charsWritten);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination.Slice(0, charsWritten));
		}
		else if (Number.HasValue)
		{
			((Utf8ValueStringBuilder)(ref writer)).Append(Number.Value);
		}
		else if (Guid.HasValue)
		{
			StandardFormat standardFormat = new StandardFormat('N');
			((Utf8ValueStringBuilder)(ref writer)).Append(Guid.Value, standardFormat);
		}
		else if (Vector.HasValue)
		{
			Span<char> destination2 = stackalloc char[128];
			((Utf8ValueStringBuilder)(ref writer)).Append('(');
			Vector3 value = Vector.Value;
			value.x.TryFormat(destination2, out var charsWritten2);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination2.Slice(0, charsWritten2));
			((Utf8ValueStringBuilder)(ref writer)).Append(',');
			value.y.TryFormat(destination2, out charsWritten2);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination2.Slice(0, charsWritten2));
			((Utf8ValueStringBuilder)(ref writer)).Append(',');
			value.z.TryFormat(destination2, out charsWritten2);
			((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)destination2.Slice(0, charsWritten2));
			((Utf8ValueStringBuilder)(ref writer)).Append(')');
		}
		else if (DateTime != default(DateTime))
		{
			((Utf8ValueStringBuilder)(ref writer)).Append(DateTime, StandardFormats.DateTime_ISO);
		}
		else if (Bytes != null)
		{
			Span<char> chars = stackalloc char[128];
			int num = 64;
			byte[] buffer = Bytes.GetBuffer();
			for (int j = 0; j < Bytes.Length; j += num)
			{
				int length2 = Mathf.Min(num, (int)Bytes.Length - j);
				Convert.TryToBase64Chars(new Span<byte>(buffer, j, length2), chars, out var charsWritten3);
				Span<char> span = chars.Slice(0, charsWritten3);
				((Utf8ValueStringBuilder)(ref writer)).Append((ReadOnlySpan<char>)span);
			}
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using ConVar;
using Epic.OnlineServices.Version;
using Facepunch;
using Facepunch.Ping;
using Facepunch.Rust;
using Network;
using UnityEngine;

public class PerformanceLogging
{
	private struct LagSpike
	{
		public int FrameIndex;

		public TimeSpan Time;

		public bool WasGC;
	}

	private struct GarbageCollect
	{
		public int FrameIndex;

		public TimeSpan Time;
	}

	private class PerformancePool
	{
		public List<TimeSpan> Frametimes;

		public List<int> Ping;
	}

	[JsonModel]
	private struct PluginInfo
	{
		public string Name;

		public string Author;

		public string Version;
	}

	[JsonModel]
	private struct ProcessInfo
	{
		public string Name;

		public long WorkingSet;
	}

	public static PerformanceLogging server = new PerformanceLogging(client: false);

	public static PerformanceLogging client = new PerformanceLogging(client: true);

	private readonly TimeSpan ClientInterval = TimeSpan.FromMinutes(10.0);

	private readonly TimeSpan ServerInterval = TimeSpan.FromMinutes(1.0);

	private readonly TimeSpan PublicServerInterval = TimeSpan.FromHours(1.0);

	private readonly TimeSpan PingInterval = TimeSpan.FromSeconds(5.0);

	private List<TimeSpan> Frametimes = new List<TimeSpan>();

	private List<int> PingHistory = new List<int>();

	private List<LagSpike> lagSpikes = new List<LagSpike>();

	private List<GarbageCollect> garbageCollections = new List<GarbageCollect>();

	private Dictionary<string, int> pendingTimings = new Dictionary<string, int>();

	private bool isClient;

	private Stopwatch frameWatch = new Stopwatch();

	private DateTime nextPingTime;

	private DateTime nextFlushTime;

	private DateTime connectedTime;

	private int serverIndex;

	private Guid totalSessionId = Guid.NewGuid();

	private Guid sessionId;

	private int lastFrameGC;

	private Type oxideType;

	private bool hasOxideType;

	public PerformanceLogging(bool client)
	{
		isClient = client;
	}

	private TimeSpan GetLagSpikeThreshold()
	{
		if (!isClient)
		{
			return TimeSpan.FromMilliseconds(200.0);
		}
		return TimeSpan.FromMilliseconds(100.0);
	}

	public void OnFrame()
	{
		if (!isClient && !Analytics.ServerPerformanceConVar)
		{
			ResetMeasurements();
			return;
		}
		TimeSpan elapsed = frameWatch.Elapsed;
		Frametimes.Add(elapsed);
		frameWatch.Restart();
		DateTime utcNow = DateTime.UtcNow;
		int num = System.GC.CollectionCount(0);
		bool flag = lastFrameGC != num;
		lastFrameGC = num;
		if (flag)
		{
			garbageCollections.Add(new GarbageCollect
			{
				FrameIndex = Frametimes.Count - 1,
				Time = elapsed
			});
		}
		if (elapsed > GetLagSpikeThreshold())
		{
			lagSpikes.Add(new LagSpike
			{
				FrameIndex = Frametimes.Count - 1,
				Time = elapsed,
				WasGC = flag
			});
		}
		if (utcNow > nextFlushTime)
		{
			try
			{
				FlushMainThread();
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Failed to flush analytics: " + ex));
			}
		}
	}

	private Dictionary<string, string> FindModifiedConvars()
	{
		Dictionary<string, string> dictionary = new Dictionary<string, string>();
		Command[] all = Index.All;
		foreach (Command val in all)
		{
			if (val.DefaultValue != null && val.GetOveride != null)
			{
				string text = val.GetOveride();
				if (text != val.DefaultValue)
				{
					dictionary[val.FullName] = text;
				}
			}
		}
		return dictionary;
	}

	public void FlushMainThread()
	{
		nextFlushTime = DateTime.UtcNow.Add(GetFlushInterval());
		if (!isClient && (BasePlayer.activePlayerList.Count == 0 || !Analytics.ServerPerformanceConVar))
		{
			ResetMeasurements();
			return;
		}
		Stopwatch stopwatch = Stopwatch.StartNew();
		EventRecord record = EventRecord.New(isClient ? "client_performance" : "server_performance", !isClient);
		record.AddObject("modified_convars", FindModifiedConvars());
		record.AddField("command_line", CommandLine.FullSafe);
		record.AddField("lag_spike_count", lagSpikes.Count).AddLegacyTimespan("lag_spike_threshold", GetLagSpikeThreshold()).AddField("gc_count", garbageCollections.Count)
			.AddField("ram_managed", System.GC.GetTotalMemory(forceFullCollection: false))
			.AddField("ram_total", SystemInfoEx.systemMemoryUsed)
			.AddField("total_session_id", totalSessionId.ToString("N"))
			.AddField("uptime", (int)Time.realtimeSinceStartup)
			.AddField("map_url", World.Url)
			.AddField("world_size", World.Size)
			.AddField("world_seed", World.Seed)
			.AddField("world_ts", World.Timestamp)
			.AddField("active_scene", LevelManager.CurrentLevelName);
		if (pendingTimings.Count > 0)
		{
			record.AddObject("load_times", pendingTimings);
			pendingTimings.Clear();
		}
		IPingEstimateResults estimateToAllRegions = PingEstimater.GetEstimateToAllRegions();
		if (estimateToAllRegions != null)
		{
			record.AddObject("ping_regions", estimateToAllRegions.GetAllRegions());
		}
		if (!isClient && !isClient)
		{
			int value = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)3) : 0);
			int value2 = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)1) : 0);
			record.AddField("is_official", Server.official && Server.stats).AddField("bot_count", BasePlayer.bots.Count).AddField("player_count", BasePlayer.activePlayerList.Count)
				.AddField("max_players", Server.maxplayers)
				.AddField("ent_count", BaseNetworkable.serverEntities.Count)
				.AddField("hostname", Server.hostname)
				.AddField("net_in", value)
				.AddField("net_out", value2);
		}
		if (!isClient)
		{
			try
			{
				if (!hasOxideType)
				{
					oxideType = Type.GetType("Oxide.Core.Interface,Oxide.Core");
					hasOxideType = true;
				}
				if (oxideType != null)
				{
					record.AddField("is_oxide", value: true);
					object obj = oxideType.GetProperty("Oxide", BindingFlags.Static | BindingFlags.Public)?.GetValue(null);
					if (obj != null)
					{
						object obj2 = obj.GetType().GetProperty("RootPluginManager", BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic)?.GetValue(obj);
						if (obj2 != null)
						{
							List<PluginInfo> list = new List<PluginInfo>();
							foreach (object item in obj2.GetType().GetMethod("GetPlugins")?.Invoke(obj2, null) as IEnumerable)
							{
								if (item != null)
								{
									string name = item.GetType().GetProperty("Name")?.GetValue(item) as string;
									string author = item.GetType().GetProperty("Author")?.GetValue(item) as string;
									string version = item.GetType().GetProperty("Version")?.GetValue(item)?.ToString();
									list.Add(new PluginInfo
									{
										Name = name,
										Author = author,
										Version = version
									});
								}
							}
							record.AddObject("oxide_plugins", list);
							record.AddField("oxide_plugin_count", list.Count);
						}
					}
				}
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Failed to get oxide when flushing server performance: {arg}");
			}
			try
			{
				List<ProcessInfo> list2 = new List<ProcessInfo>();
				Process[] processes = Process.GetProcesses();
				Process currentProcess = Process.GetCurrentProcess();
				Process[] array = processes;
				foreach (Process process in array)
				{
					try
					{
						if (currentProcess.Id != process.Id && process.ProcessName.Contains("RustDedicated"))
						{
							list2.Add(new ProcessInfo
							{
								Name = process.ProcessName,
								WorkingSet = process.WorkingSet64
							});
						}
					}
					catch (Exception ex)
					{
						if (!(ex is InvalidOperationException))
						{
							Debug.LogWarning((object)$"Failed to get memory from process when flushing performance info: {ex}");
							list2.Add(new ProcessInfo
							{
								Name = process.ProcessName,
								WorkingSet = -1L
							});
						}
					}
				}
				record.AddObject("other_servers", list2);
				record.AddField("other_server_count", list2.Count);
			}
			catch (Exception arg2)
			{
				Debug.LogError((object)$"Failed to log processes when flushing performance info: {arg2}");
			}
		}
		if (!isClient)
		{
			IEnumerable<HarmonyModInfo> harmonyMods = HarmonyLoader.GetHarmonyMods();
			record.AddObject("harmony_mods", harmonyMods);
			record.AddField("harmony_mod_count", harmonyMods.Count());
		}
		string value3;
		using (SHA256 sHA = SHA256.Create())
		{
			value3 = Convert.ToBase64String(sHA.ComputeHash(Encoding.UTF8.GetBytes(SystemInfo.deviceUniqueIdentifier)));
		}
		Dictionary<string, string> data = new Dictionary<string, string>
		{
			["device_name"] = SystemInfo.deviceName,
			["device_hash"] = value3,
			["gpu_name"] = SystemInfo.graphicsDeviceName,
			["gpu_ram"] = SystemInfo.graphicsMemorySize.ToString(),
			["gpu_vendor"] = SystemInfo.graphicsDeviceVendor,
			["gpu_version"] = SystemInfo.graphicsDeviceVersion,
			["gpu_shader_level"] = SystemInfo.graphicsShaderLevel.ToString(),
			["gpu_max_buffer_size"] = SystemInfo.maxGraphicsBufferSize.ToString(),
			["gpu_device_version"] = SystemInfo.graphicsDeviceVersion.ToString(),
			["cpu_cores"] = SystemInfo.processorCount.ToString(),
			["max_compute_work_size"] = SystemInfo.maxComputeWorkGroupSize.ToString(),
			["max_compute_work_size_x"] = SystemInfo.maxComputeWorkGroupSizeX.ToString(),
			["max_compute_work_size_y"] = SystemInfo.maxComputeWorkGroupSizeY.ToString(),
			["max_compute_work_size_z"] = SystemInfo.maxComputeWorkGroupSizeZ.ToString(),
			["cpu_frequency"] = SystemInfo.processorFrequency.ToString(),
			["gpu_max_texture_size"] = SystemInfo.maxTextureSize.ToString(),
			["cpu_name"] = SystemInfo.processorType.Trim(),
			["system_memory"] = SystemInfo.systemMemorySize.ToString(),
			["os"] = SystemInfo.operatingSystem,
			["supports_compute_shaders"] = SystemInfo.supportsComputeShaders.ToString(),
			["supports_async_compute"] = SystemInfo.supportsAsyncCompute.ToString(),
			["supports_async_gpu_readback"] = SystemInfo.supportsAsyncGPUReadback.ToString(),
			["supports_3d_textures"] = SystemInfo.supports3DTextures.ToString(),
			["supports_instancing"] = SystemInfo.supportsInstancing.ToString()
		};
		Dictionary<string, string> obj3 = new Dictionary<string, string> { ["unity"] = Application.unityVersion ?? "editor" };
		BuildInfo current2 = BuildInfo.Current;
		obj3["changeset"] = ((current2 != null) ? current2.Scm.ChangeId : null) ?? "editor";
		BuildInfo current3 = BuildInfo.Current;
		obj3["branch"] = ((current3 != null) ? current3.Scm.Branch : null) ?? "editor";
		obj3["network_version"] = 2597.ToString();
		Dictionary<string, string> dictionary = obj3;
		dictionary["eos_sdk"] = ((object)VersionInterface.GetVersion())?.ToString() ?? "disabled";
		record.AddObject("hardware", data).AddObject("application", dictionary);
		stopwatch.Stop();
		record.AddField("flush_ms", stopwatch.ElapsedMilliseconds);
		List<TimeSpan> frametimes = Frametimes;
		List<int> ping = PingHistory;
		Task.Run(async delegate
		{
			try
			{
				await ProcessPerformanceData(record, frametimes, ping);
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
		});
		ResetMeasurements();
	}

	private TimeSpan GetFlushInterval()
	{
		if (!isClient)
		{
			if (Analytics.Azure.GameplayAnalytics)
			{
				return ServerInterval;
			}
			return PublicServerInterval;
		}
		return TimeSpan.FromHours(1.0);
	}

	private void ResetMeasurements()
	{
		nextFlushTime = DateTime.UtcNow.Add(GetFlushInterval());
		if (Frametimes.Count != 0)
		{
			Frametimes = Pool.Get<List<TimeSpan>>();
			PingHistory = Pool.Get<List<int>>();
			lagSpikes.Clear();
			garbageCollections.Clear();
		}
	}

	private Task ProcessPerformanceData(EventRecord record, List<TimeSpan> frametimes, List<int> ping)
	{
		if (frametimes.Count <= 1)
		{
			return Task.CompletedTask;
		}
		List<TimeSpan> list = Pool.Get<List<TimeSpan>>();
		list.Clear();
		list.AddRange(frametimes);
		list.Sort();
		int count = frametimes.Count;
		Mathf.Max(1, frametimes.Count / 100);
		Mathf.Max(1, frametimes.Count / 1000);
		TimeSpan value = default(TimeSpan);
		for (int i = 0; i < count; i++)
		{
			TimeSpan timeSpan = list[i];
			value += timeSpan;
		}
		double frametime_average = value.TotalMilliseconds / (double)count;
		double value2 = Math.Sqrt(list.Sum((TimeSpan x) => Math.Pow(x.TotalMilliseconds - frametime_average, 2.0)) / (double)list.Count - 1.0);
		record.AddLegacyTimespan("total_time", value).AddField("frames", count).AddField("frametime_average", value.TotalSeconds / (double)count)
			.AddLegacyTimespan("frametime_99_9", list[Mathf.Clamp(count - count / 1000, 0, count - 1)])
			.AddLegacyTimespan("frametime_99", list[Mathf.Clamp(count - count / 100, 0, count - 1)])
			.AddLegacyTimespan("frametime_90", list[Mathf.Clamp(count - count / 10, 0, count - 1)])
			.AddLegacyTimespan("frametime_75", list[Mathf.Clamp(count - count / 4, 0, count - 1)])
			.AddLegacyTimespan("frametime_50", list[count / 2])
			.AddLegacyTimespan("frametime_25", list[count / 4])
			.AddLegacyTimespan("frametime_10", list[count / 10])
			.AddLegacyTimespan("frametime_1", list[count / 100])
			.AddLegacyTimespan("frametime_0_1", list[count / 1000])
			.AddField("frametime_std_dev", value2)
			.AddField("gc_generations", System.GC.MaxGeneration)
			.AddField("gc_total", System.GC.CollectionCount(System.GC.MaxGeneration));
		if (isClient)
		{
			record.AddField("ping_average", (ping.Count != 0) ? ((int)ping.Average()) : 0).AddField("ping_count", ping.Count);
		}
		record.Submit();
		Pool.FreeUnmanaged<TimeSpan>(ref list);
		Pool.FreeUnmanaged<TimeSpan>(ref frametimes);
		Pool.FreeUnmanaged<int>(ref ping);
		return Task.CompletedTask;
	}

	public void SetTiming(string category, TimeSpan elapsed)
	{
		pendingTimings[category] = (int)elapsed.TotalMilliseconds;
	}
}


using System;

private struct LagSpike
{
	public int FrameIndex;

	public TimeSpan Time;

	public bool WasGC;
}


using System;

private struct GarbageCollect
{
	public int FrameIndex;

	public TimeSpan Time;
}


using System;
using System.Collections.Generic;

private class PerformancePool
{
	public List<TimeSpan> Frametimes;

	public List<int> Ping;
}


[JsonModel]
private struct PluginInfo
{
	public string Name;

	public string Author;

	public string Version;
}


[JsonModel]
private struct ProcessInfo
{
	public string Name;

	public long WorkingSet;
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Auto)]
private struct <<FlushMainThread>b__0>d : IAsyncStateMachine
{
	public int <>1__state;

	public AsyncTaskMethodBuilder <>t__builder;

	public <>c__DisplayClass31_0 <>4__this;

	private TaskAwaiter <>u__1;

	private void MoveNext()
	{
		int num = <>1__state;
		<>c__DisplayClass31_0 <>c__DisplayClass31_ = <>4__this;
		try
		{
			try
			{
				TaskAwaiter awaiter;
				if (num != 0)
				{
					awaiter = <>c__DisplayClass31_.<>4__this.ProcessPerformanceData(<>c__DisplayClass31_.record, <>c__DisplayClass31_.frametimes, <>c__DisplayClass31_.ping).GetAwaiter();
					if (!awaiter.IsCompleted)
					{
						num = (<>1__state = 0);
						<>u__1 = awaiter;
						<>t__builder.AwaitUnsafeOnCompleted(ref awaiter, ref this);
						return;
					}
				}
				else
				{
					awaiter = <>u__1;
					<>u__1 = default(TaskAwaiter);
					num = (<>1__state = -1);
				}
				awaiter.GetResult();
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
			}
		}
		catch (Exception exception)
		{
			<>1__state = -2;
			<>t__builder.SetException(exception);
			return;
		}
		<>1__state = -2;
		<>t__builder.SetResult();
	}

	void IAsyncStateMachine.MoveNext()
	{
		//ILSpy generated this explicit interface implementation from .override directive in MoveNext
		this.MoveNext();
	}

	[DebuggerHidden]
	private void SetStateMachine(IAsyncStateMachine stateMachine)
	{
		<>t__builder.SetStateMachine(stateMachine);
	}

	void IAsyncStateMachine.SetStateMachine(IAsyncStateMachine stateMachine)
	{
		//ILSpy generated this explicit interface implementation from .override directive in SetStateMachine
		this.SetStateMachine(stateMachine);
	}
}


using Facepunch.Rust;

public class TickLogging
{
	public static AzureAnalyticsUploader tickUploader;

	[ServerVar]
	[Help("time (in seconds) before the tick uploader is disposed and recreated")]
	public static int tick_uploader_lifetime = 60;
}


using System.Net;
using ConVar;

public static class HttpManager
{
	public static void UpdateMaxConnections()
	{
		ServicePointManager.DefaultConnectionLimit = Server.http_connection_limit;
	}
}


using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Rust;
using UnityEngine;

public static class EntityProfiler
{
	public class EntityCounter
	{
		public string Name;

		public int count;

		public int spawned;

		public int killed;

		public bool queued;

		public EntityCounter(string name)
		{
			Name = name;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		public void Reset()
		{
			spawned = 0;
			killed = 0;
			queued = false;
		}
	}

	public static int mode = 0;

	public static TimeSpan aggregateEntityCountDelay = TimeSpan.FromSeconds(300.0);

	public static int spawned;

	public static int killed;

	public static Dictionary<uint, EntityCounter> counts = new Dictionary<uint, EntityCounter>();

	public static List<EntityCounter> list = new List<EntityCounter>();

	private static DateTime aggregateEntityCountCooldown;

	public static void OnSpawned(BaseNetworkable entity)
	{
		if (!counts.TryGetValue(entity.prefabID, out var value))
		{
			value = new EntityCounter(entity.ShortPrefabName);
			counts[entity.prefabID] = value;
		}
		if (!value.queued)
		{
			list.Add(value);
			value.queued = true;
		}
		value.spawned++;
		value.count++;
	}

	public static void OnKilled(BaseNetworkable entity)
	{
		if (!counts.TryGetValue(entity.prefabID, out var value))
		{
			value = new EntityCounter(entity.ShortPrefabName);
			counts[entity.prefabID] = value;
		}
		if (!value.queued)
		{
			list.Add(value);
			value.queued = true;
		}
		value.killed++;
		value.count--;
	}

	public static void Reset()
	{
		killed = 0;
		spawned = 0;
		foreach (EntityCounter item in list)
		{
			item.Reset();
		}
		list.Clear();
	}

	public static void TrySerializeEntityAggregates(int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader)
	{
		if (mode < 3 || Application.isLoadingSave || aggregateEntityCountCooldown > DateTime.UtcNow)
		{
			return;
		}
		aggregateEntityCountCooldown = DateTime.UtcNow + aggregateEntityCountDelay;
		foreach (EntityCounter value in counts.Values)
		{
			EventRecord eventRecord = EventRecord.CSV();
			eventRecord.AddField("", timestamp).AddField("", ConVar.Server.server_id).AddField("", frameIndex)
				.AddField("", value.Name)
				.AddField("", value.count);
			uploader.Append(eventRecord);
		}
	}

	public static void Serialize(EventRecord record, int frameIndex, DateTime timestamp, AzureAnalyticsUploader uploader)
	{
		if (mode == 0)
		{
			return;
		}
		try
		{
			record.AddField("entities_spawned", spawned);
			record.AddField("entities_killed", killed);
			if (mode < 3)
			{
				return;
			}
			foreach (EntityCounter item in list)
			{
				EventRecord eventRecord = EventRecord.CSV();
				eventRecord.AddField("", timestamp).AddField("", ConVar.Server.server_id).AddField("", frameIndex)
					.AddField("", item.Name)
					.AddField("", item.spawned)
					.AddField("", item.killed);
				uploader.Append(eventRecord);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}
}


using System.Runtime.CompilerServices;

public class EntityCounter
{
	public string Name;

	public int count;

	public int spawned;

	public int killed;

	public bool queued;

	public EntityCounter(string name)
	{
		Name = name;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void Reset()
	{
		spawned = 0;
		killed = 0;
		queued = false;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using UnityEngine;

public static class LagSpikeProfiler
{
	public static bool enabled = false;

	private static List<EventRecord> pendingEvents = new List<EventRecord>();

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		try
		{
			if (!enabled)
			{
				return;
			}
			foreach (EventRecord pendingEvent in pendingEvents)
			{
				pendingEvent.Timestamp = timestamp;
				pendingEvent.AddField("frame_index", frameIndex);
				uploader.Append(pendingEvent);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize lag spikes: " + ex.Message));
		}
	}

	public static void Reset()
	{
		pendingEvents.Clear();
	}

	private static void AddPendingRecord(EventRecord record)
	{
		pendingEvents.Add(record);
		if (pendingEvents.Count > 5000)
		{
			Pool.Free<EventRecord>(ref record);
		}
	}

	public static void RPC(TimeSpan time, Message packet, BaseEntity entity, uint rpcId)
	{
		if (enabled)
		{
			string value = StringPool.Get(rpcId);
			AddPendingRecord(CreateRecord(time, "rpc").AddField("entity", (BaseNetworkable)entity).AddField("rpc", value).AddField("connection_user", ((packet == null) ? ((ulong?)null) : packet.connection?.userid).GetValueOrDefault()));
		}
	}

	public static void ConsoleCommand(TimeSpan time, Message packet, string command)
	{
		if (enabled)
		{
			string value = StringExtensions.Truncate(command, 4096, (string)null);
			AddPendingRecord(CreateRecord(time, "console_command").AddField("command", value).AddField("command_length", command.Length).AddField("connection_user", ((packet == null) ? ((ulong?)null) : packet.connection?.userid).GetValueOrDefault()));
		}
	}

	public static void RconCommand(TimeSpan time, string command)
	{
		if (enabled)
		{
			string value = StringExtensions.Truncate(command, 4096, (string)null);
			AddPendingRecord(CreateRecord(time, "console_command").AddField("command", value).AddField("command_length", command.Length));
		}
	}

	private static EventRecord CreateRecord(TimeSpan duration, string reason)
	{
		return EventRecord.New("lag_spike").AddField("duration", duration).AddField("reason", reason)
			.AddField("server_id", Server.server_id);
	}
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Network;
using Unity.Profiling;
using Unity.Profiling.LowLevel;
using Unity.Profiling.LowLevel.Unsafe;
using UnityEngine;

[Factory("profile")]
public static class RuntimeProfiler
{
	private static class ProfilerCategories
	{
		public static readonly ProfilerCategory VSync = new ProfilerCategory("VSync");

		public static readonly ProfilerCategory PlayerLoop = new ProfilerCategory("PlayerLoop");
	}

	private static int profilingPreset = 0;

	private static int _profilingInterval = 60;

	private static bool _init = false;

	private static Stopwatch serializationTimer = new Stopwatch();

	private static AzureAnalyticsUploader frameProfilingUploader;

	private static AzureAnalyticsUploader entityProfilingUploader;

	private static AzureAnalyticsUploader entityAggregateUploader;

	private static AzureAnalyticsUploader invokeDetailsUploader;

	private static AzureAnalyticsUploader methodUploader;

	private static AzureAnalyticsUploader objectWorkQueueUploader;

	private static AzureAnalyticsUploader packetUploader;

	private static AzureAnalyticsUploader lagSpikeUploader;

	private static AzureAnalyticsUploader rconUploader;

	private static AzureAnalyticsUploader raknetUploader;

	private static AzureAnalyticsUploader poolUploader;

	public static TimeSpan ServerMgr_Update;

	public static TimeSpan Net_Cycle;

	public static TimeSpan Physics_SyncTransforms;

	public static TimeSpan Companion_Tick;

	public static TimeSpan BasePlayer_ServerCycle;

	private static DateTime nextPoolFlush;

	private static DateTime lastInvokeSerialization = DateTime.UtcNow;

	private static readonly ProfilerRecorderOptions PhysicsRecorderOptions = (ProfilerRecorderOptions)8;

	private static readonly List<RustProfilerRecorder> recorders = new List<RustProfilerRecorder>
	{
		new RustProfilerRecorder("cpu_total", ProfilerCategory.Scripts, "CPU Total Frame Time", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("main_thread", ProfilerCategory.Scripts, "CPU Main Thread Frame Time", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("gc_collect_time", ProfilerCategory.Memory, "GC.Collect", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("player_loop", ProfilerCategories.PlayerLoop, "PlayerLoop", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("wait_for_target_fps", ProfilerCategories.VSync, "WaitForTargetFPS", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("ram_app_resident", ProfilerCategory.Memory, "App Resident Memory", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("ram_total_used", ProfilerCategory.Memory, "Total Used Memory", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("ram_gc_used", ProfilerCategory.Memory, "GC Used Memory", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("gc_alloc_bytes", ProfilerCategory.Memory, "GC Allocated In Frame", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("gc_alloc_count", ProfilerCategory.Memory, "GC Allocation In Frame Count", 1, (ProfilerRecorderOptions)24),
		new RustProfilerRecorder("active_dynamic_bodies", ProfilerCategory.Physics, "ctive Dynamic Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("active_kinematic_bodies", ProfilerCategory.Physics, "Active Kinematic Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("static_colliders", ProfilerCategory.Physics, "Static Colliders", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("dynamic_bodies", ProfilerCategory.Physics, "Dynamic Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("articulation_bodies", ProfilerCategory.Physics, "Articulation Bodies", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("active_constraints", ProfilerCategory.Physics, "Active Constraints", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("overlaps", ProfilerCategory.Physics, "Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("discreet_overlaps", ProfilerCategory.Physics, "Discreet Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("continuous_overlaps", ProfilerCategory.Physics, "Continuous Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("modified_overlaps", ProfilerCategory.Physics, "Modified Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("trigger_overlaps", ProfilerCategory.Physics, "Trigger Overlaps", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("colliders_synced", ProfilerCategory.Physics, "Colliders Synced", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("rigidbodies_synced", ProfilerCategory.Physics, "Rigidbodies Synced", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("physics_queries", ProfilerCategory.Physics, "Physics Queries", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("broadphase_adds_removes", ProfilerCategory.Physics, "Broadphase Adds/Removes", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("broadphase_adds", ProfilerCategory.Physics, "Broadphase Adds", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("broadphase_removes", ProfilerCategory.Physics, "Broadphase Removes", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("narrowphase_touches", ProfilerCategory.Physics, "Narrowphase Touches", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("narrowphase_new_touches", ProfilerCategory.Physics, "Narrowphase New Touches", 1, PhysicsRecorderOptions),
		new RustProfilerRecorder("narrowphase_lost_touches", ProfilerCategory.Physics, "Narrowphase Lost Touches", 1, PhysicsRecorderOptions)
	};

	private static Stopwatch invokeExecutionResetTimer = new Stopwatch();

	[ServerVar]
	public static int rpc_lagspike_threshold
	{
		get
		{
			return (int)RpcWarningThreshold.TotalMilliseconds;
		}
		set
		{
			RpcWarningThreshold = TimeSpan.FromMilliseconds(value);
		}
	}

	[ServerVar]
	public static int command_lagspike_threshold
	{
		get
		{
			return (int)ConsoleCommandWarningThreshold.TotalMilliseconds;
		}
		set
		{
			ConsoleCommandWarningThreshold = TimeSpan.FromMilliseconds(value);
		}
	}

	[ServerVar]
	public static int rcon_lagspike_threshold
	{
		get
		{
			return (int)RconCommandWarningThreshold.TotalMilliseconds;
		}
		set
		{
			RconCommandWarningThreshold = TimeSpan.FromMilliseconds(value);
		}
	}

	public static TimeSpan RpcWarningThreshold { get; private set; } = TimeSpan.FromMilliseconds(40.0);

	public static TimeSpan ConsoleCommandWarningThreshold { get; private set; } = TimeSpan.FromMilliseconds(40.0);

	public static TimeSpan RconCommandWarningThreshold { get; private set; } = TimeSpan.FromMilliseconds(40.0);

	[ServerVar(Saved = true, Help = "0 = off, 1 = basic, 2 = everything. This will reset all profiling convars, however they can be modified afterwards")]
	public static int runtime_profiling
	{
		get
		{
			return profilingPreset;
		}
		set
		{
			profilingPreset = Mathf.Max(0, value);
			OnProfilingPresetChanged();
		}
	}

	[ServerVar(Saved = true, Help = "Enable to allow runtime profiling to persist across restarts")]
	public static bool runtime_profiling_persist { get; set; } = false;

	[ServerVar(Help = "Record inbound RPC & ConsoleCommands that cause lag spikes")]
	public static bool profiling_lagspikes
	{
		get
		{
			return LagSpikeProfiler.enabled;
		}
		set
		{
			LagSpikeProfiler.enabled = value;
		}
	}

	[ServerVar(Help = "Record type of packets inbound/outbound per frame")]
	public static bool profiling_packets
	{
		get
		{
			return PacketProfiler.enabled;
		}
		set
		{
			PacketProfiler.enabled = value;
		}
	}

	[ServerVar(Help = "0 = off, 1 = stats per frame, 2 = stats per method")]
	public static int profiling_invokes
	{
		get
		{
			return InvokeProfiler.update.mode;
		}
		set
		{
			InvokeProfiler.update.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "0 = off, 1 = stats per frame, 2 = stats per method")]
	public static int profiling_fixed_invokes
	{
		get
		{
			return InvokeProfiler.fixedUpdate.mode;
		}
		set
		{
			InvokeProfiler.fixedUpdate.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "0 = off, 1 = spawn/kill, 2 = spawn/kill per entity, 3 = count every '5 min'")]
	public static int profiling_entities
	{
		get
		{
			return EntityProfiler.mode;
		}
		set
		{
			EntityProfiler.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "How frequently to count all entities across the server")]
	public static int profiling_entity_count_interval
	{
		get
		{
			return (int)EntityProfiler.aggregateEntityCountDelay.TotalSeconds;
		}
		set
		{
			EntityProfiler.aggregateEntityCountDelay = TimeSpan.FromSeconds(Mathf.Max(60, value));
		}
	}

	[ServerVar(Help = "Record execution time of ObjectWorkQueues per frame")]
	public static bool profiling_work_queue
	{
		get
		{
			return WorkQueueProfiler.enabled;
		}
		set
		{
			WorkQueueProfiler.enabled = value;
		}
	}

	[ServerVar(Help = "0 = off, 1 = count per frame, 2 = connection attempts, 3 = messages")]
	public static int profiling_rcon
	{
		get
		{
			return RconProfiler.mode;
		}
		set
		{
			RconProfiler.mode = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "Clamp the length of logged RCON messages to prevent the profiler from being flooded with large messages")]
	public static int profiling_rcon_message_length
	{
		get
		{
			return RconProfiler.ClampedMessageLength;
		}
		set
		{
			RconProfiler.ClampedMessageLength = Mathf.Max(64, value);
		}
	}

	[ServerVar]
	public static int runtime_profiling_interval
	{
		get
		{
			return _profilingInterval;
		}
		set
		{
			_profilingInterval = Mathf.Clamp(value, 60, 1800);
		}
	}

	[ServerVar(Help = "Should analytics bulk uploaders use pooling")]
	public static bool runtime_profiling_uploader_pooling
	{
		get
		{
			return AzureAnalyticsUploader.UsePooling;
		}
		set
		{
			AzureAnalyticsUploader.UsePooling = value;
		}
	}

	[ServerVar(Help = "Raknet statistics, 0 = off, 2 = per connection")]
	public static int profiling_ping
	{
		get
		{
			return PlayerNetworkingProfiler.level;
		}
		set
		{
			PlayerNetworkingProfiler.level = Mathf.Max(0, value);
		}
	}

	[ServerVar(Help = "0 = off, 1 = flush every 5 minutes")]
	public static int runtime_profiling_pooling { get; set; }

	[ServerVar(Help = "How often to flush raknet stats per second")]
	public static float profiling_ping_interval
	{
		get
		{
			return (float)PlayerNetworkingProfiler.MinFlushInterval.TotalSeconds;
		}
		set
		{
			PlayerNetworkingProfiler.MinFlushInterval = TimeSpan.FromSeconds(value);
		}
	}

	[ServerVar]
	public static int profiling_ping_per_frame
	{
		get
		{
			return PlayerNetworkingProfiler.ConnectionsPerFrame;
		}
		set
		{
			PlayerNetworkingProfiler.ConnectionsPerFrame = Mathf.Max(1, value);
		}
	}

	[ServerVar(Help = "How often to flush pooling stats in seconds")]
	public static int runtime_profiling_pool_flush_interval { get; set; } = 300;

	[ClientVar(ClientAdmin = true)]
	[ServerVar]
	public static void dump_profile_recorders(Arg arg)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		List<ProfilerRecorderHandle> list = new List<ProfilerRecorderHandle>();
		ProfilerRecorderHandle.GetAvailable(list);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("Name,Category,UnitType,Flags");
		foreach (ProfilerRecorderHandle item in list)
		{
			ProfilerRecorderDescription description = ProfilerRecorderHandle.GetDescription(item);
			StringBuilder stringBuilder2 = stringBuilder.Append(((ProfilerRecorderDescription)(ref description)).Name).Append(",");
			ProfilerCategory category = ((ProfilerRecorderDescription)(ref description)).Category;
			StringBuilder stringBuilder3 = stringBuilder2.Append(((object)(ProfilerCategory)(ref category)/*cast due to .constrained prefix*/).ToString()).Append(",");
			ProfilerMarkerDataUnit unitType = ((ProfilerRecorderDescription)(ref description)).UnitType;
			StringBuilder stringBuilder4 = stringBuilder3.Append(((object)(ProfilerMarkerDataUnit)(ref unitType)/*cast due to .constrained prefix*/).ToString()).Append(",");
			MarkerFlags flags = ((ProfilerRecorderDescription)(ref description)).Flags;
			stringBuilder4.Append(((object)(MarkerFlags)(ref flags)/*cast due to .constrained prefix*/).ToString()).AppendLine();
		}
		string contents = stringBuilder.ToString();
		File.WriteAllText("profiler_recorders.csv", contents);
		arg.ReplyWith($"Successfully dumped '{list.Count}' markers");
	}

	public static void Disable()
	{
		runtime_profiling = 0;
	}

	private static void Start()
	{
		ResetAllMeasurements();
	}

	private static void OnProfilingPresetChanged()
	{
		profiling_lagspikes = false;
		profiling_packets = false;
		profiling_invokes = 0;
		profiling_fixed_invokes = 0;
		profiling_entities = 0;
		profiling_work_queue = false;
		profiling_rcon = 0;
		if (profilingPreset >= 1)
		{
			profiling_entities = 1;
			profiling_lagspikes = true;
			profiling_rcon = 1;
			runtime_profiling_pooling = 1;
		}
		if (profilingPreset >= 2)
		{
			profiling_packets = true;
			profiling_invokes = 2;
			profiling_fixed_invokes = 2;
			profiling_entities = 3;
			profiling_work_queue = true;
			profiling_rcon = 3;
			profiling_ping = 2;
		}
	}

	public static void Update()
	{
		if (!Bootstrap.bootstrapInitRun)
		{
			return;
		}
		if (runtime_profiling == 0)
		{
			_init = false;
		}
		else if (!string.IsNullOrEmpty(Analytics.BulkUploadConnectionString) || !string.IsNullOrEmpty(Analytics.BulkContainerUrl))
		{
			if (!_init)
			{
				Start();
				_init = true;
			}
			EnsureUploadersCreated();
			CollectLastFrameStats();
		}
	}

	private static void EnsureUploadersCreated()
	{
		if (frameProfilingUploader.NeedsCreation())
		{
			frameProfilingUploader = AzureAnalyticsUploader.Create("frame_profiling", TimeSpan.FromSeconds(runtime_profiling_interval));
		}
		if (entityProfilingUploader.NeedsCreation())
		{
			entityProfilingUploader = AzureAnalyticsUploader.Create("entity_profiling", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (entityAggregateUploader.NeedsCreation())
		{
			entityAggregateUploader = AzureAnalyticsUploader.Create("entity_aggregates", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (invokeDetailsUploader.NeedsCreation())
		{
			invokeDetailsUploader = AzureAnalyticsUploader.Create("invoke_minute_breakdown", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (methodUploader.NeedsCreation())
		{
			methodUploader = AzureAnalyticsUploader.Create("unity_methods", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (objectWorkQueueUploader.NeedsCreation())
		{
			objectWorkQueueUploader = AzureAnalyticsUploader.Create("object_work_queue", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (packetUploader.NeedsCreation())
		{
			packetUploader = AzureAnalyticsUploader.Create("packets_per_type", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (lagSpikeUploader.NeedsCreation())
		{
			lagSpikeUploader = AzureAnalyticsUploader.Create("lag_spikes", TimeSpan.FromSeconds(runtime_profiling_interval));
			lagSpikeUploader.UseJsonDataObject = true;
		}
		if (rconUploader.NeedsCreation())
		{
			rconUploader = AzureAnalyticsUploader.Create("rcon_profiling", TimeSpan.FromSeconds(runtime_profiling_interval));
		}
		if (raknetUploader.NeedsCreation())
		{
			raknetUploader = AzureAnalyticsUploader.Create("raknet", TimeSpan.FromSeconds(runtime_profiling_interval), AnalyticsDocumentMode.CSV);
		}
		if (poolUploader.NeedsCreation())
		{
			poolUploader = AzureAnalyticsUploader.Create("pool_profiling", TimeSpan.FromSeconds(runtime_profiling_interval));
			poolUploader.UseJsonDataObject = true;
		}
	}

	private static void CollectLastFrameStats()
	{
		WriteFrameData(Time.frameCount - 1);
	}

	private static void WriteFrameData(int frameIndex)
	{
		serializationTimer.Restart();
		RconProfilerStats currentStats = RconProfiler.GetCurrentStats(true);
		DateTime utcNow = DateTime.UtcNow;
		EventRecord eventRecord = EventRecord.New("frame_profiling").AddField("frame_index", frameIndex);
		eventRecord.Timestamp = utcNow;
		LagSpikeProfiler.Serialize(lagSpikeUploader, frameIndex, utcNow);
		SerializeCommon(eventRecord, currentStats);
		SerializeNetworking(eventRecord, frameIndex, utcNow);
		SerializeInvokes(eventRecord);
		if (DateTime.UtcNow >= lastInvokeSerialization + TimeSpan.FromSeconds(60.0))
		{
			SerializeInvokeExecutionTime(InvokeProfiler.update, invokeDetailsUploader, utcNow);
			SerializeInvokeExecutionTime(InvokeProfiler.fixedUpdate, invokeDetailsUploader, utcNow);
			lastInvokeSerialization = DateTime.UtcNow;
		}
		SerializeProfilingSamples(eventRecord);
		EntityProfiler.Serialize(eventRecord, frameIndex, utcNow, entityProfilingUploader);
		EntityProfiler.TrySerializeEntityAggregates(frameIndex, utcNow, entityAggregateUploader);
		WorkQueueProfiler.Serialize(objectWorkQueueUploader, frameIndex, utcNow);
		PlayerNetworkingProfiler.Serialize(raknetUploader, frameIndex, utcNow);
		SerializeRconEvents(rconUploader, frameIndex, utcNow, currentStats);
		SerializeMemoryPool(poolUploader, frameIndex, utcNow);
		ResetAllMeasurements();
		Pool.Free<RconProfilerStats>(ref currentStats);
		eventRecord.AddField("serialization_time", serializationTimer.Elapsed);
		frameProfilingUploader.Append(eventRecord);
	}

	private static void ResetAllMeasurements()
	{
		LagSpikeProfiler.Reset();
		PacketProfiler.Reset();
		InvokeProfiler update = InvokeProfiler.update;
		if (update != null)
		{
			update.Reset();
		}
		InvokeProfiler fixedUpdate = InvokeProfiler.fixedUpdate;
		if (fixedUpdate != null)
		{
			fixedUpdate.Reset();
		}
		EntityProfiler.Reset();
		WorkQueueProfiler.Reset();
		EntityProfiler.Reset();
		RconProfiler.Reset();
	}

	private static void SerializeCommon(EventRecord record, RconProfilerStats rconStats)
	{
		try
		{
			string hostname = Server.hostname;
			PerformanceSamplePoint lastFrame = PerformanceMetrics.LastFrame;
			record.AddField("server_id", Server.server_id).AddField("hostname", hostname).AddField("unity_time", Time.time)
				.AddField("unity_realtime", Time.realtimeSinceStartup)
				.AddField("garbage_collects", System.GC.CollectionCount(0))
				.AddField("ram_get_total_memory", System.GC.GetTotalMemory(forceFullCollection: false))
				.AddField("players_connected", BasePlayer.activePlayerList.Count)
				.AddField("players_sleeping", BasePlayer.sleepingPlayerList.Count)
				.AddField("connection_count", Net.sv.connections.Count)
				.AddField("entity_count", BaseNetworkable.serverEntities.Count)
				.AddField("servermgr_update", ServerMgr_Update)
				.AddField("net_cycle", Net_Cycle)
				.AddField("physics_sync_time", Physics_SyncTransforms)
				.AddField("companion_tick", Companion_Tick)
				.AddField("baseplayer_tick", BasePlayer_ServerCycle)
				.AddField("fixed_update_scripts", lastFrame.FixedUpdate)
				.AddField("update_scripts", lastFrame.Update)
				.AddField("late_update_scripts", lastFrame.LateUpdate)
				.AddField("physics_update", lastFrame.PhysicsUpdate)
				.AddField("rcon_execution_time", RconProfiler.ExecutionTime)
				.AddField("rcon_new_connections", rconStats.NewConnectionCount)
				.AddField("rcon_failed_connections", rconStats.FailedConnectionCount)
				.AddField("rcon_connection_count", rconStats.ConnectionCount)
				.AddField("rcon_message_count", rconStats.MessageCount)
				.AddField("rcon_messages_length", rconStats.MessageLengthSum)
				.AddField("rcon_errors", rconStats.ErrorCount);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize common data: " + ex.Message));
		}
	}

	private static void SerializeNetworking(EventRecord frameRecord, int frameIndex, DateTime timestamp)
	{
		if (!PacketProfiler.enabled)
		{
			return;
		}
		try
		{
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			int num5 = 0;
			for (int i = 0; i < 29; i++)
			{
				int num6 = PacketProfiler.inboundCount[i];
				int num7 = PacketProfiler.inboundBytes[i];
				int num8 = PacketProfiler.outboundCount[i];
				int num9 = PacketProfiler.outboundSum[i];
				int num10 = PacketProfiler.outboundBytes[i];
				num += num6;
				num2 += num7;
				num3 += num8;
				num4 += num9;
				num5 += num10;
				if (num6 > 0 || num8 > 0)
				{
					EventRecord eventRecord = EventRecord.CSV();
					eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", AnalyticsKeys.MessageType[i])
						.AddField("", num6)
						.AddField("", num7)
						.AddField("", num8)
						.AddField("", num9)
						.AddField("", num10)
						.AddField("", Server.server_id);
					packetUploader.Append(eventRecord);
				}
			}
			frameRecord.AddField("inbound_count_total", num);
			frameRecord.AddField("inbound_bytes_total", num2);
			frameRecord.AddField("outbound_count_total", num3);
			frameRecord.AddField("outbound_sum_total", num4);
			frameRecord.AddField("outbound_bytes_total", num5);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize networking data: " + ex.Message));
		}
	}

	private static void SerializeInvokes(EventRecord record)
	{
		try
		{
			if (InvokeProfiler.update.mode != 0)
			{
				record.AddField("invokes_elapsed_time", InvokeProfiler.update.elapsedTime).AddField("invokes_executed", InvokeProfiler.update.executedCount).AddField("invokes_count", InvokeProfiler.update.tickCount)
					.AddField("invokes_added", InvokeProfiler.update.addCount)
					.AddField("invokes_removed", InvokeProfiler.update.deletedCount);
			}
			if (InvokeProfiler.fixedUpdate.mode != 0)
			{
				record.AddField("invokes_fixed_elapsed_time", InvokeProfiler.fixedUpdate.elapsedTime).AddField("invokes_fixed_executed", InvokeProfiler.fixedUpdate.executedCount).AddField("invokes_fixed_count", InvokeProfiler.fixedUpdate.tickCount)
					.AddField("invokes_fixed_added", InvokeProfiler.fixedUpdate.addCount)
					.AddField("invokes_fixed_removed", InvokeProfiler.fixedUpdate.deletedCount);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize invoke data: " + ex.Message));
		}
	}

	private static void SerializeInvokeExecutionTime(InvokeProfiler profiler, AzureAnalyticsUploader uploader, DateTime timestamp, bool reset = true)
	{
		if (profiler.mode < 2)
		{
			return;
		}
		try
		{
			invokeExecutionResetTimer.Restart();
			foreach (InvokeTrackingData trackingData in profiler.trackingDataList)
			{
				if (trackingData.Calls != 0)
				{
					EventRecord eventRecord = EventRecord.CSV();
					eventRecord.AddField("", timestamp).AddField("", profiler.Name).AddField("", trackingData.TypeName)
						.AddField("", trackingData.Key.MethodName)
						.AddField("", trackingData.ExecutionTime)
						.AddField("", trackingData.Calls)
						.AddField("", Server.server_id);
					uploader.Append(eventRecord);
					if (reset)
					{
						trackingData.Reset();
					}
				}
			}
			invokeExecutionResetTimer.Stop();
			EventRecord eventRecord2 = EventRecord.CSV();
			eventRecord2.AddField("", timestamp).AddField("", "Update").AddField("", "RuntimeProfiler")
				.AddField("", "Invoke_Execution_Serialization")
				.AddField("", invokeExecutionResetTimer.Elapsed)
				.AddField("", 1)
				.AddField("", Server.server_id);
			uploader.Append(eventRecord2);
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize '" + profiler.Name + "' invoke execution time: " + ex.Message));
		}
	}

	private static void SerializeProfilingSamples(EventRecord record)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			foreach (RustProfilerRecorder recorder2 in recorders)
			{
				string columnName = recorder2.ColumnName;
				ProfilerRecorder recorder = recorder2.Recorder;
				record.AddField(columnName, ((ProfilerRecorder)(ref recorder)).LastValue);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize profiling samples: " + ex.Message));
		}
	}

	private static void SerializeRconEvents(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp, RconProfilerStats rconStats)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		foreach (RconConnectionAttempt connectionAttempt in rconStats.ConnectionAttempts)
		{
			EventRecord record = CreatePoint("rcon_connection_attempt", frameIndex, timestamp).AddField("ip", connectionAttempt.IP).AddField("port", connectionAttempt.Port).AddField("connection_id", connectionAttempt.ConnectionId)
				.AddField("password", connectionAttempt.PasswordAttempt)
				.AddField("success", connectionAttempt.Success);
			uploader.Append(record);
		}
		foreach (RconMessageStats message in rconStats.Messages)
		{
			EventRecord record2 = CreatePoint("rcon_message", frameIndex, timestamp).AddField("ip", message.IP).AddField("port", message.Port).AddField("connection_id", message.ConnectionId)
				.AddField("message", message.Message)
				.AddField("message_length", message.MessageLength);
			uploader.Append(record2);
		}
		foreach (RconDisconnects disconnect in rconStats.Disconnects)
		{
			EventRecord record3 = CreatePoint("rcon_disconnect", frameIndex, timestamp).AddField("ip", disconnect.IP).AddField("port", disconnect.Port).AddField("connection_id", disconnect.ConnectionId);
			uploader.Append(record3);
		}
	}

	private static void SerializeMemoryPool(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (runtime_profiling_pooling == 0 || !(timestamp > nextPoolFlush))
		{
			return;
		}
		nextPoolFlush = timestamp.AddSeconds(runtime_profiling_pool_flush_interval);
		foreach (KeyValuePair<Type, IPoolCollection> item in Pool.Directory)
		{
			IPoolCollection value = item.Value;
			string name = TypeNameCache.GetName(item.Key);
			EventRecord record = CreatePoint("pool_facepunch", frameIndex, timestamp).AddField("type_name", name).AddField("capacity", value.ItemsCapacity).AddField("stack", value.ItemsInStack)
				.AddField("used", value.ItemsInUse)
				.AddField("created", value.ItemsCreated)
				.AddField("taken", value.ItemsTaken)
				.AddField("spilled", value.ItemsSpilled)
				.AddField("max_used", value.MaxItemsInUse);
			uploader.Append(record);
		}
		ArrayPool<byte> arrayPool = BaseNetwork.ArrayPool;
		ConcurrentQueue<byte[]>[] buffer = arrayPool.GetBuffer();
		for (int i = 0; i < buffer.Length; i++)
		{
			ConcurrentQueue<byte[]> concurrentQueue = buffer[i];
			EventRecord record2 = CreatePoint("pool_networking", frameIndex, timestamp).AddField("size", arrayPool.IndexToSize(i)).AddField("amount", concurrentQueue.Count);
			uploader.Append(record2);
		}
	}

	private static EventRecord CreatePoint(string type, int frameIndex, DateTime timestamp)
	{
		return EventRecord.New(type).AddField("frame_index", frameIndex).SetTimestamp(timestamp)
			.AddField("server_id", Server.server_id);
	}
}


using Unity.Profiling;

private static class ProfilerCategories
{
	public static readonly ProfilerCategory VSync = new ProfilerCategory("VSync");

	public static readonly ProfilerCategory PlayerLoop = new ProfilerCategory("PlayerLoop");
}


using Unity.Profiling;

public struct RustProfilerRecorder
{
	public string ColumnName;

	public ProfilerRecorder Recorder;

	public RustProfilerRecorder(string column, ProfilerCategory category, string sample, int sampleCount = 1, ProfilerRecorderOptions options = 24)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		ColumnName = column;
		Recorder = ProfilerRecorder.StartNew(category, sample, sampleCount, options);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Unity.Profiling;
using Unity.Profiling.LowLevel.Unsafe;
using UnityEngine;

public static class UnityProfiler
{
	private struct RecorderInfo
	{
		public string MethodName;

		public ProfilerRecorder Recorder;
	}

	private static List<RecorderInfo> ActiveRecorders = new List<RecorderInfo>();

	private static bool _enabled;

	public static bool enabled
	{
		get
		{
			return _enabled;
		}
		set
		{
			SetEnabled(value);
		}
	}

	private static void SetEnabled(bool state)
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Invalid comparison between Unknown and I4
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		_enabled = state;
		Unload();
		if (!state)
		{
			return;
		}
		List<ProfilerRecorderHandle> list = new List<ProfilerRecorderHandle>();
		ProfilerRecorderHandle.GetAvailable(list);
		foreach (ProfilerRecorderDescription item2 in list.Select((ProfilerRecorderHandle x) => ProfilerRecorderHandle.GetDescription(x)).ToList())
		{
			ProfilerRecorderDescription current = item2;
			if ((int)((ProfilerRecorderDescription)(ref current)).UnitType == 1 && ProfilerCategory.op_Implicit(((ProfilerRecorderDescription)(ref current)).Category) == ProfilerCategory.op_Implicit(ProfilerCategory.Scripts))
			{
				ProfilerRecorder recorder = ProfilerRecorder.StartNew(((ProfilerRecorderDescription)(ref current)).Category, ((ProfilerRecorderDescription)(ref current)).Name, 2, (ProfilerRecorderOptions)24);
				RecorderInfo recorderInfo = default(RecorderInfo);
				recorderInfo.MethodName = ((ProfilerRecorderDescription)(ref current)).Name;
				recorderInfo.Recorder = recorder;
				RecorderInfo item = recorderInfo;
				ActiveRecorders.Add(item);
			}
		}
	}

	public static void Unload()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		foreach (RecorderInfo activeRecorder in ActiveRecorders)
		{
			ProfilerRecorder recorder = activeRecorder.Recorder;
			((ProfilerRecorder)(ref recorder)).Dispose();
		}
		ActiveRecorders.Clear();
	}

	public static void Serialize(AzureAnalyticsUploader uploader, DateTime timestamp, int frameIndex)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		if (!enabled)
		{
			return;
		}
		try
		{
			foreach (RecorderInfo activeRecorder in ActiveRecorders)
			{
				ProfilerRecorder recorder = activeRecorder.Recorder;
				if (((ProfilerRecorder)(ref recorder)).LastValue != 0L)
				{
					EventRecord eventRecord = EventRecord.CSV();
					EventRecord eventRecord2 = eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", activeRecorder.MethodName);
					recorder = activeRecorder.Recorder;
					eventRecord2.AddField("", ((ProfilerRecorder)(ref recorder)).LastValue).AddField("", Server.server_id);
					uploader.Append(eventRecord);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize profiler data: " + ex.Message));
		}
	}
}


using Unity.Profiling;

private struct RecorderInfo
{
	public string MethodName;

	public ProfilerRecorder Recorder;
}


using System;
using ConVar;
using Facepunch.Rust;
using UnityEngine;

public static class WorkQueueProfiler
{
	public static bool enabled;

	public static void Serialize(AzureAnalyticsUploader uploader, int frameIndex, DateTime timestamp)
	{
		if (!enabled)
		{
			return;
		}
		try
		{
			foreach (ObjectWorkQueue item in ObjectWorkQueue.All)
			{
				if (item.LastProcessedCount != 0)
				{
					EventRecord eventRecord = EventRecord.CSV();
					eventRecord.AddField("", frameIndex).AddField("", timestamp).AddField("", item.Name)
						.AddField("", item.LastQueueLength)
						.AddField("", item.LastExecutionTime)
						.AddField("", item.LastProcessedCount)
						.AddField("", Server.server_id);
					uploader.Append(eventRecord);
				}
			}
			foreach (PersistentObjectWorkQueue item2 in PersistentObjectWorkQueue.All)
			{
				if (item2.ListLength != 0)
				{
					EventRecord eventRecord2 = EventRecord.CSV();
					eventRecord2.AddField("", frameIndex).AddField("", timestamp).AddField("", item2.Name)
						.AddField("", item2.ListLength)
						.AddField("", item2.LastExecutionTime)
						.AddField("", item2.LastProcessedCount)
						.AddField("", Server.server_id);
					uploader.Append(eventRecord2);
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Failed to serialize work queues: " + ex.Message));
		}
	}

	public static void Reset()
	{
	}
}


using System;
using ModelViewer;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class ModelViewer_RenderParameters
{
	public enum SampleCountLevel
	{
		Low,
		Medium,
		High,
		VeryHigh
	}

	public enum renderResolution
	{
		_16,
		_32,
		_64,
		_128,
		_256,
		_512,
		_1024,
		_2048
	}

	[Header("Anti Aliasing")]
	public PostProcessLayer.Antialiasing antialiasing = PostProcessLayer.Antialiasing.TemporalAntialiasing;

	[Range(1f, 4f)]
	[Header("Shadows")]
	public int shadowCascades = 4;

	[Range(1f, 3f)]
	public int shadowLights = 3;

	[Range(1f, 4f)]
	public int shadowMode = 4;

	public float shadowDistance = 50f;

	[Range(0f, 3f)]
	public int shadowQuality = 3;

	[Range(0f, 0.02f)]
	public float shadowSoftness = 0.01f;

	[Range(0f, 2f)]
	public float sunShadowBias = 0.01f;

	[Header("Contact Shadows")]
	[Header("                ")]
	public bool enableContactShadows = true;

	[Range(0f, 1f)]
	public float blendStrength = 1f;

	[Range(0f, 1f)]
	public float accumulation = 0.9f;

	[Range(0.1f, 5f)]
	public float lengthFade = 0.7f;

	[Range(0.01f, 5f)]
	public float range = 0.7f;

	[Range(0f, 1f)]
	public float zThickness = 0.1f;

	[Range(2f, 92f)]
	public int samples = 32;

	[Range(0.5f, 4f)]
	public float nearSampleQuality = 1.5f;

	[Range(0f, 1f)]
	public float traceBias = 0.03f;

	[Header("Ambient Occlusion")]
	[Header("                ")]
	public bool enableAmbientOcclusion = true;

	public SampleCountLevel SampleCount = SampleCountLevel.Medium;

	public float Intensity = 1f;

	public Color Tint = Color.black;

	[Tooltip("Radius spread of the occlusion.")]
	[Range(0f, 32f)]
	public float Radius = 2f;

	[Tooltip("Power exponent attenuation of the occlusion.")]
	[Range(0f, 16f)]
	public float PowerExponent = 1.8f;

	[Tooltip("Controls the initial occlusion contribution offset.")]
	[Range(0f, 0.99f)]
	public float Bias = 0.05f;

	[Range(0f, 1f)]
	[Tooltip("Controls the thickness occlusion contribution.")]
	public float Thickness = 1f;

	[Tooltip("Compute the Occlusion and Blur at half of the resolution.")]
	public bool Downsample = true;

	[Tooltip("Control parameters at faraway.")]
	public bool FadeEnabled;

	[Tooltip("Distance in Unity unities that start to fade.")]
	public float FadeStart = 100f;

	[Tooltip("Length distance to performe the transition.")]
	public float FadeLength = 50f;

	[Tooltip("Final Intensity parameter.")]
	[Range(0f, 1f)]
	public float FadeToIntensity;

	public Color FadeToTint = Color.black;

	[Range(0f, 32f)]
	[Tooltip("Final Radius parameter.")]
	public float FadeToRadius = 2f;

	[Range(0f, 16f)]
	[Tooltip("Final PowerExponent parameter.")]
	public float FadeToPowerExponent = 1.8f;

	[Range(0f, 1f)]
	[Tooltip("Final Thickness parameter.")]
	public float FadeToThickness = 1f;

	[Header("Reflections")]
	[Header("                ")]
	public ReflectionProbeMode Type = (ReflectionProbeMode)1;

	public ReflectionProbeRefreshMode RefreshMode = (ReflectionProbeRefreshMode)1;

	public ReflectionProbeTimeSlicingMode TimeSlicing = (ReflectionProbeTimeSlicingMode)1;

	public renderResolution resolution;

	public float reflectionShadowDistance = 100f;

	public LayerMask cullingMask;

	public float reflectionClippingPlaneNear = 0.1f;

	public float reflectionClippingPlaneFar = 100f;
}


public enum SampleCountLevel
{
	Low,
	Medium,
	High,
	VeryHigh
}


public enum renderResolution
{
	_16,
	_32,
	_64,
	_128,
	_256,
	_512,
	_1024,
	_2048
}


using System;
using ModelViewer;
using UnityEngine;

[Serializable]
public class ModelViewer_MainCameraParameters
{
	public enum OverlayType
	{
		None,
		RuleOfThirds,
		GoldenRatio,
		CrossHair,
		AspectRatio,
		SafeFrames
	}

	public enum TonemappingMode
	{
		None,
		Neutral,
		ACES
	}

	[Header("Control")]
	public float orbitSpeed = 4f;

	public float mouseZoomSpeed = 1.2f;

	public float scrollZoomSpeed = 0.1f;

	public float panSpeed = 0.1f;

	public float moveSpeed = 0.05f;

	public float followLag;

	[Header("                ")]
	[Header("Lens")]
	[Range(0.01f, 360f)]
	public float fieldOfView = 15f;

	public float nearPlane = 0.05f;

	public float farPlane = 2500f;

	public OverlayType overlayType;

	[Range(0.01f, 100f)]
	public float Aspect = 4f;

	[Range(0.01f, 100f)]
	public float Ratio = 3f;

	[Header("Focus")]
	[Header("                ")]
	public bool depthOfField;

	public float focalLength = 3f;

	public float focalSize = 0.1f;

	public float apeture = 80f;

	public float maxBlurSize = 7f;

	public bool debugMode;

	[Header("                ")]
	[Header("Motion Blur")]
	[Range(0f, 360f)]
	public float shutterAngle;

	[Header("Distortion")]
	[Header("                ")]
	[Range(-100f, 100f)]
	public float barrelAndPincushion;

	[Range(0f, 1f)]
	public float chromaticAbberation;

	[Header("Post Effects")]
	[Header("                ")]
	public TonemappingMode ToneMapping = TonemappingMode.Neutral;

	public float Exposure = 2.34f;

	[Range(-100f, 100f)]
	public float Contrast;

	[Range(-100f, 100f)]
	public float Saturation;

	[Header("Sharpen")]
	[Header("                ")]
	public float Strength;

	public float limit;

	[Header("                ")]
	[Header("God Rays")]
	public bool GodRays = true;

	[Header("                ")]
	[Header("Bloom")]
	public float Brightness = 0.15f;

	public float Threshold = 1f;

	[Range(0f, 1f)]
	public float SoftKnee = 0.5f;

	public float Clamp;

	[Range(0f, 10f)]
	public float Diffusion = 8f;

	[Range(0f, 1f)]
	public float AnamorphicRatio = 0.55f;

	public Color Color = Color.white;

	[Header("Vignette")]
	[Header("                ")]
	public float Darkness;

	public float Sharpness;

	[Header("Grain")]
	[Header("                ")]
	public bool Coloured = true;

	[Range(0f, 1f)]
	public float Intensity;

	[Range(0.3f, 3f)]
	public float Size = 1f;

	[Range(0f, 1f)]
	public float luminanceContribution = 0.8f;
}


public enum OverlayType
{
	None,
	RuleOfThirds,
	GoldenRatio,
	CrossHair,
	AspectRatio,
	SafeFrames
}


public enum TonemappingMode
{
	None,
	Neutral,
	ACES
}


using System;
using UnityEngine;

[Serializable]
public class ModelViewer_SkyParameters
{
	[Range(0f, 1f)]
	[Header("Sky")]
	public float skyBrightness = 1f;

	[Header("Time of Day")]
	[Header("                ")]
	[Tooltip("Current hour of the day.")]
	public float Hour = 9f;

	[Tooltip("Current day of the month.")]
	public int Day = 20;

	[Tooltip("Current month of the year.")]
	public int Month = 5;

	[Tooltip("Current year.")]
	[TOD_Range(1f, 9999f)]
	public int Year = 2000;

	[Tooltip("Latitude of the current location in degrees.")]
	[Range(-90f, 90f)]
	public float Latitude = -10f;

	[Tooltip("Longitude of the current location in degrees.")]
	[Range(-180f, 180f)]
	public float Longitude = -25f;

	[Tooltip("UTC/GMT time zone of the current location in hours.")]
	[Range(-14f, 14f)]
	public float UTC;

	[Header("Atmosphere")]
	[Header("                ")]
	public float skyContrast = 1.2f;

	public float skyFogginess = 0.2f;

	public float cloudCoverage;
}


using ModelViewer;
using Rust.UI;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;
using UnityEngine.UI;

public class modelviewer : MonoBehaviour, IEditorComponent
{
	public GameObject cameraTarget;

	[Header("                ")]
	public ModelViewer_RenderParameters Render;

	public ModelViewer_MainCameraParameters MainCamera;

	public ModelViewer_SkyParameters Sky;

	[Header("Junk to clean up:")]
	[Header("                ")]
	[Header("                ")]
	public GameObject ruleOfThirds;

	public GameObject goldenRatio;

	public GameObject crosshair;

	public GameObject aspectRatio;

	public GameObject safeFrames;

	private GameObject enabledOverlay;

	public AspectRatioFitter aspectRatioFitter;

	public AspectRatioFitter safeFrameAspectRatioFigger;

	public RustText aspectRatioLabel;

	private Vector3 startpos = new Vector3(0f, 130f, 60f);

	public Camera maincamera;

	public GameObject modelHolder;

	public Transform skyDome;

	public float skyrotateSpeed;

	public Light sunLight;

	public NGSS_Directional sunLightSoftShadows;

	private GameObject orbitVector;

	private Quaternion orbt_rot_original;

	private Vector3 orbt_xform_original;

	private SEScreenSpaceShadows screenSpaceShadows;

	private AmplifyOcclusionBase ambientOcclusion;

	public ReflectionProbe[] reflectionProbes;

	private TOD_Sky todSky;

	private PostProcessVolume[] colorGradingVolumes;

	public PostProcessVolume basePostProcess;

	public PostProcessVolume sharpenvignettePostProcess;

	public PostProcessVolume colorGradingPostProcess;

	private LensDistortion lensDistortion;

	private ChromaticAberration chromaticAbberation;

	private SharpenAndVignette sharpenAndVignette;

	private Bloom bloom;

	private Grain grain;

	private ColorGrading colorGrading;

	private GodRays godRays;

	private MotionBlur motionBlur;

	public Vector3 skyRotation;

	public Vector3 cameraPosition;

	public Vector3 cameraRotation;

	public float cameraZoom;

	public Vector3 orbitVectorPosition;
}


using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;

[Factory("ai")]
public class AI : ConsoleSystem
{
	[ReplicatedVar(Saved = true)]
	public static bool allowdesigning = true;

	public const float showCommandsRefreshInterval = 0.1f;

	public const float animFadeDuration = 0.25f;

	[ServerVar]
	public static bool think = true;

	[ServerVar]
	public static bool navthink = true;

	[ServerVar]
	public static bool ignoreplayers = false;

	[ServerVar]
	public static bool effectaiweapons = false;

	[ServerVar]
	public static bool groups = true;

	[ServerVar]
	public static bool spliceupdates = true;

	[ServerVar]
	public static bool setdestinationsamplenavmesh = true;

	[ServerVar]
	public static bool usecalculatepath = true;

	[ServerVar]
	public static bool usesetdestinationfallback = true;

	[ServerVar]
	public static bool npcswimming = true;

	[ServerVar]
	public static bool accuratevisiondistance = true;

	[ServerVar]
	public static bool move = true;

	[ServerVar]
	public static bool usegrid = true;

	[ServerVar]
	public static bool sleepwake = true;

	[ServerVar]
	public static float sensetime = 1f;

	[ServerVar]
	public static float frametime = 5f;

	[ServerVar]
	public static int ocean_patrol_path_iterations = 100000;

	[ServerVar(Help = "If npc_enable is set to false then npcs won't spawn. (default: true)")]
	public static bool npc_enable = true;

	[ServerVar(Help = "npc_max_population_military_tunnels defines the size of the npc population at military tunnels. (default: 3)")]
	public static int npc_max_population_military_tunnels = 3;

	[ServerVar(Help = "npc_spawn_per_tick_max_military_tunnels defines how many can maximum spawn at once at military tunnels. (default: 1)")]
	public static int npc_spawn_per_tick_max_military_tunnels = 1;

	[ServerVar(Help = "npc_spawn_per_tick_min_military_tunnels defineshow many will minimum spawn at once at military tunnels. (default: 1)")]
	public static int npc_spawn_per_tick_min_military_tunnels = 1;

	[ServerVar(Help = "npc_respawn_delay_max_military_tunnels defines the maximum delay between spawn ticks at military tunnels. (default: 1920)")]
	public static float npc_respawn_delay_max_military_tunnels = 1920f;

	[ServerVar(Help = "npc_respawn_delay_min_military_tunnels defines the minimum delay between spawn ticks at military tunnels. (default: 480)")]
	public static float npc_respawn_delay_min_military_tunnels = 480f;

	[ServerVar(Help = "npc_valid_aim_cone defines how close their aim needs to be on target in order to fire. (default: 0.8)")]
	public static float npc_valid_aim_cone = 0.8f;

	[ServerVar(Help = "npc_valid_mounted_aim_cone defines how close their aim needs to be on target in order to fire while mounted. (default: 0.92)")]
	public static float npc_valid_mounted_aim_cone = 0.92f;

	[ServerVar(Help = "npc_cover_compromised_cooldown defines how long a cover point is marked as compromised before it's cleared again for selection. (default: 10)")]
	public static float npc_cover_compromised_cooldown = 10f;

	[ServerVar(Help = "If npc_cover_use_path_distance is set to true then npcs will look at the distance between the cover point and their target using the path between the two, rather than the straight-line distance.")]
	public static bool npc_cover_use_path_distance = true;

	[ServerVar(Help = "npc_cover_path_vs_straight_dist_max_diff defines what the maximum difference between straight-line distance and path distance can be when evaluating cover points. (default: 2)")]
	public static float npc_cover_path_vs_straight_dist_max_diff = 2f;

	[ServerVar(Help = "npc_door_trigger_size defines the size of the trigger box on doors that opens the door as npcs walk close to it (default: 1.5)")]
	public static float npc_door_trigger_size = 1.5f;

	[ServerVar(Help = "npc_patrol_point_cooldown defines the cooldown time on a patrol point until it's available again (default: 5)")]
	public static float npc_patrol_point_cooldown = 5f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the walk state, and should be a number between 0 and 1. (Default: 0.18)")]
	public static float npc_speed_walk = 0.18f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the run state, and should be a number between 0 and 1. (Default: 0.4)")]
	public static float npc_speed_run = 0.4f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the sprint state, and should be a number between 0 and 1. (Default: 1.0)")]
	public static float npc_speed_sprint = 1f;

	[ServerVar(Help = "npc_speed_walk define the speed of an npc when in the crouched walk state, and should be a number between 0 and 1. (Default: 0.1)")]
	public static float npc_speed_crouch_walk = 0.1f;

	[ServerVar(Help = "npc_speed_crouch_run define the speed of an npc when in the crouched run state, and should be a number between 0 and 1. (Default: 0.25)")]
	public static float npc_speed_crouch_run = 0.25f;

	[ServerVar(Help = "npc_alertness_drain_rate define the rate at which we drain the alertness level of an NPC when there are no enemies in sight. (Default: 0.01)")]
	public static float npc_alertness_drain_rate = 0.01f;

	[ServerVar(Help = "npc_alertness_zero_detection_mod define the threshold of visibility required to detect an enemy when alertness is zero. (Default: 0.5)")]
	public static float npc_alertness_zero_detection_mod = 0.5f;

	[ServerVar(Help = "defines the chance for scientists to spawn at NPC junkpiles. (Default: 0.1)")]
	public static float npc_junkpilespawn_chance = 0.07f;

	[ServerVar(Help = "npc_junkpile_dist_aggro_gate define at what range (or closer) a junkpile scientist will get aggressive. (Default: 8)")]
	public static float npc_junkpile_dist_aggro_gate = 8f;

	[ServerVar(Help = "npc_max_junkpile_count define how many npcs can spawn into the world at junkpiles at the same time (does not include monuments) (Default: 30)")]
	public static int npc_max_junkpile_count = 30;

	[ServerVar(Help = "If npc_families_no_hurt is true, npcs of the same family won't be able to hurt each other. (default: true)")]
	public static bool npc_families_no_hurt = true;

	[ServerVar(Help = "If npc_ignore_chairs is true, npcs won't care about seeking out and sitting in chairs. (default: true)")]
	public static bool npc_ignore_chairs = true;

	[ServerVar(Help = "The rate at which we tick the sensory system. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 5)")]
	public static float npc_sensory_system_tick_rate_multiplier = 5f;

	[ServerVar(Help = "The rate at which we gather information about available cover points. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 20)")]
	public static float npc_cover_info_tick_rate_multiplier = 20f;

	[ServerVar(Help = "The rate at which we tick the reasoning system. Minimum value is 1, as it multiplies with the tick-rate of the fixed AI tick rate of 0.1 (Default: 1)")]
	public static float npc_reasoning_system_tick_rate_multiplier = 1f;

	[ServerVar]
	public static bool npc_check_spawner_is_on_navmesh = true;

	[ServerVar(Help = "If animal_ignore_food is true, animals will not sense food sources or interact with them (server optimization). (default: true)")]
	public static bool animal_ignore_food = true;

	[ServerVar(Help = "The modifier by which a silencer reduce the noise that a gun makes when shot. (Default: 0.15)")]
	public static float npc_gun_noise_silencer_modifier = 0.15f;

	[ServerVar(Help = "If nav_carve_use_building_optimization is true, we attempt to reduce the amount of navmesh carves for a building. (default: false)")]
	public static bool nav_carve_use_building_optimization = false;

	[ServerVar(Help = "The minimum number of building blocks a building needs to consist of for this optimization to be applied. (default: 25)")]
	public static int nav_carve_min_building_blocks_to_apply_optimization = 25;

	[ServerVar(Help = "The minimum size we allow a carving volume to be. (default: 2)")]
	public static float nav_carve_min_base_size = 2f;

	[ServerVar(Help = "The size multiplier applied to the size of the carve volume. The smaller the value, the tighter the skirt around foundation edges, but too small and animals can attack through walls. (default: 4)")]
	public static float nav_carve_size_multiplier = 4f;

	[ServerVar(Help = "The height of the carve volume. (default: 2)")]
	public static float nav_carve_height = 2f;

	[ServerVar(Help = "If npc_only_hurt_active_target_in_safezone is true, npcs won't any player other than their actively targeted player when in a safe zone. (default: true)")]
	public static bool npc_only_hurt_active_target_in_safezone = true;

	[ServerVar(Help = "If npc_use_new_aim_system is true, npcs will miss on purpose on occasion, where the old system would randomize aim cone. (default: true)")]
	public static bool npc_use_new_aim_system = true;

	[ServerVar(Help = "If npc_use_thrown_weapons is true, npcs will throw grenades, etc. This is an experimental feature. (default: true)")]
	public static bool npc_use_thrown_weapons = true;

	[ServerVar(Help = "This is multiplied with the max roam range stat of an NPC to determine how far from its spawn point the NPC is allowed to roam. (default: 3)")]
	public static float npc_max_roam_multiplier = 3f;

	[ServerVar(Help = "This is multiplied with the current alertness (0-10) to decide how long it will take for the NPC to deliberately miss again. (default: 0.33)")]
	public static float npc_alertness_to_aim_modifier = 0.5f;

	[ServerVar(Help = "The time it takes for the NPC to deliberately miss to the time the NPC tries to hit its target. (default: 1.5)")]
	public static float npc_deliberate_miss_to_hit_alignment_time = 1.5f;

	[ServerVar(Help = "The offset with which the NPC will maximum miss the target. (default: 1.25)")]
	public static float npc_deliberate_miss_offset_multiplier = 1.25f;

	[ServerVar(Help = "The percentage away from a maximum miss the randomizer is allowed to travel when shooting to deliberately hit the target (we don't want perfect hits with every shot). (default: 0.85f)")]
	public static float npc_deliberate_hit_randomizer = 0.85f;

	[ServerVar(Help = "Baseline damage modifier for the new HTN Player NPCs to nerf their damage compared to the old NPCs. (default: 1.15f)")]
	public static float npc_htn_player_base_damage_modifier = 1.15f;

	[ServerVar(Help = "Spawn NPCs on the Cargo Ship. (default: true)")]
	public static bool npc_spawn_on_cargo_ship = true;

	[ServerVar(Help = "Spawn NPCs on junkpiles (default: true)")]
	public static bool npc_spawn_on_junkpile = true;

	[ServerVar(Help = "Do any kind of scientists spawn on the map (default: true)")]
	public static bool scientist_spawners_enabled = true;

	[ServerVar(Help = "npc_htn_player_frustration_threshold defines where the frustration threshold for NPCs go, where they have the opportunity to change to a more aggressive tactic. (default: 3)")]
	public static int npc_htn_player_frustration_threshold = 3;

	[ServerVar]
	public static bool logIssues = false;

	[ServerVar]
	public static float tickrate = 5f;

	[ServerVar(Help = "The angle under which the AI will think it's being watched by another entity")]
	public static float watchedAngle = 50f;

	[ServerVar(Help = "The angle under which the AI will think it's being aimed at at by a player")]
	public static float aimedAtAngle = 10f;

	public const float minDepthToBeConsideredInWater = 0.3f;

	[ServerVar]
	public static float defaultInterpolationDelay = 0.1f;

	[ServerVar]
	public static void showState(Arg arg)
	{
		arg.Player()?.ToggleShowFSMStateDebugInfo();
	}

	[ServerVar]
	public static void sleepwakestats(Arg args)
	{
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			if (!((Object)(object)zone == (Object)null) && zone.ShouldSleepAI)
			{
				num++;
				if (zone.Sleeping)
				{
					num2++;
					num3 += zone.SleepingCount;
				}
			}
		}
		args.ReplyWith("Sleeping AIZs: " + num2 + " / " + num + ". Total sleeping ents: " + num3);
	}

	[ServerVar]
	public static void wakesleepingai(Arg args)
	{
		int num = 0;
		int num2 = 0;
		foreach (AIInformationZone zone in AIInformationZone.zones)
		{
			if (!((Object)(object)zone == (Object)null) && zone.ShouldSleepAI && zone.Sleeping)
			{
				num++;
				num2 += zone.SleepingCount;
				zone.WakeAI();
			}
		}
		args.ReplyWith("Woke " + num + " sleeping AIZs containing " + num2 + " sleeping entities.");
	}

	[ServerVar]
	public static void brainstats(Arg args)
	{
		int num = BaseEntity.Util.FindAll<BaseNPC2>().Length;
		int num2 = AnimalBrain.Count + ScientistBrain.Count + PetBrain.Count;
		args.ReplyWith($"Animal: {AnimalBrain.Count}. Scientist: {ScientistBrain.Count}. Pet: {PetBrain.Count}. NPC2:{num}. Total: {num2}");
	}

	[ServerVar]
	public static void aizonestats(Arg args)
	{
		args.ReplyWith("AIInformationZone count: " + AIInformationZone.zones.Count);
	}

	[ServerVar]
	public static void killscientists(Arg args)
	{
		ScientistNPC[] array = BaseEntity.Util.FindAll<ScientistNPC>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
		TunnelDweller[] array2 = BaseEntity.Util.FindAll<TunnelDweller>();
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].Kill();
		}
	}

	[ServerVar]
	public static void killanimals(Arg args)
	{
		BaseAnimalNPC[] array = BaseEntity.Util.FindAll<BaseAnimalNPC>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
		BaseNPC2[] array2 = BaseEntity.Util.FindAll<BaseNPC2>();
		foreach (BaseNPC2 baseNPC in array2)
		{
			if (baseNPC.IsAnimal)
			{
				baseNPC.Kill();
			}
		}
	}

	[ServerVar(Help = "Add a player (or command user if no player is specified) to the AIs ignore list.")]
	public static void addignoreplayer(Arg args)
	{
		BasePlayer basePlayer = null;
		basePlayer = (args.HasArgs(1) ? args.GetPlayerOrSleeper(0) : args.Player());
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null || basePlayer.net.connection == null)
		{
			args.ReplyWith("Player not found.");
		}
		else
		{
			SimpleAIMemory.AddIgnorePlayer(basePlayer);
		}
	}

	[ServerVar(Help = "Remove a player (or command user if no player is specified) from the AIs ignore list.")]
	public static void removeignoreplayer(Arg args)
	{
		BasePlayer basePlayer = null;
		basePlayer = (args.HasArgs(1) ? args.GetPlayerOrSleeper(0) : args.Player());
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null || basePlayer.net.connection == null)
		{
			args.ReplyWith("Player not found.");
		}
		else
		{
			SimpleAIMemory.RemoveIgnorePlayer(basePlayer);
		}
	}

	[ServerVar(Help = "Remove all players from the AIs ignore list.")]
	public static void clearignoredplayers(Arg args)
	{
		SimpleAIMemory.ClearIgnoredPlayers();
	}

	[ServerVar(Help = "Print a lost of all the players in the AI ignore list.")]
	public static void printignoredplayers(Arg args)
	{
		args.ReplyWith(SimpleAIMemory.GetIgnoredPlayers());
	}

	public static float TickDelta()
	{
		return 1f / tickrate;
	}

	[ServerVar]
	public static void selectNPCLookatServer(Arg args)
	{
	}

	[ServerVar]
	public static void showDistributions(Arg args)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Math;
using Network;
using Newtonsoft.Json;
using ProtoBuf;
using Rust;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Scripting;

[Factory("global")]
public class Admin : ConsoleSystem
{
	private enum ChangeGradeMode
	{
		Upgrade,
		Downgrade
	}

	[JsonModel]
	[Preserve]
	public struct PlayerInfo
	{
		public string SteamID;

		public string OwnerSteamID;

		public string DisplayName;

		public int Ping;

		public string Address;

		public ulong EntityId;

		public int ConnectedSeconds;

		public float ViolationLevel;

		public float CurrentLevel;

		public float UnspentXp;

		public float Health;
	}

	[Preserve]
	[JsonModel]
	public struct PlayerIDInfo
	{
		public string SteamID;

		public string OwnerSteamID;

		public string DisplayName;

		public string Address;

		public ulong EntityId;
	}

	[Preserve]
	[JsonModel]
	public struct ServerInfoOutput
	{
		public string Hostname;

		public int MaxPlayers;

		public int Players;

		public int Queued;

		public int Joining;

		public int ReservedSlots;

		public int EntityCount;

		public string GameTime;

		public int Uptime;

		public string Map;

		public float Framerate;

		public int Memory;

		public int MemoryUsageSystem;

		public int Collections;

		public int NetworkIn;

		public int NetworkOut;

		public bool Restarting;

		public string SaveCreatedTime;

		public int Version;

		public string Protocol;
	}

	[Preserve]
	[JsonModel]
	public struct ServerConvarInfo
	{
		public string FullName;

		public string Value;

		public string Help;
	}

	[JsonModel]
	[Preserve]
	public struct ServerUGCInfo
	{
		public ulong entityId;

		public uint[] crcs;

		public UGCType contentType;

		public uint entityPrefabID;

		public string shortPrefabName;

		public ulong[] playerIds;

		public string contentString;

		public ServerUGCInfo(IUGCBrowserEntity fromEntity)
		{
			entityId = fromEntity.UgcEntity.net.ID.Value;
			crcs = fromEntity.GetContentCRCs;
			contentType = fromEntity.ContentType;
			entityPrefabID = fromEntity.UgcEntity.prefabID;
			shortPrefabName = fromEntity.UgcEntity.ShortPrefabName;
			playerIds = fromEntity.EditingHistory.ToArray();
			contentString = fromEntity.ContentString;
		}
	}

	private struct EntityAssociation
	{
		public BaseEntity TargetEntity;

		public EntityAssociationType AssociationType;
	}

	private enum EntityAssociationType
	{
		Owner,
		Auth,
		LockGuest
	}

	[ReplicatedVar(Help = "Controls whether the in-game admin UI is displayed to admins")]
	public static bool allowAdminUI = true;

	[ServerVar(Help = "Print out currently connected clients")]
	public static void status(Arg arg)
	{
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (@string == "--json")
		{
			@string = arg.GetString(1, "");
		}
		bool flag = arg.HasArg("--json", false);
		string text = string.Empty;
		if (!flag && @string.Length == 0)
		{
			text = text + "hostname: " + ConVar.Server.hostname + "\n";
			text = text + "version : " + 2597 + " secure (secure mode enabled, connected to Steam3)\n";
			text = text + "map     : " + ConVar.Server.level + "\n";
			text += $"players : {((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Count()} ({ConVar.Server.maxplayers} max) ({SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued} queued) ({SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining} joining)\n\n";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("ping");
			val.AddColumn("connected");
			val.AddColumn("addr");
			val.AddColumn("owner");
			val.AddColumn("violation");
			val.AddColumn("kicks");
			val.AddColumn("entityId");
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					try
					{
						if (!current.IsValid())
						{
							continue;
						}
						string userIDString = current.UserIDString;
						if (current.net.connection == null)
						{
							val.AddRow(new string[2] { userIDString, "NO CONNECTION" });
							continue;
						}
						string text2 = current.net.connection.ownerid.ToString();
						string text3 = StringExtensions.QuoteSafe(current.displayName);
						string text4 = Net.sv.GetAveragePing(current.net.connection).ToString();
						string text5 = current.net.connection.ipaddress;
						string text6 = current.net.ID.Value.ToString();
						string text7 = current.violationLevel.ToString("0.0");
						string text8 = current.GetAntiHackKicks().ToString();
						if (!arg.IsAdmin && !arg.IsRcon)
						{
							text5 = "xx.xxx.xx.xxx";
						}
						string text9 = current.net.connection.GetSecondsConnected() + "s";
						if (@string.Length <= 0 || StringEx.Contains(text3, @string, CompareOptions.IgnoreCase) || userIDString.Contains(@string) || text2.Contains(@string) || text5.Contains(@string))
						{
							val.AddRow(new string[9]
							{
								userIDString,
								text3,
								text4,
								text9,
								text5,
								(text2 == userIDString) ? string.Empty : text2,
								text7,
								text8,
								text6
							});
						}
					}
					catch (Exception ex)
					{
						val.AddRow(new string[2]
						{
							current.UserIDString,
							StringExtensions.QuoteSafe(ex.Message)
						});
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			if (flag)
			{
				arg.ReplyWith(val.ToJson(true));
			}
			else
			{
				arg.ReplyWith(text + ((object)val).ToString());
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Print out stats of currently connected clients")]
	public static void stats(Arg arg)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("time");
			val.AddColumn("kills");
			val.AddColumn("deaths");
			val.AddColumn("suicides");
			val.AddColumn("player");
			val.AddColumn("building");
			val.AddColumn("entity");
			ulong uInt = arg.GetUInt64(0, 0uL);
			if (uInt == 0L)
			{
				string @string = arg.GetString(0, "");
				Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						BasePlayer current = enumerator.Current;
						try
						{
							if (current.IsValid())
							{
								string text = StringExtensions.QuoteSafe(current.displayName);
								if (@string.Length <= 0 || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
								{
									addRow(current.userID, text, val);
								}
							}
						}
						catch (Exception ex)
						{
							val.AddRow(new string[2]
							{
								current.UserIDString,
								StringExtensions.QuoteSafe(ex.Message)
							});
						}
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
			else
			{
				string name2 = "N/A";
				BasePlayer basePlayer = BasePlayer.FindByID(uInt);
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					name2 = StringExtensions.QuoteSafe(basePlayer.displayName);
				}
				addRow(uInt, name2, val);
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		static void addRow(ulong id, string name, TextTable table)
		{
			ServerStatistics.Storage storage = ServerStatistics.Get(id);
			string text2 = TimeSpan.FromSeconds(storage.Get("time")).ToShortString();
			string text3 = storage.Get("kill_player").ToString();
			string text4 = (storage.Get("deaths") - storage.Get("death_suicide")).ToString();
			string text5 = storage.Get("death_suicide").ToString();
			string text6 = storage.Get("hit_player_direct_los").ToString();
			string text7 = storage.Get("hit_player_indirect_los").ToString();
			string text8 = storage.Get("hit_building_direct_los").ToString();
			string text9 = storage.Get("hit_building_indirect_los").ToString();
			string text10 = storage.Get("hit_entity_direct_los").ToString();
			string text11 = storage.Get("hit_entity_indirect_los").ToString();
			table.AddRow(new string[9]
			{
				id.ToString(),
				name,
				text2,
				text3,
				text4,
				text5,
				text6 + " / " + text7,
				text8 + " / " + text9,
				text10 + " / " + text11
			});
		}
	}

	[ServerVar(Help = "upgrade_radius 'grade' 'radius'")]
	public static void upgrade_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'upgrade_radius {grade} {radius}'");
		}
		else
		{
			SkinRadiusInternal(arg, changeAnyGrade: true);
		}
	}

	[ServerVar(Help = "<grade>")]
	public static void upgrade_looking(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'upgrade_looking {grade}'");
		}
		else
		{
			SkinRaycastInternal(arg, changeAnyGrade: true);
		}
	}

	[ServerVar(Help = "skin_radius 'skin' 'radius'")]
	public static void skin_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'skin_radius {skin} {radius}'");
		}
		else
		{
			SkinRadiusInternal(arg, changeAnyGrade: false);
		}
	}

	[ServerVar(Help = "<skin>")]
	public static void skin_looking(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'skin_looking <skin>'");
		}
		else
		{
			SkinRaycastInternal(arg, changeAnyGrade: false);
		}
	}

	[ServerVar(Help = "<name/id> <radius> | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random")]
	public static void add_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'add_wallpaper_radius {skin} {radius}' | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random");
		}
		else
		{
			wallpaper_radius_internal(arg, addIfMissing: true);
		}
	}

	[ServerVar(Help = "<name/id> <radius> | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random")]
	public static void change_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Format is 'change_wallpaper_radius {skin} {radius}' | Use print_wallpaper_skins for a list | 0 -> default, -1 -> random");
		}
		else
		{
			wallpaper_radius_internal(arg, addIfMissing: false);
		}
	}

	[ServerVar(Help = "clear_wallpaper_radius <radius>")]
	public static void clear_wallpaper_radius(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'clear_wallpaper_radius {radius}'");
			return;
		}
		RunInRadius(arg.GetFloat(0, 0f), arg.Player(), delegate(BuildingBlock block)
		{
			if (block.HasWallpaper())
			{
				block.RemoveWallpaper(0);
				block.RemoveWallpaper(1);
			}
		});
	}

	public static BuildingGrade FindBuildingSkin(string name, out string error)
	{
		BuildingGrade buildingGrade = null;
		error = null;
		IEnumerable<BuildingGrade> source = from x in PrefabAttribute.server.FindAll<ConstructionGrade>(2194854973u)
			select x.gradeBase;
		switch (name)
		{
		case "twig":
		case "0":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "twigs");
			break;
		case "wood":
		case "1":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "wood");
			break;
		case "stone":
		case "2":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "stone");
			break;
		case "metal":
		case "sheetmetal":
		case "3":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "metal");
			break;
		case "hqm":
		case "armored":
		case "armoured":
		case "4":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "toptier");
			break;
		case "adobe":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "adobe");
			break;
		case "shipping":
		case "shippingcontainer":
		case "container":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "shipping_container");
			break;
		case "brutal":
		case "brutalist":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "brutalist");
			break;
		case "brick":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "brick");
			break;
		case "jungle":
		case "jungleruin":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "jungle");
			break;
		case "frontier":
		case "legacy":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "frontier");
			break;
		case "gingerbread":
			buildingGrade = source.FirstOrDefault((BuildingGrade x) => ((Object)x).name == "gingerbread");
			break;
		default:
			error = "Valid skins are:\ntwig\nwood | frontier | gingerbread\nstone | adobe | brick | brutalist | jungle\nmetal | shipping\nhqm";
			return null;
		}
		if ((Object)(object)buildingGrade == (Object)null)
		{
			error = "Unable to find skin object for '" + name + "'";
		}
		return buildingGrade;
	}

	private static IEnumerable<BuildingBlock> SearchRadius(Vector3 position, float radius)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		List<BuildingBlock> list = new List<BuildingBlock>();
		Vis.Entities(position, radius, list, 2097152, (QueryTriggerInteraction)2);
		return list;
	}

	private static IEnumerable<BuildingBlock> SearchLookingAt(Vector3 position, Vector3 direction, float maxDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		BuildingBlock buildingBlock = GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, new Ray(position, direction), 0f, maxDistance, 10485760, (QueryTriggerInteraction)1) as BuildingBlock;
		if ((Object)(object)buildingBlock == (Object)null)
		{
			return Array.Empty<BuildingBlock>();
		}
		return (IEnumerable<BuildingBlock>)(buildingBlock.GetBuilding()?.buildingBlocks);
	}

	private static void SkinRadiusInternal(Arg arg, bool changeAnyGrade)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		IEnumerable<BuildingBlock> blocks = SearchRadius(((Component)arg.Player()).transform.position, arg.GetFloat(1, 0f));
		ApplySkinInternal(arg, changeAnyGrade, blocks);
	}

	private static void SkinRaycastInternal(Arg arg, bool changeAnyGrade)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		IEnumerable<BuildingBlock> blocks = SearchLookingAt(basePlayer.eyes.position, basePlayer.eyes.BodyForward(), 100f);
		ApplySkinInternal(arg, changeAnyGrade, blocks);
	}

	private static void ApplySkinInternal(Arg arg, bool changeAnyGrade, IEnumerable<BuildingBlock> blocks)
	{
		if ((Object)(object)arg.Player() == (Object)null)
		{
			arg.ReplyWith("This must be called from the client");
			return;
		}
		arg.GetFloat(1, 0f);
		string @string = arg.GetString(0, "");
		string error;
		BuildingGrade buildingGrade = FindBuildingSkin(@string, out error);
		if ((Object)(object)buildingGrade == (Object)null)
		{
			arg.ReplyWith(error);
			return;
		}
		if (!buildingGrade.enabledInStandalone)
		{
			arg.ReplyWith("Skin " + @string + " is not enabled in standalone yet");
			return;
		}
		if (blocks == null || blocks.Count() == 0)
		{
			arg.ReplyWith("No building blocks found");
			return;
		}
		foreach (BuildingBlock block in blocks)
		{
			if (block.grade == buildingGrade.type || changeAnyGrade)
			{
				block.ChangeGradeAndSkin(buildingGrade.type, buildingGrade.skin);
			}
		}
	}

	private static void wallpaper_radius_internal(Arg arg, bool addIfMissing)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("This must be called from the client");
			return;
		}
		float @float = arg.GetFloat(1, 0f);
		string @string = arg.GetString(0, "");
		int skinIdParsed = -1;
		if (!int.TryParse(@string, out skinIdParsed))
		{
			skinIdParsed = -1;
		}
		bool flag = false;
		string foundSkinName = "";
		foreach (ItemSkinDirectory.Skin item in WallpaperSettings.WallpaperItemDef.skins.Concat(WallpaperSettings.FlooringItemDef.skins).Concat(WallpaperSettings.CeilingItemDef.skins))
		{
			if (skinIdParsed != -1 && item.id == skinIdParsed)
			{
				flag = true;
				foundSkinName = item.invItem.displayName.english.Trim();
				break;
			}
			if (skinIdParsed == -1 && (item.invItem.displayName.english.Contains(@string, StringComparison.InvariantCultureIgnoreCase) || ((Object)item.invItem).name.Contains(@string, StringComparison.InvariantCultureIgnoreCase)))
			{
				flag = true;
				foundSkinName = item.invItem.displayName.english.Trim();
				skinIdParsed = item.id;
				break;
			}
		}
		if (skinIdParsed == 0)
		{
			flag = true;
		}
		if (!flag && skinIdParsed != -1)
		{
			arg.ReplyWith("Invalid skin");
			return;
		}
		RunInRadius(@float, basePlayer, delegate(BuildingBlock block)
		{
			bool flag2 = block.HasWallpaper();
			bool flag3 = flag2;
			if (addIfMissing && !flag2)
			{
				flag3 = WallpaperPlanner.Settings.CanUseWallpaper(block);
			}
			if (block.HasWallpaper() || flag3)
			{
				if (skinIdParsed == -1)
				{
					arg.ReplyWith("Applying random wallpaper");
					for (int i = 0; i < 2; i++)
					{
						ItemDefinition wallpaperItem = WallpaperPlanner.Settings.GetWallpaperItem(block, i);
						if ((Object)(object)wallpaperItem != (Object)null)
						{
							int id = wallpaperItem.skins.GetRandom().id;
							block.SetWallpaper((ulong)id, i);
						}
					}
				}
				else if (skinIdParsed == 0)
				{
					arg.ReplyWith("Applying default wallpaper");
					block.SetWallpaper(0uL);
					block.SetWallpaper(0uL, 1);
				}
				else
				{
					arg.ReplyWith("Applying '" + foundSkinName + "' wallpaper to compatible blocks");
					for (int j = 0; j < 2; j++)
					{
						ItemDefinition wallpaperItem2 = WallpaperPlanner.Settings.GetWallpaperItem(block, j);
						if ((Object)(object)wallpaperItem2 != (Object)null && wallpaperItem2.skins.Any((ItemSkinDirectory.Skin x) => x.id == skinIdParsed))
						{
							block.SetWallpaper((ulong)skinIdParsed, j);
						}
					}
				}
				block.CheckWallpaper();
			}
		});
	}

	[ServerVar(Help = "Lists all wallpaper skins")]
	public static void print_wallpaper_skins(Arg arg)
	{
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[3] { "Id", "Type", "Name" });
			ItemSkinDirectory.Skin[] skins = WallpaperSettings.WallpaperItemDef.skins;
			for (int i = 0; i < skins.Length; i++)
			{
				ItemSkinDirectory.Skin skin = skins[i];
				string[] array = new string[3];
				int id = skin.id;
				array[0] = id.ToString();
				array[1] = "Wall";
				array[2] = skin.invItem.displayName.english.Trim();
				val.AddRow(array);
			}
			skins = WallpaperSettings.FlooringItemDef.skins;
			for (int i = 0; i < skins.Length; i++)
			{
				ItemSkinDirectory.Skin skin2 = skins[i];
				string[] array2 = new string[3];
				int id = skin2.id;
				array2[0] = id.ToString();
				array2[1] = "Floor";
				array2[2] = skin2.invItem.displayName.english.Trim();
				val.AddRow(array2);
			}
			skins = WallpaperSettings.CeilingItemDef.skins;
			for (int i = 0; i < skins.Length; i++)
			{
				ItemSkinDirectory.Skin skin3 = skins[i];
				string[] array3 = new string[3];
				int id = skin3.id;
				array3[0] = id.ToString();
				array3[1] = "Ceiling";
				array3[2] = skin3.invItem.displayName.english.Trim();
				val.AddRow(array3);
			}
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void killplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
		}
	}

	[ServerVar]
	public static void killallplayers(Arg arg)
	{
		BasePlayer[] array = BaseEntity.Util.FindAll<BasePlayer>();
		int num = 0;
		BasePlayer[] array2 = array;
		foreach (BasePlayer basePlayer in array2)
		{
			if (!basePlayer.IsNpc)
			{
				basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
				num++;
			}
		}
		arg.ReplyWith($"Killed {num} players");
	}

	[ServerVar]
	public static void injureplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			Global.InjurePlayer(basePlayer);
		}
	}

	[ServerVar]
	public static void recoverplayer(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer = BasePlayer.FindBotClosestMatch(arg.GetString(0, ""));
		}
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			arg.ReplyWith("Player not found");
		}
		else
		{
			Global.RecoverPlayer(basePlayer);
		}
	}

	[ServerVar]
	public static void kick(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		string @string = arg.GetString(1, "no reason given");
		arg.ReplyWith("Kicked: " + player.displayName);
		Chat.Broadcast("Kicking " + player.displayName + " (" + @string + ")", "SERVER", "#eee", 0uL);
		player.Kick("Kicked: " + arg.GetString(1, "No Reason Given"), reserveSlot: false);
	}

	[ServerVar]
	public static void skick(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		string @string = arg.GetString(1, "no reason given");
		arg.ReplyWith("Kicked: " + player.displayName);
		Chat.ChatEntry ce = default(Chat.ChatEntry);
		ce.Channel = Chat.ChatChannel.Server;
		ce.Message = "(SILENT) Kicking " + player.displayName + " (" + @string + ")";
		ce.UserId = "0";
		ce.Username = "SERVER";
		ce.Color = "#eee";
		ce.Time = Epoch.Current;
		Chat.Record(ce);
		player.Kick("Kicked: " + arg.GetString(1, "No Reason Given"), reserveSlot: false);
	}

	[ServerVar]
	public static void kickall(Arg arg)
	{
		BasePlayer[] array = ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kick("Kicked: " + arg.GetString(0, "No Reason Given"));
		}
	}

	[ServerVar(Help = "ban <player> <reason> [optional duration]")]
	public static void ban(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if (!Object.op_Implicit((Object)(object)player) || player.net == null || player.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(player.userID);
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {player.userID.Get()} is already banned");
			return;
		}
		string @string = arg.GetString(1, "No Reason Given");
		if (TryGetBanExpiry(arg, 2, out var expiry, out var durationSuffix))
		{
			ServerUsers.Set(player.userID, ServerUsers.UserGroup.Banned, player.displayName, @string, expiry);
			string text = "";
			if (player.IsConnected && player.net.connection.ownerid != 0L && player.net.connection.ownerid != player.net.connection.userid)
			{
				text += $" and also banned ownerid {player.net.connection.ownerid}";
				ServerUsers.Set(player.net.connection.ownerid, ServerUsers.UserGroup.Banned, player.displayName, arg.GetString(1, $"Family share owner of {player.net.connection.userid}"), -1L);
			}
			ServerUsers.Save();
			arg.ReplyWith($"Kickbanned User{durationSuffix}: {player.userID.Get()} - {player.displayName}{text}");
			Chat.Broadcast("Kickbanning " + player.displayName + durationSuffix + " (" + @string + ")", "SERVER", "#eee", 0uL);
			Net.sv.Kick(player.net.connection, "Banned" + durationSuffix + ": " + @string, false);
		}
	}

	[ServerVar]
	public static void moderatorid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Moderator)
		{
			arg.ReplyWith("User " + uInt + " is already a Moderator");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.Moderator, @string, string2, -1L);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: true);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Added moderator " + @string + ", steamid " + uInt);
	}

	[ServerVar]
	public static void ownerid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		if (arg.Connection != null && arg.Connection.authLevel < 2)
		{
			arg.ReplyWith("Moderators cannot run ownerid");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Owner)
		{
			arg.ReplyWith("User " + uInt + " is already an Owner");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.Owner, @string, string2, -1L);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: true);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Added owner " + @string + ", steamid " + uInt);
	}

	[ServerVar]
	public static void removemoderator(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Moderator)
		{
			arg.ReplyWith("User " + uInt + " isn't a moderator");
			return;
		}
		ServerUsers.Remove(uInt);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: false);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Removed Moderator: " + uInt);
	}

	[ServerVar]
	public static void removeowner(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Owner)
		{
			arg.ReplyWith("User " + uInt + " isn't an owner");
			return;
		}
		ServerUsers.Remove(uInt);
		ServerUsers.Save();
		BasePlayer basePlayer = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetPlayerFlag(BasePlayer.PlayerFlags.IsAdmin, b: false);
			basePlayer.SendNetworkUpdate();
		}
		arg.ReplyWith("Removed Owner: " + uInt);
	}

	[ServerVar(Help = "banid <steamid> <username> <reason> [optional duration]")]
	public static void banid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string text = arg.GetString(1, "unnamed");
		string @string = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith("User " + uInt + " is already banned");
		}
		else
		{
			if (!TryGetBanExpiry(arg, 3, out var expiry, out var durationSuffix))
			{
				return;
			}
			string text2 = "";
			BasePlayer basePlayer = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.IsConnected)
			{
				text = basePlayer.displayName;
				if (basePlayer.IsConnected && basePlayer.net.connection.ownerid != 0L && basePlayer.net.connection.ownerid != basePlayer.net.connection.userid)
				{
					text2 += $" and also banned ownerid {basePlayer.net.connection.ownerid}";
					ServerUsers.Set(basePlayer.net.connection.ownerid, ServerUsers.UserGroup.Banned, basePlayer.displayName, arg.GetString(1, $"Family share owner of {basePlayer.net.connection.userid}"), expiry);
				}
				Chat.Broadcast("Kickbanning " + basePlayer.displayName + durationSuffix + " (" + @string + ")", "SERVER", "#eee", 0uL);
				Net.sv.Kick(basePlayer.net.connection, "Banned" + durationSuffix + ": " + @string, false);
			}
			ServerUsers.Set(uInt, ServerUsers.UserGroup.Banned, text, @string, expiry);
			arg.ReplyWith($"Banned User{durationSuffix}: {uInt} - \"{text}\" for \"{@string}\"{text2}");
		}
	}

	private static bool TryGetBanExpiry(Arg arg, int n, out long expiry, out string durationSuffix)
	{
		expiry = arg.GetTimestamp(n, -1L);
		durationSuffix = null;
		int current = Epoch.Current;
		if (expiry > 0 && expiry <= current)
		{
			arg.ReplyWith("Expiry time is in the past");
			return false;
		}
		durationSuffix = ((expiry > 0) ? (" for " + NumberExtensions.FormatSecondsLong(expiry - current)) : "");
		return true;
	}

	[ServerVar]
	public static void unban(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith($"This doesn't appear to be a 64bit steamid: {uInt}");
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user == null || user.group != ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {uInt} isn't banned");
			return;
		}
		ServerUsers.Remove(uInt);
		arg.ReplyWith("Unbanned User: " + uInt);
	}

	[ServerVar]
	public static void skipqueue(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
		}
		else
		{
			SingletonComponent<ServerMgr>.Instance.connectionQueue.SkipQueue(uInt);
		}
	}

	[ServerVar(Help = "Adds skip queue permissions to a SteamID")]
	public static void skipqueueid(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		string @string = arg.GetString(1, "unnamed");
		string string2 = arg.GetString(2, "no reason");
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && (user.group == ServerUsers.UserGroup.Owner || user.group == ServerUsers.UserGroup.Moderator || user.group == ServerUsers.UserGroup.SkipQueue))
		{
			arg.ReplyWith($"User {uInt} will already skip the queue ({user.group})");
			return;
		}
		if (user != null && user.group == ServerUsers.UserGroup.Banned)
		{
			arg.ReplyWith($"User {uInt} is banned");
			return;
		}
		ServerUsers.Set(uInt, ServerUsers.UserGroup.SkipQueue, @string, string2, -1L);
		arg.ReplyWith($"Added skip queue permission for {@string} ({uInt})");
	}

	[ServerVar(Help = "Removes skip queue permission from a SteamID")]
	public static void removeskipqueue(Arg arg)
	{
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt < 70000000000000000L)
		{
			arg.ReplyWith("This doesn't appear to be a 64bit steamid: " + uInt);
			return;
		}
		ServerUsers.User user = ServerUsers.Get(uInt);
		if (user != null && (user.group == ServerUsers.UserGroup.Owner || user.group == ServerUsers.UserGroup.Moderator))
		{
			arg.ReplyWith($"User is a {user.group}, cannot remove skip queue permission with this command");
			return;
		}
		if (user == null || user.group != ServerUsers.UserGroup.SkipQueue)
		{
			arg.ReplyWith("User does not have skip queue permission");
			return;
		}
		ServerUsers.Remove(uInt);
		arg.ReplyWith("Removed skip queue permission: " + uInt);
	}

	[ServerVar(Help = "Print out currently connected clients etc")]
	public static void players(Arg arg)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.ResizeColumns(5);
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("ping");
			val.AddColumn("updt");
			val.AddColumn("dist");
			val.AddColumn("enId");
			val.ResizeRows(BasePlayer.activePlayerList.Count);
			Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BasePlayer current = enumerator.Current;
					string userIDString = current.UserIDString;
					val.AddValue(userIDString);
					string text = current.displayName;
					if (text.Length >= 14)
					{
						text = text.Substring(0, 14) + "..";
					}
					val.AddValue(text);
					int averagePing = Net.sv.GetAveragePing(current.net.connection);
					val.AddValue(averagePing);
					int queuedUpdateCount = current.GetQueuedUpdateCount(BasePlayer.NetworkQueue.Update);
					val.AddValue(queuedUpdateCount);
					int queuedUpdateCount2 = current.GetQueuedUpdateCount(BasePlayer.NetworkQueue.UpdateDistance);
					val.AddValue(queuedUpdateCount2);
					ulong value = current.net.ID.Value;
					val.AddValue(value);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			arg.ReplyWith(flag ? val.ToJson(false) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Sends a message in chat")]
	public static void say(Arg arg)
	{
		Chat.Broadcast(arg.FullString, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "Show user info for players on server.")]
	public static void users(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				text = text + current.userID.Get() + ":\"" + current.displayName + "\"\n";
				num++;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		text = text + num + "users\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server.")]
	public static void sleepingusers(Arg arg)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				text += $"{current.userID.Get()}:{current.displayName}\n";
				num++;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		text += $"{num} sleeping users\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for sleeping players on server in range of the player.")]
	public static void sleepingusersinrange(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer fromPlayer = arg.Player();
		if ((Object)(object)fromPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(0, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)fromPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)fromPlayer) < basePlayer.Distance2D((BaseEntity)fromPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)fromPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} sleeping users within {range}m\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server in range of the player.")]
	public static void usersinrange(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer fromPlayer = arg.Player();
		if ((Object)(object)fromPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(0, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)fromPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)fromPlayer) < basePlayer.Distance2D((BaseEntity)fromPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)fromPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} users within {range}m\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "Show user info for players on server in range of the supplied player (eg. Jim 50)")]
	public static void usersinrangeofplayer(Arg arg)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer targetPlayer = arg.GetPlayerOrSleeper(0);
		if ((Object)(object)targetPlayer == (Object)null)
		{
			return;
		}
		float range = arg.GetFloat(1, 0f);
		string text = "<slot:userid:\"name\">\n";
		int num = 0;
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		list.RemoveAll((BasePlayer p) => p.Distance2D((BaseEntity)targetPlayer) > range);
		list.Sort((BasePlayer player, BasePlayer basePlayer) => (!(player.Distance2D((BaseEntity)targetPlayer) < basePlayer.Distance2D((BaseEntity)targetPlayer))) ? 1 : (-1));
		foreach (BasePlayer item in list)
		{
			text += $"{item.userID.Get()}:{item.displayName}:{item.Distance2D((BaseEntity)targetPlayer)}m\n";
			num++;
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
		text += $"{num} users within {range}m of {targetPlayer.displayName}\n";
		arg.ReplyWith(text);
	}

	[ServerVar(Help = "List of banned users (sourceds compat)")]
	public static void banlist(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListString());
	}

	[ServerVar(Help = "List of banned users - shows reasons and usernames")]
	public static void banlistex(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListStringEx());
	}

	[ServerVar(Help = "List of banned users, by ID (sourceds compat)")]
	public static void listid(Arg arg)
	{
		arg.ReplyWith(ServerUsers.BanListString(bHeader: true));
	}

	[ServerVar]
	public static void mute(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		long timestamp = arg.GetTimestamp(1, 0L);
		if (timestamp > 0)
		{
			playerOrSleeper.State.chatMuteExpiryTimestamp = timestamp;
			string text = NumberExtensions.FormatSecondsLong(timestamp - DateTimeOffset.UtcNow.ToUnixTimeSeconds());
			playerOrSleeper.ChatMessage("You have been muted for " + text);
		}
		else
		{
			playerOrSleeper.ChatMessage("You have been permanently muted");
		}
		playerOrSleeper.State.chatMuted = true;
		playerOrSleeper.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, b: true);
	}

	[ServerVar]
	public static void unmute(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			arg.ReplyWith("Player not found");
			return;
		}
		playerOrSleeper.State.chatMuted = false;
		playerOrSleeper.State.chatMuteExpiryTimestamp = 0.0;
		playerOrSleeper.SetPlayerFlag(BasePlayer.PlayerFlags.ChatMute, b: false);
		playerOrSleeper.ChatMessage("You have been unmuted");
	}

	[ServerVar(Help = "Print a list of currently muted players")]
	public static void mutelist(Arg arg)
	{
		var enumerable = from x in BasePlayer.allPlayerList
			where x.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute)
			select new
			{
				SteamId = x.UserIDString,
				Name = x.displayName
			};
		arg.ReplyWith((object)enumerable);
	}

	[ServerVar]
	public static void clientperf(Arg arg)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "legacy");
		int @int = arg.GetInt(1, Random.Range(int.MinValue, int.MaxValue));
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				current.ClientRPC(RpcTarget.Player("GetPerformanceReport", current), @string, @int);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Get information about all the cars in the world")]
	public static void carstats(Arg arg)
	{
		HashSet<ModularCar> allCarsList = ModularCar.allCarsList;
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("id");
			val.AddColumn("sockets");
			val.AddColumn("modules");
			val.AddColumn("complete");
			val.AddColumn("engine");
			val.AddColumn("health");
			val.AddColumn("location");
			int count = allCarsList.Count;
			int num = 0;
			int num2 = 0;
			int num3 = 0;
			foreach (ModularCar item in allCarsList)
			{
				string text = ((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString();
				string text2 = item.TotalSockets.ToString();
				string text3 = item.NumAttachedModules.ToString();
				string text4;
				if (item.IsComplete())
				{
					text4 = "Complete";
					num++;
				}
				else
				{
					text4 = "Partial";
				}
				string text5;
				if (item.HasAnyWorkingEngines())
				{
					text5 = "Working";
					num2++;
				}
				else
				{
					text5 = "Broken";
				}
				string text6 = ((item.TotalMaxHealth() != 0f) ? $"{item.TotalHealth() / item.TotalMaxHealth():0%}" : "0");
				string text7;
				if (item.IsOutside())
				{
					text7 = "Outside";
				}
				else
				{
					text7 = "Inside";
					num3++;
				}
				val.AddRow(new string[7] { text, text2, text3, text4, text5, text6, text7 });
			}
			string text8 = "";
			text8 = ((count != 1) ? (text8 + $"\nThe world contains {count} modular cars.") : (text8 + "\nThe world contains 1 modular car."));
			text8 = ((num != 1) ? (text8 + $"\n{num} ({(float)num / (float)count:0%}) are in a completed state.") : (text8 + $"\n1 ({1f / (float)count:0%}) is in a completed state."));
			text8 = ((num2 != 1) ? (text8 + $"\n{num2} ({(float)num2 / (float)count:0%}) are driveable.") : (text8 + $"\n1 ({1f / (float)count:0%}) is driveable."));
			arg.ReplyWith(string.Concat(str1: (num3 != 1) ? (text8 + $"\n{num3} ({(float)num3 / (float)count:0%}) are sheltered indoors.") : (text8 + $"\n1 ({1f / (float)count:0%}) is sheltered indoors."), str0: ((object)val).ToString()));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static string teaminfo(Arg arg)
	{
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			return "Player not found";
		}
		RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(num);
		if (playerTeam == null)
		{
			return "Player is not in a team";
		}
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.ResizeColumns(4);
			val.AddColumn("steamID");
			val.AddColumn("username");
			val.AddColumn("online");
			val.AddColumn("leader");
			val.ResizeRows(playerTeam.members.Count);
			foreach (ulong memberId in playerTeam.members)
			{
				bool flag2 = ((IEnumerable<Connection>)Net.sv.connections).FirstOrDefault((Func<Connection, bool>)((Connection c) => c.connected && c.userid == memberId)) != null;
				val.AddValue(memberId);
				val.AddValue(GetPlayerName(memberId));
				val.AddValue(flag2 ? "x" : "");
				val.AddValue((memberId == playerTeam.teamLeader) ? "x" : "");
			}
			return flag ? val.ToJson(true) : $"ID: {playerTeam.teamID}\n\n{val}";
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void authradius(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'authradius {radius} [user]'");
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		list.Add(arg.GetPlayer(1) ?? arg.Player());
		SetAuthInRadius(list[0], list, @float, auth: true);
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void authradius_multi(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'authradius {radius} [user, user, ...]'");
		}
		else
		{
			SetAuthInRadius(arg.Player(), arg.GetPlayerArgs(1), @float, auth: true);
		}
	}

	[ServerVar]
	public static void authradius_radius(Arg arg)
	{
		run_authradius_radius(arg, authFlag: true);
	}

	[ServerVar]
	public static void deauthradius_radius(Arg arg)
	{
		run_authradius_radius(arg, authFlag: false);
	}

	private static void run_authradius_radius(Arg arg, bool authFlag)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, -1f);
		float float2 = arg.GetFloat(1, -1f);
		if (@float < 0f || float2 < 0f)
		{
			arg.ReplyWith("Format is 'authradius_radius {playerRadius, authRadius }'");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		for (int num = list.Count - 1; num >= 0; num--)
		{
			BasePlayer basePlayer2 = list[num];
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				list.RemoveAt(num);
			}
			else if (basePlayer2.isClient || Vector3.Distance(((Component)basePlayer2).transform.position, ((Component)basePlayer).transform.position) > @float)
			{
				list.Remove(basePlayer2);
			}
		}
		SetAuthInRadius(basePlayer, list, float2, authFlag);
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void deauthradius(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'deauthradius {radius} [user]'");
			return;
		}
		List<BasePlayer> list = new List<BasePlayer>();
		list.Add(arg.GetPlayer(1) ?? arg.Player());
		SetAuthInRadius(list[0], list, @float, auth: false);
	}

	[ServerVar]
	public static void deauthradius_multi(Arg arg)
	{
		float @float = arg.GetFloat(0, -1f);
		if (@float < 0f)
		{
			arg.ReplyWith("Format is 'deauthradius {radius} [user, user, ...]'");
		}
		else
		{
			SetAuthInRadius(arg.Player(), arg.GetPlayerArgs(1), @float, auth: false);
		}
	}

	private static void SetAuthInRadius(BasePlayer radiusTargetPlayer, List<BasePlayer> players, float radius, bool auth)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (players == null)
		{
			return;
		}
		if (players.Count == 0)
		{
			players.Add(radiusTargetPlayer);
		}
		List<BaseEntity> list = new List<BaseEntity>();
		Vis.Entities(((Component)radiusTargetPlayer).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BaseEntity item in list)
		{
			if (!item.isServer)
			{
				continue;
			}
			bool flag = true;
			foreach (BasePlayer player in players)
			{
				bool flag2 = SetUserAuthorized(item, player.userID, auth);
				if (!flag2)
				{
					flag2 = SetUserAuthorized(item.GetSlot(BaseEntity.Slot.Lock), player.userID, auth);
				}
				if (flag)
				{
					num += (flag2 ? 1 : 0);
					flag = false;
				}
			}
		}
		Debug.Log((object)("Set auth: " + auth + " on " + players.Count + " players, for " + num + " entities."));
	}

	private static bool SetUserAuthorized(BaseEntity entity, ulong userId, bool state)
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Expected O, but got Unknown
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Expected O, but got Unknown
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Expected O, but got Unknown
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (entity is CodeLock codeLock)
		{
			if (state)
			{
				codeLock.whitelistPlayers.Add(userId);
			}
			else
			{
				codeLock.whitelistPlayers.Remove(userId);
				codeLock.guestPlayers.Remove(userId);
			}
			codeLock.SendNetworkUpdate();
		}
		else if (entity is AutoTurret autoTurret)
		{
			if (state)
			{
				autoTurret.authorizedPlayers.Add(new PlayerNameID
				{
					ShouldPool = false,
					userid = userId,
					username = ""
				});
			}
			else
			{
				autoTurret.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == userId);
			}
			autoTurret.SendNetworkUpdate();
		}
		else if (entity is BuildingPrivlidge buildingPrivlidge)
		{
			if (state)
			{
				buildingPrivlidge.authorizedPlayers.Add(new PlayerNameID
				{
					ShouldPool = false,
					userid = userId,
					username = ""
				});
			}
			else
			{
				buildingPrivlidge.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == userId);
			}
			if (entity.GetSlot(BaseEntity.Slot.Lock).IsValid())
			{
				SetUserAuthorized(entity.GetSlot(BaseEntity.Slot.Lock), userId, state);
			}
			buildingPrivlidge.SendNetworkUpdate();
		}
		else if (entity is Tugboat tugboat)
		{
			VehiclePrivilege componentInChildren = ((Component)tugboat).GetComponentInChildren<VehiclePrivilege>();
			if ((Object)(object)componentInChildren != (Object)null)
			{
				if (state)
				{
					componentInChildren.authorizedPlayers.Add(new PlayerNameID
					{
						ShouldPool = false,
						userid = userId,
						username = ""
					});
				}
				else
				{
					componentInChildren.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == userId);
				}
				componentInChildren.SendNetworkUpdate();
			}
		}
		else
		{
			if (!(entity is ModularCar modularCar))
			{
				return false;
			}
			if (state)
			{
				modularCar.CarLock.TryAddPlayer(userId);
			}
			else
			{
				modularCar.CarLock.TryRemovePlayer(userId);
			}
			modularCar.SendNetworkUpdate();
		}
		return true;
	}

	[ServerVar]
	public static void entid(Arg arg)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(arg.GetEntityID(1)) as BaseEntity;
		if ((Object)(object)baseEntity == (Object)null || baseEntity is BasePlayer)
		{
			return;
		}
		string @string = arg.GetString(0, "");
		if ((Object)(object)arg.Player() != (Object)null)
		{
			Debug.Log((object)("[ENTCMD] " + arg.Player().displayName + "/" + arg.Player().userID.Get() + " used *" + @string + "* on ent: " + ((Object)baseEntity).name));
		}
		switch (@string)
		{
		case "kill":
			baseEntity.AdminKill();
			return;
		case "lock":
			baseEntity.SetFlag(BaseEntity.Flags.Locked, b: true);
			return;
		case "unlock":
			baseEntity.SetFlag(BaseEntity.Flags.Locked, b: false);
			return;
		case "debug":
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, b: true);
			return;
		case "undebug":
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, b: false);
			return;
		case "who":
			arg.ReplyWith(baseEntity.Admin_Who());
			return;
		case "auth":
			arg.ReplyWith(AuthList(baseEntity));
			return;
		case "upgrade":
			arg.ReplyWith(ChangeGrade(baseEntity, arg.GetInt(2, 1), 0, BuildingGrade.Enum.None, 0uL, arg.GetFloat(3, 0f)));
			return;
		case "downgrade":
			arg.ReplyWith(ChangeGrade(baseEntity, 0, arg.GetInt(2, 1), BuildingGrade.Enum.None, 0uL, arg.GetFloat(3, 0f)));
			return;
		case "setgrade":
		{
			string error;
			BuildingGrade buildingGrade = FindBuildingSkin(arg.GetString(2, ""), out error);
			arg.ReplyWith(ChangeGrade(baseEntity, 0, 0, buildingGrade.type, buildingGrade.skin, arg.GetFloat(3, 0f)));
			return;
		}
		case "repair":
			RunInRadius(arg.GetFloat(2, 0f), baseEntity, delegate(BaseCombatEntity entity)
			{
				if (entity.repair.enabled)
				{
					entity.SetHealth(entity.MaxHealth());
				}
			});
			break;
		}
		arg.ReplyWith("Unknown command");
	}

	private static string AuthList(BaseEntity ent)
	{
		List<PlayerNameID> list;
		if (!(ent is BuildingPrivlidge buildingPrivlidge))
		{
			if (!(ent is AutoTurret autoTurret))
			{
				if (ent is CodeLock codeLock)
				{
					return CodeLockAuthList(codeLock);
				}
				if (ent is BaseVehicleModule vehicleModule)
				{
					return CodeLockAuthList(vehicleModule);
				}
				if (!(ent is Tugboat tugboat))
				{
					return "Entity has no auth list";
				}
				list = new List<PlayerNameID>();
				VehiclePrivilege componentInChildren = ((Component)tugboat).GetComponentInChildren<VehiclePrivilege>();
				if ((Object)(object)componentInChildren != (Object)null)
				{
					foreach (PlayerNameID authorizedPlayer in componentInChildren.authorizedPlayers)
					{
						list.Add(authorizedPlayer);
					}
				}
			}
			else
			{
				list = new List<PlayerNameID>();
				foreach (PlayerNameID authorizedPlayer2 in autoTurret.authorizedPlayers)
				{
					list.Add(authorizedPlayer2);
				}
			}
		}
		else
		{
			list = new List<PlayerNameID>();
			foreach (PlayerNameID authorizedPlayer3 in buildingPrivlidge.authorizedPlayers)
			{
				list.Add(authorizedPlayer3);
			}
		}
		if (list == null || list.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("steamID");
			val.AddColumn("username");
			foreach (PlayerNameID item in list)
			{
				val.AddRow(new string[2]
				{
					item.userid.ToString(),
					GetPlayerName(item.userid)
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static string CodeLockAuthList(CodeLock codeLock)
	{
		if (codeLock.whitelistPlayers.Count == 0 && codeLock.guestPlayers.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("steamID");
			val.AddColumn("username");
			val.AddColumn("isGuest");
			foreach (ulong whitelistPlayer in codeLock.whitelistPlayers)
			{
				val.AddRow(new string[3]
				{
					whitelistPlayer.ToString(),
					GetPlayerName(whitelistPlayer),
					""
				});
			}
			foreach (ulong guestPlayer in codeLock.guestPlayers)
			{
				val.AddRow(new string[3]
				{
					guestPlayer.ToString(),
					GetPlayerName(guestPlayer),
					"x"
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static string CodeLockAuthList(BaseVehicleModule vehicleModule)
	{
		if (!vehicleModule.IsOnAVehicle)
		{
			return "Nobody is authed to this entity";
		}
		ModularCar modularCar = vehicleModule.Vehicle as ModularCar;
		if ((Object)(object)modularCar == (Object)null || !modularCar.IsLockable || modularCar.CarLock.WhitelistPlayers.Count == 0)
		{
			return "Nobody is authed to this entity";
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("steamID");
			val.AddColumn("username");
			foreach (ulong whitelistPlayer in modularCar.CarLock.WhitelistPlayers)
			{
				val.AddRow(new string[2]
				{
					whitelistPlayer.ToString(),
					GetPlayerName(whitelistPlayer)
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static string GetPlayerName(ulong steamId)
	{
		BasePlayer basePlayer = BasePlayer.allPlayerList.FirstOrDefault((BasePlayer p) => (ulong)p.userID == steamId);
		string text;
		if (!((Object)(object)basePlayer != (Object)null))
		{
			text = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(steamId);
			if (text == null)
			{
				return "[unknown]";
			}
		}
		else
		{
			text = basePlayer.displayName;
		}
		return text;
	}

	public static string ChangeGrade(BaseEntity entity, int increaseBy = 0, int decreaseBy = 0, BuildingGrade.Enum targetGrade = BuildingGrade.Enum.None, ulong skin = 0uL, float radius = 0f)
	{
		if ((Object)(object)(entity as BuildingBlock) == (Object)null)
		{
			return $"'{entity}' is not a building block";
		}
		RunInRadius(radius, entity, delegate(BuildingBlock block)
		{
			BuildingGrade.Enum grade = block.grade;
			if (targetGrade > BuildingGrade.Enum.None && targetGrade < BuildingGrade.Enum.Count)
			{
				grade = targetGrade;
			}
			else
			{
				grade = (BuildingGrade.Enum)Mathf.Min((int)(grade + increaseBy), 4);
				grade = (BuildingGrade.Enum)Mathf.Max((int)(grade - decreaseBy), 0);
			}
			if (grade != block.grade)
			{
				block.ChangeGradeAndSkin(targetGrade, skin);
			}
		});
		int count = Pool.Get<List<BuildingBlock>>().Count;
		return $"Upgraded/downgraded '{count}' building block(s)";
	}

	private static bool RunInRadius<T>(float radius, BaseEntity initial, Action<T> callback, Func<T, bool> filter = null, int layerMask = 2097152) where T : BaseEntity
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		List<T> list = Pool.Get<List<T>>();
		radius = Mathf.Clamp(radius, 0f, 200f);
		if (radius > 0f)
		{
			Vis.Entities(((Component)initial).transform.position, radius, list, layerMask, (QueryTriggerInteraction)2);
		}
		else if (initial is T item)
		{
			list.Add(item);
		}
		foreach (T item2 in list)
		{
			try
			{
				callback(item2);
			}
			catch (Exception arg)
			{
				Debug.LogError((object)$"Exception while running callback in radius: {arg}");
				Pool.FreeUnmanaged<T>(ref list);
				return false;
			}
		}
		Pool.FreeUnmanaged<T>(ref list);
		return true;
	}

	[ServerVar(Help = "Get a list of players")]
	public static PlayerInfo[] playerlist()
	{
		return ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Select(delegate(BasePlayer x)
		{
			PlayerInfo result = default(PlayerInfo);
			result.SteamID = x.UserIDString;
			result.OwnerSteamID = x.OwnerID.ToString();
			result.DisplayName = x.displayName;
			result.Ping = Net.sv.GetAveragePing(x.net.connection);
			result.Address = x.net.connection.ipaddress;
			result.EntityId = x.net.ID.Value;
			result.ConnectedSeconds = (int)x.net.connection.GetSecondsConnected();
			result.ViolationLevel = x.violationLevel;
			result.Health = x.Health();
			return result;
		}).ToArray();
	}

	[ServerVar(Help = "Get a list of player's IDs")]
	public static PlayerIDInfo[] playerlistids()
	{
		return ((IEnumerable<BasePlayer>)BasePlayer.activePlayerList).Select(delegate(BasePlayer x)
		{
			PlayerIDInfo result = default(PlayerIDInfo);
			result.SteamID = x.UserIDString;
			result.OwnerSteamID = x.OwnerID.ToString();
			result.DisplayName = x.displayName;
			result.Address = x.net.connection.ipaddress;
			result.EntityId = x.net.ID.Value;
			return result;
		}).ToArray();
	}

	[ServerVar(Help = "List of banned users")]
	public static ServerUsers.User[] Bans()
	{
		return ServerUsers.GetAll(ServerUsers.UserGroup.Banned).ToArray();
	}

	[ServerVar(Help = "Get a list of information about the server")]
	public static ServerInfoOutput ServerInfo()
	{
		ServerInfoOutput result = default(ServerInfoOutput);
		result.Hostname = ConVar.Server.hostname;
		result.MaxPlayers = ConVar.Server.maxplayers;
		result.Players = BasePlayer.activePlayerList.Count;
		result.Queued = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		result.Joining = SingletonComponent<ServerMgr>.Instance.connectionQueue.Joining;
		result.ReservedSlots = SingletonComponent<ServerMgr>.Instance.connectionQueue.ReservedCount;
		result.EntityCount = BaseNetworkable.serverEntities.Count;
		result.GameTime = (((Object)(object)TOD_Sky.Instance != (Object)null) ? TOD_Sky.Instance.Cycle.DateTime.ToString() : DateTime.UtcNow.ToString());
		result.Uptime = (int)Time.realtimeSinceStartup;
		result.Map = ConVar.Server.level;
		result.Framerate = Performance.report.frameRate;
		result.Memory = (int)Performance.report.memoryAllocations;
		result.MemoryUsageSystem = (int)Performance.report.memoryUsageSystem;
		result.Collections = (int)Performance.report.memoryCollections;
		result.NetworkIn = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)3) : 0);
		result.NetworkOut = (int)((Net.sv != null) ? ((BaseNetwork)Net.sv).GetStat((Connection)null, (StatTypeLong)1) : 0);
		result.Restarting = SingletonComponent<ServerMgr>.Instance.Restarting;
		result.SaveCreatedTime = SaveRestore.SaveCreatedTime.ToString();
		result.Version = 2597;
		result.Protocol = Protocol.printable;
		return result;
	}

	[ServerVar(Help = "Get information about this build")]
	public static BuildInfo BuildInfo()
	{
		return BuildInfo.Current;
	}

	[ServerVar]
	public static void AdminUI_FullRefresh(Arg arg)
	{
		AdminUI_RequestPlayerList(arg);
		AdminUI_RequestServerInfo(arg);
		AdminUI_RequestServerConvars(arg);
		AdminUI_RequestUGCList(arg);
	}

	[ServerVar]
	public static void AdminUI_RequestPlayerList(Arg arg)
	{
		if (allowAdminUI)
		{
			ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceivePlayerList", JsonConvert.SerializeObject((object)playerlist()));
		}
	}

	[ServerVar]
	public static void AdminUI_RequestServerInfo(Arg arg)
	{
		if (allowAdminUI)
		{
			ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveServerInfo", JsonConvert.SerializeObject((object)ServerInfo()));
		}
	}

	[ServerVar]
	public static void AdminUI_RequestServerConvars(Arg arg)
	{
		if (!allowAdminUI)
		{
			return;
		}
		List<ServerConvarInfo> list = Pool.Get<List<ServerConvarInfo>>();
		Command[] all = Index.All;
		foreach (Command val in all)
		{
			if (val.Server && val.Variable && val.ServerAdmin && val.ShowInAdminUI)
			{
				list.Add(new ServerConvarInfo
				{
					FullName = val.FullName,
					Value = val.GetOveride?.Invoke(),
					Help = val.Description
				});
			}
		}
		ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveCommands", JsonConvert.SerializeObject((object)list));
		Pool.FreeUnmanaged<ServerConvarInfo>(ref list);
	}

	[ServerVar]
	public static void AdminUI_RequestUGCList(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (!allowAdminUI)
		{
			return;
		}
		List<ServerUGCInfo> list = Pool.Get<List<ServerUGCInfo>>();
		uint[] array = null;
		ulong[] array2 = null;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current.IsUnityNull())
				{
					continue;
				}
				array = null;
				array2 = null;
				UGCType uGCType = UGCType.ImageJpg;
				string text = string.Empty;
				if (((Component)current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
				{
					if ((Object)(object)iUGCBrowserEntity.UgcEntity == (Object)null)
					{
						continue;
					}
					array = iUGCBrowserEntity.GetContentCRCs;
					array2 = iUGCBrowserEntity.EditingHistory.ToArray();
					uGCType = iUGCBrowserEntity.ContentType;
					text = iUGCBrowserEntity.ContentString;
				}
				bool flag = false;
				if (array != null)
				{
					uint[] array3 = array;
					for (int i = 0; i < array3.Length; i++)
					{
						if (array3[i] != 0)
						{
							flag = true;
							break;
						}
					}
				}
				if (uGCType == UGCType.PatternBoomer)
				{
					flag = true;
					PatternFirework patternFirework = iUGCBrowserEntity as PatternFirework;
					if ((Object)(object)patternFirework != (Object)null && patternFirework.Design == null)
					{
						flag = false;
					}
				}
				if (uGCType == UGCType.VendingMachine && !string.IsNullOrEmpty(text))
				{
					flag = true;
				}
				if (flag)
				{
					list.Add(new ServerUGCInfo
					{
						entityId = current.net.ID.Value,
						crcs = array,
						contentType = uGCType,
						entityPrefabID = current.prefabID,
						shortPrefabName = current.ShortPrefabName,
						playerIds = array2,
						contentString = text
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ConsoleNetwork.SendClientCommand(arg.Connection, "AdminUI_ReceiveUGCList", JsonConvert.SerializeObject((object)list));
		Pool.FreeUnmanaged<ServerUGCInfo>(ref list);
	}

	[ServerVar]
	public static void AdminUI_RequestUGCContent(Arg arg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (allowAdminUI && !((Object)(object)arg.Player() == (Object)null))
		{
			uint uInt = arg.GetUInt(0, 0u);
			NetworkableId entityID = arg.GetEntityID(1);
			FileStorage.Type @int = (FileStorage.Type)arg.GetInt(2, 0);
			uint uInt2 = arg.GetUInt(3, 0u);
			byte[] array = FileStorage.server.Get(uInt, @int, entityID, uInt2);
			if (array != null)
			{
				SendInfo val = default(SendInfo);
				((SendInfo)(ref val))..ctor(arg.Connection);
				val.channel = 2;
				val.method = (SendMethod)0;
				SendInfo sendInfo = val;
				arg.Player().ClientRPC(RpcTarget.SendInfo("AdminReceivedUGC", sendInfo), uInt, (uint)array.Length, array, uInt2, (byte)@int);
			}
		}
	}

	[ServerVar]
	public static void AdminUI_DeleteUGCContent(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (!allowAdminUI)
		{
			return;
		}
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			FileStorage.server.RemoveAllByEntity(entityID);
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			if (((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
			{
				iUGCBrowserEntity.ClearContent();
			}
		}
	}

	[ServerVar]
	public static void AdminUI_RequestFireworkPattern(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (allowAdminUI)
		{
			NetworkableId entityID = arg.GetEntityID(0);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
			if ((Object)(object)baseNetworkable != (Object)null && baseNetworkable is PatternFirework { Design: not null } patternFirework)
			{
				SendInfo val = default(SendInfo);
				((SendInfo)(ref val))..ctor(arg.Connection);
				val.channel = 2;
				val.method = (SendMethod)0;
				SendInfo sendInfo = val;
				arg.Player().ClientRPC(RpcTarget.SendInfo("AdminReceivedPatternFirework", sendInfo), entityID, ProtoStreamExtensions.ToProtoBytes((IProto)(object)patternFirework.Design));
			}
		}
	}

	[ServerVar]
	public static void clearugcentity(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
		if ((Object)(object)baseNetworkable != (Object)null && ((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity))
		{
			iUGCBrowserEntity.ClearContent();
			arg.ReplyWith($"Cleared content on {baseNetworkable.ShortPrefabName}/{entityID}");
		}
		else
		{
			arg.ReplyWith($"Could not find UGC entity with id {entityID}");
		}
	}

	[ServerVar]
	public static void clearugcentitiesinrange(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		float @float = arg.GetFloat(1, 0f);
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (((Component)current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && Vector3.Distance(((Component)current).transform.position, vector) <= @float)
				{
					iUGCBrowserEntity.ClearContent();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num} UGC entities within {@float}m of {vector}");
	}

	[ServerVar]
	public static void clearVendingMachineNamesContaining(Arg arg)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				if (((Component)enumerator.Current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && iUGCBrowserEntity.ContentType == UGCType.VendingMachine && StringEx.Contains(iUGCBrowserEntity.ContentString, @string, CompareOptions.IgnoreCase | CompareOptions.IgnoreSymbols))
				{
					iUGCBrowserEntity.ClearContent();
					num++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num} vending machines containing {@string}");
	}

	[ServerVar]
	public static void clearUGCByPlayer(Arg arg)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong num = (((Object)(object)playerOrSleeper == (Object)null) ? arg.GetULong(0, 0uL) : playerOrSleeper.userID.Get());
		int num2 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
			while (enumerator.MoveNext())
			{
				if (((Component)enumerator.Current).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && iUGCBrowserEntity.EditingHistory.Contains(num))
				{
					iUGCBrowserEntity.ClearContent();
					num2++;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Cleared {num2} UGC entities modified by {(((Object)(object)playerOrSleeper != (Object)null) ? playerOrSleeper.displayName : ((object)num))}");
	}

	[ServerVar]
	public static void getugcinfo(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = arg.GetEntityID(0);
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
		IUGCBrowserEntity iUGCBrowserEntity = default(IUGCBrowserEntity);
		if ((Object)(object)baseNetworkable != (Object)null && ((Component)baseNetworkable).TryGetComponent<IUGCBrowserEntity>(ref iUGCBrowserEntity) && (Object)(object)iUGCBrowserEntity.UgcEntity != (Object)null)
		{
			ServerUGCInfo serverUGCInfo = new ServerUGCInfo(iUGCBrowserEntity);
			arg.ReplyWith(JsonConvert.SerializeObject((object)serverUGCInfo));
		}
		else
		{
			arg.ReplyWith($"Invalid entity id: {entityID}");
		}
	}

	[ServerVar(Help = "Returns all entities that the provided player is authed to (TC's, locks, etc), supports --json")]
	public static void authcount(Arg arg)
	{
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		ulong num = arg.GetPlayerOrSleeper(0)?.userID ?? ((EncryptedValue<ulong>)0uL);
		if (num == 0L)
		{
			num = arg.GetULong(0, 0uL);
		}
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(num))
		{
			arg.ReplyWith("Please provide a valid player, unable to find '" + arg.GetString(0, "") + "'");
			return;
		}
		string playerName = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(num);
		string text = arg.GetString(1, "");
		if (text == "--json")
		{
			text = string.Empty;
		}
		List<EntityAssociation> list = Pool.Get<List<EntityAssociation>>();
		FindEntityAssociationsForPlayer(num, useOwnerId: false, useAuth: true, text, list);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[4] { "Prefab name", "Position", "ID", "Type" });
			foreach (EntityAssociation item in list)
			{
				string[] obj = new string[4]
				{
					item.TargetEntity.ShortPrefabName,
					null,
					null,
					null
				};
				Vector3 position = ((Component)item.TargetEntity).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = ((object)(NetworkableId)(ref item.TargetEntity.net.ID)/*cast due to .constrained prefix*/).ToString();
				obj[3] = item.AssociationType.ToString();
				val.AddRow(obj);
			}
			Pool.FreeUnmanaged<EntityAssociation>(ref list);
			if (flag)
			{
				arg.ReplyWith(val.ToJson(true));
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Found entities " + playerName + " is authed to");
			stringBuilder.AppendLine(((object)val).ToString());
			arg.ReplyWith(stringBuilder.ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Returns all entities that the provided player has placed, supports --json")]
	public static void entcount(Arg arg)
	{
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		ulong uLong = arg.GetULong(0, 0uL);
		if (!SingletonComponent<ServerMgr>.Instance.persistance.DoesPlayerExist(uLong))
		{
			arg.ReplyWith($"Please provide a valid player, unable to find '{uLong}'");
			return;
		}
		string playerName = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(uLong);
		string text = arg.GetString(1, "");
		if (text == "--json")
		{
			text = string.Empty;
		}
		List<EntityAssociation> list = Pool.Get<List<EntityAssociation>>();
		FindEntityAssociationsForPlayer(uLong, useOwnerId: true, useAuth: false, text, list);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[3] { "Prefab name", "Position", "ID" });
			foreach (EntityAssociation item in list)
			{
				string[] obj = new string[3]
				{
					item.TargetEntity.ShortPrefabName,
					null,
					null
				};
				Vector3 position = ((Component)item.TargetEntity).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = ((object)(NetworkableId)(ref item.TargetEntity.net.ID)/*cast due to .constrained prefix*/).ToString();
				val.AddRow(obj);
			}
			Pool.FreeUnmanaged<EntityAssociation>(ref list);
			if (flag)
			{
				arg.ReplyWith(val.ToJson(true));
				return;
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine("Found entities associated with " + playerName);
			stringBuilder.AppendLine(((object)val).ToString());
			arg.ReplyWith(stringBuilder.ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static void FindEntityAssociationsForPlayer(ulong steamId, bool useOwnerId, bool useAuth, string filter, List<EntityAssociation> results)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		results.Clear();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				EntityAssociationType entityAssociationType = EntityAssociationType.Owner;
				if (!(current is BaseEntity baseEntity))
				{
					continue;
				}
				bool flag = false;
				if (useOwnerId && baseEntity.OwnerID == steamId)
				{
					flag = true;
				}
				if (useAuth && !flag)
				{
					if (!flag && baseEntity is BuildingPrivlidge buildingPrivlidge && buildingPrivlidge.IsAuthed(steamId))
					{
						flag = true;
					}
					if (!flag && baseEntity is KeyLock keyLock && keyLock.OwnerID == steamId)
					{
						flag = true;
					}
					else if (baseEntity is CodeLock codeLock)
					{
						if (codeLock.whitelistPlayers.Contains(steamId))
						{
							flag = true;
						}
						else if (codeLock.guestPlayers.Contains(steamId))
						{
							flag = true;
							entityAssociationType = EntityAssociationType.LockGuest;
						}
					}
					if (!flag && baseEntity is ModularCar { IsLockable: not false } modularCar && modularCar.CarLock.HasLockPermission(steamId))
					{
						flag = true;
					}
					if (flag && entityAssociationType == EntityAssociationType.Owner)
					{
						entityAssociationType = EntityAssociationType.Auth;
					}
				}
				if (flag && !string.IsNullOrEmpty(filter) && !StringEx.Contains(current.ShortPrefabName, filter, CompareOptions.IgnoreCase))
				{
					flag = false;
				}
				if (flag)
				{
					results.Add(new EntityAssociation
					{
						TargetEntity = baseEntity,
						AssociationType = entityAssociationType
					});
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}
}


private enum ChangeGradeMode
{
	Upgrade,
	Downgrade
}


using UnityEngine.Scripting;

[JsonModel]
[Preserve]
public struct PlayerInfo
{
	public string SteamID;

	public string OwnerSteamID;

	public string DisplayName;

	public int Ping;

	public string Address;

	public ulong EntityId;

	public int ConnectedSeconds;

	public float ViolationLevel;

	public float CurrentLevel;

	public float UnspentXp;

	public float Health;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct PlayerIDInfo
{
	public string SteamID;

	public string OwnerSteamID;

	public string DisplayName;

	public string Address;

	public ulong EntityId;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct ServerInfoOutput
{
	public string Hostname;

	public int MaxPlayers;

	public int Players;

	public int Queued;

	public int Joining;

	public int ReservedSlots;

	public int EntityCount;

	public string GameTime;

	public int Uptime;

	public string Map;

	public float Framerate;

	public int Memory;

	public int MemoryUsageSystem;

	public int Collections;

	public int NetworkIn;

	public int NetworkOut;

	public bool Restarting;

	public string SaveCreatedTime;

	public int Version;

	public string Protocol;
}


using UnityEngine.Scripting;

[Preserve]
[JsonModel]
public struct ServerConvarInfo
{
	public string FullName;

	public string Value;

	public string Help;
}


using UnityEngine.Scripting;

[JsonModel]
[Preserve]
public struct ServerUGCInfo
{
	public ulong entityId;

	public uint[] crcs;

	public UGCType contentType;

	public uint entityPrefabID;

	public string shortPrefabName;

	public ulong[] playerIds;

	public string contentString;

	public ServerUGCInfo(IUGCBrowserEntity fromEntity)
	{
		entityId = fromEntity.UgcEntity.net.ID.Value;
		crcs = fromEntity.GetContentCRCs;
		contentType = fromEntity.ContentType;
		entityPrefabID = fromEntity.UgcEntity.prefabID;
		shortPrefabName = fromEntity.UgcEntity.ShortPrefabName;
		playerIds = fromEntity.EditingHistory.ToArray();
		contentString = fromEntity.ContentString;
	}
}


private struct EntityAssociation
{
	public BaseEntity TargetEntity;

	public EntityAssociationType AssociationType;
}


private enum EntityAssociationType
{
	Owner,
	Auth,
	LockGuest
}


[Factory("antihack")]
public class AntiHack : ConsoleSystem
{
	[ReplicatedVar(Default = "0.22")]
	[Help("collider margin when checking for noclipping on dismount")]
	public static float noclip_margin_dismount = 0.22f;

	[ReplicatedVar(Default = "0.01")]
	[Help("collider backtracking when checking for noclipping")]
	public static float noclip_backtracking = 0.01f;

	[ServerVar]
	[Help("report violations to the anti cheat backend")]
	public static bool reporting = false;

	[ServerVar]
	[Help("are admins allowed to use their admin cheat")]
	public static bool admincheat = true;

	[ServerVar]
	[Help("use antihack to verify object placement by players")]
	public static bool objectplacement = true;

	[Help("use antihack to verify model state sent by players")]
	[ServerVar]
	public static bool modelstate = true;

	[Help("whether or not to force the position on the client")]
	[ServerVar]
	public static bool forceposition = true;

	[Help("0 == allow RPCs from stalled players, 1 == ignore RPCs from currently stalled players, 2 == ignore RPCs from recently stalled players")]
	[ServerVar]
	public static int rpcstallmode = 1;

	[ServerVar]
	[Help("time in seconds before player is no longer treated as wasStalled")]
	public static float rpcstallfade = 2.5f;

	[ServerVar]
	[Help("time in seconds we can receive no ticks for before player is considered stalling")]
	public static float rpcstallthreshold = 0.8f;

	[ServerVar]
	[Help("0 == users, 1 == admins, 2 == developers")]
	public static int userlevel = 2;

	[ServerVar]
	[Help("0 == no enforcement, 1 == kick, 2 == ban (DISABLED)")]
	public static int enforcementlevel = 1;

	[Help("max allowed client desync, lower value = more false positives")]
	[ServerVar]
	public static float maxdesync = 0.8f;

	[Help("max allowed client tick interval delta time, lower value = more false positives")]
	[ServerVar]
	public static float maxdeltatime = 1f;

	[ServerVar]
	[Help("for how many seconds to keep a tick history to use for distance checks")]
	public static float tickhistorytime = 0.5f;

	[Help("how much forgiveness to add when checking the distance from the player tick history")]
	[ServerVar]
	public static float tickhistoryforgiveness = 0.1f;

	[ServerVar]
	[Help("the rate at which violation values go back down")]
	public static float relaxationrate = 0.1f;

	[Help("the time before violation values go back down")]
	[ServerVar]
	public static float relaxationpause = 10f;

	[ServerVar]
	[Help("violation value above this results in enforcement")]
	public static float maxviolation = 100f;

	[Help("0 == disabled, 1 == enabled")]
	[ServerVar]
	public static int terrain_protection = 1;

	[ServerVar]
	[Help("how many slices to subdivide players into for the terrain check")]
	public static int terrain_timeslice = 64;

	[Help("how far to penetrate the terrain before violating")]
	[ServerVar]
	public static float terrain_padding = 0.3f;

	[ServerVar]
	[Help("violation penalty to hand out when terrain is detected")]
	public static float terrain_penalty = 100f;

	[ServerVar]
	[Help("whether or not to kill the player when terrain is detected")]
	public static bool terrain_kill = true;

	[Help("whether or not to check for player inside geometry like rocks as well as base terrain")]
	[ServerVar]
	public static bool terrain_check_geometry = false;

	[ServerVar]
	[Help("0 == disabled, 1 == ray, 2 == sphere, 3 == curve")]
	public static int noclip_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when noclip is detected")]
	public static bool noclip_reject = true;

	[ServerVar]
	[Help("violation penalty to hand out when noclip is detected")]
	public static float noclip_penalty = 0f;

	[ServerVar]
	[Help("collider margin when checking for noclipping")]
	public static float noclip_margin = 0.09f;

	[ServerVar]
	[Help("movement curve step size, lower value = less false positives")]
	public static float noclip_stepsize = 0.1f;

	[ServerVar]
	[Help("movement curve max steps, lower value = more false positives")]
	public static int noclip_maxsteps = 15;

	[ServerVar]
	[Help("0 == disabled, 1 == simple, 2 == advanced, 3 == vertical swim protection")]
	public static int speedhack_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when speedhack is detected")]
	public static bool speedhack_reject = true;

	[ServerVar]
	[Help("violation penalty to hand out when speedhack is detected")]
	public static float speedhack_penalty = 0f;

	[ServerVar]
	[Help("speed threshold to assume speedhacking, lower value = more false positives")]
	public static float speedhack_forgiveness = 2f;

	[ServerVar]
	[Help("speed threshold to assume speedhacking, lower value = more false positives")]
	public static float speedhack_forgiveness_inertia = 10f;

	[Help("speed forgiveness when moving down slopes, lower value = more false positives")]
	[ServerVar]
	public static float speedhack_slopespeed = 10f;

	[Help("0 == disabled, 1 == client, 2 == capsule, 3 == curve")]
	[ServerVar]
	public static int flyhack_protection = 3;

	[ServerVar]
	[Help("whether or not to reject movement when flyhack is detected")]
	public static bool flyhack_reject = true;

	[Help("violation penalty to hand out when flyhack is detected")]
	[ServerVar]
	public static float flyhack_penalty = 100f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_vertical = 1f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_vertical_inertia = 7f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_horizontal = 1.5f;

	[Help("distance threshold to assume flyhacking, lower value = more false positives")]
	[ServerVar]
	public static float flyhack_forgiveness_horizontal_inertia = 10f;

	[Help("collider downwards extrusion when checking for flyhacking")]
	[ServerVar]
	public static float flyhack_extrusion = 2f;

	[Help("collider margin when checking for flyhacking")]
	[ServerVar]
	public static float flyhack_margin = 0.1f;

	[Help("movement curve step size, lower value = less false positives")]
	[ServerVar]
	public static float flyhack_stepsize = 0.1f;

	[Help("movement curve max steps, lower value = more false positives")]
	[ServerVar]
	public static int flyhack_maxsteps = 15;

	[ServerVar]
	[Help("Optimizes checks by using cached water info. Originally off")]
	public static bool flyhack_usecachedstate = true;

	[Help("serverside fall damage, requires flyhack_protection >= 2 for proper functionality")]
	[ServerVar]
	public static bool serverside_fall_damage = false;

	[Help("0 == disabled, 1 == speed, 2 == speed + entity, 3 == speed + entity + LOS, 4 == speed + entity + LOS + trajectory, 5 == speed + entity + LOS + trajectory + update, 6 == speed + entity + LOS + trajectory + tickhistory")]
	[ServerVar]
	public static int projectile_protection = 6;

	[Help("violation penalty to hand out when projectile hack is detected")]
	[ServerVar]
	public static float projectile_penalty = 0f;

	[ServerVar]
	[Help("projectile speed forgiveness in percent, lower value = more false positives")]
	public static float projectile_forgiveness = 0.5f;

	[ServerVar]
	[Help("projectile server frames to include in delay, lower value = more false positives")]
	public static float projectile_serverframes = 2f;

	[ServerVar]
	[Help("projectile client frames to include in delay, lower value = more false positives")]
	public static float projectile_clientframes = 2f;

	[Help("projectile trajectory forgiveness, lower value = more false positives")]
	[ServerVar]
	public static float projectile_trajectory = 2f;

	[ServerVar]
	[Help("projectile trajectory forgiveness for projectile updates, lower value = more false positives")]
	public static float projectile_trajectory_update = 0.02f;

	[ServerVar]
	[Help("projectile penetration angle change, lower value = more false positives")]
	public static float projectile_anglechange = 60f;

	[Help("projectile penetration velocity change, lower value = more false positives")]
	[ServerVar]
	public static float projectile_velocitychange = 1.1f;

	[Help("projectile desync forgiveness, lower value = more false positives")]
	[ServerVar]
	public static float projectile_desync = 1f;

	[Help("projectile backtracking when checking for LOS")]
	[ServerVar]
	public static float projectile_backtracking = 0.01f;

	[Help("line of sight directional forgiveness when checking eye or center position")]
	[ServerVar]
	public static float projectile_losforgiveness = 0.2f;

	[Help("how often a projectile is allowed to penetrate something before its damage is ignored")]
	[ServerVar]
	public static int projectile_damagedepth = 2;

	[Help("how often a projectile is allowed to penetrate something before its impact spawn is ignored")]
	[ServerVar]
	public static int projectile_impactspawndepth = 1;

	[Help("whether or not to include terrain in the projectile LOS checks")]
	[ServerVar]
	public static bool projectile_terraincheck = true;

	[ServerVar]
	[Help("whether or not to include vehicles in the projectile LOS checks")]
	public static bool projectile_vehiclecheck = true;

	[ServerVar]
	[Help("whether or not to compensate for the client / server vehicle position offset")]
	public static bool projectile_positionoffset = true;

	[ServerVar]
	[Help("minimum distance before we verify client projectile distance mismatch, lower value = more false positives")]
	public static float projectile_distance_forgiveness_minimum = 25f;

	[Help("maximum number of projectile updates to allow before rejecting damage")]
	[ServerVar]
	public static int projectile_update_limit = 4;

	[Help("0 == disabled, 1 == initiator, 2 == initiator + target, 3 == initiator + target + LOS, 4 == initiator + target + LOS + tickhistory")]
	[ServerVar]
	public static int melee_protection = 4;

	[ServerVar]
	[Help("violation penalty to hand out when melee hack is detected")]
	public static float melee_penalty = 0f;

	[ServerVar]
	[Help("melee distance forgiveness in percent, lower value = more false positives")]
	public static float melee_forgiveness = 0.5f;

	[ServerVar]
	[Help("melee server frames to include in delay, lower value = more false positives")]
	public static float melee_serverframes = 2f;

	[ServerVar]
	[Help("melee client frames to include in delay, lower value = more false positives")]
	public static float melee_clientframes = 2f;

	[ServerVar]
	[Help("melee backtracking when checking for LOS")]
	public static float melee_backtracking = 0.01f;

	[ServerVar]
	[Help("line of sight directional forgiveness when checking eye or center position")]
	public static float melee_losforgiveness = 0.2f;

	[ServerVar]
	[Help("whether or not to include terrain in the melee LOS checks")]
	public static bool melee_terraincheck = true;

	[Help("whether or not to include vehicles in the melee LOS checks")]
	[ServerVar]
	public static bool melee_vehiclecheck = true;

	[ServerVar]
	[Help("0 == disabled, 1 == distance, 2 == distance + LOS, 3 = distance + LOS + altitude, 4 = distance + LOS + altitude + noclip, 5 = distance + LOS + altitude + noclip + history")]
	public static int eye_protection = 4;

	[ServerVar]
	[Help("violation penalty to hand out when eye hack is detected")]
	public static float eye_penalty = 0f;

	[ServerVar]
	[Help("eye distance forgiveness, lower value = more false positives")]
	public static float eye_forgiveness = 0.4f;

	[ServerVar]
	[Help("eye distance forgiveness for parented or mounted players, lower value = more false positives")]
	public static float eye_distance_parented_mounted_forgiveness = 2f;

	[ServerVar]
	[Help("eye server frames to include in delay, lower value = more false positives")]
	public static float eye_serverframes = 2f;

	[ServerVar]
	[Help("eye client frames to include in delay, lower value = more false positives")]
	public static float eye_clientframes = 2f;

	[ServerVar]
	[Help("whether or not to include terrain in the eye LOS checks")]
	public static bool eye_terraincheck = true;

	[Help("whether or not to include vehicles in the eye LOS checks")]
	[ServerVar]
	public static bool eye_vehiclecheck = true;

	[ServerVar]
	[Help("distance at which to start testing eye noclipping")]
	public static float eye_noclip_cutoff = 0.06f;

	[ServerVar]
	[Help("collider margin when checking for noclipping")]
	public static float eye_noclip_margin = 0.25f;

	[ServerVar]
	[Help("collider backtracking when checking for noclipping")]
	public static float eye_noclip_backtracking = 0.01f;

	[ServerVar]
	[Help("line of sight sphere cast radius, 0 == raycast")]
	public static float eye_losradius = 0.162f;

	[Help("violation penalty to hand out when eye history mismatch is detected")]
	[ServerVar]
	public static float eye_history_penalty = 100f;

	[Help("how much forgiveness to add when checking the distance between player tick history and player eye history")]
	[ServerVar]
	public static float eye_history_forgiveness = 0.1f;

	[Help("maximum distance an impact effect can be from the entities bounds")]
	[ServerVar]
	public static float impact_effect_distance_forgiveness = 0.45f;

	[Help("line of sight sphere cast radius, 0 == raycast")]
	[ServerVar]
	public static float build_losradius = 0.01f;

	[Help("line of sight sphere cast radius, 0 == raycast")]
	[ServerVar]
	public static float build_losradius_sleepingbag = 0.3f;

	[Help("whether or not to include terrain in the build LOS checks")]
	[ServerVar]
	public static bool build_terraincheck = true;

	[ServerVar]
	[Help("whether or not to include vehicles in the build LOS checks")]
	public static bool build_vehiclecheck = true;

	[ServerVar]
	[Help("whether or not to check for building being done on the wrong side of something (e.g. inside rocks). 0 = Disabled, 1 = Info only, 2 = Enabled")]
	public static int build_inside_check = 2;

	[ServerVar]
	[Help("the maximum distance we check for for inside mesh")]
	public static float mesh_inside_check_distance = 50f;

	[Help("use the older, simpler is inside check. has several loopholes that aren't properly catered to")]
	[ServerVar]
	public static bool use_legacy_mesh_inside_check = true;

	[ServerVar]
	[Help("whether or not to ensure players are always networked to server administrators")]
	public static bool server_occlusion_admin_bypass = false;

	[ServerVar]
	[Help("number of blocked grids permitted before line-of-sight fails")]
	public static int server_occlusion_blocked_grid_threshold = 0;

	[ServerVar]
	[Help("number of neighbour checks permitted before line-of-sight fails")]
	public static int server_occlusion_neighbour_threshold = 2;

	[ServerVar]
	[Help("whether to use server occlusion caching")]
	public static bool server_occlusion_caching = true;

	[ServerVar]
	[Help("whether to save sub grid for map to a file on first time init, faster subsequent server launching")]
	public static bool server_occlusion_save_grid = true;

	[ServerVar]
	[Help("whether to use neighbour threshold limitations")]
	public static bool server_occlusion_use_neighbour_thresholds = false;

	[ServerVar]
	[Help("whether or not to skip the line-of-sight process, this will effectively disable server occlusion")]
	public static bool server_occlusion_disable_los = false;

	[ServerVar]
	[Help("whether or not to skip the line-of-sight process for sleepers")]
	public static bool server_occlusion_disable_sleeper_los = false;

	[Help("How far a player is allowed to move in a single tick")]
	[ServerVar]
	public static float tick_max_distance = 1.1f;

	[Help("How far a player is allowed to move in a single tick when falling")]
	[ServerVar]
	public static float tick_max_distance_falling = 4f;

	[ServerVar]
	[Help("How far a player is allowed to move in a single tick when parented")]
	public static float tick_max_distance_parented = 3f;

	[ServerVar]
	[Help("Whether or not to enable additional tick validation measures")]
	public static bool tick_buffer_preventions = true;

	[ServerVar]
	[Help("How many seconds worth of ticks can be sent before server tick finalizing before we revert to noclip_protection 2")]
	public static float tick_buffer_noclip_threshold = 2f;

	[ServerVar]
	[Help("How many seconds worth of ticks can be sent before server tick finalizing before we reject movement")]
	public static float tick_buffer_reject_threshold = 3f;

	[ServerVar]
	[Help("How long it should take for a server to process a frame before we decide to skip additional tick validation measures")]
	public static float tick_buffer_server_lag_threshold = 0.3f;

	[ServerVar]
	[Help("How far a player is allowed to move in forgiveness scenarios")]
	public static float tick_distance_forgiveness = 5f;

	[ServerVar(Help = "Should explosives parented to vehicles damage deployables")]
	public static bool explosive_vehicle_parent_damage_deployables = false;

	[ServerVar]
	[Help("How long, in seconds, can the clients progress timer deviate from the servers")]
	public static float rpc_timer_forgiveness = 1f;

	[ServerVar]
	[Help("0 == silent, 1 == print max violation, 2 == print nonzero violation, 3 == print any violation except noclip, 4 == print any violation")]
	public static int debuglevel = 1;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net;
using System.Net.Sockets;
using System.Threading.Tasks;
using CompanionServer;
using ConVar;
using Facepunch.Extend;
using Steamworks;
using UnityEngine;

[Factory("app")]
public class App : ConsoleSystem
{
	[ServerVar]
	public static string listenip = "";

	[ServerVar]
	public static int port;

	[ServerVar]
	public static string publicip = "";

	[ServerVar(Help = "Disables updating entirely - emergency use only")]
	public static bool update = true;

	[ServerVar(Help = "Enables sending push notifications")]
	public static bool notifications = true;

	[ServerVar(Help = "Max number of queued messages - set to 0 to disable message processing")]
	public static int queuelimit = 100;

	[ReplicatedVar(Default = "")]
	public static string serverid = "";

	[ServerVar(Help = "Cooldown time before alarms can send another notification (in seconds)")]
	public static float alarmcooldown = 30f;

	[ServerVar]
	public static int maxconnections = 500;

	[ServerVar]
	public static int maxconnectionsperip = 5;

	[ServerVar]
	public static int maxmessagesize = 1048576;

	[ServerUserVar]
	public static async void pair(Arg arg)
	{
		try
		{
			BasePlayer basePlayer = arg.Player();
			if (!((Object)(object)basePlayer == (Object)null))
			{
				Dictionary<string, string> dictionary = Util.TryGetPlayerPairingData(basePlayer);
				if (dictionary == null)
				{
					arg.ReplyWith("This server is not configured to allow Rust+ connections.");
					return;
				}
				NotificationSendResult notificationSendResult = await Util.SendPairNotification("server", basePlayer, StringExtensions.Truncate(ConVar.Server.hostname, 128, (string)null), "Tap to pair with this server.", dictionary);
				arg.ReplyWith((notificationSendResult == NotificationSendResult.Sent) ? "Sent pairing notification." : notificationSendResult.ToErrorMessage().english);
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	[ServerUserVar]
	public static void regeneratetoken(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			SingletonComponent<ServerMgr>.Instance.persistance.RegenerateAppToken(basePlayer.userID);
			arg.ReplyWith("Regenerated Rust+ token");
		}
	}

	[ServerVar]
	public static void info(Arg arg)
	{
		if (!CompanionServer.Server.IsEnabled)
		{
			arg.ReplyWith("Companion server is not enabled");
			return;
		}
		Listener listener = CompanionServer.Server.Listener;
		arg.ReplyWith(string.Format("Server ID: {0}\nListening on: {1}:{2}\nApp connects to: {3}:{4}", serverid, listener.Address, listener.Port, GetPublicIP() ?? "null", port));
	}

	[ServerVar(Help = "Retry initializing the Rust+ companion server if it previously failed")]
	public static void retry_initialize(Arg arg)
	{
		if (CompanionServer.Server.IsEnabled)
		{
			arg.ReplyWith("Companion server is already initialized!");
			return;
		}
		if (port < 0)
		{
			arg.ReplyWith("Companion server port is invalid, cannot initialize companion server");
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if ((Object)(object)activeGameMode != (Object)null && !activeGameMode.rustPlus)
		{
			arg.ReplyWith("Companion server is disabled by gamemode, cannot initialize companion server");
			return;
		}
		arg.ReplyWith("Trying to initialize companion server...");
		CompanionServer.Server.Initialize();
	}

	[ServerVar]
	public static void resetlimiter(Arg arg)
	{
		CompanionServer.Server.Listener?.Limiter?.Clear();
	}

	[ServerVar]
	public static void connections(Arg arg)
	{
		string text = CompanionServer.Server.Listener?.Limiter?.ToString() ?? "Not available";
		arg.ReplyWith(text);
	}

	[ServerVar]
	public static void appban(Arg arg)
	{
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			arg.ReplyWith("Usage: app.appban <steamID64>");
			return;
		}
		string text = (SingletonComponent<ServerMgr>.Instance.persistance.SetAppTokenLocked(uLong, locked: true) ? $"Banned {uLong} from using the companion app" : $"{uLong} is already banned from using the companion app");
		arg.ReplyWith(text);
	}

	[ServerVar]
	public static void appunban(Arg arg)
	{
		ulong uLong = arg.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			arg.ReplyWith("Usage: app.appunban <steamID64>");
			return;
		}
		string text = (SingletonComponent<ServerMgr>.Instance.persistance.SetAppTokenLocked(uLong, locked: false) ? $"Unbanned {uLong}, they can use the companion app again" : $"{uLong} is not banned from using the companion app");
		arg.ReplyWith(text);
	}

	public static IPAddress GetListenIP()
	{
		if (!string.IsNullOrWhiteSpace(listenip))
		{
			if (!IPAddress.TryParse(listenip, out IPAddress address) || address.AddressFamily != AddressFamily.InterNetwork)
			{
				Debug.LogError((object)("Invalid app.listenip: " + listenip));
				return IPAddress.Any;
			}
			return address;
		}
		return IPAddress.Any;
	}

	public static async ValueTask<string> GetPublicIPAsync()
	{
		Stopwatch timer = null;
		string publicIP;
		while (true)
		{
			bool num = timer != null && timer.Elapsed.TotalMinutes > 5.0;
			publicIP = GetPublicIP();
			if (num || (!string.IsNullOrWhiteSpace(publicIP) && publicIP != "0.0.0.0"))
			{
				break;
			}
			if (timer == null)
			{
				timer = Stopwatch.StartNew();
			}
			await Task.Delay(10000);
		}
		return publicIP;
	}

	public static string GetPublicIP()
	{
		if (!string.IsNullOrWhiteSpace(publicip) && IPAddress.TryParse(publicip, out IPAddress address) && address.AddressFamily == AddressFamily.InterNetwork)
		{
			return publicip;
		}
		if (!SteamServer.IsValid)
		{
			return null;
		}
		return SteamServer.PublicIp.ToString();
	}
}


using UnityEngine;

[Factory("audio")]
public class Audio : ConsoleSystem
{
	[ClientVar(Help = "Volume", Saved = true)]
	public static float master = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float musicvolume = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float musicvolumemenu = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float game = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float ui = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float voices = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float instruments = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float voiceProps = 1f;

	[ClientVar(Help = "Volume", Saved = true)]
	public static float eventAudio = 1f;

	[ClientVar(Help = "Ambience System")]
	public static bool ambience = true;

	[ClientVar(Help = "Max ms per frame to spend updating sounds")]
	public static float framebudget = 0.3f;

	[ClientVar]
	public static float minupdatefraction = 0.1f;

	[ClientVar(Help = "Use more advanced sound occlusion", Saved = true)]
	public static bool advancedocclusion = false;

	[ClientVar(Help = "Use higher quality sound fades on some sounds")]
	public static bool hqsoundfade = false;

	[ClientVar(Saved = false)]
	public static bool debugVoiceLimiting = false;

	[ClientVar]
	public static bool enableSoundPooling = false;

	[ClientVar(Help = "Volume", Saved = true)]
	public static int speakers
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)AudioSettings.speakerMode;
		}
		set
		{
			value = Mathf.Clamp(value, 2, 7);
		}
	}

	[ClientVar]
	public static void printSounds(Arg arg)
	{
	}

	[ClientVar(ClientAdmin = true, Help = "print active engine sound info")]
	public static void printEngineSounds(Arg arg)
	{
	}
}


[Factory("batching")]
public class Batching : ConsoleSystem
{
	[ClientVar(ClientAdmin = true)]
	public static bool enabled = true;

	[ClientVar(ClientAdmin = true)]
	public static bool renderer_threading = true;

	[ClientVar(ClientAdmin = true)]
	public static int renderer_capacity = 30000;

	[ClientVar(ClientAdmin = true)]
	public static int renderer_vertices = 1000;

	[ClientVar(ClientAdmin = true)]
	public static int renderer_submeshes = 1;

	[ServerVar]
	[ClientVar]
	public static int verbose = 0;
}


using UnityEngine;

[Factory("bot")]
public class Bot : ConsoleSystem
{
	[ServerVar(ClientAdmin = true, ShowInAdminUI = false)]
	public static string crouch_server(Arg args)
	{
		ulong uLong = args.GetULong(0, 0uL);
		if (uLong == 0L)
		{
			return "No user id";
		}
		BasePlayer basePlayer = BasePlayer.FindBot(uLong);
		if ((Object)(object)basePlayer == (Object)null)
		{
			return $"No bot found with id{uLong}";
		}
		basePlayer.modelState.ducked = args.GetBool(0, true);
		basePlayer.SendNetworkUpdate();
		return "Crouched " + basePlayer.displayName + ".";
	}
}


using UnityEngine;

[Factory("bradley")]
public class Bradley : ConsoleSystem
{
	[ServerVar]
	public static float respawnDelayMinutes = 60f;

	[ServerVar]
	public static float respawnDelayVariance = 1f;

	[ServerVar]
	public static bool enabled = true;

	[ServerVar]
	public static void quickrespawn(Arg arg)
	{
		if (!Object.op_Implicit((Object)(object)arg.Player()))
		{
			return;
		}
		BradleySpawner singleton = BradleySpawner.singleton;
		if ((Object)(object)singleton == (Object)null)
		{
			Debug.LogWarning((object)"No Spawner");
			return;
		}
		if (Object.op_Implicit((Object)(object)singleton.spawned))
		{
			singleton.spawned.Kill();
		}
		singleton.spawned = null;
		singleton.DoRespawn();
	}
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using CircularBuffer;
using CompanionServer;
using ConVar;
using Facepunch;
using Facepunch.Math;
using Facepunch.Rust;
using Network;
using Oxide.Core;
using UnityEngine;

[Factory("chat")]
public class Chat : ConsoleSystem
{
	public enum ChatChannel
	{
		Global = 0,
		Team = 1,
		Server = 2,
		Cards = 3,
		Local = 4,
		Clan = 5,
		ExternalDM = 6,
		MaxValue = 6
	}

	public struct ChatEntry
	{
		public ChatChannel Channel { get; set; }

		public string Message { get; set; }

		public string UserId { get; set; }

		public string Username { get; set; }

		public string Color { get; set; }

		public int Time { get; set; }
	}

	[ServerVar]
	public static float localChatRange = 100f;

	[ReplicatedVar]
	public static bool globalchat = true;

	[ReplicatedVar]
	public static bool localchat = false;

	private const float textVolumeBoost = 0.2f;

	[ReplicatedVar]
	public static bool hideChatInTutorial = true;

	[ServerVar]
	[ClientVar]
	public static bool enabled = true;

	[ServerVar(Help = "Number of messages to keep in memory for chat history")]
	public static int historysize = 1000;

	public static CircularBuffer<ChatEntry> History = new CircularBuffer<ChatEntry>(historysize);

	[ServerVar]
	public static bool serverlog = true;

	public static void Broadcast(string message, string username = "SERVER", string color = "#eee", ulong userid = 0uL)
	{
		if (Interface.CallHook("OnServerMessage", (object)message, (object)username, (object)color, (object)userid) == null)
		{
			string text = StringEx.EscapeRichText(username, false);
			ConsoleNetwork.BroadcastToAllClients("chat.add", 2, 0, "<color=" + color + ">" + text + "</color> " + message);
			ChatEntry ce = default(ChatEntry);
			ce.Channel = ChatChannel.Server;
			ce.Message = message;
			ce.UserId = userid.ToString();
			ce.Username = username;
			ce.Color = color;
			ce.Time = Epoch.Current;
			Record(ce);
		}
	}

	[ServerUserVar]
	public static void say(Arg arg)
	{
		if (globalchat)
		{
			sayImpl(ChatChannel.Global, arg);
		}
	}

	[ServerUserVar]
	public static void localsay(Arg arg)
	{
		if (localchat)
		{
			sayImpl(ChatChannel.Local, arg);
		}
	}

	[ServerUserVar]
	public static void teamsay(Arg arg)
	{
		sayImpl(ChatChannel.Team, arg);
	}

	[ServerUserVar]
	public static void cardgamesay(Arg arg)
	{
		sayImpl(ChatChannel.Cards, arg);
	}

	[ServerUserVar]
	public static void clansay(Arg arg)
	{
		sayImpl(ChatChannel.Clan, arg);
	}

	private static void sayImpl(ChatChannel targetChannel, Arg arg)
	{
		if (!enabled)
		{
			arg.ReplyWith("Chat is disabled.");
			return;
		}
		BasePlayer player = arg.Player();
		if (!Object.op_Implicit((Object)(object)player) || (hideChatInTutorial && player.IsInTutorial) || player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return;
		}
		if (!player.IsAdmin && !player.IsDeveloper)
		{
			if (player.NextChatTime == 0f)
			{
				player.NextChatTime = Time.realtimeSinceStartup - 30f;
			}
			if (player.NextChatTime > Time.realtimeSinceStartup)
			{
				player.NextChatTime += 2f;
				float num = player.NextChatTime - Time.realtimeSinceStartup;
				ConsoleNetwork.SendClientCommand(player.net.connection, "chat.add", 2, 0, "You're chatting too fast - try again in " + (num + 0.5f).ToString("0") + " seconds");
				if (num > 120f)
				{
					player.Kick("Chatting too fast");
				}
				return;
			}
		}
		string @string = arg.GetString(0, "text");
		ValueTask<bool> valueTask = sayAs(targetChannel, player.userID, player.displayName, @string, player);
		Analytics.Azure.OnChatMessage(player, @string, (int)targetChannel);
		player.NextChatTime = Time.realtimeSinceStartup + 1.5f;
		if (valueTask.IsCompletedSuccessfully)
		{
			if (!valueTask.Result)
			{
				player.NextChatTime = Time.realtimeSinceStartup;
			}
			return;
		}
		Task<bool> task = valueTask.AsTask();
		task.GetAwaiter().OnCompleted(delegate
		{
			try
			{
				if (!task.Result)
				{
					player.NextChatTime = Time.realtimeSinceStartup;
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex);
			}
		});
	}

	internal static string GetNameColor(ulong userId, BasePlayer player = null)
	{
		ServerUsers.UserGroup userGroup = ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None;
		bool flag = userGroup == ServerUsers.UserGroup.Owner || userGroup == ServerUsers.UserGroup.Moderator;
		bool num = (((Object)(object)player != (Object)null) ? player.IsDeveloper : DeveloperList.Contains(userId));
		string result = "#5af";
		if (flag)
		{
			result = "#af5";
		}
		if (num)
		{
			result = "#fa5";
		}
		return result;
	}

	internal static async ValueTask<bool> sayAs(ChatChannel targetChannel, ulong userId, string username, string message, BasePlayer player = null)
	{
		if (!Object.op_Implicit((Object)(object)player))
		{
			player = null;
		}
		if (!enabled)
		{
			return false;
		}
		if ((Object)(object)player != (Object)null && player.HasPlayerFlag(BasePlayer.PlayerFlags.ChatMute))
		{
			return false;
		}
		if ((ServerUsers.Get(userId)?.group ?? ServerUsers.UserGroup.None) == ServerUsers.UserGroup.Banned)
		{
			return false;
		}
		string strChatText = message.Replace("\n", "").Replace("\r", "").Trim();
		if (strChatText.Length > 128)
		{
			strChatText = strChatText.Substring(0, 128);
		}
		if (strChatText.Length <= 0)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnPlayerChat", (object)userId, (object)username, (object)strChatText, (object)targetChannel, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (strChatText.StartsWith("/") || strChatText.StartsWith("\\"))
		{
			return false;
		}
		strChatText = StringEx.EscapeRichText(strChatText, false);
		if (ConVar.Server.emojiOwnershipCheck && strChatText.Contains(":") && (Object)(object)player != (Object)null)
		{
			List<(TmProEmojiRedirector.EmojiSub, int)> list = Pool.Get<List<(TmProEmojiRedirector.EmojiSub, int)>>();
			TmProEmojiRedirector.FindEmojiSubstitutions(strChatText, RustEmojiLibrary.Instance, list, richText: false, isServer: true);
			foreach (var item in list)
			{
				if (!item.Item1.targetEmojiResult.CanBeUsedBy(player, player.userID))
				{
					strChatText = strChatText.Replace(":" + item.Item1.targetEmoji + ":", string.Empty);
				}
			}
			Pool.FreeUnmanaged<(TmProEmojiRedirector.EmojiSub, int)>(ref list);
			if (strChatText.Length <= 0)
			{
				return false;
			}
		}
		if (serverlog)
		{
			ServerConsole.PrintColoured(ConsoleColor.DarkYellow, "[" + targetChannel.ToString() + "] " + username + ": ", ConsoleColor.DarkGreen, strChatText);
			string text = ((object)player)?.ToString() ?? $"{username}[{userId}]";
			switch (targetChannel)
			{
			case ChatChannel.Team:
				DebugEx.Log((object)("[TEAM CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			case ChatChannel.Cards:
				DebugEx.Log((object)("[CARDS CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			case ChatChannel.Clan:
				DebugEx.Log((object)("[CLAN CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			default:
				DebugEx.Log((object)("[CHAT] " + text + " : " + strChatText), (StackTraceLogType)0);
				break;
			}
		}
		string strName = StringEx.EscapeRichText(username, false);
		string nameColor = GetNameColor(userId, player);
		ChatEntry ce = default(ChatEntry);
		ce.Channel = targetChannel;
		ce.Message = strChatText;
		ce.UserId = (((Object)(object)player != (Object)null) ? player.UserIDString : userId.ToString());
		ce.Username = username;
		ce.Color = nameColor;
		ce.Time = Epoch.Current;
		Record(ce);
		switch (targetChannel)
		{
		case ChatChannel.Cards:
		{
			if ((Object)(object)player == (Object)null)
			{
				return false;
			}
			if (!player.isMounted)
			{
				return false;
			}
			BaseCardGameEntity baseCardGameEntity = player.GetMountedVehicle() as BaseCardGameEntity;
			if ((Object)(object)baseCardGameEntity == (Object)null || !(baseCardGameEntity.GameController?.IsAtTable(player) ?? false))
			{
				return false;
			}
			List<Connection> list2 = Pool.Get<List<Connection>>();
			baseCardGameEntity.GameController?.GetConnectionsInGame(list2);
			if (list2.Count > 0)
			{
				ConsoleNetwork.SendClientCommand(list2, "chat.add2", 3, userId, strChatText, strName, nameColor, 1f);
			}
			Pool.FreeUnmanaged<Connection>(ref list2);
			return true;
		}
		case ChatChannel.Global:
			ConsoleNetwork.BroadcastToAllClients("chat.add2", 0, userId, strChatText, strName, nameColor, 1f);
			return true;
		case ChatChannel.Local:
		{
			if (!((Object)(object)player != (Object)null))
			{
				break;
			}
			float num = localChatRange * localChatRange;
			Enumerator<BasePlayer> enumerator2 = BasePlayer.activePlayerList.GetEnumerator();
			try
			{
				while (enumerator2.MoveNext())
				{
					BasePlayer current2 = enumerator2.Current;
					Vector3 val3 = ((Component)current2).transform.position - ((Component)player).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (!(sqrMagnitude > num))
					{
						ConsoleNetwork.SendClientCommand(current2.net.connection, "chat.add2", 4, userId, strChatText, strName, nameColor, Mathf.Clamp01(sqrMagnitude / num + 0.2f));
					}
				}
			}
			finally
			{
				((IDisposable)enumerator2/*cast due to .constrained prefix*/).Dispose();
			}
			return true;
		}
		case ChatChannel.Team:
		{
			RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.FindPlayersTeam(userId);
			if (playerTeam == null)
			{
				return false;
			}
			List<Connection> onlineMemberConnections = playerTeam.GetOnlineMemberConnections();
			if (onlineMemberConnections != null)
			{
				ConsoleNetwork.SendClientCommand(onlineMemberConnections, "chat.add2", 1, userId, strChatText, strName, nameColor, 1f);
			}
			playerTeam.BroadcastTeamChat(userId, strName, strChatText, nameColor);
			return true;
		}
		case ChatChannel.Clan:
		{
			ClanManager serverInstance = ClanManager.ServerInstance;
			if ((Object)(object)serverInstance == (Object)null)
			{
				return false;
			}
			if ((Object)(object)player != (Object)null && player.clanId == 0L)
			{
				return false;
			}
			try
			{
				ClanValueResult<IClan> val = ((!((Object)(object)player != (Object)null) || player.clanId == 0L) ? (await serverInstance.Backend.GetByMember(userId)) : (await serverInstance.Backend.Get(player.clanId)));
				ClanValueResult<IClan> val2 = val;
				if (!val2.IsSuccess)
				{
					return false;
				}
				if ((int)(await val2.Value.SendChatMessage(strName, strChatText, userId)) != 1)
				{
					return false;
				}
				return true;
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex);
				return false;
			}
		}
		}
		return false;
	}

	[Help("Return the last x lines of the console. Default is 200")]
	[ServerVar]
	public static IEnumerable<ChatEntry> tail(Arg arg)
	{
		int @int = arg.GetInt(0, 200);
		int num = History.Size - @int;
		if (num < 0)
		{
			num = 0;
		}
		return ((IEnumerable<ChatEntry>)History).Skip(num);
	}

	[Help("Search the console for a particular string")]
	[ServerVar]
	public static IEnumerable<ChatEntry> search(Arg arg)
	{
		string search = arg.GetString(0, (string)null);
		if (search == null)
		{
			return Enumerable.Empty<ChatEntry>();
		}
		return ((IEnumerable<ChatEntry>)History).Where((ChatEntry x) => x.Message.Length < 4096 && StringEx.Contains(x.Message, search, CompareOptions.IgnoreCase));
	}

	public static void Record(ChatEntry ce)
	{
		int num = Mathf.Max(historysize, 10);
		if (History.Capacity != num)
		{
			CircularBuffer<ChatEntry> val = new CircularBuffer<ChatEntry>(num);
			foreach (ChatEntry item in History)
			{
				val.PushBack(item);
			}
			History = val;
		}
		History.PushBack(ce);
		RCon.Broadcast(RCon.LogType.Chat, ce);
	}
}


public enum ChatChannel
{
	Global = 0,
	Team = 1,
	Server = 2,
	Cards = 3,
	Local = 4,
	Clan = 5,
	ExternalDM = 6,
	MaxValue = 6
}


public struct ChatEntry
{
	public ChatChannel Channel { get; set; }

	public string Message { get; set; }

	public string UserId { get; set; }

	public string Username { get; set; }

	public string Color { get; set; }

	public int Time { get; set; }
}


using System;
using System.Collections.Generic;
using System.Text;
using System.Threading.Tasks;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

[Factory("clan")]
public class Clan : ConsoleSystem
{
	[ReplicatedVar(Help = "If enabled then players will need to be near a Clan Table to make changes to clans", Default = "true")]
	public static bool editsRequireClanTable = true;

	[ServerVar(Help = "Enables the clan system if set to true (must be set at boot, requires restart)")]
	public static bool enabled = false;

	[ServerVar(Help = "Maximum number of members each clan can have (local backend only!)")]
	public static int maxMemberCount = 100;

	[ServerVar(Help = "How much score players earn for killing a player in another clan")]
	public static int scoreForKillingPlayerInOtherClan = 10;

	[ServerVar(Help = "How much score players earn for being killed by a player in another clan (this value should be negative)")]
	public static int scoreForKilledByPlayerInOtherClan = -10;

	[ServerVar(Help = "How much score players earn for killing unarmed players (this value should be negative)")]
	public static int scoreForKillingUnarmedPlayer = -10;

	[ServerVar(Help = "How much score players earn for destroying other player's tool cupboards")]
	public static int scoreForDestroyingToolCupboards = 10;

	[ServerVar(Help = "How much score players earn for hacking crates")]
	public static int scoreForHackingCrates = 5;

	[ServerVar(Help = "How much score players earn for opening hacked crates")]
	public static int scoreForOpeningHackedCrates = 5;

	[ServerVar(Help = "How much score players earn for destroying bradley")]
	public static int scoreForDestroyingBradley = 10;

	[ServerVar(Help = "How much score players earn for running the excavator")]
	public static int scoreForRunningExcavator = 10;

	[ServerVar(Help = "How much score players earn for reaching cargo ship")]
	public static int scoreForReachingCargoShip = 10;

	[ServerVar(Help = "How much score players earn for looting an elite crate")]
	public static int scoreForLootingEliteCrate = 10;

	[ServerVar(Help = "Prints info about a clan given its ID")]
	public static void Info(Arg arg)
	{
		if ((Object)(object)ClanManager.ServerInstance == (Object)null)
		{
			arg.ReplyWith("ClanManager is null!");
			return;
		}
		long clanId = arg.GetLong(0, 0L);
		if (clanId == 0L)
		{
			BasePlayer basePlayer = arg.Player();
			if ((Object)(object)basePlayer == (Object)null)
			{
				arg.ReplyWith("Usage: clan.info <clanID>");
			}
			else
			{
				SendClanInfoPlayer(basePlayer);
			}
		}
		else
		{
			SendClanInfoConsole(clanId);
		}
		static string FormatClan(IClan clan)
		{
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
			//IL_010d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0100: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			//IL_015b: Unknown result type (might be due to invalid IL or missing references)
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"Clan ID: {clan.ClanId}");
			stringBuilder.AppendLine("Name: " + clan.Name);
			stringBuilder.AppendLine("MoTD: " + clan.Motd);
			stringBuilder.AppendLine("Members:");
			TextTable val3 = Pool.Get<TextTable>();
			try
			{
				val3.AddColumns(new string[4] { "steamID", "username", "online", "role" });
				foreach (ClanMember member in clan.Members)
				{
					ClanRole? val4 = List.TryFindWith<ClanRole, int>((IReadOnlyCollection<ClanRole>)clan.Roles, (Func<ClanRole, int>)((ClanRole r) => r.RoleId), member.RoleId, (IEqualityComparer<int>)null);
					string text = SingletonComponent<ServerMgr>.Instance.persistance.GetPlayerName(member.SteamId) ?? "[unknown]";
					bool flag = (NexusServer.Started ? NexusServer.IsOnline(member.SteamId) : ServerPlayers.IsOnline(member.SteamId));
					string[] array = new string[4];
					ulong steamId = member.SteamId;
					array[0] = steamId.ToString();
					array[1] = text;
					array[2] = (flag ? "x" : "");
					array[3] = val4?.Name ?? "[null]";
					val3.AddRow(array);
				}
				stringBuilder.Append(val3);
				return stringBuilder.ToString();
			}
			finally
			{
				((IDisposable)val3)?.Dispose();
			}
		}
		static async void SendClanInfoConsole(long id)
		{
			try
			{
				IClan val5 = await GetClanByID(id);
				if (val5 != null)
				{
					Debug.Log((object)FormatClan(val5));
				}
			}
			catch (Exception ex2)
			{
				Debug.LogException(ex2);
			}
		}
		async void SendClanInfoPlayer(BasePlayer player)
		{
			_ = 1;
			try
			{
				IClan val = ((clanId != 0L) ? (await GetClanByID(clanId)) : (await GetPlayerClan(player)));
				IClan val2 = val;
				if (val2 != null)
				{
					string msg = FormatClan(val2);
					player.ConsoleMessage(msg);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				player.ConsoleMessage(ex.ToString());
			}
		}
	}

	private static async ValueTask<IClan> GetPlayerClan(BasePlayer player)
	{
		ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.GetByMember((ulong)player.userID);
		if (!val.IsSuccess)
		{
			string msg = (((int)val.Result == 3) ? "You're not in a clan!" : "Failed to find your clan!");
			player.ConsoleMessage(msg);
			return null;
		}
		return val.Value;
	}

	private static async ValueTask<IClan> GetClanByID(long clanId, BasePlayer player = null)
	{
		ClanValueResult<IClan> val = await ClanManager.ServerInstance.Backend.Get(clanId);
		if (!val.IsSuccess)
		{
			string text = (((int)val.Result == 4) ? $"Clan with ID {clanId} was not found!" : $"Failed to get the clan with ID {clanId} ({val.Result})!");
			if ((Object)(object)player != (Object)null)
			{
				player.ConsoleMessage(text);
			}
			else
			{
				Debug.Log((object)text);
			}
			return null;
		}
		return val.Value;
	}

	public static int GetScoreForEvent(ClanScoreEventType eventType)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected I4, but got Unknown
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		return (eventType - -1) switch
		{
			1 => 1, 
			2 => scoreForKillingPlayerInOtherClan, 
			3 => scoreForKilledByPlayerInOtherClan, 
			4 => scoreForKillingUnarmedPlayer, 
			5 => scoreForDestroyingToolCupboards, 
			6 => scoreForHackingCrates, 
			7 => scoreForOpeningHackedCrates, 
			8 => scoreForDestroyingBradley, 
			9 => scoreForRunningExcavator, 
			10 => scoreForReachingCargoShip, 
			11 => scoreForLootingEliteCrate, 
			0 => 0, 
			_ => Unknown(eventType), 
		};
		static int Unknown(ClanScoreEventType type)
		{
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			Debug.LogError((object)$"Unhandled score event type: {type}");
			return 0;
		}
	}
}


[Factory("client")]
public class Client : ConsoleSystem
{
}


using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using Facepunch;
using UnityEngine;

[Factory("console")]
public class Console : ConsoleSystem
{
	[Help("Return the last x lines of the console. Default is 200")]
	[ServerVar]
	public static IEnumerable<Output.Entry> tail(Arg arg)
	{
		int @int = arg.GetInt(0, 200);
		int num = Output.HistoryOutput.Count - @int;
		if (num < 0)
		{
			num = 0;
		}
		return Output.HistoryOutput.Skip(num);
	}

	[Help("Search the console for a particular string")]
	[ServerVar]
	public static IEnumerable<Output.Entry> search(Arg arg)
	{
		string search = arg.GetString(0, (string)null);
		if (search == null)
		{
			return Enumerable.Empty<Output.Entry>();
		}
		return Output.HistoryOutput.Where((Output.Entry x) => x.Message.Length < 4096 && StringEx.Contains(x.Message, search, CompareOptions.IgnoreCase));
	}
}


[Factory("construct")]
public class Construct : ConsoleSystem
{
	[ServerVar]
	[Help("How many minutes before a placed frame gets destroyed")]
	public static float frameminutes = 30f;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Network;
using ProtoBuf;
using Rust;
using Rust.Ai.Gen2;
using UnityEngine;

[Factory("copypaste")]
public class CopyPaste : ConsoleSystem
{
	private class EntityWrapper
	{
		public BaseEntity Entity;

		public Entity Protobuf;

		public Vector3 Position;

		public Quaternion Rotation;

		public bool HasParent;
	}

	public class PasteOptions
	{
		public const string Argument_NPCs = "--npcs";

		public const string Argument_Resources = "--resources";

		public const string Argument_Vehicles = "--vehicles";

		public const string Argument_Deployables = "--deployables";

		public const string Argument_FoundationsOnly = "--foundations-only";

		public const string Argument_BuildingBlocksOnly = "--building-only";

		public const string Argument_SnapToTerrain = "--autosnap-terrain";

		public const string Argument_PastePlayers = "--players";

		public bool Resources;

		public bool NPCs;

		public bool Vehicles;

		public bool Deployables;

		public bool FoundationsOnly;

		public bool BuildingBlocksOnly;

		public bool SnapToTerrain;

		public bool Players;

		public Vector3 Origin;

		public Quaternion PlayerRotation;

		public Vector3 HeightOffset;

		public PasteOptions(Arg arg)
		{
			Resources = arg.HasArg("--resources", true);
			NPCs = arg.HasArg("--npcs", true);
			Vehicles = arg.HasArg("--vehicles", true);
			Deployables = arg.HasArg("--deployables", true);
			FoundationsOnly = arg.HasArg("--foundations-only", true);
			BuildingBlocksOnly = arg.HasArg("--building-only", true);
			SnapToTerrain = arg.HasArg("--autosnap-terrain", true);
			Players = arg.HasArg("--players", true);
		}

		public PasteOptions(PasteRequest request)
		{
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			Resources = request.resources;
			NPCs = request.npcs;
			Vehicles = request.vehicles;
			Deployables = request.deployables;
			FoundationsOnly = request.foundationsOnly;
			BuildingBlocksOnly = request.buildingBlocksOnly;
			SnapToTerrain = request.snapToTerrain;
			Players = request.players;
			Origin = request.origin;
			PlayerRotation = Quaternion.Euler(request.playerRotation);
			HeightOffset = request.heightOffset;
		}
	}

	private const string ClipboardFileName = "clipboard";

	private const string OverwriteFlag = "--overwrite";

	private static CopyPasteHistoryManager playerHistory = new CopyPasteHistoryManager();

	private static void PrintPasteNames(StringBuilder builder, string directory)
	{
		if (!Directory.Exists(directory))
		{
			builder.AppendLine("No pastes found");
			return;
		}
		string[] files = Directory.GetFiles(directory, "*.data");
		builder.AppendLine($"Found {files.Length} pastes");
		foreach (string item in files.OrderBy((string x) => x))
		{
			string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(item);
			builder.AppendLine(fileNameWithoutExtension);
		}
	}

	private static void CopyEntities(BasePlayer player, List<BaseEntity> entities, string name, Vector3 originPos, Quaternion originRot)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		OrderEntitiesForSave(entities);
		CopyPasteEntityInfo val = Pool.Get<CopyPasteEntityInfo>();
		try
		{
			val.entities = Pool.Get<List<Entity>>();
			Transform transform = new GameObject("Align").transform;
			transform.position = originPos;
			transform.rotation = originRot;
			foreach (BaseEntity entity in entities)
			{
				if (!entity.isClient && entity.enableSaving)
				{
					BaseEntity baseEntity = entity.parentEntity.Get(serverside: true);
					if ((Object)(object)baseEntity != (Object)null && (!entities.Contains(baseEntity) || !baseEntity.enableSaving))
					{
						Debug.LogWarning((object)("Skipping " + entity.ShortPrefabName + " as it is parented to an entity not included in the copy (it would become orphaned)"));
					}
					else
					{
						SaveEntity(entity, val, baseEntity, transform);
					}
				}
			}
			Object.Destroy((Object)(object)((Component)transform).gameObject);
			CopyPasteEntity.ServerInstance?.ClientRPC(RpcTarget.Player("RecievePaste", player), name, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static List<BaseEntity> PasteEntitiesInternal(CopyPasteEntityInfo toLoad, PasteOptions options)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_044a: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0500: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0520: Unknown result type (might be due to invalid IL or missing references)
		//IL_050d: Unknown result type (might be due to invalid IL or missing references)
		//IL_052d: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_05af: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_05bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_060e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0610: Unknown result type (might be due to invalid IL or missing references)
		//IL_0649: Unknown result type (might be due to invalid IL or missing references)
		//IL_064e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0650: Unknown result type (might be due to invalid IL or missing references)
		//IL_0655: Unknown result type (might be due to invalid IL or missing references)
		//IL_0685: Unknown result type (might be due to invalid IL or missing references)
		//IL_068a: Unknown result type (might be due to invalid IL or missing references)
		//IL_068c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0691: Unknown result type (might be due to invalid IL or missing references)
		toLoad = toLoad.Copy();
		Transform transform = new GameObject("Align").transform;
		transform.position = options.Origin;
		transform.rotation = options.PlayerRotation;
		List<EntityWrapper> list = new List<EntityWrapper>();
		Dictionary<ulong, ulong> remapping = new Dictionary<ulong, ulong>();
		Dictionary<uint, uint> dictionary = new Dictionary<uint, uint>();
		foreach (Entity entity in toLoad.entities)
		{
			entity.InspectUids((UidInspector<ulong>)UpdateWithNewUid);
			EntityWrapper item = new EntityWrapper
			{
				Protobuf = entity,
				HasParent = (entity.parent != null && entity.parent.uid != default(NetworkableId))
			};
			list.Add(item);
			if (entity.decayEntity != null)
			{
				if (!dictionary.TryGetValue(entity.decayEntity.buildingID, out var value))
				{
					value = BuildingManager.server.NewBuildingID();
					dictionary.Add(entity.decayEntity.buildingID, value);
				}
				entity.decayEntity.buildingID = value;
			}
		}
		foreach (EntityWrapper item2 in list)
		{
			item2.Position = item2.Protobuf.baseEntity.pos;
			item2.Rotation = Quaternion.Euler(item2.Protobuf.baseEntity.rot);
			if (!item2.HasParent)
			{
				item2.Protobuf.baseEntity.pos = transform.TransformPoint(item2.Protobuf.baseEntity.pos);
				BaseEntity baseEntity = item2.Protobuf.baseEntity;
				Quaternion val = transform.rotation * Quaternion.Euler(item2.Protobuf.baseEntity.rot);
				baseEntity.rot = ((Quaternion)(ref val)).eulerAngles;
			}
			if (CanPrefabBePasted(item2.Protobuf.baseNetworkable.prefabID, options))
			{
				item2.Entity = GameManager.server.CreateEntity(StringPool.Get(item2.Protobuf.baseNetworkable.prefabID), item2.Protobuf.baseEntity.pos, Quaternion.Euler(item2.Protobuf.baseEntity.rot));
				if (item2.Protobuf.basePlayer != null && item2.Protobuf.basePlayer.userid > 10000000)
				{
					ulong userid = 10000000uL + (ulong)Random.Range(1, int.MaxValue);
					item2.Protobuf.basePlayer.userid = userid;
				}
				item2.Entity.InitLoad(item2.Protobuf.baseNetworkable.uid);
				item2.Entity.PreServerLoad();
			}
		}
		list.RemoveAll((EntityWrapper x) => (Object)(object)x.Entity == (Object)null);
		Object.Destroy((Object)(object)((Component)transform).gameObject);
		for (int i = 0; i < list.Count; i++)
		{
			EntityWrapper entityWrapper = list[i];
			BaseNetworkable.LoadInfo info = default(BaseNetworkable.LoadInfo);
			info.fromDisk = true;
			info.fromCopy = true;
			info.msg = entityWrapper.Protobuf;
			try
			{
				entityWrapper.Entity.Spawn();
				bool flag = false;
				if (!flag && entityWrapper.Protobuf.parent != null && entityWrapper.Protobuf.parent.uid != default(NetworkableId))
				{
					BaseEntity baseEntity2 = BaseNetworkable.serverEntities.Find(entityWrapper.Protobuf.parent.uid) as BaseEntity;
					if ((Object)(object)baseEntity2 == (Object)null || baseEntity2.net == null)
					{
						flag = true;
					}
				}
				if (flag)
				{
					entityWrapper.Entity.Kill();
					list.RemoveAt(i);
					i--;
				}
				else
				{
					entityWrapper.Entity.Load(info);
				}
			}
			catch (Exception ex)
			{
				Debug.LogException(ex);
				entityWrapper.Entity.Kill();
			}
		}
		float num = float.MaxValue;
		float num2 = float.MinValue;
		RaycastHit val2 = default(RaycastHit);
		foreach (EntityWrapper item3 in list)
		{
			Vector3 position = ((Component)item3.Entity).transform.position;
			if (((Object)(object)item3.Entity.parentEntity.Get(serverside: true) == (Object)null && item3.Entity.ShortPrefabName == "foundation") || item3.Entity.ShortPrefabName == "foundation.triangle")
			{
				float num3 = TerrainMeta.HeightMap.GetHeight(position);
				if (Physics.Raycast(new Vector3(position.x, num3, position.z) + new Vector3(0f, 100f, 0f), Vector3.down, ref val2, 100f, 8454144))
				{
					num3 = ((RaycastHit)(ref val2)).point.y;
				}
				if (position.y > num3)
				{
					num = Mathf.Min(num, position.y - num3);
				}
				if (num3 > position.y)
				{
					num2 = Mathf.Max(num2, num3 - position.y);
				}
			}
		}
		if (!options.SnapToTerrain || (num == float.MaxValue && num2 == float.MinValue))
		{
			num2 = 0f;
			num = 0f;
		}
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(0f, (num < num2 || num2 == float.MinValue) ? (num * -1f) : num2, 0f);
		val3 += options.HeightOffset;
		if (val3 != Vector3.zero)
		{
			foreach (EntityWrapper item4 in list)
			{
				if ((Object)(object)item4.Entity.parentEntity.Get(serverside: true) == (Object)null)
				{
					Transform transform2 = ((Component)item4.Entity).transform;
					transform2.position += val3;
				}
				if (!(item4.Entity is IOEntity iOEntity))
				{
					continue;
				}
				if (iOEntity.inputs != null)
				{
					IOEntity.IOSlot[] inputs = iOEntity.inputs;
					foreach (IOEntity.IOSlot obj in inputs)
					{
						obj.originPosition += val3;
					}
				}
				if (iOEntity.outputs != null)
				{
					IOEntity.IOSlot[] inputs = iOEntity.outputs;
					foreach (IOEntity.IOSlot obj2 in inputs)
					{
						obj2.originPosition += val3;
					}
				}
			}
		}
		foreach (EntityWrapper item5 in list)
		{
			item5.Entity.PostServerLoad();
			item5.Entity.UpdateNetworkGroup();
		}
		foreach (EntityWrapper item6 in list)
		{
			item6.Entity.RefreshEntityLinks();
		}
		foreach (EntityWrapper item7 in list)
		{
			if (item7.Entity is BuildingBlock buildingBlock)
			{
				buildingBlock.UpdateSkin(force: true);
			}
		}
		return (from x in list
			select x.Entity into x
			where (Object)(object)x != (Object)null
			select x).ToList();
		void UpdateWithNewUid(UidType type, ref ulong prevUid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			if ((int)type == 3)
			{
				prevUid = 0uL;
			}
			else if (prevUid != 0L)
			{
				if (!remapping.TryGetValue(prevUid, out var value2))
				{
					value2 = Net.sv.TakeUID();
					remapping.Add(prevUid, value2);
				}
				prevUid = value2;
			}
		}
	}

	private static void SaveEntity(BaseEntity baseEntity, CopyPasteEntityInfo toSave, BaseEntity parent, Transform alignObject)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		BaseNetworkable.SaveInfo info = default(BaseNetworkable.SaveInfo);
		info.forDisk = true;
		info.msg = Pool.Get<Entity>();
		baseEntity.Save(info);
		if ((Object)(object)parent == (Object)null)
		{
			info.msg.baseEntity.pos = alignObject.InverseTransformPoint(info.msg.baseEntity.pos);
			_ = alignObject.rotation * ((Component)baseEntity).transform.rotation;
			BaseEntity baseEntity2 = info.msg.baseEntity;
			Quaternion val = Quaternion.Inverse(((Component)alignObject).transform.rotation) * ((Component)baseEntity).transform.rotation;
			baseEntity2.rot = ((Quaternion)(ref val)).eulerAngles;
		}
		toSave.entities.Add(info.msg);
	}

	private static void GetEntitiesLookingAt(Vector3 originPoint, Vector3 direction, List<BaseEntity> entityList)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		entityList.Clear();
		BuildingBlock buildingBlock = GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, new Ray(originPoint, direction), 0f, 100f, 2097408, (QueryTriggerInteraction)0) as BuildingBlock;
		if (!((Object)(object)buildingBlock == (Object)null))
		{
			ListHashSet<DecayEntity> val = buildingBlock.GetBuilding()?.decayEntities;
			if (val != null)
			{
				entityList.AddRange((IEnumerable<BaseEntity>)val);
			}
		}
	}

	private static void GetEntitiesInRadius(Vector3 originPoint, float radius, List<BaseEntity> entityList)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (radius <= 0f)
		{
			return;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(originPoint, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient)
			{
				entityList.Add(item);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static void GetEntitiesInBounds(Bounds bounds, List<BaseEntity> entityList)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		OBB bounds2 = new OBB(bounds);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(bounds2, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient)
			{
				entityList.Add(item);
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static bool CanPrefabBePasted(uint prefabId, PasteOptions options)
	{
		GameObject val = GameManager.server.FindPrefab(prefabId);
		if ((Object)(object)val == (Object)null)
		{
			return false;
		}
		BaseEntity component = val.GetComponent<BaseEntity>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		if (options.FoundationsOnly && component.ShortPrefabName != "foundation" && component.ShortPrefabName != "foundation.triangle")
		{
			return false;
		}
		if (options.BuildingBlocksOnly && !(component is BuildingBlock))
		{
			return false;
		}
		if (component is DecayEntity && !(component is BuildingBlock) && !options.Deployables)
		{
			return false;
		}
		if (component is BasePlayer { IsNpc: false } && !options.Players)
		{
			return false;
		}
		if (component is PointEntity || component is RelationshipManager)
		{
			return false;
		}
		if ((component is ResourceEntity || component is BushEntity) && !options.Resources)
		{
			return false;
		}
		if ((component is BaseNpc || component is RidableHorse) && !options.NPCs)
		{
			return false;
		}
		if (component is BaseVehicle && !(component is RidableHorse) && !options.Vehicles)
		{
			return false;
		}
		return true;
	}

	private static void OrderEntitiesForSave(List<BaseEntity> entities)
	{
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		list.AddRange(entities);
		entities.Clear();
		HashSet<BaseEntity> hash = new HashSet<BaseEntity>();
		foreach (BaseEntity item in list.OrderBy((BaseEntity x) => x.net.ID.Value))
		{
			AddRecursive(item);
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		void AddRecursive(BaseEntity current)
		{
			if (hash.Add(current))
			{
				entities.Add(current);
				if (current.children != null)
				{
					foreach (BaseEntity child in current.children)
					{
						AddRecursive(child);
					}
				}
			}
		}
	}

	[ServerVar(Name = "copybox_sv")]
	public static void copybox_sv(Arg args)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Missing args: copybox_sv <name> <center> <size> <rotation>");
			return;
		}
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		Vector3 vector2 = args.GetVector3(2, default(Vector3));
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		Bounds bounds = new Bounds(vector, vector2);
		List<BaseEntity> list = Pool.GetList<BaseEntity>();
		GetEntitiesInBounds(bounds, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeList<BaseEntity>(ref list);
	}

	public static List<BaseEntity> PasteEntities(CopyPasteEntityInfo data, PasteOptions options, ulong steamId)
	{
		List<BaseEntity> list;
		try
		{
			Application.isLoadingSave = true;
			Application.isLoading = true;
			list = PasteEntitiesInternal(data, options);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return new List<BaseEntity>();
		}
		finally
		{
			Application.isLoadingSave = false;
			Application.isLoading = false;
		}
		foreach (BaseEntity item in list)
		{
			if (!((Object)(object)item == (Object)null) && item is StabilityEntity stabilityEntity)
			{
				stabilityEntity.UpdateStability();
			}
		}
		playerHistory.AddToHistory(steamId, list);
		return list;
	}

	[ServerVar]
	public static void undopaste_sv(Arg args)
	{
		ulong steamId = args.Player()?.userID ?? ((EncryptedValue<ulong>)0uL);
		PasteResult pasteResult = playerHistory.Undo(steamId);
		if (pasteResult == null)
		{
			args.ReplyWith("History empty");
			return;
		}
		foreach (BaseEntity entity in pasteResult.Entities)
		{
			entity.Kill();
		}
	}

	[ServerVar]
	public static void copyradius_sv(Arg args)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		float @float = args.GetFloat(2, 0f);
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		if (@float <= 0f)
		{
			args.ReplyWith("Invalid radius: must be greater than zero");
			return;
		}
		GetEntitiesInRadius(vector, @float, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	[ServerVar]
	public static void copybuilding_sv(Arg args)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		string @string = args.GetString(0, "");
		Vector3 vector = args.GetVector3(1, default(Vector3));
		Vector3 vector2 = args.GetVector3(2, default(Vector3));
		Quaternion originRot = Quaternion.Euler(args.GetVector3(3, default(Vector3)));
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		GetEntitiesLookingAt(vector, vector2, list);
		CopyEntities(args.Player(), list, @string, vector, originRot);
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	[ServerVar]
	public static void printselection_sv(Arg args)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vector3 vector = args.GetVector3(0, default(Vector3));
		Vector3 vector2 = args.GetVector3(1, default(Vector3));
		args.GetVector3(2, default(Vector3));
		GetEntitiesInBounds(new Bounds(vector, vector2), list);
		StringBuilder stringBuilder = new StringBuilder();
		if (list.Count == 0)
		{
			stringBuilder.AppendLine("Empty");
		}
		else
		{
			foreach (BaseEntity item in list)
			{
				if (!item.isClient)
				{
					stringBuilder.AppendLine(((Object)item).name);
				}
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		args.ReplyWith(stringBuilder.ToString());
	}

	private static string GetLegacyServerDirectory()
	{
		return ConVar.Server.GetServerFolder("copypaste");
	}

	private static string GetLegacyServerPath(string name)
	{
		return GetLegacyServerDirectory() + "/" + name + ".data";
	}

	[ServerVar]
	public static void download_paste(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Missing args: download_paste <name>");
			return;
		}
		string @string = arg.GetString(0, "");
		string legacyServerPath = GetLegacyServerPath(arg.GetString(0, ""));
		if (!File.Exists(legacyServerPath))
		{
			arg.ReplyWith("Paste '" + @string + "' not found");
			return;
		}
		CopyPasteEntityInfo val = CopyPasteEntityInfo.Deserialize(File.ReadAllBytes(legacyServerPath));
		try
		{
			CopyPasteEntity.ServerInstance.ClientRPC(RpcTarget.Player("RecievePaste", arg.Connection), @string, val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void list_pastes_sv(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		PrintPasteNames(stringBuilder, GetLegacyServerDirectory());
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void killbox_sv(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = args.GetVector3(0, default(Vector3));
		Vector3 vector2 = args.GetVector3(1, default(Vector3));
		PasteOptions options = new PasteOptions(args);
		Bounds bounds = new Bounds(vector, vector2);
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		GetEntitiesInBounds(bounds, list);
		foreach (BaseEntity item in list)
		{
			if (!item.isClient && CanPrefabBePasted(item.prefabID, options) && (!(item is BasePlayer entity) || entity.IsNpcPlayer()))
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
	}

	private static Quaternion GetPlayerRotation(BasePlayer ply)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ply.eyes.BodyForward();
		val.y = 0f;
		return Quaternion.LookRotation(val, Vector3.up);
	}
}


using ProtoBuf;
using UnityEngine;

private class EntityWrapper
{
	public BaseEntity Entity;

	public Entity Protobuf;

	public Vector3 Position;

	public Quaternion Rotation;

	public bool HasParent;
}


using ProtoBuf;
using UnityEngine;

public class PasteOptions
{
	public const string Argument_NPCs = "--npcs";

	public const string Argument_Resources = "--resources";

	public const string Argument_Vehicles = "--vehicles";

	public const string Argument_Deployables = "--deployables";

	public const string Argument_FoundationsOnly = "--foundations-only";

	public const string Argument_BuildingBlocksOnly = "--building-only";

	public const string Argument_SnapToTerrain = "--autosnap-terrain";

	public const string Argument_PastePlayers = "--players";

	public bool Resources;

	public bool NPCs;

	public bool Vehicles;

	public bool Deployables;

	public bool FoundationsOnly;

	public bool BuildingBlocksOnly;

	public bool SnapToTerrain;

	public bool Players;

	public Vector3 Origin;

	public Quaternion PlayerRotation;

	public Vector3 HeightOffset;

	public PasteOptions(Arg arg)
	{
		Resources = arg.HasArg("--resources", true);
		NPCs = arg.HasArg("--npcs", true);
		Vehicles = arg.HasArg("--vehicles", true);
		Deployables = arg.HasArg("--deployables", true);
		FoundationsOnly = arg.HasArg("--foundations-only", true);
		BuildingBlocksOnly = arg.HasArg("--building-only", true);
		SnapToTerrain = arg.HasArg("--autosnap-terrain", true);
		Players = arg.HasArg("--players", true);
	}

	public PasteOptions(PasteRequest request)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		Resources = request.resources;
		NPCs = request.npcs;
		Vehicles = request.vehicles;
		Deployables = request.deployables;
		FoundationsOnly = request.foundationsOnly;
		BuildingBlocksOnly = request.buildingBlocksOnly;
		SnapToTerrain = request.snapToTerrain;
		Players = request.players;
		Origin = request.origin;
		PlayerRotation = Quaternion.Euler(request.playerRotation);
		HeightOffset = request.heightOffset;
	}
}


using System.Collections.Generic;

public class PasteResult
{
	public List<BaseEntity> Entities;

	public PasteResult(List<BaseEntity> entities)
	{
		Entities = entities;
	}
}


using System.Collections.Generic;
using System.Linq;
using ConVar;

public class CopyPasteHistoryManager
{
	public class PlayerHistory
	{
		public ulong SteamId;

		public List<PasteResult> History = new List<PasteResult>();

		public int CurrentIndex = -1;

		public PlayerHistory(ulong steamId)
		{
			SteamId = steamId;
		}
	}

	private List<PlayerHistory> playerHistory = new List<PlayerHistory>();

	public PlayerHistory GetOrCreateHistory(ulong steamId)
	{
		PlayerHistory playerHistory = this.playerHistory.FirstOrDefault((PlayerHistory x) => x.SteamId == steamId);
		if (playerHistory == null)
		{
			playerHistory = new PlayerHistory(steamId);
			this.playerHistory.Add(playerHistory);
		}
		return playerHistory;
	}

	public void AddToHistory(ulong steamId, List<BaseEntity> entities)
	{
		PlayerHistory orCreateHistory = GetOrCreateHistory(steamId);
		int num = orCreateHistory.History.Count - orCreateHistory.CurrentIndex - 1;
		if (num > 0)
		{
			orCreateHistory.History.RemoveRange(orCreateHistory.CurrentIndex + 1, num);
		}
		orCreateHistory.History.Add(new PasteResult(entities));
		orCreateHistory.CurrentIndex = orCreateHistory.History.Count - 1;
	}

	public PasteResult Undo(ulong steamId)
	{
		PlayerHistory orCreateHistory = GetOrCreateHistory(steamId);
		if (orCreateHistory.CurrentIndex < 0)
		{
			return null;
		}
		orCreateHistory.CurrentIndex--;
		return orCreateHistory.History[orCreateHistory.CurrentIndex + 1];
	}
}


using System.Collections.Generic;

public class PlayerHistory
{
	public ulong SteamId;

	public List<PasteResult> History = new List<PasteResult>();

	public int CurrentIndex = -1;

	public PlayerHistory(ulong steamId)
	{
		SteamId = steamId;
	}
}


using UnityEngine;

[Factory("craft")]
public class Craft : ConsoleSystem
{
	[ServerVar]
	public static bool instant;

	[ServerUserVar]
	public static void add(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || basePlayer.IsDead())
		{
			return;
		}
		int @int = args.GetInt(0, 0);
		int int2 = args.GetInt(1, 1);
		int num = (int)args.GetUInt64(2, 0uL);
		bool @bool = args.GetBool(3, false);
		if (int2 < 1)
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(@int);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			args.ReplyWith("Item not found");
			return;
		}
		ItemBlueprint itemBlueprint = ItemManager.FindBlueprint(itemDefinition);
		if (!Object.op_Implicit((Object)(object)itemBlueprint))
		{
			args.ReplyWith("Blueprint not found");
			return;
		}
		if (!itemBlueprint.userCraftable)
		{
			args.ReplyWith("Item is not craftable");
			return;
		}
		if (!basePlayer.blueprints.CanCraft(@int, num, basePlayer.userID))
		{
			num = 0;
			if (!basePlayer.blueprints.CanCraft(@int, num, basePlayer.userID))
			{
				args.ReplyWith("You can't craft this item");
				return;
			}
			args.ReplyWith("You don't have permission to use this skin, so crafting unskinned");
		}
		int num2 = int2;
		int num3 = int2;
		if (@bool)
		{
			num2 = Mathf.Min(int2, 5);
			num3 = 1;
		}
		for (int num4 = num2; num4 >= num3; num4--)
		{
			if (basePlayer.inventory.crafting.CraftItem(itemBlueprint, basePlayer, null, num4, num))
			{
				return;
			}
		}
		args.ReplyWith("Couldn't craft!");
	}

	[ServerUserVar]
	public static void canceltask(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			if (!basePlayer.inventory.crafting.CancelTask(@int))
			{
				args.ReplyWith("Couldn't cancel task!");
			}
		}
	}

	[ServerUserVar]
	public static void cancel(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			basePlayer.inventory.crafting.CancelBlueprint(@int);
		}
	}

	[ServerUserVar]
	public static void fasttracktask(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead())
		{
			int @int = args.GetInt(0, 0);
			if (!basePlayer.inventory.crafting.FastTrackTask(@int))
			{
				args.ReplyWith("Couldn't fast track task!");
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class Creative : ConsoleSystem
{
	[ReplicatedVar(Help = "Apply creative mode to the entire server", Saved = true)]
	public static bool allUsers;

	[ServerVar(Saved = true)]
	public static bool alwaysOnEnabled;

	[ReplicatedVar(Help = "Bypass the 30s repair cooldown when repairing objects", Saved = true)]
	public static bool freeRepair;

	[ReplicatedVar(Help = "Build blocks for free", Saved = true)]
	public static bool freeBuild;

	[ReplicatedVar(Help = "Bypasses all placement checks", Saved = true)]
	public static bool freePlacement;

	[ReplicatedVar(Help = "Bypasses bypassHoldToPlaceDuration when deploying items", Saved = true)]
	public static bool bypassHoldToPlaceDuration;

	[ReplicatedVar(Help = "Bypasses limits on IO length and points", Saved = true)]
	public static bool unlimitedIo;

	[ServerVar]
	public static void toggleCreativeModeUser(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		bool @bool = arg.GetBool(1, false);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Invalid player provided " + arg.GetString(0, ""));
			return;
		}
		player.SetPlayerFlag(BasePlayer.PlayerFlags.CreativeMode, @bool);
		arg.ReplyWith($"{player.displayName} creative mode: {@bool}");
	}

	[ServerVar]
	public static void toggleAlwaysOnAll(Arg arg)
	{
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInCreativeMode)
		{
			return;
		}
		bool @bool = arg.GetBool(0, false);
		BaseCombatEntity[] array = BaseEntity.Util.FindAll<BaseCombatEntity>();
		foreach (BaseCombatEntity baseCombatEntity in array)
		{
			if (!baseCombatEntity.isClient && baseCombatEntity is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
	}

	[ServerUserVar(ServerAdmin = true)]
	public static void toggleAlwaysOnRadius(Arg arg)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInCreativeMode)
		{
			return;
		}
		bool @bool = arg.GetBool(0, false);
		float radius = Mathf.Clamp(arg.GetFloat(1, 0f), 0f, 100f);
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		Vis.Entities(((Component)basePlayer).transform.position, radius, list, -1, (QueryTriggerInteraction)2);
		foreach (BaseCombatEntity item in list)
		{
			if (!item.isClient && item is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
	}

	[ServerUserVar(ServerAdmin = true)]
	public static void toggleAlwaysOn(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (!alwaysOnEnabled)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && basePlayer.IsInCreativeMode)
		{
			bool @bool = arg.GetBool(0, false);
			RaycastHit hit = default(RaycastHit);
			if (Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 1218652417, (QueryTriggerInteraction)1) && hit.GetEntity() is IAlwaysOn alwaysOn)
			{
				alwaysOn.SetAlwaysOn(@bool);
			}
		}
	}
}


[Factory("culling")]
public class Culling : ConsoleSystem
{
}


using System.IO;
using UnityEngine;

[Factory("data")]
public class Data : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static void export(Arg args)
	{
		string @string = args.GetString(0, "none");
		string text = Path.Combine(Application.persistentDataPath, @string + ".raw");
		switch (@string)
		{
		case "splatmap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.SplatMap))
			{
				RawWriter.Write(TerrainMeta.SplatMap.ToEnumerable(), text);
			}
			break;
		case "heightmap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.HeightMap))
			{
				RawWriter.Write(TerrainMeta.HeightMap.ToEnumerable(), text);
			}
			break;
		case "biomemap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.BiomeMap))
			{
				RawWriter.Write(TerrainMeta.BiomeMap.ToEnumerable(), text);
			}
			break;
		case "topologymap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.TopologyMap))
			{
				RawWriter.Write(TerrainMeta.TopologyMap.ToEnumerable(), text);
			}
			break;
		case "alphamap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.AlphaMap))
			{
				RawWriter.Write(TerrainMeta.AlphaMap.ToEnumerable(), text);
			}
			break;
		case "watermap":
			if (Object.op_Implicit((Object)(object)TerrainMeta.WaterMap))
			{
				RawWriter.Write(TerrainMeta.WaterMap.ToEnumerable(), text);
			}
			break;
		default:
			args.ReplyWith("Unknown export source: " + @string);
			return;
		}
		args.ReplyWith("Export written to " + text);
	}
}


public class DDraw
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using ConVar;
using Development.Attributes;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Unity;
using Oxide.Core;
using Rust;
using Rust.Ai;
using UnityEngine;

[Factory("debug")]
[ResetStaticFields]
public class Debugging : ConsoleSystem
{
	private const string NO_RECOVER_ARG = "--no-recover";

	[ServerVar]
	[ClientVar]
	public static bool checktriggers = false;

	[ServerVar]
	public static bool checkparentingtriggers = true;

	[ClientVar(Saved = false, Help = "Shows some debug info for dismount attempts.")]
	[ServerVar]
	public static bool DebugDismounts = false;

	[ServerVar(Help = "Do not damage any items")]
	public static bool disablecondition = false;

	[ServerVar]
	public static int tutorial_start_cooldown = 60;

	[ServerVar]
	public static bool printMissionSpeakInfo = false;

	private static HashSet<BasePlayer> invisiblePlayers = new HashSet<BasePlayer>();

	[ClientVar]
	[ServerVar]
	public static bool callbacks = false;

	[ServerVar]
	[ClientVar]
	public static bool log
	{
		get
		{
			return Debug.unityLogger.logEnabled;
		}
		set
		{
			Debug.unityLogger.logEnabled = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	[ServerVar]
	public static void renderinfo(Arg arg)
	{
		RenderInfo.GenerateReport();
	}

	[ServerVar]
	public static void enable_player_movement(Arg arg)
	{
		if (arg.IsAdmin)
		{
			bool @bool = arg.GetBool(0, true);
			BasePlayer basePlayer = arg.Player();
			if ((Object)(object)basePlayer == (Object)null)
			{
				arg.ReplyWith("Must be called from client with player model");
				return;
			}
			basePlayer.ClientRPC(RpcTarget.Player("TogglePlayerMovement", basePlayer), @bool);
			arg.ReplyWith((@bool ? "enabled" : "disabled") + " player movement");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void stall(Arg arg)
	{
		float num = Mathf.Clamp(arg.GetFloat(0, 0f), 0f, 1f);
		arg.ReplyWith("Stalling for " + num + " seconds...");
		Thread.Sleep(Mathf.RoundToInt(num * 1000f));
	}

	[ServerVar(Help = "Repair all items in inventory")]
	public static void repair_inventory(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		List<Item> list = Pool.Get<List<Item>>();
		basePlayer.inventory.GetAllItems(list);
		foreach (Item item in list)
		{
			if (item != null)
			{
				item.maxCondition = item.info.condition.max;
				item.condition = item.maxCondition;
				item.MarkDirty();
			}
			if (item.contents == null)
			{
				continue;
			}
			foreach (Item item2 in item.contents.itemList)
			{
				item2.maxCondition = item2.info.condition.max;
				item2.condition = item2.maxCondition;
				item2.MarkDirty();
			}
		}
		Pool.Free<Item>(ref list, false);
	}

	[ServerVar]
	public static void spawnParachuteTester(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, 50f);
		BasePlayer basePlayer = arg.Player();
		BasePlayer basePlayer2 = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", ((Component)basePlayer).transform.position + Vector3.up * @float, Quaternion.LookRotation(basePlayer.eyes.BodyForward())) as BasePlayer;
		basePlayer2.Spawn();
		basePlayer2.eyes.rotation = basePlayer.eyes.rotation;
		basePlayer2.SendNetworkUpdate();
		Inventory.copyTo(basePlayer, basePlayer2);
		if (!basePlayer2.HasValidParachuteEquipped())
		{
			basePlayer2.inventory.containerWear.GiveItem(ItemManager.CreateByName("parachute", 1, 0uL));
		}
		basePlayer2.RequestParachuteDeploy();
	}

	[ServerVar]
	public static string testTutorialCinematic(Arg arg)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsInTutorial)
		{
			return "Requires a player";
		}
		TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland == (Object)null)
		{
			return "Invalid island";
		}
		Transform val = TransformEx.FindChildRecursive(((Component)currentTutorialIsland).transform, "KayakMissionPoint");
		if ((Object)(object)val == (Object)null)
		{
			return "Can't find KayakMissionPoint on island";
		}
		Kayak obj = GameManager.server.CreateEntity("assets/content/vehicles/boats/kayak/kayak.prefab", val.position, val.rotation) as Kayak;
		obj.Spawn();
		obj.WantsMount(basePlayer);
		currentTutorialIsland.StartEndingCinematic(basePlayer);
		return "Playing cinematic";
	}

	[ServerVar(Help = "If a player ends up stuck on a tutorial for any reason this will clear the island and reset the player (will also kill player)")]
	public static void clearTutorialForPlayer(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Please provide a player");
		}
		else if (player.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = player.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.Return();
			}
			player.ClearTutorial();
			player.Hurt(99999f);
			player.ClearTutorial_PostDeath();
		}
	}

	[ServerVar]
	public static void deleteEntitiesByShortname(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		string text = arg.GetString(0, "").ToLower();
		float @float = arg.GetFloat(1, 0f);
		BasePlayer basePlayer = arg.Player();
		PooledList<BaseNetworkable> val = Pool.Get<PooledList<BaseNetworkable>>();
		try
		{
			Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					BaseNetworkable current = enumerator.Current;
					if (current.ShortPrefabName == text && (@float == 0f || ((Object)(object)basePlayer != (Object)null && basePlayer.Distance(current as BaseEntity) <= @float)))
					{
						((List<BaseNetworkable>)(object)val).Add(current);
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			Debug.Log((object)$"Deleting {((List<BaseNetworkable>)(object)val).Count} {text}...");
			foreach (BaseNetworkable item in (List<BaseNetworkable>)(object)val)
			{
				item.Kill();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void deleteEntityById(Arg arg)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < arg.Args.Length; i++)
		{
			NetworkableId entityID = arg.GetEntityID(i);
			BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(entityID);
			if ((Object)(object)baseNetworkable != (Object)null)
			{
				stringBuilder.AppendLine($"Deleting {baseNetworkable}");
				baseNetworkable.Kill();
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void printgroups(Arg arg)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Server");
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				Debug.Log((object)string.Format("{0}:{1}{2}", current.PrefabName, current.net.group.ID, current.net.group.restricted ? "/Restricted" : string.Empty));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Takes you in and out of your current network group, causing you to delete and then download all entities in your PVS again")]
	public static void flushgroup(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			basePlayer.net.SwitchGroup(BaseNetworkable.LimboNetworkGroup);
			basePlayer.UpdateNetworkGroup();
		}
	}

	[ServerVar(Help = "Break the current held object")]
	public static void breakheld(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		activeItem?.LoseCondition(activeItem.condition * 2f);
	}

	[ServerVar(Help = "Breaks the currently held shield")]
	public static void breakshield(Arg arg)
	{
		if (arg.Player().GetActiveShield(out var foundShield) && foundShield.GetItem() != null)
		{
			foundShield.GetItem().LoseCondition(999f);
		}
	}

	[ServerVar(Help = "Almost break the current held object")]
	public static void breakheld_almost(Arg arg)
	{
		Item activeItem = arg.Player().GetActiveItem();
		if (activeItem != null && activeItem.hasCondition)
		{
			activeItem.condition = 1f;
		}
	}

	[ServerVar(Help = "reset all puzzles")]
	public static void puzzlereset(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)arg.Player() == (Object)null))
		{
			PuzzleReset[] array = Object.FindObjectsOfType<PuzzleReset>();
			Debug.Log((object)"iterating...");
			PuzzleReset[] array2 = array;
			foreach (PuzzleReset puzzleReset in array2)
			{
				Vector3 position = ((Component)puzzleReset).transform.position;
				Debug.Log((object)("resetting puzzle at :" + ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString()));
				puzzleReset.DoReset();
				puzzleReset.ResetTimer();
			}
		}
	}

	[ServerVar(EditorOnly = true, Help = "respawn all puzzles from their prefabs")]
	public static void puzzleprefabrespawn(Arg arg)
	{
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		foreach (BaseNetworkable item in BaseNetworkable.serverEntities.Where((BaseNetworkable x) => x is IOEntity && PrefabAttribute.server.Find<Construction>(x.prefabID) == null).ToList())
		{
			item.Kill();
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			GameObject val = GameManager.server.FindPrefab(((Object)((Component)monument).gameObject).name);
			if ((Object)(object)val == (Object)null)
			{
				continue;
			}
			Dictionary<IOEntity, IOEntity> dictionary = new Dictionary<IOEntity, IOEntity>();
			IOEntity[] componentsInChildren = val.GetComponentsInChildren<IOEntity>(true);
			foreach (IOEntity iOEntity in componentsInChildren)
			{
				Quaternion rot = ((Component)monument).transform.rotation * ((Component)iOEntity).transform.rotation;
				Vector3 pos = ((Component)monument).transform.TransformPoint(((Component)iOEntity).transform.position);
				BaseEntity newEntity = GameManager.server.CreateEntity(iOEntity.PrefabName, pos, rot);
				IOEntity iOEntity2 = newEntity as IOEntity;
				if (!((Object)(object)iOEntity2 != (Object)null))
				{
					continue;
				}
				dictionary.Add(iOEntity, iOEntity2);
				DoorManipulator doorManipulator = newEntity as DoorManipulator;
				if ((Object)(object)doorManipulator != (Object)null)
				{
					List<Door> list = Pool.Get<List<Door>>();
					Vis.Entities(((Component)newEntity).transform.position, 10f, list, -1, (QueryTriggerInteraction)2);
					Door door = list.OrderBy((Door x) => x.Distance(((Component)newEntity).transform.position)).FirstOrDefault();
					if ((Object)(object)door != (Object)null)
					{
						doorManipulator.targetDoor = door;
					}
					Pool.FreeUnmanaged<Door>(ref list);
				}
				CardReader cardReader = newEntity as CardReader;
				if ((Object)(object)cardReader != (Object)null)
				{
					CardReader cardReader2 = iOEntity as CardReader;
					if ((Object)(object)cardReader2 != (Object)null)
					{
						cardReader.accessLevel = cardReader2.accessLevel;
						cardReader.accessDuration = cardReader2.accessDuration;
					}
				}
				TimerSwitch timerSwitch = newEntity as TimerSwitch;
				if ((Object)(object)timerSwitch != (Object)null)
				{
					TimerSwitch timerSwitch2 = iOEntity as TimerSwitch;
					if ((Object)(object)timerSwitch2 != (Object)null)
					{
						timerSwitch.timerLength = timerSwitch2.timerLength;
					}
				}
			}
			foreach (KeyValuePair<IOEntity, IOEntity> item2 in dictionary)
			{
				IOEntity key = item2.Key;
				IOEntity value = item2.Value;
				for (int j = 0; j < key.outputs.Length; j++)
				{
					if (!((Object)(object)key.outputs[j].connectedTo.ioEnt == (Object)null))
					{
						value.outputs[j].connectedTo.ioEnt = dictionary[key.outputs[j].connectedTo.ioEnt];
						value.outputs[j].connectedToSlot = key.outputs[j].connectedToSlot;
					}
				}
			}
			foreach (IOEntity value2 in dictionary.Values)
			{
				value2.Spawn();
			}
		}
	}

	[ServerVar(Help = "Break all the items in your inventory whose name match the passed string")]
	public static void breakitem(Arg arg)
	{
		string @string = arg.GetString(0, "");
		foreach (Item item in arg.Player().inventory.containerMain.itemList)
		{
			if (StringEx.Contains(item.info.shortname, @string, CompareOptions.IgnoreCase) && item.hasCondition)
			{
				item.LoseCondition(item.condition * 2f);
			}
		}
	}

	[ServerVar(ClientAdmin = true, Help = "Refills the vital of a target player. eg. debug.refillsvital jim - leave blank to target yourself, can take multiple players at once. Will revive players if they are injured. To disable this, pass in --no-recover as the first argument.")]
	public static void refillvitals(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int num = 0;
		bool shouldPlayerRecover = true;
		if (arg.GetString(0, "") == "--no-recover")
		{
			shouldPlayerRecover = false;
			num++;
		}
		arg.TryRemoveKeyBindEventArgs();
		if (arg.Args == null || num >= arg.Args.Length)
		{
			RefillPlayerVitals(basePlayer, shouldPlayerRecover);
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = num; i < arg.Args.Length; i++)
		{
			string @string = arg.GetString(i, "");
			BasePlayer basePlayer2 = ((!(@string == basePlayer.displayName)) ? (string.IsNullOrEmpty(@string) ? null : arg.GetPlayerOrSleeperOrBot(i)) : basePlayer);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				stringBuilder.AppendLine("Could not find player '" + @string + "'");
				continue;
			}
			RefillPlayerVitals(basePlayer2, shouldPlayerRecover);
			stringBuilder.AppendLine("Refilled '" + @string + "' vitals");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar(ClientAdmin = true, Help = "Refills the vitals of all active players on the server. Will revive players if they are injured. To disable this, pass in --no-recover as the first argument.")]
	public static void refillvitalsall(Arg arg)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		bool shouldPlayerRecover = arg.GetString(0, "") != "--no-recover";
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					RefillPlayerVitals(current, shouldPlayerRecover);
					stringBuilder.AppendLine("Refilled player '" + current.displayName + "' vitals");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current2 = enumerator.Current;
				if (!((Object)(object)current2 == (Object)null))
				{
					RefillPlayerVitals(current2, shouldPlayerRecover);
					stringBuilder.AppendLine("Refilled bot '" + current2.displayName + "' vitals");
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void RefillPlayerVitals(BasePlayer player, bool shouldPlayerRecover)
	{
		if (shouldPlayerRecover && player.IsWounded())
		{
			player.StopWounded();
		}
		AdjustHealth(player, 1000f);
		AdjustCalories(player, 1000f);
		AdjustHydration(player, 1000f);
		AdjustRadiation(player, -10000f);
		AdjustBleeding(player, -10000f);
	}

	[ServerVar(Help = "To disable revival if player is downed, pass in --no-recover as the first argument.")]
	public static void heal(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		bool flag = true;
		int num = 0;
		if (arg.GetString(0, "") == "--no-recover")
		{
			flag = false;
			num++;
		}
		if (flag && basePlayer.IsWounded())
		{
			basePlayer.StopWounded();
		}
		AdjustHealth(basePlayer, arg.GetInt(num, 1));
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		int @int = arg.GetInt(0, 1);
		string @string = arg.GetString(1, string.Empty);
		HitInfo hitInfo = new HitInfo(basePlayer, basePlayer, DamageType.Bullet, @int);
		if (!string.IsNullOrEmpty(@string))
		{
			hitInfo.HitBone = StringPool.Get(@string);
		}
		basePlayer.OnAttacked(hitInfo);
	}

	[ServerVar]
	public static void eat(Arg arg)
	{
		AdjustCalories(arg.Player(), arg.GetInt(0, 1), arg.GetInt(1, 1));
	}

	[ServerVar]
	public static void drink(Arg arg)
	{
		AdjustHydration(arg.Player(), arg.GetInt(0, 1), arg.GetInt(1, 1));
	}

	[ServerVar]
	public static void sethealth(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.SetHealth(@int);
		}
	}

	[ServerVar]
	public static void setmaxhealth(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.SetMaxHealth(@int);
		}
	}

	[ServerVar]
	public static void setdamage(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			float damageAmount = usePlayer.health - (float)@int;
			HitInfo info = new HitInfo(basePlayer, basePlayer, DamageType.Bullet, damageAmount);
			usePlayer.OnAttacked(info);
		}
	}

	[ServerVar]
	public static void setfood(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Calories);
	}

	[ServerVar]
	public static void setwater(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Hydration);
	}

	[ServerVar]
	public static void setradiation(Arg arg)
	{
		setattribute(arg, MetabolismAttribute.Type.Radiation);
	}

	private static void AdjustHealth(BasePlayer player, float amount, string bone = null)
	{
		player.health += amount;
	}

	private static void AdjustCalories(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.ApplyChange(MetabolismAttribute.Type.Calories, amount, time);
	}

	private static void AdjustHydration(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.ApplyChange(MetabolismAttribute.Type.Hydration, amount, time);
	}

	private static void AdjustRadiation(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.SetAttribute(MetabolismAttribute.Type.Radiation, amount);
	}

	private static void AdjustBleeding(BasePlayer player, float amount, float time = 1f)
	{
		player.metabolism.SetAttribute(MetabolismAttribute.Type.Bleeding, amount);
	}

	private static void setattribute(Arg arg, MetabolismAttribute.Type type)
	{
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Please enter an amount.");
			return;
		}
		int @int = arg.GetInt(0, 0);
		BasePlayer usePlayer = GetUsePlayer(arg, 1);
		if (Object.op_Implicit((Object)(object)usePlayer))
		{
			usePlayer.metabolism.SetAttribute(type, @int);
		}
	}

	private static BasePlayer GetUsePlayer(Arg arg, int playerArgument)
	{
		BasePlayer basePlayer = null;
		if (arg.HasArgs(playerArgument + 1))
		{
			BasePlayer player = arg.GetPlayer(playerArgument);
			if (!Object.op_Implicit((Object)(object)player))
			{
				return null;
			}
			return player;
		}
		return arg.Player();
	}

	[ServerVar]
	public static void ResetSleepingBagTimers(Arg arg)
	{
		SleepingBag.ResetTimersForPlayer(arg.Player());
	}

	[ServerVar(Help = "Deducts the given number of hours from all spoilable food on the server")]
	public static void FoodSpoilingDeductTimeHours(Arg arg)
	{
		ItemModFoodSpoiling.DeductTimeFromAll(TimeSpan.FromHours(arg.GetFloat(0, 0f)));
	}

	[ServerVar(Help = "Spoils all food on the server")]
	public static void FoodSpoilingSpoilAll()
	{
		ItemModFoodSpoiling.DeductTimeFromAll(TimeSpan.MaxValue);
	}

	[ServerVar(Help = "Applies the given number of hours to all food in the players inventory")]
	public static void FoodSpoilingInventoryHours(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		PooledList<Item> spoilList = Pool.Get<PooledList<Item>>();
		try
		{
			FindSpoilableItems(basePlayer.inventory.containerMain.itemList);
			FindSpoilableItems(basePlayer.inventory.containerBelt.itemList);
			foreach (Item item in (List<Item>)(object)spoilList)
			{
				ItemModFoodSpoiling.FoodSpoilingWorkQueue.DeductTimeFromFoodItem(item, (float)@int * 60f * 60f, setDirty: true);
			}
		}
		finally
		{
			if (spoilList != null)
			{
				((IDisposable)spoilList).Dispose();
			}
		}
		void FindSpoilableItems(List<Item> items)
		{
			ItemModFoodSpoiling itemModFoodSpoiling = default(ItemModFoodSpoiling);
			foreach (Item item2 in items)
			{
				if (((Component)item2.info).TryGetComponent<ItemModFoodSpoiling>(ref itemModFoodSpoiling))
				{
					((List<Item>)(object)spoilList).Add(item2);
				}
			}
		}
	}

	[ServerVar]
	public static void ForceChickensSpawnEgg(Arg arg)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		float @float = arg.GetFloat(0, 50f);
		if ((Object)(object)arg.Player() == (Object)null)
		{
			return;
		}
		PooledList<Chicken> val = Pool.Get<PooledList<Chicken>>();
		try
		{
			Vis.Entities(((Component)arg.Player()).transform.position, @float, (List<Chicken>)(object)val, 2048, (QueryTriggerInteraction)2);
			foreach (Chicken item in (List<Chicken>)(object)val)
			{
				if (item.isServer)
				{
					item.SpawnEgg();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void dropWorldItems(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		int @int = arg.GetInt(0, 0);
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(arg.GetString(1, ""));
		Ray val = basePlayer.eyes.HeadRay();
		Vector3 val2 = ((Ray)(ref val)).GetPoint(1f);
		if (!((Object)(object)itemDefinition == (Object)null))
		{
			for (int i = 0; i < @int; i++)
			{
				ItemManager.Create(itemDefinition, 1, 0uL).Drop(val2, Vector3.zero, Quaternion.identity);
				val2 += Vector3.up * 0.3f;
			}
		}
	}

	[ServerVar(Help = "Spawns one of every deployable in a grid")]
	public static void spawn_all_deployables(Arg arg)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper))
		{
			arg.ReplyWith("Must be called by admin player");
			return;
		}
		arg.ReplyWith("Spawning all deployables");
		bool stability = ConVar.Server.stability;
		ConVar.Server.stability = false;
		try
		{
			Vector3 position = ((Component)basePlayer).transform.position;
			List<ItemModDeployable> list = (from x in ItemManager.itemList
				where (Object)(object)((Component)x).GetComponent<ItemModDeployable>() != (Object)null && x.shortname != "legacy.shelter.wood"
				select ((Component)x).GetComponent<ItemModDeployable>()).ToList();
			int num = 12;
			float num2 = Mathf.Ceil(Mathf.Sqrt((float)list.Count));
			float num3 = num2 * (float)num / 2f;
			Vector3 pos = default(Vector3);
			for (int i = 0; i < list.Count; i++)
			{
				((Vector3)(ref pos))..ctor(position.x - num3 + (float)num * ((float)i % num2), position.y, position.z - num3 + (float)num * Mathf.Floor((float)i / num2));
				GameManager.server.CreateEntity(list[i].entityPrefab.resourcePath, pos)?.Spawn();
			}
		}
		finally
		{
			ConVar.Server.stability = stability;
		}
	}

	[ServerVar]
	public static void removeOverlappingStaticSpawnPoints(Arg arg)
	{
		PooledList<StaticRespawnArea> val = Pool.Get<PooledList<StaticRespawnArea>>();
		try
		{
			foreach (StaticRespawnArea staticRespawnArea2 in StaticRespawnArea.staticRespawnAreas)
			{
				((List<StaticRespawnArea>)(object)val).Add(staticRespawnArea2);
			}
			int num = 0;
			for (int i = 0; i < ((List<StaticRespawnArea>)(object)val).Count; i++)
			{
				StaticRespawnArea staticRespawnArea = ((List<StaticRespawnArea>)(object)val)[i];
				bool flag = false;
				foreach (StaticRespawnArea item in (List<StaticRespawnArea>)(object)val)
				{
					if ((Object)(object)item != (Object)(object)staticRespawnArea && item.Distance((BaseEntity)staticRespawnArea) < 1f)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					((List<StaticRespawnArea>)(object)val).RemoveAt(i);
					i--;
					num++;
					staticRespawnArea.Kill();
				}
			}
			arg.ReplyWith($"Destroyed {num} overlapping static spawn points");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void setUnloadableCarFillPercent(Arg arg)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)basePlayer).transform.position;
		PooledList<TrainCarUnloadable> val = Pool.Get<PooledList<TrainCarUnloadable>>();
		try
		{
			Vis.Entities(position, 3f, (List<TrainCarUnloadable>)(object)val, 8192, (QueryTriggerInteraction)2);
			float num = Mathf.Clamp01(arg.GetFloat(0, 0f));
			foreach (TrainCarUnloadable item in (List<TrainCarUnloadable>)(object)val)
			{
				if (!item.isServer)
				{
					continue;
				}
				foreach (Item item2 in item.GetStorageContainer().inventory.itemList)
				{
					item2.amount = Mathf.Max(Mathf.RoundToInt(num), 1);
				}
				item.SetLootPercentage(num);
				item.SetVisualOreLevel(num);
				item.SendNetworkUpdate();
				arg.ReplyWith($"Set ore level to {num} on {item.PrefabName}");
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Spawn lots of IO entities to lag the server")]
	public static void bench_io(Arg arg)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		int @int = arg.GetInt(0, 50);
		string name = arg.GetString(1, "water_catcher_small");
		List<IOEntity> list = new List<IOEntity>();
		WaterCatcher waterCatcher = null;
		Vector3 position = ((Component)arg.Player()).transform.position;
		string[] array = (from x in GameManifest.Current.entities
			where StringEx.Contains(Path.GetFileNameWithoutExtension(x), name, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (array.Length == 0)
		{
			arg.ReplyWith("Couldn't find io prefab \"" + array[0] + "\"");
			return;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(Path.GetFileNameWithoutExtension(x), name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				Debug.Log((object)$"{arg} failed to find io entity \"{name}\"");
				arg.ReplyWith("Unknown entity - could be:\n\n" + string.Join("\n", array.Select(Path.GetFileNameWithoutExtension).ToArray()));
				return;
			}
			array[0] = text;
		}
		for (int i = 0; i < @int; i++)
		{
			Vector3 pos = position + new Vector3((float)(i * 5), 0f, 0f);
			Quaternion identity = Quaternion.identity;
			BaseEntity baseEntity = GameManager.server.CreateEntity(array[0], pos, identity);
			if (!Object.op_Implicit((Object)(object)baseEntity))
			{
				continue;
			}
			baseEntity.Spawn();
			WaterCatcher component = ((Component)baseEntity).GetComponent<WaterCatcher>();
			if (Object.op_Implicit((Object)(object)component))
			{
				list.Add(component);
				if ((Object)(object)waterCatcher != (Object)null)
				{
					Connect(waterCatcher, component);
				}
				if (i == @int - 1)
				{
					Connect(component, list.First());
				}
				waterCatcher = component;
			}
		}
		static void Connect(IOEntity InputIOEnt, IOEntity OutputIOEnt)
		{
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0091: Unknown result type (might be due to invalid IL or missing references)
			int num = 0;
			int num2 = 0;
			WireTool.WireColour wireColour = WireTool.WireColour.Gray;
			IOEntity.IOSlot iOSlot = InputIOEnt.inputs[num];
			IOEntity.IOSlot obj = OutputIOEnt.outputs[num2];
			iOSlot.connectedTo.Set(OutputIOEnt);
			iOSlot.connectedToSlot = num2;
			iOSlot.wireColour = wireColour;
			iOSlot.connectedTo.Init();
			obj.connectedTo.Set(InputIOEnt);
			obj.connectedToSlot = num;
			obj.wireColour = wireColour;
			obj.connectedTo.Init();
			obj.linePoints = (Vector3[])(object)new Vector3[2]
			{
				Vector3.zero,
				((Component)OutputIOEnt).transform.InverseTransformPoint(((Component)InputIOEnt).transform.TransformPoint(iOSlot.handlePosition))
			};
			OutputIOEnt.MarkDirtyForceUpdateOutputs();
			OutputIOEnt.SendNetworkUpdate();
			InputIOEnt.SendNetworkUpdate();
			OutputIOEnt.SendChangedToRoot(forceUpdate: true);
		}
	}

	[ServerVar]
	public static void completeMissionStage(Arg arg)
	{
		int @int = arg.GetInt(0, -1);
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer != (Object)null) || basePlayer.GetActiveMission() == -1)
		{
			return;
		}
		BaseMission.MissionInstance missionInstance = basePlayer.missions[basePlayer.GetActiveMission()];
		if (missionInstance == null)
		{
			return;
		}
		for (int i = 0; i < missionInstance.objectiveStatuses.Length; i++)
		{
			if (!missionInstance.objectiveStatuses[i].completed && (i == @int || (@int == -1 && !missionInstance.objectiveStatuses[i].completed)))
			{
				missionInstance.GetMission().objectives[i].objective.ObjectiveStarted(basePlayer, i, missionInstance);
				missionInstance.GetMission().objectives[i].objective.CompleteObjective(i, missionInstance, basePlayer);
				break;
			}
		}
	}

	[ServerVar]
	public static void completeMission(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer != (Object)null) || basePlayer.GetActiveMission() == -1)
		{
			return;
		}
		BaseMission.MissionInstance missionInstance = basePlayer.missions[basePlayer.GetActiveMission()];
		if (missionInstance == null)
		{
			return;
		}
		for (int i = 0; i < missionInstance.objectiveStatuses.Length; i++)
		{
			if (!missionInstance.objectiveStatuses[i].completed)
			{
				missionInstance.GetMission().objectives[i].objective.CompleteObjective(i, missionInstance, basePlayer);
			}
		}
	}

	[ServerUserVar]
	public static void startTutorial(Arg arg)
	{
		if (!ConVar.Server.tutorialEnabled)
		{
			arg.ReplyWith("Tutorial is not enabled on this server");
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && !basePlayer.IsInTutorial)
		{
			basePlayer.StartTutorial(triggerAnalytics: false);
		}
	}

	[ServerVar]
	public static void completeTutorial(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: false, triggerAnalytics: false);
			}
		}
	}

	[ServerUserVar(ServerAdmin = false)]
	public static void quitTutorial(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			TutorialIsland currentTutorialIsland = basePlayer.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				currentTutorialIsland.OnPlayerCompletedTutorial(basePlayer, isQuit: true, triggerAnalytics: true);
			}
		}
	}

	[ServerVar]
	public static void tutorialStatus(Arg arg)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		ListHashSet<TutorialIsland> tutorialList = TutorialIsland.GetTutorialList(isServer: true);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[5] { "Index", "ID", "Player Name", "Duration", "IsConnected" });
			int num = 0;
			Enumerator<TutorialIsland> enumerator = tutorialList.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					TutorialIsland current = enumerator.Current;
					BasePlayer basePlayer = current.ForPlayer.Get(serverside: true);
					val.AddRow(new string[5]
					{
						num++.ToString(),
						(current.net.group.ID - 1).ToString(),
						((Object)(object)basePlayer != (Object)null) ? basePlayer.displayName : "NULL",
						current.TutorialDuration.ToShortString(),
						((Object)(object)basePlayer != (Object)null) ? basePlayer.IsConnected.ToString() : "NULL"
					});
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
			StringBuilder stringBuilder = new StringBuilder();
			stringBuilder.AppendLine($"Tutorial islands in use: {num}/{TutorialIsland.MaxTutorialIslandCount}");
			stringBuilder.AppendLine(((object)val).ToString());
			arg.ReplyWith(stringBuilder.ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Make admin invisible")]
	public static void invis(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		bool @bool = arg.GetBool(0, !invisiblePlayers.Contains(basePlayer));
		if (@bool && !invisiblePlayers.Contains(basePlayer))
		{
			invisiblePlayers.Add(basePlayer);
			basePlayer.limitNetworking = true;
			basePlayer.isInvisible = true;
			basePlayer.syncPosition = false;
			basePlayer.GetHeldEntity()?.SetHeld(bHeld: false);
			basePlayer.DisablePlayerCollider();
			SimpleAIMemory.AddIgnorePlayer(basePlayer);
			BaseEntity.Query.Server.RemovePlayer(basePlayer);
			Interface.CallHook("OnPlayerVanish", (object)basePlayer);
			if (!Global.Runner.IsInvoking((Action)TickInvis))
			{
				Global.Runner.InvokeRepeating((Action)TickInvis, 0f, 0f);
			}
		}
		else if (!@bool && invisiblePlayers.Contains(basePlayer))
		{
			invisiblePlayers.Remove(basePlayer);
			basePlayer.limitNetworking = false;
			basePlayer.isInvisible = false;
			basePlayer.syncPosition = true;
			basePlayer.EnablePlayerCollider();
			SimpleAIMemory.RemoveIgnorePlayer(basePlayer);
			BaseEntity.Query.Server.RemovePlayer(basePlayer);
			BaseEntity.Query.Server.AddPlayer(basePlayer);
			Interface.CallHook("OnPlayerUnvanish", (object)basePlayer);
			if (invisiblePlayers.Count == 0)
			{
				Global.Runner.CancelInvoke((Action)TickInvis);
			}
		}
		arg.ReplyWith("Invis: " + basePlayer.limitNetworking);
		basePlayer.Command("debug.setinvis_ui", basePlayer.limitNetworking);
	}

	private static void TickInvis()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BasePlayer> val = Pool.Get<PooledList<BasePlayer>>();
		try
		{
			foreach (BasePlayer invisiblePlayer in invisiblePlayers)
			{
				if (!invisiblePlayer.IsValid())
				{
					((List<BasePlayer>)(object)val).Add(invisiblePlayer);
				}
				else
				{
					invisiblePlayer.net.UpdateGroups(((Component)invisiblePlayer).transform.position);
				}
			}
			foreach (BasePlayer item in (List<BasePlayer>)(object)val)
			{
				invisiblePlayers.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void clearPlayerModifiers(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			int count = basePlayer.modifiers.All.Count;
			basePlayer.modifiers.RemoveAll();
			arg.ReplyWith($"Removed {count} modifiers");
		}
	}

	[ServerVar]
	public static void applyBuildingBlockRandomisation(Arg arg)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		int @int = arg.GetInt(0, 0);
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0f, out var hitInfo, 3f, 2097408, (QueryTriggerInteraction)0) && hitInfo.GetEntity() is SimpleBuildingBlock simpleBuildingBlock)
		{
			simpleBuildingBlock.SetVariant(@int);
		}
	}

	[ServerVar]
	public static void vineSwingingReport(Arg arg)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (current is VineSwingingTree)
				{
					num++;
				}
				if (current is VineMountable vineMountable)
				{
					num2++;
					num3 += vineMountable.DestinationCount;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Entity", "Count" });
			val.AddRow(new string[2]
			{
				"VineTrees",
				num.ToString()
			});
			val.AddRow(new string[2]
			{
				"VineMountables",
				num2.ToString()
			});
			val.AddRow(new string[2]
			{
				"VineMountableDirections",
				((float)num3 / (float)num2).ToString()
			});
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void vineSwingingHighlight(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is VineMountable vineMountable)
				{
					vineMountable.Highlight(arg.Player());
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void respawnVineTreesInRadius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			GamePhysics.OverlapSphere(((Component)basePlayer).transform.position, @float, (List<Collider>)(object)val, 1073741824, (QueryTriggerInteraction)1);
			int num = 0;
			int num2 = 0;
			PooledList<VineSwingingTreeStump> val2 = Pool.Get<PooledList<VineSwingingTreeStump>>();
			try
			{
				foreach (Collider item in (List<Collider>)(object)val)
				{
					VineSwingingTreeStump vineSwingingTreeStump = item.ToBaseEntity() as VineSwingingTreeStump;
					if ((Object)(object)vineSwingingTreeStump != (Object)null && vineSwingingTreeStump.isServer && !((List<VineSwingingTreeStump>)(object)val2).Contains(vineSwingingTreeStump))
					{
						((List<VineSwingingTreeStump>)(object)val2).Add(vineSwingingTreeStump);
						if (vineSwingingTreeStump.RespawnTree())
						{
							num++;
						}
						else
						{
							num2++;
						}
					}
				}
				arg.ReplyWith($"Respawned {num} trees in {@float}m, {num2} were blocked by players");
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void conveyorStrictModeReport(Arg arg)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		IndustrialConveyor[] array = BaseEntity.Util.FindAll<IndustrialConveyor>();
		foreach (IndustrialConveyor industrialConveyor in array)
		{
			if (industrialConveyor.strictMode)
			{
				stringBuilder.AppendLine($"{((Component)industrialConveyor).transform.position}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	[ClientVar(ClientAdmin = true)]
	public static void printqueues(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[4] { "Name", "Processed", "Size", "Execution Time" });
			foreach (ObjectWorkQueue item in ObjectWorkQueue.All.OrderBy((ObjectWorkQueue x) => x.Name))
			{
				string text = ((item.TotalExecutionTime.TotalMilliseconds < 1000.0) ? $"{Math.Floor(item.TotalExecutionTime.TotalMilliseconds)}ms" : $"{Math.Round(item.TotalExecutionTime.TotalSeconds, 2)}s");
				val.AddRow(new string[4]
				{
					item.Name,
					item.TotalProcessedCount.ToString(),
					item.QueueLength.ToString(),
					text
				});
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


[Factory("decay")]
public class Decay : ConsoleSystem
{
	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static bool upgrade_wood_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to stone")]
	public static bool upgrade_stone_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to metal")]
	public static bool upgrade_metal_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to hqm")]
	public static bool upgrade_hqm_enabled = true;

	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static float build_twig_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to wood")]
	public static float upgrade_wood_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to stone")]
	public static float upgrade_stone_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to metal")]
	public static float upgrade_metal_cost_multiplier = 1f;

	[ReplicatedVar(Help = "Can players upgrade building blocks to hqm")]
	public static float upgrade_hqm_cost_multiplier = 1f;

	[ServerVar(Help = "Maximum distance to test to see if a structure is outside, higher values are slower but accurate for huge buildings")]
	public static float outside_test_range = 50f;

	[ServerVar]
	public static float tick = 600f;

	[ServerVar]
	public static float scale = 1f;

	[ServerVar]
	public static bool debug = false;

	[ServerVar(Help = "Is upkeep enabled")]
	public static bool upkeep = true;

	[ServerVar(Help = "How many minutes does the upkeep cost last? default : 1440 (24 hours)")]
	public static float upkeep_period_minutes = 1440f;

	[ServerVar(Help = "How many minutes can the upkeep cost last after the cupboard was destroyed? default : 1440 (24 hours)")]
	public static float upkeep_grief_protection = 1440f;

	[ServerVar(Help = "Scale at which objects heal when upkeep conditions are met, default of 1 is same rate at which they decay")]
	public static float upkeep_heal_scale = 1f;

	[ServerVar(Help = "Scale at which objects decay when they are inside, default of 0.1")]
	public static float upkeep_inside_decay_scale = 0.1f;

	[ServerVar(Help = "When set to a value above 0 everything will decay with this delay")]
	public static float delay_override = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_twig = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_wood = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_stone = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_metal = 0f;

	[ServerVar(Help = "How long should this building grade decay be delayed when not protected by upkeep, in hours")]
	public static float delay_toptier = 0f;

	[ServerVar(Help = "When set to a value above 0 everything will decay with this duration")]
	public static float duration_override = 0f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_twig = 1f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_wood = 3f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_stone = 5f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_metal = 8f;

	[ServerVar(Help = "How long should this building grade take to decay when not protected by upkeep, in hours")]
	public static float duration_toptier = 12f;

	public const int UpkeepBracketCount = 4;

	[ServerVar(Help = "Number of blocks in the 1st upkeep bracket")]
	public static int bracket_0_blockcount = 15;

	[ServerVar(Help = "Blocks in the 1st upkeep bracket will cost this value per day to maintain")]
	public static float bracket_0_costfraction = 0.1f;

	[ServerVar(Help = "Number of blocks in the 2nd upkeep bracket")]
	public static int bracket_1_blockcount = 50;

	[ServerVar(Help = "Blocks in the 2nd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_1_costfraction = 0.15f;

	[ServerVar(Help = "The number of blocks in the 3rd upkeep bracket")]
	public static int bracket_2_blockcount = 125;

	[ServerVar(Help = "Blocks in the 3rd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_2_costfraction = 0.2f;

	[ServerVar(Help = "Blocks in the 4th upkeep bracket will cost this value per day to maintain")]
	public static float bracket_3_costfraction = 0.333f;

	[ServerVar(Help = "Should doors have their own upkeep brackets separate from building blocks")]
	public static bool use_door_upkeep_brackets = false;

	[ServerVar(Help = "Number of doors in the 1st upkeep bracket")]
	public static int bracket_0_doorcount = 15;

	[ServerVar(Help = "Doors in the 1st upkeep bracket will cost this value per day to maintain")]
	public static float bracket_0_doorfraction = 0.1f;

	[ServerVar(Help = "Number of doors in the 2nd upkeep bracket")]
	public static int bracket_1_doorcount = 50;

	[ServerVar(Help = "Doors in the 2nd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_1_doorfraction = 0.15f;

	[ServerVar(Help = "The number of doors in the 3rd upkeep bracket")]
	public static int bracket_2_doorcount = 125;

	[ServerVar(Help = "Doors in the 3rd upkeep bracket will cost this value per day to maintain")]
	public static float bracket_2_doorfraction = 0.2f;

	[ServerVar(Help = "Doors in the 4th upkeep bracket will cost this value per day to maintain")]
	public static float bracket_3_doorfraction = 0.333f;

	public static float GetCostMultiplier(BuildingGrade.Enum grade)
	{
		return grade switch
		{
			BuildingGrade.Enum.Twigs => build_twig_cost_multiplier, 
			BuildingGrade.Enum.Wood => upgrade_wood_cost_multiplier, 
			BuildingGrade.Enum.Stone => upgrade_stone_cost_multiplier, 
			BuildingGrade.Enum.Metal => upgrade_metal_cost_multiplier, 
			BuildingGrade.Enum.TopTier => upgrade_hqm_cost_multiplier, 
			_ => 1f, 
		};
	}

	public static bool CanUpgradeToGrade(BuildingGrade.Enum grade)
	{
		return grade switch
		{
			BuildingGrade.Enum.Twigs => true, 
			BuildingGrade.Enum.Wood => upgrade_wood_enabled, 
			BuildingGrade.Enum.Stone => upgrade_stone_enabled, 
			BuildingGrade.Enum.Metal => upgrade_metal_enabled, 
			BuildingGrade.Enum.TopTier => upgrade_hqm_enabled, 
			_ => true, 
		};
	}
}


[Factory("decor")]
public class Decor : ConsoleSystem
{
}


using System.IO;
using Network;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

[Factory("demo")]
public class Demo : ConsoleSystem
{
	public class Header : DemoHeader, IDemoHeader
	{
		long IDemoHeader.Length
		{
			get
			{
				return base.length;
			}
			set
			{
				base.length = value;
			}
		}

		public void Write(BinaryWriter writer)
		{
			byte[] array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)this);
			writer.Write("RUST DEMO FORMAT");
			writer.Write(array.Length);
			writer.Write(array);
			writer.Write('\0');
		}
	}

	public static uint Version = 3u;

	[ServerVar]
	public static float splitseconds = 3600f;

	[ServerVar]
	public static float splitmegabytes = 200f;

	[ServerVar(Saved = true)]
	public static string recordlist = "";

	private static int _recordListModeValue = 0;

	[ServerVar(Name = "upload_demos", Saved = true)]
	public static bool UploadDemos
	{
		get
		{
			return DemoConVars.UploadDemos;
		}
		set
		{
			DemoConVars.UploadDemos = value;
		}
	}

	[ServerVar(Name = "upload_url", Saved = true)]
	public static string UploadUrl
	{
		get
		{
			return DemoConVars.UploadEndpoint;
		}
		set
		{
			DemoConVars.UploadEndpoint = value;
		}
	}

	[ServerVar(Name = "full_server_demo", Saved = true)]
	public static bool ServerDemosEnabled
	{
		get
		{
			return DemoConVars.ServerDemosEnabled;
		}
		set
		{
			DemoConVars.EnableServerDemos(value);
		}
	}

	[ServerVar(Name = "server_flush_seconds", Saved = true)]
	public static int ServerDemoFlushInterval
	{
		get
		{
			return DemoConVars.ServerDemoFlushIntervalSeconds;
		}
		set
		{
			DemoConVars.ServerDemoFlushIntervalSeconds = Mathf.Clamp(value, 60, 1800);
		}
	}

	[ServerVar(Name = "upload_bandwidth_limit_ratio")]
	public static float UploadBandwidthLimitRatio
	{
		get
		{
			return DemoConVars.BandwidthLimitRatio;
		}
		set
		{
			DemoConVars.BandwidthLimitRatio = value;
		}
	}

	[ServerVar(Name = "server_demo_directory", Help = "Directory to save full server demos")]
	public static string ServerDemoDirectory
	{
		get
		{
			return DemoConVars.ServerDemoDirectory;
		}
		set
		{
			DemoConVars.ServerDemoDirectory = value;
		}
	}

	[ServerVar(Name = "delete_after_upload", Saved = true, Help = "Should the full server demos be deleted after they are uploaded")]
	public static bool DeleteDemoAfterUpload
	{
		get
		{
			return DemoConVars.DeleteDemoAfterUpload;
		}
		set
		{
			DemoConVars.DeleteDemoAfterUpload = value;
		}
	}

	[ServerVar(Name = "zip_demos", Saved = true, Help = "Should we be zipping the demos before we upload them")]
	public static bool ZipServerDemos
	{
		get
		{
			return DemoConVars.ZipServerDemos;
		}
		set
		{
			DemoConVars.ZipServerDemos = value;
		}
	}

	[ServerVar(Name = "server_demo_disk_space_gb", Saved = true, Help = "How much disk space full server demos can take before we start to delete them")]
	public static int MaxDemoDiskSpaceGB
	{
		get
		{
			return DemoConVars.MaxDemoDiskSpaceGB;
		}
		set
		{
			DemoConVars.MaxDemoDiskSpaceGB = Mathf.Max(value, 0);
		}
	}

	[ServerVar(Name = "server_demo_cleanup_interval", Saved = true, Help = "How many minutes between cleaning up demos from the disk")]
	public static int DemoDiskCleanupIntervalMinutes
	{
		get
		{
			return DemoConVars.DiskCleanupIntervalMinutes;
		}
		set
		{
			DemoConVars.DiskCleanupIntervalMinutes = Mathf.Max(value, 1);
		}
	}

	[ServerVar(Name = "max_upload_concurrency", Help = "Max parallel requests when uploading demos")]
	public static int DemoUploadConcurrency
	{
		get
		{
			return DemoConVars.MaxUploadConcurrency;
		}
		set
		{
			DemoConVars.MaxUploadConcurrency = Mathf.Max(value, 1);
		}
	}

	[ServerVar(Saved = true, Help = "Controls the behavior of recordlist, 0=whitelist, 1=blacklist")]
	public static int recordlistmode
	{
		get
		{
			return _recordListModeValue;
		}
		set
		{
			_recordListModeValue = Mathf.Clamp(value, 0, 1);
		}
	}

	[ServerVar]
	public static string record(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			return "Player not found";
		}
		if (playerOrSleeper.net.connection.IsRecording)
		{
			return "Player already recording a demo";
		}
		playerOrSleeper.StartDemoRecording();
		return null;
	}

	[ServerVar]
	public static string stop(Arg arg)
	{
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		if (!Object.op_Implicit((Object)(object)playerOrSleeper) || playerOrSleeper.net == null || playerOrSleeper.net.connection == null)
		{
			return "Player not found";
		}
		if (!playerOrSleeper.net.connection.IsRecording)
		{
			return "Player not recording a demo";
		}
		playerOrSleeper.StopDemoRecording();
		return null;
	}
}


using System.IO;
using Network;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;

public class Header : DemoHeader, IDemoHeader
{
	long IDemoHeader.Length
	{
		get
		{
			return base.length;
		}
		set
		{
			base.length = value;
		}
	}

	public void Write(BinaryWriter writer)
	{
		byte[] array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)this);
		writer.Write("RUST DEMO FORMAT");
		writer.Write(array.Length);
		writer.Write(array);
		writer.Write('\0');
	}
}


[Factory("editor")]
public class Editor : ConsoleSystem
{
}


[Factory("effects")]
public class Effects : ConsoleSystem
{
}


using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using ConVar;
using Facepunch;
using UnityEngine;

[Factory("entity")]
public class Entity : ConsoleSystem
{
	private struct EntityInfo
	{
		public BaseNetworkable entity;

		public NetworkableId entityID;

		public uint groupID;

		public NetworkableId parentID;

		public string status;

		public EntityInfo(BaseNetworkable src)
		{
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0058: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
			entity = src;
			BaseEntity baseEntity = entity as BaseEntity;
			BaseEntity baseEntity2 = (((Object)(object)baseEntity != (Object)null) ? baseEntity.GetParentEntity() : null);
			NetworkableId val;
			NetworkableId val2;
			if (!((Object)(object)entity != (Object)null) || entity.net == null)
			{
				val = default(NetworkableId);
				val2 = val;
			}
			else
			{
				val2 = entity.net.ID;
			}
			entityID = val2;
			groupID = (((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null) ? entity.net.group.ID : 0u);
			NetworkableId val3;
			if (!((Object)(object)baseEntity != (Object)null))
			{
				val = default(NetworkableId);
				val3 = val;
			}
			else
			{
				val3 = baseEntity.parentEntity.uid;
			}
			parentID = val3;
			if ((Object)(object)baseEntity != (Object)null)
			{
				val = baseEntity.parentEntity.uid;
				if (((NetworkableId)(ref val)).IsValid)
				{
					if ((Object)(object)baseEntity2 == (Object)null)
					{
						status = "orphan";
					}
					else
					{
						status = "child";
					}
					return;
				}
			}
			status = string.Empty;
		}
	}

	public struct EntitySpawnRequest
	{
		public string PrefabName;

		public string Error;

		public bool Valid => string.IsNullOrEmpty(Error);
	}

	private static void GetEntityTable(TextTable table, Func<EntityInfo, bool> filter)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		table.AddColumn("realm");
		table.AddColumn("entity");
		table.AddColumn("group");
		table.AddColumn("parent");
		table.AddColumn("name");
		table.AddColumn("position");
		table.AddColumn("local");
		table.AddColumn("rotation");
		table.AddColumn("local");
		table.AddColumn("status");
		table.AddColumn("invokes");
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseNetworkable current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					EntityInfo arg = new EntityInfo(current);
					if (filter(arg))
					{
						string[] obj = new string[11]
						{
							"sv",
							arg.entityID.Value.ToString(),
							arg.groupID.ToString(),
							arg.parentID.Value.ToString(),
							arg.entity.ShortPrefabName,
							null,
							null,
							null,
							null,
							null,
							null
						};
						Vector3 val = ((Component)arg.entity).transform.position;
						obj[5] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						val = ((Component)arg.entity).transform.localPosition;
						obj[6] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						Quaternion val2 = ((Component)arg.entity).transform.rotation;
						val = ((Quaternion)(ref val2)).eulerAngles;
						obj[7] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						val2 = ((Component)arg.entity).transform.localRotation;
						val = ((Quaternion)(ref val2)).eulerAngles;
						obj[8] = ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
						obj[9] = arg.status;
						obj[10] = arg.entity.InvokeString();
						table.AddRow(obj);
					}
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void find_entity(Arg args)
	{
		string filter = args.GetString(0, "");
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => string.IsNullOrEmpty(filter) || info.entity.PrefabName.Contains(filter));
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void find_id(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId filter = args.GetEntityID(0);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.entityID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_group(Arg args)
	{
		uint filter = args.GetUInt(0, 0u);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.groupID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_parent(Arg args)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId filter = args.GetEntityID(0);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.parentID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void find_status(Arg args)
	{
		string filter = args.GetString(0, "");
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => string.IsNullOrEmpty(filter) || info.status.Contains(filter));
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void find_radius(Arg args)
	{
		BasePlayer player = args.Player();
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		uint filter = args.GetUInt(0, 10u);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => Vector3.Distance(((Component)info.entity).transform.position, ((Component)player).transform.position) <= (float)filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void find_self(Arg args)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null)
		{
			return;
		}
		NetworkableId filter = basePlayer.net.ID;
		TextTable val = Pool.Get<TextTable>();
		try
		{
			GetEntityTable(val, (EntityInfo info) => info.entityID == filter);
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void debug_toggle(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId def = default(NetworkableId);
		NetworkableId entityID = args.GetEntityID(0, def);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			return;
		}
		BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
		if (!((Object)(object)baseEntity == (Object)null))
		{
			baseEntity.SetFlag(BaseEntity.Flags.Debugging, !baseEntity.IsDebugging());
			if (baseEntity.IsDebugging())
			{
				baseEntity.OnDebugStart();
			}
			def = baseEntity.net.ID;
			args.ReplyWith("Debugging for " + ((object)(NetworkableId)(ref def)/*cast due to .constrained prefix*/).ToString() + " " + (baseEntity.IsDebugging() ? "enabled" : "disabled"));
		}
	}

	[ServerVar]
	public static void nudge(Arg args)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		NetworkableId entityID = args.GetEntityID(0);
		if (((NetworkableId)(ref entityID)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityID) as BaseEntity;
			if (!((Object)(object)baseEntity == (Object)null))
			{
				((Component)baseEntity).BroadcastMessage("DebugNudge", (SendMessageOptions)1);
			}
		}
	}

	public static EntitySpawnRequest GetSpawnEntityFromName(string name)
	{
		EntitySpawnRequest result;
		if (string.IsNullOrEmpty(name))
		{
			result = default(EntitySpawnRequest);
			result.Error = "No entity name provided";
			return result;
		}
		string[] array = (from x in GameManifest.Current.entities
			where StringEx.Contains(Path.GetFileNameWithoutExtension(x), name, CompareOptions.IgnoreCase)
			select x.ToLower()).ToArray();
		if (array.Length == 0)
		{
			result = default(EntitySpawnRequest);
			result.Error = "Entity type not found";
			return result;
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(Path.GetFileNameWithoutExtension(x), name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				result = default(EntitySpawnRequest);
				result.Error = "Unknown entity - could be:\n\n" + string.Join("\n", array.Select(Path.GetFileNameWithoutExtension).ToArray());
				return result;
			}
			array[0] = text;
		}
		result = default(EntitySpawnRequest);
		result.PrefabName = array[0];
		return result;
	}

	[ServerVar(Name = "spawn")]
	public static string svspawn(string name, Vector3 pos, Vector3 dir, int forceUp = 1)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer arg = ConsoleSystem.CurrentArgs.Player();
		EntitySpawnRequest spawnEntityFromName = GetSpawnEntityFromName(name);
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		bool flag = forceUp == 1;
		BaseEntity baseEntity = GameManager.server.CreateEntity(spawnEntityFromName.PrefabName, pos, flag ? Quaternion.LookRotation(dir, Vector3.up) : Quaternion.Euler(dir));
		if ((Object)(object)baseEntity == (Object)null)
		{
			Debug.Log((object)$"{arg} failed to spawn \"{spawnEntityFromName.PrefabName}\" (tried to spawn \"{name}\")");
			return "Couldn't spawn " + name;
		}
		BasePlayer basePlayer = baseEntity as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (flag)
			{
				Quaternion val = Quaternion.LookRotation(dir, Vector3.up);
				basePlayer.OverrideViewAngles(((Quaternion)(ref val)).eulerAngles);
			}
			else
			{
				basePlayer.OverrideViewAngles(dir);
			}
		}
		baseEntity.Spawn();
		Debug.Log((object)$"{arg} spawned \"{baseEntity}\" at {pos}");
		string? obj = ((object)baseEntity)?.ToString();
		Vector3 val2 = pos;
		return "spawned " + obj + " at " + ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
	}

	[ServerVar(Name = "spawnitem")]
	public static string svspawnitem(string name, Vector3 pos)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ConsoleSystem.CurrentArgs.Player();
		if (string.IsNullOrEmpty(name))
		{
			return "No entity name provided";
		}
		string[] array = (from x in ItemManager.itemList
			select x.shortname into x
			where StringEx.Contains(x, name, CompareOptions.IgnoreCase)
			select x).ToArray();
		if (array.Length == 0)
		{
			return "Entity type not found";
		}
		if (array.Length > 1)
		{
			string text = array.FirstOrDefault((string x) => string.Compare(x, name, StringComparison.OrdinalIgnoreCase) == 0);
			if (text == null)
			{
				Debug.Log((object)$"{basePlayer} failed to spawn \"{name}\"");
				return "Unknown entity - could be:\n\n" + string.Join("\n", array);
			}
			array[0] = text;
		}
		Item item = ItemManager.CreateByName(array[0], 1, 0uL);
		if (item == null)
		{
			Debug.Log((object)$"{basePlayer} failed to spawn \"{array[0]}\" (tried to spawnitem \"{name}\")");
			return "Couldn't spawn " + name;
		}
		item?.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		BaseEntity arg = item.CreateWorldObject(pos);
		Debug.Log((object)$"{basePlayer} spawned \"{arg}\" at {pos} (via spawnitem)");
		string obj = item?.ToString();
		Vector3 val = pos;
		return "spawned " + obj + " at " + ((object)(Vector3)(ref val)/*cast due to .constrained prefix*/).ToString();
	}

	[ServerVar(Name = "spawngrid")]
	public static string svspawngrid(string name, int width = 5, int height = 5, int spacing = 5)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = ConsoleSystem.CurrentArgs.Player();
		EntitySpawnRequest spawnEntityFromName = GetSpawnEntityFromName(name);
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		Quaternion rotation = ((Component)basePlayer).transform.rotation;
		((Quaternion)(ref rotation)).eulerAngles = new Vector3(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
		Matrix4x4 val = Matrix4x4.TRS(((Component)basePlayer).transform.position, ((Component)basePlayer).transform.rotation, Vector3.one);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < height; j++)
			{
				Vector3 pos = ((Matrix4x4)(ref val)).MultiplyPoint(new Vector3((float)(i * spacing), 0f, (float)(j * spacing)));
				BaseEntity baseEntity = GameManager.server.CreateEntity(spawnEntityFromName.PrefabName, pos, rotation);
				if ((Object)(object)baseEntity == (Object)null)
				{
					Debug.Log((object)$"{basePlayer} failed to spawn \"{spawnEntityFromName.PrefabName}\" (tried to spawn \"{name}\")");
					return "Couldn't spawn " + name;
				}
				baseEntity.Spawn();
			}
		}
		Debug.Log((object)($"{basePlayer} spawned ({width * height}) " + spawnEntityFromName.PrefabName));
		return $"spawned ({width * height}) " + spawnEntityFromName.PrefabName;
	}

	[ServerVar]
	public static void spawnlootfrom(Arg args)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		string @string = args.GetString(0, string.Empty);
		int @int = args.GetInt(1, 1);
		Vector3 vector = args.GetVector3(1, Object.op_Implicit((Object)(object)basePlayer) ? basePlayer.CenterPoint() : Vector3.zero);
		if (string.IsNullOrEmpty(@string))
		{
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(@string, vector);
		if ((Object)(object)baseEntity == (Object)null)
		{
			return;
		}
		baseEntity.Spawn();
		basePlayer.ChatMessage("Contents of " + @string + " spawned " + @int + " times");
		LootContainer component = ((Component)baseEntity).GetComponent<LootContainer>();
		if ((Object)(object)component != (Object)null)
		{
			for (int i = 0; i < @int * component.maxDefinitionsToSpawn; i++)
			{
				component.lootDefinition.SpawnIntoContainer(basePlayer.inventory.containerMain);
			}
		}
		baseEntity.Kill();
	}

	public static int DeleteBy(ulong id)
	{
		List<ulong> list = Pool.Get<List<ulong>>();
		list.Add(id);
		int result = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		return result;
	}

	[ServerVar(Help = "Destroy all entities created by provided users (separate users by space)")]
	public static int DeleteBy(Arg arg)
	{
		if (!arg.HasArgs(1))
		{
			return 0;
		}
		List<ulong> list = Pool.Get<List<ulong>>();
		string[] args = arg.Args;
		for (int i = 0; i < args.Length; i++)
		{
			if (ulong.TryParse(args[i], out var result))
			{
				list.Add(result);
			}
		}
		int result2 = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		return result2;
	}

	private static int DeleteBy(List<ulong> ids)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BaseEntity baseEntity = (BaseEntity)enumerator.Current;
				if ((Object)(object)baseEntity == (Object)null)
				{
					continue;
				}
				bool flag = false;
				foreach (ulong id in ids)
				{
					if (baseEntity.OwnerID == id)
					{
						flag = true;
						break;
					}
				}
				if (flag)
				{
					((FacepunchBehaviour)baseEntity).Invoke((Action)baseEntity.KillMessage, (float)num * 0.2f);
					num++;
				}
			}
			return num;
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Destroy all entities created by users in the provided text block (can use with copied results from ent auth)")]
	public static void DeleteByTextBlock(Arg arg)
	{
		if (arg.Args.Length != 1)
		{
			arg.ReplyWith("Invalid arguments, provide a text block surrounded by \" and listing player id's at the start of each line");
			return;
		}
		MatchCollection matchCollection = Regex.Matches(arg.GetString(0, ""), "^\\b\\d{17}", RegexOptions.Multiline);
		List<ulong> list = Pool.Get<List<ulong>>();
		foreach (Match item in matchCollection)
		{
			if (ulong.TryParse(item.Value, out var result))
			{
				list.Add(result);
			}
		}
		int num = DeleteBy(list);
		Pool.FreeUnmanaged<ulong>(ref list);
		arg.ReplyWith($"Destroyed {num} entities");
	}

	[ServerVar]
	public static void set_battery_charge(Arg arg)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Usage: set_battery_charge <charge>");
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		ElectricBattery electricBattery = GamePhysics.TraceRealmEntity(GamePhysics.Realm.Server, basePlayer.eyes.HeadRay(), 0f, 5f, -5, (QueryTriggerInteraction)0) as ElectricBattery;
		if ((Object)(object)electricBattery == (Object)null)
		{
			arg.ReplyWith("Not looking at battery");
			return;
		}
		electricBattery.SetCharge(@float);
		arg.ReplyWith($"Set battery charge to {@float}");
	}

	[ServerVar(EditorOnly = true)]
	public static void test_pooling(Arg args)
	{
	}
}


using UnityEngine;

private struct EntityInfo
{
	public BaseNetworkable entity;

	public NetworkableId entityID;

	public uint groupID;

	public NetworkableId parentID;

	public string status;

	public EntityInfo(BaseNetworkable src)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		entity = src;
		BaseEntity baseEntity = entity as BaseEntity;
		BaseEntity baseEntity2 = (((Object)(object)baseEntity != (Object)null) ? baseEntity.GetParentEntity() : null);
		NetworkableId val;
		NetworkableId val2;
		if (!((Object)(object)entity != (Object)null) || entity.net == null)
		{
			val = default(NetworkableId);
			val2 = val;
		}
		else
		{
			val2 = entity.net.ID;
		}
		entityID = val2;
		groupID = (((Object)(object)entity != (Object)null && entity.net != null && entity.net.group != null) ? entity.net.group.ID : 0u);
		NetworkableId val3;
		if (!((Object)(object)baseEntity != (Object)null))
		{
			val = default(NetworkableId);
			val3 = val;
		}
		else
		{
			val3 = baseEntity.parentEntity.uid;
		}
		parentID = val3;
		if ((Object)(object)baseEntity != (Object)null)
		{
			val = baseEntity.parentEntity.uid;
			if (((NetworkableId)(ref val)).IsValid)
			{
				if ((Object)(object)baseEntity2 == (Object)null)
				{
					status = "orphan";
				}
				else
				{
					status = "child";
				}
				return;
			}
		}
		status = string.Empty;
	}
}


public struct EntitySpawnRequest
{
	public string PrefabName;

	public string Error;

	public bool Valid => string.IsNullOrEmpty(Error);
}


using System;
using UnityEngine;

[Factory("env")]
public class Env : ConsoleSystem
{
	[ClientVar(Default = "1")]
	public static bool nightlight_enabled = true;

	[ReplicatedVar(Default = "0")]
	public static bool redMoon = false;

	[ClientVar(Default = "0", Help = "Toggles nightlight screen effect when using debug camera")]
	public static bool nightlight_debugcamera_enabled = true;

	private static float nightlight_distance_internal = 7f;

	private static float nightlight_fadefraction_internal = 0.65f;

	private static float nightlight_brightness_internal = 0.0175f;

	[ServerVar]
	public static bool progresstime
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return false;
			}
			return TOD_Sky.Instance.Components.Time.ProgressTime;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Components.Time.ProgressTime = value;
			}
		}
	}

	[ServerVar(ShowInAdminUI = true)]
	public static float time
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0f;
			}
			return TOD_Sky.Instance.Cycle.Hour;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Hour = value;
			}
		}
	}

	[ServerVar]
	public static int day
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Day;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Day = value;
			}
		}
	}

	[ServerVar]
	public static int month
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Month;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Month = value;
			}
		}
	}

	[ServerVar]
	public static int year
	{
		get
		{
			if ((Object)(object)TOD_Sky.Instance == (Object)null)
			{
				return 0;
			}
			return TOD_Sky.Instance.Cycle.Year;
		}
		set
		{
			if (!((Object)(object)TOD_Sky.Instance == (Object)null))
			{
				TOD_Sky.Instance.Cycle.Year = value;
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float oceanlevel
	{
		get
		{
			return WaterSystem.OceanLevel;
		}
		set
		{
			WaterSystem.OceanLevel = value;
		}
	}

	[ReplicatedVar(Default = "7")]
	public static float nightlight_distance
	{
		get
		{
			return nightlight_distance_internal;
		}
		set
		{
			value = Mathf.Clamp(value, 0f, 25f);
			nightlight_distance_internal = value;
		}
	}

	[ReplicatedVar(Default = "0.65")]
	public static float nightlight_fadefraction
	{
		get
		{
			return nightlight_fadefraction_internal;
		}
		set
		{
			nightlight_fadefraction_internal = value;
		}
	}

	[ReplicatedVar(Default = "0.0175")]
	public static float nightlight_brightness
	{
		get
		{
			return nightlight_brightness_internal;
		}
		set
		{
			value = Mathf.Clamp(value, 0f, 0.2f);
			nightlight_brightness_internal = value;
		}
	}

	[ServerVar]
	public static void addtime(Arg arg)
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			DateTime dateTime = TOD_Sky.Instance.Cycle.DateTime.AddTicks(arg.GetTicks(0, 0L));
			TOD_Sky.Instance.Cycle.DateTime = dateTime;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using UnityEngine;

[Factory("events")]
public class Events : ConsoleSystem
{
	public class PendingEventChange
	{
		public string Id;

		public float? MinHours;

		public float? MaxHours;

		public bool? Enabled;

		public bool Invalid;

		public PendingEventChange(string id)
		{
			Id = id;
		}
	}

	private const string BradleyEventId = "bradley";

	private static List<PendingEventChange> TargetChanges = new List<PendingEventChange>();

	private static PendingEventChange GetPendingChanges(string id, bool create)
	{
		PendingEventChange pendingEventChange = TargetChanges.FirstOrDefault((PendingEventChange c) => c.Id.Equals(id, StringComparison.OrdinalIgnoreCase));
		if (pendingEventChange == null && create)
		{
			pendingEventChange = new PendingEventChange(id);
			TargetChanges.Add(pendingEventChange);
		}
		return pendingEventChange;
	}

	private static void ApplyAllChanges()
	{
		foreach (PendingEventChange targetChange in TargetChanges)
		{
			UpdateServerEvent(targetChange);
		}
		TargetChanges.RemoveAll((PendingEventChange c) => c.Invalid);
	}

	public static void UpdateServerEvent(PendingEventChange targetState)
	{
		if (targetState.Id == "bradley")
		{
			Bradley.enabled = targetState.Enabled ?? Bradley.enabled;
			Bradley.respawnDelayMinutes = targetState.MinHours ?? targetState.MaxHours ?? Bradley.respawnDelayMinutes;
		}
		else if (HasAnyEvents())
		{
			EventSchedule eventSchedule = FindEventById(targetState.Id);
			if ((Object)(object)eventSchedule == (Object)null)
			{
				Debug.LogWarning((object)("Unknown event '" + targetState.Id + "' when applying settings to server events"));
				targetState.Invalid = true;
			}
			else
			{
				UpdateScheduleFromConVars(eventSchedule);
			}
		}
	}

	public static void UpdateScheduleFromConVars(EventSchedule schedule)
	{
		PendingEventChange pendingChanges = GetPendingChanges(schedule.Key, create: false);
		if (pendingChanges != null)
		{
			((Behaviour)schedule).enabled = pendingChanges.Enabled ?? ((Behaviour)schedule).enabled;
			schedule.minimumHoursBetween = pendingChanges.MinHours ?? schedule.minimumHoursBetween;
			schedule.maxmumHoursBetween = pendingChanges.MaxHours ?? schedule.maxmumHoursBetween;
		}
	}

	[ServerVar]
	public static void print_server_events(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		foreach (EventSchedule allEvent in EventSchedule.allEvents)
		{
			if (string.IsNullOrEmpty(allEvent.Key))
			{
				stringBuilder.AppendLine("WARNING: Missing event key for prefab '" + ((Object)((Component)allEvent).gameObject).name + "'");
				continue;
			}
			stringBuilder.AppendLine(allEvent.Key ?? "");
			stringBuilder.AppendLine($"  - enabled: {((Behaviour)allEvent).enabled}");
			stringBuilder.AppendLine($"  - min hours: {allEvent.minimumHoursBetween}");
			stringBuilder.AppendLine($"  - max hours: {allEvent.maxmumHoursBetween}");
			stringBuilder.AppendLine();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void set_event_enabled(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_enabled <event_name> <true|false>");
			return;
		}
		string @string = arg.GetString(0, "");
		bool @bool = arg.GetBool(1, false);
		GetPendingChanges(@string, create: true).Enabled = @bool;
		ApplyAllChanges();
		arg.ReplyWith((@bool ? "Enabled" : "Disabled") + " event '" + @string + "'");
	}

	[ServerVar]
	public static void set_event_min_delay(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_max_delay <event_name> <float>");
			return;
		}
		string @string = arg.GetString(0, "");
		float @float = arg.GetFloat(1, 0f);
		GetPendingChanges(@string, create: true).MinHours = @float;
		ApplyAllChanges();
		arg.ReplyWith($"Set minimum delay for '{@string}' to {@float} in-game hours");
	}

	[ServerVar]
	public static void set_event_max_delay(Arg arg)
	{
		if (!arg.HasArgs(2))
		{
			arg.ReplyWith("Usage: set_event_max_delay <event_name> <float>");
			return;
		}
		string @string = arg.GetString(0, "");
		float @float = arg.GetFloat(1, 0f);
		GetPendingChanges(@string, create: true).MaxHours = @float;
		ApplyAllChanges();
		arg.ReplyWith($"Set maximum delay for '{@string}' to {@float} in-game hours");
	}

	private static bool HasAnyEvents()
	{
		return EventSchedule.allEvents.Count > 0;
	}

	private static EventSchedule FindEventById(string key)
	{
		return EventSchedule.allEvents.FirstOrDefault((EventSchedule e) => e.Key.Equals(key, StringComparison.OrdinalIgnoreCase));
	}
}


public class PendingEventChange
{
	public string Id;

	public float? MinHours;

	public float? MaxHours;

	public bool? Enabled;

	public bool Invalid;

	public PendingEventChange(string id)
	{
		Id = id;
	}
}


[Factory("file")]
public class FileConVar : ConsoleSystem
{
	[ClientVar]
	public static bool debug
	{
		get
		{
			return FileSystem.LogDebug;
		}
		set
		{
			FileSystem.LogDebug = value;
		}
	}

	[ClientVar]
	public static bool time
	{
		get
		{
			return FileSystem.LogTime;
		}
		set
		{
			FileSystem.LogTime = value;
		}
	}
}


using UnityEngine;

[Factory("fps")]
public class FPS : ConsoleSystem
{
	private static int _limit = 240;

	private static int m_graph;

	[ClientVar(Saved = true)]
	[ServerVar(Saved = true)]
	public static int limit
	{
		get
		{
			if (_limit == -1)
			{
				_limit = Application.targetFrameRate;
			}
			return _limit;
		}
		set
		{
			_limit = value;
			Application.targetFrameRate = _limit;
		}
	}

	[ClientVar]
	public static int graph
	{
		get
		{
			return m_graph;
		}
		set
		{
			m_graph = value;
			if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
			{
				FPSGraph component = ((Component)MainCamera.mainCamera).GetComponent<FPSGraph>();
				if (Object.op_Implicit((Object)(object)component))
				{
					component.Refresh();
				}
			}
		}
	}
}


using UnityEngine;

[Factory("gamemode")]
public class gamemode : ConsoleSystem
{
	[ServerUserVar]
	public static void setteam(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			int @int = arg.GetInt(0, 0);
			if (@int >= 0 && @int < activeGameMode.GetNumTeams())
			{
				activeGameMode.ResetPlayerScores(basePlayer);
				activeGameMode.SetPlayerTeam(basePlayer, @int);
				basePlayer.Respawn();
			}
		}
	}

	[ServerVar]
	public static void set(Arg arg)
	{
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			Debug.Log((object)"Invalid gamemode");
		}
		BaseGameMode baseGameMode = null;
		GameObjectRef gameObjectRef = null;
		GameModeManifest gameModeManifest = GameModeManifest.Get();
		Debug.Log((object)("total gamemodes : " + gameModeManifest.gameModePrefabs.Count));
		foreach (GameObjectRef gameModePrefab in gameModeManifest.gameModePrefabs)
		{
			BaseGameMode component = gameModePrefab.Get().GetComponent<BaseGameMode>();
			if (component.shortname == @string)
			{
				baseGameMode = component;
				gameObjectRef = gameModePrefab;
				Debug.Log((object)("Found :" + component.shortname + " prefab name is :" + component.PrefabName + ": rpath is " + gameModePrefab.resourcePath + ":"));
				break;
			}
			Debug.Log((object)("search name " + @string + "searched against : " + component.shortname));
		}
		if ((Object)(object)baseGameMode == (Object)null)
		{
			Debug.Log((object)("Unknown gamemode : " + @string));
			return;
		}
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode))
		{
			if (baseGameMode.shortname == activeGameMode.shortname)
			{
				Debug.Log((object)"Same gamemode, resetting");
			}
			if (activeGameMode.permanent)
			{
				Debug.LogError((object)"This game mode is permanent, you must reset the server to switch game modes.");
				return;
			}
			activeGameMode.ShutdownGame();
			activeGameMode.Kill();
			BaseGameMode.SetActiveGameMode(null, serverside: true);
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(gameObjectRef.resourcePath, Vector3.zero, Quaternion.identity);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			Debug.Log((object)("Spawning new game mode : " + baseGameMode.shortname));
			baseEntity.Spawn();
		}
		else
		{
			Debug.Log((object)("Failed to create new game mode :" + baseGameMode.PrefabName));
		}
	}
}


using Rust;
using UnityEngine;
using UnityEngine.Scripting;

[Factory("gc")]
public class GC : ConsoleSystem
{
	[ClientVar]
	public static bool buffer_enabled = true;

	[ClientVar]
	public static int debuglevel = 1;

	[ClientVar(Saved = true)]
	public static int buffer = GC.gcDefaultValue;

	public static int safeBuffer
	{
		get
		{
			return GC.GetSafeGCValue(buffer);
		}
		set
		{
			buffer = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool incremental_enabled
	{
		get
		{
			return GarbageCollector.isIncremental;
		}
		set
		{
			Debug.LogWarning((object)"Cannot set gc.incremental as it is read only");
		}
	}

	[ServerVar]
	[ClientVar]
	public static int incremental_milliseconds
	{
		get
		{
			return (int)(GarbageCollector.incrementalTimeSliceNanoseconds / 1000000);
		}
		set
		{
			GarbageCollector.incrementalTimeSliceNanoseconds = 1000000uL * (ulong)Mathf.Max(value, 0);
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool enabled
	{
		get
		{
			return GC.Enabled;
		}
		set
		{
			Debug.LogWarning((object)"Cannot set gc.enabled as it is read only");
		}
	}

	[ServerVar]
	[ClientVar]
	public static void collect()
	{
		GC.Collect();
	}

	[ServerVar]
	[ClientVar]
	public static void unload()
	{
		Resources.UnloadUnusedAssets();
	}

	[ClientVar]
	[ServerVar]
	public static void alloc(Arg args)
	{
		byte[] array = new byte[args.GetInt(0, 1048576)];
		args.ReplyWith("Allocated " + array.Length + " bytes");
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Nexus.Models;
using Network;
using Network.Visibility;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Unity.Jobs.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.Profiling;
using UnityEngine.SceneManagement;

[Factory("global")]
public class Global : ConsoleSystem
{
	private static int _developer;

	[ClientVar]
	[ServerVar]
	public static int maxthreads = 8;

	[ClientVar]
	[ServerVar]
	public static bool forceUnloadBundles = true;

	[ServerVar]
	public static bool updateNetworkPositionWithDebugCameraWhileSpectating = false;

	[ClientVar(Saved = true)]
	[ServerVar(Saved = true)]
	public static int perf = 0;

	private static bool _god = false;

	private static bool _godforceoffoverlay = false;

	[ServerVar(ClientAdmin = true, ServerAdmin = true, Help = "When enabled a player wearing a gingerbread suit will gib like the gingerbread NPC's")]
	[ClientVar]
	public static bool cinematicGingerbreadCorpses = false;

	private static uint _gingerbreadMaterialID = 0u;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Multiplier applied to SprayDuration if a spray isn't in the sprayers auth (cannot go above 1f)")]
	public static float SprayOutOfAuthMultiplier = 0.5f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Base time (in seconds) that sprays last")]
	public static float SprayDuration = 10800f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "If a player sprays more than this, the oldest spray will be destroyed. 0 will disable")]
	public static int MaxSpraysPerPlayer = 40;

	[ServerVar(Help = "Disables the backpacks that appear after a corpse times out")]
	public static bool disableBagDropping = false;

	[ClientVar(Saved = true, Help = "Disables any emoji animations")]
	public static bool blockEmojiAnimations = false;

	[ClientVar(Saved = true, Help = "Blocks any emoji from appearing")]
	public static bool blockEmoji = false;

	[ClientVar(Saved = true, Help = "Blocks emoji provided by servers from appearing")]
	public static bool blockServerEmoji = false;

	[ClientVar(Saved = true, Help = "Displays any emoji rendering errors in the console")]
	public static bool showEmojiErrors = false;

	[ClientVar]
	[ServerVar]
	public static int developer
	{
		get
		{
			return _developer;
		}
		set
		{
			_developer = value;
			Array.Fill(RustLog.Levels, _developer);
		}
	}

	[ServerVar]
	[ClientVar]
	public static int job_system_threads
	{
		get
		{
			return JobsUtility.JobWorkerCount;
		}
		set
		{
			if (value < 1)
			{
				JobsUtility.ResetJobWorkerCount();
				return;
			}
			value = Mathf.Clamp(value, 1, JobsUtility.JobWorkerMaximumCount);
			JobsUtility.JobWorkerCount = value;
		}
	}

	[ClientVar(ClientInfo = true, Saved = true, Help = "If you're an admin this will enable god mode")]
	public static bool god
	{
		get
		{
			return _god;
		}
		set
		{
			_god = value;
		}
	}

	[ClientVar(ClientInfo = true, Saved = true, Help = "Media: Forces the global.god overlay to never show if enabled")]
	public static bool godforceoffoverlay
	{
		get
		{
			return _godforceoffoverlay;
		}
		set
		{
			_godforceoffoverlay = value;
		}
	}

	[ServerVar]
	public static void restart(Arg args)
	{
		ServerMgr.RestartServer(args.GetString(1, string.Empty), args.GetInt(0, 300));
	}

	[ClientVar]
	[ServerVar]
	public static void quit(Arg args)
	{
		if (args != null && args.HasArgs(1))
		{
			args.ReplyWith("Invalid quit command, quit only works if provided with no arguments.");
			return;
		}
		if (Application.isEditor)
		{
			Debug.LogWarning((object)"Aborting quit because we're in the editor");
			return;
		}
		if ((Object)(object)SingletonComponent<ServerMgr>.Instance != (Object)null)
		{
			SingletonComponent<ServerMgr>.Instance.Shutdown();
		}
		Application.isQuitting = true;
		Server sv = Net.sv;
		if (sv != null)
		{
			sv.Stop("quit");
		}
		Process.GetCurrentProcess().Kill();
		Debug.Log((object)"Quitting");
		Application.Quit();
	}

	[ServerVar]
	public static void report(Arg args)
	{
		ServerPerformance.DoReport();
	}

	[ClientVar]
	[ServerVar]
	public static void objects(Arg args)
	{
		Object[] array = Object.FindObjectsOfType<Object>();
		string text = "";
		Dictionary<Type, int> dictionary = new Dictionary<Type, int>();
		Dictionary<Type, long> dictionary2 = new Dictionary<Type, long>();
		Object[] array2 = array;
		foreach (Object val in array2)
		{
			int runtimeMemorySize = Profiler.GetRuntimeMemorySize(val);
			if (dictionary.ContainsKey(((object)val).GetType()))
			{
				dictionary[((object)val).GetType()]++;
			}
			else
			{
				dictionary.Add(((object)val).GetType(), 1);
			}
			if (dictionary2.ContainsKey(((object)val).GetType()))
			{
				dictionary2[((object)val).GetType()] += runtimeMemorySize;
			}
			else
			{
				dictionary2.Add(((object)val).GetType(), runtimeMemorySize);
			}
		}
		foreach (KeyValuePair<Type, long> item in dictionary2.OrderByDescending(delegate(KeyValuePair<Type, long> x)
		{
			KeyValuePair<Type, long> keyValuePair = x;
			return keyValuePair.Value;
		}))
		{
			text = text + dictionary[item.Key].ToString().PadLeft(10) + " " + NumberExtensions.FormatBytes<long>(item.Value, false).PadLeft(15) + "\t" + item.Key?.ToString() + "\n";
		}
		args.ReplyWith(text);
	}

	[ClientVar]
	[ServerVar]
	public static void textures(Arg args)
	{
		Texture[] array = Object.FindObjectsOfType<Texture>();
		string text = "";
		Texture[] array2 = array;
		foreach (Texture val in array2)
		{
			string text2 = NumberExtensions.FormatBytes<int>(Profiler.GetRuntimeMemorySize((Object)(object)val), false);
			text = text + ((object)val).ToString().PadRight(30) + ((Object)val).name.PadRight(30) + text2 + "\n";
		}
		args.ReplyWith(text);
	}

	[ServerVar]
	[ClientVar]
	public static void colliders(Arg args)
	{
		int num = (from x in Object.FindObjectsOfType<Collider>()
			where x.enabled
			select x).Count();
		int num2 = (from x in Object.FindObjectsOfType<Collider>()
			where !x.enabled
			select x).Count();
		string text = num + " colliders enabled, " + num2 + " disabled";
		args.ReplyWith(text);
	}

	[ServerVar]
	[ClientVar]
	public static void error(Arg args)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((GameObject)null).transform.position = Vector3.zero;
	}

	[ClientVar]
	[ServerVar]
	public static void queue(Arg args)
	{
		string text = "";
		text = text + "stabilityCheckQueue:        " + ((ObjectWorkQueue<StabilityEntity>)StabilityEntity.stabilityCheckQueue).Info() + "\n";
		text = text + "updateSurroundingsQueue:    " + ((ObjectWorkQueue<Bounds>)StabilityEntity.updateSurroundingsQueue).Info() + "\n";
		args.ReplyWith(text);
	}

	[ServerUserVar]
	public static void setinfo(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			string @string = args.GetString(0, (string)null);
			string string2 = args.GetString(1, (string)null);
			if (@string != null && string2 != null)
			{
				basePlayer.SetInfo(@string, string2);
			}
		}
	}

	[ServerVar]
	public static void sleep(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsSleeping() && !basePlayer.IsSpectating() && !basePlayer.IsDead())
		{
			basePlayer.StartSleeping();
		}
	}

	[ServerVar]
	public static void sleeptarget(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(basePlayer);
			if (!((Object)(object)lookingAtPlayer == (Object)null))
			{
				lookingAtPlayer.StartSleeping();
			}
		}
	}

	[ServerUserVar]
	public static void kill(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || basePlayer.IsSpectating() || basePlayer.IsDead())
		{
			return;
		}
		if (basePlayer.IsRestrained)
		{
			Handcuffs handcuffs = basePlayer.Belt?.GetRestraintItem();
			if ((Object)(object)handcuffs != (Object)null && handcuffs.BlockSuicide)
			{
				return;
			}
		}
		if (basePlayer.CanSuicide())
		{
			basePlayer.Hurt(1000f, DamageType.Suicide, basePlayer, useProtection: false);
			if (basePlayer.IsDead())
			{
				basePlayer.MarkSuicide();
			}
		}
		else
		{
			basePlayer.ConsoleMessage("You can't suicide again so quickly, wait a while");
		}
	}

	[ServerUserVar]
	public static void respawn(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		if (!basePlayer.IsDead() && !basePlayer.IsSpectating())
		{
			if (developer > 0)
			{
				Debug.LogWarning((object)(((object)basePlayer)?.ToString() + " wanted to respawn but isn't dead or spectating"));
			}
			basePlayer.SendNetworkUpdate();
		}
		else if (basePlayer.CanRespawn())
		{
			basePlayer.MarkRespawn();
			basePlayer.Respawn();
		}
		else
		{
			basePlayer.ConsoleMessage("You can't respawn again so quickly, wait a while");
		}
	}

	[ServerVar]
	public static void injure(Arg args)
	{
		InjurePlayer(args.Player());
	}

	public static void InjurePlayer(BasePlayer ply)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ply == (Object)null || ply.IsDead())
		{
			return;
		}
		HitInfo hitInfo = Pool.Get<HitInfo>();
		hitInfo.Init(ply, ply, DamageType.Suicide, 1000f, ((Component)ply).transform.position);
		hitInfo.UseProtection = false;
		if (ConVar.Server.woundingenabled && !ply.IsIncapacitated() && !ply.IsSleeping() && !ply.isMounted)
		{
			if (ply.IsCrawling())
			{
				ply.GoToIncapacitated(hitInfo);
			}
			else
			{
				ply.BecomeWounded(hitInfo);
			}
		}
		else
		{
			ply.ConsoleMessage("Can't go to wounded state right now.");
		}
	}

	[ServerVar]
	public static void recover(Arg args)
	{
		RecoverPlayer(args.Player());
	}

	public static void RecoverPlayer(BasePlayer ply)
	{
		if (!((Object)(object)ply == (Object)null) && !ply.IsDead())
		{
			ply.StopWounded();
		}
	}

	[ServerVar]
	public static void spectate(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer.wantsSpectate = true;
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			string @string = args.GetString(0, "");
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(@string);
			}
			basePlayer.wantsSpectate = false;
		}
	}

	[ServerVar]
	public static void toggleSpectateTeamInfo(Arg args)
	{
		bool @bool = args.GetBool(0, false);
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.SetSpectateTeamInfo(@bool);
			args.ReplyWith($"ToggleSpectateTeamInfo is now {@bool}");
		}
		else
		{
			args.ReplyWith("Invalid player or player is not spectating");
		}
	}

	[ServerVar]
	public static void spectateid(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			basePlayer.wantsSpectate = true;
			if (!basePlayer.IsDead())
			{
				basePlayer.DieInstantly();
			}
			ulong uLong = args.GetULong(0, 0uL);
			if (basePlayer.IsDead())
			{
				basePlayer.StartSpectating();
				basePlayer.UpdateSpectateTarget(uLong);
			}
			basePlayer.wantsSpectate = false;
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag(Arg args)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer) || !basePlayer.IsDead())
		{
			return;
		}
		NetworkableId entityID = args.GetEntityID(0);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			args.ReplyWith("Missing sleeping bag ID");
			return;
		}
		string @string = args.GetString(1, "");
		string errorMessage;
		if (NexusServer.Started && !string.IsNullOrWhiteSpace(@string))
		{
			if (!ZoneController.Instance.CanRespawnAcrossZones(basePlayer))
			{
				args.ReplyWith("You cannot respawn to a different zone");
				return;
			}
			NexusZoneDetails val = NexusServer.FindZone(@string);
			if (val == null)
			{
				args.ReplyWith("Zone was not found");
			}
			else if (!basePlayer.CanRespawn())
			{
				args.ReplyWith("You can't respawn again so quickly, wait a while");
			}
			else
			{
				NexusRespawn(basePlayer, val, entityID);
			}
		}
		else if (!SleepingBag.TrySpawnPlayer(basePlayer, entityID, out errorMessage))
		{
			args.ReplyWith(errorMessage);
		}
		static async void NexusRespawn(BasePlayer player, NexusZoneDetails toZone, NetworkableId sleepingBag)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			_ = 1;
			try
			{
				player.nextRespawnTime = float.PositiveInfinity;
				Request val2 = Pool.Get<Request>();
				val2.respawnAtBag = Pool.Get<SleepingBagRespawnRequest>();
				val2.respawnAtBag.userId = player.userID;
				val2.respawnAtBag.sleepingBagId = sleepingBag;
				val2.respawnAtBag.secondaryData = player.SaveSecondaryData();
				Response val3 = await NexusServer.ZoneRpc(toZone.Key, val2);
				try
				{
					if (!val3.status.success)
					{
						if (player.IsConnected)
						{
							player.ConsoleMessage("RespawnAtBag failed: " + val3.status.errorMessage);
						}
						return;
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
				await NexusServer.ZoneClient.Assign(player.UserIDString, toZone.Key);
				if (player.IsConnected)
				{
					ConsoleNetwork.SendClientCommandImmediate(player.net.connection, "nexus.redirect", toZone.IpAddress, toZone.GamePort, toZone.ConnectionProtocol());
					player.Kick("Redirecting to another zone...");
				}
			}
			catch (Exception ex)
			{
				if (player.IsConnected)
				{
					player.ConsoleMessage(ex.ToString());
				}
			}
			finally
			{
				player.MarkRespawn();
			}
		}
	}

	[ServerUserVar]
	public static void respawn_sleepingbag_remove(Arg args)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		NetworkableId entityID = args.GetEntityID(0);
		if (!((NetworkableId)(ref entityID)).IsValid)
		{
			args.ReplyWith("Missing sleeping bag ID");
			return;
		}
		string @string = args.GetString(1, "");
		if (NexusServer.Started && !string.IsNullOrWhiteSpace(@string))
		{
			NexusZoneDetails val = NexusServer.FindZone(@string);
			if (val == null)
			{
				args.ReplyWith("Zone was not found");
			}
			else if (ZoneController.Instance.CanRespawnAcrossZones(basePlayer))
			{
				NexusRemoveBag(basePlayer, val.Key, entityID);
			}
		}
		else
		{
			SleepingBag.DestroyBag(basePlayer.userID, entityID);
		}
		static async void NexusRemoveBag(BasePlayer player, string zoneKey, NetworkableId sleepingBag)
		{
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			try
			{
				Request val2 = Pool.Get<Request>();
				val2.destroyBag = Pool.Get<SleepingBagDestroyRequest>();
				val2.destroyBag.userId = player.userID;
				val2.destroyBag.sleepingBagId = sleepingBag;
				(await NexusServer.ZoneRpc(zoneKey, val2)).Dispose();
			}
			catch (Exception ex)
			{
				if (player.IsConnected)
				{
					player.ConsoleMessage(ex.ToString());
				}
			}
		}
	}

	[ServerUserVar]
	public static void status_sv(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			args.ReplyWith(basePlayer.GetDebugStatus());
		}
	}

	[ClientVar]
	public static void status_cl(Arg args)
	{
	}

	[ServerVar]
	public static void teleport(Arg args)
	{
		if (args.HasArgs(2))
		{
			BasePlayer playerOrSleeperOrBot = args.GetPlayerOrSleeperOrBot(0);
			if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot) && playerOrSleeperOrBot.IsAlive())
			{
				BasePlayer playerOrSleeperOrBot2 = args.GetPlayerOrSleeperOrBot(1);
				if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot2) && playerOrSleeperOrBot2.IsAlive())
				{
					playerOrSleeperOrBot.Teleport(playerOrSleeperOrBot2);
				}
			}
			return;
		}
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			BasePlayer playerOrSleeperOrBot3 = args.GetPlayerOrSleeperOrBot(0);
			if (Object.op_Implicit((Object)(object)playerOrSleeperOrBot3) && playerOrSleeperOrBot3.IsAlive())
			{
				basePlayer.Teleport(playerOrSleeperOrBot3);
			}
		}
	}

	[ServerVar]
	public static void teleport2me(Arg args)
	{
		BasePlayer playerOrSleeperOrBot = args.GetPlayerOrSleeperOrBot(0);
		if ((Object)(object)playerOrSleeperOrBot == (Object)null)
		{
			args.ReplyWith("Player or bot not found");
			return;
		}
		if (!playerOrSleeperOrBot.IsAlive())
		{
			args.ReplyWith("Target is not alive");
			return;
		}
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			playerOrSleeperOrBot.Teleport(basePlayer);
		}
	}

	[ServerVar]
	public static void teleporteveryone2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, 0uL);
		}
	}

	[ServerVar]
	public static void teleportsleepers2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: false, 0uL);
		}
	}

	[ServerVar]
	public static void teleportnonsleepers2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			TeleportPlayersToMe(basePlayer, includeSleepers: false, includeNonSleepers: true, 0uL);
		}
	}

	[ServerVar]
	public static void teleportteam2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			if (basePlayer.Team == null)
			{
				args.ReplyWith("Player is not in a team");
			}
			else
			{
				TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, basePlayer.Team.teamID);
			}
		}
	}

	[ServerVar]
	public static void teleporttargetteam2me(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			if (basePlayer.Team == null)
			{
				args.ReplyWith("Player is not in a team");
				return;
			}
			ulong uLong = args.GetULong(0, 0uL);
			TeleportPlayersToMe(basePlayer, includeSleepers: true, includeNonSleepers: true, uLong);
		}
	}

	private static void TeleportPlayersToMe(BasePlayer player, bool includeSleepers, bool includeNonSleepers, ulong filterByTeam = 0uL)
	{
		if ((Object)(object)player == (Object)null || !Object.op_Implicit((Object)(object)player) || !player.IsAlive())
		{
			return;
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (allPlayer.IsAlive() && !((Object)(object)allPlayer == (Object)(object)player) && (!allPlayer.IsSleeping() || includeSleepers) && (allPlayer.IsSleeping() || includeNonSleepers) && (filterByTeam == 0L || (allPlayer.Team != null && allPlayer.Team.teamID == filterByTeam)))
			{
				allPlayer.Teleport(player);
			}
		}
	}

	[ServerVar]
	public static void teleportany(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			basePlayer.Teleport(args.GetString(0, ""), playersOnly: false);
		}
	}

	[ServerVar]
	public static void teleportpos(Arg args)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			string text = args.FullString.Replace(", ", ",").Trim('"');
			basePlayer.Teleport(StringExtensions.ToVector3(text));
		}
	}

	[ServerVar]
	public static void teleportlos(Arg args)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && basePlayer.IsAlive())
		{
			Ray val = basePlayer.eyes.HeadRay();
			int @int = args.GetInt(0, 1000);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.Raycast(val, ref val2, (float)@int, 1218652417))
			{
				basePlayer.Teleport(((RaycastHit)(ref val2)).point);
			}
			else
			{
				basePlayer.Teleport(((Ray)(ref val)).origin + ((Ray)(ref val)).direction * (float)@int);
			}
		}
	}

	[ServerVar]
	public static void teleport2owneditem(Arg arg)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong result;
		if ((Object)(object)playerOrSleeper != (Object)null)
		{
			result = playerOrSleeper.userID;
		}
		else if (!ulong.TryParse(arg.GetString(0, ""), out result))
		{
			arg.ReplyWith("No player with that id found");
			return;
		}
		string @string = arg.GetString(1, "");
		BaseEntity[] array = BaseEntity.Util.FindTargetsOwnedBy(result, @string);
		if (array.Length == 0)
		{
			arg.ReplyWith("No targets found");
			return;
		}
		int num = Random.Range(0, array.Length);
		arg.ReplyWith($"Teleporting to {array[num].ShortPrefabName} at {((Component)array[num]).transform.position}");
		basePlayer.Teleport(((Component)array[num]).transform.position);
	}

	[ServerVar]
	public static void teleport2autheditem(Arg arg)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		BasePlayer playerOrSleeper = arg.GetPlayerOrSleeper(0);
		ulong result;
		if ((Object)(object)playerOrSleeper != (Object)null)
		{
			result = playerOrSleeper.userID;
		}
		else if (!ulong.TryParse(arg.GetString(0, ""), out result))
		{
			arg.ReplyWith("No player with that id found");
			return;
		}
		string @string = arg.GetString(1, "");
		BaseEntity[] array = BaseEntity.Util.FindTargetsAuthedTo(result, @string);
		if (array.Length == 0)
		{
			arg.ReplyWith("No targets found");
			return;
		}
		int num = Random.Range(0, array.Length);
		arg.ReplyWith($"Teleporting to {array[num].ShortPrefabName} at {((Component)array[num]).transform.position}");
		basePlayer.Teleport(((Component)array[num]).transform.position);
	}

	[ServerVar]
	public static void teleport2marker(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be called from a player");
			return;
		}
		if (basePlayer.State.pointsOfInterest == null || basePlayer.State.pointsOfInterest.Count == 0)
		{
			arg.ReplyWith("You don't have a marker set");
			return;
		}
		string @string = arg.GetString(0, "");
		if (arg.HasArgs(1) && @string != "True")
		{
			int num = arg.GetInt(0, 0);
			if (num == -1)
			{
				num = basePlayer.State.pointsOfInterest.Count - 1;
			}
			if (num >= 0 && num < basePlayer.State.pointsOfInterest.Count)
			{
				TeleportToMarker(basePlayer.State.pointsOfInterest[num], basePlayer);
				return;
			}
		}
		if (!string.IsNullOrEmpty(@string))
		{
			foreach (MapNote item in basePlayer.State.pointsOfInterest)
			{
				if (!string.IsNullOrEmpty(item.label) && string.Equals(item.label, @string, StringComparison.InvariantCultureIgnoreCase))
				{
					TeleportToMarker(item, basePlayer);
					return;
				}
			}
		}
		int debugMapMarkerIndex = basePlayer.DebugMapMarkerIndex;
		debugMapMarkerIndex++;
		if (debugMapMarkerIndex >= basePlayer.State.pointsOfInterest.Count)
		{
			debugMapMarkerIndex = 0;
		}
		TeleportToMarker(basePlayer.State.pointsOfInterest[debugMapMarkerIndex], basePlayer);
		basePlayer.DebugMapMarkerIndex = debugMapMarkerIndex;
	}

	private static void TeleportToMarker(MapNote marker, BasePlayer player)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		TeleportToTopOfBase(player, marker.worldPosition);
	}

	private static void TeleportToTopOfBase(BasePlayer player, Vector3 position)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		position.y = WaterLevel.GetWaterOrTerrainSurface(position, waves: true, volumes: true);
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(new Ray(position + Vector3.up * 100f, Vector3.down), ref val, 110f, 1218652417))
		{
			position.y = ((RaycastHit)(ref val)).point.y + 0.5f;
		}
		player.Teleport(position);
	}

	[ServerVar]
	public static void teleport2grid(Arg arg)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3? val = MapHelper.StringToPosition(arg.GetString(0, ""));
			if (!val.HasValue)
			{
				arg.ReplyWith("Invalid grid reference, should look like 'A1'");
			}
			else
			{
				TeleportToTopOfBase(basePlayer, val.Value);
			}
		}
	}

	[ServerVar]
	public static void teleport2death(Arg arg)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be called from a player");
			return;
		}
		if (basePlayer.State.deathMarker == null)
		{
			arg.ReplyWith("No death marker found");
			return;
		}
		Vector3 worldPosition = basePlayer.ServerCurrentDeathNote.worldPosition;
		basePlayer.Teleport(worldPosition);
	}

	[ServerVar]
	public static void teleport2mission(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			BaseMission.MissionInstance activeMissionInstance = basePlayer.GetActiveMissionInstance();
			if (activeMissionInstance != null)
			{
				TeleportToTopOfBase(basePlayer, activeMissionInstance.missionLocation);
			}
		}
	}

	[ServerVar]
	[ClientVar]
	public static void free(Arg args)
	{
		Pool.clear_prefabs(args);
		Pool.clear_assets(args);
		Pool.clear_memory(args);
		ConVar.GC.collect();
		ConVar.GC.unload();
	}

	[ServerVar(ServerUser = true)]
	[ClientVar]
	public static void version(Arg arg)
	{
		arg.ReplyWith($"Protocol: {Protocol.printable}\nBuild Date: {BuildInfo.Current.BuildDate}\nUnity Version: {Application.unityVersion}\nChangeset: {BuildInfo.Current.Scm.ChangeId}\nBranch: {BuildInfo.Current.Scm.Branch}");
	}

	[ClientVar]
	[ServerVar]
	public static void sysinfo(Arg arg)
	{
		arg.ReplyWith(SystemInfoGeneralText.currentInfo);
	}

	[ClientVar]
	[ServerVar]
	public static void sysuid(Arg arg)
	{
		arg.ReplyWith(SystemInfo.deviceUniqueIdentifier);
	}

	[ServerVar]
	public static void breakitem(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Item activeItem = basePlayer.GetActiveItem();
			activeItem?.LoseCondition(activeItem.condition);
		}
	}

	[ServerVar]
	public static void breakclothing(Arg args)
	{
		BasePlayer basePlayer = args.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		foreach (Item item in basePlayer.inventory.containerWear.itemList)
		{
			item?.LoseCondition(item.condition);
		}
	}

	[ServerVar]
	[ClientVar]
	public static void subscriptions(Arg arg)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("realm");
			val.AddColumn("group");
			BasePlayer basePlayer = arg.Player();
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				Enumerator<Group> enumerator = basePlayer.net.subscriber.subscribed.GetEnumerator();
				try
				{
					while (enumerator.MoveNext())
					{
						Group current = enumerator.Current;
						val.AddRow(new string[2]
						{
							"sv",
							current.ID.ToString()
						});
					}
				}
				finally
				{
					((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
				}
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static uint GingerbreadMaterialID()
	{
		if (_gingerbreadMaterialID == 0)
		{
			_gingerbreadMaterialID = StringPool.Get("Gingerbread");
		}
		return _gingerbreadMaterialID;
	}

	[ServerVar]
	public static void ClearAllSprays()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
	}

	[ServerVar]
	public static void ClearAllSpraysByPlayer(Arg arg)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!arg.HasArgs(1))
		{
			return;
		}
		ulong uLong = arg.GetULong(0, 0uL);
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				if (current.sprayedByPlayer == uLong)
				{
					list.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		int count = list.Count;
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
		arg.ReplyWith($"Deleted {count} sprays by {uLong}");
	}

	[ServerVar]
	public static void ClearSpraysInRadius(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			float @float = arg.GetFloat(0, 16f);
			int num = ClearSpraysInRadius(((Component)basePlayer).transform.position, @float);
			arg.ReplyWith($"Deleted {num} sprays within {@float} of {basePlayer.displayName}");
		}
	}

	private static int ClearSpraysInRadius(Vector3 position, float radius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		List<SprayCanSpray> list = Pool.Get<List<SprayCanSpray>>();
		Enumerator<SprayCanSpray> enumerator = SprayCanSpray.AllSprays.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				SprayCanSpray current = enumerator.Current;
				if (current.Distance(position) <= radius)
				{
					list.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (SprayCanSpray item in list)
		{
			item.Kill();
		}
		int count = list.Count;
		Pool.FreeUnmanaged<SprayCanSpray>(ref list);
		return count;
	}

	[ServerVar]
	public static void ClearSpraysAtPositionInRadius(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		float @float = arg.GetFloat(1, 0f);
		if (@float != 0f)
		{
			int num = ClearSpraysInRadius(vector, @float);
			arg.ReplyWith($"Deleted {num} sprays within {@float} of {vector}");
		}
	}

	[ServerVar]
	public static void ClearDroppedItems()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		List<DroppedItem> list = Pool.Get<List<DroppedItem>>();
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is DroppedItem item)
				{
					list.Add(item);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (DroppedItem item2 in list)
		{
			item2.Kill();
		}
		Pool.FreeUnmanaged<DroppedItem>(ref list);
	}

	[ClientVar]
	[ServerVar]
	public static string printAllScenesInBuild(Arg args)
	{
		StringBuilder stringBuilder = new StringBuilder();
		int sceneCountInBuildSettings = SceneManager.sceneCountInBuildSettings;
		stringBuilder.AppendLine($"Scenes: {sceneCountInBuildSettings}");
		for (int i = 0; i < sceneCountInBuildSettings; i++)
		{
			stringBuilder.AppendLine(SceneUtility.GetScenePathByBuildIndex(i));
		}
		return stringBuilder.ToString();
	}

	[ServerVar(Clientside = true, Help = "Immediately update the manifest")]
	public static void UpdateManifest(Arg args)
	{
		Manifest.UpdateManifest();
	}
}


using Rust.Workshop;
using UnityEngine;

[Factory("graphics")]
public class Graphics : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static int shadowmode = 2;

	[ClientVar(Saved = true)]
	public static int shadowlights = 1;

	private static int _shadowquality = 1;

	[ClientVar(Saved = true)]
	public static bool grassshadows = false;

	[ClientVar(Saved = true)]
	public static bool contactshadows = false;

	[ClientVar(Saved = true)]
	public static float drawdistance = 2500f;

	private static EncryptedValue<float> _fov = 75f;

	[ClientVar]
	public static bool hud = true;

	[ClientVar(Saved = true)]
	public static bool chat = true;

	[ClientVar(Saved = true)]
	public static bool branding = true;

	[ClientVar(Saved = true)]
	public static int compass = 1;

	[ClientVar(Saved = true)]
	public static bool dof = false;

	[ClientVar(Saved = true)]
	public static float dof_aper = 12f;

	[ClientVar(Saved = true)]
	public static float dof_blur = 1f;

	[ClientVar(Saved = true, Help = "0 = auto 1 = manual 2 = dynamic based on target")]
	public static int dof_mode = 0;

	[ClientVar(Saved = true, Help = "distance from camera to focus on")]
	public static float dof_focus_dist = 10f;

	[ClientVar(Saved = true)]
	public static float dof_focus_time = 0.2f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static float dof_squeeze = 0f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static float dof_barrel = 0f;

	[ClientVar(Saved = true, ClientAdmin = true)]
	public static bool dof_debug = false;

	[ClientVar(Saved = true, Help = "Goes from 0 - 3, higher = more dof samples but slower perf")]
	public static int dof_kernel_count = 0;

	public static BaseEntity dof_focus_target_entity = null;

	[ClientVar(Saved = true, Help = "Whether to scale vm models with fov")]
	public static bool vm_fov_scale = true;

	[ClientVar(Saved = true, Help = "FLips viewmodels horizontally (for left handed players)")]
	public static bool vm_horizontal_flip = false;

	private static float _uiscale = 1f;

	private static int _anisotropic = 1;

	private static int _parallax = 0;

	[ClientVar(Help = "Represents the number of vertical syncs that should pass between each frame. An integer in the range of 0-4. ", Saved = true)]
	public static int vsync
	{
		get
		{
			return QualitySettings.vSyncCount;
		}
		set
		{
			QualitySettings.vSyncCount = Mathf.Clamp(value, 0, 4);
		}
	}

	[ClientVar(Saved = true)]
	public static int shadowquality
	{
		get
		{
			return _shadowquality;
		}
		set
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Invalid comparison between Unknown and I4
			_shadowquality = Mathf.Clamp(value, 0, 3);
			shadowmode = _shadowquality + 1;
			bool flag = (int)SystemInfo.graphicsDeviceType == 17;
			KeywordUtil.EnsureKeywordState("SHADOW_QUALITY_HIGH", !flag && _shadowquality == 2);
			KeywordUtil.EnsureKeywordState("SHADOW_QUALITY_VERYHIGH", !flag && _shadowquality == 3);
			KeywordUtil.EnsureKeywordState("FORWARD_SHADOWS_MEDIUM", _shadowquality == 1);
			KeywordUtil.EnsureKeywordState("FORWARD_SHADOWS_HIGH", _shadowquality >= 2);
		}
	}

	[ClientVar(Saved = true)]
	public static float fov
	{
		get
		{
			return _fov;
		}
		set
		{
			_fov = Mathf.Clamp(value, 70f, 90f);
		}
	}

	[ClientVar(Help = "Global multiplier for the LOD's switching distance. A larger value leads to a longer view distance before a lower resolution LOD is picked.", Saved = true)]
	public static float lodBias
	{
		get
		{
			return QualitySettings.lodBias;
		}
		set
		{
			QualitySettings.lodBias = Mathf.Clamp(value, 0.5f, 5f);
		}
	}

	[ClientVar(Saved = true)]
	public static int shaderlod
	{
		get
		{
			int globalMaximumLOD = Shader.globalMaximumLOD;
			if (globalMaximumLOD >= 100 && globalMaximumLOD <= 199)
			{
				return 1;
			}
			if (globalMaximumLOD >= 200 && globalMaximumLOD <= 299)
			{
				return 2;
			}
			if (globalMaximumLOD >= 300 && globalMaximumLOD <= 399)
			{
				return 3;
			}
			if (globalMaximumLOD >= 400 && globalMaximumLOD <= 499)
			{
				return 4;
			}
			if (globalMaximumLOD >= 500 && globalMaximumLOD <= 599)
			{
				return 5;
			}
			_ = 600;
			return 6;
		}
		set
		{
			switch (Mathf.Clamp(value, 1, 6))
			{
			case 1:
				Shader.globalMaximumLOD = 100;
				break;
			case 2:
				Shader.globalMaximumLOD = 200;
				break;
			case 3:
				Shader.globalMaximumLOD = 300;
				break;
			case 4:
				Shader.globalMaximumLOD = 400;
				break;
			case 5:
				Shader.globalMaximumLOD = 500;
				break;
			case 6:
				Shader.globalMaximumLOD = 600;
				break;
			}
		}
	}

	[ClientVar(Saved = true)]
	public static float uiscale
	{
		get
		{
			return _uiscale;
		}
		set
		{
			_uiscale = Mathf.Clamp(value, 0.5f, 1f);
		}
	}

	[ClientVar(Saved = true)]
	public static int af
	{
		get
		{
			return _anisotropic;
		}
		set
		{
			value = Mathf.Clamp(value, 1, 16);
			Texture.SetGlobalAnisotropicFilteringLimits(1, value);
			if (value <= 1)
			{
				Texture.anisotropicFiltering = (AnisotropicFiltering)0;
			}
			if (value > 1)
			{
				Texture.anisotropicFiltering = (AnisotropicFiltering)1;
			}
			_anisotropic = value;
		}
	}

	[ClientVar(Saved = true)]
	public static int parallax
	{
		get
		{
			return _parallax;
		}
		set
		{
			switch (value)
			{
			default:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 1:
				Shader.EnableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.DisableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			case 2:
				Shader.DisableKeyword("TERRAIN_PARALLAX_OFFSET");
				Shader.EnableKeyword("TERRAIN_PARALLAX_OCCLUSION");
				break;
			}
			_parallax = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static bool itemskins
	{
		get
		{
			return WorkshopSkin.AllowApply;
		}
		set
		{
			WorkshopSkin.AllowApply = value;
		}
	}

	[ClientVar]
	public static bool itemskinunload
	{
		get
		{
			return WorkshopSkin.AllowUnload;
		}
		set
		{
			WorkshopSkin.AllowUnload = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static float itemskintimeout
	{
		get
		{
			return WorkshopSkin.DownloadTimeout;
		}
		set
		{
			WorkshopSkin.DownloadTimeout = value;
		}
	}

	[ClientVar(ClientAdmin = true)]
	public static void dof_focus_target(Arg arg)
	{
	}

	[ClientVar]
	public static void dof_nudge(Arg arg)
	{
		float @float = arg.GetFloat(0, 0f);
		dof_focus_dist += @float;
		if (dof_focus_dist < 0f)
		{
			dof_focus_dist = 0f;
		}
	}
}


using System.Linq;
using UnityEngine;

[Factory("graphicssettings")]
public class GraphicsSettings : ConsoleSystem
{
	private const float MinShadowDistance = 100f;

	private const float MaxShadowDistance2Split = 600f;

	private const float MaxShadowDistance4Split = 1000f;

	private static float _shadowDistancePercent = 100f;

	[ClientVar(Help = "The maximum number of pixel lights that should affect any object.", Saved = true)]
	public static int pixelLightCount
	{
		get
		{
			return QualitySettings.pixelLightCount;
		}
		set
		{
			QualitySettings.pixelLightCount = Mathf.Clamp(value, 0, 8);
		}
	}

	[ClientVar(Help = "Indicates how many of the highest-resolution mips of each texture Unity does not upload at the given quality level.", Saved = true)]
	public static int globalTextureMipmapLimit
	{
		get
		{
			return QualitySettings.globalTextureMipmapLimit;
		}
		set
		{
			value = Mathf.Clamp(value, 0, 3);
			bool num = QualitySettings.globalTextureMipmapLimit != value;
			QualitySettings.globalTextureMipmapLimit = value;
			if (num && (Object)(object)SingletonComponent<FoliageGrid>.Instance != (Object)null)
			{
				SingletonComponent<FoliageGrid>.Instance.OnGlobalTextureMipmapLimitChange();
			}
		}
	}

	[ClientVar(Help = "Global anisotropic filtering mode. 0-2. Disabled, enabled per-texture, force-enabled for all textures.", Saved = true)]
	public static int anisotropicFiltering
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.anisotropicFiltering;
		}
		set
		{
			QualitySettings.anisotropicFiltering = (AnisotropicFiltering)Mathf.Clamp(value, 0, 2);
		}
	}

	[ClientVar(Help = "Should soft blending be used for particles?", Saved = true)]
	public static bool softParticles
	{
		get
		{
			return QualitySettings.softParticles;
		}
		set
		{
			QualitySettings.softParticles = value;
		}
	}

	[ClientVar(Help = "Budget for how many ray casts can be performed per frame for approximate collision testing.", Saved = true)]
	public static int particleRaycastBudget
	{
		get
		{
			return QualitySettings.particleRaycastBudget;
		}
		set
		{
			QualitySettings.particleRaycastBudget = value;
		}
	}

	[ClientVar(Help = "If enabled, billboards will face towards camera position rather than camera orientation.", Saved = true)]
	public static bool billboardsFaceCameraPosition
	{
		get
		{
			return QualitySettings.billboardsFaceCameraPosition;
		}
		set
		{
			QualitySettings.billboardsFaceCameraPosition = value;
		}
	}

	[ClientVar(Help = "The rendering mode of Shadowmask. 0 = Shadowmask 1 = Distance Shadowmask", Saved = true)]
	public static int shadowmaskMode
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.shadowmaskMode;
		}
		set
		{
			QualitySettings.shadowmaskMode = (ShadowmaskMode)Mathf.Clamp(value, 0, 1);
		}
	}

	[ClientVar(Help = "The default resolution of shadow maps. 0 = Low, 1 = Medium, 2 = High, 3 = Very High", Saved = true)]
	public static int shadowResolution
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)QualitySettings.shadowResolution;
		}
		set
		{
			QualitySettings.shadowResolution = (ShadowResolution)Mathf.Clamp(value, 0, 3);
		}
	}

	[ClientVar(Help = "Shadow drawing distance percentage", Saved = true)]
	public static float shadowDistancePercent
	{
		get
		{
			return _shadowDistancePercent;
		}
		set
		{
			_shadowDistancePercent = Mathf.Clamp(value, 0f, 100f);
			EnforceShadowDistanceBounds();
		}
	}

	[ClientVar(Help = "Number of cascades to use for directional light shadows. 1 = None, 2 = Two, 4 = Four", Saved = true)]
	public static int shadowCascades
	{
		get
		{
			return QualitySettings.shadowCascades;
		}
		set
		{
			QualitySettings.shadowCascades = ForceOption(value, 1, 1, 2, 4);
			EnforceShadowDistanceBounds();
		}
	}

	[ClientVar(Help = "Enables or disables LOD Cross Fade.", Saved = true)]
	public static bool enableLODCrossFade
	{
		get
		{
			return QualitySettings.enableLODCrossFade;
		}
		set
		{
			QualitySettings.enableLODCrossFade = value;
		}
	}

	public static void SetMandatoryDefaults()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		QualitySettings.useLegacyDetailDistribution = true;
		QualitySettings.terrainQualityOverrides = (TerrainQualityOverrides)0;
		QualitySettings.shadowNearPlaneOffset = 2f;
		QualitySettings.shadowCascade2Split = 0.1f;
		QualitySettings.shadowCascade4Split = new Vector3(0.01f, 0.03f, 0.1f);
		QualitySettings.asyncUploadTimeSlice = 2;
		QualitySettings.asyncUploadBufferSize = 4;
		QualitySettings.asyncUploadPersistentBuffer = true;
		QualitySettings.maximumLODLevel = 0;
		QualitySettings.enableLODCrossFade = true;
		QualitySettings.skinWeights = (SkinWeights)4;
		QualitySettings.resolutionScalingFixedDPIFactor = 1f;
		QualitySettings.shadows = (ShadowQuality)2;
		QualitySettings.shadowProjection = (ShadowProjection)1;
	}

	private static void EnforceShadowDistanceBounds()
	{
		float num = _shadowDistancePercent / 100f;
		float shadowDistance = ((QualitySettings.shadowCascades == 1) ? 100f : ((QualitySettings.shadowCascades != 2) ? (100f + 900f * num) : (100f + 500f * num)));
		QualitySettings.shadowDistance = shadowDistance;
	}

	private static int ForceOption(int value, int defaultValue, params int[] options)
	{
		if (options == null || options.Length == 0 || !options.Contains(value))
		{
			return defaultValue;
		}
		return value;
	}
}


using Development.Attributes;

[Factory("grass")]
[ResetStaticFields]
public class Grass : ConsoleSystem
{
}


[Factory("halloween")]
public class Halloween : ConsoleSystem
{
	[ServerVar]
	public static bool enabled = false;

	[ServerVar(Help = "Population active on the server, per square km")]
	public static float murdererpopulation = 0f;

	[ServerVar(Help = "Population active on the server, per square km")]
	public static float scarecrowpopulation = 0f;

	[ServerVar(Help = "Scarecrows can throw beancans (Default: true).")]
	public static bool scarecrows_throw_beancans = true;

	[ServerVar(Help = "The delay globally on a server between each time a scarecrow throws a beancan (Default: 8 seconds).")]
	public static float scarecrow_throw_beancan_global_delay = 8f;

	[ServerVar(Help = "Modified damage from beancan explosion vs players (Default: 0.1).")]
	public static float scarecrow_beancan_vs_player_dmg_modifier = 0.1f;

	[ServerVar(Help = "Modifier to how much damage scarecrows take to the body. (Default: 0.25)")]
	public static float scarecrow_body_dmg_modifier = 0.25f;

	[ServerVar(Help = "Stopping distance for destinations set while chasing a target (Default: 0.5)")]
	public static float scarecrow_chase_stopping_distance = 0.5f;
}


[Factory("harmony")]
public class Harmony : ConsoleSystem
{
	[ServerVar(Name = "load")]
	public static void Load(Arg args)
	{
		HarmonyLoader.TryLoadMod(args.GetString(0, ""));
	}

	[ServerVar(Name = "unload")]
	public static void Unload(Arg args)
	{
		HarmonyLoader.TryUnloadMod(args.GetString(0, ""));
	}
}


using UnityEngine;

[Factory("heli")]
public class PatrolHelicopter : ConsoleSystem
{
	private const string path = "assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab";

	[ServerVar]
	public static float lifetimeMinutes = 30f;

	[ServerVar]
	public static int guns = 1;

	[ServerVar]
	public static float bulletDamageScale = 1f;

	[ServerVar]
	public static float bulletAccuracy = 2f;

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Vector3 pos = ((Component)basePlayer).transform.position;
			Debug.Log((object)("heli called to : " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
			GameManager server = GameManager.server;
			pos = default(Vector3);
			BaseEntity baseEntity = server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", pos);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<PatrolHelicopterAI>().SetInitialDestination(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f), 0f);
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void calltome(Arg arg)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Vector3 pos = ((Component)basePlayer).transform.position;
			Debug.Log((object)("heli called to : " + ((object)(Vector3)(ref pos)/*cast due to .constrained prefix*/).ToString()));
			GameManager server = GameManager.server;
			pos = default(Vector3);
			BaseEntity baseEntity = server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab", pos);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<PatrolHelicopterAI>().SetInitialDestination(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void call(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)arg.Player()))
		{
			Debug.Log((object)"Helicopter inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/patrol helicopter/patrolhelicopter.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void strafe(Arg arg)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.strafe_target = basePlayer;
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Strafe_Enter(basePlayer);
		}
	}

	[ServerVar]
	public static void orbit(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Orbit_Enter(70f);
		}
	}

	[ServerVar]
	public static void orbitstrafe(Arg arg)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.strafe_target = basePlayer;
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_OrbitStrafe_Enter();
		}
	}

	[ServerVar]
	public static void move(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Move_Enter(((Component)basePlayer).transform.position);
		}
	}

	[ServerVar]
	public static void flee(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Flee_Enter();
		}
	}

	[ServerVar]
	public static void patrol(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Patrol_Enter();
		}
	}

	[ServerVar]
	public static void death(Arg arg)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			PatrolHelicopterAI heliInstance = PatrolHelicopterAI.heliInstance;
			if ((Object)(object)heliInstance == (Object)null)
			{
				Debug.Log((object)"no heli instance");
				return;
			}
			heliInstance.interestZoneOrigin = ((Component)basePlayer).transform.position;
			heliInstance.ExitCurrentState();
			heliInstance.State_Death_Enter();
		}
	}

	[ServerVar]
	public static void testpuzzle(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			_ = basePlayer.IsDeveloper;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Factory("hierarchy")]
public class Hierarchy : ConsoleSystem
{
	private static GameObject currentDir;

	private static Transform[] GetCurrent()
	{
		if ((Object)(object)currentDir == (Object)null)
		{
			return TransformUtil.GetRootObjects().ToArray();
		}
		List<Transform> list = new List<Transform>();
		for (int i = 0; i < currentDir.transform.childCount; i++)
		{
			list.Add(currentDir.transform.GetChild(i));
		}
		return list.ToArray();
	}

	[ServerVar]
	public static void ls(Arg args)
	{
		string text = "";
		string filter = args.GetString(0, "");
		text = ((!Object.op_Implicit((Object)(object)currentDir)) ? (text + "Listing .\n\n") : (text + "Listing " + currentDir.transform.GetRecursiveName() + "\n\n"));
		foreach (Transform item in (from x in GetCurrent()
			where string.IsNullOrEmpty(filter) || ((Object)x).name.Contains(filter)
			select x).Take(40))
		{
			text += $"   {((Object)item).name} [{item.childCount}]\n";
		}
		text += "\n";
		args.ReplyWith(text);
	}

	[ServerVar]
	public static void cd(Arg args)
	{
		if (args.FullString == ".")
		{
			currentDir = null;
			args.ReplyWith("Changed to .");
			return;
		}
		if (args.FullString == "..")
		{
			if (Object.op_Implicit((Object)(object)currentDir))
			{
				currentDir = (Object.op_Implicit((Object)(object)currentDir.transform.parent) ? ((Component)currentDir.transform.parent).gameObject : null);
			}
			currentDir = null;
			if (Object.op_Implicit((Object)(object)currentDir))
			{
				args.ReplyWith("Changed to " + currentDir.transform.GetRecursiveName());
			}
			else
			{
				args.ReplyWith("Changed to .");
			}
			return;
		}
		Transform val = ((IEnumerable<Transform>)GetCurrent()).FirstOrDefault((Func<Transform, bool>)((Transform x) => ((Object)x).name.ToLower() == args.FullString.ToLower()));
		if ((Object)(object)val == (Object)null)
		{
			val = ((IEnumerable<Transform>)GetCurrent()).FirstOrDefault((Func<Transform, bool>)((Transform x) => ((Object)x).name.StartsWith(args.FullString, StringComparison.CurrentCultureIgnoreCase)));
		}
		if (Object.op_Implicit((Object)(object)val))
		{
			currentDir = ((Component)val).gameObject;
			args.ReplyWith("Changed to " + currentDir.transform.GetRecursiveName());
		}
		else
		{
			args.ReplyWith("Couldn't find \"" + args.FullString + "\"");
		}
	}

	[ServerVar]
	public static void del(Arg args)
	{
		if (!args.HasArgs(1))
		{
			return;
		}
		IEnumerable<Transform> enumerable = from x in GetCurrent()
			where ((Object)x).name.ToLower() == args.FullString.ToLower()
			select x;
		if (enumerable.Count() == 0)
		{
			enumerable = from x in GetCurrent()
				where ((Object)x).name.StartsWith(args.FullString, StringComparison.CurrentCultureIgnoreCase)
				select x;
		}
		if (enumerable.Count() == 0)
		{
			args.ReplyWith("Couldn't find  " + args.FullString);
			return;
		}
		foreach (Transform item in enumerable)
		{
			BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
			if (baseEntity.IsValid())
			{
				if (baseEntity.isServer)
				{
					baseEntity.Kill();
				}
			}
			else
			{
				GameManager.Destroy(((Component)item).gameObject);
			}
		}
		args.ReplyWith("Deleted " + enumerable.Count() + " objects");
	}
}


[Factory("input")]
public class Input : ConsoleSystem
{
}


[Factory("instruments")]
public class instruments : ConsoleSystem
{
	public const string InstrumentsFolder = "instruments";
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Newtonsoft.Json;
using Steamworks;
using UnityEngine;

[Factory("inventory")]
public class Inventory : ConsoleSystem
{
	public class SavedLoadout
	{
		public struct SavedItem
		{
			public int id;

			public int amount;

			public ulong skin;

			public int[] containedItems;

			public int blueprintTarget;
		}

		public SavedItem[] belt;

		public SavedItem[] wear;

		public SavedItem[] main;

		public SavedItem[] backpack;

		public int heldItemIndex;

		public SavedLoadout()
		{
		}

		public SavedLoadout(BasePlayer player)
		{
			belt = SaveItems(player.inventory.containerBelt);
			wear = SaveItems(player.inventory.containerWear);
			main = SaveItems(player.inventory.containerMain);
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpack = SaveItems(backpackWithInventory.contents);
			}
			heldItemIndex = GetSlotIndex(player);
		}

		public SavedLoadout(PlayerInventoryProperties properties)
		{
			belt = SaveItems(properties.belt);
			wear = SaveItems(properties.wear);
			main = SaveItems(properties.main);
			heldItemIndex = 0;
		}

		private static SavedItem[] SaveItems(ItemContainer itemContainer)
		{
			List<SavedItem> list = new List<SavedItem>();
			for (int i = 0; i < itemContainer.capacity; i++)
			{
				Item slot = itemContainer.GetSlot(i);
				if (slot == null)
				{
					continue;
				}
				SavedItem savedItem = default(SavedItem);
				savedItem.id = slot.info.itemid;
				savedItem.amount = slot.amount;
				savedItem.skin = slot.skin;
				savedItem.blueprintTarget = slot.blueprintTarget;
				SavedItem item = savedItem;
				if (slot.contents != null && slot.contents.itemList != null)
				{
					List<int> list2 = new List<int>();
					foreach (Item item2 in slot.contents.itemList)
					{
						list2.Add(item2.info.itemid);
					}
					item.containedItems = list2.ToArray();
				}
				list.Add(item);
			}
			return list.ToArray();
		}

		private static SavedItem[] SaveItems(List<PlayerInventoryProperties.ItemAmountSkinned> items)
		{
			List<SavedItem> list = new List<SavedItem>();
			foreach (PlayerInventoryProperties.ItemAmountSkinned item2 in items)
			{
				SavedItem savedItem = default(SavedItem);
				savedItem.id = item2.itemid;
				savedItem.amount = (int)item2.amount;
				savedItem.skin = item2.skinOverride;
				SavedItem item = savedItem;
				if (item2.blueprint)
				{
					item.blueprintTarget = item.id;
					item.id = ItemManager.blueprintBaseDef.itemid;
				}
				list.Add(item);
			}
			return list.ToArray();
		}

		public void LoadItemsOnTo(BasePlayer player)
		{
			player.inventory.containerMain.Clear();
			player.inventory.containerBelt.Clear();
			player.inventory.containerWear.Clear();
			ItemManager.DoRemoves();
			LoadItems(belt, player.inventory.containerBelt);
			LoadItems(wear, player.inventory.containerWear);
			LoadItems(main, player.inventory.containerMain);
			if (backpack != null && backpack.Length != 0)
			{
				Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
				if (backpackWithInventory != null)
				{
					backpackWithInventory.contents.Clear();
					LoadItems(backpack, backpackWithInventory.contents);
				}
			}
			EquipItemInSlot(player, heldItemIndex);
			player.inventory.SendSnapshot();
			void LoadItems(SavedItem[] items, ItemContainer container)
			{
				foreach (SavedItem item in items)
				{
					player.inventory.GiveItem(LoadItem(item), container);
				}
			}
		}

		private Item LoadItem(SavedItem item)
		{
			Item item2 = ItemManager.CreateByItemID(item.id, item.amount, item.skin);
			if (item.blueprintTarget != 0)
			{
				item2.blueprintTarget = item.blueprintTarget;
			}
			if (item.containedItems != null && item.containedItems.Length != 0)
			{
				int[] containedItems = item.containedItems;
				foreach (int itemID in containedItems)
				{
					item2.contents.AddItem(ItemManager.FindItemDefinition(itemID), 1, 0uL);
				}
			}
			return item2;
		}
	}

	[ReplicatedVar(Help = "Disables all attire limitations, so NPC clothing and invalid overlaps can be equipped")]
	public static bool disableAttireLimitations;

	private const string LoadoutDirectory = "loadouts";

	[ServerVar]
	public static bool stackable_item_ownership;

	[ServerUserVar(Name = "lighttoggle")]
	public static void lighttoggle_sv(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead() && !basePlayer.IsSleeping() && !basePlayer.InGesture)
		{
			basePlayer.LightToggle();
		}
	}

	[ServerUserVar]
	public static void endloot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer) && !basePlayer.IsDead() && !basePlayer.IsSleeping())
		{
			basePlayer.inventory.loot.Clear();
		}
	}

	[ServerVar(Help = "{item} {amount} {condition} {skin} {container} {slot}")]
	public static void give(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		bool flag = arg.HasArg("--silent", true);
		Item item = ItemManager.CreateByPartialName(arg.GetString(0, ""), 1, arg.GetULong(3, 0uL));
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		float @float = arg.GetFloat(2, 1f);
		item.conditionNormalized = @float;
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		string @string = arg.GetString(4, "");
		int num2 = arg.GetInt(5, -1);
		ItemContainer itemContainer = null;
		switch (@string)
		{
		case "0":
		case "main":
			itemContainer = basePlayer.inventory.containerMain;
			break;
		case "1":
		case "belt":
			itemContainer = basePlayer.inventory.containerBelt;
			break;
		case "2":
		case "wear":
			itemContainer = basePlayer.inventory.containerWear;
			break;
		}
		if (itemContainer == null)
		{
			if (!basePlayer.inventory.GiveItem(item))
			{
				item.Remove();
				arg.ReplyWith("Couldn't give item (inventory full?)");
				return;
			}
		}
		else
		{
			if (num2 != -1)
			{
				Item slot = itemContainer.GetSlot(num2);
				if (slot != null && slot.contents != null)
				{
					itemContainer = slot.contents;
					num2 = -1;
				}
			}
			if (!item.MoveToContainer(itemContainer, num2))
			{
				item.Remove();
				arg.ReplyWith("Couldn't give item (inventory full?)");
				return;
			}
		}
		if (!flag)
		{
			basePlayer.Command("note.inv", item.info.itemid, num);
		}
		Debug.Log((object)("giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			if (!flag)
			{
				basePlayer.ChatMessage("you silently gave yourself " + num + " x " + item.info.displayName.english);
			}
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar]
	public static void resetbp(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		basePlayer.blueprints.Reset();
	}

	[ServerVar]
	public static void unlockall(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		basePlayer.blueprints.UnlockAll();
	}

	[ServerVar]
	public static void giveall(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Item item = null;
		string text = "SERVER";
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			text = basePlayer.displayName;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				item = ItemManager.CreateByPartialName(arg.GetString(0, ""), 1, 0uL);
				if (item == null)
				{
					arg.ReplyWith("Invalid Item!");
					return;
				}
				int num = (item.amount = arg.GetInt(1, 1));
				item.OnVirginSpawn();
				item.SetItemOwnership(text, ItemOwnershipPhrases.SpawnedPhrase);
				if (!current.inventory.GiveItem(item))
				{
					item.Remove();
					arg.ReplyWith("Couldn't give item (inventory full?)");
					continue;
				}
				current.Command("note.inv", item.info.itemid, num);
				Debug.Log((object)(" [ServerVar] giving " + current.displayName + " " + item.amount + " x " + item.info.displayName.english));
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		if (item != null)
		{
			Chat.Broadcast(text + " gave everyone " + item.amount + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
		}
	}

	[ServerVar(Help = "{item} {player} {amount} {skin}")]
	public static void giveto(Arg arg)
	{
		string text = "SERVER";
		if ((Object)(object)arg.Player() != (Object)null)
		{
			text = arg.Player().displayName;
		}
		BasePlayer basePlayer = BasePlayer.Find(arg.GetString(0, ""));
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Couldn't find player!");
			return;
		}
		Item item = ItemManager.CreateByPartialName(arg.GetString(1, ""), 1, arg.GetULong(3, 0uL));
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(2, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		Chat.Broadcast(text + " gave " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "{itemid} {amount}")]
	public static void giveid(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		Item item = ItemManager.CreateByItemID(arg.GetInt(0, 0), 1, 0uL);
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + num + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself " + num + " x " + item.info.displayName.english);
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + num + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "{itemid} {amount}")]
	public static void givearm(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		Item item = ItemManager.CreateByItemID(arg.GetInt(0, 0), 1, 0uL);
		if (item == null)
		{
			arg.ReplyWith("Invalid Item!");
			return;
		}
		int num = (item.amount = arg.GetInt(1, 1));
		item.OnVirginSpawn();
		item.SetItemOwnership(basePlayer, ItemOwnershipPhrases.SpawnedPhrase);
		if (!basePlayer.inventory.GiveItem(item, basePlayer.inventory.containerBelt))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, num);
		Debug.Log((object)(" [ServerVar] giving " + basePlayer.displayName + " " + item.amount + " x " + item.info.displayName.english));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself " + item.amount + " x " + item.info.displayName.english);
			return;
		}
		Chat.Broadcast(basePlayer.displayName + " gave themselves " + item.amount + " x " + item.info.displayName.english, "SERVER", "#eee", 0uL);
	}

	[ServerVar(Help = "Set worn items to have maximum armor slots supported")]
	public static void setwornarmorslots(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		int @int = arg.GetInt(0, 4);
		foreach (Item item in basePlayer.inventory.containerWear.itemList)
		{
			ItemModContainerArmorSlot component = ((Component)item.info).GetComponent<ItemModContainerArmorSlot>();
			if ((Object)(object)component != (Object)null)
			{
				component.SetSlotAmount(item, Mathf.Min(@int, component.MaxSlots));
			}
		}
	}

	[ServerVar]
	public static void pipetteid(Arg arg)
	{
		BasePlayer ply = arg.Player();
		int itemId = arg.GetInt(0, 0);
		PooledList<Item> val = Pool.Get<PooledList<Item>>();
		try
		{
			ply.inventory.FindItemsByItemID((List<Item>)(object)val, itemId);
			ulong skinId = arg.GetULong(1, 1uL);
			bool flag = false;
			foreach (Item item in (List<Item>)(object)val)
			{
				if (item.skin == skinId)
				{
					flag = true;
				}
			}
			if (!flag)
			{
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemId);
				ply.Command($"give {itemDefinition.shortname} 1 1 {skinId}");
			}
			InvokeHandler.Invoke((Behaviour)(object)ply, (Action)delegate
			{
				ply.Command($"inventory.selectitem {itemId} {skinId}");
			}, 0.2f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Copies the players inventory to the player in front of them")]
	public static void copyTo(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BasePlayer basePlayer2 = null;
		if (arg.HasArgs(1) && arg.GetString(0, "").ToLower() != "true")
		{
			basePlayer2 = arg.GetPlayer(0);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				uint uInt = arg.GetUInt(0, 0u);
				basePlayer2 = BasePlayer.FindByID(uInt);
				if ((Object)(object)basePlayer2 == (Object)null)
				{
					basePlayer2 = BasePlayer.FindBot(uInt);
				}
			}
		}
		else
		{
			basePlayer2 = RelationshipManager.GetLookingAtPlayer(basePlayer);
		}
		if (!((Object)(object)basePlayer2 == (Object)null))
		{
			copyTo(basePlayer, basePlayer2);
		}
	}

	public static void copyTo(BasePlayer from, BasePlayer toply)
	{
		toply.inventory.containerBelt.Clear();
		toply.inventory.containerWear.Clear();
		int num = 0;
		foreach (Item item4 in from.inventory.containerBelt.itemList)
		{
			toply.inventory.containerBelt.AddItem(item4.info, item4.amount, item4.skin);
			if (item4.contents != null && !CopyArmorSlots(item4, toply.inventory.containerBelt.itemList[num], toply))
			{
				Item item = toply.inventory.containerBelt.itemList[num];
				foreach (Item item5 in item4.contents.itemList)
				{
					item.contents.AddItem(item5.info, item5.amount, item5.skin);
				}
			}
			num++;
		}
		foreach (Item item6 in from.inventory.containerWear.itemList)
		{
			toply.inventory.containerWear.AddItem(item6.info, item6.amount, item6.skin);
			if (item6.contents == null)
			{
				continue;
			}
			List<Item> itemList = toply.inventory.containerWear.itemList;
			Item item2 = itemList[itemList.Count - 1];
			if (item6.IsBackpack())
			{
				if (item2 == null)
				{
					continue;
				}
				foreach (Item item7 in item6.contents.itemList)
				{
					item2.contents.AddItem(item7.info, item7.amount, item7.skin);
					if (item7.contents == null)
					{
						continue;
					}
					List<Item> itemList2 = item2.contents.itemList;
					Item item3 = itemList2[itemList2.Count - 1];
					if (CopyArmorSlots(item7, item3, toply))
					{
						continue;
					}
					foreach (Item item8 in item7.contents.itemList)
					{
						item3.contents.AddItem(item8.info, item8.amount, item8.skin);
					}
				}
			}
			else
			{
				CopyArmorSlots(item6, item2, toply);
			}
		}
		if (from.IsDeveloper)
		{
			from.ChatMessage("you silently copied items to " + toply.displayName);
		}
		else
		{
			Chat.Broadcast(from.displayName + " copied their inventory to " + toply.displayName, "SERVER", "#eee", 0uL);
		}
	}

	private static bool CopyArmorSlots(Item sourceItem, Item destItem, BasePlayer player)
	{
		if (sourceItem == null)
		{
			return false;
		}
		if (sourceItem.contents == null)
		{
			return false;
		}
		if (destItem == null)
		{
			return false;
		}
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		ItemModContainerArmorSlot itemModContainerArmorSlot = default(ItemModContainerArmorSlot);
		if (!((Component)sourceItem.info).TryGetComponent<ItemModContainerArmorSlot>(ref itemModContainerArmorSlot))
		{
			return false;
		}
		int capacity = sourceItem.contents.capacity;
		if (capacity == 0)
		{
			return false;
		}
		((Component)destItem.info).GetComponent<ItemModContainerArmorSlot>().CreateAtCapacity(capacity, destItem);
		foreach (Item item in sourceItem.contents.itemList)
		{
			destItem.contents.AddItem(item.info, item.amount, item.skin);
		}
		return true;
	}

	[ServerVar(Help = "Deploys a loadout to players in a radius eg. inventory.deployLoadoutInRange testloadout 30")]
	public static void deployLoadoutInRange(Arg arg)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		string @string = arg.GetString(0, "");
		if (!LoadLoadout(@string, out var so))
		{
			arg.ReplyWith("Can't find loadout: " + @string);
			return;
		}
		float @float = arg.GetFloat(1, 0f);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		int num = 0;
		foreach (BasePlayer item in list)
		{
			if (!((Object)(object)item == (Object)(object)basePlayer) && !item.isClient)
			{
				so.LoadItemsOnTo(item);
				num++;
			}
		}
		arg.ReplyWith($"Applied loadout {@string} to {num} players");
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar(Help = "Deploys the given loadout to a target player. eg. inventory.deployLoadout testloadout jim")]
	public static void deployLoadout(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic))
		{
			string @string = arg.GetString(0, "");
			BasePlayer basePlayer2 = (string.IsNullOrEmpty(arg.GetString(1, "")) ? null : arg.GetPlayerOrSleeperOrBot(1));
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = basePlayer;
			}
			SavedLoadout so;
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				arg.ReplyWith("Could not find player " + arg.GetString(1, "") + " and no local player available");
			}
			else if (LoadLoadout(@string, out so))
			{
				so.LoadItemsOnTo(basePlayer2);
				arg.ReplyWith("Deployed loadout " + @string + " to " + basePlayer2.displayName);
			}
			else
			{
				arg.ReplyWith("Could not find loadout " + @string);
			}
		}
	}

	[ServerVar(Help = "Clears the inventory of a target player. eg. inventory.clearInventory jim. Can take container names as arguments: --belt --wear --backpack")]
	public static void clearInventory(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic))
		{
			return;
		}
		arg.TryRemoveKeyBindEventArgs();
		BasePlayer basePlayer2 = basePlayer;
		StringBuilder stringBuilder = new StringBuilder();
		bool flag = false;
		if (arg.Args == null || arg.Args.Length == 0)
		{
			flag = true;
		}
		else
		{
			int num = 0;
			basePlayer2 = arg.GetPlayerOrSleeperOrBot(0);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				switch (arg.GetString(0, "").ToLower())
				{
				case "--main":
				case "--belt":
				case "--wear":
				case "--backpack":
					break;
				default:
					arg.ReplyWith("Could not find player '" + arg.GetString(0, "") + "'");
					return;
				}
				basePlayer2 = basePlayer;
				num = 0;
			}
			else
			{
				num = 1;
			}
			if (num == 1 && arg.Args.Length == 1)
			{
				flag = true;
			}
			else
			{
				bool flag2 = false;
				bool flag3 = false;
				bool flag4 = false;
				bool flag5 = false;
				for (int i = num; i < arg.Args.Length; i++)
				{
					switch (arg.GetString(i, "").ToLower())
					{
					case "--main":
						flag2 = true;
						break;
					case "--belt":
						flag3 = true;
						break;
					case "--wear":
						flag4 = true;
						break;
					case "--backpack":
						flag5 = true;
						break;
					}
				}
				if (flag2)
				{
					basePlayer2.inventory.containerMain.Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s main inventory");
				}
				if (flag3)
				{
					basePlayer2.inventory.containerBelt.Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s belt");
				}
				if (flag4)
				{
					basePlayer2.inventory.containerWear.Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s clothings");
				}
				if (flag5 && basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents) != null)
				{
					basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents).Clear();
					stringBuilder.AppendLine("Cleared " + basePlayer2.displayName + "'s backpack");
				}
			}
		}
		if (flag)
		{
			basePlayer2.inventory.containerMain.Clear();
			basePlayer2.inventory.containerBelt.Clear();
			basePlayer2.inventory.containerWear.Clear();
			basePlayer2.inventory.GetContainer(PlayerInventory.Type.BackpackContents)?.Clear();
			stringBuilder.AppendLine(basePlayer2.displayName + "'s whole inventory cleared");
		}
		arg.ReplyWith(stringBuilder.ToString());
		ItemManager.DoRemoves();
	}

	private static string GetLoadoutPath(string loadoutName)
	{
		return Server.GetServerFolder("loadouts") + "/" + loadoutName + ".ldt";
	}

	[ServerVar(Help = "Saves the current equipped loadout of the calling player. eg. inventory.saveLoadout loaduoutname")]
	public static void saveloadout(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null) && (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic))
		{
			string @string = arg.GetString(0, "");
			string contents = JsonConvert.SerializeObject((object)new SavedLoadout(basePlayer), (Formatting)1);
			string loadoutPath = GetLoadoutPath(@string);
			File.WriteAllText(loadoutPath, contents);
			arg.ReplyWith("Saved loadout to " + loadoutPath);
		}
	}

	public static bool LoadLoadout(string name, out SavedLoadout so)
	{
		PlayerInventoryProperties inventoryConfig = PlayerInventoryProperties.GetInventoryConfig(name);
		if (inventoryConfig != null)
		{
			Debug.Log((object)"Found builtin config!");
			so = new SavedLoadout(inventoryConfig);
			return true;
		}
		so = new SavedLoadout();
		string loadoutPath = GetLoadoutPath(name);
		if (!File.Exists(loadoutPath))
		{
			return false;
		}
		so = JsonConvert.DeserializeObject<SavedLoadout>(File.ReadAllText(loadoutPath));
		if (so == null)
		{
			return false;
		}
		return true;
	}

	[ServerVar(Help = "Prints all saved inventory loadouts")]
	public static void listloadouts(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic))
		{
			return;
		}
		string serverFolder = Server.GetServerFolder("loadouts");
		StringBuilder stringBuilder = new StringBuilder();
		foreach (string item in Directory.EnumerateFiles(serverFolder))
		{
			stringBuilder.AppendLine(item);
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void defs(Arg arg)
	{
		if (SteamInventory.Definitions == null)
		{
			arg.ReplyWith("no definitions");
			return;
		}
		if (SteamInventory.Definitions.Length == 0)
		{
			arg.ReplyWith("0 definitions");
			return;
		}
		string[] array = SteamInventory.Definitions.Select((InventoryDef x) => x.Name).ToArray();
		arg.ReplyWith((object)array);
	}

	[ClientVar]
	[ServerVar]
	public static void reloaddefs(Arg arg)
	{
		SteamInventory.LoadItemDefinitions();
	}

	[ServerVar]
	public static void equipslottarget(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic) && !((Object)(object)basePlayer == (Object)null))
		{
			BasePlayer lookingAtPlayer = RelationshipManager.GetLookingAtPlayer(basePlayer);
			if (!((Object)(object)lookingAtPlayer == (Object)null))
			{
				int @int = arg.GetInt(0, 0);
				EquipItemInSlot(lookingAtPlayer, @int);
				arg.ReplyWith($"Equipped slot {@int} on player {lookingAtPlayer.displayName}");
			}
		}
	}

	[ServerVar]
	public static void equipslot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic) || (Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		BasePlayer basePlayer2 = null;
		if (arg.HasArgs(2))
		{
			basePlayer2 = arg.GetPlayer(1);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				uint uInt = arg.GetUInt(1, 0u);
				basePlayer2 = BasePlayer.FindByID(uInt);
				if ((Object)(object)basePlayer2 == (Object)null)
				{
					basePlayer2 = BasePlayer.FindBot(uInt);
				}
			}
		}
		if (!((Object)(object)basePlayer2 == (Object)null))
		{
			int @int = arg.GetInt(0, 0);
			EquipItemInSlot(basePlayer2, @int);
			Debug.Log((object)$"Equipped slot {@int} on player {basePlayer2.displayName}");
		}
	}

	public static void EquipItemInSlot(BasePlayer player, int slot)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		ItemId itemID = default(ItemId);
		for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
		{
			if (player.inventory.containerBelt.itemList[i] != null && i == slot)
			{
				itemID = player.inventory.containerBelt.itemList[i].uid;
				break;
			}
		}
		player.UpdateActiveItem(itemID);
	}

	private static int GetSlotIndex(BasePlayer player)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (player.GetActiveItem() == null)
		{
			return -1;
		}
		ItemId uid = player.GetActiveItem().uid;
		for (int i = 0; i < player.inventory.containerBelt.itemList.Count; i++)
		{
			if (player.inventory.containerBelt.itemList[i] != null && player.inventory.containerBelt.itemList[i].uid == uid)
			{
				return i;
			}
		}
		return -1;
	}

	[ServerVar]
	public static void giveBp(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		ItemDefinition itemDefinition = ItemManager.FindDefinitionByPartialName(arg.GetString(0, ""));
		if ((Object)(object)itemDefinition == (Object)null)
		{
			arg.ReplyWith("Could not find item: " + arg.GetString(0, ""));
			return;
		}
		if ((Object)(object)itemDefinition.Blueprint == (Object)null)
		{
			arg.ReplyWith(itemDefinition.shortname + " has no blueprint!");
			return;
		}
		Item item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
		item.blueprintTarget = itemDefinition.itemid;
		item.OnVirginSpawn();
		if (!basePlayer.inventory.GiveItem(item))
		{
			item.Remove();
			arg.ReplyWith("Couldn't give item (inventory full?)");
			return;
		}
		basePlayer.Command("note.inv", item.info.itemid, 1);
		Debug.Log((object)("giving " + basePlayer.displayName + " 1 x " + item.blueprintTargetDef.shortname + " blueprint"));
		if (basePlayer.IsDeveloper)
		{
			basePlayer.ChatMessage("you silently gave yourself 1 x " + item.blueprintTargetDef.shortname + " blueprint");
		}
		else
		{
			Chat.Broadcast(basePlayer.displayName + " gave themselves 1 x " + item.blueprintTargetDef.shortname + " blueprint", "SERVER", "#eee", 0uL);
		}
	}

	[ServerVar(Help = "Add ownership to item")]
	public static void addownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Usage: addownership {username} {reason} {amount}");
			return;
		}
		string @string = args.GetString(0, "");
		string string2 = args.GetString(1, "");
		int @int = args.GetInt(2, 1);
		activeItem.AddItemOwnership(@string, string2, @int);
		args.ReplyWith($"Added '{@int}' ownership to item");
	}

	[ServerVar(Help = "Reduce ownership to item to allow new ownership to be added")]
	public static void reduceownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(1))
		{
			args.ReplyWith("Usage: reduceownership {amount}");
			return;
		}
		int @int = args.GetInt(0, 1);
		activeItem.ReduceItemOwnership(@int);
		args.ReplyWith($"Reduced ownership of item by '{@int}'");
	}

	[ServerVar(Help = "Reduce ownership to item to allow new ownership to be added")]
	public static void convertownership(Arg args)
	{
		Item activeItem = args.Player().GetActiveItem();
		if (activeItem == null)
		{
			args.ReplyWith("You must be holding an item to use this command");
			return;
		}
		if (!args.HasArgs(3))
		{
			args.ReplyWith("Usage: convertownership {username} {reason} {amount}");
			return;
		}
		string @string = args.GetString(0, "");
		string string2 = args.GetString(1, "");
		int @int = args.GetInt(2, 1);
		activeItem.ReduceItemOwnership(@int);
		activeItem.AddItemOwnership(@string, string2, @int);
		args.ReplyWith($"Converted '{@int}' ownership of item to '{@string}'");
	}
}


using System.Collections.Generic;

public class SavedLoadout
{
	public struct SavedItem
	{
		public int id;

		public int amount;

		public ulong skin;

		public int[] containedItems;

		public int blueprintTarget;
	}

	public SavedItem[] belt;

	public SavedItem[] wear;

	public SavedItem[] main;

	public SavedItem[] backpack;

	public int heldItemIndex;

	public SavedLoadout()
	{
	}

	public SavedLoadout(BasePlayer player)
	{
		belt = SaveItems(player.inventory.containerBelt);
		wear = SaveItems(player.inventory.containerWear);
		main = SaveItems(player.inventory.containerMain);
		Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
		if (backpackWithInventory != null)
		{
			backpack = SaveItems(backpackWithInventory.contents);
		}
		heldItemIndex = GetSlotIndex(player);
	}

	public SavedLoadout(PlayerInventoryProperties properties)
	{
		belt = SaveItems(properties.belt);
		wear = SaveItems(properties.wear);
		main = SaveItems(properties.main);
		heldItemIndex = 0;
	}

	private static SavedItem[] SaveItems(ItemContainer itemContainer)
	{
		List<SavedItem> list = new List<SavedItem>();
		for (int i = 0; i < itemContainer.capacity; i++)
		{
			Item slot = itemContainer.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			SavedItem savedItem = default(SavedItem);
			savedItem.id = slot.info.itemid;
			savedItem.amount = slot.amount;
			savedItem.skin = slot.skin;
			savedItem.blueprintTarget = slot.blueprintTarget;
			SavedItem item = savedItem;
			if (slot.contents != null && slot.contents.itemList != null)
			{
				List<int> list2 = new List<int>();
				foreach (Item item2 in slot.contents.itemList)
				{
					list2.Add(item2.info.itemid);
				}
				item.containedItems = list2.ToArray();
			}
			list.Add(item);
		}
		return list.ToArray();
	}

	private static SavedItem[] SaveItems(List<PlayerInventoryProperties.ItemAmountSkinned> items)
	{
		List<SavedItem> list = new List<SavedItem>();
		foreach (PlayerInventoryProperties.ItemAmountSkinned item2 in items)
		{
			SavedItem savedItem = default(SavedItem);
			savedItem.id = item2.itemid;
			savedItem.amount = (int)item2.amount;
			savedItem.skin = item2.skinOverride;
			SavedItem item = savedItem;
			if (item2.blueprint)
			{
				item.blueprintTarget = item.id;
				item.id = ItemManager.blueprintBaseDef.itemid;
			}
			list.Add(item);
		}
		return list.ToArray();
	}

	public void LoadItemsOnTo(BasePlayer player)
	{
		player.inventory.containerMain.Clear();
		player.inventory.containerBelt.Clear();
		player.inventory.containerWear.Clear();
		ItemManager.DoRemoves();
		LoadItems(belt, player.inventory.containerBelt);
		LoadItems(wear, player.inventory.containerWear);
		LoadItems(main, player.inventory.containerMain);
		if (backpack != null && backpack.Length != 0)
		{
			Item backpackWithInventory = player.inventory.GetBackpackWithInventory();
			if (backpackWithInventory != null)
			{
				backpackWithInventory.contents.Clear();
				LoadItems(backpack, backpackWithInventory.contents);
			}
		}
		EquipItemInSlot(player, heldItemIndex);
		player.inventory.SendSnapshot();
		void LoadItems(SavedItem[] items, ItemContainer container)
		{
			foreach (SavedItem item in items)
			{
				player.inventory.GiveItem(LoadItem(item), container);
			}
		}
	}

	private Item LoadItem(SavedItem item)
	{
		Item item2 = ItemManager.CreateByItemID(item.id, item.amount, item.skin);
		if (item.blueprintTarget != 0)
		{
			item2.blueprintTarget = item.blueprintTarget;
		}
		if (item.containedItems != null && item.containedItems.Length != 0)
		{
			int[] containedItems = item.containedItems;
			foreach (int itemID in containedItems)
			{
				item2.contents.AddItem(ItemManager.FindItemDefinition(itemID), 1, 0uL);
			}
		}
		return item2;
	}
}


public struct SavedItem
{
	public int id;

	public int amount;

	public ulong skin;

	public int[] containedItems;

	public int blueprintTarget;
}


[Factory("layer")]
public class Layer : ConsoleSystem
{
}


[Factory("legs")]
public class Legs : ConsoleSystem
{
}


[Factory("lerp")]
public class Lerp : ConsoleSystem
{
}


[Factory("lod")]
public class LOD : ConsoleSystem
{
}


using Facepunch;

public class Manifest
{
	[ServerVar]
	[ClientVar]
	public static object PrintManifest()
	{
		return Application.Manifest;
	}

	[ClientVar]
	[ServerVar]
	public static object PrintManifestRaw()
	{
		return Manifest.Contents;
	}
}


using System;
using System.IO;
using Unity.Profiling.Memory;

[Factory("memsnap")]
public class MemSnap : ConsoleSystem
{
	private static string NeedProfileFolder()
	{
		string path = "profile";
		if (!Directory.Exists(path))
		{
			return Directory.CreateDirectory(path).FullName;
		}
		return new DirectoryInfo(path).FullName;
	}

	[ClientVar]
	[ServerVar]
	public static void managed(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)1);
	}

	[ClientVar]
	[ServerVar]
	public static void native(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)2);
	}

	[ClientVar]
	[ServerVar]
	public static void full(Arg arg)
	{
		MemoryProfiler.TakeSnapshot(NeedProfileFolder() + "/memdump-" + DateTime.Now.ToString("MM-dd-yyyy-h-mm-ss") + ".snap", (Action<string, bool>)null, (CaptureFlags)31);
	}
}


[Factory("mesh")]
public class Mesh : ConsoleSystem
{
}


using System.Text;
using UnityEngine;

[Factory("music")]
public class Music : ConsoleSystem
{
	[ClientVar]
	public static bool enabled = true;

	[ClientVar]
	public static int songGapMin = 240;

	[ClientVar]
	public static int songGapMax = 480;

	[ClientVar]
	public static void info(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)SingletonComponent<MusicManager>.Instance == (Object)null)
		{
			stringBuilder.Append("No music manager was found");
		}
		else
		{
			stringBuilder.Append("Current music info: ");
			stringBuilder.AppendLine();
			stringBuilder.Append("  theme: " + (object)SingletonComponent<MusicManager>.Instance.currentTheme);
			stringBuilder.AppendLine();
			stringBuilder.Append("  intensity: " + SingletonComponent<MusicManager>.Instance.intensity);
			stringBuilder.AppendLine();
			stringBuilder.Append("  next music: " + SingletonComponent<MusicManager>.Instance.nextMusic);
			stringBuilder.AppendLine();
			stringBuilder.Append("  current time: " + Time.time);
			stringBuilder.AppendLine();
		}
		arg.ReplyWith(stringBuilder.ToString());
	}
}


[Factory("net")]
public class Net : ConsoleSystem
{
	[ServerVar]
	public static bool visdebug = false;

	[ClientVar]
	public static bool debug = false;

	[ServerVar]
	public static int visibilityRadiusFarOverride = -1;

	[ServerVar]
	public static int visibilityRadiusNearOverride = -1;

	[ServerVar(Name = "global_networked_bases")]
	public static bool globalNetworkedBases = true;

	[ServerVar(Help = "Toggle printing time taken to send all global entities to client when they connect")]
	public static bool global_network_debug = false;

	[ServerVar(Help = "Toggle checking network group bounds whenever an entity changes its network group")]
	public static bool network_group_debug = false;

	[ServerVar(Help = "(default) true = only broadcast to clients with global networking enabled, false = broadcast to every client regardless")]
	public static bool limit_global_update_broadcast = true;
}


[Factory("netgraph")]
public class Netgraph : ConsoleSystem
{
}


using System;
using Facepunch;
using ProtoBuf.Nexus;
using UnityEngine;

[Factory("nexus")]
public class Nexus : ConsoleSystem
{
	public static readonly Phrase RedirectPhrase = new Phrase("loading.redirect", "Switching servers");

	private const string DefaultEndpoint = "https://api.facepunch.com/api/nexus/";

	[ReplicatedVar(Help = "URL endpoint to use for the Nexus API", Default = "https://api.facepunch.com/api/nexus/")]
	public static string endpoint = "https://api.facepunch.com/api/nexus/";

	[ServerVar(Clientside = true)]
	public static bool logging = true;

	[ServerVar]
	public static string secretKey = "";

	[ServerVar]
	public static string zoneController = "basic";

	[ServerVar(Help = "Time in seconds to allow the server to process nexus messages before re-sending (requires restart)")]
	public static int messageLockDuration = 5;

	[ServerVar(Help = "Maximum amount of time in seconds that transfers should be cached before auto-saving")]
	public static int transferFlushTime = 60;

	[ServerVar(Help = "How far away islands should be spawned, as a factor of the map size")]
	public static float islandSpawnDistance = 1.5f;

	[ServerVar(Help = "Default distance between zones to allow boat travel, if map.contactRadius isn't set in the nexus (uses normalized coordinates)")]
	public static float defaultZoneContactRadius = 0.33f;

	[ServerVar(Help = "Time offset in hours from the nexus clock")]
	public static float timeOffset = 0f;

	[ServerVar(Help = "Multiplier for nexus RPC timeout durations in case we expect different latencies")]
	public static float rpcTimeoutMultiplier = 1f;

	[ServerVar(Help = "Time in seconds to keep players in the loading state before going to sleep")]
	public static float loadingTimeout = 900f;

	[ServerVar(Help = "Time in seconds to wait between server status pings")]
	public static float pingInterval = 30f;

	[ServerVar(Help = "Maximum time in seconds to keep transfer protection enabled on entities")]
	public static float protectionDuration = 300f;

	[ServerVar(Help = "Maximum duration in seconds to batch clan chat messages to send to other servers on the nexus")]
	public static float clanClatBatchDuration = 1f;

	[ServerVar(Help = "Interval in seconds to broadcast the player manifest to other servers on the nexus")]
	public static float playerManifestInterval = 30f;

	[ServerVar(Help = "Scale of the map to render and upload to the nexus")]
	public static float mapImageScale = 0.5f;

	[ServerVar]
	public static void transfer(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		string text = arg.GetString(0, "")?.Trim();
		if (string.IsNullOrWhiteSpace(text))
		{
			arg.ReplyWith("Usage: nexus.transfer <target_zone>");
			return;
		}
		if (string.Equals(text, NexusServer.ZoneKey, StringComparison.InvariantCultureIgnoreCase))
		{
			arg.ReplyWith("You're already on the target zone");
			return;
		}
		BasePlayer basePlayer = arg.Connection.player as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Must be run as a player");
		}
		else
		{
			NexusServer.TransferEntity(basePlayer, text, "console", includeFerry: false);
		}
	}

	[ServerVar]
	public static void refreshislands(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			NexusServer.UpdateIslands();
		}
	}

	[ServerVar]
	public static void ping(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		string @string = arg.GetString(0, "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			arg.ReplyWith("Usage: nexus.ping <target_zone>");
		}
		else
		{
			SendPing(arg.Player(), @string);
		}
		static async void SendPing(BasePlayer requester, string to)
		{
			Request val = Pool.Get<Request>();
			val.ping = Pool.Get<PingRequest>();
			float startTime = Time.realtimeSinceStartup;
			try
			{
				await NexusServer.ZoneRpc(to, val);
				float num = Time.realtimeSinceStartup - startTime;
				requester?.ConsoleMessage($"Ping took {num:F3}s");
			}
			catch (Exception arg2)
			{
				requester?.ConsoleMessage($"Failed to ping zone {to}: {arg2}");
			}
		}
	}

	[ServerVar]
	public static void broadcast_ping(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			SendBroadcastPing(arg.Player());
		}
		static async void SendBroadcastPing(BasePlayer requester)
		{
			Request val = Pool.Get<Request>();
			val.ping = Pool.Get<PingRequest>();
			float startTime = Time.realtimeSinceStartup;
			try
			{
				using NexusRpcResult nexusRpcResult = await NexusServer.BroadcastRpc(val);
				float num = Time.realtimeSinceStartup - startTime;
				string arg2 = string.Join(", ", nexusRpcResult.Responses.Keys);
				requester?.ConsoleMessage($"Broadcast ping took {num:F3}s, response received from zones: {arg2}");
			}
			catch (Exception arg3)
			{
				requester?.ConsoleMessage($"Failed to broadcast ping: {arg3}");
			}
		}
	}

	[ServerVar]
	public static void playeronline(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
			return;
		}
		ulong uInt = arg.GetUInt64(0, 0uL);
		if (uInt == 0L)
		{
			arg.ReplyWith("Usage: nexus.playeronline <steamID64>");
			return;
		}
		bool flag = NexusServer.IsOnline(uInt);
		arg.ReplyWith(flag ? "Online" : "Offline");
	}

	[ServerVar(Help = "Reupload the map image to the nexus. Normally happens automatically at server boot. WARNING: This will lag the server!")]
	public static void uploadmap(Arg arg)
	{
		if (!NexusServer.Started)
		{
			arg.ReplyWith("Server is not connected to a nexus");
		}
		else
		{
			NexusServer.UploadMapImage(force: true);
		}
	}
}


[Factory("note")]
public class Note : ConsoleSystem
{
}


[Factory("npc")]
public class NPC_ConVars : ConsoleSystem
{
	[ReplicatedVar]
	public static bool vendor_minicopter_enabled = true;

	[ReplicatedVar]
	public static bool vendor_attack_heli_enabled = true;

	[ReplicatedVar]
	public static bool vendor_scrap_heli_enabled = true;

	[ReplicatedVar]
	public static bool vendor_hab_enabled = true;

	[ReplicatedVar]
	public static bool vendor_rowboat_enabled = true;

	[ReplicatedVar]
	public static bool vendor_rhib_enabled = true;

	[ReplicatedVar]
	public static bool vendor_sub_solo_enabled = true;

	[ReplicatedVar]
	public static bool vendor_sub_duo_enabled = true;
}


[Factory("particle")]
public class Particle : ConsoleSystem
{
}


public static class party
{
	[ServerVar]
	public static int maxpartyspawnattempts = 50;

	[ServerVar]
	public static int maxpartyspawndistance = 100;

	[ServerVar]
	public static bool nearbypartyspawns = true;
}


using UnityEngine;

[Factory("physics")]
public class Physics : ConsoleSystem
{
	[ServerVar(Help = "The collision detection mode that dropped items and corpses should use")]
	public static int droppedmode = 2;

	[ServerVar(Help = "Send effects to clients when physics objects collide")]
	public static bool sendeffects = true;

	[ServerVar]
	public static bool groundwatchdebug = false;

	[ServerVar]
	public static int groundwatchfails = 1;

	[ServerVar]
	public static float groundwatchdelay = 0.1f;

	[ServerVar(Help = "The collision detection mode that server-side ragdolls should use")]
	public static int serverragdollmode = 3;

	private const float baseGravity = -9.81f;

	private static bool _serversideragdolls = false;

	[ServerVar]
	public static float towingmaxlinearaccelfromjoint = 40f;

	[ServerVar]
	public static bool allowplayertempragdoll = true;

	[ServerVar]
	public static bool allowhorsetempragdoll = true;

	[ServerVar]
	[ClientVar]
	public static bool batchsynctransforms = true;

	private static bool _treecollision = true;

	[ServerVar]
	public static float bouncethreshold
	{
		get
		{
			return Physics.bounceThreshold;
		}
		set
		{
			Physics.bounceThreshold = value;
		}
	}

	[ServerVar]
	public static float sleepthreshold
	{
		get
		{
			return Physics.sleepThreshold;
		}
		set
		{
			Physics.sleepThreshold = value;
		}
	}

	[ServerVar(Help = "The default solver iteration count permitted for any rigid bodies (default 7). Must be positive")]
	public static int solveriterationcount
	{
		get
		{
			return Physics.defaultSolverIterations;
		}
		set
		{
			Physics.defaultSolverIterations = value;
		}
	}

	[ReplicatedVar(Help = "Gravity multiplier", Default = "1.0")]
	public static float gravity
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			return Physics.gravity.y / -9.81f;
		}
		set
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			Physics.gravity = new Vector3(0f, value * -9.81f, 0f);
		}
	}

	[ReplicatedVar(Help = "Do ragdoll physics calculations on the server, or use the old client-side system", Saved = true, ShowInAdminUI = true)]
	public static bool serversideragdolls
	{
		get
		{
			return _serversideragdolls;
		}
		set
		{
			_serversideragdolls = value;
			Physics.IgnoreLayerCollision(9, 13, !_serversideragdolls);
			Physics.IgnoreLayerCollision(9, 11, !_serversideragdolls);
			Physics.IgnoreLayerCollision(9, 28, !_serversideragdolls);
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool autosynctransforms
	{
		get
		{
			return Physics.autoSyncTransforms;
		}
		set
		{
			Physics.autoSyncTransforms = value;
		}
	}

	[ReplicatedVar(Help = "Do players and vehicles collide with trees?", Saved = true, ShowInAdminUI = true)]
	public static bool treecollision
	{
		get
		{
			return _treecollision;
		}
		set
		{
			_treecollision = value;
			Physics.IgnoreLayerCollision(15, 30, !_treecollision);
			Physics.IgnoreLayerCollision(12, 30, !_treecollision);
		}
	}

	internal static void ApplyDropped(Rigidbody rigidBody)
	{
		if (droppedmode <= 0)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)0;
		}
		if (droppedmode == 1)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)1;
		}
		if (droppedmode == 2)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)2;
		}
		if (droppedmode >= 3)
		{
			rigidBody.collisionDetectionMode = (CollisionDetectionMode)3;
		}
	}
}


using Facepunch.Ping;

[Factory("ping")]
public class Ping : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static int ping_samples
	{
		get
		{
			return PingEstimater.numSamples;
		}
		set
		{
			PingEstimater.numSamples = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool ping_parallel
	{
		get
		{
			return PingEstimater.parallel;
		}
		set
		{
			PingEstimater.parallel = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static int ping_refresh_interval
	{
		get
		{
			return PingEstimater.refreshIntervalMinutes;
		}
		set
		{
			PingEstimater.refreshIntervalMinutes = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool auto_refresh_region
	{
		get
		{
			return PingEstimater.AutoRefresh;
		}
		set
		{
			PingEstimater.AutoRefresh = value;
		}
	}

	[ClientVar]
	[ServerVar]
	public static bool ping_estimate_logging
	{
		get
		{
			return PingEstimater.logging;
		}
		set
		{
			PingEstimater.logging = value;
		}
	}

	[ServerVar]
	[ClientVar]
	public static bool ping_estimation
	{
		get
		{
			return PingEstimater.enabled;
		}
		set
		{
			PingEstimater.enabled = value;
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

[Factory("player")]
public class Player : ConsoleSystem
{
	public const string serverTickRateDefaultString = "16";

	public static int serverTickRate = 16;

	public const int serverTickRateDefault = 16;

	public const int serverTickRateMin = 16;

	public const int serverTickRateMax = 128;

	public static float serverTickInterval = 0.0625f;

	public const string clientTickRateDefaultString = "32";

	public const int clientTickRateDefault = 32;

	public const int clientTickRateMin = 16;

	public const int clientTickRateMax = 128;

	public static EncryptedValue<int> clientTickRate = 32;

	public static EncryptedValue<float> clientTickInterval = 1f / 32f;

	[ClientVar(ClientInfo = true)]
	public static bool InfiniteAmmo = false;

	[ServerVar]
	public static bool keepteaondeath = false;

	[ServerVar]
	public static bool dropbackpackondeath = true;

	[ServerVar]
	public static bool dropbackpackondowned = true;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Whether the crawling state expires")]
	public static bool woundforever = false;

	[ReplicatedVar(Default = "16")]
	public static int tickrate_sv
	{
		get
		{
			return serverTickRate;
		}
		set
		{
			serverTickRate = Mathf.Clamp(value, 16, 128);
			serverTickInterval = 1f / (float)serverTickRate;
		}
	}

	[ReplicatedVar(Default = "32")]
	public static int tickrate_cl
	{
		get
		{
			return clientTickRate;
		}
		set
		{
			clientTickRate = Mathf.Clamp(value, 16, 128);
			clientTickInterval = 1f / (float)(int)clientTickRate;
		}
	}

	[ClientVar(AllowRunFromServer = true)]
	[ServerUserVar]
	public static void cinematic_play(Arg arg)
	{
		if (!arg.HasArgs(1) || !arg.IsServerside)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string strCommand = string.Empty;
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				strCommand = arg.cmd.FullName + " " + arg.FullString + " " + basePlayer.UserIDString;
			}
			else if (Server.cinematic)
			{
				strCommand = arg.cmd.FullName + " " + arg.GetString(0, "") + " " + basePlayer.UserIDString;
			}
			if (Server.cinematic)
			{
				ConsoleNetwork.BroadcastToAllClients(strCommand);
			}
			else if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				ConsoleNetwork.SendClientCommand(arg.Connection, strCommand);
			}
		}
	}

	[ClientVar(AllowRunFromServer = true)]
	[ServerUserVar]
	public static void cinematic_stop(Arg arg)
	{
		if (!arg.IsServerside)
		{
			return;
		}
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string strCommand = string.Empty;
			if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				strCommand = arg.cmd.FullName + " " + arg.FullString + " " + basePlayer.UserIDString;
			}
			else if (Server.cinematic)
			{
				strCommand = arg.cmd.FullName + " " + basePlayer.UserIDString;
			}
			if (Server.cinematic)
			{
				ConsoleNetwork.BroadcastToAllClients(strCommand);
			}
			else if (basePlayer.IsAdmin || basePlayer.IsDeveloper)
			{
				ConsoleNetwork.SendClientCommand(arg.Connection, strCommand);
			}
		}
	}

	[ServerUserVar]
	public static void cinematic_gesture(Arg arg)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (Server.cinematic)
		{
			string @string = arg.GetString(0, "");
			BasePlayer basePlayer = arg.GetPlayer(1);
			if ((Object)(object)basePlayer == (Object)null)
			{
				basePlayer = arg.Player();
			}
			basePlayer.UpdateActiveItem(default(ItemId));
			basePlayer.SignalBroadcast(BaseEntity.Signal.Gesture, @string);
		}
	}

	[ServerUserVar]
	public static void copyrotation(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			uint uInt = arg.GetUInt(0, 0u);
			BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = BasePlayer.FindBot(uInt);
			}
			if ((Object)(object)basePlayer2 != (Object)null)
			{
				basePlayer2.CopyRotation(basePlayer);
				Debug.Log((object)("Copied rotation of " + basePlayer2.UserIDString));
			}
		}
	}

	[ServerUserVar]
	public static void abandonmission(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.HasActiveMission())
		{
			basePlayer.AbandonActiveMission();
		}
	}

	[ServerUserVar]
	public static void mount(Arg arg)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer2 == (Object)null)
		{
			basePlayer2 = BasePlayer.FindBot(uInt);
		}
		RaycastHit hit = default(RaycastHit);
		if (!Object.op_Implicit((Object)(object)basePlayer2) || !Physics.Raycast(basePlayer.eyes.position, basePlayer.eyes.HeadForward(), ref hit, 5f, 10496, (QueryTriggerInteraction)1))
		{
			return;
		}
		BaseEntity entity = hit.GetEntity();
		if (!Object.op_Implicit((Object)(object)entity))
		{
			return;
		}
		BaseMountable baseMountable = ((Component)entity).GetComponent<BaseMountable>();
		if (!Object.op_Implicit((Object)(object)baseMountable))
		{
			BaseVehicle baseVehicle = ((Component)entity).GetComponentInParent<BaseVehicle>();
			if (Object.op_Implicit((Object)(object)baseVehicle))
			{
				if (!baseVehicle.isServer)
				{
					baseVehicle = BaseNetworkable.serverEntities.Find(baseVehicle.net.ID) as BaseVehicle;
				}
				baseVehicle.AttemptMount(basePlayer2);
				return;
			}
		}
		if (Object.op_Implicit((Object)(object)baseMountable) && !baseMountable.isServer)
		{
			baseMountable = BaseNetworkable.serverEntities.Find(baseMountable.net.ID) as BaseMountable;
		}
		if (Object.op_Implicit((Object)(object)baseMountable))
		{
			baseMountable.AttemptMount(basePlayer2);
		}
	}

	[ServerVar]
	public static void gotosleep(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindSleeping(uInt.ToString());
		if (!Object.op_Implicit((Object)(object)basePlayer2))
		{
			basePlayer2 = BasePlayer.FindBotClosestMatch(uInt.ToString());
			if (basePlayer2.IsSleeping())
			{
				basePlayer2 = null;
			}
		}
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			basePlayer2.StartSleeping();
		}
	}

	[ServerVar(Help = "optional param {player}", ClientAdmin = true)]
	public static void ragdoll(Arg arg)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			BasePlayer basePlayer2 = arg.GetPlayerOrSleeperOrBot(0) ?? basePlayer;
			if (!((Object)(object)basePlayer2 == (Object)null))
			{
				basePlayer2.Ragdoll();
			}
		}
	}

	[ServerVar(Help = "Ragdolls a player you're looking at", ClientAdmin = true)]
	public static void ragdollother(Arg arg)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic) && GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0.5f, out var hitInfo, 5f, 1218652417, (QueryTriggerInteraction)0, basePlayer) && hitInfo.GetEntity() is BasePlayer { isClient: false } basePlayer2)
		{
			basePlayer2.Ragdoll();
		}
	}

	[ServerVar(Help = "ragdolls")]
	public static void ragdollall(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "ragdolls everyone except player")]
	public static void ragdollallbutme(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				if (!((Object)(object)current == (Object)(object)basePlayer))
				{
					current.Ragdoll();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.bots.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Ragdoll();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void dismount(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			uint uInt = arg.GetUInt(0, 0u);
			BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
			if ((Object)(object)basePlayer2 == (Object)null)
			{
				basePlayer2 = BasePlayer.FindBot(uInt);
			}
			if (Object.op_Implicit((Object)(object)basePlayer2) && Object.op_Implicit((Object)(object)basePlayer2) && basePlayer2.isMounted)
			{
				basePlayer2.GetMounted().DismountPlayer(basePlayer2);
			}
		}
	}

	[ServerVar]
	public static void swapseat(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		uint uInt = arg.GetUInt(0, 0u);
		BasePlayer basePlayer2 = BasePlayer.FindByID(uInt);
		if ((Object)(object)basePlayer2 == (Object)null)
		{
			basePlayer2 = BasePlayer.FindBot(uInt);
		}
		if (Object.op_Implicit((Object)(object)basePlayer2))
		{
			int @int = arg.GetInt(1, 0);
			if (Object.op_Implicit((Object)(object)basePlayer2) && basePlayer2.isMounted && Object.op_Implicit((Object)(object)basePlayer2.GetMounted().VehicleParent()))
			{
				basePlayer2.GetMounted().VehicleParent().SwapSeats(basePlayer2, @int);
			}
		}
	}

	[ServerVar]
	public static void wakeup(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (basePlayer.IsAdmin || basePlayer.IsDeveloper || Server.cinematic)
		{
			BasePlayer basePlayer2 = BasePlayer.FindSleeping(arg.GetUInt(0, 0u).ToString());
			if (Object.op_Implicit((Object)(object)basePlayer2))
			{
				basePlayer2.EndSleeping();
			}
		}
	}

	[ServerVar]
	public static void wakeupall(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (!basePlayer.IsAdmin && !basePlayer.IsDeveloper && !Server.cinematic)
		{
			return;
		}
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Enumerator<BasePlayer> enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				list.Add(current);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		foreach (BasePlayer item in list)
		{
			item.EndSleeping();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void printstats(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!Object.op_Implicit((Object)(object)basePlayer))
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsAlive:F1}s alive");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsSleeping:F1}s sleeping");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsSwimming:F1}s swimming");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsInBase:F1}s in base");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsWilderness:F1}s in wilderness");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsInMonument:F1}s in monuments");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsFlying:F1}s flying");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsBoating:F1}s boating");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.secondsDriving:F1}s driving");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.metersRun:F1}m run");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.metersWalked:F1}m walked");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.totalDamageTaken:F1} damage taken");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.totalHealing:F1} damage healed");
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedPlayers} other players killed");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedScientists} scientists killed");
		stringBuilder.AppendLine($"{basePlayer.lifeStory.killedAnimals} animals killed");
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine("Weapon stats:");
		if (basePlayer.lifeStory.weaponStats != null)
		{
			foreach (WeaponStats weaponStat in basePlayer.lifeStory.weaponStats)
			{
				float num = (float)weaponStat.shotsHit / (float)weaponStat.shotsFired;
				num *= 100f;
				stringBuilder.AppendLine($"{weaponStat.weaponName} - shots fired: {weaponStat.shotsFired} shots hit: {weaponStat.shotsHit} accuracy: {num:F1}%");
			}
		}
		stringBuilder.AppendLine("===");
		stringBuilder.AppendLine("Misc stats:");
		if (basePlayer.lifeStory.genericStats != null)
		{
			foreach (GenericStat genericStat in basePlayer.lifeStory.genericStats)
			{
				stringBuilder.AppendLine($"{genericStat.key} = {genericStat.value}");
			}
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void printpresence(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		bool flag = (basePlayer.currentTimeCategory & 1) != 0;
		bool flag2 = (basePlayer.currentTimeCategory & 4) != 0;
		bool flag3 = (basePlayer.currentTimeCategory & 2) != 0;
		bool flag4 = (basePlayer.currentTimeCategory & 0x20) != 0;
		bool flag5 = (basePlayer.currentTimeCategory & 0x10) != 0;
		bool flag6 = (basePlayer.currentTimeCategory & 8) != 0;
		arg.ReplyWith($"Wilderness:{flag} Base:{flag2} Monument:{flag3} Swimming: {flag4} Boating: {flag5} Flying: {flag6}");
	}

	[ServerVar(Help = "Resets the PlayerState of the given player")]
	public static void resetstate(Arg args)
	{
		BasePlayer playerOrSleeper = args.GetPlayerOrSleeper(0);
		if ((Object)(object)playerOrSleeper == (Object)null)
		{
			args.ReplyWith("Player not found");
			return;
		}
		playerOrSleeper.ResetPlayerState();
		args.ReplyWith("Player state reset");
	}

	[ServerVar(ServerAdmin = true)]
	public static void fillwater(Arg arg)
	{
		bool flag = arg.GetString(0, "").ToLower() == "salt";
		bool num = arg.GetString(0, "").ToLower() == "rads";
		BasePlayer basePlayer = arg.Player();
		ItemDefinition itemDefinition = (flag ? WaterTypes.SaltWaterItemDef : WaterTypes.WaterItemDef);
		itemDefinition = (num ? WaterTypes.RadioactiveWaterItemDef : itemDefinition);
		ItemModContainer itemModContainer = default(ItemModContainer);
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot != null && itemInSlot.GetHeldEntity() is BaseLiquidVessel { hasLid: not false } baseLiquidVessel)
			{
				int amount = 999;
				if (((Component)baseLiquidVessel.GetItem().info).TryGetComponent<ItemModContainer>(ref itemModContainer))
				{
					amount = itemModContainer.maxStackSize;
				}
				baseLiquidVessel.AddLiquid(itemDefinition, amount);
			}
		}
	}

	[ServerVar(ServerAdmin = true)]
	public static void reloadweapons(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		for (int i = 0; i < PlayerBelt.MaxBeltSlots; i++)
		{
			Item itemInSlot = basePlayer.Belt.GetItemInSlot(i);
			if (itemInSlot == null)
			{
				continue;
			}
			if (itemInSlot.GetHeldEntity() is BaseProjectile baseProjectile)
			{
				if (baseProjectile.primaryMagazine != null)
				{
					baseProjectile.SetAmmoCount(baseProjectile.primaryMagazine.capacity);
					baseProjectile.SendNetworkUpdateImmediate();
				}
			}
			else if (itemInSlot.GetHeldEntity() is FlameThrower flameThrower)
			{
				flameThrower.ammo = flameThrower.maxAmmo;
				flameThrower.SendNetworkUpdateImmediate();
			}
			else if (itemInSlot.GetHeldEntity() is LiquidWeapon liquidWeapon)
			{
				liquidWeapon.AddLiquid(WaterTypes.WaterItemDef, 999);
			}
		}
	}

	[ServerVar]
	public static void createskull(Arg arg)
	{
		string text = arg.GetString(0, "");
		BasePlayer basePlayer = arg.Player();
		if (string.IsNullOrEmpty(text))
		{
			text = RandomUsernames.Get(Random.Range(0, 1000));
		}
		Item item = ItemManager.Create(ItemManager.FindItemDefinition("skull.human"), 1, 0uL);
		item.name = HumanBodyResourceDispenser.CreateSkullName(text);
		item.streamerName = item.name;
		basePlayer.inventory.GiveItem(item);
	}

	[ServerVar]
	public static string createTrophy(Arg arg)
	{
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		Entity.EntitySpawnRequest spawnEntityFromName = Entity.GetSpawnEntityFromName(arg.GetString(0, ""));
		if (!spawnEntityFromName.Valid)
		{
			return spawnEntityFromName.Error;
		}
		BaseCombatEntity baseCombatEntity = default(BaseCombatEntity);
		if (GameManager.server.FindPrefab(spawnEntityFromName.PrefabName).TryGetComponent<BaseCombatEntity>(ref baseCombatEntity))
		{
			Item item = ItemManager.CreateByName("head.bag", 1, 0uL);
			HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item);
			if ((Object)(object)associatedEntity != (Object)null)
			{
				associatedEntity.SetupSourceId(baseCombatEntity.prefabID);
			}
			if (basePlayer.inventory.GiveItem(item))
			{
				basePlayer.Command("note.inv", item.info.itemid, 1);
			}
			else
			{
				item.DropAndTossUpwards(basePlayer.eyes.position);
			}
		}
		return "Created head";
	}

	[ServerVar]
	public static void trigger_wildlife_trap(Arg arg)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		if (GamePhysics.Trace(basePlayer.eyes.HeadRay(), 0.5f, out var hitInfo, 5f, 1218652417, (QueryTriggerInteraction)0, basePlayer))
		{
			WildlifeTrap wildlifeTrap = hitInfo.GetEntity() as WildlifeTrap;
			if (wildlifeTrap != null)
			{
				if (wildlifeTrap.isClient)
				{
					wildlifeTrap = BaseNetworkable.serverEntities.Find(wildlifeTrap.net.ID) as WildlifeTrap;
				}
				if (!wildlifeTrap.IsTrapActive())
				{
					arg.ReplyWith("Trap is not loaded or active");
					return;
				}
				wildlifeTrap.TrapThink();
				arg.ReplyWith("Trap think triggered");
				return;
			}
		}
		arg.ReplyWith("Not looking at a trap");
	}

	[ServerVar]
	public static void gesture_radius(Arg arg)
	{
		gesture_radius(arg, includeMe: true);
	}

	[ServerVar]
	public static void gesture_radius_notme(Arg arg)
	{
		gesture_radius(arg, includeMe: false);
	}

	public static void gesture_radius(Arg arg, bool includeMe)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		List<string> list = Pool.Get<List<string>>();
		for (int i = 0; i < 5; i++)
		{
			if (!string.IsNullOrEmpty(arg.GetString(i + 1, "")))
			{
				list.Add(arg.GetString(i + 1, ""));
			}
		}
		if (list.Count == 0)
		{
			arg.ReplyWith("No gestures provided. eg. player.gesture_radius 10f cabbagepatch raiseroof");
			return;
		}
		List<BasePlayer> list2 = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list2, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list2)
		{
			if (includeMe || (!((Object)(object)item == (Object)(object)basePlayer) && !item.isClient))
			{
				GestureConfig toPlay = GestureCollection.Instance.StringToGesture(list[Random.Range(0, list.Count)]);
				item.Server_StartGesture(toPlay, BasePlayer.GestureStartSource.Player, bypassOwnershipCheck: true);
			}
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list2);
	}

	[ServerVar]
	public static void stopgesture_radius(Arg arg)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		List<BasePlayer> list = Pool.Get<List<BasePlayer>>();
		Vis.Entities(((Component)basePlayer).transform.position, @float, list, 131072, (QueryTriggerInteraction)2);
		foreach (BasePlayer item in list)
		{
			item.Server_CancelGesture();
		}
		Pool.FreeUnmanaged<BasePlayer>(ref list);
	}

	[ServerVar]
	public static void markhostile(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer != (Object)null)
		{
			basePlayer.MarkHostileFor();
		}
	}
}


public class PlayerCull : ConsoleSystem
{
}


using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using Facepunch;
using Facepunch.Extend;
using Network;
using UnityEngine;

[Factory("pool")]
public class Pool : ConsoleSystem
{
	[ClientVar]
	[ServerVar]
	public static int mode = 2;

	[ClientVar]
	[ServerVar]
	public static bool prewarm = true;

	[ClientVar]
	[ServerVar]
	public static bool enabled = true;

	[ClientVar]
	[ServerVar]
	public static bool debug = false;

	[ClientVar]
	[ServerVar]
	public static void print_memory(Arg arg)
	{
		if (Pool.Directory.Count == 0)
		{
			arg.ReplyWith("Memory pool is empty.");
			return;
		}
		bool flag = arg.HasArg("--raw", true);
		bool flag2 = arg.HasArg("--json", true);
		string @string = arg.GetString(0, (string)null);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag2;
			val.AddColumn("type");
			val.AddColumn("capacity");
			val.AddColumn("pooled");
			val.AddColumn("active");
			val.AddColumn("max");
			val.AddColumn("hits");
			val.AddColumn("misses");
			val.AddColumn("spills");
			foreach (KeyValuePair<Type, IPoolCollection> item in Pool.Directory.OrderByDescending((KeyValuePair<Type, IPoolCollection> x) => x.Value.ItemsCreated))
			{
				Type key = item.Key;
				IPoolCollection value = item.Value;
				if (@string == null || key.ToString().Contains(@string))
				{
					val.AddRow(new string[8]
					{
						key.ToString().Replace("System.Collections.Generic.", ""),
						flag ? value.ItemsCapacity.ToString() : NumberExtensions.FormatNumberShort(value.ItemsCapacity),
						flag ? value.ItemsInStack.ToString() : NumberExtensions.FormatNumberShort(value.ItemsInStack),
						flag ? value.ItemsInUse.ToString() : NumberExtensions.FormatNumberShort(value.ItemsInUse),
						flag ? value.MaxItemsInUse.ToString() : NumberExtensions.FormatNumberShort(value.MaxItemsInUse),
						flag ? value.ItemsTaken.ToString() : NumberExtensions.FormatNumberShort(value.ItemsTaken),
						flag ? value.ItemsCreated.ToString() : NumberExtensions.FormatNumberShort(value.ItemsCreated),
						flag ? value.ItemsSpilled.ToString() : NumberExtensions.FormatNumberShort(value.ItemsSpilled)
					});
				}
			}
			arg.ReplyWith(flag2 ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void reset_max_pool_counter(Arg arg)
	{
		if (Pool.Directory.Count == 0)
		{
			arg.ReplyWith("Memory pool is empty.");
			return;
		}
		foreach (IPoolCollection value in Pool.Directory.Values)
		{
			value.ResetMaxUsageCounter();
		}
		arg.ReplyWith("Reset max item counter of pool");
	}

	[ServerVar]
	[ClientVar]
	public static void print_arraypool(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		string text = (flag ? "[" : string.Empty);
		string table2 = PrintArrayPool<byte>(BaseNetwork.ArrayPool, flag);
		text += FormatTable("BaseNetwork.ArrayPool", table2, flag);
		text += (flag ? "," : "\n");
		string table3 = PrintArrayPool<byte>(Shared.ArrayPool, flag);
		text += FormatTable("ProtocolParser.ArrayPool", table3, flag);
		if (flag)
		{
			text += "]";
		}
		arg.ReplyWith(text);
		static string FormatTable(string name, string table, bool toJson)
		{
			if (!toJson)
			{
				return name + "\n" + table;
			}
			return "{\"name\":\"" + name + "\",\"content\":" + table + "}";
		}
		unsafe static string PrintArrayPool<T>(ArrayPool<T> pool, bool toJson) where T : unmanaged
		{
			ConcurrentQueue<T[]>[] buffer = pool.GetBuffer();
			TextTable val = Pool.Get<TextTable>();
			try
			{
				val.ShouldPadColumns = !toJson;
				val.ResizeColumns(5);
				val.AddColumn("index");
				val.AddColumn("size");
				val.AddColumn("bytes");
				val.AddColumn("count");
				val.AddColumn("memory");
				val.ResizeRows(buffer.Length);
				int num = 1;
				num = sizeof(T);
				for (int i = 0; i < buffer.Length; i++)
				{
					int num2 = pool.IndexToSize(i);
					int num3 = num2 * num;
					int count = buffer[i].Count;
					int num4 = num3 * count;
					val.AddValue(i);
					val.AddValue(num2);
					val.AddValue(NumberExtensions.FormatBytes<int>(num2, false));
					val.AddValue(count);
					val.AddValue(NumberExtensions.FormatBytes<int>(num4, false));
				}
				return toJson ? val.ToJson(false) : ((object)val).ToString();
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	[ServerVar]
	[ClientVar]
	public static void print_prefabs(Arg arg)
	{
		PrefabPoolCollection pool = GameManager.server.pool;
		if (pool.storage.Count == 0)
		{
			arg.ReplyWith("Prefab pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("missed");
			val.AddColumn("count");
			val.AddColumn("target");
			val.AddColumn("added");
			val.AddColumn("removed");
			foreach (PrefabPool item in pool.storage.Values.OrderByDescending((PrefabPool x) => x.Missed))
			{
				string text = StringPool.Get(item.PrefabName).ToString();
				string prefabName = item.PrefabName;
				string text2 = item.Count.ToString();
				if (string.IsNullOrEmpty(@string) || StringEx.Contains(prefabName, @string, CompareOptions.IgnoreCase))
				{
					val.AddRow(new string[7]
					{
						text,
						Path.GetFileNameWithoutExtension(prefabName),
						text2,
						item.TargetCapacity.ToString(),
						item.Missed.ToString(),
						item.Pushed.ToString(),
						item.Popped.ToString()
					});
				}
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ClientVar]
	[ServerVar]
	public static void print_assets(Arg arg)
	{
		if (AssetPool.storage.Count == 0)
		{
			arg.ReplyWith("Asset pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("type");
			val.AddColumn("allocated");
			val.AddColumn("available");
			foreach (KeyValuePair<Type, Pool> item in AssetPool.storage)
			{
				string text = item.Key.ToString();
				string text2 = item.Value.allocated.ToString();
				string text3 = item.Value.available.ToString();
				if (string.IsNullOrEmpty(@string) || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
				{
					val.AddRow(new string[3] { text, text2, text3 });
				}
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	[ClientVar]
	public static void clear_memory(Arg arg)
	{
		Pool.Clear(arg.GetString(0, string.Empty));
	}

	[ServerVar]
	[ClientVar]
	public static void clear_prefabs(Arg arg)
	{
		string @string = arg.GetString(0, string.Empty);
		GameManager.server.pool.Clear(@string);
	}

	[ClientVar]
	[ServerVar]
	public static void clear_assets(Arg arg)
	{
		AssetPool.Clear(arg.GetString(0, string.Empty));
	}

	[ClientVar]
	[ServerVar]
	public static void export_prefabs(Arg arg)
	{
		PrefabPoolCollection pool = GameManager.server.pool;
		if (pool.storage.Count == 0)
		{
			arg.ReplyWith("Prefab pool is empty.");
			return;
		}
		string @string = arg.GetString(0, string.Empty);
		StringBuilder stringBuilder = new StringBuilder();
		foreach (KeyValuePair<uint, PrefabPool> item in pool.storage)
		{
			string arg2 = item.Key.ToString();
			string text = StringPool.Get(item.Key);
			string arg3 = item.Value.Count.ToString();
			if (string.IsNullOrEmpty(@string) || StringEx.Contains(text, @string, CompareOptions.IgnoreCase))
			{
				stringBuilder.AppendLine($"{arg2},{Path.GetFileNameWithoutExtension(text)},{arg3}");
			}
		}
		File.WriteAllText("prefabs.csv", stringBuilder.ToString());
	}

	[ClientVar]
	[ServerVar]
	public static void fill_prefabs(Arg arg)
	{
		string @string = arg.GetString(0, string.Empty);
		int @int = arg.GetInt(1, 0);
		PrefabPoolWarmup.Run(@string, @int);
	}
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using ConVar;
using Facepunch.Extend;
using UnityEngine;

[Factory("profile")]
public class Profile : ConsoleSystem
{
	private static Action delayedTakeSnapshot;

	private static bool exportDone = true;

	[ServerVar(Saved = true, Help = "Controls whether perfsnapshot commands emit chat messages")]
	public static bool Quiet = false;

	private const string PerfSnapshotHelp = "profile.perfsnapshot [delay=15, int] [name='Profile', str, no extension, max 32chars] [frames=10, int, max 10] [debug=false, dumps a binary snapshot as well]\nWill produce a JSON perf snapshot of <frames> that can be viewed in Perfetto or similar tools";

	private const string PerfSnapshot_StreamHelp = "profile.perfsnapshot_stream [name='Profile', str, no extension, max 32chars] [MainCap=32, int, max 256, buffer size for Main thread in Megabytes] [WorkerCap=8, int, max 256, buffer size for each Worker thread in Megabytes] [debug=false, dumps a binary snapshot as well]\nWill stream <mainCap>MB worth of data and generate a JSON snapshot that can be viewed in Perfetto or similar tools";

	private const string WatchAllocsHelp = "Params: [Name = 'Allocs'] [maxStackDepth = 16].\nStarts tracking of allocs, dumping a [Name].json.gz record once conditions are met";

	private static uint notifyOnTotalAllocCount = 16000u;

	private static uint notifyOnTotalMemKB = 12288u;

	private static uint notifyOnMainAllocCount = 0u;

	private static uint notifyOnMainMemKB = 0u;

	private static uint notifyOnWorkerAllocCount = 0u;

	private static uint notifyOnWorkerMemKB = 0u;

	[ServerVar]
	public static int NotifyOnTotalAllocCount
	{
		get
		{
			return (int)notifyOnTotalAllocCount;
		}
		set
		{
			if (notifyOnTotalAllocCount != value)
			{
				notifyOnTotalAllocCount = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalAllocCount, notifyOnTotalAllocCount);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnTotalMemKB
	{
		get
		{
			return (int)notifyOnTotalMemKB;
		}
		set
		{
			if (notifyOnTotalMemKB != value)
			{
				notifyOnTotalMemKB = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalMem, notifyOnTotalMemKB * 1024);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnMainAllocCount
	{
		get
		{
			return (int)notifyOnMainAllocCount;
		}
		set
		{
			if (notifyOnMainAllocCount != value)
			{
				notifyOnMainAllocCount = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainAllocCount, notifyOnMainAllocCount);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnMainMemKB
	{
		get
		{
			return (int)notifyOnMainMemKB;
		}
		set
		{
			if (notifyOnMainMemKB != value)
			{
				notifyOnMainMemKB = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainMem, notifyOnMainMemKB * 1024);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnWorkerAllocCount
	{
		get
		{
			return (int)notifyOnWorkerAllocCount;
		}
		set
		{
			if (notifyOnWorkerAllocCount != value)
			{
				notifyOnWorkerAllocCount = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerAllocCount, notifyOnWorkerAllocCount);
			}
		}
	}

	[ServerVar]
	public static int NotifyOnWorkerMemKB
	{
		get
		{
			return (int)notifyOnWorkerMemKB;
		}
		set
		{
			if (notifyOnWorkerMemKB != value)
			{
				notifyOnWorkerMemKB = (uint)value;
				ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerMem, notifyOnWorkerMemKB * 1024);
			}
		}
	}

	private static void NeedProfileFolder()
	{
		if (!Directory.Exists("profile"))
		{
			Directory.CreateDirectory("profile");
		}
	}

	[ServerVar]
	[ClientVar]
	public static void start(Arg arg)
	{
	}

	[ServerVar]
	[ClientVar]
	public static void stop(Arg arg)
	{
	}

	[ServerVar]
	[ClientVar]
	public static void flush_analytics(Arg arg)
	{
	}

	[ServerVar(Help = "profile.perfsnapshot [delay=15, int] [name='Profile', str, no extension, max 32chars] [frames=10, int, max 10] [debug=false, dumps a binary snapshot as well]\nWill produce a JSON perf snapshot of <frames> that can be viewed in Perfetto or similar tools")]
	public static void PerfSnapshot(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (!exportDone)
		{
			arg.ReplyWith("Already taking snapshot!");
			return;
		}
		int delay = arg.GetInt(0, 15);
		string name = StringExtensions.Truncate(arg.GetString(1, "Profile"), 32, (string)null);
		int frames = arg.GetInt(2, 4);
		bool generateBinary = arg.GetBool(3, false);
		if (delay == 0 || Quiet)
		{
			if (!Quiet)
			{
				Chat.Broadcast("Server taking a perf snapshot", "SERVER", "#eee", 0uL);
			}
			ServerProfiler.RecordNextFrames(frames, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
			{
				if (!Quiet)
				{
					Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
				}
				Task.Run(delegate
				{
					if (generateBinary)
					{
						ProfileExporter.Binary.Export(name, profiles);
					}
					ProfileExporter.JSON.Export(name, profiles, memState);
					ServerProfiler.ReleaseResources();
					exportDone = true;
				});
			});
			arg.ReplyWith("ServerProfiler is recording a perf snapshot");
			return;
		}
		Chat.Broadcast($"Server will be taking a perf snapshot, expect stutters in {delay} seconds", "SERVER", "#eee", 0uL);
		delayedTakeSnapshot = delegate
		{
			delay--;
			if (delay > 10 && delay % 5 == 0)
			{
				Chat.Broadcast($"Server will be taking a perf snapshot, expect stutters in {delay} seconds", "SERVER", "#eee", 0uL);
			}
			else if (delay > 0 && delay <= 10)
			{
				Chat.Broadcast($"{delay}...", "SERVER", "#eee", 0uL);
			}
			if (delay == 0)
			{
				ServerProfiler.RecordNextFrames(frames, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
				{
					Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
					Task.Run(delegate
					{
						if (generateBinary)
						{
							ProfileExporter.Binary.Export(name, profiles);
						}
						ProfileExporter.JSON.Export(name, profiles, memState);
						ServerProfiler.ReleaseResources();
						exportDone = true;
					});
				});
				InvokeHandler.CancelInvoke((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, delayedTakeSnapshot);
				delayedTakeSnapshot = null;
			}
		};
		InvokeHandler.InvokeRepeating((Behaviour)(object)SingletonComponent<InvokeHandler>.Instance, delayedTakeSnapshot, 0f, 1f);
		arg.ReplyWith("ServerProfiler will record a perf snapshot after a delay");
	}

	[ServerVar(Help = "profile.perfsnapshot_stream [name='Profile', str, no extension, max 32chars] [MainCap=32, int, max 256, buffer size for Main thread in Megabytes] [WorkerCap=8, int, max 256, buffer size for each Worker thread in Megabytes] [debug=false, dumps a binary snapshot as well]\nWill stream <mainCap>MB worth of data and generate a JSON snapshot that can be viewed in Perfetto or similar tools")]
	public static void PerfSnapshot_Stream(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (!exportDone)
		{
			arg.ReplyWith("Already taking snapshot!");
			return;
		}
		string name = StringExtensions.Truncate(arg.GetString(0, "Profile"), 32, (string)null);
		uint mainThreadCap = Math.Min(arg.GetUInt(1, 32u), 256u) * 1048576;
		uint workerThreadCap = Math.Min(arg.GetUInt(2, 8u), 256u) * 1048576;
		bool generateBinary = arg.GetBool(3, false);
		if (!Quiet)
		{
			Chat.Broadcast("Server taking a perf snapshot, there might be stutters", "SERVER", "#eee", 0uL);
		}
		ServerProfiler.RecordIntoBuffer(mainThreadCap, workerThreadCap, delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			if (!Quiet)
			{
				Chat.Broadcast("Snapshot taken", "SERVER", "#eee", 0uL);
			}
			Task.Run(delegate
			{
				if (generateBinary)
				{
					ProfileExporter.Binary.Export(name, profiles);
				}
				ProfileExporter.JSON.Export(name, profiles, memState);
				ServerProfiler.ReleaseResources();
				exportDone = true;
			});
		});
		arg.ReplyWith("ServerProfiler started recording a perf stream snapshot");
	}

	[ServerVar(Help = "Params: [Name = 'Allocs'] [maxStackDepth = 16].\nStarts tracking of allocs, dumping a [Name].json.gz record once conditions are met")]
	public static void WatchAllocs(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		if (ServerProfiler.IsRunning)
		{
			arg.ReplyWith("ServerProfiler is busy with a previous task");
			return;
		}
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalAllocCount, notifyOnTotalAllocCount);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.TotalMem, notifyOnTotalMemKB * 1024);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainAllocCount, notifyOnMainAllocCount);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.MainMem, notifyOnMainMemKB * 1024);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerAllocCount, notifyOnWorkerAllocCount);
		ServerProfiler.Native.SetContinuousProfilerNotifySettings(ServerProfiler.NotifyMetric.WorkerMem, notifyOnWorkerMemKB * 1024);
		string name = arg.GetString(0, "Allocs");
		ServerProfiler.StartContinuousRecording((byte)arg.GetInt(1, 16), delegate(IList<ServerProfiler.Profile> profiles, ServerProfiler.MemoryState memState)
		{
			Task.Run(delegate
			{
				if (ProfileExporter.JSON.Export(name, profiles, memState))
				{
					ServerProfiler.ResumeContinuousRecording();
				}
				else
				{
					Debug.Log((object)"Stopping watching allocations due to export error");
					ServerProfiler.StopContinuousRecording();
				}
			});
		});
		arg.ReplyWith("ServerProfiler started tracking allocations");
	}

	[ServerVar(Help = "Stops tracking of allocations")]
	public static void StopWatchingAllocs(Arg arg)
	{
		if (!ServerProfiler.IsEnabled())
		{
			arg.ReplyWith("ServerProfiler is disabled");
			return;
		}
		ServerProfiler.StopContinuousRecording();
		arg.ReplyWith("ServerProfiler stopped tracking allocations");
	}
}


[Factory("reflection")]
public class Reflection : ConsoleSystem
{
}


using System.Collections.Generic;
using System.Linq;
using System.Text;
using ProtoBuf;

[Factory("render")]
public class Render : ConsoleSystem
{
	public static bool use_normal_rendering = false;

	[ClientVar(Saved = true, Help = "0 = off, 1 = on (must restart client for changes to take effect)")]
	public static int instanced_rendering = 0;

	[ClientVar(ClientAdmin = true, Help = "Developer command to toggle instanced rendering at runtime to measure performance impact")]
	public static bool instanced_toggle_all = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of cliffs on / off")]
	public static bool instanced_toggle_cliffs = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of buildings on / off")]
	public static bool instanced_toggle_buildings = true;

	[ClientVar(ClientAdmin = true, Help = "Toggle rendering of uncategorized meshes on / off")]
	public static bool instanced_toggle_other = true;

	[ClientVar(ClientAdmin = true, Help = "Allow unity to batch together multiple draw calls")]
	public static bool multidraw = true;

	[ClientVar(ClientAdmin = true, Help = "0 = CPU, 1 = GPU")]
	public static int upload_multidraw_meshes_mode = 0;

	[ClientVar(ClientAdmin = true)]
	public static bool render_shadows = true;

	[ClientVar(Help = "Whether to call ComputeBuffer.SetData immediately or at the end of the frame")]
	public static bool computebuffer_setdata_immediate = true;

	[ClientVar(ClientAdmin = true, Help = "Set the amount of instanced renderers to show for debugging")]
	public static int max_renderers = 0;

	[ClientVar(Saved = true, Help = "Max distance for instanced rendering, can be higher than normal render distance")]
	public static float instancing_render_distance = 1000f;

	public static bool IsInstancingDisabled => true;

	public static bool IsInstancingEnabled => !IsInstancingDisabled;

	[ClientVar(Name = "show_building_blocked", Saved = true)]
	public static bool show_building_blocked_client { get; set; } = true;

	[ClientVar(Name = "building_blocked_preview_distance", Help = "Distance from the border of building blocked to show the red preview")]
	public static float building_blocked_preview_distance { get; set; } = 100f;

	[ReplicatedVar]
	public static bool show_building_blocked_server { get; set; } = true;

	public static bool IsMultidrawEnabled => multidraw;

	[ServerVar]
	[ClientVar(Name = "print_tree_counts", ClientAdmin = true, Help = "Print off count of trees to ensure server sent them all")]
	public static void tree_entities(Arg arg)
	{
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Server Trees: {TreeManager.server.GetTreeCount()}");
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ClientVar(Name = "print_global_entities", ClientAdmin = true, Help = "Print off count of global building entities on the client")]
	[ServerVar(Name = "print_global_entities", Help = "Print off count of global building entities on the server")]
	public static void print_global_entities(Arg arg)
	{
		if (IsInstancingDisabled)
		{
			return;
		}
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("SERVER ENTITIES:");
		Dictionary<uint, int> dictionary = new Dictionary<uint, int>();
		foreach (GlobalEntityData value2 in GlobalNetworkHandler.server.serverData.Values)
		{
			dictionary.TryGetValue(value2.prefabId, out var value);
			dictionary[value2.prefabId] = value + 1;
		}
		KeyValuePair<uint, int>[] array = dictionary.OrderByDescending((KeyValuePair<uint, int> x) => x.Value).ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			KeyValuePair<uint, int> keyValuePair = array[i];
			stringBuilder.AppendLine($"{StringPool.Get(keyValuePair.Key)} - {keyValuePair.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	private static void global_entities_client(StringBuilder builder)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_debug", Help = "Print off array size and memory usage to ensure no memory leaks & debug rendering system")]
	public static void instanced_memory_usage(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(ClientAdmin = true, Help = "Spawn (default 50k) prefabs spread across the map to quickly test instanced rendering system in isolation")]
	public static void test_instancing_culling(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_renderers", ClientAdmin = true, Help = "Print off number of each mesh inside instanced rendering system (including outside of render range)")]
	public static void instanced_renderers_debug(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "print_instanced_cell", ClientAdmin = true, Help = "Print number of meshes inside a single grid")]
	public static void print_instanced_grid(Arg arg)
	{
		_ = IsInstancingDisabled;
	}

	[ClientVar(Name = "expand_instancing", ClientAdmin = true)]
	public static void expand_instancing(Arg arg)
	{
		_ = IsInstancingDisabled;
	}
}


using Facepunch;
using UnityEngine;

[Factory("reports")]
public class reports : ConsoleSystem
{
	[ServerVar(Default = "600")]
	[ClientVar(Default = "600")]
	public static int ExceptionReportMaxLength
	{
		get
		{
			return ExceptionReporter.ReportMessageMaxLength;
		}
		set
		{
			ExceptionReporter.ReportMessageMaxLength = Mathf.Max(value, 250);
		}
	}
}


[Factory("sentry")]
public class Sentry : ConsoleSystem
{
	[ServerVar(Help = "target everyone regardless of authorization")]
	public static bool targetall = false;

	[ServerVar(Help = "how long until something is considered hostile after it attacked")]
	public static float hostileduration = 120f;

	[ReplicatedVar(Help = "radius to check for other turrets")]
	public static float interferenceradius = 40f;

	[ReplicatedVar(Help = "max interference from other turrets")]
	public static int maxinterference = 12;

	[ServerVar(Help = "Prevents auto turrets getting added more than once to the IO queue")]
	public static bool debugPreventDuplicates = true;

	[ServerVar(Help = "How quickly can a turret acquire a potential target. Less is faster, but perf taxing")]
	public static float scantimer = 1f;
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using Development.Attributes;
using Epic.OnlineServices.Logging;
using Epic.OnlineServices.Reports;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Rust;
using Network;
using Rust;
using UnityEngine;

[Factory("server")]
[ResetStaticFields]
public class Server : ConsoleSystem
{
	[ServerVar]
	public static string ip = "";

	[ServerVar]
	public static int port = 28015;

	[ServerVar]
	public static int queryport = 0;

	[ServerVar(ShowInAdminUI = true)]
	public static int maxplayers = 500;

	[ServerVar(ShowInAdminUI = true)]
	public static string hostname = "My Untitled Rust Server";

	[ServerVar]
	public static string identity = "my_server_identity";

	[ServerVar]
	public static string filefolderoverride = "";

	[ServerVar]
	public static string level = "Procedural Map";

	[ServerVar]
	public static string levelurl = "";

	[ServerVar]
	public static bool leveltransfer = true;

	[ServerVar]
	public static int seed = 1337;

	[ServerVar]
	public static int salt = 1;

	[ServerVar]
	public static int worldsize = 4500;

	[ServerVar]
	public static int saveinterval = 600;

	[ServerVar]
	public static int encryption = 2;

	[ServerVar]
	public static string anticheatid = "xyza7891h6UjNfd0eb2HQGtaul0WhfvS";

	[ServerVar]
	public static string anticheatkey = "OWUDFZmi9VNL/7VhGVSSmCWALKTltKw8ISepa0VXs60";

	[ServerVar]
	public static bool anticheattoken = true;

	[ServerVar]
	public static bool strictauth_eac = false;

	[ServerVar]
	public static bool strictauth_steam = false;

	[ServerVar]
	public static int tickrate = 10;

	[ServerVar]
	public static int entityrate = 16;

	[ServerVar]
	public static float schematime = 1800f;

	[ServerVar]
	public static float cycletime = 500f;

	[ServerVar]
	public static bool official = false;

	[ServerVar]
	public static bool stats = false;

	[ServerVar]
	public static bool stability = true;

	[ServerVar(ShowInAdminUI = true)]
	public static bool radiation = true;

	[ReplicatedVar]
	public static float max_explosive_protection = 0.75f;

	[ServerVar]
	public static float itemdespawn = 300f;

	[ServerVar]
	public static float itemdespawn_container_scale = 2f;

	[ServerVar]
	public static int itemdespawn_container_max_multiplier = 24;

	[ServerVar]
	public static float itemdespawn_quick = 30f;

	[ServerVar]
	public static float corpsedespawn = 300f;

	[ServerVar]
	public static float debrisdespawn = 30f;

	[ServerVar]
	public static bool pve = false;

	[ReplicatedVar]
	public static bool cinematic = false;

	[ServerVar(ShowInAdminUI = true)]
	public static string description = "No server description has been provided.";

	[ServerVar(ShowInAdminUI = true)]
	public static string url = "";

	[ServerVar]
	public static string branch = "";

	[ServerVar]
	public static int queriesPerSecond = 2000;

	[ServerVar]
	public static int ipQueriesPerMin = 30;

	[ServerVar]
	public static bool statBackup = false;

	[ServerVar]
	public static int rejoin_delay = 300;

	[ServerVar]
	public static string ping_region_code_override = "";

	private static string _favoritesEndpoint = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static string headerimage = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static string logoimage = "";

	[ServerVar(Saved = true, ShowInAdminUI = true)]
	public static int saveBackupCount = 2;

	[ReplicatedVar(Saved = true, ShowInAdminUI = true)]
	public static string motd = "";

	[ServerVar(Saved = true)]
	public static float meleedamage = 1f;

	[ServerVar(Saved = true)]
	public static float arrowdamage = 1f;

	[ServerVar(Saved = true)]
	public static float bulletdamage = 1f;

	[ServerVar(Saved = true)]
	public static float bleedingdamage = 1f;

	[ServerVar(Help = "Lower damage of explosives to 1 and allow them to be triggered multiple times")]
	public static bool explosive_testing_mode = false;

	[ServerVar(Saved = true)]
	public static float oilrig_radiation_amount_scale = 1f;

	[ServerVar(Saved = true)]
	public static float oilrig_radiation_time_scale = 1f;

	[ServerVar]
	public static float oilrig_radiation_alarm_threshold = 0f;

	[ReplicatedVar(Saved = true)]
	public static float funWaterDamageThreshold = 0.8f;

	[ReplicatedVar(Saved = true)]
	public static float funWaterWetnessGain = 0.05f;

	[ServerVar(Saved = true)]
	public static float meleearmor = 1f;

	[ServerVar(Saved = true)]
	public static float arrowarmor = 1f;

	[ServerVar(Saved = true)]
	public static float bulletarmor = 1f;

	[ServerVar(Saved = true)]
	public static float bleedingarmor = 1f;

	[ServerVar(Saved = true)]
	public static float pvpBulletDamageMultiplier = 1f;

	[ServerVar(Saved = true)]
	public static float pveBulletDamageMultiplier = 1f;

	[ServerVar]
	public static int updatebatch = 512;

	[ServerVar]
	public static int updatebatchspawn = 1024;

	[ServerVar]
	public static int entitybatchsize = 100;

	[ServerVar]
	public static float entitybatchtime = 1f;

	[ServerVar]
	public static float composterUpdateInterval = 300f;

	[ReplicatedVar]
	public static float planttick = 60f;

	[ServerVar]
	public static float planttickscale = 1f;

	private static int _maxHttp = 32;

	[ServerVar]
	public static bool useMinimumPlantCondition = true;

	[ServerVar(Saved = true)]
	public static float nonPlanterDeathChancePerTick = 0.005f;

	[ServerVar(Saved = true)]
	public static float ceilingLightGrowableRange = 3f;

	[ReplicatedVar(Saved = true)]
	public static float artificialTemperatureGrowableRange = 4f;

	[ServerVar(Saved = true)]
	public static float ceilingLightHeightOffset = 3f;

	[ReplicatedVar(Saved = true)]
	public static float sprinklerRadius = 3f;

	[ServerVar(Saved = true)]
	public static float sprinklerEyeHeightOffset = 3f;

	[ServerVar(Saved = true)]
	public static bool useLegacySprinklerLoadProcess = false;

	[ServerVar(Saved = true)]
	public static float optimalPlanterQualitySaturation = 0.6f;

	[ServerVar]
	public static float metabolismtick = 1f;

	[ServerVar]
	public static float modifierTickRate = 1f;

	[ServerVar(Saved = true)]
	public static float rewounddelay = 60f;

	[ServerVar(Saved = true, Help = "Can players be wounded after receiving fatal damage")]
	public static bool woundingenabled = true;

	[ServerVar(Saved = true, Help = "Do players go into the crawling wounded state")]
	public static bool crawlingenabled = true;

	[ServerVar(Help = "Base chance of recovery after crawling wounded state", Saved = true)]
	public static float woundedrecoverchance = 0.2f;

	[ServerVar(Help = "Base chance of recovery after incapacitated wounded state", Saved = true)]
	public static float incapacitatedrecoverchance = 0.1f;

	[ServerVar(Help = "Maximum percent chance added to base wounded/incapacitated recovery chance, based on the player's food and water level", Saved = true)]
	public static float woundedmaxfoodandwaterbonus = 0.25f;

	[ServerVar(Help = "Minimum initial health given when a player dies and moves to crawling wounded state", Saved = false)]
	public static int crawlingminimumhealth = 7;

	[ServerVar(Help = "Maximum initial health given when a player dies and moves to crawling wounded state", Saved = false)]
	public static int crawlingmaximumhealth = 12;

	[ServerVar(Saved = true)]
	public static bool playerserverfall = true;

	[ServerVar]
	public static bool plantlightdetection = true;

	[ServerVar]
	public static float respawnresetrange = 50f;

	[ReplicatedVar]
	public static int max_sleeping_bags = 15;

	[ReplicatedVar]
	public static bool bag_quota_item_amount = true;

	[ServerVar]
	public static int maxunack = 4;

	[ServerVar]
	public static bool netcache = true;

	[ServerVar]
	public static bool corpses = true;

	[ServerVar]
	public static bool events = true;

	[ServerVar]
	public static bool dropitems = true;

	[ServerVar]
	public static int netcachesize = 0;

	[ServerVar]
	public static int savecachesize = 0;

	[ServerVar]
	public static int combatlogsize = 30;

	[ServerVar]
	public static int combatlogdelay = 10;

	[ServerVar]
	public static int authtimeout = 60;

	[ServerVar]
	public static int playertimeout = 60;

	[ServerVar(ShowInAdminUI = true)]
	public static int idlekick = 30;

	[ServerVar]
	public static int idlekickmode = 1;

	[ServerVar]
	public static int idlekickadmins = 0;

	[ServerVar]
	public static bool long_distance_sounds = true;

	private static string _gamemode;

	private static string _tags = "";

	[ServerVar(Help = "Censors the Steam player list to make player tracking more difficult")]
	public static bool censorplayerlist = true;

	[ServerVar(Help = "HTTP API endpoint for centralized banning (see wiki)")]
	public static string bansServerEndpoint = "";

	[ServerVar(Help = "Failure mode for centralized banning, set to 1 to reject players from joining if it's down (see wiki)")]
	public static int bansServerFailureMode = 0;

	[ServerVar(Help = "Timeout (in seconds) for centralized banning web server requests")]
	public static int bansServerTimeout = 5;

	[ServerVar(Help = "HTTP API endpoint for receiving F7 reports", Saved = true)]
	public static string reportsServerEndpoint = "";

	[ServerVar(Help = "If set, this key will be included with any reports sent via reportsServerEndpoint (for validation)", Saved = true)]
	public static string reportsServerEndpointKey = "";

	[ServerVar(Help = "Should F7 reports from players be printed to console", Saved = true)]
	public static bool printReportsToConsole = false;

	[ServerVar(Help = "If a player presses the respawn button, respawn at their death location (for trailer filming)")]
	public static bool respawnAtDeathPosition = false;

	[ServerVar(Help = "When a player respawns give them the loadout assigned to client.RespawnLoadout (created with inventory.saveloadout)")]
	public static bool respawnWithLoadout = false;

	[ServerVar(Help = "When transferring water, should containers keep 1 water behind. Enabling this should help performance if water IO is causing performance loss", Saved = true)]
	public static bool waterContainersLeaveWaterBehind = false;

	[ServerVar(Help = "How often industrial conveyors attempt to move items (value is an interval measured in seconds). Setting to 0 will disable all movement", Saved = true, ShowInAdminUI = true)]
	public static float conveyorMoveFrequency = 5f;

	[ServerVar(Help = "How often industrial crafters attempt to craft items (value is an interval measured in seconds). Setting to 0 will disable all crafting", Saved = true, ShowInAdminUI = true)]
	public static float industrialCrafterFrequency = 5f;

	[ReplicatedVar(Help = "How much scrap is required to research default blueprints", Saved = true, ShowInAdminUI = true)]
	public static int defaultBlueprintResearchCost = 10;

	[ServerVar(Help = "Whether to check for illegal industrial pipes when changing building block states (roof bunkers)", Saved = true, ShowInAdminUI = true)]
	public static bool enforcePipeChecksOnBuildingBlockChanges = true;

	[ServerVar(Help = "How many stacks a single conveyor can move in a single tick", Saved = true, ShowInAdminUI = true)]
	public static int maxItemStacksMovedPerTickIndustrial = 12;

	[ServerVar(Help = "How long per frame to spend on industrial jobs", Saved = true, ShowInAdminUI = true)]
	public static float industrialFrameBudgetMs = 0.5f;

	[ServerVar(Help = "Should indusrial be paused during autosaves")]
	public static bool pauseindustrialduringsave = true;

	[ServerVar(Help = "When enabled industrial transfers will abort if they start to take too long. Will lead to inconsistent splitting but should retain performance", Saved = true)]
	public static bool industrialTransferStrictTimeLimits = true;

	[ServerVar(Help = "Enables a faster way to move items around during conveyor transfers. Should be on unless there's a issue")]
	public static bool industrialAllowQuickMove = true;

	[ServerVar(Help = "How long per frame to spend animating items moving into the hopper (will be instant if <= 0)", Saved = true, ShowInAdminUI = true)]
	public static float hopperAnimationBudgetMs = 0.1f;

	[ReplicatedVar(Help = "How many markers each player can place", Saved = true, ShowInAdminUI = true)]
	public static int maximumMapMarkers = 5;

	[ServerVar(Help = "How many pings can be placed by each player", Saved = true, ShowInAdminUI = true)]
	public static int maximumPings = 5;

	[ServerVar(Help = "How long a ping should last", Saved = true, ShowInAdminUI = true)]
	public static float pingDuration = 10f;

	[ServerVar(Help = "Allows backpack equipping while not grounded", Saved = true, ShowInAdminUI = true)]
	public static bool canEquipBackpacksInAir = false;

	[ReplicatedVar(Help = "How long it takes to pick up a used parachute in seconds", Saved = true, ShowInAdminUI = true)]
	public static float parachuteRepackTime = 8f;

	[ServerVar(Help = "Whether emoji ownership is checked server side. Could be performance draining in high chat volumes")]
	public static bool emojiOwnershipCheck = true;

	[ReplicatedVar(Help = "Skip death screen fade", Saved = false, ShowInAdminUI = false)]
	public static bool skipDeathScreenFade = false;

	[ReplicatedVar(Help = "Controls whether the tutorial is enabled on this server", Saved = true, ShowInAdminUI = true, Default = "false")]
	public static bool tutorialEnabled = false;

	[ReplicatedVar(Help = "How much of a tax to apply to workbench T1 tech unlocks. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbench1TaxRate = 0f;

	[ServerVar(Help = "Automatically upload procedurally generated maps so that players download them (faster) instead of re-generating them", Saved = true, ShowInAdminUI = true)]
	public static bool autoUploadMap = true;

	[ServerVar(Help = "Automatically upload an image of the map, used to show the map in the server browser", Saved = true, ShowInAdminUI = true)]
	public static bool autoUploadMapImages = true;

	[ReplicatedVar(Help = "How much of a tax to apply to workbench T2 tech unlocks. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbench2TaxRate = 10f;

	[ReplicatedVar(Help = "How much of a tax to apply to workbench  T3tech unlocks. 10 = additional 10% scrap cost", Saved = true)]
	public static float workbench3TaxRate = 20f;

	[ServerVar(Help = "How often (in hours) the water well NPC's update their sell orders")]
	public static float waterWellNpcSalesRefreshFrequency = 1f;

	[ReplicatedVar(Help = "Opens a loot panel when interacting with a workbench instead of going straight into the tech tree. Designed for backwards compatibility with mods.")]
	public static bool useLegacyWorkbenchInteraction = false;

	[ServerVar(Help = "If no players are in this range kayaks, boogie boards and inner tubes will switch to a cheaper buoyancy system")]
	public static float lowPriorityBuoyancyRange = 30f;

	[ServerVar(Help = "If true hot air balloons can be shot down with homing missiles")]
	public static bool homingMissileTargetsHab = false;

	[ServerVar(Help = "Require a premium status account to connect to this server")]
	public static bool premium = false;

	[ReplicatedVar(Help = "Whether to run the food spoiling system")]
	public static bool foodSpoiling = true;

	[ServerVar]
	public static float foodSpoilingBudgetMs = 0.05f;

	[ServerVar(Help = "Maximum difference (in seconds) that two items with spoil timers can have and still be stackable")]
	public static float maxFoodSpoilTimeDiffForItemStack = 180f;

	[ServerVar(Help = "If two spoiled food items are both above this threshold then we will allow them to be stacked")]
	public static float normalisedFoodSpoilTimeStackThreshold = 0.9f;

	[ServerVar(Help = "Whether to run local avoidance for chickens, disabling might get a slight performance improvement but chickens will clip", Saved = true, ShowInAdminUI = true)]
	public static bool farmChickenLocalAvoidance = true;

	[ServerVar(Help = "Endpoint to use to check if players have premium status")]
	public static string premiumVerifyEndpoint = "https://rust-api.facepunch.com/api/premium/verify";

	[ServerVar(Help = "Minimum time to recheck premium status for already connected players (in seconds)")]
	public static float premiumRecheckMinSeconds = 300f;

	[ServerVar(Help = "How often to do premium status rechecks")]
	public static float premiumRecheckInterval = 300f;

	[ServerVar(Help = "Maximum number of players to recheck at a time")]
	public static int premiumRecheckMaxBatchSize = 100;

	[ServerVar(Saved = true)]
	public static bool spawnVineTrees = true;

	[ServerVar(Saved = true)]
	public static bool allowVineSwinging = true;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Bags will increase their respawn time by this much")]
	public static float respawnTimeAdditionBag = 0f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "Beds will increase their respawn time by this much")]
	public static float respawnTimeAdditionBed = 0f;

	[ServerVar(Saved = true, ShowInAdminUI = true, Help = "All ammo drops from NPC loot will be multiplied by this")]
	public static float npcAmmoLootMultiplier = 1f;

	[ReplicatedVar(Help = "Multiplies crafting cost of firearm ammunition", Saved = true, ShowInAdminUI = true)]
	public static float hardcoreFirearmAmmunitionCraftingMultiplier = 1f;

	[ServerVar(Saved = true)]
	public static bool showHolsteredItems = true;

	[ServerVar]
	public static int maxpacketspersecond_world = 1;

	[ServerVar]
	public static int maxpacketspersecond_rpc = 200;

	[ServerVar]
	public static int maxpacketspersecond_rpc_signal = 30;

	[ServerVar]
	public static int maxpacketspersecond_command = 100;

	[ServerVar]
	public static int maxpacketsize_command = 100000;

	[ServerVar]
	public static int maxpacketsize_globaltrees = 100;

	[ServerVar]
	public static int maxpacketsize_globalentities = 1000;

	[ServerVar]
	public static int maxpacketspersecond_tick = 300;

	[ServerVar]
	public static int maxpacketspersecond_voice = 100;

	[ServerVar]
	public static int maxpacketspersecond_syncvar = 200;

	[ServerVar]
	public static bool packetlog_enabled = false;

	[ServerVar]
	public static bool rpclog_enabled = false;

	[ServerVar(Help = "MS per frame to spend warming up entity save caches")]
	public static int saveframebudget = 5;

	[ServerVar(Help = "Player Update parallelism mode. 0 - serial(def); 1 - burst jobs; 2 - 1 + managed tasks")]
	public static int UsePlayerUpdateJobs = 0;

	[ServerVar(Help = "UsePlayerUpdateJobs 2 related - how many snapshot messages to batch into 1 task")]
	public static int SnapshotTaskBatchCount = 64;

	[ServerVar(Help = "UsePlayerUpdateJobs 2 related - how many destroy messages to batch into 1 task")]
	public static int DestroyTaskBatchCount = 128;

	[ServerVar(Help = "Runs extra validation checks to prevent crashes and instead switch back to vanilla processing")]
	public static bool EmergencyDisablePlayerJobs = true;

	[ServerVar(Saved = true)]
	public static string server_id
	{
		get
		{
			return DemoConVars.ServerId;
		}
		set
		{
			DemoConVars.ServerId = value;
		}
	}

	[ServerVar(ShowInAdminUI = true, Saved = true, Help = "Domain name to save when players favorite your server. The port can be omitted if using the default port or a SRV DNS record is created.")]
	public static string favoritesEndpoint
	{
		get
		{
			return _favoritesEndpoint;
		}
		set
		{
			if (string.IsNullOrWhiteSpace(value))
			{
				_favoritesEndpoint = "";
				return;
			}
			value = value.Trim();
			if (value.StartsWith("https://"))
			{
				string text = value;
				int length = "https://".Length;
				value = text.Substring(length, text.Length - length);
			}
			if (value.StartsWith("http://"))
			{
				string text = value;
				int length = "http://".Length;
				value = text.Substring(length, text.Length - length);
			}
			_favoritesEndpoint = value.Trim().ToLowerInvariant();
		}
	}

	[ServerVar]
	public static int anticheatlog
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected I4, but got Unknown
			return (int)EOS.LogLevel;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			EOS.LogLevel = (LogLevel)value;
		}
	}

	[ServerVar]
	public static int http_connection_limit
	{
		get
		{
			return _maxHttp;
		}
		set
		{
			_maxHttp = value;
			HttpManager.UpdateMaxConnections();
		}
	}

	[ServerVar]
	public static string gamemode
	{
		get
		{
			return _gamemode;
		}
		set
		{
			_gamemode = value;
			ApplyGamemode();
		}
	}

	[ServerVar(Help = "Comma-separated server browser tag values (see wiki)", Saved = true, ShowInAdminUI = true)]
	public static string tags
	{
		get
		{
			return _tags;
		}
		set
		{
			_tags = AutoCorrectTags(value);
		}
	}

	[ServerVar]
	public static int maxclientinfosize
	{
		get
		{
			return Connection.MaxClientInfoSize;
		}
		set
		{
			Connection.MaxClientInfoSize = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxconnectionsperip
	{
		get
		{
			return Server.MaxConnectionsPerIP;
		}
		set
		{
			Server.MaxConnectionsPerIP = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreceivetime
	{
		get
		{
			return Server.MaxReceiveTime;
		}
		set
		{
			Server.MaxReceiveTime = Mathf.Clamp(value, 10, 1000);
		}
	}

	[ServerVar]
	public static int maxmainthreadwait
	{
		get
		{
			return Server.MaxMainThreadWait;
		}
		set
		{
			Server.MaxMainThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreadthreadwait
	{
		get
		{
			return Server.MaxReadThreadWait;
		}
		set
		{
			Server.MaxReadThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxwritethreadwait
	{
		get
		{
			return Server.MaxWriteThreadWait;
		}
		set
		{
			Server.MaxWriteThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxdecryptthreadwait
	{
		get
		{
			return Server.MaxDecryptThreadWait;
		}
		set
		{
			Server.MaxDecryptThreadWait = Mathf.Clamp(value, 1, 1000);
		}
	}

	[ServerVar]
	public static int maxreadqueuelength
	{
		get
		{
			return Server.MaxReadQueueLength;
		}
		set
		{
			Server.MaxReadQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxwritequeuelength
	{
		get
		{
			return Server.MaxWriteQueueLength;
		}
		set
		{
			Server.MaxWriteQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxdecryptqueuelength
	{
		get
		{
			return Server.MaxDecryptQueueLength;
		}
		set
		{
			Server.MaxDecryptQueueLength = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxreadqueuebytes
	{
		get
		{
			return Server.MaxReadQueueBytes;
		}
		set
		{
			Server.MaxReadQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxwritequeuebytes
	{
		get
		{
			return Server.MaxWriteQueueBytes;
		}
		set
		{
			Server.MaxWriteQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int maxdecryptqueuebytes
	{
		get
		{
			return Server.MaxDecryptQueueBytes;
		}
		set
		{
			Server.MaxDecryptQueueBytes = Mathf.Max(value, 1);
		}
	}

	[ServerVar]
	public static int player_state_cache_size
	{
		get
		{
			return SingletonComponent<ServerMgr>.Instance?.playerStateManager.CacheSize ?? 0;
		}
		set
		{
			SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheSize = value;
		}
	}

	[ServerVar]
	public static int maxpacketspersecond
	{
		get
		{
			return (int)Server.MaxPacketsPerSecond;
		}
		set
		{
			Server.MaxPacketsPerSecond = (ulong)Mathf.Clamp(value, 1, 1000000);
		}
	}

	public static string rootFolder => "server/" + identity;

	public static string filesStorageFolder
	{
		get
		{
			if (!string.IsNullOrEmpty(filefolderoverride))
			{
				return filefolderoverride;
			}
			return rootFolder;
		}
	}

	public static string backupFolder => "backup/0/" + identity;

	public static string backupFolder1 => "backup/1/" + identity;

	public static string backupFolder2 => "backup/2/" + identity;

	public static string backupFolder3 => "backup/3/" + identity;

	[ServerVar]
	public static bool compression
	{
		get
		{
			if (Net.sv == null)
			{
				return false;
			}
			return Net.sv.compressionEnabled;
		}
		set
		{
			Net.sv.compressionEnabled = value;
		}
	}

	[ServerVar]
	public static bool netlog
	{
		get
		{
			if (Net.sv == null)
			{
				return false;
			}
			return Net.sv.logging;
		}
		set
		{
			Net.sv.logging = value;
		}
	}

	public static bool UsePlayerTasks => UsePlayerUpdateJobs >= 2;

	[ReplicatedVar(Name = "era", Help = "none,primitive,medieval,frontier,rust")]
	public static string era
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0005: Unknown result type (might be due to invalid IL or missing references)
			Era val = Era;
			return ((object)(Era)(ref val)/*cast due to .constrained prefix*/).ToString();
		}
		set
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0149: Unknown result type (might be due to invalid IL or missing references)
			//IL_014a: Unknown result type (might be due to invalid IL or missing references)
			if (string.IsNullOrEmpty(value) && (int)Era != 0)
			{
				Era = (Era)0;
				OnEraChanged();
				return;
			}
			Era val = Era;
			switch (value.ToLower())
			{
			case "unknown":
			case "none":
				Era = (Era)0;
				break;
			case "primitive":
				Era = (Era)10;
				break;
			case "siege":
			case "medieval":
				Era = (Era)20;
				break;
			case "frontier":
				Era = (Era)30;
				break;
			case "modern":
			case "rust":
				Era = (Era)1000;
				break;
			}
			if (val != Era)
			{
				OnEraChanged();
			}
		}
	}

	public static Era Era { get; private set; }

	private static void ApplyGamemode()
	{
		GameModeManifest gameModeManifest = GameModeManifest.Get();
		if ((Object)(object)gameModeManifest == (Object)null)
		{
			Debug.LogError((object)"No GameModeManifest found");
			return;
		}
		foreach (GameObjectRef gameModePrefab in gameModeManifest.gameModePrefabs)
		{
			object obj;
			if (gameModePrefab == null)
			{
				obj = null;
			}
			else
			{
				GameObject obj2 = gameModePrefab.Get();
				obj = ((obj2 != null) ? obj2.GetComponent<BaseGameMode>() : null);
			}
			BaseGameMode baseGameMode = (BaseGameMode)obj;
			if (baseGameMode.shortname == gamemode)
			{
				baseGameMode.ApplyConVars();
				return;
			}
		}
		Debug.LogWarning((object)("Couldn't find gamemode: " + gamemode));
	}

	public static float GetTaxRateForWorkbenchUnlock(int workbenchLevel)
	{
		float num = 0f;
		switch (workbenchLevel)
		{
		case 0:
			num = workbench1TaxRate;
			break;
		case 1:
			num = workbench2TaxRate;
			break;
		case 2:
			num = workbench3TaxRate;
			break;
		}
		return Mathf.Clamp(num, 0f, 100f);
	}

	public static float TickDelta()
	{
		return 1f / (float)tickrate;
	}

	public static float TickTime(uint tick)
	{
		return (float)((double)TickDelta() * (double)tick);
	}

	[ServerVar(Help = "Show holstered items on player bodies")]
	public static void setshowholstereditems(Arg arg)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		showHolsteredItems = arg.GetBool(0, showHolsteredItems);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.inventory.UpdatedVisibleHolsteredItems();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = BasePlayer.sleepingPlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.inventory.UpdatedVisibleHolsteredItems();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar]
	public static void player_state_cache_count(Arg args)
	{
		args.ReplyWith((object)SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheCount);
	}

	[ServerVar]
	public static void player_state_cache_evictions(Arg args)
	{
		args.ReplyWith((object)SingletonComponent<ServerMgr>.Instance.playerStateManager.CacheEvictions);
	}

	[ServerVar]
	public static string printreadqueue(Arg arg)
	{
		return "Server read queue: " + ((BaseNetwork)Net.sv).ReadQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).ReadQueueBytes, false);
	}

	[ServerVar]
	public static string printwritequeue(Arg arg)
	{
		return "Server write queue: " + ((BaseNetwork)Net.sv).WriteQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).WriteQueueBytes, false);
	}

	[ServerVar]
	public static string printdecryptqueue(Arg arg)
	{
		return "Server decrypt queue: " + ((BaseNetwork)Net.sv).DecryptQueueLength + " items / " + NumberExtensions.FormatBytes<int>(((BaseNetwork)Net.sv).DecryptQueueBytes, false);
	}

	[ServerVar]
	public static string packetlog(Arg arg)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (!packetlog_enabled)
		{
			return "Packet log is not enabled.";
		}
		List<Tuple<Type, ulong>> list = new List<Tuple<Type, ulong>>();
		foreach (KeyValuePair<Type, TimeAverageValue> item2 in SingletonComponent<ServerMgr>.Instance.packetHistory.dict)
		{
			list.Add(new Tuple<Type, ulong>(item2.Key, item2.Value.Calculate()));
		}
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("type");
			val.AddColumn("calls");
			foreach (Tuple<Type, ulong> item3 in list.OrderByDescending((Tuple<Type, ulong> entry) => entry.Item2))
			{
				if (item3.Item2 == 0L)
				{
					break;
				}
				Type item = item3.Item1;
				string text = ((object)(Type)(ref item)/*cast due to .constrained prefix*/).ToString();
				string text2 = item3.Item2.ToString();
				val.AddRow(new string[2] { text, text2 });
			}
			return flag ? val.ToJson(true) : ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static string rpclog(Arg arg)
	{
		if (!rpclog_enabled)
		{
			return "RPC log is not enabled.";
		}
		List<Tuple<uint, ulong>> list = new List<Tuple<uint, ulong>>();
		foreach (KeyValuePair<uint, TimeAverageValue> item in SingletonComponent<ServerMgr>.Instance.rpcHistory.dict)
		{
			list.Add(new Tuple<uint, ulong>(item.Key, item.Value.Calculate()));
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("calls");
			foreach (Tuple<uint, ulong> item2 in list.OrderByDescending((Tuple<uint, ulong> entry) => entry.Item2))
			{
				if (item2.Item2 == 0L)
				{
					break;
				}
				string text = item2.Item1.ToString();
				string text2 = StringPool.Get(item2.Item1);
				string text3 = item2.Item2.ToString();
				val.AddRow(new string[3] { text, text2, text3 });
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Starts a server")]
	public static void start(Arg arg)
	{
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			arg.ReplyWith("There is already a server running!");
			return;
		}
		string strLevelName = arg.GetString(0, level);
		if (!LevelManager.IsValid(strLevelName))
		{
			arg.ReplyWith("Level '" + strLevelName + "' isn't valid!");
			return;
		}
		if (Object.op_Implicit((Object)(object)Object.FindObjectOfType<ServerMgr>()))
		{
			arg.ReplyWith("There is already a server running!");
			return;
		}
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/shared.prefab"));
		Object.DontDestroyOnLoad((Object)(object)GameManager.server.CreatePrefab("assets/bundled/prefabs/system/server.prefab"));
		((MonoBehaviour)Global.Runner).StartCoroutine(LoadImpl());
		IEnumerator LoadImpl()
		{
			yield return LevelManager.LoadLevelAsync(strLevelName);
		}
	}

	[ServerVar(Help = "Stops a server")]
	public static void stop(Arg arg)
	{
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			arg.ReplyWith("There isn't a server running!");
		}
		else
		{
			Net.sv.Stop(arg.GetString(0, "Stopping Server"));
		}
	}

	[ServerVar(Help = "Backup server folder")]
	public static void backup()
	{
		DirectoryEx.Backup(backupFolder, backupFolder1, backupFolder2, backupFolder3);
		DirectoryEx.CopyAll(rootFolder, backupFolder);
	}

	public static string GetServerFolder(string folder)
	{
		string text = rootFolder + "/" + folder;
		if (Directory.Exists(text))
		{
			return text;
		}
		Directory.CreateDirectory(text);
		return text;
	}

	[ServerVar(Help = "Writes config files")]
	public static void writecfg(Arg arg)
	{
		string contents = ConsoleSystem.SaveToConfigString(true);
		File.WriteAllText(GetServerFolder("cfg") + "/serverauto.cfg", contents);
		ServerUsers.Save();
		arg.ReplyWith("Config Saved");
	}

	[ServerVar]
	public static void fps(Arg arg)
	{
		arg.ReplyWith(Performance.report.frameRate + " FPS");
	}

	[ServerVar(Help = "Force save the current game")]
	public static void save(Arg arg)
	{
		Stopwatch stopwatch = Stopwatch.StartNew();
		foreach (BaseEntity save in BaseEntity.saveList)
		{
			save.InvalidateNetworkCache();
		}
		Debug.Log((object)("Invalidate Network Cache took " + stopwatch.Elapsed.TotalSeconds.ToString("0.00") + " seconds"));
		SaveRestore.Save(AndWait: true);
	}

	[ServerVar]
	public static string readcfg(Arg arg)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		string serverFolder = GetServerFolder("cfg");
		Option server;
		if (File.Exists(serverFolder + "/serverauto.cfg"))
		{
			string text = File.ReadAllText(serverFolder + "/serverauto.cfg");
			server = Option.Server;
			ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text);
		}
		if (File.Exists(serverFolder + "/server.cfg"))
		{
			string text2 = File.ReadAllText(serverFolder + "/server.cfg");
			server = Option.Server;
			ConsoleSystem.RunFile(((Option)(ref server)).Quiet(), text2);
		}
		return "Server Config Loaded";
	}

	[ServerVar]
	public static string netprotocol(Arg arg)
	{
		if (Net.sv == null)
		{
			return string.Empty;
		}
		return Net.sv.ProtocolId;
	}

	[ServerUserVar]
	public static void cheatreport(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			string text = arg.GetUInt64(0, 0uL).ToString();
			string @string = arg.GetString(1, "");
			Debug.LogWarning((object)(((object)basePlayer)?.ToString() + " reported " + text + ": " + StringEx.ToPrintable(@string, 140)));
			EACServer.SendPlayerBehaviorReport(basePlayer, (PlayerReportsCategory)1, text, @string);
		}
	}

	[ServerVar(Help = "Get info on player corpses on the server")]
	public static void corpseinfo(Arg arg)
	{
		PlayerCorpse[] array = BaseNetworkable.serverEntities.OfType<PlayerCorpse>().ToArray();
		int num = 0;
		int num2 = 0;
		int num3 = 0;
		int num4 = 0;
		PlayerCorpse[] array2 = array;
		foreach (PlayerCorpse playerCorpse in array2)
		{
			if (playerCorpse.isClient)
			{
				continue;
			}
			num++;
			if (playerCorpse.CorpseIsRagdoll)
			{
				num2++;
				if (playerCorpse.CorpseRagdollScript.IsKinematic)
				{
					num3++;
				}
				else if (playerCorpse.CorpseRagdollScript.IsFullySleeping())
				{
					num4++;
				}
			}
		}
		int num5 = num2 - num3 - num4;
		float num6 = ((num2 > 0) ? ((float)num5 / (float)num2) : 0f);
		string text = $"Found {num} player corpses in the world, " + $"of which {num2} are using server-side ragdolls. " + $"{num5} of those are active ({num6:0%}), {num4} are sleeping, and {num3} are kinematic.";
		arg.ReplyWith(text);
	}

	[ServerAllVar(Help = "Get the player combat log")]
	public static string combatlog(Arg arg)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1) && arg.IsAdmin)
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if ((Object)(object)basePlayer == (Object)null || basePlayer.net == null)
		{
			return "invalid player";
		}
		CombatLog combat = basePlayer.stats.combat;
		int count = combatlogsize;
		bool json = arg.HasArg("--json", false);
		bool isAdmin = arg.IsAdmin;
		ulong requestingUser = arg.Connection?.userid ?? 0;
		return combat.Get(count, default(NetworkableId), json, isAdmin, requestingUser);
	}

	[ServerAllVar(Help = "Get the player combat log, only showing outgoing damage")]
	public static string combatlog_outgoing(Arg arg)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1) && arg.IsAdmin)
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if ((Object)(object)basePlayer == (Object)null)
		{
			return "invalid player";
		}
		return basePlayer.stats.combat.Get(combatlogsize, basePlayer.net.ID, arg.HasArg("--json", false), arg.IsAdmin, arg.Connection?.userid ?? 0);
	}

	[ServerVar(Help = "Print the current player position.")]
	public static string printpos(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3 position = ((Component)basePlayer).transform.position;
			return ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player center position.")]
	public static string printposcenter(Arg arg)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Vector3 center = basePlayer.GetCenter(ducked: false);
			return ((object)(Vector3)(ref center)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player rotation.")]
	public static string printrot(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Quaternion rotation = ((Component)basePlayer).transform.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			return ((object)(Vector3)(ref eulerAngles)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(Help = "Print the current player eyes.")]
	public static string printeyes(Arg arg)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (arg.HasArgs(1))
		{
			basePlayer = arg.GetPlayerOrSleeper(0);
		}
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Quaternion rotation = basePlayer.eyes.rotation;
			Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
			return ((object)(Vector3)(ref eulerAngles)/*cast due to .constrained prefix*/).ToString();
		}
		return "invalid player";
	}

	[ServerVar(ServerAdmin = true, Help = "This sends a snapshot of all the entities in the client's pvs. This is mostly redundant, but we request this when the client starts recording a demo.. so they get all the information.")]
	public static void snapshot(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if (!((Object)(object)basePlayer == (Object)null))
		{
			Debug.Log((object)("Sending full snapshot to " + (object)basePlayer));
			basePlayer.SendNetworkUpdateImmediate();
			basePlayer.SendGlobalSnapshot();
			basePlayer.SendFullSnapshot();
			basePlayer.SendEntityUpdate();
			TreeManager.SendSnapshot(basePlayer);
			ServerMgr.SendReplicatedVars(basePlayer.net.connection);
		}
	}

	[ServerVar(Help = "Send network update for all players")]
	public static void sendnetworkupdate(Arg arg)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.SendNetworkUpdate();
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	public static void GetPlayerListPosTable(TextTable table)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		table.ResizeColumns(4);
		table.AddColumn("SteamID");
		table.AddColumn("DisplayName");
		table.AddColumn("POS");
		table.AddColumn("ROT");
		table.ResizeRows(BasePlayer.activePlayerList.Count);
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				BasePlayer current = enumerator.Current;
				table.AddValue(current.userID.Get());
				table.AddValue(current.displayName);
				table.AddValue(((Component)current).transform.position);
				table.AddValue(current.eyes.BodyForward());
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
	}

	[ServerVar(Help = "Prints the position of all players on the server")]
	public static void playerlistpos(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			GetPlayerListPosTable(val);
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Prints all the vending machines on the server")]
	public static void listvendingmachines(Arg arg)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[3] { "EntityId", "Position", "Name" });
			foreach (VendingMachine item in BaseNetworkable.serverEntities.OfType<VendingMachine>())
			{
				string[] obj = new string[3]
				{
					((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString(),
					null,
					null
				};
				Vector3 position = ((Component)item).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = StringExtensions.QuoteSafe(item.shopName);
				val.AddRow(obj);
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Prints all the Tool Cupboards on the server")]
	public static void listtoolcupboards(Arg arg)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumns(new string[3] { "EntityId", "Position", "Authed" });
			foreach (BuildingPrivlidge item in BaseNetworkable.serverEntities.OfType<BuildingPrivlidge>())
			{
				string[] obj = new string[3]
				{
					((object)(NetworkableId)(ref item.net.ID)/*cast due to .constrained prefix*/).ToString(),
					null,
					null
				};
				Vector3 position = ((Component)item).transform.position;
				obj[1] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				obj[2] = item.authorizedPlayers.Count.ToString();
				val.AddRow(obj);
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void BroadcastPlayVideo(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		string @string = arg.GetString(0, "");
		if (string.IsNullOrWhiteSpace(@string))
		{
			arg.ReplyWith("Missing video URL");
			return;
		}
		Enumerator<BasePlayer> enumerator = BasePlayer.activePlayerList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				enumerator.Current.Command("client.playvideo", @string);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		arg.ReplyWith($"Sent video to {BasePlayer.activePlayerList.Count} players");
	}

	[ServerVar(Help = "Rescans the serveremoji folder, note that clients will need to reconnect to get the latest emoji")]
	public static void ResetServerEmoji()
	{
		RustEmojiLibrary.ResetServerEmoji();
	}

	[ServerVar]
	public static string BotCount()
	{
		return BasePlayer.bots.Count.ToString();
	}

	[ServerVar(Help = "Prints the current wipe id of the sav")]
	public static void printwipeid(Arg arg)
	{
		if (string.IsNullOrEmpty(SaveRestore.WipeId))
		{
			arg.ReplyWith("ERROR: wipe ID is null or empty!");
		}
		else
		{
			arg.ReplyWith(SaveRestore.WipeId);
		}
	}

	[ServerVar(Help = "Clears the loot spawn cache used to restrict loot into each era")]
	public static void clear_loot_spawn_cache(Arg arg)
	{
		LootContainer[] source = (from x in GameManager.server.preProcessed.prefabList.Values
			select x.GetComponent<LootContainer>() into x
			where (Object)(object)x != (Object)null
			select x).ToArray();
		LootSpawn[] array = (from x in source.Select((LootContainer x) => x.lootDefinition).Concat(from x in source.SelectMany((LootContainer x) => x.LootSpawnSlots)
				select x.definition)
			where (Object)(object)x != (Object)null
			select x).ToArray();
		LootSpawn[] array2 = array;
		for (int i = 0; i < array2.Length; i++)
		{
			array2[i].ClearCache();
		}
		arg.ReplyWith($"Cleared {array.Length} loot spawn caches");
	}

	[ServerVar]
	public static void clear_trees_radius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		float @float = arg.GetFloat(0, 0f);
		Vector3 position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
		if (arg.HasArgs(2))
		{
			position = arg.GetVector3(1, default(Vector3));
		}
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
			Vis.Entities(position, @float, list, 1073741824, (QueryTriggerInteraction)2);
			foreach (TreeEntity item in list)
			{
				item.Kill();
				num++;
			}
		}
		arg.ReplyWith($"Deleted {num} server tree entities within {@float}m");
	}

	[ServerVar]
	public static void clear_bushes_radius(Arg arg)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		float @float = arg.GetFloat(0, 0f);
		Vector3 position = (((Object)(object)basePlayer != (Object)null) ? ((Component)basePlayer).transform.position : Vector3.zero);
		if (arg.HasArgs(2))
		{
			position = arg.GetVector3(1, default(Vector3));
		}
		int num = 0;
		if ((Object)(object)basePlayer != (Object)null)
		{
			PooledList<BushEntity> val = Pool.Get<PooledList<BushEntity>>();
			try
			{
				Vis.Entities(position, @float, (List<BushEntity>)(object)val, 67108864, (QueryTriggerInteraction)2);
				foreach (BushEntity item in (List<BushEntity>)(object)val)
				{
					item.Kill();
					num++;
				}
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		arg.ReplyWith($"Deleted {num} server bush entities within {@float}m");
	}

	[ServerVar(Help = "Deletes items on the server that are not allowed in the era")]
	public static void enforce_era_restrictions(Arg arg)
	{
		int num = 0;
		int num2 = 0;
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		foreach (Item allItem in ItemManager.GetAllItems())
		{
			num++;
			if (!allItem.info.IsAllowed((EraRestriction)0))
			{
				if (!dictionary.ContainsKey(allItem.info.shortname))
				{
					dictionary.Add(allItem.info.shortname, allItem.amount);
				}
				else
				{
					dictionary[allItem.info.shortname] += allItem.amount;
				}
				allItem.Remove();
				num2++;
			}
		}
		ItemManager.DoRemoves();
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Iterated '{num}' items and removed '{num2}' restricted items");
		foreach (KeyValuePair<string, int> item in dictionary)
		{
			stringBuilder.AppendLine($"{item.Key}: {item.Value}");
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void fillChickenCoop(Arg arg)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		PooledList<ChickenCoop> val = Pool.Get<PooledList<ChickenCoop>>();
		try
		{
			Vis.Entities(((Component)basePlayer).transform.position, 5f, (List<ChickenCoop>)(object)val, 256, (QueryTriggerInteraction)2);
			foreach (ChickenCoop item in (List<ChickenCoop>)(object)val)
			{
				if (item.isServer)
				{
					item.DebugFillCoop();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Unlock all static respawn points")]
	public static void unlockrespawns(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		foreach (SleepingBag sleepingBag in SleepingBag.sleepingBags)
		{
			if (sleepingBag is StaticRespawnArea staticRespawnArea && !staticRespawnArea.IsAuthed(basePlayer.userID))
			{
				staticRespawnArea.Authorize(basePlayer.userID);
			}
		}
	}

	[ServerVar(Help = "Clear all static respawn points")]
	public static void resetrespawns(Arg arg)
	{
		BasePlayer basePlayer = arg.GetPlayer(0);
		if ((Object)(object)basePlayer == (Object)null)
		{
			if (arg.HasArgs(1))
			{
				arg.ReplyWith("Can't find player");
				return;
			}
			basePlayer = arg.Player();
		}
		foreach (SleepingBag sleepingBag in SleepingBag.sleepingBags)
		{
			if (sleepingBag is StaticRespawnArea staticRespawnArea && staticRespawnArea.IsAuthed(basePlayer.userID))
			{
				staticRespawnArea.Deauthorize(basePlayer.userID);
			}
		}
	}

	public static void GetPlayerReportsListTable(TextTable table)
	{
		table.ResizeColumns(4);
		table.AddColumn("NumReports");
		table.AddColumn("UserID");
		table.AddColumn("DisplayName");
		table.AddColumn("IsConnected");
		foreach (BasePlayer item in BasePlayer.allPlayerList.OrderByDescending((BasePlayer x) => x.State.numberOfTimesReported))
		{
			if (item.State.numberOfTimesReported >= 1)
			{
				table.AddValue(item.State.numberOfTimesReported);
				table.AddValue((ulong)item.userID);
				table.AddValue(item.displayName);
				table.AddValue(item.IsConnected);
			}
		}
	}

	[ServerVar(Help = "List the amount of reports players on the server have received")]
	public static void listplayerreportcounts(Arg arg)
	{
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			GetPlayerReportsListTable(val);
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Help = "Clear the player reports list")]
	public static void clearplayerreportcounts(Arg arg)
	{
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			allPlayer.State.numberOfTimesReported = 0;
		}
		arg.ReplyWith("Cleared report counts");
	}

	private static void OnEraChanged()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<BaseNetworkable> enumerator = BaseNetworkable.serverEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				if (enumerator.Current is LootContainer lootContainer)
				{
					lootContainer.PopulateLoot();
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		SingletonComponent<SpawnHandler>.Instance?.EnforceLimits();
	}

	private static string AutoCorrectTags(string value)
	{
		List<string> inputValues = (from s in value.Split(',', StringSplitOptions.RemoveEmptyEntries)
			select s.Trim().ToLowerInvariant()).ToList();
		List<string> outputValues = new List<string>();
		Add(new string[3] { "monthly", "biweekly", "weekly" });
		Add(new string[3] { "vanilla", "hardcore", "softcore" });
		Add(new string[1] { "roleplay" });
		Add(new string[1] { "creative" });
		Add(new string[1] { "minigame" });
		Add(new string[1] { "training" });
		Add(new string[1] { "battlefield" });
		Add(new string[1] { "broyale" });
		Add(new string[1] { "builds" });
		Add(new string[7] { "NA", "SA", "EU", "WA", "EA", "OC", "AF" });
		Add(new string[1] { "tut" });
		Add(new string[1] { "premium" });
		if (!pve)
		{
			Add(new string[1] { "pve" });
		}
		return string.Join(',', outputValues);
		void Add(string[] options)
		{
			if (outputValues.Count < 4)
			{
				foreach (string text in options)
				{
					if (inputValues.Contains<string>(text, StringComparer.InvariantCultureIgnoreCase))
					{
						outputValues.Add(text);
						break;
					}
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using UnityEngine;

[Factory("spawn")]
public class Spawn : ConsoleSystem
{
	[ServerVar]
	public static float min_rate = 0.5f;

	[ServerVar]
	public static float max_rate = 1f;

	[ServerVar]
	public static float min_density = 0.5f;

	[ServerVar]
	public static float max_density = 1f;

	[ServerVar]
	public static float player_base = 100f;

	[ServerVar]
	public static float player_scale = 2f;

	[ServerVar]
	public static bool respawn_populations = true;

	[ServerVar]
	public static bool respawn_groups = true;

	[ServerVar]
	public static bool respawn_individuals = true;

	[ServerVar]
	public static float tick_populations = 60f;

	[ServerVar]
	public static float tick_individuals = 300f;

	[ServerVar(Help = "When scaling loot respawn rates by population, this will be considered the 'max' population, preventing loot speeding up if player counts are above this")]
	public static int population_cap_rate = 300;

	[ServerVar(Help = "If set the loot spawn system will consider this the player count, not the actual player count. Useful for testing")]
	public static int loot_population_test = 0;

	[ServerVar]
	public static void fill_populations(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillPopulations();
		}
	}

	[ServerVar]
	public static void delete_populations(Arg args)
	{
		if (!args.HasArgs(1))
		{
			args.ReplyWith("Usage: delete_populations <population_name> ...");
			return;
		}
		string[] args2 = args.Args;
		foreach (string name in args2)
		{
			SingletonComponent<SpawnHandler>.Instance?.DeletePopulation(name);
		}
	}

	[ServerVar]
	public static void delete_all_populations(Arg args)
	{
		SingletonComponent<SpawnHandler>.Instance?.DeleteAllPopulations();
	}

	[ServerVar(Help = "<iterations> - Simulates a number of iterations on the closest loot container and sums up the items spawned")]
	public static void simulate_loot(Arg args)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer player = args.Player();
		if ((Object)(object)player == (Object)null)
		{
			args.ReplyWith("Must be called from player");
			return;
		}
		int num = Mathf.Clamp(args.GetInt(0, 100), 1, 10000);
		List<LootContainer> list = new List<LootContainer>();
		Vis.Entities(((Component)player).transform.position, 5f, list, -1, (QueryTriggerInteraction)1);
		LootContainer lootContainer = list.OrderBy((LootContainer x) => Vector3.Distance(((Component)player).transform.position, ((Component)x).transform.position)).FirstOrDefault();
		if ((Object)(object)lootContainer == (Object)null)
		{
			args.ReplyWith("No loot container found");
			return;
		}
		Dictionary<string, int> dictionary = new Dictionary<string, int>();
		for (int i = 0; i < num; i++)
		{
			lootContainer.inventory.Clear();
			ItemManager.DoRemoves();
			lootContainer.PopulateLoot();
			foreach (Item item in lootContainer.inventory.itemList)
			{
				if (item != null)
				{
					dictionary.TryGetValue(item.info.shortname, out var value);
					dictionary[item.info.shortname] = value + item.amount;
				}
			}
		}
		int totalWidth = dictionary.Max((KeyValuePair<string, int> x) => x.Key.Length);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Simulated loot from {num} {lootContainer.ShortPrefabName}:");
		foreach (KeyValuePair<string, int> item2 in dictionary.OrderByDescending((KeyValuePair<string, int> x) => x.Value))
		{
			stringBuilder.AppendLine($"{item2.Key.PadRight(totalWidth)} : {item2.Value}");
		}
		args.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void fill_groups(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillGroups();
		}
	}

	[ServerVar]
	public static void fill_individuals(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.FillIndividuals();
		}
	}

	[ServerVar]
	public static void report(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			bool @bool = args.GetBool(0, false);
			string @string = args.GetString(1, (string)null);
			args.ReplyWith(SingletonComponent<SpawnHandler>.Instance.GetReport(@bool, @string));
		}
		else
		{
			args.ReplyWith("No spawn handler found.");
		}
	}

	[ServerVar]
	public static void scalars(Arg args)
	{
		bool flag = args.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("Type");
			val.AddColumn("Value");
			val.AddRow(new string[2]
			{
				"Player Fraction",
				SpawnHandler.PlayerFraction().ToString()
			});
			val.AddRow(new string[2]
			{
				"Player Excess",
				SpawnHandler.PlayerExcess().ToString()
			});
			val.AddRow(new string[2]
			{
				"Population Rate",
				SpawnHandler.PlayerLerp(min_rate, max_rate).ToString()
			});
			val.AddRow(new string[2]
			{
				"Population Density",
				SpawnHandler.PlayerLerp(min_density, max_density).ToString()
			});
			val.AddRow(new string[2]
			{
				"Group Rate",
				SpawnHandler.PlayerScale(player_scale).ToString()
			});
			args.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar]
	public static void cargoshipevent(Arg args)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab");
		if ((Object)(object)baseEntity != (Object)null)
		{
			((Component)baseEntity).SendMessage("TriggeredEventSpawn", (SendMessageOptions)1);
			baseEntity.Spawn();
			args.ReplyWith("Cargo ship event has been started");
		}
		else
		{
			args.ReplyWith("Couldn't find cargo ship prefab - maybe it has been renamed?");
		}
	}

	[ServerVar]
	public static void ch47event(Arg args)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = args.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return;
		}
		if (!CH47LandingZone.HasAnyLandingZones)
		{
			args.ReplyWith("Couldn't find any landing zones for CH47. Not starting the event");
			return;
		}
		int @int = args.GetInt(0, 300);
		if (CH47ReinforcementListener.TryCall("assets/Prefabs/NPC/CH47/ch47scientists.entity.prefab", ((Component)basePlayer).transform.position, @int))
		{
			args.ReplyWith($"CH47 event has been started at a distance of {@int}m");
		}
		else
		{
			args.ReplyWith("Couldn't start CH47 event");
		}
	}

	[ServerVar]
	public static void cargoshipdockingtest(Arg args)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (CargoShip.TotalAvailableHarborDockingPaths == 0)
		{
			args.ReplyWith("No valid harbor dock points");
			return;
		}
		int @int = args.GetInt(0, 0);
		@int = Mathf.Clamp(@int, 0, CargoShip.TotalAvailableHarborDockingPaths);
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/content/vehicles/boats/cargoship/cargoshiptest.prefab");
		if ((Object)(object)baseEntity != (Object)null)
		{
			((Component)baseEntity).SendMessage("TriggeredEventSpawnDockingTest", (object)@int, (SendMessageOptions)1);
			baseEntity.Spawn();
			args.ReplyWith("Cargo ship event has been started");
		}
		else
		{
			args.ReplyWith("Couldn't find cargo ship prefab - maybe it has been renamed?");
		}
	}

	[ServerVar]
	public static void svShieldDummy(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		bool @bool = arg.GetBool(2, false);
		BasePlayer basePlayer = GameManager.server.CreateEntity("assets/prefabs/player/player.prefab", vector, Quaternion.Euler(vector2)) as BasePlayer;
		basePlayer.Spawn();
		if (Inventory.LoadLoadout("Shields", out var so))
		{
			so.LoadItemsOnTo(basePlayer);
			if (!@bool)
			{
				Inventory.EquipItemInSlot(basePlayer, 0);
			}
			else
			{
				Inventory.EquipItemInSlot(basePlayer, -1);
			}
		}
	}
}


[Factory("SSS")]
public class SSS : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool enabled = true;

	[ClientVar(Saved = true)]
	public static int quality = 0;

	[ClientVar(Saved = true)]
	public static bool halfres = true;

	[ClientVar(Saved = true)]
	public static float scale = 1f;
}


using System.Linq;
using UnityEngine;

[Factory("stability")]
public class Stability : ConsoleSystem
{
	[ServerVar]
	public static int verbose = 0;

	[ServerVar]
	public static int strikes = 10;

	[ServerVar]
	public static float collapse = 0.05f;

	[ServerVar]
	public static float accuracy = 0.001f;

	[ServerVar]
	public static float stabilityqueue = 9f;

	[ServerVar]
	public static float surroundingsqueue = 3f;

	[ServerVar]
	public static bool support_highest_stability = true;

	[ServerVar]
	public static bool log_stability_death = false;

	[ServerVar]
	public static bool log_ground_missing_death = false;

	[ServerVar]
	public static void refresh_stability(Arg args)
	{
		StabilityEntity[] array = BaseNetworkable.serverEntities.OfType<StabilityEntity>().ToArray();
		Debug.Log((object)("Refreshing stability on " + array.Length + " entities..."));
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateStability();
		}
	}
}


public class Steam
{
	[ReplicatedVar(Saved = true, ShowInAdminUI = true)]
	public static bool server_allow_steam_nicknames { get; set; } = true;
}


public class Store
{
}


using UnityEngine;

[Factory("supply")]
public class Supply : ConsoleSystem
{
	private const string path = "assets/prefabs/npc/cargo plane/cargo_plane.prefab";

	[ServerVar]
	public static void drop(Arg arg)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if (Object.op_Implicit((Object)(object)basePlayer))
		{
			Debug.Log((object)"Supply Drop Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).GetComponent<CargoPlane>().InitDropPosition(((Component)basePlayer).transform.position + new Vector3(0f, 10f, 0f));
				baseEntity.Spawn();
			}
		}
	}

	[ServerVar]
	public static void call(Arg arg)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)arg.Player()))
		{
			Debug.Log((object)"Supply Drop Inbound");
			BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/npc/cargo plane/cargo_plane.prefab");
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				baseEntity.Spawn();
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using UnityEngine;

[Factory("system")]
public static class SystemCommands
{
	public static bool appliedManualCpuAffinity;

	[ServerVar]
	[ClientVar]
	public static void cpu_affinity(Arg arg)
	{
		ulong num = 0uL;
		if (!arg.HasArgs(1))
		{
			arg.ReplyWith("Format is 'cpu_affinity {core,core1-core2,etc}'");
			return;
		}
		string[] array = arg.GetString(0, "").Split(',');
		HashSet<int> hashSet = new HashSet<int>();
		string[] array2 = array;
		foreach (string text in array2)
		{
			if (int.TryParse(text, out var result))
			{
				hashSet.Add(result);
			}
			else
			{
				if (!text.Contains('-'))
				{
					continue;
				}
				string[] array3 = text.Split('-');
				if (array3.Length != 2)
				{
					arg.ReplyWith("Failed to parse section " + text + ", format should be '0-15'");
					continue;
				}
				if (!int.TryParse(array3[0], out var result2) || !int.TryParse(array3[1], out var result3))
				{
					arg.ReplyWith("Core range in section " + text + " are not valid numbers, format should be '0-15'");
					continue;
				}
				if (result2 > result3)
				{
					arg.ReplyWith("Core range in section " + text + " are not ordered from least to greatest, format should be '0-15'");
					continue;
				}
				if (result3 - result2 > 64)
				{
					arg.ReplyWith("Core range in section " + text + " are too big of a range, must be <64");
					return;
				}
				for (int j = result2; j <= result3; j++)
				{
					hashSet.Add(j);
				}
			}
		}
		if (hashSet.Any((int x) => x < 0 || x > 63))
		{
			arg.ReplyWith("Cores provided out of range! Must be in between 0 and 63");
			return;
		}
		for (int k = 0; k < 64; k++)
		{
			if (hashSet.Contains(k))
			{
				num |= (ulong)(1L << k);
			}
		}
		if (num == 0L)
		{
			arg.ReplyWith("No cores provided (bitmask empty)! Format is 'cpu_affinity {core,core1-core2,etc}'");
		}
		else if (SetCpuAffinity(num))
		{
			appliedManualCpuAffinity = true;
			arg.ReplyWith("Successfully changed CPU affinity");
		}
	}

	public static bool SetCpuAffinity(ulong affinityMask)
	{
		try
		{
			Process.GetCurrentProcess().ProcessorAffinity = (IntPtr)(long)affinityMask;
			return true;
		}
		catch (Exception arg)
		{
			Debug.LogWarning((object)$"Unable to set CPU affinity: {arg}");
			return false;
		}
	}

	[ClientVar]
	[ServerVar]
	public static void cpu_priority(Arg arg)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		if ((int)Application.platform == 1)
		{
			arg.ReplyWith("OSX is not a supported platform");
			return;
		}
		string @string = arg.GetString(0, "");
		ProcessPriorityClass priorityClass;
		switch (@string.Replace("-", "").Replace("_", ""))
		{
		case "belownormal":
			priorityClass = ProcessPriorityClass.BelowNormal;
			break;
		case "normal":
			priorityClass = ProcessPriorityClass.Normal;
			break;
		case "abovenormal":
			priorityClass = ProcessPriorityClass.AboveNormal;
			break;
		case "high":
			priorityClass = ProcessPriorityClass.High;
			break;
		default:
			arg.ReplyWith("Unknown priority '" + @string + "', possible values: below_normal, normal, above_normal, high");
			return;
		}
		try
		{
			Process.GetCurrentProcess().PriorityClass = priorityClass;
		}
		catch (Exception arg2)
		{
			Debug.LogWarning((object)$"Unable to set cpu priority: {arg2}");
			return;
		}
		arg.ReplyWith("Successfully changed cpu priority to " + priorityClass);
	}
}


[Factory("terrain")]
public class Terrain : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static float quality = 100f;
}


[Factory("texture")]
public class Texture : ConsoleSystem
{
}


using UnityEngine;

[Factory("time")]
public class Time : ConsoleSystem
{
	public const int SERVER_DEFAULT_TICKS = 16;

	public const int CLIENT_DEFAULT_TICKS = 32;

	public const string CLIENT_DEFAULT_TICKS_STR = "32";

	[ServerVar]
	[Help("Pause time while loading")]
	public static bool pausewhileloading = true;

	private static int _cl_steps = 32;

	private static int _cl_maxstepsperframe = 2;

	[ServerVar(Help = "Desired physics ticks per second on the server")]
	public static int sv_steps
	{
		get
		{
			return Mathf.RoundToInt(1f / Time.fixedDeltaTime);
		}
		set
		{
			value = Mathf.Clamp(value, 16, 64);
			int num = sv_maxstepsperframe;
			Time.fixedDeltaTime = 1f / (float)value;
			sv_maxstepsperframe = num;
		}
	}

	[ServerVar(Help = "The maximum amount physics ticks per frame on the server. If things are taking too long, time slows down")]
	public static int sv_maxstepsperframe
	{
		get
		{
			return Mathf.RoundToInt(Time.maximumDeltaTime / Time.fixedDeltaTime);
		}
		set
		{
			value = Mathf.Clamp(value, 2, 10);
			Time.maximumDeltaTime = (float)value * Time.fixedDeltaTime;
		}
	}

	[Help("The time scale")]
	[ServerVar]
	public static float timescale
	{
		get
		{
			return Time.timeScale;
		}
		set
		{
			Time.timeScale = value;
		}
	}

	[ReplicatedVar(Help = "Desired physics ticks per second on clients", Default = "32")]
	public static int cl_steps
	{
		get
		{
			return _cl_steps;
		}
		set
		{
			value = Mathf.Clamp(value, 32, 64);
			_cl_steps = value;
			cl_maxstepsperframe = _cl_maxstepsperframe;
		}
	}

	[ReplicatedVar(Help = "The maximum amount physics ticks per frame on clients. If things are taking too long, time slows down", Default = "2")]
	public static int cl_maxstepsperframe
	{
		get
		{
			return _cl_maxstepsperframe;
		}
		set
		{
			value = Mathf.Clamp(value, 2, 10);
			_cl_maxstepsperframe = value;
		}
	}
}


[Factory("tree")]
public class Tree : ConsoleSystem
{
	[ServerVar]
	public static bool global_broadcast;

	[ServerVar]
	public static bool simplified_collider;
}


using System;
using Facepunch;
using UnityEngine;

[Factory("vehicle")]
public class vehicle : ConsoleSystem
{
	[ServerVar]
	[Help("how long until boat corpses despawn (excluding tugboat - use tugboat_corpse_seconds)")]
	public static float boat_corpse_seconds = 300f;

	[ServerVar]
	public static bool disable_wheels_when_sleeping = true;

	[ServerVar(Help = "If true, trains always explode when destroyed, and hitting a barrier always destroys the train immediately. Default: false")]
	public static bool cinematictrains = false;

	[ServerVar(Help = "Determines whether trains stop automatically when there's no-one on them. Default: false")]
	public static bool trainskeeprunning = false;

	[ServerVar(Help = "Determines whether modular cars turn into wrecks when destroyed, or just immediately gib. Default: true")]
	public static bool carwrecks = true;

	[ServerVar(Help = "Determines whether vehicles drop storage items when destroyed. Default: true")]
	public static bool vehiclesdroploot = true;

	[ServerUserVar]
	public static void swapseats(Arg arg)
	{
		int seat = -1;
		TryMovePlayerToSeat(arg.Player(), seat);
	}

	[ServerUserVar]
	public static void swaptoseat(Arg arg)
	{
		int @int = arg.GetInt(0, -1);
		TryMovePlayerToSeat(arg.Player(), @int);
	}

	public static void TryMovePlayerToSeat(BasePlayer ply, int seat)
	{
		if ((Object)(object)ply == (Object)null || ply.SwapSeatCooldown())
		{
			return;
		}
		BaseMountable mounted = ply.GetMounted();
		if (!((Object)(object)mounted == (Object)null))
		{
			BaseVehicle baseVehicle = ((Component)mounted).GetComponent<BaseVehicle>();
			if ((Object)(object)baseVehicle == (Object)null)
			{
				baseVehicle = mounted.VehicleParent();
			}
			if (!((Object)(object)baseVehicle == (Object)null))
			{
				baseVehicle.SwapSeats(ply, seat);
			}
		}
	}

	[ServerVar]
	public static void fixcars(Arg arg)
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
			return;
		}
		if (!basePlayer.IsAdmin)
		{
			arg.ReplyWith("Must be an admin to use fixcars.");
			return;
		}
		int @int = arg.GetInt(0, 2);
		@int = Mathf.Clamp(@int, 1, 3);
		BaseVehicle[] array = BaseEntity.Util.FindAll<BaseVehicle>();
		int num = 0;
		BaseVehicle[] array2 = array;
		foreach (BaseVehicle baseVehicle in array2)
		{
			if (baseVehicle.isServer && Vector3.Distance(((Component)baseVehicle).transform.position, ((Component)basePlayer).transform.position) <= 10f && baseVehicle.AdminFixUp(@int))
			{
				num++;
			}
		}
		MLRS[] array3 = BaseEntity.Util.FindAll<MLRS>();
		foreach (MLRS mLRS in array3)
		{
			if (mLRS.isServer && Vector3.Distance(((Component)mLRS).transform.position, ((Component)basePlayer).transform.position) <= 10f && mLRS.AdminFixUp())
			{
				num++;
			}
		}
		DiverPropulsionVehicle[] array4 = BaseEntity.Util.FindAll<DiverPropulsionVehicle>();
		foreach (DiverPropulsionVehicle diverPropulsionVehicle in array4)
		{
			if (diverPropulsionVehicle.isServer && Vector3.Distance(((Component)diverPropulsionVehicle).transform.position, ((Component)basePlayer).transform.position) <= 10f && diverPropulsionVehicle.AdminFixUp())
			{
				num++;
			}
		}
		HotAirBalloon[] array5 = BaseEntity.Util.FindAll<HotAirBalloon>();
		foreach (HotAirBalloon hotAirBalloon in array5)
		{
			if (hotAirBalloon.isServer && Vector3.Distance(((Component)hotAirBalloon).transform.position, ((Component)basePlayer).transform.position) <= 10f && hotAirBalloon.AdminFixUp())
			{
				num++;
			}
		}
		arg.ReplyWith($"Fixed up {num} vehicles.");
	}

	[ServerVar]
	public static void autohover(Arg arg)
	{
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null)
		{
			arg.ReplyWith("Null player.");
			return;
		}
		if (!basePlayer.IsAdmin)
		{
			arg.ReplyWith("Must be an admin to use autohover.");
			return;
		}
		BaseHelicopter baseHelicopter = basePlayer.GetMountedVehicle() as BaseHelicopter;
		if ((Object)(object)baseHelicopter != (Object)null)
		{
			bool flag = baseHelicopter.ToggleAutoHover(basePlayer);
			arg.ReplyWith($"Toggled auto-hover to {flag}.");
		}
		else
		{
			arg.ReplyWith("Must be mounted in a helicopter first.");
		}
	}

	[ServerVar]
	public static void stop_all_trains(Arg arg)
	{
		TrainEngine[] array = Object.FindObjectsOfType<TrainEngine>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].StopEngine();
		}
		arg.ReplyWith("All trains stopped.");
	}

	[ServerVar]
	public static void killcars(Arg args)
	{
		ModularCar[] array = BaseEntity.Util.FindAll<ModularCar>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killpushbikes(Arg args)
	{
		Bike[] array = BaseEntity.Util.FindAll<Bike>();
		foreach (Bike bike in array)
		{
			if (bike.poweredBy == Bike.PoweredBy.Human)
			{
				bike.Kill();
			}
		}
	}

	[ServerVar]
	public static void killmotorbikes(Arg args)
	{
		Bike[] array = BaseEntity.Util.FindAll<Bike>();
		foreach (Bike bike in array)
		{
			if (bike.poweredBy == Bike.PoweredBy.Fuel)
			{
				bike.Kill();
			}
		}
	}

	[ServerVar]
	public static void killminis(Arg args)
	{
		PlayerHelicopter[] array = BaseEntity.Util.FindAll<PlayerHelicopter>();
		foreach (PlayerHelicopter playerHelicopter in array)
		{
			if (((Object)playerHelicopter).name.ToLower().Contains("minicopter"))
			{
				playerHelicopter.Kill();
			}
		}
	}

	[ServerVar]
	public static void killscraphelis(Arg args)
	{
		ScrapTransportHelicopter[] array = BaseEntity.Util.FindAll<ScrapTransportHelicopter>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killtrains(Arg args)
	{
		TrainCar[] array = BaseEntity.Util.FindAll<TrainCar>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killboats(Arg args)
	{
		BaseBoat[] array = BaseEntity.Util.FindAll<BaseBoat>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].Kill();
		}
	}

	[ServerVar]
	public static void killdrones(Arg args)
	{
		Drone[] array = BaseEntity.Util.FindAll<Drone>();
		foreach (Drone drone in array)
		{
			if (!(drone is DeliveryDrone))
			{
				drone.Kill();
			}
		}
	}

	[ServerVar(Help = "Print out boat drift status for all boats")]
	public static void boatdriftinfo(Arg args)
	{
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("id");
			val.AddColumn("name");
			val.AddColumn("position");
			val.AddColumn("status");
			val.AddColumn("drift");
			BaseBoat[] array = BaseEntity.Util.FindAll<BaseBoat>();
			BaseBoat[] array2 = array;
			foreach (BaseBoat baseBoat in array2)
			{
				if (baseBoat.IsValid())
				{
					string text = (baseBoat.IsAlive() ? "alive" : "dead");
					string driftStatus = baseBoat.GetDriftStatus();
					string[] obj = new string[5]
					{
						((object)(NetworkableId)(ref baseBoat.net.ID)/*cast due to .constrained prefix*/).ToString(),
						baseBoat.ShortPrefabName,
						null,
						null,
						null
					};
					Vector3 position = ((Component)baseBoat).transform.position;
					obj[2] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
					obj[3] = text;
					obj[4] = driftStatus;
					val.AddRow(obj);
				}
			}
			if (array.Length == 0)
			{
				args.ReplyWith("No boats in world");
			}
			args.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


[Factory("vis")]
public class Vis : ConsoleSystem
{
	[Help("Turns on debug display of lerp")]
	[ClientVar]
	public static bool lerp;

	[Help("Turns on debug display of damages")]
	[ServerVar]
	public static bool damage;

	[ServerVar]
	[ClientVar]
	[Help("Turns on debug display of attacks")]
	public static bool attack;

	[Help("Turns on debug display of protection")]
	[ClientVar]
	[ServerVar]
	public static bool protection;

	[Help("Turns on debug display of weakspots")]
	[ServerVar]
	public static bool weakspots;

	[Help("Show trigger entries")]
	[ServerVar]
	public static bool triggers;

	[Help("Turns on debug display of hitboxes")]
	[ServerVar]
	public static bool hitboxes;

	[Help("Turns on debug display of line of sight checks")]
	[ServerVar]
	public static bool lineofsight;

	[Help("Turns on debug display of senses, which are received by Ai")]
	[ServerVar]
	public static bool sense;
}


using UnityEngine;

[Factory("voice")]
public class Voice : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool loopback = false;

	private static float _voiceRangeBoostAmount = 50f;

	[ReplicatedVar]
	public static float voiceRangeBoostAmount
	{
		get
		{
			return _voiceRangeBoostAmount;
		}
		set
		{
			_voiceRangeBoostAmount = Mathf.Clamp(value, 0f, 200f);
		}
	}

	[ServerVar(Help = "Enabled/disables voice range boost for a player eg. ToggleVoiceRangeBoost sam 1")]
	public static void ToggleVoiceRangeBoost(Arg arg)
	{
		BasePlayer player = arg.GetPlayer(0);
		if ((Object)(object)player == (Object)null)
		{
			arg.ReplyWith("Invalid player: " + arg.GetString(0, ""));
			return;
		}
		bool @bool = arg.GetBool(1, false);
		player.SetPlayerFlag(BasePlayer.PlayerFlags.VoiceRangeBoost, @bool);
		arg.ReplyWith($"Set {player.displayName} volume boost to {@bool}");
	}
}


[Factory("water")]
public class Water : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static int quality = 1;

	public static int MaxQuality = 2;

	public static int MinQuality = 0;

	[ClientVar(Saved = true)]
	public static int reflections = 1;

	public static int MaxReflections = 2;

	public static int MinReflections = 0;

	[ClientVar(ClientAdmin = true, Default = "0")]
	public static bool scaled_time = false;
}


using System;
using System.Globalization;
using System.Text;
using Facepunch;
using UnityEngine;

[Factory("weather")]
public class Weather : ConsoleSystem
{
	[ServerVar]
	public static float wetness_rain = 0.4f;

	[ServerVar]
	public static float wetness_snow = 0.2f;

	[ReplicatedVar(Default = "-1")]
	public static float ocean_time = -1f;

	[ReplicatedVar(Default = "1")]
	public static float clear_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 1f;
			}
			return SingletonComponent<Climate>.Instance.Weather.ClearChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.ClearChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float dust_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.DustChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.DustChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float fog_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.FogChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.FogChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float overcast_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.OvercastChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.OvercastChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float storm_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.StormChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.StormChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "0")]
	public static float rain_chance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return 0f;
			}
			return SingletonComponent<Climate>.Instance.Weather.RainChance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.Weather.RainChance = Mathf.Clamp01(value);
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float rain
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Rain;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Rain = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float wind
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Wind;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Wind = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float thunder
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Thunder = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float rainbow
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Rainbow = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float fog
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Fogginess;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Fogginess = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_rayleigh
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.RayleighMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.RayleighMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_mie
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.MieMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.MieMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_brightness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Brightness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Brightness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_contrast
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Contrast;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Contrast = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_directionality
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Directionality;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Atmosphere.Directionality = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_size
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Size;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Size = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_opacity
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Opacity;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Opacity = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_coverage
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coverage;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coverage = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_sharpness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Sharpness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Sharpness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_coloring
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coloring;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Coloring = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_attenuation
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Attenuation;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Attenuation = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_saturation
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Saturation;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Saturation = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_scattering
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Scattering;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Scattering = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float cloud_brightness
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Brightness;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.Clouds.Brightness = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float ocean_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.OceanScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.OceanScale = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float ambient_light_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AmbientLightMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AmbientLightMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float directional_light_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.DirectionalLightMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.DirectionalLightMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float reflection_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ReflectionMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ReflectionMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float sun_mesh_brightness_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.SunMeshBrightnessMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.SunMeshBrightnessMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float moon_mesh_brightness_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.MoonMeshBrightnessMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.MoonMeshBrightnessMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float fog_multiplier
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.FogMultiplier;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.FogMultiplier = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float biome_fog_distance_curve
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogDistanceCurve;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogDistanceCurve = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float biome_fog_ambient_saturation_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogAmbientSaturationMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.BiomeFogAmbientSaturationMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_fog_height_falloff
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogHeightFalloff;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogHeightFalloff = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float vclouds_sun_color_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsSunColorScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsSunColorScale = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float vclouds_moon_color_scale
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsMoonColorScale;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsMoonColorScale = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arid_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AridFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float temperate_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TemperateFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float tundra_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.TundraFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float arctic_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.ArcticFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_ambient_intensity_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.AmbientIntensityMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.AmbientIntensityMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_light_boost_mult
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.LightBoostMult;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.LightBoostMult = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_ramp_start
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampStartDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampStartDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float jungle_fog_ramp_end
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampEndDist;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.JungleFogMults.FogRampEndDist = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static int cloud_config
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.OverrideCloudConfig;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.OverrideCloudConfig = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_fog_ramp_start_distance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampStartDistance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampStartDistance = value;
			}
		}
	}

	[ReplicatedVar(Default = "-1")]
	public static float atmosphere_fog_ramp_end_distance
	{
		get
		{
			if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				return -1f;
			}
			return SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampEndDistance;
		}
		set
		{
			if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
			{
				SingletonComponent<Climate>.Instance.WeatherOverrides.AtmosphereFogRampEndDistance = value;
			}
		}
	}

	[ServerVar]
	[ClientVar]
	public static void load(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		string name = args.GetString(0, "");
		if (string.IsNullOrEmpty(name))
		{
			args.ReplyWith("Weather preset name invalid.");
			return;
		}
		WeatherPreset weatherPreset = Array.Find(SingletonComponent<Climate>.Instance.WeatherPresets, (WeatherPreset x) => StringEx.Contains(((Object)x).name, name, CompareOptions.IgnoreCase));
		if ((Object)(object)weatherPreset == (Object)null)
		{
			args.ReplyWith("Weather preset not found: " + name);
			return;
		}
		SingletonComponent<Climate>.Instance.WeatherOverrides.Set(weatherPreset);
		SingletonComponent<Climate>.Instance.WeatherOverrides.SetVolumeCloudsConfigs(weatherPreset);
		if (args.IsServerside)
		{
			ServerMgr.SendReplicatedVars("weather.");
		}
	}

	public static WeatherPreset GetWeatherPreset(string withName)
	{
		return Array.Find(SingletonComponent<Climate>.Instance.WeatherPresets, (WeatherPreset x) => StringEx.Contains(((Object)x).name, withName, CompareOptions.IgnoreCase));
	}

	[ClientVar]
	public static void debug_cloud_position(Arg args)
	{
	}

	[ClientVar]
	[ServerVar]
	public static void load_cloud_config(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		string name = args.GetString(0, "");
		if (string.IsNullOrEmpty(name))
		{
			return;
		}
		VolumeCloudsConfig volumeCloudsConfig = Array.Find(SingletonComponent<Climate>.Instance.AllCloudConfigs, (VolumeCloudsConfig x) => StringEx.Contains(((Object)x).name, name, CompareOptions.IgnoreCase));
		if ((Object)(object)volumeCloudsConfig == (Object)null)
		{
			args.ReplyWith("Cloud config not found: " + name);
			return;
		}
		WeatherPreset weatherOverrides = SingletonComponent<Climate>.Instance.WeatherOverrides;
		weatherOverrides.VolumeCloudsConfigs = new VolumeCloudsConfig[1] { volumeCloudsConfig };
		int overrideCloudConfig = Array.IndexOf(SingletonComponent<Climate>.Instance.AllCloudConfigs, volumeCloudsConfig);
		weatherOverrides.OverrideCloudConfig = overrideCloudConfig;
		if (args.IsServerside)
		{
			ServerMgr.SendReplicatedVars("weather.");
		}
	}

	[ClientVar]
	[ServerVar]
	public static void list_cloud_configs(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			VolumeCloudsConfig[] allCloudConfigs = SingletonComponent<Climate>.Instance.AllCloudConfigs;
			StringBuilder stringBuilder = new StringBuilder();
			VolumeCloudsConfig[] array = allCloudConfigs;
			foreach (VolumeCloudsConfig volumeCloudsConfig in array)
			{
				stringBuilder.AppendLine(((Object)volumeCloudsConfig).name);
			}
			args.ReplyWith(stringBuilder.ToString());
		}
	}

	[ClientVar]
	[ServerVar]
	public static void reset_cloud_config(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			WeatherPreset weatherOverrides = SingletonComponent<Climate>.Instance.WeatherOverrides;
			weatherOverrides.VolumeCloudsConfigs = null;
			weatherOverrides.OverrideCloudConfig = -1;
			if (args.IsServerside)
			{
				ServerMgr.SendReplicatedVars("weather.");
			}
		}
	}

	[ServerVar]
	[ClientVar]
	public static void reset(Arg args)
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			SingletonComponent<Climate>.Instance.WeatherOverrides.Reset();
			SingletonComponent<Climate>.Instance.WeatherOverrides.VolumeCloudsConfigs = null;
			if (args.IsServerside)
			{
				ServerMgr.SendReplicatedVars("weather.");
			}
		}
	}

	[ClientVar]
	[ServerVar]
	public static void report(Arg args)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<Climate>.Instance))
		{
			return;
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStatePrevious).name);
			val.AddColumn("|");
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStateTarget).name);
			val.AddColumn("|");
			val.AddColumn(((Object)SingletonComponent<Climate>.Instance.WeatherStateNext).name);
			int num = Mathf.RoundToInt(SingletonComponent<Climate>.Instance.WeatherStateBlend * 100f);
			if (num < 100)
			{
				val.AddRow(new string[5]
				{
					"fading out (" + (100 - num) + "%)",
					"|",
					"fading in (" + num + "%)",
					"|",
					"up next"
				});
			}
			else
			{
				val.AddRow(new string[5] { "previous", "|", "current", "|", "up next" });
			}
			args.ReplyWith(((object)val).ToString() + Environment.NewLine + ((object)SingletonComponent<Climate>.Instance.WeatherState).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Facepunch;

[Factory("workshop")]
public class Workshop : ConsoleSystem
{
	[ServerVar]
	public static void print_approved_skins(Arg arg)
	{
		if (!PlatformService.Instance.IsValid || PlatformService.Instance.ItemDefinitions == null)
		{
			return;
		}
		bool flag = arg.HasArg("--json", false);
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.ShouldPadColumns = !flag;
			val.AddColumn("name");
			val.AddColumn("itemshortname");
			val.AddColumn("workshopid");
			val.AddColumn("workshopdownload");
			foreach (IPlayerItemDefinition itemDefinition in PlatformService.Instance.ItemDefinitions)
			{
				string name = itemDefinition.Name;
				string itemShortName = itemDefinition.ItemShortName;
				string text = itemDefinition.WorkshopId.ToString();
				string text2 = itemDefinition.WorkshopDownload.ToString();
				val.AddRow(new string[4] { name, itemShortName, text, text2 });
			}
			arg.ReplyWith(flag ? val.ToJson(true) : ((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using System.IO;
using Facepunch;
using UnityEngine;

[Factory("world")]
public class World : ConsoleSystem
{
	[ServerVar]
	[ClientVar]
	public static bool cache = true;

	[ClientVar]
	public static bool streaming = true;

	[ServerVar]
	public static string configString = string.Empty;

	[ServerVar]
	public static string configFile = string.Empty;

	[ServerVar]
	[ClientVar]
	public static void monuments(Arg arg)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			return;
		}
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumn("type");
			val.AddColumn("name");
			val.AddColumn("prefab");
			val.AddColumn("pos");
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				string[] obj = new string[4]
				{
					monument.Type.ToString(),
					monument.displayPhrase.translated,
					((Object)monument).name,
					null
				};
				Vector3 position = ((Component)monument).transform.position;
				obj[3] = ((object)(Vector3)(ref position)/*cast due to .constrained prefix*/).ToString();
				val.AddRow(obj);
			}
			arg.ReplyWith(((object)val).ToString());
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	[ServerVar(Clientside = true, Help = "Renders a high resolution PNG of the current map")]
	public static void rendermap(Arg arg)
	{
		float @float = arg.GetFloat(0, 1f);
		int imageWidth;
		int imageHeight;
		Color background;
		byte[] array = MapImageRenderer.Render(out imageWidth, out imageHeight, out background, @float, lossy: false);
		if (array == null)
		{
			arg.ReplyWith("Failed to render the map (is a map loaded now?)");
			return;
		}
		string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, $"map_{World.Size}_{World.Seed}.png"));
		File.WriteAllBytes(fullPath, array);
		arg.ReplyWith("Saved map render to: " + fullPath);
	}

	[ServerVar(Clientside = true, Help = "Renders a PNG of the current map's tunnel network")]
	public static void rendertunnels(Arg arg)
	{
		RenderMapLayerToFile(arg, "tunnels", MapLayer.TrainTunnels);
	}

	[ServerVar(Clientside = true, Help = "Renders a PNG of the current map's underwater labs, for a specific floor")]
	public static void renderlabs(Arg arg)
	{
		int underwaterLabFloorCount = MapLayerRenderer.GetOrCreate().GetUnderwaterLabFloorCount();
		int @int = arg.GetInt(0, 0);
		if (@int < 0 || @int >= underwaterLabFloorCount)
		{
			arg.ReplyWith($"Floor number must be between 0 and {underwaterLabFloorCount}");
		}
		else
		{
			RenderMapLayerToFile(arg, $"labs_{@int}", (MapLayer)(1 + @int));
		}
	}

	private static void RenderMapLayerToFile(Arg arg, string name, MapLayer layer)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Expected O, but got Unknown
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			MapLayerRenderer orCreate = MapLayerRenderer.GetOrCreate();
			orCreate.Render(layer);
			string fullPath = Path.GetFullPath(Path.Combine(Environment.CurrentDirectory, $"{name}_{World.Size}_{World.Seed}.png"));
			RenderTexture targetTexture = orCreate.renderCamera.targetTexture;
			Texture2D val = new Texture2D(((Texture)targetTexture).width, ((Texture)targetTexture).height);
			RenderTexture active = RenderTexture.active;
			try
			{
				RenderTexture.active = targetTexture;
				val.ReadPixels(new Rect(0f, 0f, (float)((Texture)targetTexture).width, (float)((Texture)targetTexture).height), 0, 0);
				val.Apply();
				File.WriteAllBytes(fullPath, ImageConversion.EncodeToPNG(val));
			}
			finally
			{
				RenderTexture.active = active;
				Object.DestroyImmediate((Object)(object)val);
			}
			arg.ReplyWith("Saved " + name + " render to: " + fullPath);
		}
		catch (Exception ex)
		{
			Debug.LogWarning((object)ex);
			arg.ReplyWith("Failed to render " + name);
		}
	}
}


using UnityEngine;

[Factory("xmas")]
public class XMas : ConsoleSystem
{
	private const string path = "assets/prefabs/misc/xmas/xmasrefill.prefab";

	[ServerVar]
	public static bool enabled = false;

	[ServerVar]
	public static float spawnRange = 40f;

	[ServerVar]
	public static int spawnAttempts = 5;

	[ServerVar]
	public static int giftsPerPlayer = 2;

	[ServerVar]
	public static void refill(Arg arg)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity("assets/prefabs/misc/xmas/xmasrefill.prefab");
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.Spawn();
		}
	}
}


using ConVar.Misc;
using UnityEngine;

public class NoBuildZoneMaterialController : SingletonComponent<NoBuildZoneMaterialController>
{
	[SerializeField]
	private Material noBuildZoneMaterial;

	private static readonly int DistanceWarningStrength = Shader.PropertyToID("_DistanceWarningStrength");

	private static readonly int DistanceWarningStrengthNight = Shader.PropertyToID("_DistanceWarningStrengthNight");

	private static readonly int DistanceWarningMinHeight = Shader.PropertyToID("_DistanceWarningMinHeight");

	[ClientVar(ClientAdmin = true, Help = "[0.0-1.0]")]
	public static void SetStrengthDay(Arg arg)
	{
		float @float = SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.GetFloat(DistanceWarningStrength);
		float float2 = arg.GetFloat(0, @float);
		SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.SetFloat(DistanceWarningStrength, float2);
	}

	[ClientVar(ClientAdmin = true, Help = "[0.0-1.0]")]
	public static void SetStrengthNight(Arg arg)
	{
		float @float = SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.GetFloat(DistanceWarningStrengthNight);
		float float2 = arg.GetFloat(0, @float);
		SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.SetFloat(DistanceWarningStrengthNight, float2);
	}

	[ClientVar(ClientAdmin = true, Help = "[0.0-10]")]
	public static void SetHeight(Arg arg)
	{
		float @float = SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.GetFloat(DistanceWarningMinHeight);
		float float2 = arg.GetFloat(0, @float);
		SingletonComponent<NoBuildZoneMaterialController>.Instance.noBuildZoneMaterial.SetFloat(DistanceWarningMinHeight, float2);
	}
}


public static class PlayerMenuAnimation
{
	public enum Layers
	{
		Movement
	}

	public static class Groups
	{
	}
}


public enum Layers
{
	Movement
}


public static class Groups
{
}


public static class Numlock
{
	public static bool IsOn => true;

	public static void TurnOn()
	{
	}
}


using System;
using UnityEngine;

public class GC : MonoBehaviour, IClientComponent
{
	public static int gcLowerBounds = 64;

	public static int gcDefaultValue = 256;

	public static int gcEditorDefaultValue = 4096;

	public static bool Enabled => true;

	public static void Collect()
	{
		GC.Collect();
	}

	public static int GetSafeGCValue(int val)
	{
		return Mathf.Clamp(val, gcLowerBounds, Mathf.Min(4096, SystemInfo.systemMemorySize / 8));
	}

	public static long GetTotalMemory()
	{
		return GC.GetTotalMemory(forceFullCollection: false) / 1048576;
	}

	public static int CollectionCount()
	{
		return GC.CollectionCount(0);
	}
}


public enum DamageType
{
	Generic,
	Hunger,
	Thirst,
	Cold,
	Drowned,
	Heat,
	Bleeding,
	Poison,
	Suicide,
	Bullet,
	Slash,
	Blunt,
	Fall,
	Radiation,
	Bite,
	Stab,
	Explosion,
	RadiationExposure,
	ColdExposure,
	Decay,
	ElectricShock,
	Arrow,
	AntiVehicle,
	Collision,
	Fun_Water,
	BeeSting,
	LAST
}


using System.Collections.Generic;
using Rust;

public class DamageTypeList
{
	public float[] types = new float[26];

	public void Set(DamageType index, float amount)
	{
		types[(int)index] = amount;
	}

	public float Get(DamageType index)
	{
		return types[(int)index];
	}

	public void Add(DamageType index, float amount)
	{
		Set(index, Get(index) + amount);
	}

	public void Scale(DamageType index, float amount)
	{
		Set(index, Get(index) * amount);
	}

	public bool Has(DamageType index)
	{
		return Get(index) > 0f;
	}

	public float Total()
	{
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2))
			{
				num += num2;
			}
		}
		return num;
	}

	public void Clear()
	{
		for (int i = 0; i < types.Length; i++)
		{
			types[i] = 0f;
		}
	}

	public void Add(List<DamageTypeEntry> entries)
	{
		foreach (DamageTypeEntry entry in entries)
		{
			Add(entry.type, entry.amount);
		}
	}

	public void ScaleAll(float amount)
	{
		for (int i = 0; i < types.Length; i++)
		{
			Scale((DamageType)i, amount);
		}
	}

	public DamageType GetMajorityDamageType()
	{
		int result = 0;
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2) && !(num2 < num))
			{
				result = i;
				num = num2;
			}
		}
		return (DamageType)result;
	}

	public bool Contains(DamageType damage)
	{
		if (damage < DamageType.Generic || (int)damage >= types.Length)
		{
			return false;
		}
		float num = types[(int)damage];
		if (!float.IsNaN(num) && !float.IsInfinity(num))
		{
			return num > 0f;
		}
		return false;
	}

	public bool IsMeleeType()
	{
		return GetMajorityDamageType().IsMeleeType();
	}

	public bool IsBleedCausing()
	{
		return GetMajorityDamageType().IsBleedCausing();
	}

	public bool IsConsideredAnAttack()
	{
		return GetMajorityDamageType().IsConsideredAnAttack();
	}

	public DamageTypeList Clone()
	{
		DamageTypeList damageTypeList = new DamageTypeList();
		for (int i = 0; i < types.Length; i++)
		{
			damageTypeList.types[i] = types[i];
		}
		return damageTypeList;
	}
}


using System;
using Rust;

[Serializable]
public class DamageTypeEntry
{
	public DamageType type;

	public float amount;
}


using Rust;

public static class DamageTypeEx
{
	public static bool IsMeleeType(this DamageType damageType)
	{
		if (damageType != DamageType.Blunt && damageType != DamageType.Slash)
		{
			return damageType == DamageType.Stab;
		}
		return true;
	}

	public static bool IsBleedCausing(this DamageType damageType)
	{
		if (damageType != DamageType.Bite && damageType != DamageType.Slash && damageType != DamageType.Stab && damageType != DamageType.Bullet)
		{
			return damageType == DamageType.Arrow;
		}
		return true;
	}

	public static bool IsConsideredAnAttack(this DamageType damageType)
	{
		if (damageType != DamageType.Decay)
		{
			return damageType != DamageType.Collision;
		}
		return false;
	}

	public static bool InterruptsRestraintMinigame(this DamageType damageType)
	{
		if (damageType != DamageType.Fall && damageType != DamageType.Blunt && damageType != DamageType.Slash && damageType != DamageType.Stab && damageType != DamageType.Bullet && damageType != DamageType.Explosion)
		{
			return damageType == DamageType.Arrow;
		}
		return true;
	}
}


using ConVar;
using UnityEngine;

internal static class GameInfo
{
	internal static bool IsOfficialServer
	{
		get
		{
			if (Application.isEditor)
			{
				return true;
			}
			return Server.official;
		}
	}

	internal static bool HasAchievements => IsOfficialServer;
}


public static class Defines
{
	public static class Connection
	{
		public const byte mode_steam = 228;
	}

	public static class Tags
	{
		public const string NotPlayerUsable = "Not Player Usable";
	}

	public static uint appID = 252490u;

	public const string resourceFolder = "assets/bundled";
}


public static class Connection
{
	public const byte mode_steam = 228;
}


public static class Tags
{
	public const string NotPlayerUsable = "Not Player Usable";
}


using UnityEngine.SceneManagement;

public static class Generic
{
	private static Scene _batchingScene;

	public static Scene BatchingScene
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!((Scene)(ref _batchingScene)).IsValid())
			{
				_batchingScene = SceneManager.CreateScene("Batching");
			}
			return _batchingScene;
		}
	}
}


using UnityEngine.SceneManagement;

public static class Server
{
	public const float UseDistance = 3f;

	private static Scene _entityScene;

	public static Scene EntityScene
	{
		get
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			if (!((Scene)(ref _entityScene)).IsValid())
			{
				_entityScene = SceneManager.CreateScene("Server Entities");
			}
			return _entityScene;
		}
	}
}


using Facepunch;
using ProtoBuf.Nexus;

public interface INexusRequestHandler : IPooled
{
	Response Response { get; }

	void Execute();
}


using System;
using Facepunch;
using Facepunch.Nexus;
using Facepunch.Nexus.Models;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public abstract class BaseNexusRequestHandler<T> : INexusRequestHandler, IPooled where T : class
{
	private bool _fireAndForget;

	protected NexusZoneDetails FromZone { get; private set; }

	protected Uuid RequestId { get; private set; }

	protected T Request { get; private set; }

	public Response Response { get; private set; }

	public void Initialize(NexusZoneDetails fromZone, Uuid id, bool fireAndForget, T request)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		FromZone = fromZone;
		RequestId = id;
		Request = request;
		_fireAndForget = fireAndForget;
	}

	public void EnterPool()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		FromZone = null;
		RequestId = Uuid.Empty;
		Request = null;
		Response = null;
		_fireAndForget = false;
		Reset();
	}

	public void LeavePool()
	{
	}

	public void Execute()
	{
		try
		{
			Handle();
			if (Response == null)
			{
				SendSuccess();
			}
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			if (Response != null)
			{
				Debug.LogError((object)"Nexus RPC handler threw an exception but already sent a response!");
			}
			else
			{
				SendError(ex.Message);
			}
		}
	}

	protected abstract void Handle();

	protected virtual void Reset()
	{
	}

	protected void SendSuccess()
	{
		SendResult(success: true);
	}

	protected void SendSuccess(Response response)
	{
		SendResult(success: true, response);
	}

	protected void SendResult(bool success)
	{
		SendResult(success, NewResponse());
	}

	protected void SendResult(bool success, Response response)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_fireAndForget)
		{
			response.Dispose();
			return;
		}
		if (Response != null)
		{
			response.Dispose();
			throw new InvalidOperationException("Already sent a response for this nexus RPC invocation!");
		}
		response.id = RequestId;
		response.status = Pool.Get<Status>();
		response.status.success = success;
		Response = response;
	}

	protected void SendError(string message)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!_fireAndForget)
		{
			if (Response != null)
			{
				throw new InvalidOperationException("Already sent a response for this nexus RPC invocation!");
			}
			Response val = Pool.Get<Response>();
			val.id = RequestId;
			val.status = Pool.Get<Status>();
			val.status.success = false;
			val.status.errorMessage = message;
			Response = val;
		}
	}

	protected static Response NewResponse()
	{
		return Pool.Get<Response>();
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class ClanChatBatchHandler : BaseNexusRequestHandler<ClanChatBatchRequest>
{
	protected override void Handle()
	{
		if (!(ClanManager.ServerInstance.Backend is NexusClanBackend nexusClanBackend))
		{
			Debug.LogError((object)"Received a clan chat batch but this server isn't using the nexus clan backend!");
		}
		else
		{
			nexusClanBackend.HandleClanChatBatch(base.Request);
		}
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class DestroyBagHandler : BaseNexusRequestHandler<SleepingBagDestroyRequest>
{
	protected override void Handle()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		SleepingBag.DestroyBag(base.Request.userId, base.Request.sleepingBagId);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryRetireHandler : BaseNexusRequestHandler<FerryRetireRequest>
{
	protected override void Handle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NexusFerry nexusFerry = NexusFerry.Get(base.Request.entityId, base.Request.timestamp);
		if ((Object)(object)nexusFerry != (Object)null)
		{
			nexusFerry.Retire();
		}
		SendSuccess();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryStatusHandler : BaseNexusRequestHandler<FerryStatusRequest>
{
	protected override void Handle()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		FerryStatusResponse val = Pool.Get<FerryStatusResponse>();
		val.statuses = Pool.Get<List<FerryStatus>>();
		Enumerator<NexusFerry> enumerator = NexusFerry.All.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				NexusFerry current = enumerator.Current;
				if (!((Object)(object)current == (Object)null))
				{
					FerryStatus status = current.GetStatus();
					val.statuses.Add(status);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Response val2 = Pool.Get<Response>();
		val2.ferryStatus = val;
		SendSuccess(val2);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class FerryUpdateScheduleHandler : BaseNexusRequestHandler<FerryUpdateScheduleRequest>
{
	protected override void Handle()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		NexusFerry nexusFerry = NexusFerry.Get(base.Request.entityId, base.Request.timestamp);
		if ((Object)(object)nexusFerry != (Object)null)
		{
			nexusFerry.UpdateSchedule(base.Request.schedule);
		}
		SendSuccess();
	}
}


using ConVar;
using Facepunch;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class PingHandler : BaseNexusRequestHandler<PingRequest>
{
	protected override void Handle()
	{
		Response val = BaseNexusRequestHandler<PingRequest>.NewResponse();
		val.ping = Pool.Get<PingResponse>();
		val.ping.players = BasePlayer.activePlayerList.Count;
		val.ping.maxPlayers = Server.maxplayers;
		val.ping.queuedPlayers = SingletonComponent<ServerMgr>.Instance.connectionQueue.Queued;
		SendSuccess(val);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class PlayerManifestHandler : BaseNexusRequestHandler<PlayerManifestRequest>
{
	protected override void Handle()
	{
		NexusServer.AddZonePlayerManifest(base.FromZone.Key, base.Request.userIds);
	}
}


using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;
using UnityEngine;

public class RespawnAtBagHandler : BaseNexusRequestHandler<SleepingBagRespawnRequest>
{
	protected override void Handle()
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = BasePlayer.FindByID(base.Request.userId) ?? BasePlayer.FindSleeping(base.Request.userId);
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsConnected)
			{
				basePlayer.Kick("You're apparently respawning from a another zone - contact developers!");
			}
			basePlayer.Kill();
		}
		BasePlayer basePlayer2 = SingletonComponent<ServerMgr>.Instance.SpawnNewPlayer(null);
		basePlayer2.userID = base.Request.userId;
		basePlayer2.UserIDString = base.Request.userId.ToString();
		basePlayer2.displayName = basePlayer2.UserIDString;
		basePlayer2.SetPlayerFlag(BasePlayer.PlayerFlags.LoadingAfterTransfer, b: true);
		if (!SleepingBag.TrySpawnPlayer(basePlayer2, base.Request.sleepingBagId, out var errorMessage))
		{
			basePlayer2.Kill();
			SendError(errorMessage);
		}
		if (basePlayer2.isMounted)
		{
			basePlayer2.DisableTransferProtection();
		}
		else if (!basePlayer2.isMounted)
		{
			basePlayer2.SetPlayerFlag(BasePlayer.PlayerFlags.LoadingAfterTransfer, b: false);
		}
		basePlayer2.LoadSecondaryData(base.Request.secondaryData);
		basePlayer2.LoadClanInfo();
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust.Nexus.Handlers;

public class SpawnOptionsHandler : BaseNexusRequestHandler<SpawnOptionsRequest>
{
	protected override void Handle()
	{
		Response val = BaseNexusRequestHandler<SpawnOptionsRequest>.NewResponse();
		val.spawnOptions = Pool.Get<SpawnOptionsResponse>();
		val.spawnOptions.spawnOptions = Pool.Get<List<SpawnOptions>>();
		BasePlayer.GetRespawnOptionsForPlayer(val.spawnOptions.spawnOptions, base.Request.userId);
		SendSuccess(val);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Network;
using ProtoBuf;
using ProtoBuf.Nexus;
using Rust;
using Rust.Nexus.Handlers;
using UnityEngine;

public class TransferHandler : BaseNexusRequestHandler<TransferRequest>
{
	private static readonly Dictionary<ulong, ulong> UidMapping = new Dictionary<ulong, ulong>();

	private static readonly Dictionary<NetworkableId, Entity> UidToEntity = new Dictionary<NetworkableId, Entity>();

	private static readonly Dictionary<BaseEntity, Entity> EntityToSpawn = new Dictionary<BaseEntity, Entity>();

	private static readonly Dictionary<ulong, BasePlayer> SpawnedPlayers = new Dictionary<ulong, BasePlayer>();

	private static readonly List<string> PlayerIds = new List<string>();

	private static readonly List<NetworkableId> EntitiesToProtect = new List<NetworkableId>();

	private static readonly Dictionary<ulong, RelationshipManager.PlayerTeam> TeamMapping = new Dictionary<ulong, RelationshipManager.PlayerTeam>();

	protected override void Handle()
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		UidMapping.Clear();
		base.Request.InspectUids((UidInspector<ulong>)UpdateWithNewUid);
		UidToEntity.Clear();
		PlayerIds.Clear();
		EntitiesToProtect.Clear();
		foreach (Entity entity in base.Request.entities)
		{
			UidToEntity.Add(entity.baseNetworkable.uid, entity);
			if (entity.basePlayer != null)
			{
				ulong userid = entity.basePlayer.userid;
				PlayerIds.Add(userid.ToString("G"));
				BasePlayer basePlayer = BasePlayer.FindByID(userid) ?? BasePlayer.FindSleeping(userid);
				if ((Object)(object)basePlayer != (Object)null)
				{
					if (basePlayer.IsConnected)
					{
						basePlayer.Kick("Player transfer is overwriting you - contact developers!");
					}
					basePlayer.Kill();
				}
				entity.basePlayer.currentTeam = 0uL;
				RelationshipManager.ServerInstance.FindPlayersTeam(userid)?.RemovePlayer(userid);
				if ((entity.basePlayer.playerFlags & 0x10) == 0)
				{
					BasePlayer basePlayer2 = entity.basePlayer;
					basePlayer2.playerFlags |= 0x2000000;
				}
				if (entity.basePlayer.loadingTimeout <= 0f || entity.basePlayer.loadingTimeout > Nexus.loadingTimeout)
				{
					entity.basePlayer.loadingTimeout = Nexus.loadingTimeout;
				}
			}
			if (entity.baseCombat != null && entity.baseNetworkable != null)
			{
				EntitiesToProtect.Add(entity.baseNetworkable.uid);
			}
		}
		RepositionEntitiesFromTransfer();
		SpawnedPlayers.Clear();
		SpawnEntities(SpawnedPlayers);
		foreach (NetworkableId item in EntitiesToProtect)
		{
			if (BaseNetworkable.serverEntities.Find(item) is BaseEntity baseEntity)
			{
				baseEntity.EnableTransferProtection();
			}
		}
		TeamMapping.Clear();
		foreach (PlayerSecondaryData secondaryDatum in base.Request.secondaryData)
		{
			if (!SpawnedPlayers.TryGetValue(secondaryDatum.userId, out var value))
			{
				Debug.LogError((object)$"Got secondary data for {secondaryDatum.userId} but they were not spawned in the transfer");
				continue;
			}
			value.LoadSecondaryData(secondaryDatum);
			if (secondaryDatum.isTeamLeader && secondaryDatum.teamId != 0L && !TeamMapping.ContainsKey(secondaryDatum.teamId))
			{
				RelationshipManager.PlayerTeam playerTeam = RelationshipManager.ServerInstance.CreateTeam();
				playerTeam.teamLeader = value.userID;
				playerTeam.AddPlayer(value);
				TeamMapping.Add(secondaryDatum.teamId, playerTeam);
			}
		}
		foreach (PlayerSecondaryData secondaryDatum2 in base.Request.secondaryData)
		{
			if (SpawnedPlayers.TryGetValue(secondaryDatum2.userId, out var value2) && secondaryDatum2.teamId != 0L && !secondaryDatum2.isTeamLeader)
			{
				if (TeamMapping.TryGetValue(secondaryDatum2.teamId, out var value3))
				{
					value3.AddPlayer(value2);
					continue;
				}
				RelationshipManager.PlayerTeam playerTeam2 = RelationshipManager.ServerInstance.CreateTeam();
				playerTeam2.teamLeader = value2.userID;
				playerTeam2.AddPlayer(value2);
				TeamMapping.Add(secondaryDatum2.teamId, playerTeam2);
			}
		}
		if (PlayerIds.Count > 0)
		{
			CompleteTransfers();
		}
		static void UpdateWithNewUid(UidType type, ref ulong prevUid)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Invalid comparison between Unknown and I4
			if ((int)type == 3)
			{
				prevUid = 0uL;
			}
			else if (prevUid != 0L)
			{
				if (!UidMapping.TryGetValue(prevUid, out var value4))
				{
					value4 = Net.sv.TakeUID();
					UidMapping.Add(prevUid, value4);
				}
				prevUid = value4;
			}
		}
	}

	private static async void CompleteTransfers()
	{
		try
		{
			await NexusServer.ZoneClient.CompleteTransfers((IEnumerable<string>)PlayerIds);
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
		}
	}

	private void RepositionEntitiesFromTransfer()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		Entity obj = base.Request.entities[0];
		Vector3 pos = obj.baseEntity.pos;
		Quaternion val = Quaternion.Euler(obj.baseEntity.rot);
		(Vector3 Position, Quaternion Rotation, bool PreserveY) tuple = ZoneController.Instance.ChooseTransferDestination(base.FromZone.Key, base.Request.method, base.Request.from, base.Request.to, pos, val);
		var (val2, val3, _) = tuple;
		if (tuple.PreserveY)
		{
			val2.y = pos.y;
		}
		Vector3 val4 = val2 - pos;
		Quaternion val5 = Quaternion.Inverse(val) * val3;
		foreach (Entity entity in base.Request.entities)
		{
			if (entity.baseEntity == null)
			{
				continue;
			}
			if (entity.parent != null && ((NetworkableId)(ref entity.parent.uid)).IsValid)
			{
				if (!UidToEntity.TryGetValue(entity.parent.uid, out var _))
				{
					Debug.LogError((object)$"Transferred entity (ID={entity.baseNetworkable.uid}) has a parent set but it wasn't found in the transfer! The parent is required to correctly restore this entity's position!");
				}
				if (((Vector3)(ref entity.baseEntity.pos)).magnitude > 100f)
				{
					Debug.LogError((object)$"Transferred entity (ID={entity.baseNetworkable.uid}) has a valid parent (ID={entity.parent.uid}) but its position ({entity.baseEntity.pos}) doesn't seem to be in local space! This will probably not work properly!");
				}
			}
			else
			{
				BaseEntity baseEntity = entity.baseEntity;
				baseEntity.pos += val4;
				BaseEntity baseEntity2 = entity.baseEntity;
				Quaternion val6 = Quaternion.Euler(entity.baseEntity.rot) * val5;
				baseEntity2.rot = ((Quaternion)(ref val6)).eulerAngles;
			}
		}
	}

	private void SpawnEntities(Dictionary<ulong, BasePlayer> players)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		Application.isLoadingSave = true;
		try
		{
			EntityToSpawn.Clear();
			foreach (Entity entity in base.Request.entities)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(StringPool.Get(entity.baseNetworkable.prefabID), entity.baseEntity.pos, Quaternion.Euler(entity.baseEntity.rot));
				if ((Object)(object)baseEntity != (Object)null)
				{
					baseEntity.InitLoad(entity.baseNetworkable.uid);
					baseEntity.PreServerLoad();
					EntityToSpawn.Add(baseEntity, entity);
				}
			}
			foreach (KeyValuePair<BaseEntity, Entity> item in EntityToSpawn)
			{
				BaseEntity key = item.Key;
				if (!((Object)(object)key == (Object)null))
				{
					key.Spawn();
					key.Load(new BaseNetworkable.LoadInfo
					{
						fromDisk = true,
						fromTransfer = true,
						msg = item.Value
					});
				}
			}
			foreach (KeyValuePair<BaseEntity, Entity> item2 in EntityToSpawn)
			{
				BaseEntity key2 = item2.Key;
				if (!((Object)(object)key2 == (Object)null))
				{
					key2.UpdateNetworkGroup();
					key2.PostServerLoad();
					if (key2 is BasePlayer basePlayer)
					{
						players[basePlayer.userID] = basePlayer;
					}
				}
			}
		}
		finally
		{
			Application.isLoadingSave = false;
		}
	}
}


using Rust.Rendering.IndirectInstancing;
using UnityEngine;

[DefaultExecutionOrder(-1)]
public class IndirectInstancingCamera : SingletonComponent<IndirectInstancingCamera>
{
	public Shader[] supportedShaders;
}


public static class IntEx
{
}


public abstract class InstancedLODComponent : LODComponent
{
}


using System.Runtime.InteropServices;
using UnityEngine;

internal struct PerInstanceData
{
	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct Property
	{
		public static readonly int _ObjectToWorld = Shader.PropertyToID("_ObjectToWorld");

		public static readonly int _TextureIndex = Shader.PropertyToID("_TextureIndex");

		public static readonly int _Color = Shader.PropertyToID("_Color");

		public static readonly int _DetailColor = Shader.PropertyToID("_DetailColor");

		public static readonly int _DetailAlbedoMap_ST = Shader.PropertyToID("_DetailAlbedoMap_ST");

		public static readonly int _EmissionColor = Shader.PropertyToID("_EmissionColor");
	}

	public int ReorderOffset;

	public Matrix4x4 _ObjectToWorld;

	public int _TextureIndex;

	public Color _Color;

	public Color _DetailColor;

	public Vector4 _DetailAlbedoMap_ST;

	public Color _EmissionColor;

	public float MinDistance;

	public float MaxDistance;
}


using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct Property
{
	public static readonly int _ObjectToWorld = Shader.PropertyToID("_ObjectToWorld");

	public static readonly int _TextureIndex = Shader.PropertyToID("_TextureIndex");

	public static readonly int _Color = Shader.PropertyToID("_Color");

	public static readonly int _DetailColor = Shader.PropertyToID("_DetailColor");

	public static readonly int _DetailAlbedoMap_ST = Shader.PropertyToID("_DetailAlbedoMap_ST");

	public static readonly int _EmissionColor = Shader.PropertyToID("_EmissionColor");
}


using Rust.Rendering.IndirectInstancing;
using UnityEngine;
using UnityEngine.Assertions;

internal struct Frustum
{
	public Plane left;

	public Plane right;

	public Plane down;

	public Plane up;

	public Plane near;

	public Plane far;

	public Frustum(Plane[] planes)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		Assert.AreEqual(planes.Length, 6);
		left = planes[0];
		right = planes[1];
		down = planes[2];
		up = planes[3];
		near = planes[4];
		far = planes[5];
	}

	public static implicit operator Frustum(Plane[] planes)
	{
		return new Frustum(planes);
	}
}


using Rust.Rendering.IndirectInstancing;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Assertions;

internal struct TerrainRef
{
	public ReadOnly<short> data;

	public Vector3 pos;

	public Vector3 size;

	public Vector3 one_over_size;

	public int res;

	public static TerrainRef FromCurrent()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsNotNull<TerrainHeightMap>(TerrainMeta.HeightMap, "Cannot create TerrainRef because there is no terrain!");
		TerrainRef result = default(TerrainRef);
		result.data = TerrainMeta.HeightMap.src.AsReadOnly();
		result.pos = TerrainMeta.Position;
		result.size = TerrainMeta.Size;
		result.one_over_size = TerrainMeta.OneOverSize;
		result.res = TerrainMeta.HeightMap.res;
		return result;
	}
}


using Rust.Water5;
using Unity.Mathematics;
using UnityEngine;

public struct OceanDisplacementShort3
{
	private const float precision = 20f;

	private const float float2short = 32766f;

	private const float short2float = 3.051944E-05f;

	public short x;

	public short y;

	public short z;

	public static implicit operator Vector3(OceanDisplacementShort3 v)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result = default(Vector3);
		result.x = 3.051944E-05f * (float)v.x * 20f;
		result.y = 3.051944E-05f * (float)v.y * 20f;
		result.z = 3.051944E-05f * (float)v.z * 20f;
		return result;
	}

	public static implicit operator OceanDisplacementShort3(Vector3 v)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		OceanDisplacementShort3 result = default(OceanDisplacementShort3);
		result.x = (short)(v.x / 20f * 32766f + 0.5f);
		result.y = (short)(v.y / 20f * 32766f + 0.5f);
		result.z = (short)(v.z / 20f * 32766f + 0.5f);
		return result;
	}

	public static implicit operator OceanDisplacementShort3(float3 v)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		OceanDisplacementShort3 result = default(OceanDisplacementShort3);
		result.x = (short)(v.x / 20f * 32766f + 0.5f);
		result.y = (short)(v.y / 20f * 32766f + 0.5f);
		result.z = (short)(v.z / 20f * 32766f + 0.5f);
		return result;
	}

	public static implicit operator float3(OceanDisplacementShort3 v)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		float3 result = default(float3);
		result.x = 3.051944E-05f * (float)v.x * 20f;
		result.y = 3.051944E-05f * (float)v.y * 20f;
		result.z = 3.051944E-05f * (float)v.z * 20f;
		return result;
	}
}


using System;
using Rust.Water5;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

internal struct NativeOceanDisplacementShort3 : IDisposable
{
	private NativeArray<OceanDisplacementShort3> _arr;

	private int spectrumCount;

	private int frameCount;

	public OceanDisplacementShort3 this[int x, int y, int z]
	{
		get
		{
			return _arr[z * spectrumCount * frameCount + y * spectrumCount + x];
		}
		set
		{
			_arr[z * spectrumCount * frameCount + y * spectrumCount + x] = value;
		}
	}

	public int Length => _arr.Length;

	public static NativeOceanDisplacementShort3 Create(int x, int y, int z)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		NativeOceanDisplacementShort3 result = default(NativeOceanDisplacementShort3);
		result._arr = new NativeArray<OceanDisplacementShort3>(x * y * z, (Allocator)4, (NativeArrayOptions)0);
		result.spectrumCount = x;
		result.frameCount = y;
		return result;
	}

	public static NativeOceanDisplacementShort3 Create(OceanDisplacementShort3[,,] simData)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		NativeOceanDisplacementShort3 result = default(NativeOceanDisplacementShort3);
		result._arr = new NativeArray<OceanDisplacementShort3>(simData.Length, (Allocator)4, (NativeArrayOptions)1);
		result.spectrumCount = simData.GetLength(0);
		result.frameCount = simData.GetLength(1);
		for (int i = 0; i < result.spectrumCount; i++)
		{
			for (int j = 0; j < result.frameCount; j++)
			{
				for (int k = 0; k < simData.GetLength(2); k++)
				{
					result._arr[i * result.spectrumCount + j * result.frameCount + k] = simData[i, j, k];
				}
			}
		}
		return result;
	}

	public unsafe OceanDisplacementShort3* GetUnsafePtr()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		if (!_arr.IsCreated)
		{
			return null;
		}
		return (OceanDisplacementShort3*)NativeArrayUnsafeUtility.GetUnsafePtr<OceanDisplacementShort3>(_arr);
	}

	public ReadOnly<OceanDisplacementShort3> GetNativeRawReadOnly()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return _arr.AsReadOnly();
	}

	public NativeArray<OceanDisplacementShort3> GetNativeRaw()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _arr;
	}

	public void Dispose()
	{
		_arr.Dispose();
	}
}


using System;
using System.Runtime.CompilerServices;
using OceanSimulationJobs;
using Rust.Water5;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Assertions;

public class OceanSimulation : IDisposable
{
	public const int octaveCount = 3;

	public const int simulationSize = 256;

	public const int physicsSimulationSize = 256;

	public const int physicsFrameRate = 4;

	public const int physicsLooptime = 18;

	public const int physicsFrameCount = 72;

	public const float phsyicsDeltaTime = 0.25f;

	public const float oneOverPhysicsSimulationSize = 0.00390625f;

	public const int physicsFrameSize = 65536;

	public const int physicsSpectrumOffset = 4718592;

	private OceanSettings oceanSettings;

	private float[] spectrumRanges;

	private float distanceAttenuationFactor;

	private float depthAttenuationFactor;

	private static float oneOverOctave0Scale;

	private static float[] beaufortValues;

	private int spectrum0;

	private int spectrum1;

	private float spectrumBlend;

	private int frame0;

	private int frame1;

	private float frameBlend;

	private float currentTime;

	private float prevUpdateComputeTime;

	private float deltaTime;

	private NativeOceanDisplacementShort3 nativeSimData;

	private GetHeightBatchedJob _cachedBatchJob;

	private GetHeightsJobIndirect _heightsJobIndirect;

	private NativeArray<float3> _batchPositionQueryArr;

	public int Spectrum0 => spectrum0;

	public int Spectrum1 => spectrum1;

	public float SpectrumBlend => spectrumBlend;

	public int Frame0 => frame0;

	public int Frame1 => frame1;

	public float FrameBlend => frameBlend;

	public OceanSimulation(OceanSettings oceanSettings)
	{
		this.oceanSettings = oceanSettings;
		oneOverOctave0Scale = 1f / oceanSettings.octaveScales[0];
		beaufortValues = new float[oceanSettings.spectrumSettings.Length];
		for (int i = 0; i < oceanSettings.spectrumSettings.Length; i++)
		{
			beaufortValues[i] = oceanSettings.spectrumSettings[i].beaufort;
		}
		nativeSimData = oceanSettings.LoadNativeSimData();
		spectrumRanges = oceanSettings.spectrumRanges;
		depthAttenuationFactor = oceanSettings.depthAttenuationFactor;
		distanceAttenuationFactor = oceanSettings.distanceAttenuationFactor;
		_cachedBatchJob = new GetHeightBatchedJob
		{
			SimData = nativeSimData
		};
		_heightsJobIndirect = new GetHeightsJobIndirect
		{
			SimData = nativeSimData
		};
	}

	public void Update(float time, float dt, float beaufort)
	{
		currentTime = time % 18f;
		deltaTime = dt;
		FindFrames(currentTime, out frame0, out frame1, out frameBlend);
		FindSpectra(beaufort, out spectrum0, out spectrum1, out spectrumBlend);
	}

	private static void FindSpectra(float beaufort, out int spectrum0, out int spectrum1, out float spectrumT)
	{
		beaufort = Mathf.Clamp(beaufort, 0f, 10f);
		spectrum0 = (spectrum1 = 0);
		spectrumT = 0f;
		for (int i = 1; i < beaufortValues.Length; i++)
		{
			float num = beaufortValues[i - 1];
			float num2 = beaufortValues[i];
			if (beaufort >= num && beaufort <= num2)
			{
				spectrum0 = i - 1;
				spectrum1 = i;
				spectrumT = math.remap(num, num2, 0f, 1f, beaufort);
				break;
			}
		}
	}

	public static void FindFrames(float time, out int frame0, out int frame1, out float frameBlend)
	{
		frame0 = (int)math.floor(time * 4f);
		frame1 = (int)math.floor(time * 4f);
		frame1 = (frame1 + 1) % 72;
		frameBlend = math.remap((float)frame0 * 0.25f, (float)(frame0 + 1) * 0.25f, 0f, 1f, time);
	}

	public JobHandle TraceBatch(NativeList<Ray> rays, NativeArray<float> maxDists, NativeArray<bool> hitResults, NativeArray<Vector3> hitPositions, JobHandle inputDeps)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
		if (num <= 0.1f)
		{
			SmallDisplacementPlaneTraceJob smallDisplacementPlaneTraceJob = default(SmallDisplacementPlaneTraceJob);
			smallDisplacementPlaneTraceJob.SeaPlane = new Plane(Vector3.up, -0f);
			smallDisplacementPlaneTraceJob.Rays = rays;
			smallDisplacementPlaneTraceJob.MaxDists = maxDists.AsReadOnly();
			smallDisplacementPlaneTraceJob.HitResults = hitResults;
			smallDisplacementPlaneTraceJob.HitPositions = hitPositions;
			inputDeps = IJobParallelForDeferExtensions.Schedule<SmallDisplacementPlaneTraceJob, Ray>(smallDisplacementPlaneTraceJob, rays, 256, inputDeps);
			return inputDeps;
		}
		OceanTraceJob oceanTraceJob = default(OceanTraceJob);
		oceanTraceJob.MaxDisplacement = num;
		oceanTraceJob.Rays = rays;
		oceanTraceJob.MaxDists = maxDists.AsReadOnly();
		oceanTraceJob.HitResults = hitResults;
		oceanTraceJob.HitPositions = hitPositions;
		oceanTraceJob.OneOverOctave0Scale = oneOverOctave0Scale;
		oceanTraceJob.SimData = nativeSimData;
		oceanTraceJob.Spectrum0 = spectrum0;
		oceanTraceJob.Spectrum1 = spectrum1;
		oceanTraceJob.Frame0 = frame0;
		oceanTraceJob.Frame1 = frame1;
		oceanTraceJob.spectrumBlend = spectrumBlend;
		oceanTraceJob.frameBlend = frameBlend;
		oceanTraceJob.HeightMapQueryStructure = TerrainMeta.HeightMap.GetQueryStructure();
		oceanTraceJob.ShoreVectorQueryStructure = TerrainMeta.Texturing.GetShoreVectorQueryStructure();
		oceanTraceJob.distanceAttenuationFactor = distanceAttenuationFactor;
		oceanTraceJob.depthAttenuationFactor = depthAttenuationFactor;
		inputDeps = IJobParallelForDeferExtensions.Schedule<OceanTraceJob, Ray>(oceanTraceJob, rays, 256, inputDeps);
		return inputDeps;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Trace(Ray ray, float maxDist, out Vector3 result)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
		if (num <= 0.1f)
		{
			Plane val = default(Plane);
			((Plane)(ref val))..ctor(Vector3.up, -0f);
			float num2 = default(float);
			if (((Plane)(ref val)).Raycast(ray, ref num2) && num2 < maxDist)
			{
				result = ((Ray)(ref ray)).GetPoint(num2);
				return true;
			}
			result = Vector3.zero;
			return false;
		}
		float num3 = 0f - num;
		Vector3 point = ((Ray)(ref ray)).GetPoint(maxDist);
		if (((Ray)(ref ray)).origin.y > num && point.y > num)
		{
			result = Vector3.zero;
			return false;
		}
		if (((Ray)(ref ray)).origin.y < num3 && point.y < num3)
		{
			result = Vector3.zero;
			return false;
		}
		Vector3 val2 = ((Ray)(ref ray)).origin;
		Vector3 direction = ((Ray)(ref ray)).direction;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 2f / (math.abs(direction.y) + 1f);
		result = val2;
		if (direction.y <= -0.99f)
		{
			result.y = GetHeight(val2);
			return math.lengthsq(float3.op_Implicit(result - val2)) < maxDist * maxDist;
		}
		if (val2.y >= num + 0f)
		{
			num5 = (num4 = (0f - (val2.y - num - 0f)) / direction.y);
			val2 += num4 * direction;
			if (num5 >= maxDist)
			{
				result = Vector3.zero;
				return false;
			}
		}
		int num7 = 0;
		while (true)
		{
			float height = GetHeight(val2);
			num4 = num6 * Mathf.Abs(val2.y - height - 0f);
			val2 += num4 * direction;
			num5 += num4;
			if (num7 >= 16 || num4 < 0.1f)
			{
				break;
			}
			if (num5 >= maxDist)
			{
				return false;
			}
			num7++;
		}
		if (num4 < 0.1f && num5 >= 0f)
		{
			result = val2;
			return true;
		}
		if (direction.y < 0f)
		{
			num4 = (0f - (val2.y + num - 0f)) / direction.y;
			Vector3 val3 = val2;
			Vector3 val4 = val2 + num4 * ((Ray)(ref ray)).direction;
			for (int i = 0; i < 16; i++)
			{
				val2 = (val3 + val4) * 0.5f;
				float height2 = GetHeight(val2);
				if (val2.y - height2 - 0f > 0f)
				{
					val3 = val2;
				}
				else
				{
					val4 = val2;
				}
				if (math.abs(val2.y - height2) < 0.1f)
				{
					val2.y = height2;
					break;
				}
			}
			result = val2;
			return true;
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float MinLevel()
	{
		return 0f - Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float MaxLevel()
	{
		return Mathf.Lerp(spectrumRanges[spectrum0], spectrumRanges[spectrum1], spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static float GetHeight(Vector3[,,] simData, Vector3 position, float time, float beaufort, float distAttenFactor, float depthAttenFactor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float num3 = (((Object)(object)TerrainTexturing.Instance != (Object)null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(uv) : 0f);
		float num4 = (((Object)(object)TerrainMeta.HeightMap != (Object)null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
		float num5 = Mathf.Clamp01(num3 / distAttenFactor);
		float num6 = Mathf.Clamp01(Mathf.Abs(num4) / depthAttenFactor);
		Vector3 zero = Vector3.zero;
		zero = GetDisplacement(simData, position, time, beaufort);
		zero = GetDisplacement(simData, position - zero, time, beaufort);
		zero = GetDisplacement(simData, position - zero, time, beaufort);
		return GetDisplacement(simData, position - zero, time, beaufort).y * num5 * num6;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, Vector3 position, float time, float beaufort)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		FindFrames(time, out var num, out var num2, out var num3);
		FindSpectra(beaufort, out var num4, out var num5, out var spectrumT);
		return GetDisplacement(simData, position, num, num2, num3, num4, num5, spectrumT);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, Vector3 position, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * oneOverOctave0Scale;
		float normZ = position.z * oneOverOctave0Scale;
		return GetDisplacement(simData, normX, normZ, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, float normX, float normZ, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		normX -= Mathf.Floor(normX);
		normZ -= Mathf.Floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = Mathf.FloorToInt(num);
		int num4 = Mathf.FloorToInt(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int x = num3;
		int y = num4;
		int x2 = num3 + 1;
		int y2 = num4 + 1;
		Vector3 displacement = GetDisplacement(simData, x, y, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement2 = GetDisplacement(simData, x2, y, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement3 = GetDisplacement(simData, x, y2, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 displacement4 = GetDisplacement(simData, x2, y2, frame0, frame1, frameBlend, spectrum0, spectrum1, spectrumBlend);
		Vector3 val = Vector3.LerpUnclamped(displacement, displacement2, num5);
		Vector3 val2 = Vector3.LerpUnclamped(displacement3, displacement4, num5);
		return Vector3.LerpUnclamped(val, val2, num6);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Vector3 GetDisplacement(Vector3[,,] simData, int x, int y, int frame0, int frame1, float frameBlend, int spectrum0, int spectrum1, float spectrumBlend)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		int num = x * 256 + y;
		Vector3 val = Vector3.LerpUnclamped(simData[spectrum0, frame0, num], simData[spectrum1, frame0, num], spectrumBlend);
		Vector3 val2 = Vector3.LerpUnclamped(simData[spectrum0, frame1, num], simData[spectrum1, frame1, num], spectrumBlend);
		return Vector3.LerpUnclamped(val, val2, frameBlend);
	}

	public void Dispose()
	{
		if (_batchPositionQueryArr.IsCreated)
		{
			_batchPositionQueryArr.Dispose();
		}
		nativeSimData.Dispose();
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(Vector2[] positions, float[] heights, float[] shore, float[] terrainHeight)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		PopulateBatchNative(positions);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = positions.Length;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = _batchPositionQueryArr[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void GetHeightBatch(NativeArray<float3> positions, Span<float> heights, ReadOnlySpan<float> shore, ReadOnlySpan<float> terrainHeight)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(positions.Length == heights.Length);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		_cachedBatchJob.Positions = positions;
		_cachedBatchJob.Count = positions.Length;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		for (int i = 0; i < heights.Length; i++)
		{
			heights[i] = positions[i].x * GetHeightAttenuation(shore[i], terrainHeight[i]);
		}
	}

	public void GetHeightsIndirect(ReadOnly<Vector3> pos, ReadOnly<float> shore, ReadOnly<float> terrainHeight, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		_heightsJobIndirect.Heights = results;
		_heightsJobIndirect.Pos = pos;
		_heightsJobIndirect.ShoreDists = shore;
		_heightsJobIndirect.TerrainHeights = terrainHeight;
		_heightsJobIndirect.Indices = indices;
		_heightsJobIndirect.OneOverOctave0Scale = oneOverOctave0Scale;
		_heightsJobIndirect.Frame0 = frame0;
		_heightsJobIndirect.Frame1 = frame1;
		_heightsJobIndirect.Spectrum0 = spectrum0;
		_heightsJobIndirect.Spectrum1 = spectrum1;
		_heightsJobIndirect.SpectrumBlend = spectrumBlend;
		_heightsJobIndirect.FrameBlend = frameBlend;
		_heightsJobIndirect.DistanceAttenuationFactor = distanceAttenuationFactor;
		_heightsJobIndirect.DepthAttenuationFactor = depthAttenuationFactor;
		IJobExtensions.RunByRef<GetHeightsJobIndirect>(ref _heightsJobIndirect);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeight(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		float heightAttenuation = GetHeightAttenuation(position);
		_cachedBatchJob.OneOverOctave0Scale = oneOverOctave0Scale;
		_cachedBatchJob.Frame0 = frame0;
		_cachedBatchJob.Frame1 = frame1;
		_cachedBatchJob.Spectrum0 = spectrum0;
		_cachedBatchJob.Spectrum1 = spectrum1;
		_cachedBatchJob.spectrumBlend = spectrumBlend;
		_cachedBatchJob.frameBlend = frameBlend;
		PopulateBatchNative(position);
		_cachedBatchJob.Positions = _batchPositionQueryArr;
		_cachedBatchJob.Count = 1;
		IJobExtensions.RunByRef<GetHeightBatchedJob>(ref _cachedBatchJob);
		return _cachedBatchJob.Positions[0].x * heightAttenuation;
	}

	private void PopulateBatchNative(Vector3 position)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < 1)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(1, (Allocator)4, (NativeArrayOptions)1);
		}
		_batchPositionQueryArr[0] = float3.op_Implicit(position);
	}

	private void PopulateBatchNative(Vector2[] positions)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (!_batchPositionQueryArr.IsCreated || _batchPositionQueryArr.Length < positions.Length)
		{
			if (_batchPositionQueryArr.IsCreated)
			{
				_batchPositionQueryArr.Dispose();
			}
			_batchPositionQueryArr = new NativeArray<float3>(positions.Length, (Allocator)4, (NativeArrayOptions)1);
		}
		for (int i = 0; i < positions.Length; i++)
		{
			_batchPositionQueryArr[i] = float3.op_Implicit(Vector3Ex.XZ3D(positions[i]));
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeightAttenuation(float shore, float terrainHeight)
	{
		float num = Mathf.Clamp01(shore / distanceAttenuationFactor);
		float num2 = Mathf.Clamp01(Mathf.Abs(terrainHeight) / depthAttenuationFactor);
		return num * num2;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float GetHeightAttenuation(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		float num = (position.x - x) * x2;
		float num2 = (position.z - z) * z2;
		Vector2 uv = default(Vector2);
		((Vector2)(ref uv))..ctor(num, num2);
		float num3 = (((Object)(object)TerrainTexturing.Instance != (Object)null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(uv) : 0f);
		float num4 = (((Object)(object)TerrainMeta.HeightMap != (Object)null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
		float num5 = Mathf.Clamp01(num3 / distanceAttenuationFactor);
		float num6 = Mathf.Clamp01(Mathf.Abs(num4) / depthAttenuationFactor);
		return num5 * num6;
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
internal struct GetHeightBatchedJob : IJob
{
	public NativeArray<float3> Positions;

	public int Count;

	public float OneOverOctave0Scale;

	public NativeOceanDisplacementShort3 SimData;

	public int Spectrum0;

	public int Spectrum1;

	public int Frame0;

	public int Frame1;

	public float spectrumBlend;

	public float frameBlend;

	public void Execute()
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Count; i++)
		{
			ref NativeArray<float3> positions = ref Positions;
			int num = i;
			float3 val = Positions[i];
			positions[num] = float3.op_Implicit(GetHeightRaw(((float3)(ref val)).xyz));
		}
	}

	private float GetHeightRaw(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float3 zero = float3.zero;
		zero = float3.op_Implicit(GetDisplacement(position));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return float3.op_Implicit(GetDisplacement(normX, normZ));
	}

	private float3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		float3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		float3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		float3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		float3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(displacementFromSimData, displacementFromSimData2, num5);
		float3 val2 = math.lerp(displacementFromSimData3, displacementFromSimData4, num5);
		return math.lerp(val, val2, num6);
	}

	private float3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], spectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], spectrumBlend);
		return math.lerp(val, val2, frameBlend);
	}
}


using Rust.Water5;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile]
internal struct GetHeightsJobIndirect : IJob
{
	[WriteOnly]
	public NativeArray<float> Heights;

	[ReadOnly]
	public ReadOnly<Vector3> Pos;

	[ReadOnly]
	public ReadOnly<float> ShoreDists;

	[ReadOnly]
	public ReadOnly<float> TerrainHeights;

	[ReadOnly]
	public ReadOnly<int> Indices;

	[ReadOnly]
	public float OneOverOctave0Scale;

	[ReadOnly]
	public NativeOceanDisplacementShort3 SimData;

	[ReadOnly]
	public int Spectrum0;

	[ReadOnly]
	public int Spectrum1;

	[ReadOnly]
	public int Frame0;

	[ReadOnly]
	public int Frame1;

	[ReadOnly]
	public float SpectrumBlend;

	[ReadOnly]
	public float FrameBlend;

	[ReadOnly]
	public float DistanceAttenuationFactor;

	[ReadOnly]
	public float DepthAttenuationFactor;

	public void Execute()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Indices.Length; i++)
		{
			int num = Indices[i];
			float heightRaw = GetHeightRaw(float3.op_Implicit(Pos[num]));
			Heights[num] = heightRaw * GetHeightAttenuation(ShoreDists[num], TerrainHeights[num]);
		}
	}

	private float GetHeightRaw(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float3 zero = float3.zero;
		zero = float3.op_Implicit(GetDisplacement(position));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		zero = float3.op_Implicit(GetDisplacement(position - zero));
		return GetDisplacement(position - zero).y;
	}

	private Vector3 GetDisplacement(float3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float normX = position.x * OneOverOctave0Scale;
		float normZ = position.z * OneOverOctave0Scale;
		return float3.op_Implicit(GetDisplacement(normX, normZ));
	}

	private float3 GetDisplacement(float normX, float normZ)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		normX -= math.floor(normX);
		normZ -= math.floor(normZ);
		float num = normX * 256f - 0.5f;
		float num2 = normZ * 256f - 0.5f;
		int num3 = (int)math.floor(num);
		int num4 = (int)math.floor(num2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		int num7 = num3 % 256;
		int num8 = num4 % 256;
		int x = (num7 + 256) % 256;
		int z = (num8 + 256) % 256;
		int x2 = (num7 + 1 + 256) % 256;
		int z2 = (num8 + 1 + 256) % 256;
		float3 displacementFromSimData = GetDisplacementFromSimData(x, z);
		float3 displacementFromSimData2 = GetDisplacementFromSimData(x2, z);
		float3 displacementFromSimData3 = GetDisplacementFromSimData(x, z2);
		float3 displacementFromSimData4 = GetDisplacementFromSimData(x2, z2);
		float3 val = math.lerp(displacementFromSimData, displacementFromSimData2, num5);
		float3 val2 = math.lerp(displacementFromSimData3, displacementFromSimData4, num5);
		return math.lerp(val, val2, num6);
	}

	private float3 GetDisplacementFromSimData(int x, int z)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		int z2 = x * 256 + z;
		float3 val = math.lerp((float3)SimData[Spectrum0, Frame0, z2], (float3)SimData[Spectrum1, Frame0, z2], SpectrumBlend);
		float3 val2 = math.lerp((float3)SimData[Spectrum0, Frame1, z2], (float3)SimData[Spectrum1, Frame1, z2], SpectrumBlend);
		return math.lerp(val, val2, FrameBlend);
	}

	public float GetHeightAttenuation(float shore, float terrainHeight)
	{
		float num = Mathf.Clamp01(shore / DistanceAttenuationFactor);
		float num2 = Mathf.Clamp01(Mathf.Abs(terrainHeight) / DepthAttenuationFactor);
		return num * num2;
	}
}


using System;

[Serializable]
public struct SpectrumParameters
{
	public float scale;

	public float angle;

	public float spreadBlend;

	public float swell;

	public float alpha;

	public float peakOmega;

	public float gamma;

	public float shortWavesFade;
}


using System;
using UnityEngine;

[Serializable]
public struct SpectrumSettings
{
	[Range(0f, 1f)]
	public float scale;

	public float windSpeed;

	public float fetch;

	[Range(0f, 1f)]
	public float spreadBlend;

	[Range(0f, 1f)]
	public float swell;

	public float peakEnhancement;

	public float shortWavesFade;
}


using Rust.Water5;
using UnityEngine;

[CreateAssetMenu(fileName = "New Spectrum Settings", menuName = "Water5/Spectrum Settings")]
public class OceanSpectrumSettings : ScriptableObject
{
	public OceanSettings oceanSettings;

	[Header("Deep Wave Settings")]
	public float g;

	public float beaufort;

	public float depth;

	public SpectrumSettings local;

	public SpectrumSettings swell;

	[Header("Material Settings")]
	public Color color;

	public Color specColor;

	public float smoothness;

	public Color waterColor;

	public Color waterExtinction;

	public float scatteringCoefficient;

	public Color subSurfaceColor;

	public float subSurfaceFalloff;

	public float subSurfaceBase;

	public float subSurfaceSun;

	public float subSurfaceAmount;

	public float foamAmount;

	public float foamScale;

	public Color foamColor;

	public Color baseFoamColor;

	[Button("Update Spectrum")]
	public void UpdateSpectrum()
	{
		WaterSystem.Instance?.Refresh();
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class ConditionalObject
{
	public enum AdjacentCondition
	{
		SameInFront,
		SameBehind,
		DifferentInFront,
		DifferentBehind,
		BothDifferent,
		BothSame
	}

	public enum AdjacentMatchType
	{
		GroupOrExact,
		ExactOnly,
		GroupNotExact
	}

	public GameObject gameObject;

	public GameObject ownerGameObject;

	public ConditionalSocketSettings[] socketSettings;

	public bool restrictOnHealth;

	public float healthRestrictionMin;

	public float healthRestrictionMax;

	public bool restrictOnAdjacent;

	public AdjacentCondition adjacentRestriction;

	public AdjacentMatchType adjacentMatch;

	public bool restrictOnLockable;

	public bool lockableRestriction;

	public bool? IsActive { get; private set; }

	public ConditionalObject(GameObject conditionalGO, GameObject ownerGO, int socketsTaken)
	{
		gameObject = conditionalGO;
		ownerGameObject = ownerGO;
		socketSettings = new ConditionalSocketSettings[socketsTaken];
	}

	public void SetActive(bool active)
	{
		if (!IsActive.HasValue || active != IsActive.Value)
		{
			gameObject.SetActive(active);
			IsActive = active;
		}
	}

	public void RefreshActive()
	{
		if (IsActive.HasValue)
		{
			gameObject.SetActive(IsActive.Value);
		}
	}
}


public enum AdjacentCondition
{
	SameInFront,
	SameBehind,
	DifferentInFront,
	DifferentBehind,
	BothDifferent,
	BothSame
}


public enum AdjacentMatchType
{
	GroupOrExact,
	ExactOnly,
	GroupNotExact
}


using System;
using Rust.Modular;

[Serializable]
public class ConditionalSocketSettings
{
	public enum LocationCondition
	{
		Middle,
		Front,
		Back,
		NotMiddle,
		NotFront,
		NotBack
	}

	public bool restrictOnLocation;

	public LocationCondition locationRestriction;

	public bool restrictOnWheel;

	public ModularVehicleSocket.SocketWheelType wheelRestriction;

	public bool HasSocketRestrictions
	{
		get
		{
			if (!restrictOnLocation)
			{
				return restrictOnWheel;
			}
			return true;
		}
	}
}


public enum LocationCondition
{
	Middle,
	Front,
	Back,
	NotMiddle,
	NotFront,
	NotBack
}


using UnityEngine;
using UnityEngine.Events;

public class EnableDisableEvent : MonoBehaviour
{
	[SerializeField]
	private UnityEvent enableEvent;

	[SerializeField]
	private UnityEvent disableEvent;

	protected void OnEnable()
	{
		if (enableEvent != null)
		{
			enableEvent.Invoke();
		}
	}

	protected void OnDisable()
	{
		if (disableEvent != null)
		{
			disableEvent.Invoke();
		}
	}
}


using Rust.Modular;

public static class EngineItemTypeEx
{
	public static bool BoostsAcceleration(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.SparkPlug)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Piston;
		}
		return true;
	}

	public static bool BoostsTopSpeed(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.Carburetor && engineItemType != 0)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Piston;
		}
		return true;
	}

	public static bool BoostsFuelEconomy(this EngineStorage.EngineItemTypes engineItemType)
	{
		if (engineItemType != EngineStorage.EngineItemTypes.Carburetor)
		{
			return engineItemType == EngineStorage.EngineItemTypes.Valve;
		}
		return true;
	}
}


using System;
using System.Linq;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Modular;
using UnityEngine;

public class EngineStorage : StorageContainer
{
	public enum EngineItemTypes
	{
		Crankshaft,
		Carburetor,
		SparkPlug,
		Piston,
		Valve
	}

	[Header("Engine Storage")]
	public Sprite engineIcon;

	public float internalDamageMultiplier = 0.5f;

	public EngineItemTypes[] slotTypes;

	[SerializeField]
	public VehicleModuleEngineItems allEngineItems;

	[SerializeField]
	[ReadOnly]
	public int accelerationBoostSlots;

	[ReadOnly]
	[SerializeField]
	public int topSpeedBoostSlots;

	[ReadOnly]
	[SerializeField]
	public int fuelEconomyBoostSlots;

	public bool isUsable { get; set; }

	public float accelerationBoostPercent { get; set; }

	public float topSpeedBoostPercent { get; set; }

	public float fuelEconomyBoostPercent { get; set; }

	public VehicleModuleEngine GetEngineModule()
	{
		BaseEntity baseEntity = GetParentEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			return ((Component)baseEntity).GetComponent<VehicleModuleEngine>();
		}
		return null;
	}

	public float GetAveragedLoadoutPercent()
	{
		return (accelerationBoostPercent + topSpeedBoostPercent + fuelEconomyBoostPercent) / 3f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.engineStorage != null)
		{
			isUsable = info.msg.engineStorage.isUsable;
			accelerationBoostPercent = info.msg.engineStorage.accelerationBoost;
			topSpeedBoostPercent = info.msg.engineStorage.topSpeedBoost;
			fuelEconomyBoostPercent = info.msg.engineStorage.fuelEconomyBoost;
		}
		GetEngineModule()?.RefreshPerformanceStats(this);
	}

	public override bool CanBeLooted(BasePlayer player)
	{
		VehicleModuleEngine engineModule = GetEngineModule();
		if ((Object)(object)engineModule != (Object)null)
		{
			return engineModule.CanBeLooted(player);
		}
		return false;
	}

	public override int GetIdealSlot(BasePlayer player, ItemContainer container, Item item)
	{
		return GetValidSlot(item);
	}

	public int GetValidSlot(Item item)
	{
		ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
		if ((Object)(object)component == (Object)null)
		{
			return -1;
		}
		EngineItemTypes engineItemType = component.engineItemType;
		for (int i = 0; i < inventorySlots; i++)
		{
			if (engineItemType == slotTypes[i] && !base.inventory.SlotTaken(item, i))
			{
				return i;
			}
		}
		return -1;
	}

	public override void OnInventoryFirstCreated(ItemContainer container)
	{
		RefreshLoadoutData();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		RefreshLoadoutData();
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (!base.ItemFilter(item, targetSlot))
		{
			return false;
		}
		if (targetSlot < 0 || targetSlot >= slotTypes.Length)
		{
			return false;
		}
		ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
		if ((Object)(object)component != (Object)null && component.engineItemType == slotTypes[targetSlot])
		{
			return true;
		}
		return false;
	}

	public void RefreshLoadoutData()
	{
		if (Interface.CallHook("OnEngineLoadoutRefresh", (object)this) == null)
		{
			isUsable = base.inventory.IsFull() && base.inventory.itemList.All((Item item) => !item.isBroken);
			accelerationBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsAcceleration) / (float)accelerationBoostSlots;
			topSpeedBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsTopSpeed) / (float)topSpeedBoostSlots;
			fuelEconomyBoostPercent = GetContainerItemsValueFor(EngineItemTypeEx.BoostsFuelEconomy) / (float)fuelEconomyBoostSlots;
			SendNetworkUpdate();
			GetEngineModule()?.RefreshPerformanceStats(this);
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.engineStorage = Pool.Get<EngineStorage>();
		info.msg.engineStorage.isUsable = isUsable;
		info.msg.engineStorage.accelerationBoost = accelerationBoostPercent;
		info.msg.engineStorage.topSpeedBoost = topSpeedBoostPercent;
		info.msg.engineStorage.fuelEconomyBoost = fuelEconomyBoostPercent;
	}

	public void OnModuleDamaged(float damageTaken)
	{
		if (damageTaken <= 0f)
		{
			return;
		}
		damageTaken *= internalDamageMultiplier;
		float[] array = new float[base.inventory.capacity];
		float num = 0f;
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = Random.value;
			num += array[i];
		}
		float num2 = damageTaken / num;
		for (int j = 0; j < array.Length; j++)
		{
			Item slot = base.inventory.GetSlot(j);
			if (slot != null)
			{
				slot.condition -= array[j] * num2;
			}
		}
		RefreshLoadoutData();
	}

	public void AdminAddParts(int tier)
	{
		if (base.inventory == null)
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": Null inventory on " + ((Object)this).name));
			return;
		}
		for (int i = 0; i < base.inventory.capacity; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot != null)
			{
				slot.RemoveFromContainer();
				slot.Remove();
			}
		}
		for (int j = 0; j < base.inventory.capacity; j++)
		{
			if (base.inventory.GetSlot(j) == null && allEngineItems.TryGetItem(tier, slotTypes[j], out var output))
			{
				ItemDefinition component = ((Component)output).GetComponent<ItemDefinition>();
				Item item = ItemManager.Create(component, 1, 0uL);
				if (item != null)
				{
					item.condition = component.condition.max;
					item.MoveToContainer(base.inventory, j, allowStack: false);
				}
				else
				{
					Debug.LogError((object)(((object)this).GetType().Name + ": Failed to create engine storage item."));
				}
			}
		}
	}

	public float GetContainerItemsValueFor(Func<EngineItemTypes, bool> boostConditional)
	{
		float num = 0f;
		foreach (Item item in base.inventory.itemList)
		{
			ItemModEngineItem component = ((Component)item.info).GetComponent<ItemModEngineItem>();
			if ((Object)(object)component != (Object)null && boostConditional(component.engineItemType) && !item.isBroken)
			{
				num += (float)item.amount * GetTierValue(component.tier);
			}
		}
		return num;
	}

	public float GetTierValue(int tier)
	{
		switch (tier)
		{
		case 1:
			return 0.6f;
		case 2:
			return 0.8f;
		case 3:
			return 1f;
		default:
			Debug.LogError((object)(((object)this).GetType().Name + ": Unrecognised item tier: " + tier));
			return 0f;
		}
	}
}


public enum EngineItemTypes
{
	Crankshaft,
	Carburetor,
	SparkPlug,
	Piston,
	Valve
}


using UnityEngine;

public class ModularCarAudio : GroundVehicleAudio
{
	public bool showDebug;

	[Header("Skid")]
	[SerializeField]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;

	[Header("Movement & Suspension")]
	[SerializeField]
	private SoundDefinition movementStartOneshot;

	[SerializeField]
	private SoundDefinition movementStopOneshot;

	[SerializeField]
	private float movementStartStopMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	private SoundDefinition movementRattleLoop;

	[SerializeField]
	private float movementRattleMaxSpeed = 10f;

	[SerializeField]
	private float movementRattleMaxAngSpeed = 10f;

	[SerializeField]
	private float movementRattleIdleGain = 0.3f;

	[SerializeField]
	private SoundDefinition suspensionLurchSound;

	[SerializeField]
	private float suspensionLurchMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionLurchMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	[Header("Wheels")]
	private SoundDefinition tyreRollingSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingWaterSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingGrassSoundDef;

	[SerializeField]
	private SoundDefinition tyreRollingSnowSoundDef;

	[SerializeField]
	private AnimationCurve tyreRollGainCurve;
}


using System;
using Facepunch;
using Rust;
using Rust.Modular;
using UnityEngine;

public class ModularVehicleInventory : IDisposable
{
	private ItemContainer moduleContainer;

	private ItemContainer chassisContainer;

	private readonly BaseModularVehicle vehicle;

	public ItemContainer ModuleContainer => moduleContainer;

	public ItemContainer ChassisContainer => chassisContainer;

	public ItemContainerId UID => moduleContainer.uid;

	private int TotalSockets => vehicle.TotalSockets;

	public ModularVehicleInventory(BaseModularVehicle vehicle, ItemDefinition chassisItemDef, bool giveUID)
	{
		this.vehicle = vehicle;
		moduleContainer = CreateModuleInventory(vehicle, giveUID);
		chassisContainer = CreateChassisInventory(vehicle, giveUID);
		vehicle.AssociatedItemInstance = ItemManager.Create(chassisItemDef, 1, 0uL);
		if (!Application.isLoadingSave)
		{
			vehicle.AssociatedItemInstance.MoveToContainer(chassisContainer, 0, allowStack: false);
		}
	}

	public void Dispose()
	{
		foreach (Item item in moduleContainer.itemList)
		{
			item.OnDirty -= OnModuleItemChanged;
		}
		Pool.Free<ItemContainer>(ref moduleContainer);
		Pool.Free<ItemContainer>(ref chassisContainer);
	}

	public void GiveUIDs()
	{
		moduleContainer.GiveUID();
		chassisContainer.GiveUID();
	}

	public bool SocketIsFree(int socketIndex, Item moduleItem = null)
	{
		Item item = null;
		int num = socketIndex;
		while (item == null && num >= 0)
		{
			item = moduleContainer.GetSlot(num);
			if (item != null)
			{
				if (item == moduleItem)
				{
					return true;
				}
				ItemModVehicleModule component = ((Component)item.info).GetComponent<ItemModVehicleModule>();
				return num + component.socketsTaken - 1 < socketIndex;
			}
			num--;
		}
		return true;
	}

	public bool SocketIsTaken(int socketIndex)
	{
		return !SocketIsFree(socketIndex);
	}

	public bool TryAddModuleItem(Item moduleItem, int socketIndex)
	{
		if (moduleItem == null)
		{
			Debug.LogError((object)(GetType().Name + ": Can't add null item."));
			return false;
		}
		return moduleItem.MoveToContainer(moduleContainer, socketIndex, allowStack: false);
	}

	public bool RemoveAndDestroy(Item itemToRemove)
	{
		bool result = moduleContainer.Remove(itemToRemove);
		itemToRemove.Remove();
		return result;
	}

	public int TryGetFreeSocket(int socketsTaken)
	{
		return TryGetFreeSocket(null, socketsTaken);
	}

	public int TryGetFreeSocket(Item moduleItem, int socketsTaken)
	{
		for (int i = 0; i <= TotalSockets - socketsTaken; i++)
		{
			if (SocketsAreFree(i, socketsTaken, moduleItem))
			{
				return i;
			}
		}
		return -1;
	}

	public bool SocketsAreFree(int firstIndex, int socketsTaken, Item moduleItem = null)
	{
		if (firstIndex < 0 || firstIndex + socketsTaken > TotalSockets)
		{
			return false;
		}
		for (int i = firstIndex; i < firstIndex + socketsTaken; i++)
		{
			if (!SocketIsFree(i, moduleItem))
			{
				return false;
			}
		}
		return true;
	}

	public bool TrySyncModuleInventory(BaseVehicleModule moduleEntity, int firstSocketIndex)
	{
		if (firstSocketIndex < 0)
		{
			Debug.LogError((object)$"{GetType().Name}: Invalid socket index ({firstSocketIndex}) for new module entity.", (Object)(object)((Component)vehicle).gameObject);
			return false;
		}
		Item slot = moduleContainer.GetSlot(firstSocketIndex);
		int numSocketsTaken = moduleEntity.GetNumSocketsTaken();
		if (!SocketsAreFree(firstSocketIndex, numSocketsTaken) && (slot == null || moduleEntity.AssociatedItemInstance != slot))
		{
			Debug.LogError((object)$"{GetType().Name}: Sockets are not free for new module entity. First: {firstSocketIndex} Taken: {numSocketsTaken}", (Object)(object)((Component)vehicle).gameObject);
			return false;
		}
		if (slot == null)
		{
			Item item = ItemManager.Create(moduleEntity.AssociatedItemDef, 1, 0uL);
			item.condition = moduleEntity.health;
			moduleEntity.AssociatedItemInstance = item;
			bool num = TryAddModuleItem(item, firstSocketIndex);
			if (num)
			{
				vehicle.SetUpModule(moduleEntity, item);
				return num;
			}
			item.Remove();
			return num;
		}
		return true;
	}

	private bool SocketIsUsed(Item item, int slotIndex)
	{
		return !SocketIsFree(slotIndex, item);
	}

	private ItemContainer CreateModuleInventory(BaseModularVehicle vehicle, bool giveUID)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = vehicle;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.maxStackSize = 1;
		itemContainer.ServerInitialize(null, TotalSockets);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		itemContainer.onItemAddedRemoved = OnSocketInventoryAddRemove;
		itemContainer.canAcceptItem = ItemFilter;
		itemContainer.slotIsReserved = SocketIsUsed;
		return itemContainer;
	}

	private ItemContainer CreateChassisInventory(BaseModularVehicle vehicle, bool giveUID)
	{
		ItemContainer itemContainer = Pool.Get<ItemContainer>();
		itemContainer.entityOwner = vehicle;
		itemContainer.allowedContents = ItemContainer.ContentsType.Generic;
		itemContainer.maxStackSize = 1;
		itemContainer.ServerInitialize(null, 1);
		if (giveUID)
		{
			itemContainer.GiveUID();
		}
		return itemContainer;
	}

	private void OnSocketInventoryAddRemove(Item moduleItem, bool added)
	{
		if (added)
		{
			ModuleItemAdded(moduleItem, moduleItem.position);
		}
		else
		{
			ModuleItemRemoved(moduleItem);
		}
	}

	private void ModuleItemAdded(Item moduleItem, int socketIndex)
	{
		ItemModVehicleModule component = ((Component)moduleItem.info).GetComponent<ItemModVehicleModule>();
		if (!Application.isLoadingSave && (Object)(object)vehicle.GetModuleForItem(moduleItem) == (Object)null)
		{
			vehicle.CreatePhysicalModuleEntity(moduleItem, component, socketIndex);
		}
		moduleItem.OnDirty += OnModuleItemChanged;
	}

	private void ModuleItemRemoved(Item moduleItem)
	{
		if (moduleItem == null)
		{
			Debug.LogError((object)"Null module item removed.", (Object)(object)((Component)vehicle).gameObject);
			return;
		}
		moduleItem.OnDirty -= OnModuleItemChanged;
		BaseVehicleModule moduleForItem = vehicle.GetModuleForItem(moduleItem);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			if (!moduleForItem.IsFullySpawned())
			{
				Debug.LogError((object)"Module entity being removed before it's fully spawned. This could cause errors.", (Object)(object)((Component)vehicle).gameObject);
			}
			moduleForItem.Kill();
		}
		else
		{
			Debug.Log((object)"Couldn't find entity for this item.");
		}
	}

	private void OnModuleItemChanged(Item moduleItem)
	{
		BaseVehicleModule moduleForItem = vehicle.GetModuleForItem(moduleItem);
		if ((Object)(object)moduleForItem != (Object)null)
		{
			moduleForItem.SetHealth(moduleItem.condition);
			if (moduleForItem.FirstSocketIndex != moduleItem.position)
			{
				ModuleItemRemoved(moduleItem);
				ModuleItemAdded(moduleItem, moduleItem.position);
			}
		}
	}

	private bool ItemFilter(Item item, int targetSlot)
	{
		string failureReason;
		return vehicle.ModuleCanBeAdded(item, targetSlot, out failureReason);
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class ModularVehicleSocket
{
	public enum SocketWheelType
	{
		NoWheel,
		ForwardWheel,
		BackWheel
	}

	public enum SocketLocationType
	{
		Middle,
		Front,
		Back
	}

	[SerializeField]
	private Transform socketTransform;

	[SerializeField]
	private SocketWheelType wheelType;

	[SerializeField]
	private SocketLocationType locationType;

	public Vector3 WorldPosition => socketTransform.position;

	public Quaternion WorldRotation => socketTransform.rotation;

	public SocketWheelType WheelType => wheelType;

	public SocketLocationType LocationType => locationType;

	public bool ShouldBeActive(ConditionalSocketSettings modelSettings)
	{
		bool flag = true;
		if (modelSettings.restrictOnLocation)
		{
			ConditionalSocketSettings.LocationCondition locationRestriction = modelSettings.locationRestriction;
			switch (LocationType)
			{
			case SocketLocationType.Back:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Back || locationRestriction == ConditionalSocketSettings.LocationCondition.NotFront || locationRestriction == ConditionalSocketSettings.LocationCondition.NotMiddle;
				break;
			case SocketLocationType.Front:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Front || locationRestriction == ConditionalSocketSettings.LocationCondition.NotBack || locationRestriction == ConditionalSocketSettings.LocationCondition.NotMiddle;
				break;
			case SocketLocationType.Middle:
				flag = locationRestriction == ConditionalSocketSettings.LocationCondition.Middle || locationRestriction == ConditionalSocketSettings.LocationCondition.NotFront || locationRestriction == ConditionalSocketSettings.LocationCondition.NotBack;
				break;
			}
		}
		if (flag && modelSettings.restrictOnWheel)
		{
			flag = WheelType == modelSettings.wheelRestriction;
		}
		return flag;
	}
}


public enum SocketWheelType
{
	NoWheel,
	ForwardWheel,
	BackWheel
}


public enum SocketLocationType
{
	Middle,
	Front,
	Back
}


using System.Collections.Generic;
using Facepunch;
using Rust.Modular;
using UnityEngine;

[CreateAssetMenu(fileName = "Vehicle Module Engine Items", menuName = "Scriptable Object/Vehicles/Module Engine Items")]
public class VehicleModuleEngineItems : ScriptableObject
{
	[SerializeField]
	private ItemModEngineItem[] engineItems;

	public bool TryGetItem(int tier, EngineStorage.EngineItemTypes type, out ItemModEngineItem output)
	{
		List<ItemModEngineItem> list = Pool.Get<List<ItemModEngineItem>>();
		bool result = false;
		output = null;
		ItemModEngineItem[] array = engineItems;
		foreach (ItemModEngineItem itemModEngineItem in array)
		{
			if (itemModEngineItem.tier == tier && itemModEngineItem.engineItemType == type)
			{
				list.Add(itemModEngineItem);
			}
		}
		if (list.Count > 0)
		{
			output = ListEx.GetRandom<ItemModEngineItem>(list);
			result = true;
		}
		Pool.FreeUnmanaged<ItemModEngineItem>(ref list);
		return result;
	}
}


using System;
using Rust.Modular;
using UnityEngine;

[Serializable]
public class VehicleModuleSlidingComponent
{
	[Serializable]
	public class SlidingPart
	{
		public Transform transform;

		public Vector3 openPosition;

		public Vector3 closedPosition;
	}

	public string interactionColliderName = "MyCollider";

	public BaseEntity.Flags flag_SliderOpen = BaseEntity.Flags.Reserved3;

	public float moveTime = 1f;

	public SlidingPart[] slidingParts;

	public SoundDefinition openSoundDef;

	public SoundDefinition closeSoundDef;

	private float positionPercent;

	public bool WantsOpenPos(BaseEntity parentEntity)
	{
		return parentEntity.HasFlag(flag_SliderOpen);
	}

	public void Use(BaseVehicleModule parentModule)
	{
		parentModule.SetFlag(flag_SliderOpen, !WantsOpenPos(parentModule));
	}

	public void ServerUpdateTick(BaseVehicleModule parentModule)
	{
		CheckPosition(parentModule, Time.fixedDeltaTime);
	}

	private void CheckPosition(BaseEntity parentEntity, float dt)
	{
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		bool flag = WantsOpenPos(parentEntity);
		if ((flag && positionPercent == 1f) || (!flag && positionPercent == 0f))
		{
			return;
		}
		float num = (flag ? (dt / moveTime) : (0f - dt / moveTime));
		positionPercent = Mathf.Clamp01(positionPercent + num);
		SlidingPart[] array = slidingParts;
		foreach (SlidingPart slidingPart in array)
		{
			if (!((Object)(object)slidingPart.transform == (Object)null))
			{
				slidingPart.transform.localPosition = Vector3.Lerp(slidingPart.closedPosition, slidingPart.openPosition, positionPercent);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SlidingPart
{
	public Transform transform;

	public Vector3 openPosition;

	public Vector3 closedPosition;
}


using Rust.Modular;
using UnityEngine;

public class ItemModEngineItem : ItemMod
{
	public EngineStorage.EngineItemTypes engineItemType;

	[Range(1f, 3f)]
	public int tier = 1;
}


using UnityEngine;

public class ItemModVehicleChassis : ItemMod, VehicleModuleInformationPanel.IVehicleModuleInfo
{
	public GameObjectRef entityPrefab;

	[Range(1f, 6f)]
	public int socketsTaken = 1;

	public int SocketsTaken => socketsTaken;
}


using UnityEngine;

public class ItemModVehicleModule : ItemMod, VehicleModuleInformationPanel.IVehicleModuleInfo
{
	public GameObjectRef entityPrefab;

	[Range(1f, 2f)]
	public int socketsTaken = 1;

	public int SocketsTaken => socketsTaken;

	public BaseVehicleModule CreateModuleEntity(BaseEntity parent, Vector3 position, Quaternion rotation)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (!entityPrefab.isValid)
		{
			Debug.LogError((object)"Invalid entity prefab for module");
			return null;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityPrefab.resourcePath, position, rotation);
		BaseVehicleModule result = null;
		if ((Object)(object)baseEntity != (Object)null)
		{
			if ((Object)(object)parent != (Object)null)
			{
				baseEntity.SetParent(parent, worldPositionStays: true);
				baseEntity.canTriggerParent = false;
			}
			baseEntity.Spawn();
			result = ((Component)baseEntity).GetComponent<BaseVehicleModule>();
		}
		return result;
	}
}


public enum Notes
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System.Collections.Generic;
using Rust.Interpolation;

public interface IGenericLerpTarget<T> where T : ISnapshot<T>, new()
{
	float GetInterpolationDelay(ILerpInfo.LerpType lerpType);

	float GetInterpolationSmoothing();

	void SetFrom(T snapshot);

	T GetCurrentState();

	void DebugInterpolationState(Interpolator<T>.Segment segment, List<T> entries);
}


using System;
using Rust.Interpolation;
using UnityEngine;

public class GenericLerp<T> : IDisposable where T : ISnapshot<T>, new()
{
	private readonly Interpolator<T> interpolator;

	private IGenericLerpTarget<T> target;

	private static T snapshotPrototype = new T();

	private static float timeOffset = 0f;

	private float timeOffset0 = float.MaxValue;

	private float timeOffset1 = float.MaxValue;

	private float timeOffset2 = float.MaxValue;

	private float timeOffset3 = float.MaxValue;

	private int timeOffsetCount;

	private int TimeOffsetInterval => PositionLerp.TimeOffsetInterval;

	private float LerpTime => PositionLerp.LerpTime;

	public GenericLerp(IGenericLerpTarget<T> target, int listCount)
	{
		this.target = target;
		interpolator = new Interpolator<T>(listCount);
	}

	public void Tick()
	{
		if (target != null)
		{
			float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
			float interpolationSmoothing = target.GetInterpolationSmoothing();
			Interpolator<T>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, interpolationSmoothing, ref snapshotPrototype);
			target.SetFrom(segment.tick);
		}
	}

	public void Snapshot(T snapshot)
	{
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
		float interpolationSmoothing = target.GetInterpolationSmoothing();
		float num = interpolationDelay + interpolationSmoothing + 1f;
		float lerpTime = LerpTime;
		timeOffset0 = Mathf.Min(timeOffset0, lerpTime - snapshot.Time);
		timeOffsetCount++;
		if (timeOffsetCount >= TimeOffsetInterval / 4)
		{
			timeOffset3 = timeOffset2;
			timeOffset2 = timeOffset1;
			timeOffset1 = timeOffset0;
			timeOffset0 = float.MaxValue;
			timeOffsetCount = 0;
		}
		timeOffset = Mathx.Min(timeOffset0, timeOffset1, timeOffset2, timeOffset3);
		lerpTime = (snapshot.Time += timeOffset);
		interpolator.Add(snapshot);
		interpolator.Cull(lerpTime - num);
	}

	public void SnapTo(T snapshot)
	{
		interpolator.Clear();
		Snapshot(snapshot);
		target.SetFrom(snapshot);
	}

	public void SnapToNow(T snapshot)
	{
		snapshot.Time = LerpTime;
		interpolator.last = snapshot;
		Wipe();
	}

	public void SnapToEnd()
	{
		float interpolationDelay = target.GetInterpolationDelay(ILerpInfo.LerpType.Generic);
		Interpolator<T>.Segment segment = interpolator.Query(LerpTime, interpolationDelay, 0f, 0f, ref snapshotPrototype);
		target.SetFrom(segment.tick);
		Wipe();
	}

	public void Dispose()
	{
		target = null;
		interpolator.Clear();
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
		timeOffsetCount = 0;
	}

	private void Wipe()
	{
		interpolator.Clear();
		timeOffsetCount = 0;
		timeOffset0 = float.MaxValue;
		timeOffset1 = float.MaxValue;
		timeOffset2 = float.MaxValue;
		timeOffset3 = float.MaxValue;
	}
}


public interface ISnapshot<T>
{
	float Time { get; set; }

	void MatchValuesTo(T entry);

	void Lerp(T prev, T next, float delta);

	T GetNew();
}


using System.Collections.Generic;
using Rust.Interpolation;
using UnityEngine;

public class Interpolator<T> where T : ISnapshot<T>, new()
{
	public struct Segment
	{
		public T tick;

		public T prev;

		public T next;
	}

	public List<T> list;

	public T last;

	public Interpolator(int listCount)
	{
		list = new List<T>(listCount);
	}

	public void Add(T tick)
	{
		last = tick;
		list.Add(tick);
	}

	public void Cull(float beforeTime)
	{
		for (int i = 0; i < list.Count; i++)
		{
			if (list[i].Time < beforeTime)
			{
				list.RemoveAt(i);
				i--;
			}
		}
	}

	public void Clear()
	{
		list.Clear();
	}

	public Segment Query(float time, float interpolation, float extrapolation, float smoothing, ref T t)
	{
		Segment result = default(Segment);
		if (list.Count == 0)
		{
			result.prev = last;
			result.next = last;
			result.tick = last;
			return result;
		}
		float num = time - interpolation - smoothing * 0.5f;
		float num2 = Mathf.Min(time - interpolation, last.Time);
		float num3 = num2 - smoothing;
		T prev = list[0];
		T val = last;
		T prev2 = list[0];
		T val2 = last;
		foreach (T item in list)
		{
			if (item.Time < num3)
			{
				prev = item;
			}
			else if (val.Time >= item.Time)
			{
				val = item;
			}
			if (item.Time < num2)
			{
				prev2 = item;
			}
			else if (val2.Time >= item.Time)
			{
				val2 = item;
			}
		}
		T @new = t.GetNew();
		if (val.Time - prev.Time <= Mathf.Epsilon)
		{
			@new.Time = num3;
			@new.MatchValuesTo(val);
		}
		else
		{
			@new.Time = num3;
			@new.Lerp(prev, val, (num3 - prev.Time) / (val.Time - prev.Time));
		}
		result.prev = @new;
		T new2 = t.GetNew();
		if (val2.Time - prev2.Time <= Mathf.Epsilon)
		{
			new2.Time = num2;
			new2.MatchValuesTo(val2);
		}
		else
		{
			new2.Time = num2;
			new2.Lerp(prev2, val2, (num2 - prev2.Time) / (val2.Time - prev2.Time));
		}
		result.next = new2;
		if (new2.Time - @new.Time <= Mathf.Epsilon)
		{
			result.prev = new2;
			result.tick = new2;
			return result;
		}
		if (num - new2.Time > extrapolation)
		{
			result.prev = new2;
			result.tick = new2;
			return result;
		}
		T new3 = t.GetNew();
		new3.Time = num;
		new3.Lerp(@new, new2, Mathf.Min(num - @new.Time, new2.Time + extrapolation - @new.Time) / (new2.Time - @new.Time));
		result.tick = new3;
		return result;
	}
}


public struct Segment
{
	public T tick;

	public T prev;

	public T next;
}


using Rust.Interpolation;
using UnityEngine;

public struct TransformSnapshot : ISnapshot<TransformSnapshot>
{
	public Vector3 pos;

	public Quaternion rot;

	public float Time { get; set; }

	public TransformSnapshot(float time, Vector3 pos, Quaternion rot)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Time = time;
		this.pos = pos;
		this.rot = rot;
	}

	public void MatchValuesTo(TransformSnapshot entry)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		pos = entry.pos;
		rot = entry.rot;
	}

	public void Lerp(TransformSnapshot prev, TransformSnapshot next, float delta)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		pos = Vector3.LerpUnclamped(prev.pos, next.pos, delta);
		rot = Quaternion.SlerpUnclamped(prev.rot, next.rot, delta);
	}

	public TransformSnapshot GetNew()
	{
		return default(TransformSnapshot);
	}
}


using Rust.Interpolation;
using UnityEngine;

public struct FloatSnapshot : ISnapshot<FloatSnapshot>
{
	public float value;

	public float Time { get; set; }

	public FloatSnapshot(float time, float value)
	{
		Time = time;
		this.value = value;
	}

	public void MatchValuesTo(FloatSnapshot entry)
	{
		value = entry.value;
	}

	public void Lerp(FloatSnapshot prev, FloatSnapshot next, float delta)
	{
		value = Mathf.Lerp(prev.value, next.value, delta);
	}

	public FloatSnapshot GetNew()
	{
		return default(FloatSnapshot);
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public static class AStarPath
{
	private static float Heuristic(IAIPathNode from, IAIPathNode to)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(from.Position, to.Position);
	}

	public static bool FindPath(IAIPathNode start, IAIPathNode goal, out Stack<IAIPathNode> path, out float pathCost)
	{
		path = null;
		pathCost = -1f;
		bool result = false;
		if (start == goal)
		{
			return false;
		}
		AStarNodeList aStarNodeList = new AStarNodeList();
		HashSet<IAIPathNode> hashSet = new HashSet<IAIPathNode>();
		AStarNode item = new AStarNode(0f, Heuristic(start, goal), null, start);
		aStarNodeList.Add(item);
		while (aStarNodeList.Count > 0)
		{
			AStarNode aStarNode = aStarNodeList[0];
			aStarNodeList.RemoveAt(0);
			hashSet.Add(aStarNode.Node);
			if (aStarNode.Satisfies(goal))
			{
				path = new Stack<IAIPathNode>();
				pathCost = 0f;
				while (aStarNode.Parent != null)
				{
					pathCost += aStarNode.F;
					path.Push(aStarNode.Node);
					aStarNode = aStarNode.Parent;
				}
				if (aStarNode != null)
				{
					path.Push(aStarNode.Node);
				}
				result = true;
				break;
			}
			foreach (IAIPathNode item2 in aStarNode.Node.Linked)
			{
				if (!hashSet.Contains(item2))
				{
					float num = aStarNode.G + Heuristic(aStarNode.Node, item2);
					AStarNode aStarNodeOf = aStarNodeList.GetAStarNodeOf(item2);
					if (aStarNodeOf == null)
					{
						aStarNodeOf = new AStarNode(num, Heuristic(item2, goal), aStarNode, item2);
						aStarNodeList.Add(aStarNodeOf);
						aStarNodeList.AStarNodeSort();
					}
					else if (num < aStarNodeOf.G)
					{
						aStarNodeOf.Update(num, aStarNodeOf.H, aStarNode, item2);
						aStarNodeList.AStarNodeSort();
					}
				}
			}
		}
		return result;
	}
}


using Rust.Ai;

public class AStarNode
{
	public AStarNode Parent;

	public float G;

	public float H;

	public IAIPathNode Node;

	public float F => G + H;

	public AStarNode(float g, float h, AStarNode parent, IAIPathNode node)
	{
		G = g;
		H = h;
		Parent = parent;
		Node = node;
	}

	public void Update(float g, float h, AStarNode parent, IAIPathNode node)
	{
		G = g;
		H = h;
		Parent = parent;
		Node = node;
	}

	public bool Satisfies(IAIPathNode node)
	{
		return Node == node;
	}

	public static bool operator <(AStarNode lhs, AStarNode rhs)
	{
		return lhs.F < rhs.F;
	}

	public static bool operator >(AStarNode lhs, AStarNode rhs)
	{
		return lhs.F > rhs.F;
	}
}


using System.Collections.Generic;
using Rust.Ai;

public class AStarNodeList : List<AStarNode>
{
	private class AStarNodeComparer : IComparer<AStarNode>
	{
		int IComparer<AStarNode>.Compare(AStarNode lhs, AStarNode rhs)
		{
			if (lhs < rhs)
			{
				return -1;
			}
			if (lhs > rhs)
			{
				return 1;
			}
			return 0;
		}
	}

	private readonly AStarNodeComparer comparer = new AStarNodeComparer();

	public bool Contains(IAIPathNode n)
	{
		for (int i = 0; i < base.Count; i++)
		{
			AStarNode aStarNode = base[i];
			if (aStarNode != null && aStarNode.Node.Equals(n))
			{
				return true;
			}
		}
		return false;
	}

	public AStarNode GetAStarNodeOf(IAIPathNode n)
	{
		for (int i = 0; i < base.Count; i++)
		{
			AStarNode aStarNode = base[i];
			if (aStarNode != null && aStarNode.Node.Equals(n))
			{
				return aStarNode;
			}
		}
		return null;
	}

	public void AStarNodeSort()
	{
		Sort(comparer);
	}
}


using System.Collections.Generic;

private class AStarNodeComparer : IComparer<AStarNode>
{
	int IComparer<AStarNode>.Compare(AStarNode lhs, AStarNode rhs)
	{
		if (lhs < rhs)
		{
			return -1;
		}
		if (lhs > rhs)
		{
			return 1;
		}
		return 0;
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust.Ai;
using UnityEngine;

public class SimpleAIMemory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public static HashSet<BasePlayer> PlayerIgnoreList = new HashSet<BasePlayer>();

	[NonSerialized]
	public List<SeenInfo> All = new List<SeenInfo>();

	[NonSerialized]
	public List<BaseEntity> Players = new List<BaseEntity>();

	[NonSerialized]
	public HashSet<BaseEntity> LOS = new HashSet<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Targets = new List<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Threats = new List<BaseEntity>();

	[NonSerialized]
	public List<BaseEntity> Friendlies = new List<BaseEntity>();

	public void SetKnown(BaseEntity ent, BaseEntity owner, AIBrainSenses brainSenses)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnNpcTargetSense", (object)owner, (object)ent, (object)brainSenses) != null)
		{
			return;
		}
		IAISenses iAISenses = owner as IAISenses;
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null && PlayerIgnoreList.Contains(basePlayer))
		{
			return;
		}
		bool flag = false;
		if (iAISenses != null && iAISenses.IsThreat(ent))
		{
			flag = true;
			if (brainSenses != null)
			{
				brainSenses.LastThreatTimestamp = Time.realtimeSinceStartup;
			}
		}
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo value = All[i];
				value.Position = ((Component)ent).transform.position;
				value.Timestamp = Mathf.Max(Time.realtimeSinceStartup, value.Timestamp);
				All[i] = value;
				return;
			}
		}
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (AI.ignoreplayers && !basePlayer.IsNpc)
			{
				return;
			}
			Players.Add(ent);
		}
		if (iAISenses != null)
		{
			if (iAISenses.IsTarget(ent))
			{
				Targets.Add(ent);
			}
			if (iAISenses.IsFriendly(ent))
			{
				Friendlies.Add(ent);
			}
			if (flag)
			{
				Threats.Add(ent);
			}
		}
		All.Add(new SeenInfo
		{
			Entity = ent,
			Position = ((Component)ent).transform.position,
			Timestamp = Time.realtimeSinceStartup
		});
	}

	public void SetLOS(BaseEntity ent, bool flag)
	{
		if (!((Object)(object)ent == (Object)null))
		{
			if (flag)
			{
				LOS.Add(ent);
			}
			else
			{
				LOS.Remove(ent);
			}
		}
	}

	public bool IsLOS(BaseEntity ent)
	{
		return LOS.Contains(ent);
	}

	public bool IsPlayerKnown(BasePlayer player)
	{
		return Players.Contains(player);
	}

	public void Forget(float secondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			if (!(Time.realtimeSinceStartup - All[i].Timestamp >= secondsOld))
			{
				continue;
			}
			BaseEntity entity = All[i].Entity;
			if ((Object)(object)entity != (Object)null)
			{
				if (entity is BasePlayer)
				{
					Players.Remove(entity);
				}
				Targets.Remove(entity);
				Threats.Remove(entity);
				Friendlies.Remove(entity);
				LOS.Remove(entity);
			}
			All.RemoveAt(i);
			i--;
		}
	}

	public static void AddIgnorePlayer(BasePlayer player)
	{
		if (!PlayerIgnoreList.Contains(player))
		{
			PlayerIgnoreList.Add(player);
		}
	}

	public static void RemoveIgnorePlayer(BasePlayer player)
	{
		PlayerIgnoreList.Remove(player);
	}

	public static void ClearIgnoredPlayers()
	{
		PlayerIgnoreList.Clear();
	}

	public static string GetIgnoredPlayers()
	{
		TextTable val = Pool.Get<TextTable>();
		try
		{
			val.AddColumns(new string[2] { "Name", "Steam ID" });
			foreach (BasePlayer playerIgnore in PlayerIgnoreList)
			{
				val.AddRow(new string[2]
				{
					playerIgnore.displayName,
					playerIgnore.userID.ToString()
				});
			}
			return ((object)val).ToString();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using System.Collections;
using Rust.Ai;
using UnityEngine;

public class CoverPoint
{
	public enum CoverType
	{
		Full,
		Partial,
		None
	}

	public CoverType NormalCoverType;

	public bool IsDynamic;

	public Transform SourceTransform;

	private Vector3 _staticPosition;

	private Vector3 _staticNormal;

	public CoverPointVolume Volume { get; private set; }

	public Vector3 Position
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (IsDynamic && (Object)(object)SourceTransform != (Object)null)
			{
				return SourceTransform.position;
			}
			return _staticPosition;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_staticPosition = value;
		}
	}

	public Vector3 Normal
	{
		get
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if (IsDynamic && (Object)(object)SourceTransform != (Object)null)
			{
				return SourceTransform.forward;
			}
			return _staticNormal;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			_staticNormal = value;
		}
	}

	public BaseEntity ReservedFor { get; set; }

	public bool IsReserved => (Object)(object)ReservedFor != (Object)null;

	public bool IsCompromised { get; set; }

	public float Score { get; set; }

	public bool IsValidFor(BaseEntity entity)
	{
		if (!IsCompromised)
		{
			if (!((Object)(object)ReservedFor == (Object)null))
			{
				return (Object)(object)ReservedFor == (Object)(object)entity;
			}
			return true;
		}
		return false;
	}

	public CoverPoint(CoverPointVolume volume, float score)
	{
		Volume = volume;
		Score = score;
	}

	public void CoverIsCompromised(float cooldown)
	{
		if (!IsCompromised && (Object)(object)Volume != (Object)null)
		{
			((MonoBehaviour)Volume).StartCoroutine(StartCooldown(cooldown));
		}
	}

	private IEnumerator StartCooldown(float cooldown)
	{
		IsCompromised = true;
		yield return CoroutineEx.waitForSeconds(cooldown);
		IsCompromised = false;
	}

	public bool ProvidesCoverFromPoint(Vector3 point, float arcThreshold)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Position - point;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return Vector3.Dot(Normal, normalized) < arcThreshold;
	}
}


public enum CoverType
{
	Full,
	Partial,
	None
}


using UnityEngine;

[RequireComponent(typeof(Collider))]
public class CoverPointBlockerVolume : MonoBehaviour
{
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class CoverPointVolume : MonoBehaviour, IServerComponent
{
	internal enum CoverType
	{
		None,
		Partial,
		Full
	}

	public float DefaultCoverPointScore = 1f;

	public float CoverPointRayLength = 1f;

	public LayerMask CoverLayerMask;

	public Transform BlockerGroup;

	public Transform ManualCoverPointGroup;

	[ServerVar(Help = "cover_point_sample_step_size defines the size of the steps we do horizontally for the cover point volume's cover point generation (smaller steps gives more accurate cover points, but at a higher processing cost). (default: 6.0)")]
	public static float cover_point_sample_step_size = 6f;

	[ServerVar(Help = "cover_point_sample_step_height defines the height of the steps we do vertically for the cover point volume's cover point generation (smaller steps gives more accurate cover points, but at a higher processing cost). (default: 2.0)")]
	public static float cover_point_sample_step_height = 2f;

	public readonly List<CoverPoint> CoverPoints = new List<CoverPoint>();

	private readonly List<CoverPointBlockerVolume> _coverPointBlockers = new List<CoverPointBlockerVolume>();

	private float _dynNavMeshBuildCompletionTime = -1f;

	private int _genAttempts;

	private Bounds bounds = new Bounds(Vector3.zero, Vector3.zero);

	public bool repeat => true;

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (CoverPoints.Count == 0)
		{
			if (_dynNavMeshBuildCompletionTime < 0f)
			{
				if ((Object)(object)SingletonComponent<DynamicNavMesh>.Instance == (Object)null || !((Behaviour)SingletonComponent<DynamicNavMesh>.Instance).enabled || !SingletonComponent<DynamicNavMesh>.Instance.IsBuilding)
				{
					_dynNavMeshBuildCompletionTime = Time.realtimeSinceStartup;
				}
			}
			else if (_genAttempts < 4 && Time.realtimeSinceStartup - _dynNavMeshBuildCompletionTime > 0.25f)
			{
				GenerateCoverPoints(null);
				if (CoverPoints.Count != 0)
				{
					return null;
				}
				_dynNavMeshBuildCompletionTime = Time.realtimeSinceStartup;
				_genAttempts++;
				if (_genAttempts >= 4)
				{
					Object.Destroy((Object)(object)((Component)this).gameObject);
					return null;
				}
			}
		}
		return 1f + Random.value * 2f;
	}

	[ContextMenu("Clear Cover Points")]
	private void ClearCoverPoints()
	{
		CoverPoints.Clear();
		_coverPointBlockers.Clear();
	}

	public Bounds GetBounds()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = ((Bounds)(ref bounds)).center;
		if (Mathf.Approximately(((Vector3)(ref center)).sqrMagnitude, 0f))
		{
			bounds = new Bounds(((Component)this).transform.position, ((Component)this).transform.localScale);
		}
		return bounds;
	}

	[ContextMenu("Pre-Generate Cover Points")]
	public void PreGenerateCoverPoints()
	{
		GenerateCoverPoints(null);
	}

	[ContextMenu("Convert to Manual Cover Points")]
	public void ConvertToManualCoverPoints()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		foreach (CoverPoint coverPoint in CoverPoints)
		{
			ManualCoverPoint manualCoverPoint = new GameObject("MCP").AddComponent<ManualCoverPoint>();
			((Component)manualCoverPoint).transform.localPosition = Vector3.zero;
			((Component)manualCoverPoint).transform.position = coverPoint.Position;
			manualCoverPoint.Normal = coverPoint.Normal;
			manualCoverPoint.NormalCoverType = coverPoint.NormalCoverType;
			manualCoverPoint.Volume = this;
		}
	}

	public void GenerateCoverPoints(Transform coverPointGroup)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		_ = Time.realtimeSinceStartup;
		ClearCoverPoints();
		if ((Object)(object)ManualCoverPointGroup == (Object)null)
		{
			ManualCoverPointGroup = coverPointGroup;
		}
		if ((Object)(object)ManualCoverPointGroup == (Object)null)
		{
			ManualCoverPointGroup = ((Component)this).transform;
		}
		if (ManualCoverPointGroup.childCount > 0)
		{
			ManualCoverPoint[] componentsInChildren = ((Component)ManualCoverPointGroup).GetComponentsInChildren<ManualCoverPoint>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				CoverPoint item = componentsInChildren[i].ToCoverPoint(this);
				CoverPoints.Add(item);
			}
		}
		if (_coverPointBlockers.Count == 0 && (Object)(object)BlockerGroup != (Object)null)
		{
			CoverPointBlockerVolume[] componentsInChildren2 = ((Component)BlockerGroup).GetComponentsInChildren<CoverPointBlockerVolume>();
			if (componentsInChildren2 != null && componentsInChildren2.Length != 0)
			{
				_coverPointBlockers.AddRange(componentsInChildren2);
			}
		}
		NavMeshHit val = default(NavMeshHit);
		if (CoverPoints.Count != 0 || !NavMesh.SamplePosition(((Component)this).transform.position, ref val, ((Component)this).transform.localScale.y * cover_point_sample_step_height, -1))
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 val2 = ((Component)this).transform.lossyScale * 0.5f;
		NavMeshHit info = default(NavMeshHit);
		for (float num = position.x - val2.x + 1f; num < position.x + val2.x - 1f; num += cover_point_sample_step_size)
		{
			for (float num2 = position.z - val2.z + 1f; num2 < position.z + val2.z - 1f; num2 += cover_point_sample_step_size)
			{
				for (float num3 = position.y - val2.y; num3 < position.y + val2.y; num3 += cover_point_sample_step_height)
				{
					if (!NavMesh.FindClosestEdge(new Vector3(num, num3, num2), ref info, ((NavMeshHit)(ref val)).mask))
					{
						continue;
					}
					((NavMeshHit)(ref info)).position = new Vector3(((NavMeshHit)(ref info)).position.x, ((NavMeshHit)(ref info)).position.y + 0.5f, ((NavMeshHit)(ref info)).position.z);
					bool flag = true;
					foreach (CoverPoint coverPoint2 in CoverPoints)
					{
						Vector3 val3 = coverPoint2.Position - ((NavMeshHit)(ref info)).position;
						if (((Vector3)(ref val3)).sqrMagnitude < cover_point_sample_step_size * cover_point_sample_step_size)
						{
							flag = false;
							break;
						}
					}
					if (flag)
					{
						CoverPoint coverPoint = CalculateCoverPoint(info);
						if (coverPoint != null)
						{
							CoverPoints.Add(coverPoint);
						}
					}
				}
			}
		}
	}

	private CoverPoint CalculateCoverPoint(NavMeshHit info)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit rayHit;
		CoverType coverType = ProvidesCoverInDir(new Ray(((NavMeshHit)(ref info)).position, -((NavMeshHit)(ref info)).normal), CoverPointRayLength, out rayHit);
		if (coverType == CoverType.None)
		{
			return null;
		}
		CoverPoint coverPoint = new CoverPoint(this, DefaultCoverPointScore)
		{
			Position = ((NavMeshHit)(ref info)).position,
			Normal = -((NavMeshHit)(ref info)).normal
		};
		switch (coverType)
		{
		case CoverType.Full:
			coverPoint.NormalCoverType = CoverPoint.CoverType.Full;
			break;
		case CoverType.Partial:
			coverPoint.NormalCoverType = CoverPoint.CoverType.Partial;
			break;
		}
		return coverPoint;
	}

	internal CoverType ProvidesCoverInDir(Ray ray, float maxDistance, out RaycastHit rayHit)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		rayHit = default(RaycastHit);
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).origin))
		{
			return CoverType.None;
		}
		if (Vector3Ex.IsNaNOrInfinity(((Ray)(ref ray)).direction))
		{
			return CoverType.None;
		}
		if (((Ray)(ref ray)).direction == Vector3.zero)
		{
			return CoverType.None;
		}
		((Ray)(ref ray)).origin = ((Ray)(ref ray)).origin + PlayerEyes.EyeOffset;
		if (Physics.Raycast(((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction, ref rayHit, maxDistance, LayerMask.op_Implicit(CoverLayerMask)))
		{
			return CoverType.Full;
		}
		((Ray)(ref ray)).origin = ((Ray)(ref ray)).origin + PlayerEyes.DuckOffset;
		if (Physics.Raycast(((Ray)(ref ray)).origin, ((Ray)(ref ray)).direction, ref rayHit, maxDistance, LayerMask.op_Implicit(CoverLayerMask)))
		{
			return CoverType.Partial;
		}
		return CoverType.None;
	}

	public bool Contains(Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Bounds val = default(Bounds);
		((Bounds)(ref val))..ctor(((Component)this).transform.position, ((Component)this).transform.localScale);
		return ((Bounds)(ref val)).Contains(point);
	}
}


internal enum CoverType
{
	None,
	Partial,
	Full
}


using Rust.Ai;
using UnityEngine;

public class ManualCoverPoint : FacepunchBehaviour
{
	public bool IsDynamic;

	public float Score = 2f;

	public CoverPointVolume Volume;

	public Vector3 Normal;

	public CoverPoint.CoverType NormalCoverType;

	public Vector3 Position => ((Component)this).transform.position;

	public float DirectionMagnitude
	{
		get
		{
			if ((Object)(object)Volume != (Object)null)
			{
				return Volume.CoverPointRayLength;
			}
			return 1f;
		}
	}

	private void Awake()
	{
		if ((Object)(object)((Component)this).transform.parent != (Object)null)
		{
			Volume = ((Component)((Component)this).transform.parent).GetComponent<CoverPointVolume>();
		}
	}

	public CoverPoint ToCoverPoint(CoverPointVolume volume)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Volume = volume;
		if (IsDynamic)
		{
			CoverPoint obj = new CoverPoint(Volume, Score)
			{
				IsDynamic = true,
				SourceTransform = ((Component)this).transform,
				NormalCoverType = NormalCoverType
			};
			Transform transform = ((Component)this).transform;
			obj.Position = ((transform != null) ? transform.position : Vector3.zero);
			return obj;
		}
		Vector3 val = ((Component)this).transform.rotation * Normal;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return new CoverPoint(Volume, Score)
		{
			IsDynamic = false,
			Position = ((Component)this).transform.position,
			Normal = normalized,
			NormalCoverType = NormalCoverType
		};
	}
}


using System;
using Rust;
using Rust.Ai;
using UnityEngine;

[DefaultExecutionOrder(-102)]
public class AiManagedAgent : FacepunchBehaviour, IServerComponent
{
	[Tooltip("TODO: Replace with actual agent type id on the NavMeshAgent when we upgrade to 5.6.1 or above.")]
	public int AgentTypeIndex;

	[NonSerialized]
	[ReadOnly]
	public Vector2i NavmeshGridCoord;

	private bool isRegistered;

	private void OnEnable()
	{
		isRegistered = false;
		if ((Object)(object)SingletonComponent<AiManager>.Instance == (Object)null || !((Behaviour)SingletonComponent<AiManager>.Instance).enabled || AiManager.nav_disable)
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void DelayedRegistration()
	{
		if (!isRegistered)
		{
			isRegistered = true;
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && !((Object)(object)SingletonComponent<AiManager>.Instance == (Object)null) && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled)
		{
			_ = isRegistered;
		}
	}
}


using System;
using Rust;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

[DefaultExecutionOrder(-103)]
public class AiManager : SingletonComponent<AiManager>, IServerComponent
{
	[SerializeField]
	[Header("Cover System")]
	public bool UseCover = true;

	public float CoverPointVolumeCellSize = 20f;

	public float CoverPointVolumeCellHeight = 8f;

	public float CoverPointRayLength = 1f;

	public CoverPointVolume cpvPrefab;

	[SerializeField]
	public LayerMask DynamicCoverPointVolumeLayerMask;

	private WorldSpaceGrid<CoverPointVolume> coverPointVolumeGrid;

	[ServerVar(Help = "If true we'll wait for the navmesh to generate before completely starting the server. This might cause your server to hitch and lag as it generates in the background.")]
	public static bool nav_wait = true;

	[ServerVar(Help = "If set to true the navmesh won't generate.. which means Ai that uses the navmesh won't be able to move")]
	public static bool nav_disable = false;

	[ServerVar(Help = "If set to true, npcs will attempt to place themselves on the navmesh if not on a navmesh when set destination is called.")]
	public static bool setdestination_navmesh_failsafe = false;

	[ServerVar(Help = "If ai_dormant is true, any npc outside the range of players will render itself dormant and take up less resources, but wildlife won't simulate as well.")]
	public static bool ai_dormant = true;

	[ServerVar(Help = "If an agent is beyond this distance to a player, it's flagged for becoming dormant.")]
	public static float ai_to_player_distance_wakeup_range = 160f;

	[ServerVar(Help = "nav_obstacles_carve_state defines which obstacles can carve the terrain. 0 - No carving, 1 - Only player construction carves, 2 - All obstacles carve.")]
	public static int nav_obstacles_carve_state = 2;

	[ServerVar(Help = "ai_dormant_max_wakeup_per_tick defines the maximum number of dormant agents we will wake up in a single tick. (default: 30)")]
	public static int ai_dormant_max_wakeup_per_tick = 30;

	[ServerVar(Help = "ai_htn_player_tick_budget defines the maximum amount of milliseconds ticking htn player agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_player_junkpile_tick_budget defines the maximum amount of milliseconds ticking htn player junkpile agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_player_junkpile_tick_budget = 4f;

	[ServerVar(Help = "ai_htn_animal_tick_budget defines the maximum amount of milliseconds ticking htn animal agents are allowed to consume. (default: 4 ms)")]
	public static float ai_htn_animal_tick_budget = 4f;

	[ServerVar(Help = "If ai_htn_use_agency_tick is true, the ai manager's agency system will tick htn agents at the ms budgets defined in ai_htn_player_tick_budget and ai_htn_animal_tick_budget. If it's false, each agent registers with the invoke system individually, with no frame-budget restrictions. (default: true)")]
	public static bool ai_htn_use_agency_tick = true;

	private readonly BasePlayer[] playerVicinityQuery = new BasePlayer[1];

	private readonly Func<BasePlayer, bool> filter = InterestedInPlayersOnly;

	[ServerVar(Help = "The maximum amount of nodes processed each frame in the asynchronous pathfinding process. Increasing this value will cause the paths to be processed faster, but can cause some hiccups in frame rate. Default value is 100, a good range for tuning is between 50 and 500.")]
	public static int pathfindingIterationsPerFrame
	{
		get
		{
			return NavMesh.pathfindingIterationsPerFrame;
		}
		set
		{
			NavMesh.pathfindingIterationsPerFrame = value;
		}
	}

	public bool repeat => true;

	internal void OnEnableAgency()
	{
	}

	internal void OnDisableAgency()
	{
	}

	internal void UpdateAgency()
	{
	}

	internal void OnEnableCover()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			Vector3 size = TerrainMeta.Size;
			coverPointVolumeGrid = new WorldSpaceGrid<CoverPointVolume>(size.x, CoverPointVolumeCellSize, (RoundingMode)0);
		}
	}

	internal void OnDisableCover()
	{
		if (coverPointVolumeGrid != null && coverPointVolumeGrid.Cells != null)
		{
			for (int i = 0; i < coverPointVolumeGrid.Cells.Length; i++)
			{
				Object.Destroy((Object)(object)coverPointVolumeGrid.Cells[i]);
			}
		}
	}

	public static CoverPointVolume CreateNewCoverVolume(Vector3 point, Transform coverPointGroup)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<AiManager>.Instance != (Object)null && ((Behaviour)SingletonComponent<AiManager>.Instance).enabled && SingletonComponent<AiManager>.Instance.UseCover)
		{
			CoverPointVolume coverPointVolume = SingletonComponent<AiManager>.Instance.GetCoverVolumeContaining(point);
			if ((Object)(object)coverPointVolume == (Object)null)
			{
				Vector2i val = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.WorldToGridCoords(point);
				coverPointVolume = ((!((Object)(object)SingletonComponent<AiManager>.Instance.cpvPrefab != (Object)null)) ? new GameObject("CoverPointVolume").AddComponent<CoverPointVolume>() : Object.Instantiate<CoverPointVolume>(SingletonComponent<AiManager>.Instance.cpvPrefab));
				((Component)coverPointVolume).transform.localPosition = default(Vector3);
				((Component)coverPointVolume).transform.position = SingletonComponent<AiManager>.Instance.coverPointVolumeGrid.GridToWorldCoords(val) + Vector3.up * point.y;
				((Component)coverPointVolume).transform.localScale = new Vector3(SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellHeight, SingletonComponent<AiManager>.Instance.CoverPointVolumeCellSize);
				coverPointVolume.CoverLayerMask = SingletonComponent<AiManager>.Instance.DynamicCoverPointVolumeLayerMask;
				coverPointVolume.CoverPointRayLength = SingletonComponent<AiManager>.Instance.CoverPointRayLength;
				SingletonComponent<AiManager>.Instance.coverPointVolumeGrid[val] = coverPointVolume;
				coverPointVolume.GenerateCoverPoints(coverPointGroup);
			}
			return coverPointVolume;
		}
		return null;
	}

	public CoverPointVolume GetCoverVolumeContaining(Vector3 point)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (coverPointVolumeGrid == null)
		{
			return null;
		}
		Vector2i val = coverPointVolumeGrid.WorldToGridCoords(point);
		return coverPointVolumeGrid[val];
	}

	public void Initialize()
	{
		OnEnableAgency();
		if (UseCover)
		{
			OnEnableCover();
		}
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			OnDisableAgency();
			if (UseCover)
			{
				OnDisableCover();
			}
		}
	}

	public float? ExecuteUpdate(float deltaTime, float nextInterval)
	{
		if (nav_disable)
		{
			return nextInterval;
		}
		UpdateAgency();
		return Random.value + 1f;
	}

	private static bool InterestedInPlayersOnly(BaseEntity entity)
	{
		BasePlayer basePlayer = entity as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null)
		{
			return false;
		}
		if (basePlayer.IsSleeping() || !basePlayer.IsConnected)
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class Memory
{
	public struct SeenInfo
	{
		public BaseEntity Entity;

		public Vector3 Position;

		public float Timestamp;

		public float Danger;
	}

	public struct ExtendedInfo
	{
		public BaseEntity Entity;

		public Vector3 Direction;

		public float Dot;

		public float DistanceSqr;

		public byte LineOfSight;

		public float LastHurtUsTime;
	}

	public List<BaseEntity> Visible = new List<BaseEntity>();

	public List<SeenInfo> All = new List<SeenInfo>();

	public List<ExtendedInfo> AllExtended = new List<ExtendedInfo>();

	public SeenInfo Update(BaseEntity entity, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return Update(entity, entity.ServerPosition, score, direction, dot, distanceSqr, lineOfSight, updateLastHurtUsTime, lastHurtUsTime, out extendedInfo);
	}

	public SeenInfo Update(BaseEntity entity, Vector3 position, float score, Vector3 direction, float dot, float distanceSqr, byte lineOfSight, bool updateLastHurtUsTime, float lastHurtUsTime, out ExtendedInfo extendedInfo)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		extendedInfo = default(ExtendedInfo);
		bool flag = false;
		for (int i = 0; i < AllExtended.Count; i++)
		{
			if ((Object)(object)AllExtended[i].Entity == (Object)(object)entity)
			{
				ExtendedInfo extendedInfo2 = AllExtended[i];
				extendedInfo2.Direction = direction;
				extendedInfo2.Dot = dot;
				extendedInfo2.DistanceSqr = distanceSqr;
				extendedInfo2.LineOfSight = lineOfSight;
				if (updateLastHurtUsTime)
				{
					extendedInfo2.LastHurtUsTime = lastHurtUsTime;
				}
				AllExtended[i] = extendedInfo2;
				extendedInfo = extendedInfo2;
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			if (updateLastHurtUsTime)
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				extendedInfo3.LastHurtUsTime = lastHurtUsTime;
				ExtendedInfo extendedInfo4 = extendedInfo3;
				AllExtended.Add(extendedInfo4);
				extendedInfo = extendedInfo4;
			}
			else
			{
				ExtendedInfo extendedInfo3 = default(ExtendedInfo);
				extendedInfo3.Entity = entity;
				extendedInfo3.Direction = direction;
				extendedInfo3.Dot = dot;
				extendedInfo3.DistanceSqr = distanceSqr;
				extendedInfo3.LineOfSight = lineOfSight;
				ExtendedInfo extendedInfo5 = extendedInfo3;
				AllExtended.Add(extendedInfo5);
				extendedInfo = extendedInfo5;
			}
		}
		return Update(entity, position, score);
	}

	public SeenInfo Update(BaseEntity ent, float danger = 0f)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return Update(ent, ent.ServerPosition, danger);
	}

	public SeenInfo Update(BaseEntity ent, Vector3 position, float danger = 0f)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if ((Object)(object)All[i].Entity == (Object)(object)ent)
			{
				SeenInfo seenInfo = All[i];
				seenInfo.Position = position;
				seenInfo.Timestamp = Time.realtimeSinceStartup;
				seenInfo.Danger += danger;
				All[i] = seenInfo;
				return seenInfo;
			}
		}
		SeenInfo seenInfo2 = default(SeenInfo);
		seenInfo2.Entity = ent;
		seenInfo2.Position = position;
		seenInfo2.Timestamp = Time.realtimeSinceStartup;
		seenInfo2.Danger = danger;
		SeenInfo seenInfo3 = seenInfo2;
		All.Add(seenInfo3);
		Visible.Add(ent);
		return seenInfo3;
	}

	public void AddDanger(Vector3 position, float amount)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < All.Count; i++)
		{
			if (Mathf.Approximately(All[i].Position.x, position.x) && Mathf.Approximately(All[i].Position.y, position.y) && Mathf.Approximately(All[i].Position.z, position.z))
			{
				SeenInfo value = All[i];
				value.Danger = amount;
				All[i] = value;
				return;
			}
		}
		All.Add(new SeenInfo
		{
			Position = position,
			Timestamp = Time.realtimeSinceStartup,
			Danger = amount
		});
	}

	public SeenInfo GetInfo(BaseEntity entity)
	{
		foreach (SeenInfo item in All)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public SeenInfo GetInfo(Vector3 position)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		foreach (SeenInfo item in All)
		{
			Vector3 val = item.Position - position;
			if (((Vector3)(ref val)).sqrMagnitude < 1f)
			{
				return item;
			}
		}
		return default(SeenInfo);
	}

	public ExtendedInfo GetExtendedInfo(BaseEntity entity)
	{
		foreach (ExtendedInfo item in AllExtended)
		{
			if ((Object)(object)item.Entity == (Object)(object)entity)
			{
				return item;
			}
		}
		return default(ExtendedInfo);
	}

	internal void Forget(float maxSecondsOld)
	{
		for (int i = 0; i < All.Count; i++)
		{
			float num = Time.realtimeSinceStartup - All[i].Timestamp;
			if (num > maxSecondsOld)
			{
				if ((Object)(object)All[i].Entity != (Object)null)
				{
					Visible.Remove(All[i].Entity);
					for (int j = 0; j < AllExtended.Count; j++)
					{
						if ((Object)(object)AllExtended[j].Entity == (Object)(object)All[i].Entity)
						{
							AllExtended.RemoveAt(j);
							break;
						}
					}
				}
				All.RemoveAt(i);
				i--;
			}
			else
			{
				if (!(num > 0f))
				{
					continue;
				}
				float num2 = num / maxSecondsOld;
				if (All[i].Danger > 0f)
				{
					SeenInfo value = All[i];
					value.Danger -= num2;
					All[i] = value;
				}
				if (!(num >= 1f))
				{
					continue;
				}
				for (int k = 0; k < AllExtended.Count; k++)
				{
					if ((Object)(object)AllExtended[k].Entity == (Object)(object)All[i].Entity)
					{
						ExtendedInfo value2 = AllExtended[k];
						value2.LineOfSight = 0;
						AllExtended[k] = value2;
						break;
					}
				}
			}
		}
		for (int l = 0; l < Visible.Count; l++)
		{
			if ((Object)(object)Visible[l] == (Object)null)
			{
				Visible.RemoveAt(l);
				l--;
			}
		}
		for (int m = 0; m < AllExtended.Count; m++)
		{
			if ((Object)(object)AllExtended[m].Entity == (Object)null)
			{
				AllExtended.RemoveAt(m);
				m--;
			}
		}
	}
}


using UnityEngine;

public struct SeenInfo
{
	public BaseEntity Entity;

	public Vector3 Position;

	public float Timestamp;

	public float Danger;
}


using UnityEngine;

public struct ExtendedInfo
{
	public BaseEntity Entity;

	public Vector3 Direction;

	public float Dot;

	public float DistanceSqr;

	public byte LineOfSight;

	public float LastHurtUsTime;
}


using UnityEngine;

public class NavmeshPrefabInstantiator : MonoBehaviour
{
	public GameObjectRef NavmeshPrefab;

	private void Start()
	{
		if (NavmeshPrefab != null)
		{
			NavmeshPrefab.Instantiate(((Component)this).transform).SetActive(true);
			Object.Destroy((Object)(object)this);
		}
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class ScientistSpawner : SpawnGroup
{
	[Header("Scientist Spawner")]
	public bool Mobile = true;

	public bool NeverMove;

	public bool SpawnHostile;

	public bool OnlyAggroMarkedTargets = true;

	public bool IsPeacekeeper = true;

	public bool IsBandit;

	public bool IsMilitaryTunnelLab;

	public WaypointSet Waypoints;

	public Transform[] LookAtInterestPointsStationary;

	public Vector2 RadioEffectRepeatRange = new Vector2(10f, 15f);

	public Model Model;

	[SerializeField]
	private AiLocationManager _mgr;

	private float _nextForcedRespawn = float.PositiveInfinity;

	private bool _lastSpawnCallHadAliveMembers;

	private bool _lastSpawnCallHadMaxAliveMembers;

	protected override void Spawn(int numToSpawn)
	{
		if (!AI.npc_enable)
		{
			return;
		}
		if (base.currentPopulation == maxPopulation)
		{
			_lastSpawnCallHadMaxAliveMembers = true;
			_lastSpawnCallHadAliveMembers = true;
			return;
		}
		if (_lastSpawnCallHadMaxAliveMembers)
		{
			_nextForcedRespawn = Time.time + 2200f;
		}
		if (Time.time < _nextForcedRespawn)
		{
			if (base.currentPopulation == 0 && _lastSpawnCallHadAliveMembers)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = false;
				return;
			}
			if (base.currentPopulation > 0)
			{
				_lastSpawnCallHadMaxAliveMembers = false;
				_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
				return;
			}
		}
		_lastSpawnCallHadMaxAliveMembers = false;
		_lastSpawnCallHadAliveMembers = base.currentPopulation > 0;
		base.Spawn(numToSpawn);
	}

	protected override void PostSpawnProcess(BaseEntity entity, BaseSpawnPoint spawnPoint)
	{
	}

	protected override void OnDrawGizmos()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		base.OnDrawGizmos();
		if (LookAtInterestPointsStationary == null || LookAtInterestPointsStationary.Length == 0)
		{
			return;
		}
		Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
		Transform[] lookAtInterestPointsStationary = LookAtInterestPointsStationary;
		foreach (Transform val in lookAtInterestPointsStationary)
		{
			if ((Object)(object)val != (Object)null)
			{
				Gizmos.DrawSphere(val.position, 0.1f);
				Gizmos.DrawLine(((Component)this).transform.position, val.position);
			}
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Rust.Ai;
using UnityEngine;
using UnityEngine.AI;

public class AiLocationManager : FacepunchBehaviour, IServerComponent
{
	public static List<AiLocationManager> Managers = new List<AiLocationManager>();

	[SerializeField]
	public AiLocationSpawner MainSpawner;

	[SerializeField]
	public AiLocationSpawner.SquadSpawnerLocation LocationWhenMainSpawnerIsNull = AiLocationSpawner.SquadSpawnerLocation.None;

	public Transform CoverPointGroup;

	public Transform PatrolPointGroup;

	public CoverPointVolume DynamicCoverPointVolume;

	public bool SnapCoverPointsToGround;

	private List<PathInterestNode> patrolPoints;

	public AiLocationSpawner.SquadSpawnerLocation LocationType
	{
		get
		{
			if ((Object)(object)MainSpawner != (Object)null)
			{
				return MainSpawner.Location;
			}
			return LocationWhenMainSpawnerIsNull;
		}
	}

	private void Awake()
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Managers.Add(this);
		if (!SnapCoverPointsToGround)
		{
			return;
		}
		AICoverPoint[] componentsInChildren = ((Component)CoverPointGroup).GetComponentsInChildren<AICoverPoint>();
		NavMeshHit val = default(NavMeshHit);
		foreach (AICoverPoint aICoverPoint in componentsInChildren)
		{
			if (NavMesh.SamplePosition(((Component)aICoverPoint).transform.position, ref val, 4f, -1))
			{
				((Component)aICoverPoint).transform.position = ((NavMeshHit)(ref val)).position;
			}
		}
	}

	private void OnDestroy()
	{
		Managers.Remove(this);
	}

	public PathInterestNode GetFirstPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		foreach (PathInterestNode patrolPoint in patrolPoints)
		{
			Vector3 val = ((Component)patrolPoint).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				return patrolPoint;
			}
		}
		return null;
	}

	public PathInterestNode GetRandomPatrolPointInRange(Vector3 from, float minRange = 10f, float maxRange = 100f, PathInterestNode currentPatrolPoint = null)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)PatrolPointGroup == (Object)null)
		{
			return null;
		}
		if (patrolPoints == null)
		{
			patrolPoints = new List<PathInterestNode>(((Component)PatrolPointGroup).GetComponentsInChildren<PathInterestNode>());
		}
		if (patrolPoints.Count == 0)
		{
			return null;
		}
		float num = minRange * minRange;
		float num2 = maxRange * maxRange;
		for (int i = 0; i < 20; i++)
		{
			PathInterestNode pathInterestNode = patrolPoints[Random.Range(0, patrolPoints.Count)];
			if (Time.time < pathInterestNode.NextVisitTime)
			{
				if ((Object)(object)pathInterestNode == (Object)(object)currentPatrolPoint)
				{
					return null;
				}
				continue;
			}
			Vector3 val = ((Component)pathInterestNode).transform.position - from;
			float sqrMagnitude = ((Vector3)(ref val)).sqrMagnitude;
			if (sqrMagnitude >= num && sqrMagnitude <= num2)
			{
				pathInterestNode.NextVisitTime = Time.time + AI.npc_patrol_point_cooldown;
				return pathInterestNode;
			}
		}
		return null;
	}
}


using ConVar;
using Rust.Ai;
using UnityEngine;

public class AiLocationSpawner : SpawnGroup
{
	public enum SquadSpawnerLocation
	{
		MilitaryTunnels,
		JunkpileA,
		JunkpileG,
		CH47,
		None,
		Compound,
		BanditTown,
		CargoShip
	}

	public SquadSpawnerLocation Location;

	public AiLocationManager Manager;

	public JunkPile Junkpile;

	public bool IsMainSpawner = true;

	public float chance = 1f;

	private int defaultMaxPopulation;

	private int defaultNumToSpawnPerTickMax;

	private int defaultNumToSpawnPerTickMin;

	public override void SpawnInitial()
	{
		if (IsMainSpawner)
		{
			if (Location == SquadSpawnerLocation.MilitaryTunnels)
			{
				maxPopulation = AI.npc_max_population_military_tunnels;
				numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
				numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
				respawnDelayMax = AI.npc_respawn_delay_max_military_tunnels;
				respawnDelayMin = AI.npc_respawn_delay_min_military_tunnels;
			}
			else
			{
				defaultMaxPopulation = maxPopulation;
				defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
				defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
			}
		}
		else
		{
			defaultMaxPopulation = maxPopulation;
			defaultNumToSpawnPerTickMax = numToSpawnPerTickMax;
			defaultNumToSpawnPerTickMin = numToSpawnPerTickMin;
		}
		base.SpawnInitial();
	}

	protected override void Spawn(int numToSpawn)
	{
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable)
		{
			maxPopulation = 0;
			numToSpawnPerTickMax = 0;
			numToSpawnPerTickMin = 0;
			return;
		}
		if (numToSpawn == 0)
		{
			if (IsMainSpawner)
			{
				if (Location == SquadSpawnerLocation.MilitaryTunnels)
				{
					maxPopulation = AI.npc_max_population_military_tunnels;
					numToSpawnPerTickMax = AI.npc_spawn_per_tick_max_military_tunnels;
					numToSpawnPerTickMin = AI.npc_spawn_per_tick_min_military_tunnels;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
				else
				{
					maxPopulation = defaultMaxPopulation;
					numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
					numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
					numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
				}
			}
			else
			{
				maxPopulation = defaultMaxPopulation;
				numToSpawnPerTickMax = defaultNumToSpawnPerTickMax;
				numToSpawnPerTickMin = defaultNumToSpawnPerTickMin;
				numToSpawn = Random.Range(numToSpawnPerTickMin, numToSpawnPerTickMax + 1);
			}
		}
		float npc_junkpilespawn_chance = chance;
		switch (Location)
		{
		case SquadSpawnerLocation.JunkpileA:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		case SquadSpawnerLocation.JunkpileG:
			npc_junkpilespawn_chance = AI.npc_junkpilespawn_chance;
			break;
		}
		if (numToSpawn == 0 || Random.value > npc_junkpilespawn_chance)
		{
			return;
		}
		numToSpawn = Mathf.Min(numToSpawn, maxPopulation - base.currentPopulation);
		for (int i = 0; i < numToSpawn; i++)
		{
			GameObjectRef prefab = GetPrefab();
			Vector3 pos;
			Quaternion rot;
			BaseSpawnPoint spawnPoint = GetSpawnPoint(prefab, out pos, out rot);
			if (Object.op_Implicit((Object)(object)spawnPoint))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(prefab.resourcePath, pos, rot);
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Spawn();
					SpawnPointInstance spawnPointInstance = ((Component)baseEntity).gameObject.AddComponent<SpawnPointInstance>();
					spawnPointInstance.parentSpawnPointUser = this;
					spawnPointInstance.parentSpawnPoint = spawnPoint;
					spawnPointInstance.Entity = baseEntity;
					spawnPointInstance.Notify();
				}
			}
		}
	}

	protected override BaseSpawnPoint GetSpawnPoint(GameObjectRef prefabRef, out Vector3 pos, out Quaternion rot)
	{
		return base.GetSpawnPoint(prefabRef, out pos, out rot);
	}
}


public enum SquadSpawnerLocation
{
	MilitaryTunnels,
	JunkpileA,
	JunkpileG,
	CH47,
	None,
	Compound,
	BanditTown,
	CargoShip
}


using System;
using System.Collections.Generic;
using Rust.Ai;
using UnityEngine;

public class WaypointSet : MonoBehaviour, IServerComponent
{
	public enum NavModes
	{
		Loop,
		PingPong
	}

	[Serializable]
	public struct Waypoint
	{
		public Transform Transform;

		public float WaitTime;

		public Transform[] LookatPoints;

		[NonSerialized]
		public bool IsOccupied;
	}

	[SerializeField]
	private List<Waypoint> _points = new List<Waypoint>();

	[SerializeField]
	private NavModes navMode;

	public List<Waypoint> Points
	{
		get
		{
			return _points;
		}
		set
		{
			_points = value;
		}
	}

	public NavModes NavMode => navMode;

	private void OnDrawGizmos()
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < Points.Count; i++)
		{
			Transform transform = Points[i].Transform;
			if ((Object)(object)transform != (Object)null)
			{
				if (Points[i].IsOccupied)
				{
					Gizmos.color = Color.red;
				}
				else
				{
					Gizmos.color = Color.cyan;
				}
				Gizmos.DrawSphere(transform.position, 0.25f);
				Gizmos.color = Color.cyan;
				if (i + 1 < Points.Count)
				{
					Gizmos.DrawLine(transform.position, Points[i + 1].Transform.position);
				}
				else if (NavMode == NavModes.Loop)
				{
					Gizmos.DrawLine(transform.position, Points[0].Transform.position);
				}
				Gizmos.color = Color.magenta - new Color(0f, 0f, 0f, 0.5f);
				Transform[] lookatPoints = Points[i].LookatPoints;
				foreach (Transform val in lookatPoints)
				{
					Gizmos.DrawSphere(val.position, 0.1f);
					Gizmos.DrawLine(transform.position, val.position);
				}
			}
		}
	}
}


public enum NavModes
{
	Loop,
	PingPong
}


using System;
using UnityEngine;

[Serializable]
public struct Waypoint
{
	public Transform Transform;

	public float WaitTime;

	public Transform[] LookatPoints;

	[NonSerialized]
	public bool IsOccupied;
}


using System;
using System.Collections.Generic;
using ConVar;
using Rust;
using Rust.Ai.HTN.ScientistJunkpile;
using UnityEngine;

public class ScientistJunkpileSpawner : MonoBehaviour, IServerComponent, ISpawnGroup
{
	public enum JunkpileType
	{
		A,
		B,
		C,
		D,
		E,
		F,
		G
	}

	public GameObjectRef ScientistPrefab;

	[NonSerialized]
	public List<BaseCombatEntity> Spawned = new List<BaseCombatEntity>();

	[NonSerialized]
	public BaseSpawnPoint[] SpawnPoints;

	public int MaxPopulation = 1;

	public bool InitialSpawn;

	public float MinRespawnTimeMinutes = 120f;

	public float MaxRespawnTimeMinutes = 120f;

	public float MovementRadius = -1f;

	public bool ReducedLongRangeAccuracy;

	public JunkpileType SpawnType;

	[Range(0f, 1f)]
	public float SpawnBaseChance = 1f;

	private float nextRespawnTime;

	private bool pendingRespawn;

	public int currentPopulation => Spawned.Count;

	private void Awake()
	{
		SpawnPoints = ((Component)this).GetComponentsInChildren<BaseSpawnPoint>();
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Add((ISpawnGroup)this);
		}
	}

	protected void OnDestroy()
	{
		if (Object.op_Implicit((Object)(object)SingletonComponent<SpawnHandler>.Instance))
		{
			SingletonComponent<SpawnHandler>.Instance.SpawnGroups.Remove((ISpawnGroup)this);
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": SpawnHandler instance not found."));
		}
	}

	public void Fill()
	{
		DoRespawn();
	}

	public void Clear()
	{
		if (Spawned == null)
		{
			return;
		}
		foreach (BaseCombatEntity item in Spawned)
		{
			if (!((Object)(object)item == (Object)null) && !((Object)(object)((Component)item).gameObject == (Object)null) && !((Object)(object)((Component)item).transform == (Object)null))
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					baseEntity.Kill();
				}
			}
		}
		Spawned.Clear();
	}

	public void SpawnInitial()
	{
		nextRespawnTime = Time.time + Random.Range(3f, 4f);
		pendingRespawn = true;
	}

	public void SpawnRepeating()
	{
		CheckIfRespawnNeeded();
	}

	public void CheckIfRespawnNeeded()
	{
		if (!pendingRespawn)
		{
			if (Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead())
			{
				ScheduleRespawn();
			}
		}
		else if ((Spawned == null || Spawned.Count == 0 || IsAllSpawnedDead()) && Time.time >= nextRespawnTime)
		{
			DoRespawn();
		}
	}

	private bool IsAllSpawnedDead()
	{
		int num = 0;
		while (num < Spawned.Count)
		{
			BaseCombatEntity baseCombatEntity = Spawned[num];
			if ((Object)(object)baseCombatEntity == (Object)null || (Object)(object)((Component)baseCombatEntity).transform == (Object)null || baseCombatEntity.IsDestroyed || baseCombatEntity.IsDead())
			{
				Spawned.RemoveAt(num);
				num--;
				num++;
				continue;
			}
			return false;
		}
		return true;
	}

	public void ScheduleRespawn()
	{
		nextRespawnTime = Time.time + Random.Range(MinRespawnTimeMinutes, MaxRespawnTimeMinutes) * 60f;
		pendingRespawn = true;
	}

	public void DoRespawn()
	{
		if (!Application.isLoading && !Application.isLoadingSave)
		{
			SpawnScientist();
		}
		pendingRespawn = false;
	}

	public void SpawnScientist()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (!AI.npc_enable || Spawned == null || Spawned.Count >= MaxPopulation)
		{
			return;
		}
		float num = SpawnBaseChance;
		switch (SpawnType)
		{
		case JunkpileType.A:
			num = AI.npc_junkpilespawn_chance;
			break;
		case JunkpileType.G:
			num = AI.npc_junkpilespawn_chance;
			break;
		}
		if (Random.value > num)
		{
			return;
		}
		int num2 = MaxPopulation - Spawned.Count;
		for (int i = 0; i < num2; i++)
		{
			if (!((Object)(object)GetSpawnPoint(out var pos, out var rot) == (Object)null))
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(ScientistPrefab.resourcePath, pos, rot, startActive: false);
				if (!((Object)(object)baseEntity != (Object)null))
				{
					break;
				}
				baseEntity.enableSaving = false;
				((Component)baseEntity).gameObject.AwakeFromInstantiate();
				baseEntity.Spawn();
				Spawned.Add((BaseCombatEntity)baseEntity);
			}
		}
	}

	private BaseSpawnPoint GetSpawnPoint(out Vector3 pos, out Quaternion rot)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		BaseSpawnPoint baseSpawnPoint = null;
		pos = Vector3.zero;
		rot = Quaternion.identity;
		int num = Random.Range(0, SpawnPoints.Length);
		for (int i = 0; i < SpawnPoints.Length; i++)
		{
			baseSpawnPoint = SpawnPoints[(num + i) % SpawnPoints.Length];
			if (Object.op_Implicit((Object)(object)baseSpawnPoint) && ((Component)baseSpawnPoint).gameObject.activeSelf)
			{
				break;
			}
		}
		if (Object.op_Implicit((Object)(object)baseSpawnPoint))
		{
			baseSpawnPoint.GetLocation(out pos, out rot);
		}
		return baseSpawnPoint;
	}
}


public enum JunkpileType
{
	A,
	B,
	C,
	D,
	E,
	F,
	G
}


using System;
using FIMSpace.FLook;
using FIMSpace.FSpine;
using FIMSpace.FTail;
using Network;
using Rust.Ai.Gen2;
using UnityEngine;

public class NPCAnimController : EntityComponent<BaseEntity>, IClientComponent
{
	public enum AnimatorType
	{
		NoStrafe,
		Strafe
	}

	[SerializeField]
	private string animationsPrefix = "wolf_";

	[SerializeField]
	private string[] animationBlacklist = new string[4] { "prowl", "walk", "trot", "run" };

	[ClientVar(ClientAdmin = true)]
	public static float lookInterpSpeed = 3f;

	[ClientVar(ClientAdmin = true)]
	public static float spineInterpSpeed = 3f;

	[SerializeField]
	private AnimatorType animatorType;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private FSpineAnimator spineAnimator;

	[SerializeField]
	private FLookAnimator lookAnimator;

	[SerializeField]
	private TailAnimator2 tailAnimator;

	[SerializeField]
	private float maxPitchToConformToSlope = 30f;

	[SerializeField]
	private bool onlyConformPitchToSlope = true;

	[SerializeField]
	private float posInterpSpeed = 10f;

	[SerializeField]
	private float rotInterpSpeed = 2f;

	[SerializeField]
	public bool enableLookAtDuringLocomotion = true;

	[SerializeField]
	public bool enableLookAtDuringProwl = true;

	[SerializeField]
	private AnimationClip[] animationsWithLookAt;

	[SerializeField]
	private AnimationClip[] animationsWithSpineDeform;

	public override bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		TimeWarning val = TimeWarning.New("NPCAnimController.OnRpcMessage", 0);
		try
		{
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		return base.OnRpcMessage(player, rpc, msg);
	}
}


public enum AnimatorType
{
	NoStrafe,
	Strafe
}


