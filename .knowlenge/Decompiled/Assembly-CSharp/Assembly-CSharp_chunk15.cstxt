using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class LoadingScreen : SingletonComponent<LoadingScreen>
{
	private bool _isOpen;

	[Header("Loading Screen References - UI")]
	public CanvasGroup panel;

	public CanvasGroup blackout;

	public NeedsCursor needsCursor;

	public TextMeshProUGUI title;

	public TextMeshProUGUI subtitle;

	public RawImage backgroundImage;

	public Texture2D defaultBackground;

	public GameObject infoHeader;

	public GameObject demoBlock;

	public GameObject serverBlock;

	public RustButton cancelButton;

	[Header("Loading Screen References - Server Info")]
	public RustText serverName;

	public RustText serverPlayers;

	public RustText serverMode;

	public RustText serverMap;

	public RustText serverWiped;

	public HttpImage serverLogoImage;

	public ServerBrowserTagList serverTags;

	[Header("Loading Screen References - Demo Info")]
	public RustText demoName;

	public RustText demoLength;

	public RustText demoDate;

	public RustText demoMap;

	[Header("Loading Screen References - Tips and Warnings")]
	public MenuTip menuTip;

	public GameObject performanceWarning;

	public GameObject pingWarning;

	public RustText pingWarningText;

	[Header("Loading Screen References - Audio")]
	public AudioSource music;

	[Tooltip("Ping must be at least this many ms higher than the server browser ping")]
	[Header("Loading Screen References - Settings")]
	public int minPingDiffToShowWarning = 50;

	[Tooltip("Ping must be this many times higher than the server browser ping")]
	public float pingDiffFactorToShowWarning = 2f;

	[Tooltip("Number of ping samples required before showing the warning")]
	public int requiredPingSampleCount = 10;

	public static Phrase pingWarningPhrase = new Phrase("loading.ping-warning", "<color=#FFF><size=20>PING WARNING</size></color>\nThis server's ping on the server browser ({0} ms) is much lower than the ping you are getting after connecting to the server ({1} ms). This could mean that this server is located far away and you will have a less than ideal playing experience while on this server.");

	public static Phrase vanillaPhrase = new Phrase("loading.mode.vanilla", "vanilla");

	public static bool isOpen
	{
		get
		{
			if ((Object)(object)SingletonComponent<LoadingScreen>.Instance != (Object)null)
			{
				return SingletonComponent<LoadingScreen>.Instance._isOpen;
			}
			return false;
		}
	}

	public static string Text { get; private set; }

	public static void Update(string strType)
	{
	}

	public static void Update(string strType, string strSubtitle)
	{
	}
}


using System;
using System.Collections.Generic;
using Development.Attributes;
using Rust.UI;
using UnityEngine;

[ResetStaticFields]
public class MainMenuSystem : SingletonComponent<MainMenuSystem>
{
	public static bool isOpen = true;

	public static Action OnOpenStateChanged;

	public RustButton SessionButton;

	public GameObject SessionPanel;

	public GameObject NewsStoriesAlert;

	public GameObject ItemStoreAlert;

	public GameObject CompanionAlert;

	public GameObject DemoBrowser;

	public GameObject DemoBrowserButton;

	public GameObject SuicideButton;

	public GameObject EndDemoButton;

	public List<GameObject> ReturnToOptionsPanels;

	public RustButton OptionsButton;

	public GameObject ReflexModeOption;

	public GameObject ReflexLatencyMarkerOption;

	[SerializeField]
	private GameObject QuitConfirmation;

	public GameObject QuitTutorialOption;

	[SerializeField]
	private GameObject Connection;

	[SerializeField]
	private UISafeZoneWarning safeZoneWarning;
}


using UnityEngine;

public class MenuBackgroundOverride : MonoBehaviour
{
	public Texture2D Background;

	public Color Tint = Color.white;
}


public class MenuBackgroundPanel : SingletonComponent<MenuBackgroundPanel>
{
	public CoverImage Image;

	public float FadeDuration = 0.15f;
}


using System;
using System.Collections;
using System.IO;
using System.Linq;
using Rust;
using UnityEngine;
using UnityEngine.Video;

public class MenuBackgroundVideo : SingletonComponent<MenuBackgroundVideo>
{
	[ClientVar]
	public static bool RestrictMP4 = true;

	private int index;

	private bool errored;

	private string[] mp4Videos;

	private string[] webmVideos;

	private bool forceWebmOnly;

	private VideoPlayer _videoPlayer;

	protected override void Awake()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Invalid comparison between Unknown and I4
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Expected O, but got Unknown
		((SingletonComponent)this).Awake();
		if (RestrictMP4)
		{
			forceWebmOnly = true;
		}
		_videoPlayer = ((Component)this).GetComponent<VideoPlayer>();
		_videoPlayer.source = (VideoSource)1;
		if ((int)Application.platform == 13 || (int)Application.platform == 16)
		{
			forceWebmOnly = true;
		}
		_videoPlayer.errorReceived += new ErrorEventHandler(OnVideoError);
		LoadVideoList();
		NextVideo();
	}

	private void OnVideoError(VideoPlayer source, string message)
	{
		errored = true;
		forceWebmOnly = true;
		_videoPlayer.Stop();
		NextVideo();
	}

	public void LoadVideoList()
	{
		string path = Path.Combine(Application.streamingAssetsPath, "MenuVideo");
		string path2 = Path.Combine(path, "mp4");
		string path3 = Path.Combine(path, "webm");
		if (Directory.Exists(path2))
		{
			mp4Videos = (from x in Directory.EnumerateFiles(path2, "*.mp4")
				orderby Guid.NewGuid()
				select x).ToArray();
		}
		else
		{
			mp4Videos = Array.Empty<string>();
		}
		if (Directory.Exists(path3))
		{
			webmVideos = (from x in Directory.EnumerateFiles(path3, "*.webm")
				orderby Guid.NewGuid()
				select x).ToArray();
		}
		else
		{
			webmVideos = Array.Empty<string>();
		}
	}

	public void Update()
	{
		if (Input.GetKeyDown((KeyCode)258))
		{
			LoadVideoList();
		}
		if (Input.GetKeyDown((KeyCode)257))
		{
			NextVideo();
		}
	}

	private void NextVideo()
	{
		if (Application.isQuitting)
		{
			return;
		}
		errored = false;
		string[] array = (forceWebmOnly ? webmVideos : mp4Videos);
		if (array.Length == 0)
		{
			Debug.LogWarning((object)"[MenuBackgroundVideo] No available videos to play.");
			return;
		}
		string text = array[index++ % array.Length];
		if (!forceWebmOnly && Global.LaunchCountThisVersion <= 3)
		{
			string text2 = mp4Videos.FirstOrDefault((string x) => x.EndsWith("whatsnew.mp4", StringComparison.OrdinalIgnoreCase));
			if (!string.IsNullOrEmpty(text2))
			{
				text = text2;
			}
		}
		_videoPlayer.url = "file://" + text;
		_videoPlayer.Play();
	}

	internal IEnumerator ReadyVideo()
	{
		if (!errored)
		{
			if ((Object)(object)_videoPlayer == (Object)null)
			{
				_videoPlayer = ((Component)this).GetComponent<VideoPlayer>();
			}
			NextVideo();
			while (!_videoPlayer.isPrepared && !errored)
			{
				yield return null;
			}
		}
	}

	[ClientVar]
	public static void ForceNextVideo()
	{
		MenuBackgroundVideo[] array = Object.FindObjectsOfType<MenuBackgroundVideo>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].NextVideo();
		}
	}

	[ClientVar]
	public static void EmulateError()
	{
		Object.FindObjectOfType<MenuBackgroundVideo>().OnVideoError(null, null);
	}
}


using UnityEngine;

public class MenuServerPanel : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;

public class NewsParagraph : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public RustText Text;

	public List<string> Links;

	public void OnPointerClick(PointerEventData eventData)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Text == (Object)null || Links == null || (int)eventData.button != 0)
		{
			return;
		}
		int num = TMP_TextUtilities.FindIntersectingLink((TMP_Text)(object)Text, Vector2.op_Implicit(eventData.position), eventData.pressEventCamera);
		if (num < 0 || num >= ((TMP_Text)Text).textInfo.linkCount)
		{
			return;
		}
		TMP_LinkInfo val = ((TMP_Text)Text).textInfo.linkInfo[num];
		if (int.TryParse(((TMP_LinkInfo)(ref val)).GetLinkID(), out var result) && result >= 0 && result < Links.Count)
		{
			string text = Links[result];
			if (text.StartsWith("http", StringComparison.InvariantCultureIgnoreCase))
			{
				Application.OpenURL(text);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Flexbox;
using Facepunch.Math;
using Facepunch.Models;
using Facepunch.Rust;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class NewsSource : MonoBehaviour
{
	private struct ParagraphBuilder
	{
		public StringBuilder StringBuilder;

		public List<string> Links;

		public static ParagraphBuilder New()
		{
			ParagraphBuilder result = default(ParagraphBuilder);
			result.StringBuilder = new StringBuilder();
			result.Links = new List<string>();
			return result;
		}

		public void AppendLine()
		{
			StringBuilder.AppendLine();
		}

		public void Append(string text)
		{
			StringBuilder.Append(text);
		}
	}

	private static readonly Regex BbcodeParse = new Regex("([^\\[]*)(?:\\[(\\w+)(?:=([^\\]]+))?\\](.*?)\\[\\/\\2\\])?", RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline);

	public RustText title;

	public RustText date;

	public RustText authorName;

	public HttpImage coverImage;

	public RectTransform container;

	public Button button;

	public FlexElement layoutRoot;

	public RustText paragraphTemplate;

	public HttpImage imageTemplate;

	public HttpImage youtubeTemplate;

	private static readonly string[] BulletSeparators = new string[1] { "[*]" };

	public void Awake()
	{
		EventRecord eventRecord = EventRecord.New("news", isServer: false);
		eventRecord.AddField("action", "view");
		eventRecord.Submit();
	}

	public void OnEnable()
	{
		if (SteamNewsSource.Stories != null && SteamNewsSource.Stories.Length != 0)
		{
			SetStory(SteamNewsSource.Stories[0]);
		}
	}

	public void SetStory(SteamNewsSource.Story story)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Expected O, but got Unknown
		PlayerPrefs.SetInt("lastNewsDate", story.date);
		TransformEx.DestroyAllChildren((Transform)(object)container, false);
		((TMP_Text)title).text = story.name;
		((TMP_Text)authorName).text = "by " + story.author;
		string text = NumberExtensions.FormatSecondsLong((long)(Epoch.Current - story.date));
		((TMP_Text)date).text = "Posted " + text + " ago";
		((UnityEventBase)button.onClick).RemoveAllListeners();
		((UnityEvent)button.onClick).AddListener((UnityAction)delegate
		{
			string text2 = GetBlogPost()?.Url ?? story.url;
			Debug.Log((object)("Opening URL: " + text2));
			Application.OpenURL(text2);
		});
		string firstImage = GetBlogPost()?.HeaderImage;
		ParagraphBuilder currentParagraph = ParagraphBuilder.New();
		ParseBbcode(ref currentParagraph, story.text, ref firstImage);
		AppendParagraph(ref currentParagraph);
		if (firstImage != null)
		{
			coverImage.Load(firstImage);
		}
		BlogInfo GetBlogPost()
		{
			Manifest manifest = Application.Manifest;
			if (manifest == null)
			{
				return null;
			}
			NewsInfo news = manifest.News;
			if (news == null)
			{
				return null;
			}
			BlogInfo[] blogs = news.Blogs;
			if (blogs == null)
			{
				return null;
			}
			return List.FindWith<BlogInfo, string>((IReadOnlyCollection<BlogInfo>)(object)blogs, (Func<BlogInfo, string>)((BlogInfo b) => b.Title), story.name, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
		}
	}

	private void ParseBbcode(ref ParagraphBuilder currentParagraph, string bbcode, ref string firstImage, int depth = 0)
	{
		foreach (Match item in BbcodeParse.Matches(bbcode))
		{
			string value = item.Groups[1].Value;
			string value2 = item.Groups[2].Value;
			string value3 = item.Groups[3].Value;
			string value4 = item.Groups[4].Value;
			currentParagraph.Append(value);
			switch (value2.ToLowerInvariant())
			{
			case "previewyoutube":
				if (depth == 0)
				{
					string[] array2 = value3.Split(';');
					AppendYouTube(ref currentParagraph, array2[0]);
				}
				break;
			case "h1":
			case "h2":
				currentParagraph.Append("<size=200%>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</size>");
				break;
			case "h3":
				currentParagraph.Append("<size=175%>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</size>");
				break;
			case "h4":
				currentParagraph.Append("<size=150%>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</size>");
				break;
			case "b":
				currentParagraph.Append("<b>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</b>");
				break;
			case "u":
				currentParagraph.Append("<u>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</u>");
				break;
			case "i":
				currentParagraph.Append("<i>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</i>");
				break;
			case "strike":
				currentParagraph.Append("<s>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</s>");
				break;
			case "noparse":
				currentParagraph.Append(value4);
				break;
			case "url":
			{
				if (value4.Contains("[img]", StringComparison.InvariantCultureIgnoreCase))
				{
					ParseBbcode(ref currentParagraph, value4, ref firstImage, depth);
					break;
				}
				int count = currentParagraph.Links.Count;
				currentParagraph.Links.Add(value3);
				currentParagraph.Append($"<link={count}><u>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</u></link>");
				break;
			}
			case "list":
			{
				currentParagraph.AppendLine();
				string[] array = GetBulletPoints(value4);
				foreach (string text3 in array)
				{
					if (!string.IsNullOrWhiteSpace(text3))
					{
						currentParagraph.Append("\t• ");
						ParseBbcode(ref currentParagraph, text3.Trim(), ref firstImage, depth + 1);
						currentParagraph.AppendLine();
					}
				}
				break;
			}
			case "olist":
			{
				currentParagraph.AppendLine();
				string[] bulletPoints = GetBulletPoints(value4);
				int num = 1;
				string[] array = bulletPoints;
				foreach (string text2 in array)
				{
					if (!string.IsNullOrWhiteSpace(text2))
					{
						currentParagraph.Append($"\t{num++} ");
						ParseBbcode(ref currentParagraph, text2.Trim(), ref firstImage, depth + 1);
						currentParagraph.AppendLine();
					}
				}
				break;
			}
			case "img":
				if (depth == 0)
				{
					string text = value4.Trim();
					if (firstImage == null)
					{
						firstImage = text;
					}
					AppendImage(ref currentParagraph, text);
				}
				break;
			}
		}
	}

	private static string[] GetBulletPoints(string listContent)
	{
		return listContent?.Split(BulletSeparators, StringSplitOptions.RemoveEmptyEntries) ?? Array.Empty<string>();
	}

	private void AppendParagraph(ref ParagraphBuilder currentParagraph)
	{
		if (currentParagraph.StringBuilder.Length > 0)
		{
			string text = currentParagraph.StringBuilder.ToString();
			RustText obj = Object.Instantiate<RustText>(paragraphTemplate, (Transform)(object)container);
			ComponentExtensions.SetActive<RustText>(obj, true);
			obj.SetText(text);
			NewsParagraph newsParagraph = default(NewsParagraph);
			if (((Component)obj).TryGetComponent<NewsParagraph>(ref newsParagraph))
			{
				newsParagraph.Links = currentParagraph.Links;
			}
		}
		currentParagraph = ParagraphBuilder.New();
	}

	private void AppendImage(ref ParagraphBuilder currentParagraph, string url)
	{
		AppendParagraph(ref currentParagraph);
		HttpImage obj = Object.Instantiate<HttpImage>(imageTemplate, (Transform)(object)container);
		ComponentExtensions.SetActive<HttpImage>(obj, true);
		obj.Load(url);
	}

	private void AppendYouTube(ref ParagraphBuilder currentParagraph, string videoId)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Expected O, but got Unknown
		AppendParagraph(ref currentParagraph);
		HttpImage obj = Object.Instantiate<HttpImage>(youtubeTemplate, (Transform)(object)container);
		ComponentExtensions.SetActive<HttpImage>(obj, true);
		obj.Load("https://img.youtube.com/vi/" + videoId + "/maxresdefault.jpg");
		RustButton component = ((Component)obj).GetComponent<RustButton>();
		if ((Object)(object)component != (Object)null)
		{
			string videoUrl = "https://www.youtube.com/watch?v=" + videoId;
			component.OnReleased.AddListener((UnityAction)delegate
			{
				Debug.Log((object)("Opening URL: " + videoUrl));
				Application.OpenURL(videoUrl);
			});
		}
	}
}


using System.Collections.Generic;
using System.Text;

private struct ParagraphBuilder
{
	public StringBuilder StringBuilder;

	public List<string> Links;

	public static ParagraphBuilder New()
	{
		ParagraphBuilder result = default(ParagraphBuilder);
		result.StringBuilder = new StringBuilder();
		result.Links = new List<string>();
		return result;
	}

	public void AppendLine()
	{
		StringBuilder.AppendLine();
	}

	public void Append(string text)
	{
		StringBuilder.Append(text);
	}
}


using System.Collections;
using System.Collections.Generic;
using JSON;
using UnityEngine;

public static class SteamNewsSource
{
	public struct Story
	{
		public string name;

		public string url;

		public int date;

		public string text;

		public string author;
	}

	public static Story[] Stories;

	public static IEnumerator GetStories()
	{
		WWW www = new WWW("https://api.steampowered.com/ISteamNews/GetNewsForApp/v0002/?appid=252490&count=8&format=json&feeds=steam_community_announcements");
		yield return www;
		Object val = Object.Parse(www.text);
		www.Dispose();
		if (val == null)
		{
			yield break;
		}
		Array array = val.GetObject("appnews").GetArray("newsitems");
		List<Story> list = new List<Story>();
		foreach (Value item in array)
		{
			string @string = item.Obj.GetString("contents", "Missing Contents");
			@string = @string.Replace("\\n", "\n").Replace("\\r", "").Replace("\\\"", "\"");
			list.Add(new Story
			{
				name = item.Obj.GetString("title", "Missing Title"),
				url = item.Obj.GetString("url", "Missing URL"),
				date = item.Obj.GetInt("date", 0),
				text = @string,
				author = item.Obj.GetString("author", "Missing Author")
			});
		}
		Stories = list.ToArray();
	}
}


public struct Story
{
	public string name;

	public string url;

	public int date;

	public string text;

	public string author;
}


using Facepunch.Extend;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ToggleHUDLayer : MonoBehaviour, IClientComponent
{
	public Toggle toggleControl;

	public TextMeshProUGUI textControl;

	public string hudComponentName;

	protected void OnEnable()
	{
		UIHUD instance = SingletonComponent<UIHUD>.Instance;
		if (!((Object)(object)instance != (Object)null))
		{
			return;
		}
		Transform val = TransformEx.FindChildRecursive(((Component)instance).transform, hudComponentName);
		if ((Object)(object)val != (Object)null)
		{
			Canvas component = ((Component)val).GetComponent<Canvas>();
			if ((Object)(object)component != (Object)null)
			{
				toggleControl.isOn = ((Behaviour)component).enabled;
			}
			else
			{
				toggleControl.isOn = ((Component)val).gameObject.activeSelf;
			}
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": Couldn't find child: " + hudComponentName));
		}
	}

	public void OnToggleChanged()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Client, "global.hudcomponent", new object[2] { hudComponentName, toggleControl.isOn });
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ToggleLayer : MonoBehaviour, IClientComponent
{
	public Toggle toggleControl;

	public TextMeshProUGUI textControl;

	public LayerSelect layer;

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
		{
			toggleControl.isOn = (MainCamera.mainCamera.cullingMask & layer.Mask) != 0;
		}
	}

	public void OnToggleChanged()
	{
		if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
		{
			if (toggleControl.isOn)
			{
				Camera mainCamera = MainCamera.mainCamera;
				mainCamera.cullingMask |= layer.Mask;
			}
			else
			{
				Camera mainCamera2 = MainCamera.mainCamera;
				mainCamera2.cullingMask &= ~layer.Mask;
			}
		}
	}

	protected void OnValidate()
	{
		if (Object.op_Implicit((Object)(object)textControl))
		{
			((TMP_Text)textControl).text = layer.Name;
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ToggleTerrainRenderer : MonoBehaviour
{
	public Toggle toggleControl;

	public Text textControl;

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			toggleControl.isOn = Terrain.activeTerrain.drawHeightmap;
		}
	}

	public void OnToggleChanged()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			Terrain.activeTerrain.drawHeightmap = toggleControl.isOn;
		}
	}

	protected void OnValidate()
	{
		if (Object.op_Implicit((Object)(object)textControl))
		{
			textControl.text = "Terrain Renderer";
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ToggleTerrainTrees : MonoBehaviour
{
	public Toggle toggleControl;

	public Text textControl;

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			toggleControl.isOn = Terrain.activeTerrain.drawTreesAndFoliage;
		}
	}

	public void OnToggleChanged()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			Terrain.activeTerrain.drawTreesAndFoliage = toggleControl.isOn;
		}
	}

	protected void OnValidate()
	{
		if (Object.op_Implicit((Object)(object)textControl))
		{
			textControl.text = "Terrain Trees";
		}
	}
}


using System;
using UnityEngine;

public class TweakUI : SingletonComponent<TweakUI>
{
	public static bool isOpen;

	private void Update()
	{
		if (Input.GetKeyDown((KeyCode)283) && CanToggle())
		{
			SetVisible(!isOpen);
		}
	}

	protected bool CanToggle()
	{
		if (!LevelManager.isLoaded)
		{
			return false;
		}
		return true;
	}

	public void SetVisible(bool b)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (b)
		{
			isOpen = true;
			return;
		}
		isOpen = false;
		ConsoleSystem.Run(Option.Client, "writecfg", Array.Empty<object>());
	}
}


using Rust.UI.MainMenu;
using UnityEngine.UI;

public class TweakUIMultiSelect : UI_SettingsTweakConvar
{
	public ToggleGroup toggleGroup;
}


using System.Threading;
using Rust.UI;
using UnityEngine;

public class PartyInviteModal : SingletonComponent<PartyInviteModal>
{
	public RustText InviteLabel;

	public RustButton AcceptButton;

	public static Phrase InvitePhrase = new Phrase("party.invite", "{0} has invited you to a party");

	private ulong pendingLobbyId;

	private TimeSince age;

	public HttpImage ProfilePicture;

	public RectTransform ProgressBar;

	private CancellationTokenSource cancel;

	private ulong lastUserId;

	public bool IsShown => ((Component)this).gameObject.activeInHierarchy;

	public void Show(string username, ulong userId, ulong lobbyId)
	{
	}

	public void OnClientStartup()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (lastUserId != 0L)
		{
			age = TimeSince.op_Implicit(0f);
		}
	}

	public void Hide()
	{
	}

	public void OnAcceptButtonClicked()
	{
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class PremiumModal : SingletonComponent<PremiumModal>
{
	public RustText UsernameLabel;

	public RustText MoneyLabel;

	public RustText ActiveStatusLabel;

	public RawImage ProfilePicture;

	public RustButton RefreshButton;

	public Phrase ActivePhrase;

	public Phrase InactivePhrase;

	public Phrase SearchingPhrase;

	public static Phrase ErrorPhrase = new Phrase("premium.error", "Error");

	public GameObject[] BackgroundImages;

	public static TimeSpan ButtonTimeout = TimeSpan.FromSeconds(65.0);

	public void Open()
	{
	}

	public void Close()
	{
	}

	private void UpdateInfo()
	{
	}

	public void RefreshButtonClicked()
	{
	}
}


using Rust.UI;
using UnityEngine;

public class ServerBrowser : MonoBehaviour
{
	public string orderBy = "pingDesc";

	public RustButton cacheBrowserToggle;

	public RustButton filterTutorialButton;

	public GameObject pingEstimationButton;
}


using Rust.UI;
using UnityEngine;

public class ServerBrowserCategory : MonoBehaviour
{
	public RustText serverCountText;

	public bool useServerCount;
}


public static class ServerBrowserEx
{
	public static string GetPingString(this ServerInfo server)
	{
		if (((ServerInfo)(ref server)).Ping != int.MaxValue)
		{
			return ((ServerInfo)(ref server)).Ping.ToString();
		}
		return "?";
	}
}


using Rust.UI;
using UnityEngine.UI;

public class ServerBrowserInfo : SingletonComponent<ServerBrowserInfo>
{
	public bool isMain;

	public RustText serverName;

	public RustText serverMeta;

	public Text serverText;

	public Button viewWebpage;

	public Button refresh;

	public ServerInfo? currentServer;

	public HttpImage headerImage;

	public HttpImage logoImage;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class ServerBrowserInfoNexus : SingletonComponent<ServerBrowserInfoNexus>
{
	public GameObject loadingIndicator;

	public GameObject errorIndicator;

	public GameObject errorGenericText;

	public GameObject errorSteamAuthNullText;

	public RustText serverName;

	public RustText serverDesc;

	public RustText playerCount;

	public RustText zoneCount;

	public RustText lastWiped;

	public HttpImage coverImage;

	public HttpImage logoImage;

	public UINexusMapWidget mapWidget;

	public FlexTransition zoneListReveal;

	public RectTransform zoneListParent;

	public GameObjectRef zoneListItem;

	public RustButton joinServer;

	public RustButton viewWebpage;
}


using Rust.UI;
using UnityEngine;

public class ServerBrowserInfoNexusZone : MonoBehaviour
{
	public RustButton button;

	public GameObject checkbox;

	public GameObject checkboxIndicator;

	public RectTransform currentServerIndicator;

	public RustText zoneName;

	public RustText ping;

	public RustText playerCount;
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ServerBrowserItem : MonoBehaviour
{
	[Serializable]
	public struct PremiumGameObject
	{
		public GameObject GameObject;

		public bool ShowIfEligible;
	}

	public TextMeshProUGUI serverName;

	public RustFlexText mapName;

	public TextMeshProUGUI playerCount;

	public TextMeshProUGUI ping;

	public TextMeshProUGUI pendingPing;

	public Toggle favourited;

	public ServerBrowserTagList serverTagList;

	public Color pingColor;

	public Color pingWarningColor;

	public Tooltip pingWarningTooltip;

	public PremiumGameObject[] PremiumOptions;
}


using System;
using UnityEngine;

[Serializable]
public struct PremiumGameObject
{
	public GameObject GameObject;

	public bool ShowIfEligible;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ServerBrowserItemNexus : MonoBehaviour
{
	public TextMeshProUGUI serverName;

	public RustFlexText mapName;

	public TextMeshProUGUI playerCount;

	public Toggle favourited;

	public ServerBrowserTagList serverTagList;

	public TextMeshProUGUI changeset;
}


using System;
using Facepunch;
using UnityEngine;

public class ServerBrowserList : ServerBrowserListBase, VirtualScroll.IDataSource, VirtualScroll.IVisualUpdate
{
	[Serializable]
	public struct Rules
	{
		public string tag;

		public ServerBrowserList serverList;

		public bool keepInList;

		public string CompressedTag { get; set; }
	}

	public enum QueryType
	{
		RegularInternet,
		Friends,
		History,
		LAN,
		Favourites,
		None
	}

	[Serializable]
	public struct ServerKeyvalues
	{
		public string key;

		public string value;
	}

	public bool legacyUIDisplay = true;

	public bool UseOfficialServers;

	public VirtualScroll VirtualScroll;

	public FlexVirtualScroll VirtualScrollFlex;

	public bool prioritizePremiumServers;

	public Rules[] rules;

	public bool hideOfficialServers;

	public bool excludeEmptyServersUsingQuery;

	public bool alwaysIncludeEmptyServers;

	public bool clampPlayerCountsToTrustedValues = true;

	public bool replacePingWithTimeSinceLastPlayed;

	private static string[] pingStrings = new string[3] { ".", "..", "..." };

	public QueryType queryType;

	public static string VersionTag = "v" + 2594;

	public ServerKeyvalues[] keyValues = new ServerKeyvalues[0];

	public void OnVisualUpdate(int i, GameObject obj)
	{
	}

	public int GetItemCount()
	{
		return 0;
	}

	public void SetItemData(int i, GameObject obj)
	{
	}

	private void VisualUpdate(int i, GameObject obj)
	{
	}

	private void VisualUpdateLegacy(int i, GameObject obj)
	{
	}
}


using System;

[Serializable]
public struct Rules
{
	public string tag;

	public ServerBrowserList serverList;

	public bool keepInList;

	public string CompressedTag { get; set; }
}


public enum QueryType
{
	RegularInternet,
	Friends,
	History,
	LAN,
	Favourites,
	None
}


using System;

[Serializable]
public struct ServerKeyvalues
{
	public string key;

	public string value;
}


public abstract class ServerBrowserListBase : BaseMonoBehaviour
{
	public ServerBrowserCategory categoryButton;

	public string sortOrder = "pingDesc";
}


using Facepunch;

public class ServerBrowserListNexus : ServerBrowserListBase
{
	public VirtualScroll VirtualScroll;
}


using System.Collections.Generic;
using Facepunch;
using Facepunch.Nexus.Models;

public class NexusEx : Nexus
{
	public static HashSet<StringView> Empty = new HashSet<StringView>();

	public string Key { get; }

	public HashSet<StringView> TagsSet { get; }

	public NexusEx(string endpoint, Nexus nexus)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		((Nexus)this).NexusId = nexus.NexusId;
		((Nexus)this).Name = nexus.Name;
		((Nexus)this).LastReset = nexus.LastReset;
		((Nexus)this).ZoneCount = nexus.ZoneCount;
		((Nexus)this).MaxPlayers = nexus.MaxPlayers;
		((Nexus)this).OnlinePlayers = nexus.OnlinePlayers;
		((Nexus)this).QueuedPlayers = nexus.QueuedPlayers;
		((Nexus)this).Build = nexus.Build;
		((Nexus)this).Protocol = nexus.Protocol;
		((Nexus)this).Tags = nexus.Tags;
		Key = $"{endpoint}#{nexus.NexusId}";
		if (!string.IsNullOrEmpty(((Nexus)this).Tags))
		{
			List<StringView> list = Pool.Get<List<StringView>>();
			StringView val = StringView.op_Implicit(((Nexus)this).Tags);
			((StringView)(ref val)).Split(',', (ICollection<StringView>)list);
			TagsSet = new HashSet<StringView>(list, (IEqualityComparer<StringView>?)ComparerIgnoreCase.Instance);
		}
		else
		{
			TagsSet = Empty;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.UI;
using UnityEngine;

public class ServerBrowserTag : MonoBehaviour
{
	public string serverTag;

	[Tooltip("Priority will choose what tag will show if multiple in group are defined. Seperate from display order")]
	public int priority;

	public bool excludeOnly;

	private string _tag;

	public RustButton button;

	public string CompactTag
	{
		get
		{
			if (_tag == null)
			{
				_tag = ServerTagCompressor.ShortenTag(serverTag);
			}
			return _tag;
		}
	}

	public bool IsActive
	{
		get
		{
			if ((Object)(object)button != (Object)null)
			{
				return ((RustControl)button).IsPressed;
			}
			return false;
		}
	}

	public bool ContainsTag(HashSet<StringView> tags)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (tags.Contains(StringView.op_Implicit(CompactTag)) || tags.Contains(StringView.op_Implicit(serverTag)))
		{
			return true;
		}
		if (CompactTag != serverTag)
		{
			foreach (StringView tag in tags)
			{
				StringView current = tag;
				if (((StringView)(ref current)).Contains(StringView.op_Implicit(CompactTag)))
				{
					return true;
				}
			}
		}
		return excludeOnly;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class ServerBrowserTagFilters : MonoBehaviour
{
	public UnityEvent TagFiltersChanged = new UnityEvent();

	private ServerBrowserTagGroup[] _groups;

	private List<bool> _previousState;

	public void Start()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Expected O, but got Unknown
		_groups = ((Component)this).gameObject.GetComponentsInChildren<ServerBrowserTagGroup>();
		UnityAction val = (UnityAction)delegate
		{
			UnityEvent tagFiltersChanged = TagFiltersChanged;
			if (tagFiltersChanged != null)
			{
				tagFiltersChanged.Invoke();
			}
		};
		ServerBrowserTagGroup[] groups = _groups;
		for (int i = 0; i < groups.Length; i++)
		{
			ServerBrowserTag[] tags = groups[i].tags;
			foreach (ServerBrowserTag obj in tags)
			{
				obj.button.OnPressed.AddListener(val);
				obj.button.OnReleased.AddListener(val);
			}
		}
	}

	public void DeselectAll()
	{
		if (_groups == null)
		{
			return;
		}
		ServerBrowserTagGroup[] groups = _groups;
		foreach (ServerBrowserTagGroup serverBrowserTagGroup in groups)
		{
			if (serverBrowserTagGroup.tags != null)
			{
				ServerBrowserTag[] tags = serverBrowserTagGroup.tags;
				for (int j = 0; j < tags.Length; j++)
				{
					tags[j].button.SetToggleFalse(true);
				}
			}
		}
	}

	public void GetTags(out List<HashSet<string>> searchTagGroups, out HashSet<string> excludeTags)
	{
		searchTagGroups = new List<HashSet<string>>();
		excludeTags = new HashSet<string>();
		ServerBrowserTagGroup[] groups = _groups;
		foreach (ServerBrowserTagGroup serverBrowserTagGroup in groups)
		{
			if (!serverBrowserTagGroup.AnyActive())
			{
				continue;
			}
			ServerBrowserTag[] tags;
			if (serverBrowserTagGroup.isExclusive)
			{
				HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
				tags = serverBrowserTagGroup.tags;
				foreach (ServerBrowserTag serverBrowserTag in tags)
				{
					if (serverBrowserTag.IsActive)
					{
						if (!serverBrowserTag.excludeOnly)
						{
							hashSet.Add(serverBrowserTag.CompactTag);
							hashSet.Add(serverBrowserTag.serverTag);
						}
					}
					else if (serverBrowserTagGroup.isExclusive)
					{
						excludeTags.Add(serverBrowserTag.CompactTag);
						excludeTags.Add(serverBrowserTag.serverTag);
					}
				}
				if (hashSet.Count > 0)
				{
					searchTagGroups.Add(hashSet);
				}
				continue;
			}
			tags = serverBrowserTagGroup.tags;
			foreach (ServerBrowserTag serverBrowserTag2 in tags)
			{
				if (serverBrowserTag2.IsActive)
				{
					HashSet<string> hashSet2 = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
					hashSet2.Add(serverBrowserTag2.CompactTag);
					hashSet2.Add(serverBrowserTag2.serverTag);
					searchTagGroups.Add(hashSet2);
				}
				else if (serverBrowserTag2.excludeOnly)
				{
					excludeTags.Add(serverBrowserTag2.CompactTag);
					excludeTags.Add(serverBrowserTag2.serverTag);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class ServerBrowserTagGroup : MonoBehaviour
{
	[Tooltip("If set then queries will filter out servers matching unselected tags in the group")]
	public bool isExclusive;

	[NonSerialized]
	public ServerBrowserTag[] tags;

	private void Initialize()
	{
		if (tags == null)
		{
			tags = (from x in ((Component)this).GetComponentsInChildren<ServerBrowserTag>(true)
				orderby x.priority descending
				select x).ToArray();
		}
	}

	public void Awake()
	{
		Initialize();
	}

	public bool AnyActive()
	{
		ServerBrowserTag[] array = tags;
		foreach (ServerBrowserTag serverBrowserTag in array)
		{
			if (serverBrowserTag.IsActive)
			{
				return true;
			}
			if (serverBrowserTag.excludeOnly)
			{
				return true;
			}
		}
		return false;
	}

	public void Refresh(HashSet<StringView> serverTags, ref int tagsEnabled, int maxTags)
	{
		Initialize();
		bool flag = false;
		ServerBrowserTag[] array = tags;
		foreach (ServerBrowserTag serverBrowserTag in array)
		{
			if ((!isExclusive || !flag) && tagsEnabled < maxTags && serverBrowserTag.ContainsTag(serverTags))
			{
				ComponentExtensions.SetActive<ServerBrowserTag>(serverBrowserTag, true);
				tagsEnabled++;
				flag = true;
			}
			else
			{
				ComponentExtensions.SetActive<ServerBrowserTag>(serverBrowserTag, false);
			}
		}
		((Component)this).gameObject.SetActive(flag);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ServerBrowserTagList : MonoBehaviour
{
	public int maxTagsToShow = 3;

	private ServerBrowserTagGroup[] _groups;

	private void Initialize()
	{
		if (_groups == null)
		{
			_groups = ((Component)this).GetComponentsInChildren<ServerBrowserTagGroup>(true);
		}
	}

	public void Awake()
	{
		Initialize();
	}

	public bool Refresh(HashSet<StringView> serverTags)
	{
		Initialize();
		int tagsEnabled = 0;
		ServerBrowserTagGroup[] groups = _groups;
		for (int i = 0; i < groups.Length; i++)
		{
			groups[i].Refresh(serverTags, ref tagsEnabled, maxTagsToShow);
		}
		return tagsEnabled > 0;
	}

	public void PremiumButtonClicked()
	{
		SingletonComponent<PremiumModal>.Instance.Open();
	}
}


using UnityEngine;

public class ServerHistory : MonoBehaviour
{
	public ServerHistoryItem prefab;

	public GameObject panelList;

	internal IServerQuery Request;
}


using UnityEngine;
using UnityEngine.UI;

public class ServerHistoryItem : MonoBehaviour
{
	private ServerInfo serverInfo;

	public Text serverName;

	public Text players;

	public Text lastJoinDate;

	public uint order;
}


using Rust.UI;
using UnityEngine;

public class UIConfirmationPopup : MonoBehaviour
{
	[SerializeField]
	private Transform buttonsParent;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private RustButton buttonTemplate;

	public RustButton[] buttons;
}


using Rust.UI;
using UnityEngine;

public class UISafeModeWarning : MonoBehaviour, IClientComponent
{
	public RustButton ApplyButton;

	public RustSlider TimeSlider;

	public float TimeToWait = 5f;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UISafeZoneWarning : MonoBehaviour
{
	[SerializeField]
	private Transform buttonsParent;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private Button buttonTemplate;
}


using Rust.UI;
using UnityEngine;

public class UnreadMessages : SingletonComponent<UnreadMessages>
{
	public StyleAsset AllRead;

	public StyleAsset Unread;

	public RustButton Button;

	public GameObject UnreadTextObject;

	public RustText UnreadText;

	public GameObject MessageList;

	public GameObject MessageListContainer;

	public GameObject MessageListEmpty;
}


using UnityEngine;
using UnityEngine.UI;

[ExecuteAlways]
[RequireComponent(typeof(RawImage))]
public class RawImagePreserveAspect : MonoBehaviour, IClientComponent
{
	public RawImage rawImage;

	public RectTransform rectTransform;

	private Texture lastTexture;
}


using UnityEngine;
using UnityEngine.UI;

public class UI_FullscreenSkinViewer : SingletonComponent<UI_FullscreenSkinViewer>
{
	public CanvasGroup background;

	public Image glowImage;

	private UI_SkinViewerControls _source;
}


using UnityEngine;

public class UI_SkinViewerControls : MonoBehaviour
{
	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private CoverImage coverImage;

	[SerializeField]
	private float maxYaw = 8f;

	[SerializeField]
	private float maxPitch = 4f;

	[SerializeField]
	private float lerpSpeed = 6f;

	[SerializeField]
	private float responseCurve = 1.5f;

	[SerializeField]
	[Header("Drag")]
	private float inertiaDecay = 5f;

	[SerializeField]
	private float rotationSpeed = 300f;

	[SerializeField]
	[Header("Pan")]
	private Vector2 panLimitX = new Vector2(-1f, 1f);

	[SerializeField]
	private Vector2 panLimitY = new Vector2(-1f, 1f);

	[SerializeField]
	private float panSpeed = 0.005f;

	[SerializeField]
	[Header("Zoom")]
	private float zoomSpeed = 0.1f;

	[SerializeField]
	private Vector2 minMaxFov = new Vector2(20f, 8f);

	[SerializeField]
	[Header("Idle")]
	private float idleSwaySpeed = 1f;

	[SerializeField]
	private float idleSwayAmount = 1.5f;

	[SerializeField]
	private float swayEaseSpeed = 1f;

	[SerializeField]
	private float swayDelay = 0.3f;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(AudioSource), typeof(Toggle))]
public class UI_StoreSongPreview : BaseMonoBehaviour
{
}


using Rust.UI;
using UnityEngine;

public class MissionsHUD : SingletonComponent<MissionsHUD>
{
	public SoundDefinition listComplete;

	public SoundDefinition itemComplete;

	public SoundDefinition popup;

	public Canvas Canvas;

	public RustText titleText;

	public GameObject timerObject;

	public RustText timerText;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.Serialization;

public class MissionsHUDToDo : BaseMonoBehaviour
{
	private static readonly Memoized<string, (float Current, float Target)> FormatProgres = new Memoized<string, (float, float)>((Func<(float, float), string>)delegate((float Current, float Target) d)
	{
		float num = Mathf.Min(d.Current, d.Target);
		return $" ({num:0.#}/{d.Target:0.#})";
	});

	public RustText text;

	public RectTransform checkIcon;

	public RectTransform checkBox;

	public Phrase optionalPrefix;

	public CanvasGroup group;

	[FormerlySerializedAs("AliveColor")]
	public Color DefaultColor;

	[FormerlySerializedAs("DeadColor")]
	public Color CompletedColor;

	[FormerlySerializedAs("HighlightColor")]
	public Color CompletedHighlightColor;

	public Color FailedColor;

	public Color FailedHighlightColor;

	public PingWidget PingWidget;
}


using UnityEngine;

public class NoRespawnIcon : FacepunchBehaviour
{
	[SerializeField]
	private CanvasGroup noRespawnWarning;

	[SerializeField]
	private GameObject noRespawnWarningGO;
}


using UnityEngine;

public class ObjectRotation : MonoBehaviour
{
	public Camera cam;

	public bool ignoreNeedsKeyboard = true;

	public Transform panTransform;
}


using UnityEngine;

public class OpenURL : MonoBehaviour
{
	public bool OpenWebURL = true;
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RawImage))]
public class ImageAlphaRaycastFilter : UIBehaviour, ICanvasRaycastFilter
{
	[NonSerialized]
	private RawImage m_rawImage;

	public float rChannelHitTestMinimumThreshold = 1f;

	protected RawImage rawImage => m_rawImage ?? (m_rawImage = ((Component)this).GetComponent<RawImage>());

	public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		//IL_0101: Expected O, but got Unknown
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		if (rChannelHitTestMinimumThreshold <= 0f)
		{
			return true;
		}
		if (rChannelHitTestMinimumThreshold > 1f)
		{
			return false;
		}
		Texture mainTexture = ((Graphic)rawImage).mainTexture;
		Texture2D val = (Texture2D)(object)((mainTexture is Texture2D) ? mainTexture : null);
		Vector2 val2 = default(Vector2);
		if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(((Graphic)rawImage).rectTransform, screenPoint, eventCamera, ref val2))
		{
			return false;
		}
		Rect pixelAdjustedRect = ((Graphic)rawImage).GetPixelAdjustedRect();
		val2.x += ((Graphic)rawImage).rectTransform.pivot.x * ((Rect)(ref pixelAdjustedRect)).width;
		val2.y += ((Graphic)rawImage).rectTransform.pivot.y * ((Rect)(ref pixelAdjustedRect)).height;
		((Vector2)(ref val2))..ctor(val2.x / ((Rect)(ref pixelAdjustedRect)).width, val2.y / ((Rect)(ref pixelAdjustedRect)).height);
		if ((Object)(object)val != (Object)null && !((Texture)val).isReadable)
		{
			return false;
		}
		try
		{
			return val.GetPixelBilinear(val2.x, val2.y).r <= rChannelHitTestMinimumThreshold;
		}
		catch (UnityException val3)
		{
			UnityException val4 = val3;
			Debug.LogError((object)("Using alphaHitTestMinimumThreshold greater than 0 on Graphic whose sprite texture cannot be read. " + ((Exception)(object)val4).Message + " Also make sure to disable sprite packing for this sprite."), (Object)(object)this);
			return true;
		}
	}
}


using UnityEngine.EventSystems;

public class PaintableImageGrid : UIBehaviour, IServerFileReceiver
{
	public GameObjectRef templateImage;

	public int cols = 4;

	public int rows = 4;

	public bool readOnly;
}


using UnityEngine;
using UnityEngine.UI;

public class UIPaintableImage : MonoBehaviour
{
	public enum DrawMode
	{
		AlphaBlended,
		Additive,
		Lighten,
		Erase
	}

	public RawImage image;

	public int texSize = 64;

	public Color clearColor = Color.clear;

	public FilterMode filterMode = (FilterMode)1;

	public bool mipmaps;

	public bool readOnly;

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}
}


public enum DrawMode
{
	AlphaBlended,
	Additive,
	Lighten,
	Erase
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class UIParticle : BaseMonoBehaviour
{
	public Vector2 LifeTime;

	public Vector2 Gravity = new Vector2(1000f, 1000f);

	public Vector2 InitialX;

	public Vector2 InitialY;

	public Vector2 InitialScale = Vector2.one;

	public Vector2 InitialDelay;

	public Vector2 ScaleVelocity;

	public Gradient InitialColor;

	private float lifetime;

	private float gravity;

	private Vector2 velocity;

	private float scaleVelocity;

	public static void Add(UIParticle particleSource, RectTransform spawnPosition, RectTransform particleCanvas)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = Object.Instantiate<GameObject>(((Component)particleSource).gameObject);
		obj.transform.SetParent((Transform)(object)spawnPosition, false);
		Transform transform = obj.transform;
		Rect rect = spawnPosition.rect;
		float num = Random.Range(0f, ((Rect)(ref rect)).width);
		rect = spawnPosition.rect;
		float num2 = num - ((Rect)(ref rect)).width * spawnPosition.pivot.x;
		rect = spawnPosition.rect;
		float num3 = Random.Range(0f, ((Rect)(ref rect)).height);
		rect = spawnPosition.rect;
		transform.localPosition = new Vector3(num2, num3 - ((Rect)(ref rect)).height * spawnPosition.pivot.y, 0f);
		obj.transform.SetParent((Transform)(object)particleCanvas, true);
		obj.transform.localScale = Vector3.one;
		obj.transform.localRotation = Quaternion.identity;
	}

	private void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		transform.localScale *= Random.Range(InitialScale.x, InitialScale.y);
		velocity.x = Random.Range(InitialX.x, InitialX.y);
		velocity.y = Random.Range(InitialY.x, InitialY.y);
		gravity = Random.Range(Gravity.x, Gravity.y);
		scaleVelocity = Random.Range(ScaleVelocity.x, ScaleVelocity.y);
		Image component = ((Component)this).GetComponent<Image>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Graphic)component).color = InitialColor.Evaluate(Random.Range(0f, 1f));
		}
		lifetime = Random.Range(InitialDelay.x, InitialDelay.y) * -1f;
		if (lifetime < 0f)
		{
			((Component)this).GetComponent<CanvasGroup>().alpha = 0f;
		}
		((FacepunchBehaviour)this).Invoke((Action)Die, Random.Range(LifeTime.x, LifeTime.y) + lifetime * -1f);
	}

	private void Update()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (lifetime < 0f)
		{
			lifetime += Time.deltaTime;
			if (lifetime < 0f)
			{
				return;
			}
			((Component)this).GetComponent<CanvasGroup>().alpha = 1f;
		}
		else
		{
			lifetime += Time.deltaTime;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 localScale = ((Component)this).transform.localScale;
		velocity.y -= gravity * Time.deltaTime;
		position.x += velocity.x * Time.deltaTime;
		position.y += velocity.y * Time.deltaTime;
		localScale += Vector3.one * scaleVelocity * Time.deltaTime;
		if (localScale.x <= 0f || localScale.y <= 0f)
		{
			Die();
			return;
		}
		((Component)this).transform.position = position;
		((Component)this).transform.localScale = localScale;
	}

	private void Die()
	{
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}
}


using Rust.UI;
using UnityEngine;

public class UIParty : BaseMonoBehaviour
{
	public GameObjectRef PartyMemberPrefab;

	public GameObjectRef InvitePrefab;

	public int MaxPartyMembersToRender = 6;

	public GameObject HiddenPartyMemberContainer;

	public RustText HiddenPartyMemberCountText;

	public RectTransform PartyMemberContainer;

	public GameObject PartySection;

	public RustText PartyMemberCount;

	public RectTransform InvitesContainer;

	public GameObject InvitesSection;

	public RustText InviteCountLabel;

	public FriendStyleDef Style;

	public UIFriendsList FriendsList;

	public bool RenderParty = true;

	public bool ShouldShowInvites = true;

	public void LeavePartyClicked()
	{
	}
}


using UnityEngine;

public class PeacekeeperHostileIcon : FacepunchBehaviour
{
	[SerializeField]
	private CanvasGroup turretWarningCanvasGroup;

	[SerializeField]
	private GameObject noRespawnWarningGO;
}


using TMPro;
using UnityEngine;

public class PerformanceText : MonoBehaviour
{
	public TextMeshProUGUI text;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[ExecuteInEditMode]
public class PieMenu : UIBehaviour
{
	[Serializable]
	public class MenuOption
	{
		public struct ColorMode
		{
			public enum PieMenuSpriteColorOption
			{
				CustomColor,
				SpriteColor
			}

			public PieMenuSpriteColorOption Mode;

			public Color CustomColor;
		}

		public Phrase name;

		public Phrase desc;

		public string requirements;

		public Sprite sprite;

		public bool disabled;

		public int order;

		public ColorMode? overrideColorMode;

		public bool showOverlay;

		public float time;

		public BasePlayer.PingType? showTutorialHighlight;

		public float sizeRatio = 1f;

		public float iconScale = 1f;

		[NonSerialized]
		public Action<BasePlayer> action;

		[NonSerialized]
		public Action<BasePlayer> actionDisabled;

		[NonSerialized]
		public Action<BasePlayer> actionPrev;

		[NonSerialized]
		public Action<BasePlayer> actionNext;

		[NonSerialized]
		public PieOption option;

		[NonSerialized]
		public bool selected;

		[NonSerialized]
		public bool allowMerge;
	}

	public static PieMenu Instance;

	public Image middleBox;

	public PieShape pieBackgroundBlur;

	public PieShape pieBackground;

	public PieShape pieSelection;

	public GameObject pieOptionPrefab;

	public GameObject optionsCanvas;

	public MenuOption[] options;

	public GameObject scaleTarget;

	public GameObject arrowLeft;

	public GameObject arrowRight;

	public float sliceGaps = 10f;

	[Range(0f, 1f)]
	public float outerSize = 1f;

	[Range(0f, 1f)]
	public float innerSize = 0.5f;

	[Range(0f, 1f)]
	public float iconSize = 0.8f;

	[Range(0f, 360f)]
	public float startRadius;

	[Range(0f, 360f)]
	public float radiusSize = 360f;

	public Image middleImage;

	public RustText middleTitle;

	public RustText middleDesc;

	public RustText middleRequired;

	public Color colorIconActive;

	public Color colorIconHovered;

	public Color colorIconDisabled;

	public Color colorBackgroundDisabled;

	public SoundDefinition clipOpen;

	public SoundDefinition clipCancel;

	public SoundDefinition clipChanged;

	public SoundDefinition clipSelected;

	public MenuOption defaultOption;

	public Material IconMaterial;

	public bool IsOpen { get; private set; }
}


using System;
using UnityEngine;

[Serializable]
public class MenuOption
{
	public struct ColorMode
	{
		public enum PieMenuSpriteColorOption
		{
			CustomColor,
			SpriteColor
		}

		public PieMenuSpriteColorOption Mode;

		public Color CustomColor;
	}

	public Phrase name;

	public Phrase desc;

	public string requirements;

	public Sprite sprite;

	public bool disabled;

	public int order;

	public ColorMode? overrideColorMode;

	public bool showOverlay;

	public float time;

	public BasePlayer.PingType? showTutorialHighlight;

	public float sizeRatio = 1f;

	public float iconScale = 1f;

	[NonSerialized]
	public Action<BasePlayer> action;

	[NonSerialized]
	public Action<BasePlayer> actionDisabled;

	[NonSerialized]
	public Action<BasePlayer> actionPrev;

	[NonSerialized]
	public Action<BasePlayer> actionNext;

	[NonSerialized]
	public PieOption option;

	[NonSerialized]
	public bool selected;

	[NonSerialized]
	public bool allowMerge;
}


using UnityEngine;

public struct ColorMode
{
	public enum PieMenuSpriteColorOption
	{
		CustomColor,
		SpriteColor
	}

	public PieMenuSpriteColorOption Mode;

	public Color CustomColor;
}


public enum PieMenuSpriteColorOption
{
	CustomColor,
	SpriteColor
}


using ConVar;
using UnityEngine;

public static class UISound
{
	private static AudioSource source;

	private static AudioSource GetAudioSource()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)source != (Object)null)
		{
			return source;
		}
		source = new GameObject("UISound").AddComponent<AudioSource>();
		source.spatialBlend = 0f;
		source.volume = 1f;
		return source;
	}

	public static void Play(AudioClip clip, float volume = 1f)
	{
		if (!((Object)(object)clip == (Object)null))
		{
			GetAudioSource().volume = volume * Audio.master * 0.4f;
			GetAudioSource().PlayOneShot(clip);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class PieOption : MonoBehaviour
{
	public PieShape background;

	public Image imageIcon;

	public Image overlayIcon;

	public PingWidget tutorialHighlight;
}


using System;
using UnityEngine;
using UnityEngine.UI;

[ExecuteInEditMode]
public class PieShape : Graphic
{
	[Range(0f, 1f)]
	public float outerSize = 1f;

	[Range(0f, 1f)]
	public float innerSize = 0.5f;

	public float startRadius = -45f;

	public float endRadius = 45f;

	public float border;

	public bool debugDrawing;

	public bool calculateAverage;

	public Rect drawRect { get; private set; }

	public Vector2 centrePosition { get; private set; }

	public Vector2 firstPosition { get; private set; }

	public Vector2 lastPosition { get; private set; }

	public Vector3 averagePosition { get; private set; } = Vector2.op_Implicit(default(Vector2));

	protected override void OnPopulateMesh(VertexHelper vbo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		Rect val2 = (drawRect = default(Rect));
		vbo.Clear();
		UIVertex simpleVert = UIVertex.simpleVert;
		float num = startRadius;
		float num2 = endRadius;
		if (startRadius > endRadius)
		{
			num2 = endRadius + 360f;
		}
		float num3 = Mathf.Floor((num2 - num) / 6f);
		if (num3 <= 1f)
		{
			return;
		}
		float num4 = (num2 - num) / num3;
		float num5 = num + (num2 - num) * 0.5f;
		averagePosition = default(Vector3);
		Color val3 = ((Graphic)this).color;
		val2 = ((Graphic)this).rectTransform.rect;
		float num6 = ((Rect)(ref val2)).height * 0.5f;
		Vector2 val4 = new Vector2(Mathf.Sin(num5 * (MathF.PI / 180f)), Mathf.Cos(num5 * (MathF.PI / 180f))) * border;
		int num7 = 0;
		firstPosition = Vector2.zero;
		lastPosition = Vector2.zero;
		for (float num8 = num; num8 < num2; num8 += num4)
		{
			if (debugDrawing)
			{
				val3 = ((!(val3 == Color.red)) ? Color.red : Color.white);
			}
			simpleVert.color = Color32.op_Implicit(val3);
			float num9 = Mathf.Sin(num8 * (MathF.PI / 180f));
			float num10 = Mathf.Cos(num8 * (MathF.PI / 180f));
			float num11 = num8 + num4;
			if (num11 > num2)
			{
				num11 = num2;
			}
			float num12 = Mathf.Sin(num11 * (MathF.PI / 180f));
			float num13 = Mathf.Cos(num11 * (MathF.PI / 180f));
			simpleVert.position = Vector2.op_Implicit(new Vector2(num9 * outerSize * num6, num10 * outerSize * num6) + val4);
			if (vbo.currentVertCount == 0)
			{
				firstPosition = Vector2.op_Implicit(simpleVert.position);
				if (calculateAverage)
				{
					averagePosition = simpleVert.position;
				}
			}
			else if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			vbo.AddVert(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num12 * outerSize * num6, num13 * outerSize * num6) + val4);
			if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			vbo.AddVert(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num12 * innerSize * num6, num13 * innerSize * num6) + val4);
			if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			lastPosition = Vector2.op_Implicit(simpleVert.position);
			vbo.AddVert(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num9 * innerSize * num6, num10 * innerSize * num6) + val4);
			if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			vbo.AddVert(simpleVert);
			vbo.AddTriangle(num7, num7 + 1, num7 + 2);
			vbo.AddTriangle(num7 + 2, num7 + 3, num7);
			num7 += 4;
		}
		if (calculateAverage)
		{
			averagePosition = new Vector3(averagePosition.x / (float)vbo.currentVertCount, averagePosition.y / (float)vbo.currentVertCount, averagePosition.z / (float)vbo.currentVertCount);
		}
		drawRect = new Rect(Mathf.Min(firstPosition.x, lastPosition.x), Mathf.Min(firstPosition.y, lastPosition.y), Mathf.Abs(firstPosition.x - lastPosition.x), Mathf.Abs(firstPosition.y - lastPosition.y));
		centrePosition = Vector2.Lerp(firstPosition, lastPosition, 0.5f);
	}
}


using UnityEngine;

public class PingManager : ListComponent<PingManager>
{
	public GameObjectRef PingWidgetRef;

	public RectTransform PingParent;

	public RectTransform TeamPingParent;

	public CanvasGroup AlphaCanvas;
}


using UnityEngine;
using UnityEngine.UI;

public class PingWidget : MonoBehaviour
{
	public RectTransform MoveTransform;

	public RectTransform ScaleTransform;

	public Image InnerImage;

	public Image OuterImage;

	public GameObject TeamLeaderRoot;

	public GameObject CancelHoverRoot;

	public SoundDefinition PingDeploySoundHostile;

	public SoundDefinition PingDeploySoundGoTo;

	public SoundDefinition PingDeploySoundDollar;

	public SoundDefinition PingDeploySoundLoot;

	public SoundDefinition PingDeploySoundNode;

	public SoundDefinition PingDeploySoundGun;

	public CanvasGroup FadeCanvas;
}


using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class CameraEx : MonoBehaviour
{
	public bool overrideAmbientLight;

	public AmbientMode ambientMode;

	public Color ambientGroundColor;

	public Color ambientEquatorColor;

	public Color ambientLight;

	public float ambientIntensity;

	public ReflectionProbe reflectionProbe;

	internal Color old_ambientLight;

	internal Color old_ambientGroundColor;

	internal Color old_ambientEquatorColor;

	internal float old_ambientIntensity;

	internal AmbientMode old_ambientMode;

	public float aspect;

	private Camera camera;
}


using UnityEngine;

public class SegmentMaskPositioning : MonoBehaviour
{
	public PlayerModel source;

	public GameObject headMask;

	public GameObject chestMask;

	public GameObject legsMask;

	public float xOffset = 0.75f;
}


using UnityEngine;

public class uiPlayerPreview : SingletonComponent<uiPlayerPreview>
{
	public enum EffectMode
	{
		Poster,
		Polaroid
	}

	public Camera previewCamera;

	public PlayerModel playermodel;

	public GameObject wantedSnapshotEffectPosterRoot;

	public GameObject wantedSnapshotEffectPolaroidRoot;

	public SegmentMaskPositioning segmentMask;
}


public enum EffectMode
{
	Poster,
	Polaroid
}


public class UIPlayerPreviewControls : SingletonComponent<UIPlayerPreviewControls>
{
	public float RotationSpeed = 90f;

	public float RotationLerpSpeed = 5f;

	public float RotationStopLerpSpeed = 2.5f;
}


using UnityEngine;
using UnityEngine.UI;

public class PowerBar : MonoBehaviour
{
	public static PowerBar Instance;

	public Image powerInner;

	public float fullSize;

	public CanvasGroup group;
}


using UnityEngine;
using UnityEngine.UI;

public class UIInvertedMaskImage : Image
{
	private Material cachedMaterial;

	public override Material materialForRendering
	{
		get
		{
			if ((Object)(object)cachedMaterial == (Object)null)
			{
				cachedMaterial = Object.Instantiate<Material>(((Graphic)this).materialForRendering);
				cachedMaterial.SetInt("_StencilComp", 6);
			}
			return cachedMaterial;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ProgressBar : UIBehaviour
{
	public static ProgressBar Instance;

	private Action<BasePlayer> action;

	public float timeFinished;

	private float timeCounter;

	public GameObject scaleTarget;

	public Image progressField;

	public Image iconField;

	public Text leftField;

	public Text rightField;

	public SoundDefinition clipOpen;

	public SoundDefinition clipCancel;

	private bool isOpen;

	public bool InstanceIsOpen
	{
		get
		{
			if ((Object)(object)Instance == (Object)(object)this)
			{
				return isOpen;
			}
			return Instance.InstanceIsOpen;
		}
	}
}


public static class ProgressBarUI
{
}


using UnityEngine;

public class RandomObjectEnableOnEnable : MonoBehaviour
{
	public GameObject[] objects;

	public void OnEnable()
	{
		objects[Random.Range(0, objects.Length)].SetActive(true);
	}
}


using Rust.UI;

public class RecordingSaved : SingletonComponent<RecordingSaved>
{
	public RustText Label;
}


using UnityEngine;

public class RepairCostIndicator : SingletonComponent<RepairCostIndicator>, IClientComponent
{
	public RepairCostIndicatorRow[] Rows;

	public CanvasGroup Fader;
}


public class RepairCostIndicatorRow : CostIndicatorRow
{
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

public abstract class RevealTransitionBase : BaseMonoBehaviour
{
	[Serializable]
	public struct Reveal
	{
		public FlexTransition Transition;

		[Min(0f)]
		public float Delay;
	}

	public Reveal[] Reveals = Array.Empty<Reveal>();
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

[Serializable]
public struct Reveal
{
	public FlexTransition Transition;

	[Min(0f)]
	public float Delay;
}


public class RevealTransitionOnEnable : RevealTransitionBase
{
}


using RTLTMPro;
using TMPro;

public class RTLTMP_InputField : TMP_InputField
{
	private static readonly FastStringBuilder inputBuilder = new FastStringBuilder(2048);

	public bool changeAlignment = true;
}


using Rust.UI;
using UnityEngine;

public class Scoreboard : MonoBehaviour, IClientComponent
{
	public class TeamColumn
	{
		public GameObject nameColumn;

		public GameObject[] activeColumns;
	}

	public static Scoreboard instance;

	public RustText scoreboardTitle;

	public RectTransform scoreboardRootContents;

	public RustText scoreLimitText;

	public GameObject teamPrefab;

	public GameObject columnPrefab;

	public GameObject dividerPrefab;

	public Color localPlayerColor;

	public Color otherPlayerColor;

	public TeamColumn[] teamColumns;

	public GameObject[] TeamPanels;
}


using UnityEngine;

public class TeamColumn
{
	public GameObject nameColumn;

	public GameObject[] activeColumns;
}


public class ScrollRectDisable : ListComponent<ScrollRectDisable>
{
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ScrollRectZoom : MonoBehaviour, IScrollHandler, IEventSystemHandler
{
	public ScrollRectEx scrollRect;

	public float zoom = 1f;

	public float max = 1.5f;

	public float min = 0.5f;

	public bool mouseWheelZoom = true;

	public float scrollAmount = 0.2f;

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)scrollRect).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	private void OnEnable()
	{
		SetZoom(zoom);
	}

	public void OnScroll(PointerEventData data)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (mouseWheelZoom)
		{
			SetZoom(zoom + scrollAmount * data.scrollDelta.y);
		}
	}

	public void SetZoom(float z, bool expZoom = true)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		z = Mathf.Clamp(z, min, max);
		zoom = z;
		Vector2 normalizedPosition = scrollRect.normalizedPosition;
		if (expZoom)
		{
			((Transform)scrollRect.content).localScale = Vector3.one * Mathf.Exp(zoom);
		}
		else
		{
			((Transform)scrollRect.content).localScale = Vector3.one * zoom;
		}
		scrollRect.normalizedPosition = normalizedPosition;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class SetMemorySlider : MonoBehaviour
{
	private void Awake()
	{
		((Component)this).GetComponent<Slider>().maxValue = Mathf.Min(4096, SystemInfo.systemMemorySize / 8);
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SleepingBagButton : MonoBehaviour
{
	public GameObject TimeLockRoot;

	public GameObject LockRoot;

	public GameObject UnavailableRoot;

	public Tooltip unavailableTooltip;

	public Phrase occupied;

	public Phrase underwater;

	public Phrase noRespawnZone;

	public Button ClickButton;

	public TextMeshProUGUI BagName;

	public TextMeshProUGUI ZoneName;

	public TextMeshProUGUI LockTime;

	public Image Icon;

	public Sprite SleepingBagSprite;

	public Sprite BedSprite;

	public Sprite BeachTowelSprite;

	public Sprite CamperSprite;

	public Image CircleRim;

	public Image CircleFill;

	public Image Background;

	public RustButton DeleteButton;

	public Image ConfirmSlider;

	public static Phrase toastHoldToUnclaimBag = new Phrase("hold_unclaim_bag", "Hold down the delete button to unclaim a sleeping bag");

	public GameObject CorpseRoot;

	public Image CorpseBackground;
}


using System.Globalization;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class SliderCookie : MonoBehaviour
{
	public void OnEnable()
	{
		RustSlider val = default(RustSlider);
		if (((Component)this).TryGetComponent<RustSlider>(ref val))
		{
			float result;
			float num = (float.TryParse(PlayerPrefs.GetString("SliderCookie_" + ((Object)this).name), NumberStyles.Float, CultureInfo.InvariantCulture, out result) ? result : val.ValueInternal);
			val.ValueInternal = num + 1f;
			val.Value = num;
			((UnityEvent<float>)(object)val.OnChanged).AddListener((UnityAction<float>)OnSliderChanged);
		}
	}

	public void OnDisable()
	{
		RustSlider val = default(RustSlider);
		if (!Application.isQuitting && ((Component)this).TryGetComponent<RustSlider>(ref val))
		{
			((UnityEvent<float>)(object)val.OnChanged).RemoveListener((UnityAction<float>)OnSliderChanged);
		}
	}

	private void OnSliderChanged(float v)
	{
		PlayerPrefs.SetString("SliderCookie_" + ((Object)this).name, v.ToString(CultureInfo.InvariantCulture));
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class StatusPanel : MonoBehaviour
{
	[SerializeField]
	[Header("On Status")]
	private RustText onStatusText;

	[SerializeField]
	private Image onStatusImage;

	[SerializeField]
	[Header("Off Status")]
	private RustText offStatusText;

	[SerializeField]
	private Image offStatusImage;

	public void SetStatus(bool status)
	{
		((Component)onStatusText).gameObject.SetActive(status);
		((Component)offStatusText).gameObject.SetActive(!status);
		((Component)onStatusImage).gameObject.SetActive(status);
		((Component)offStatusImage).gameObject.SetActive(!status);
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;

public class SteamFriendsList : MonoBehaviour
{
	[Serializable]
	public class onFriendSelectedEvent : UnityEvent<ulong, string>
	{
	}

	public RectTransform targetPanel;

	public SteamUserButton userButton;

	public bool IncludeFriendsList = true;

	public bool IncludeRecentlySeen;

	public bool IncludeLastAttacker;

	public bool IncludeRecentlyPlayedWith;

	public bool ShowTeamFirst;

	public bool ExcludeTeamMembers;

	public bool HideSteamIdsInStreamerMode;

	public bool IncludeContacts;

	public bool EnableCopy;

	public bool RefreshOnEnable = true;

	public onFriendSelectedEvent onFriendSelected;

	public Func<ulong, bool> shouldShowPlayer;
}


using System;
using UnityEngine.Events;

[Serializable]
public class onFriendSelectedEvent : UnityEvent<ulong, string>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SteamUserButton : MonoBehaviour
{
	public RustButton copyButton;

	public RustText steamName;

	public RustText steamInfo;

	public RawImage avatar;

	public Color colorTeamOnline;

	public Color colorTeamOffline;

	public Color colorFriendOnline;

	public Color colorFriendOffline;

	public Color colorOnline;

	public Color colorOffline;

	public ulong SteamId { get; private set; }

	public string Username { get; private set; }

	public void CopySteamId()
	{
		GUIUtility.systemCopyBuffer = SteamId.ToString();
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class TabToggle : MonoBehaviour
{
	public Transform TabHolder;

	public Transform ContentHolder;

	public bool FadeIn;

	public bool FadeOut;

	public void Awake()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)TabHolder))
		{
			return;
		}
		for (int i = 0; i < TabHolder.childCount; i++)
		{
			Button c = ((Component)TabHolder.GetChild(i)).GetComponent<Button>();
			if (Object.op_Implicit((Object)(object)c))
			{
				((UnityEvent)c.onClick).AddListener((UnityAction)delegate
				{
					SwitchTo(c);
				});
			}
		}
	}

	public void SwitchTo(Button sourceTab)
	{
		string name = ((Object)((Component)sourceTab).transform).name;
		if (Object.op_Implicit((Object)(object)TabHolder))
		{
			for (int i = 0; i < TabHolder.childCount; i++)
			{
				Button component = ((Component)TabHolder.GetChild(i)).GetComponent<Button>();
				if (Object.op_Implicit((Object)(object)component))
				{
					((Selectable)component).interactable = ((Object)component).name != name;
				}
			}
		}
		if (!Object.op_Implicit((Object)(object)ContentHolder))
		{
			return;
		}
		for (int j = 0; j < ContentHolder.childCount; j++)
		{
			Transform child = ContentHolder.GetChild(j);
			if (((Object)child).name == name)
			{
				Show(((Component)child).gameObject);
			}
			else
			{
				Hide(((Component)child).gameObject);
			}
		}
	}

	private void Hide(GameObject go)
	{
		if (!go.activeSelf)
		{
			return;
		}
		CanvasGroup val = default(CanvasGroup);
		if (FadeOut && go.TryGetComponent<CanvasGroup>(ref val))
		{
			LeanTween.alphaCanvas(val, 0f, 0.1f).setOnComplete((Action)delegate
			{
				go.SetActive(false);
			});
		}
		else
		{
			go.SetActive(false);
		}
	}

	private void Show(GameObject go)
	{
		if (!go.activeSelf)
		{
			CanvasGroup val = default(CanvasGroup);
			if (FadeIn && go.TryGetComponent<CanvasGroup>(ref val))
			{
				val.alpha = 0f;
				LeanTween.alphaCanvas(val, 1f, 0.1f);
			}
			go.SetActive(true);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class TeamMemberElement : MonoBehaviour
{
	public RustText nameText;

	public RawImage icon;

	public Color onlineColor;

	public Color offlineColor;

	public Color deadColor;

	public Color woundedColor;

	public RawImage memberIcon;

	public RawImage leaderIcon;

	public RawImage deadIcon;

	public RawImage woundedIcon;

	public int teamIndex;

	public CanvasGroup EditButton;
}


using System;
using Rust.UI;
using UnityEngine;

public class TeamUI : MonoBehaviour
{
	public static Phrase invitePhrase = new Phrase("team.invited", "{0} has invited you to join a team");

	public RectTransform MemberPanel;

	public GameObject memberEntryPrefab;

	public GameObjectRef InviteFriendDialog;

	public TeamMemberElement[] elements;

	public GameObject NoTeamPanel;

	public GameObject TeamPanel;

	public GameObject LeaveTeamButton;

	public GameObject InviteAcceptPanel;

	public GameObject InviteButton;

	public RustText inviteText;

	public static bool dirty = true;

	[NonSerialized]
	public static ulong pendingTeamID;

	[NonSerialized]
	public static string pendingTeamLeaderName;

	public GameObject teamMemberDetailsPanel;

	public RustText selectedTeamMemberNameText;
}


using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class TextEntryCookie : MonoBehaviour
{
	public InputField control => ((Component)this).GetComponent<InputField>();

	private void OnEnable()
	{
		string @string = PlayerPrefs.GetString("TextEntryCookie_" + ((Object)this).name);
		if (!string.IsNullOrEmpty(@string))
		{
			control.text = @string;
		}
		((UnityEvent<string>)(object)control.onValueChanged).Invoke(control.text);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			PlayerPrefs.SetString("TextEntryCookie_" + ((Object)this).name, control.text);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class TimeSlider : MonoBehaviour
{
	private Slider slider;

	private void Start()
	{
		slider = ((Component)this).GetComponent<Slider>();
	}

	private void Update()
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			slider.value = TOD_Sky.Instance.Cycle.Hour;
		}
	}

	public void OnValue(float f)
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			TOD_Sky.Instance.Cycle.Hour = f;
			TOD_Sky.Instance.UpdateAmbient();
			TOD_Sky.Instance.UpdateReflection();
			TOD_Sky.Instance.UpdateFog();
		}
	}
}


using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class ToggleCookie : MonoBehaviour
{
	public void OnEnable()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Expected O, but got Unknown
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected O, but got Unknown
		RustButton val = default(RustButton);
		if (((Component)this).TryGetComponent<RustButton>(ref val))
		{
			bool result;
			bool flag = (bool.TryParse(PlayerPrefs.GetString("ToggleCookie_" + ((Object)this).name), out result) ? result : val.Value);
			val.Toggle(flag, true, true);
			val.OnPressed.AddListener(new UnityAction(OnPressed));
			val.OnReleased.AddListener(new UnityAction(OnReleased));
		}
	}

	public void OnDisable()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		RustButton val = default(RustButton);
		if (!Application.isQuitting && ((Component)this).TryGetComponent<RustButton>(ref val))
		{
			val.OnPressed.RemoveListener(new UnityAction(OnPressed));
			val.OnReleased.RemoveListener(new UnityAction(OnReleased));
		}
	}

	private void OnPressed()
	{
		OnChanged(v: true);
	}

	private void OnReleased()
	{
		OnChanged(v: false);
	}

	private void OnChanged(bool v)
	{
		PlayerPrefs.SetString("ToggleCookie_" + ((Object)this).name, v.ToString());
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ToggleGroupCookie : MonoBehaviour
{
	public ToggleGroup group => ((Component)this).GetComponent<ToggleGroup>();

	private void OnEnable()
	{
		string @string = PlayerPrefs.GetString("ToggleGroupCookie_" + ((Object)this).name);
		if (!string.IsNullOrEmpty(@string))
		{
			Transform val = FindChild(((Component)this).transform, @string);
			if (Object.op_Implicit((Object)(object)val))
			{
				Toggle component = ((Component)val).GetComponent<Toggle>();
				if (Object.op_Implicit((Object)(object)component))
				{
					Toggle[] componentsInChildren = ((Component)this).GetComponentsInChildren<Toggle>(true);
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].isOn = false;
					}
					component.isOn = false;
					component.isOn = true;
					SetupListeners();
					return;
				}
			}
		}
		Toggle val2 = group.ActiveToggles().FirstOrDefault((Func<Toggle, bool>)((Toggle x) => x.isOn));
		if (Object.op_Implicit((Object)(object)val2))
		{
			val2.isOn = false;
			val2.isOn = true;
		}
		SetupListeners();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Toggle[] componentsInChildren = ((Component)this).GetComponentsInChildren<Toggle>(true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				((UnityEvent<bool>)(object)componentsInChildren[i].onValueChanged).RemoveListener((UnityAction<bool>)OnToggleChanged);
			}
		}
	}

	private void SetupListeners()
	{
		Toggle[] componentsInChildren = ((Component)this).GetComponentsInChildren<Toggle>(true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			((UnityEvent<bool>)(object)componentsInChildren[i].onValueChanged).AddListener((UnityAction<bool>)OnToggleChanged);
		}
	}

	private void OnToggleChanged(bool b)
	{
		Toggle val = ((IEnumerable<Toggle>)((Component)this).GetComponentsInChildren<Toggle>()).FirstOrDefault((Func<Toggle, bool>)((Toggle x) => x.isOn));
		if (Object.op_Implicit((Object)(object)val))
		{
			PlayerPrefs.SetString("ToggleGroupCookie_" + ((Object)this).name, ((Object)((Component)val).gameObject).name);
		}
	}

	private static Transform FindChild(Transform parent, string name)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		foreach (Transform item in parent)
		{
			Transform val = item;
			if (((Object)val).name == name)
			{
				return val;
			}
		}
		return null;
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ToolsHUDUI : MonoBehaviour
{
	[SerializeField]
	private GameObject prefab;

	[SerializeField]
	private Transform parent;

	private bool initialised;

	protected void OnEnable()
	{
		Init();
	}

	private void Init()
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Expected O, but got Unknown
		if (initialised)
		{
			return;
		}
		UIHUD instance = SingletonComponent<UIHUD>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			return;
		}
		initialised = true;
		Transform[] componentsInChildren = ((Component)instance).GetComponentsInChildren<Transform>();
		foreach (Transform val in componentsInChildren)
		{
			string name = ((Object)val).name;
			if (!name.ToLower().StartsWith("gameui.hud."))
			{
				continue;
			}
			if (name.ToLower() == "gameui.hud.crosshair")
			{
				foreach (Transform item in val)
				{
					Transform val2 = item;
					AddToggleObj(((Object)val2).name, "<color=yellow>Crosshair sub:</color> " + ((Object)val2).name);
				}
			}
			AddToggleObj(name, name.Substring(11));
		}
	}

	private void AddToggleObj(string trName, string labelText)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = Object.Instantiate<GameObject>(prefab, Vector3.zero, Quaternion.identity, parent);
		((Object)obj).name = trName;
		ToggleHUDLayer component = obj.GetComponent<ToggleHUDLayer>();
		component.hudComponentName = trName;
		((TMP_Text)component.textControl).text = labelText;
	}

	public void SelectAll()
	{
		Toggle[] componentsInChildren = ((Component)parent).GetComponentsInChildren<Toggle>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isOn = true;
		}
	}

	public void SelectNone()
	{
		Toggle[] componentsInChildren = ((Component)parent).GetComponentsInChildren<Toggle>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isOn = false;
		}
	}
}


using UnityEngine;

public class Tooltip : BaseMonoBehaviour, IClientComponent
{
	public enum DelayType
	{
		Short,
		Long
	}

	public static TooltipContainer Current;

	public GameObject TooltipObject;

	[TextArea]
	public string Text;

	public string token = "";

	[Tooltip("Delay timing before the tooltip appears. Short is 0.15 seconds, Long is 0.5 seconds.")]
	[Header("Additional Settings - Delay")]
	[Space(10f)]
	public DelayType delayBeforeAppearing;

	[Tooltip("What position relative to the object that the tooltip should be spawned on.")]
	[Header("Advanced Settings - Position")]
	[Space(10f)]
	public TooltipContainer.PositionMode positionMode;

	[Tooltip("Spawn the tooltip relative to the mouse position rather than the objects.")]
	public bool useMousePosition;

	[Tooltip("Anchor tooltip at the centre of the object rather than a specific side.")]
	public bool useCentre;

	[Tooltip("Use percentage of source width/Height for horizontal offset in Left/Right or Up/Down mode.")]
	public bool usePercentageOffset;

	[Tooltip("Percentage of the source rect width to offset (0.0 - 1.0).")]
	public float offsetPercent;

	[Tooltip("How far to spawn from the objects position")]
	public Vector2 offset = new Vector2(8f, 8f);

	private object[] localizationArguments;

	public string english => Text;
}


public enum DelayType
{
	Short,
	Long
}


using Rust.UI;
using UnityEngine;

public class TooltipContainer : MonoBehaviour
{
	public enum PositionMode
	{
		Auto,
		Top,
		Bottom,
		Left,
		Right,
		TopLeft
	}

	public Transform ScaleRoot;

	public RustText TooltipText;

	public RectTransform OverrideLayoutRoot;
}


public enum PositionMode
{
	Auto,
	Top,
	Bottom,
	Left,
	Right,
	TopLeft
}


public class TooltipContainer_Emoji : TooltipContainer
{
	public TmProEmojiRedirector EmojiRedirector;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class TutorialHelpPopup : ListComponent<TutorialHelpPopup>
{
	public RustText HelpText;

	public Image HelpImage;

	public VideoPlayer HelpVideo;

	public RawImage HelpVideoTexture;

	public CanvasGroup Group;

	public Canvas Canvas;
}


public class TutorialStartModal : UIDialog
{
}


using System.Collections;
using Rust;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class TypeThroughButton : Button, IUpdateSelectedHandler, IEventSystemHandler
{
	public InputField typingTarget;

	private Event _processingEvent = new Event();

	public void OnUpdateSelected(BaseEventData eventData)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected O, but got Unknown
		if ((Object)(object)typingTarget == (Object)null)
		{
			return;
		}
		while (Event.PopEvent(_processingEvent))
		{
			if ((int)_processingEvent.rawType == 4 && _processingEvent.character != 0)
			{
				Event e = new Event(_processingEvent);
				((MonoBehaviour)Global.Runner).StartCoroutine(DelayedActivateTextField(e));
				break;
			}
		}
		((AbstractEventData)eventData).Use();
	}

	private IEnumerator DelayedActivateTextField(Event e)
	{
		typingTarget.ActivateInputField();
		((Selectable)typingTarget).Select();
		if (e.character != ' ')
		{
			InputField obj = typingTarget;
			obj.text += " ";
		}
		typingTarget.MoveTextEnd(false);
		typingTarget.ProcessEvent(e);
		yield return null;
		typingTarget.caretPosition = typingTarget.text.Length;
		typingTarget.ForceLabelUpdate();
	}
}


using UnityEngine;

public class UIAutoPanelCloser : MonoBehaviour
{
	public UIDialog Dialog;
}


using UnityEngine;

public class UIBackgroundBlur : ListComponent<UIBackgroundBlur>, IClientComponent
{
	public float amount = 1f;

	public static float currentMax
	{
		get
		{
			if (ListComponent<UIBackgroundBlur>.InstanceList.Count == 0)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < ListComponent<UIBackgroundBlur>.InstanceList.Count; i++)
			{
				num = Mathf.Max(ListComponent<UIBackgroundBlur>.InstanceList[i].amount, num);
			}
			return num;
		}
	}
}


using Rust.UI;

public class UIBinocularOverlay : UIBlackoutOverlay
{
	public RustText RangeText;
}


public class UIBlackoutDeathOverlay : UIBlackoutOverlay
{
}


using System.Collections.Generic;
using UnityEngine;

public class UIBlackoutOverlay : MonoBehaviour
{
	public enum blackoutType
	{
		FULLBLACK = 0,
		BINOCULAR = 1,
		SCOPE = 2,
		HELMETSLIT = 3,
		SNORKELGOGGLE = 4,
		NVG = 5,
		FULLWHITE = 6,
		SUNGLASSES = 7,
		PRISONERHOOD = 8,
		DEATH = 9,
		OBSCUREVISION = 10,
		NONE = 64
	}

	public CanvasGroup group;

	public static Dictionary<blackoutType, UIBlackoutOverlay> instances;

	public blackoutType overlayType = blackoutType.NONE;

	public bool overrideCanvasScaling;

	public float referenceScale = 1f;
}


public enum blackoutType
{
	FULLBLACK = 0,
	BINOCULAR = 1,
	SCOPE = 2,
	HELMETSLIT = 3,
	SNORKELGOGGLE = 4,
	NVG = 5,
	FULLWHITE = 6,
	SUNGLASSES = 7,
	PRISONERHOOD = 8,
	DEATH = 9,
	OBSCUREVISION = 10,
	NONE = 64
}


using System;
using Rust.UI;
using UnityEngine;

public class UICameraOverlay : SingletonComponent<UICameraOverlay>
{
	public static readonly Phrase FocusOffText = new Phrase("camera.infinite_focus", "Infinite Focus");

	public static readonly Phrase FocusAutoText = new Phrase("camera.auto_focus", "Auto Focus");

	public static readonly Phrase FocusManualText = new Phrase("camera.manual_focus", "Manual Focus");

	public static readonly Phrase FlashOn = new Phrase("camera.flash_is_on", "Flash [ON]");

	public static readonly Phrase FlashOff = new Phrase("camera.flash_is_off", "Flash [OFF]");

	public CanvasGroup CanvasGroup;

	public RustText FocusModeLabel;

	public RustText FlashLabel;

	public void Show()
	{
		CanvasGroup.alpha = 1f;
	}

	public void Hide()
	{
		CanvasGroup.alpha = 0f;
	}

	public void SetFlash(bool flashEnabled)
	{
		FlashLabel.SetPhrase(flashEnabled ? FlashOn : FlashOff, Array.Empty<object>());
	}

	public void SetFocusMode(CameraFocusMode mode)
	{
		switch (mode)
		{
		case CameraFocusMode.Auto:
			FocusModeLabel.SetPhrase(FocusAutoText, Array.Empty<object>());
			break;
		case CameraFocusMode.Manual:
			FocusModeLabel.SetPhrase(FocusManualText, Array.Empty<object>());
			break;
		default:
			FocusModeLabel.SetPhrase(FocusOffText, Array.Empty<object>());
			break;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIConversationScreen : SingletonComponent<UIConversationScreen>, IUIScreen
{
	public NeedsCursor needsCursor;

	public RectTransform conversationPanel;

	public RustText conversationSpeechBody;

	public RustText conversationProviderName;

	public Image conversationProviderImage;

	public RustButton[] responseButtons;

	public RectTransform letterBoxTop;

	public RectTransform letterBoxBottom;

	public CanvasGroup responseCanvasGroup;

	public GameObject cancelButton;

	protected CanvasGroup canvasGroup;

	public UIMissionInfoConversation missionInfo;

	public UIMissionInfoConversation missionInfoComplete;

	public CanvasGroup conversationCanvas;

	public UIEscapeCapture escapeCapture;
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class UIDeathScreen : SingletonComponent<UIDeathScreen>, IUIScreen
{
	[Serializable]
	public struct RespawnColourScheme
	{
		public Color BackgroundColour;

		public Color CircleRimColour;

		public Color CircleFillColour;
	}

	public LifeInfographic previousLifeInfographic;

	public Animator screenAnimator;

	public bool fadeIn;

	public Button ReportCheatButton;

	public MapView View;

	public List<SleepingBagButton> sleepingBagButtons = new List<SleepingBagButton>();

	public GameObject loadingIndicator;

	public RespawnColourScheme[] RespawnColourSchemes;

	public GameObject RespawnScrollGradient;

	public ScrollRect RespawnScrollRect;

	public ExpandedLifeStats ExpandedStats;

	public GameObject OpenStatsButton;

	public CanvasGroup StreamerModeContainer;

	public GameObject SafeZoneInfo;

	public Image FadeImage;
}


using System;
using UnityEngine;

[Serializable]
public struct RespawnColourScheme
{
	public Color BackgroundColour;

	public Color CircleRimColour;

	public Color CircleFillColour;
}


using System;
using UnityEngine;
using UnityEngine.Events;

public class UIEscapeCapture : ListComponent<UIEscapeCapture>
{
	public UnityEvent onEscape = new UnityEvent();

	[Tooltip("If true, pressing escape will call only this callback and not any others.")]
	public bool blockOtherCallbacks = true;

	[Tooltip("Set this to true if you want this EscapeCapture to take priority over any older EscapeCapture when enabled. Surely this should be default?")]
	public bool insertAtTop = true;

	[ClientVar(ClientAdmin = true)]
	public static bool debug;

	public override void Setup()
	{
		if (!ListComponent<UIEscapeCapture>.InstanceList.Contains(this))
		{
			if (insertAtTop && ListComponent<UIEscapeCapture>.InstanceList.Count > 0)
			{
				ListComponent<UIEscapeCapture>.InstanceList.Insert(0, this);
			}
			else
			{
				ListComponent<UIEscapeCapture>.InstanceList.Add(this);
			}
		}
	}

	public static bool EscapePressed()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<UIEscapeCapture> enumerator = ListComponent<UIEscapeCapture>.InstanceList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				UIEscapeCapture current = enumerator.Current;
				if (debug)
				{
					Debug.Log((object)("Escape key pressed by: " + ((object)current).GetType().Name + " - " + ((Object)current).name));
				}
				current.onEscape.Invoke();
				if (current.blockOtherCallbacks)
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIFogOverlay : MonoBehaviour
{
	public static UIFogOverlay Instance;

	public CanvasGroup group;

	public Color baseColor;

	public Image overlayImage;
}


using UnityEngine;
using UnityEngine.UI;

public class UIGene : MonoBehaviour
{
	public GameObject Child;

	public Color PositiveColour;

	public Color NegativeColour;

	public Color PositiveTextColour;

	public Color NegativeTextColour;

	public Image ImageBG;

	public Text TextGene;

	public void Init(GrowableGene gene)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = gene.IsPositive();
		((Graphic)ImageBG).color = (flag ? PositiveColour : NegativeColour);
		((Graphic)TextGene).color = (flag ? PositiveTextColour : NegativeTextColour);
		TextGene.text = gene.GetDisplayCharacter();
		Show();
	}

	public void InitPrevious(GrowableGene gene)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)ImageBG).color = Color.black;
		((Graphic)TextGene).color = Color.grey;
		TextGene.text = GrowableGene.GetDisplayCharacter(gene.PreviousType);
		Show();
	}

	public void Hide()
	{
		Child.gameObject.SetActive(false);
	}

	public void Show()
	{
		Child.gameObject.SetActive(true);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIGenesDisplay : MonoBehaviour
{
	public UIGene[] GeneUI;

	public Text[] TextLinks;

	public Text[] TextDiagLinks;

	public void Init(GrowableGenes genes)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		GrowableGene[] genes2 = genes.Genes;
		foreach (GrowableGene gene in genes2)
		{
			GeneUI[num].Init(gene);
			num++;
			if (num < genes.Genes.Length)
			{
				((Graphic)TextLinks[num - 1]).color = (genes.Genes[num].IsPositive() ? GeneUI[num - 1].PositiveColour : GeneUI[num - 1].NegativeColour);
			}
		}
	}

	public void InitDualRow(GrowableGenes genes, bool firstRow)
	{
		if (firstRow)
		{
			InitFirstRow(genes);
		}
		else
		{
			InitSecondRow(genes);
		}
	}

	private void InitFirstRow(GrowableGenes genes)
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		GrowableGene[] genes2 = genes.Genes;
		foreach (GrowableGene growableGene in genes2)
		{
			if (growableGene.Type != growableGene.PreviousType)
			{
				GeneUI[num].InitPrevious(growableGene);
			}
			else
			{
				GeneUI[num].Init(growableGene);
			}
			num++;
			if (num >= genes.Genes.Length)
			{
				break;
			}
			if (growableGene.Type != growableGene.PreviousType || genes.Genes[num].Type != genes.Genes[num].PreviousType)
			{
				((Behaviour)TextLinks[num - 1]).enabled = false;
				continue;
			}
			((Behaviour)TextLinks[num - 1]).enabled = true;
			((Graphic)TextLinks[num - 1]).color = (genes.Genes[num].IsPositive() ? GeneUI[num - 1].PositiveColour : GeneUI[num - 1].NegativeColour);
		}
	}

	private void InitSecondRow(GrowableGenes genes)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		GrowableGene[] genes2 = genes.Genes;
		foreach (GrowableGene growableGene in genes2)
		{
			if (growableGene.Type != growableGene.PreviousType)
			{
				GeneUI[num].Init(growableGene);
			}
			else
			{
				GeneUI[num].Hide();
			}
			num++;
			if (num >= genes.Genes.Length)
			{
				break;
			}
			((Behaviour)TextLinks[num - 1]).enabled = false;
			GrowableGene growableGene2 = genes.Genes[num];
			((Behaviour)TextDiagLinks[num - 1]).enabled = false;
			if (growableGene.Type != growableGene.PreviousType && growableGene2.Type != growableGene2.PreviousType)
			{
				((Behaviour)TextLinks[num - 1]).enabled = true;
				((Graphic)TextLinks[num - 1]).color = (growableGene2.IsPositive() ? GeneUI[num - 1].PositiveColour : GeneUI[num - 1].NegativeColour);
			}
			else if (growableGene.Type == growableGene.PreviousType && growableGene2.Type != growableGene2.PreviousType)
			{
				ShowDiagLink(num - 1, -43f, growableGene2);
			}
			else if (growableGene.Type != growableGene.PreviousType && growableGene2.Type == growableGene2.PreviousType)
			{
				ShowDiagLink(num - 1, 43f, growableGene2);
			}
		}
	}

	private void ShowDiagLink(int index, float rotation, GrowableGene nextGene)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localEulerAngles = ((Component)TextDiagLinks[index]).transform.localEulerAngles;
		localEulerAngles.z = rotation;
		((Component)TextDiagLinks[index]).transform.localEulerAngles = localEulerAngles;
		((Behaviour)TextDiagLinks[index]).enabled = true;
		((Graphic)TextDiagLinks[index]).color = (nextGene.IsPositive() ? GeneUI[index].PositiveColour : GeneUI[index].NegativeColour);
	}
}


using UnityEngine;

public class UIGodOverlay : SingletonComponent<UIGodOverlay>
{
	public CanvasGroup invisCanvas;
}


public class UIIngame : SingletonComponent<UIIngame>
{
}


using UnityEngine;

public class UIInvisOverlay : SingletonComponent<UIInvisOverlay>
{
	public CanvasGroup invisCanvas;
}


using Rust.UI;
using UnityEngine;

public class UIMissionInfoConversation : MonoBehaviour
{
	public RustText MissionName;

	public RustText[] MissionObjectives;

	public GameObject TimerRoot;

	public RustText TimerText;

	public VirtualItemIcon[] RewardIcons;

	public UIMissionNonItemReward[] NonItemRewards;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIMissionNonItemReward : MonoBehaviour
{
	public RustText TextField;

	public Image Icon;

	public void Populate(BaseMission.NonItemReward reward)
	{
		TextField.SetPhrase(reward.DisplayPhrase, Array.Empty<object>());
		Icon.sprite = reward.DisplaySprite;
	}
}


public class UIObscureVisionOverlay : UIBlackoutOverlay
{
	public float FadeSpeed = 10f;
}


using UnityEngine;
using UnityEngine.UI;

public class UIPixelDownscale : MonoBehaviour
{
	public CanvasScaler CanvasScaler;

	private void Awake()
	{
		if ((Object)(object)CanvasScaler == (Object)null)
		{
			CanvasScaler = ((Component)this).GetComponent<CanvasScaler>();
			if ((Object)(object)CanvasScaler == (Object)null)
			{
				Debug.LogError((object)(((object)this).GetType().Name + " is attached to a gameobject that is missing a canvas scaler"));
				Object.Destroy((Object)(object)((Component)this).gameObject);
			}
		}
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if ((float)Screen.width < CanvasScaler.referenceResolution.x || (float)Screen.height < CanvasScaler.referenceResolution.y)
		{
			CanvasScaler.uiScaleMode = (ScaleMode)0;
		}
		else
		{
			CanvasScaler.uiScaleMode = (ScaleMode)1;
		}
	}
}


using Facepunch;
using UnityEngine;

public class UIPrefab : MonoBehaviour
{
	public GameObject prefabSource;

	internal GameObject createdGameObject;

	private void Awake()
	{
		if (!((Object)(object)prefabSource == (Object)null) && !((Object)(object)createdGameObject != (Object)null))
		{
			createdGameObject = Instantiate.GameObject(prefabSource, (Transform)null);
			((Object)createdGameObject).name = ((Object)prefabSource).name;
			createdGameObject.transform.SetParent(((Component)this).transform, false);
			createdGameObject.Identity();
		}
	}

	public void SetVisible(bool visible)
	{
		if (!((Object)(object)createdGameObject == (Object)null) && createdGameObject.activeSelf != visible)
		{
			createdGameObject.SetActive(visible);
		}
	}
}


public class UIPrisonerHoodOverlay : UIBlackoutOverlay
{
}


using UnityEngine;
using UnityEngine.UI;

public abstract class UIRoot : MonoBehaviour
{
	private GraphicRaycaster[] graphicRaycasters;

	public Canvas overlayCanvas;

	private void ToggleRaycasters(bool state)
	{
		for (int i = 0; i < graphicRaycasters.Length; i++)
		{
			GraphicRaycaster val = graphicRaycasters[i];
			if (((Behaviour)val).enabled != state)
			{
				((Behaviour)val).enabled = state;
			}
		}
	}

	protected virtual void Awake()
	{
	}

	protected virtual void Start()
	{
		graphicRaycasters = ((Component)this).GetComponentsInChildren<GraphicRaycaster>(true);
	}

	protected void Update()
	{
		Refresh();
	}

	protected abstract void Refresh();
}


public class UIRootPixel : UIRoot
{
	protected override void Refresh()
	{
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.UI;

public class UIRootScaled : UIRoot
{
	private static UIRootScaled Instance;

	public bool OverrideReference;

	public Vector2 TargetReference = new Vector2(1280f, 720f);

	public CanvasScaler scaler;

	public static Canvas DragOverlayCanvas => Instance.overlayCanvas;

	protected override void Awake()
	{
		Instance = this;
		base.Awake();
	}

	protected override void Refresh()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1280f / Graphics.uiscale, 720f / Graphics.uiscale);
		if (OverrideReference)
		{
			((Vector2)(ref val))..ctor(TargetReference.x / Graphics.uiscale, TargetReference.y / Graphics.uiscale);
		}
		if (scaler.referenceResolution != val)
		{
			scaler.referenceResolution = val;
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIScale : MonoBehaviour, IClientComponent
{
	public CanvasScaler scaler;
}


using UnityEngine;

public class UIScalerOverride : MonoBehaviour
{
	public AnimationCurve scaleCurve = AnimationCurve.Linear(0f, 2f, 1f, 1f);
}


using UnityEngine;
using UnityEngine.UI;

public class UIScopeOverlay : MonoBehaviour
{
	public CanvasGroup group;

	public static UIScopeOverlay instance;

	public Image scopeImage;
}


public interface IUIScreen
{
}


using TMPro;
using UnityEngine;

public class UISleepingScreen : SingletonComponent<UISleepingScreen>, IUIScreen
{
	protected CanvasGroup canvasGroup;

	private bool visible;

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		canvasGroup = ((Component)this).GetComponent<CanvasGroup>();
		visible = true;
	}

	public void SetVisible(bool b)
	{
		if (visible != b)
		{
			visible = b;
			canvasGroup.alpha = (visible ? 1f : 0f);
			((Component)SingletonComponent<UISleepingScreen>.Instance).gameObject.SetChildComponentsEnabled<TMP_Text>(visible);
		}
	}
}


using UnityEngine;

public class UISoundPlayer : MonoBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class UIVoiceIcon : MonoBehaviour
{
	public Text nameText;

	public RawImage avatar;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIWounded : MonoBehaviour
{
	public CanvasGroup group;

	public Image chanceFill;

	public RustText chanceText;

	public Image timeRemainingFill;

	public RustText timeRemainingText;
}


using UnityEngine;

public class UI_LocalVoice : PriorityListComponent<UI_LocalVoice>
{
	public CanvasGroup voiceCanvas;

	public CanvasGroup levelImage;
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DragMe : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public static DragMe dragging;

	public static GameObject dragIcon;

	public static Image dragImage;

	public static object data;

	[NonSerialized]
	public string dragType = "generic";

	protected virtual Canvas TopCanvas => UIRootScaled.DragOverlayCanvas;

	public virtual void OnBeginDrag(PointerEventData eventData)
	{
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
	}

	public static void SetDropAppearance()
	{
	}

	public virtual void OnEndDrag(PointerEventData eventData)
	{
	}

	public void CancelDrag()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Expected O, but got Unknown
		OnEndDrag(new PointerEventData(EventSystem.current));
	}
}


public interface IDraggable
{
}


using UnityEngine;

public class DragMeCustomParent : DragMe
{
	public Canvas OverrideCanvas;

	public bool ShouldCancelOnDrop;
}


using UnityEngine;
using UnityEngine.EventSystems;

public class DropMe : MonoBehaviour, IDropHandler, IEventSystemHandler
{
	public string[] droppableTypes;

	public virtual void OnDrop(PointerEventData eventData)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class GridLayoutGroupNeat : GridLayoutGroup
{
	private float IdealCellWidth(float cellSize)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((LayoutGroup)this).rectTransform.rect;
		float num = ((Rect)(ref rect)).x + (float)(((LayoutGroup)this).padding.left + ((LayoutGroup)this).padding.right) * 0.5f;
		float num2 = Mathf.Floor(num / cellSize);
		return num / num2 - base.m_Spacing.x;
	}

	public override void SetLayoutHorizontal()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 cellSize = base.m_CellSize;
		base.m_CellSize.x = IdealCellWidth(cellSize.x);
		((GridLayoutGroup)this).SetLayoutHorizontal();
		base.m_CellSize = cellSize;
	}

	public override void SetLayoutVertical()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 cellSize = base.m_CellSize;
		base.m_CellSize.x = IdealCellWidth(cellSize.x);
		((GridLayoutGroup)this).SetLayoutVertical();
		base.m_CellSize = cellSize;
	}
}


using Rust.Localization;
using UnityEngine;

public class LocalizeText : MonoBehaviour, IClientComponent, ILocalize
{
	public enum SpecialMode
	{
		None,
		AllUppercase,
		AllLowercase
	}

	public string token;

	[TextArea]
	public string english;

	public string append;

	public SpecialMode specialMode;

	public string LanguageToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	public string LanguageEnglish
	{
		get
		{
			return english;
		}
		set
		{
			english = value;
		}
	}
}


public enum SpecialMode
{
	None,
	AllUppercase,
	AllLowercase
}


using UnityEngine.UI;

public class NonDrawingGraphic : Graphic
{
	public override void SetMaterialDirty()
	{
	}

	public override void SetVerticesDirty()
	{
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		vh.Clear();
	}
}


using UnityEngine.Events;
using UnityEngine.EventSystems;

public class RectChangeEvent : UIBehaviour
{
	public UnityEvent action;

	protected override void OnRectTransformDimensionsChange()
	{
		action.Invoke();
	}
}


using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class RightClickReceiver : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public UnityEvent ClickReceiver;

	public void OnPointerClick(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1)
		{
			UnityEvent clickReceiver = ClickReceiver;
			if (clickReceiver != null)
			{
				clickReceiver.Invoke();
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class AlphaSinPulse : MonoBehaviour
{
	public CanvasGroup target;

	public float speed = 3f;

	public float amplitude = 2f;

	public bool preview;
}


using UnityEngine;

public static class EaseExtensions
{
	public static AnimationCurve FadeInFadeOutCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.5f, 1f),
		new Keyframe(1f, 0f)
	});
}


using UnityEngine;

public class ShowIfConvarEnabled : MonoBehaviour
{
	public string Convar = "";
}


using UnityEngine;

public class WorkshopSettingsSwitcher : MonoBehaviour
{
	public TextAsset SettingsFile;
}


public interface IVitalNotice
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class VitalInfo : MonoBehaviour, IClientComponent, IVitalNotice
{
	public enum Vital
	{
		BuildingBlocked,
		CanBuild,
		Crafting,
		CraftLevel1,
		CraftLevel2,
		CraftLevel3,
		DecayProtected,
		Decaying,
		SafeZone,
		Buffed,
		Pet,
		ModifyClan,
		DartEffects,
		NegativeEffects
	}

	public HudElement Element;

	public Image InfoImage;

	public Vital VitalType;

	public RustText text;

	public static readonly Phrase BoostActive = new Phrase("tea.boostactive", "{0} Boost active");

	public static readonly Phrase BoostsActive = new Phrase("tea.boostactive.plural", "{0} Boosts active");

	public static readonly Phrase DartEffectActive = new Phrase("dart.effectactive", "{0} dart effect");

	public static readonly Phrase DartEffectsActive = new Phrase("dart.effectactive.plural", "{0} dart effects");

	public static readonly Phrase NegativeEffectActive = new Phrase("negative.active", "{0} negative effect");

	public static readonly Phrase NegativeEffectsActive = new Phrase("negative.active.plural", "{0} negative effects");
}


public enum Vital
{
	BuildingBlocked,
	CanBuild,
	Crafting,
	CraftLevel1,
	CraftLevel2,
	CraftLevel3,
	DecayProtected,
	Decaying,
	SafeZone,
	Buffed,
	Pet,
	ModifyClan,
	DartEffects,
	NegativeEffects
}


using TMPro;
using UnityEngine;

public class VitalNote : MonoBehaviour, IClientComponent, IVitalNotice
{
	public enum Vital
	{
		Comfort,
		Radiation,
		Poison,
		Cold,
		Bleeding,
		Hot,
		Oxygen,
		Wet,
		Hygiene,
		Starving,
		Dehydration
	}

	public Vital VitalType;

	public FloatConditions showIf;

	public TextMeshProUGUI valueText;
}


public enum Vital
{
	Comfort,
	Radiation,
	Poison,
	Cold,
	Bleeding,
	Hot,
	Oxygen,
	Wet,
	Hygiene,
	Starving,
	Dehydration
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class VitalNoteOxygen : MonoBehaviour, IClientComponent, IVitalNotice
{
	[SerializeField]
	private float refreshTime = 1f;

	[SerializeField]
	private TextMeshProUGUI valueText;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private Image airIcon;

	[SerializeField]
	private RectTransform airIconTr;

	[SerializeField]
	private Image backgroundImage;

	[SerializeField]
	private Color baseColour;

	[SerializeField]
	private Color badColour;

	[SerializeField]
	private Image iconImage;

	[SerializeField]
	private Color iconBaseColour;

	[SerializeField]
	private Color iconBadColour;

	protected bool show = true;
}


using UnityEngine;

public class VitalRadial : MonoBehaviour
{
	private void Awake()
	{
		Debug.LogWarning((object)("VitalRadial is obsolete " + ((Component)this).transform.GetRecursiveName()), (Object)(object)((Component)this).gameObject);
	}
}


using UnityEngine;

public class WorkshopWeather : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

public class BaseCommandBuffer : MonoBehaviour
{
	private Dictionary<Camera, Dictionary<int, CommandBuffer>> cameras = new Dictionary<Camera, Dictionary<int, CommandBuffer>>();

	protected CommandBuffer GetCommandBuffer(string name, Camera camera, CameraEvent cameraEvent)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected I4, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected I4, but got Unknown
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (!cameras.TryGetValue(camera, out var value))
		{
			value = new Dictionary<int, CommandBuffer>();
			cameras.Add(camera, value);
		}
		if (value.TryGetValue((int)cameraEvent, out var value2))
		{
			value2.Clear();
		}
		else
		{
			value2 = new CommandBuffer();
			value2.name = name;
			value.Add((int)cameraEvent, value2);
			CleanupCamera(name, camera, cameraEvent);
			camera.AddCommandBuffer(cameraEvent, value2);
		}
		return value2;
	}

	protected void CleanupCamera(string name, Camera camera, CameraEvent cameraEvent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer[] commandBuffers = camera.GetCommandBuffers(cameraEvent);
		foreach (CommandBuffer val in commandBuffers)
		{
			if (val.name == name)
			{
				camera.RemoveCommandBuffer(cameraEvent, val);
			}
		}
	}

	protected void CleanupCommandBuffer(Camera camera, CameraEvent cameraEvent)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Expected I4, but got Unknown
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (cameras.TryGetValue(camera, out var value) && value.TryGetValue((int)cameraEvent, out var value2))
		{
			camera.RemoveCommandBuffer(cameraEvent, value2);
		}
	}

	protected void Cleanup()
	{
		foreach (KeyValuePair<Camera, Dictionary<int, CommandBuffer>> camera in cameras)
		{
			Camera key = camera.Key;
			Dictionary<int, CommandBuffer> value = camera.Value;
			if (!Object.op_Implicit((Object)(object)key))
			{
				continue;
			}
			foreach (KeyValuePair<int, CommandBuffer> item in value)
			{
				int key2 = item.Key;
				CommandBuffer value2 = item.Value;
				key.RemoveCommandBuffer((CameraEvent)key2, value2);
			}
		}
	}
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public abstract class BaseMonoBehaviour : FacepunchBehaviour
{
	public virtual bool IsDebugging()
	{
		return false;
	}

	public virtual string GetLogColor()
	{
		return "yellow";
	}

	public void LogEntry(RustLog.EntryType log, int level, string fmtString)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			LogImpl(log, level, fmtString);
		}
	}

	public void LogEntry<T1>(RustLog.EntryType log, int level, string fmtString, T1 arg1)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			string message = string.Format(fmtString, arg1);
			LogImpl(log, level, message);
		}
	}

	public void LogEntry<T1, T2>(RustLog.EntryType log, int level, string fmtString, T1 arg1, T2 arg2)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			string message = string.Format(fmtString, arg1, arg2);
			LogImpl(log, level, message);
		}
	}

	public void LogEntry<T1, T2, T3>(RustLog.EntryType log, int level, string fmtString, T1 arg1, T2 arg2, T3 arg3)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			string message = string.Format(fmtString, arg1, arg2, arg3);
			LogImpl(log, level, message);
		}
	}

	protected virtual string GetLogIdentity()
	{
		return $"{this} (InstID: {((Object)((Component)this).gameObject).GetInstanceID():x})";
	}

	private void LogImpl(RustLog.EntryType entryType, int level, string message)
	{
		string msgFormat = "<color={0}>{1}</color>: {2}";
		RustLog.Log(entryType, level, ((Component)this).gameObject, msgFormat, GetLogColor(), GetLogIdentity(), message);
	}
}


using UnityEngine;

public class BaseScriptableObject : ScriptableObject
{
	[HideInInspector]
	public uint FilenameStringId;

	public string LookupFileName()
	{
		return StringPool.Get(FilenameStringId);
	}

	public static bool operator ==(BaseScriptableObject a, BaseScriptableObject b)
	{
		if ((object)a == b)
		{
			return true;
		}
		if ((object)a == null || (object)b == null)
		{
			return false;
		}
		return a.FilenameStringId == b.FilenameStringId;
	}

	public static bool operator !=(BaseScriptableObject a, BaseScriptableObject b)
	{
		return !(a == b);
	}

	public override int GetHashCode()
	{
		return (int)FilenameStringId;
	}

	public override bool Equals(object o)
	{
		if (o != null && o is BaseScriptableObject)
		{
			return o as BaseScriptableObject == this;
		}
		return false;
	}
}


using UnityEngine;

public class ForceChildSingletonSetup : MonoBehaviour
{
	[ComponentHelp("Any child objects of this object that contain SingletonComponents will be registered - even if they're not enabled")]
	private void Awake()
	{
		SingletonComponent[] componentsInChildren = ((Component)this).GetComponentsInChildren<SingletonComponent>(true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].SingletonSetup();
		}
	}
}


public interface ICreateAssetCallback
{
	void OnAssetCreated(string assetName);
}


using UnityEngine;

public class InspectorNameAttribute : PropertyAttribute
{
	public string name;

	public InspectorNameAttribute(string name)
	{
		this.name = name;
	}
}


using System;
using UnityEngine;

[Serializable]
public class MinMax
{
	public float x;

	public float y = 1f;

	public MinMax(float x, float y)
	{
		this.x = x;
		this.y = y;
	}

	public float Random()
	{
		return Random.Range(x, y);
	}

	public float Lerp(float t)
	{
		return Mathf.Lerp(x, y, t);
	}

	public float Lerp(float a, float b, float t)
	{
		return Mathf.Lerp(x, y, Mathf.InverseLerp(a, b, t));
	}
}


using UnityEngine;

public class MinMaxAttribute : PropertyAttribute
{
	public float min;

	public float max;

	public MinMaxAttribute(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using UnityEngine;

public class AmbientLightLOD : FacepunchBehaviour, ILOD, IClientComponent
{
	public bool isDynamic;

	public float enabledRadius = 20f;

	public bool toggleFade;

	public float toggleFadeDuration = 0.5f;

	protected void OnValidate()
	{
		LightEx.CheckConflict(((Component)this).gameObject);
	}
}


using UnityEngine;

public class BasePrefab : BaseMonoBehaviour, IPrefabPreProcess
{
	[HideInInspector]
	public uint prefabID;

	[HideInInspector]
	public bool isClient;

	public bool isServer => !isClient;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		prefabID = StringPool.Get(name);
		isClient = clientside;
	}
}


using UnityEngine;

public struct CachedTransform<T> where T : Component
{
	public T component;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 localScale;

	public Matrix4x4 localToWorldMatrix => Matrix4x4.TRS(position, rotation, localScale);

	public Matrix4x4 worldToLocalMatrix
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 val = localToWorldMatrix;
			return ((Matrix4x4)(ref val)).inverse;
		}
	}

	public Vector3 forward => rotation * Vector3.forward;

	public Vector3 up => rotation * Vector3.up;

	public Vector3 right => rotation * Vector3.right;

	public CachedTransform(T instance)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		component = instance;
		if (Object.op_Implicit((Object)(object)component))
		{
			position = ((Component)component).transform.position;
			rotation = ((Component)component).transform.rotation;
			localScale = ((Component)component).transform.localScale;
		}
		else
		{
			position = Vector3.zero;
			rotation = Quaternion.identity;
			localScale = Vector3.one;
		}
	}

	public void Apply()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)component))
		{
			((Component)component).transform.SetPositionAndRotation(position, rotation);
			((Component)component).transform.localScale = localScale;
		}
	}

	public void RotateAround(Vector3 center, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = val * (position - center);
		position = center + val2;
		rotation *= Quaternion.Inverse(rotation) * val * rotation;
	}

	public static implicit operator bool(CachedTransform<T> instance)
	{
		return (Object)(object)instance.component != (Object)null;
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using UnityEngine;

[DisallowMultipleComponent]
public class CameraUpdateHook : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static CameraCallback <>9__5_0;

		public static CameraCallback <>9__5_1;

		public static CameraCallback <>9__5_2;

		internal void <Awake>b__5_0(Camera args)
		{
			Camera mainCamera = MainCamera.mainCamera;
			LastFrameFOV = ((mainCamera != null) ? mainCamera.fieldOfView : Graphics.fov);
			PreRender?.Invoke();
		}

		internal void <Awake>b__5_1(Camera args)
		{
			PostRender?.Invoke();
		}

		internal void <Awake>b__5_2(Camera args)
		{
			PreCull?.Invoke();
		}
	}

	public static Action PreCull;

	public static Action PreRender;

	public static Action PostRender;

	public static Action RustCamera_PreRender;

	public static float LastFrameFOV = Graphics.fov;

	private void Awake()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected O, but got Unknown
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected O, but got Unknown
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Expected O, but got Unknown
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Expected O, but got Unknown
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Expected O, but got Unknown
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Expected O, but got Unknown
		CameraUpdateHook[] components = ((Component)this).GetComponents<CameraUpdateHook>();
		foreach (CameraUpdateHook cameraUpdateHook in components)
		{
			if ((Object)(object)cameraUpdateHook != (Object)(object)this)
			{
				Object.DestroyImmediate((Object)(object)cameraUpdateHook);
			}
		}
		CameraCallback onPreRender = Camera.onPreRender;
		object obj = <>c.<>9__5_0;
		if (obj == null)
		{
			CameraCallback val = delegate
			{
				Camera mainCamera = MainCamera.mainCamera;
				LastFrameFOV = ((mainCamera != null) ? mainCamera.fieldOfView : Graphics.fov);
				PreRender?.Invoke();
			};
			<>c.<>9__5_0 = val;
			obj = (object)val;
		}
		Camera.onPreRender = (CameraCallback)Delegate.Combine((Delegate?)(object)onPreRender, (Delegate?)obj);
		CameraCallback onPostRender = Camera.onPostRender;
		object obj2 = <>c.<>9__5_1;
		if (obj2 == null)
		{
			CameraCallback val2 = delegate
			{
				PostRender?.Invoke();
			};
			<>c.<>9__5_1 = val2;
			obj2 = (object)val2;
		}
		Camera.onPostRender = (CameraCallback)Delegate.Combine((Delegate?)(object)onPostRender, (Delegate?)obj2);
		CameraCallback onPreCull = Camera.onPreCull;
		object obj3 = <>c.<>9__5_2;
		if (obj3 == null)
		{
			CameraCallback val3 = delegate
			{
				PreCull?.Invoke();
			};
			<>c.<>9__5_2 = val3;
			obj3 = (object)val3;
		}
		Camera.onPreCull = (CameraCallback)Delegate.Combine((Delegate?)(object)onPreCull, (Delegate?)obj3);
	}
}


using System;
using System.Collections;
using System.IO;
using System.Linq;
using UnityEngine;

public class ChildrenScreenshot : MonoBehaviour
{
	public Vector3 offsetAngle = new Vector3(0f, 0f, 1f);

	public int width = 512;

	public int height = 512;

	public float fieldOfView = 70f;

	[Tooltip("0 = full recursive name, 1 = object name")]
	public string folder = "screenshots/{0}.png";

	[ContextMenu("Create Screenshots")]
	public void CreateScreenshots()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Expected O, but got Unknown
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture val = new RenderTexture(width, height, 0);
		GameObject val2 = new GameObject();
		Camera val3 = val2.AddComponent<Camera>();
		val3.targetTexture = val;
		val3.orthographic = false;
		val3.fieldOfView = fieldOfView;
		val3.nearClipPlane = 0.1f;
		val3.farClipPlane = 2000f;
		val3.cullingMask = LayerMask.GetMask(new string[1] { "TransparentFX" });
		val3.clearFlags = (CameraClearFlags)2;
		val3.backgroundColor = new Color(0f, 0f, 0f, 0f);
		val3.renderingPath = (RenderingPath)3;
		Texture2D val4 = new Texture2D(((Texture)val).width, ((Texture)val).height, (TextureFormat)5, false);
		foreach (Transform item in ((IEnumerable)((Component)this).transform).Cast<Transform>())
		{
			PositionCamera(val3, ((Component)item).gameObject);
			int layer = ((Component)item).gameObject.layer;
			((Component)item).gameObject.SetLayerRecursive(1);
			val3.Render();
			((Component)item).gameObject.SetLayerRecursive(layer);
			string recursiveName = item.GetRecursiveName();
			recursiveName = recursiveName.Replace('/', '.');
			RenderTexture.active = val;
			val4.ReadPixels(new Rect(0f, 0f, (float)((Texture)val).width, (float)((Texture)val).height), 0, 0, false);
			RenderTexture.active = null;
			byte[] bytes = ImageConversion.EncodeToPNG(val4);
			string path = string.Format(folder, recursiveName, ((Object)item).name);
			string directoryName = Path.GetDirectoryName(path);
			if (!Directory.Exists(directoryName))
			{
				Directory.CreateDirectory(directoryName);
			}
			File.WriteAllBytes(path, bytes);
		}
		Object.DestroyImmediate((Object)(object)val4, true);
		Object.DestroyImmediate((Object)(object)val, true);
		Object.DestroyImmediate((Object)(object)val2, true);
	}

	public void PositionCamera(Camera cam, GameObject obj)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = default(Bounds);
		((Bounds)(ref bounds))..ctor(obj.transform.position, Vector3.zero * 0.1f);
		bool flag = true;
		Renderer[] componentsInChildren = obj.GetComponentsInChildren<Renderer>();
		foreach (Renderer val in componentsInChildren)
		{
			if (flag)
			{
				bounds = val.bounds;
				flag = false;
			}
			else
			{
				((Bounds)(ref bounds)).Encapsulate(val.bounds);
			}
		}
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = ((Vector3)(ref size)).magnitude * 0.5f / Mathf.Tan(cam.fieldOfView * 0.5f * (MathF.PI / 180f));
		((Component)cam).transform.position = ((Bounds)(ref bounds)).center + obj.transform.TransformVector(((Vector3)(ref offsetAngle)).normalized) * num;
		((Component)cam).transform.LookAt(((Bounds)(ref bounds)).center);
	}
}


using UnityEngine;

public class CommentComponent : MonoBehaviour, IEditorComponent
{
	[TextArea]
	public string comment;
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class ConvarComponent : MonoBehaviour
{
	[Serializable]
	public class ConvarEvent
	{
		public string convar;

		public string on;

		public MonoBehaviour component;

		internal Command cmd;

		public void OnEnable()
		{
			cmd = Client.Find(convar);
			if (cmd == null)
			{
				cmd = Server.Find(convar);
			}
			if (cmd != null)
			{
				cmd.OnValueChanged += cmd_OnValueChanged;
				cmd_OnValueChanged(cmd);
			}
		}

		private void cmd_OnValueChanged(Command obj)
		{
			if (!((Object)(object)component == (Object)null))
			{
				bool flag = obj.String == on;
				if (((Behaviour)component).enabled != flag)
				{
					((Behaviour)component).enabled = flag;
				}
			}
		}

		public void OnDisable()
		{
			if (!Application.isQuitting && cmd != null)
			{
				cmd.OnValueChanged -= cmd_OnValueChanged;
			}
		}
	}

	public bool runOnServer = true;

	public bool runOnClient = true;

	public List<ConvarEvent> List = new List<ConvarEvent>();

	protected void OnEnable()
	{
		if (!ShouldRun())
		{
			return;
		}
		foreach (ConvarEvent item in List)
		{
			item.OnEnable();
		}
	}

	protected void OnDisable()
	{
		if (Application.isQuitting || !ShouldRun())
		{
			return;
		}
		foreach (ConvarEvent item in List)
		{
			item.OnDisable();
		}
	}

	private bool ShouldRun()
	{
		if (!runOnServer)
		{
			return false;
		}
		return true;
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public class ConvarEvent
{
	public string convar;

	public string on;

	public MonoBehaviour component;

	internal Command cmd;

	public void OnEnable()
	{
		cmd = Client.Find(convar);
		if (cmd == null)
		{
			cmd = Server.Find(convar);
		}
		if (cmd != null)
		{
			cmd.OnValueChanged += cmd_OnValueChanged;
			cmd_OnValueChanged(cmd);
		}
	}

	private void cmd_OnValueChanged(Command obj)
	{
		if (!((Object)(object)component == (Object)null))
		{
			bool flag = obj.String == on;
			if (((Behaviour)component).enabled != flag)
			{
				((Behaviour)component).enabled = flag;
			}
		}
	}

	public void OnDisable()
	{
		if (!Application.isQuitting && cmd != null)
		{
			cmd.OnValueChanged -= cmd_OnValueChanged;
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class ConvarWater : MonoBehaviour
{
	[FormerlySerializedAs("waterEx")]
	public WaterSystem water;
}


public class DistanceFlareLOD : FacepunchBehaviour, ILOD, IClientComponent
{
	public bool isDynamic;

	public float minEnabledDistance = 100f;

	public float maxEnabledDistance = 600f;

	public bool toggleFade;

	public float toggleFadeDuration = 0.5f;
}


using System;
using UnityEngine;

public class ExecComponent : MonoBehaviour
{
	public string ExecToRun = string.Empty;

	public void Run()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Client, ExecToRun, Array.Empty<object>());
	}
}


using UnityEngine;

public class FoliageTrigger : MonoBehaviour
{
}


using UnityEngine;

public class IgnoreCollision : MonoBehaviour
{
	public Collider collider;

	protected void OnTriggerEnter(Collider other)
	{
		Physics.IgnoreCollision(other, collider, true);
	}
}


using UnityEngine;

public class LayerCullDistance : MonoBehaviour
{
	public string Layer = "Default";

	public float Distance = 1000f;

	protected void OnEnable()
	{
		Camera component = ((Component)this).GetComponent<Camera>();
		float[] layerCullDistances = component.layerCullDistances;
		layerCullDistances[LayerMask.NameToLayer(Layer)] = Distance;
		component.layerCullDistances = layerCullDistances;
	}
}


using UnityEngine;

public class LightLOD : MonoBehaviour, ILOD, IClientComponent
{
	public float DistanceBias;

	public bool ToggleLight;

	public bool ToggleShadows = true;

	protected void OnValidate()
	{
		LightEx.CheckConflict(((Component)this).gameObject);
	}
}


using UnityEngine;

public class LightOccludee : MonoBehaviour
{
	public float RadiusScale = 0.5f;

	public float MinTimeVisible = 0.1f;

	public bool IsDynamic;
}


using System.Collections.Generic;
using System.Diagnostics;
using Rust;
using UnityEngine;

public class LoadBalancer : SingletonComponent<LoadBalancer>
{
	public static bool Paused;

	private const float MinMilliseconds = 1f;

	private const float MaxMilliseconds = 100f;

	private const int MinBacklog = 1000;

	private const int MaxBacklog = 100000;

	private Queue<DeferredAction>[] queues = new Queue<DeferredAction>[5]
	{
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>()
	};

	private Stopwatch watch = Stopwatch.StartNew();

	protected void LateUpdate()
	{
		if (Application.isReceiving || Application.isLoading || Application.isUnloadingWorld || Paused)
		{
			return;
		}
		int num = Count();
		float num2 = Mathf.InverseLerp(1000f, 100000f, (float)num);
		float num3 = Mathf.SmoothStep(1f, 100f, num2);
		watch.Reset();
		watch.Start();
		for (int i = 0; i < queues.Length; i++)
		{
			Queue<DeferredAction> queue = queues[i];
			while (queue.Count > 0)
			{
				queue.Dequeue().Action();
				if (watch.Elapsed.TotalMilliseconds > (double)num3)
				{
					return;
				}
			}
		}
	}

	public static int Count()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<LoadBalancer>.Instance))
		{
			return 0;
		}
		Queue<DeferredAction>[] array = SingletonComponent<LoadBalancer>.Instance.queues;
		int num = 0;
		for (int i = 0; i < array.Length; i++)
		{
			num += array[i].Count;
		}
		return num;
	}

	public static void ProcessAll()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<LoadBalancer>.Instance))
		{
			CreateInstance();
		}
		Queue<DeferredAction>[] array = SingletonComponent<LoadBalancer>.Instance.queues;
		foreach (Queue<DeferredAction> queue in array)
		{
			while (queue.Count > 0)
			{
				queue.Dequeue().Action();
			}
		}
	}

	public static void Enqueue(DeferredAction action)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<LoadBalancer>.Instance))
		{
			CreateInstance();
		}
		SingletonComponent<LoadBalancer>.Instance.queues[action.Index].Enqueue(action);
	}

	private static void CreateInstance()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		GameObject val = new GameObject
		{
			name = "LoadBalancer"
		};
		val.AddComponent<LoadBalancer>();
		Object.DontDestroyOnLoad((Object)val);
	}
}


public enum ActionPriority
{
	Highest,
	High,
	Medium,
	Low,
	Lowest
}


using System;
using UnityEngine;

public class DeferredAction
{
	private Object sender;

	private Action action;

	private ActionPriority priority = ActionPriority.Medium;

	public bool Idle { get; private set; }

	public int Index => (int)priority;

	public DeferredAction(Object sender, Action action, ActionPriority priority = ActionPriority.Medium)
	{
		this.sender = sender;
		this.action = action;
		this.priority = priority;
		Idle = true;
	}

	public void Action()
	{
		if (Idle)
		{
			throw new Exception("Double invocation of a deferred action.");
		}
		Idle = true;
		if (Object.op_Implicit(sender))
		{
			action();
		}
	}

	public void Invoke()
	{
		if (!Idle)
		{
			throw new Exception("Double invocation of a deferred action.");
		}
		LoadBalancer.Enqueue(this);
		Idle = false;
	}

	public static implicit operator bool(DeferredAction obj)
	{
		return obj != null;
	}

	public static void Invoke(Object sender, Action action, ActionPriority priority = ActionPriority.Medium)
	{
		new DeferredAction(sender, action, priority).Invoke();
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Material Config")]
public class MaterialConfig : ScriptableObject
{
	[Serializable]
	public class EnvironmentVolumeOverride
	{
		public EnvironmentType Environment;

		public Enum Biome;
	}

	public class ShaderParameters<T>
	{
		public string Name;

		public T Arid;

		public T Temperate;

		public T Tundra;

		public T Arctic;

		[FormerlySerializedAs("Temperate")]
		public T Jungle;

		private T[] climates;

		public float FindBlendParameters(Vector3 pos, int biomeOverride, out T src, out T dst)
		{
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				src = Temperate;
				dst = Tundra;
				return 0f;
			}
			if (climates == null || climates.Length == 0)
			{
				climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
			}
			int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
			int num2 = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~num));
			src = climates[TerrainBiome.TypeToIndex(num)];
			dst = climates[TerrainBiome.TypeToIndex(num2)];
			return TerrainMeta.BiomeMap.GetBiome(pos, num2);
		}

		public T FindBlendParameters(Vector3 pos, int biomeOverride)
		{
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return Temperate;
			}
			if (climates == null || climates.Length == 0)
			{
				climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
			}
			int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
			return climates[TerrainBiome.TypeToIndex(num)];
		}
	}

	[Serializable]
	public class ShaderParametersFloat : ShaderParameters<float>
	{
	}

	[Serializable]
	public class ShaderParametersColor : ShaderParameters<Color>
	{
	}

	[Serializable]
	public class ShaderParametersTexture : ShaderParameters<Texture>
	{
	}

	[Serializable]
	public class ShaderParametersToggle : ShaderParameters<bool>
	{
	}

	[Horizontal(5, 0)]
	public ShaderParametersFloat[] Floats;

	[Horizontal(5, 0)]
	public ShaderParametersColor[] Colors;

	[Horizontal(5, 0)]
	public ShaderParametersTexture[] Textures;

	[Horizontal(5, 0)]
	public ShaderParametersToggle[] Toggles;

	public string[] ScaleUV;

	[Horizontal(2, -1)]
	public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;

	private MaterialPropertyBlock properties;

	public MaterialPropertyBlock GetMaterialPropertyBlock(Material mat, Vector3 pos, Vector3 scale)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Expected I4, but got Unknown
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		if (properties == null)
		{
			properties = new MaterialPropertyBlock();
		}
		properties.Clear();
		int biomeOverride = 0;
		if (EnvironmentVolumeOverrides.Length != 0)
		{
			EnvironmentType environmentType = EnvironmentManager.Get(pos);
			if (TerrainMeta.IsPointWithinTutorialBounds(pos))
			{
				biomeOverride = 2;
			}
			else
			{
				EnvironmentVolumeOverride[] environmentVolumeOverrides = EnvironmentVolumeOverrides;
				foreach (EnvironmentVolumeOverride environmentVolumeOverride in environmentVolumeOverrides)
				{
					if ((environmentType & environmentVolumeOverride.Environment) != 0)
					{
						biomeOverride = (int)environmentVolumeOverride.Biome;
						break;
					}
				}
			}
		}
		for (int j = 0; j < Floats.Length; j++)
		{
			ShaderParametersFloat shaderParametersFloat = Floats[j];
			float src;
			float dst;
			float num = shaderParametersFloat.FindBlendParameters(pos, biomeOverride, out src, out dst);
			properties.SetFloat(shaderParametersFloat.Name, Mathf.Lerp(src, dst, num));
		}
		for (int k = 0; k < Colors.Length; k++)
		{
			ShaderParametersColor shaderParametersColor = Colors[k];
			Color src2;
			Color dst2;
			float num2 = shaderParametersColor.FindBlendParameters(pos, biomeOverride, out src2, out dst2);
			properties.SetColor(shaderParametersColor.Name, Color.Lerp(src2, dst2, num2));
		}
		for (int l = 0; l < Textures.Length; l++)
		{
			ShaderParametersTexture shaderParametersTexture = Textures[l];
			Texture val = shaderParametersTexture.FindBlendParameters(pos, biomeOverride);
			if (Object.op_Implicit((Object)(object)val))
			{
				properties.SetTexture(shaderParametersTexture.Name, val);
			}
		}
		for (int m = 0; m < Toggles.Length; m++)
		{
			ShaderParametersToggle shaderParametersToggle = Toggles[m];
			bool flag = shaderParametersToggle.FindBlendParameters(pos, biomeOverride);
			properties.SetFloat(shaderParametersToggle.Name, flag ? 1f : 0f);
		}
		for (int n = 0; n < ScaleUV.Length; n++)
		{
			Vector4 vector = mat.GetVector(ScaleUV[n]);
			((Vector4)(ref vector))..ctor(vector.x * scale.y, vector.y * scale.y, vector.z, vector.w);
			properties.SetVector(ScaleUV[n], vector);
		}
		return properties;
	}
}


using System;

[Serializable]
public class EnvironmentVolumeOverride
{
	public EnvironmentType Environment;

	public Enum Biome;
}


using UnityEngine;
using UnityEngine.Serialization;

public class ShaderParameters<T>
{
	public string Name;

	public T Arid;

	public T Temperate;

	public T Tundra;

	public T Arctic;

	[FormerlySerializedAs("Temperate")]
	public T Jungle;

	private T[] climates;

	public float FindBlendParameters(Vector3 pos, int biomeOverride, out T src, out T dst)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			src = Temperate;
			dst = Tundra;
			return 0f;
		}
		if (climates == null || climates.Length == 0)
		{
			climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
		int num2 = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~num));
		src = climates[TerrainBiome.TypeToIndex(num)];
		dst = climates[TerrainBiome.TypeToIndex(num2)];
		return TerrainMeta.BiomeMap.GetBiome(pos, num2);
	}

	public T FindBlendParameters(Vector3 pos, int biomeOverride)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			return Temperate;
		}
		if (climates == null || climates.Length == 0)
		{
			climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
		return climates[TerrainBiome.TypeToIndex(num)];
	}
}


using System;

[Serializable]
public class ShaderParametersFloat : ShaderParameters<float>
{
}


using System;
using UnityEngine;

[Serializable]
public class ShaderParametersColor : ShaderParameters<Color>
{
}


using System;
using UnityEngine;

[Serializable]
public class ShaderParametersTexture : ShaderParameters<Texture>
{
}


using System;

[Serializable]
public class ShaderParametersToggle : ShaderParameters<bool>
{
}


using Rust;

public class MaterialSetup : ProceduralObject, IClientComponent
{
	public MaterialConfig config;

	public bool IncludeChildren;

	protected void OnEnable()
	{
		if (!Application.isLoading)
		{
			Setup();
		}
	}

	public override void Process()
	{
		Setup();
	}

	private void Setup()
	{
	}
}


using UnityEngine;

public class MeshToggle : MonoBehaviour
{
	public Mesh[] RendererMeshes;

	public Mesh[] ColliderMeshes;

	public void SwitchRenderer(int index)
	{
		if (RendererMeshes.Length != 0)
		{
			MeshFilter component = ((Component)this).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.sharedMesh = RendererMeshes[Mathf.Clamp(index, 0, RendererMeshes.Length - 1)];
			}
		}
	}

	public void SwitchRenderer(float factor)
	{
		int index = Mathf.RoundToInt(factor * (float)RendererMeshes.Length);
		SwitchRenderer(index);
	}

	public void SwitchCollider(int index)
	{
		if (ColliderMeshes.Length != 0)
		{
			MeshCollider component = ((Component)this).GetComponent<MeshCollider>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.sharedMesh = ColliderMeshes[Mathf.Clamp(index, 0, ColliderMeshes.Length - 1)];
			}
		}
	}

	public void SwitchCollider(float factor)
	{
		int index = Mathf.RoundToInt(factor * (float)ColliderMeshes.Length);
		SwitchCollider(index);
	}

	public void SwitchAll(int index)
	{
		SwitchRenderer(index);
		SwitchCollider(index);
	}

	public void SwitchAll(float factor)
	{
		SwitchRenderer(factor);
		SwitchCollider(factor);
	}
}


using UnityEngine;

public class MoveForward : MonoBehaviour
{
	public float Speed = 2f;

	protected void Update()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).GetComponent<Rigidbody>().velocity = Speed * ((Component)this).transform.forward;
	}
}


using UnityEngine;

public class NetworkSleep : MonoBehaviour
{
	public static int totalBehavioursDisabled;

	public static int totalCollidersDisabled;

	public Behaviour[] behaviours;

	public Collider[] colliders;

	internal int BehavioursDisabled;

	internal int CollidersDisabled;
}


using UnityEngine;

public class ObjectFlasher : BaseMonoBehaviour
{
	public GameObject enabledObj;

	public GameObject disabledObj;

	public float toggleLength = 1f;

	public float timeOffset;

	public float randomOffset;
}


using UnityEngine;

[ExecuteAlways]
public class OneActiveSibling : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ParticleSystemContainer : MonoBehaviour, IPrefabPreProcess
{
	[Serializable]
	public struct ParticleSystemGroup
	{
		public ParticleSystem system;

		public LODComponentParticleSystem[] lodComponents;
	}

	public bool precached;

	public bool includeLights;

	[HideInInspector]
	[SerializeField]
	private ParticleSystemGroup[] particleGroups;

	[SerializeField]
	[HideInInspector]
	private Light[] lights;

	[SerializeField]
	[HideInInspector]
	private LightEx[] lightExs;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void Play()
	{
	}

	public void Pause()
	{
	}

	public void Stop()
	{
	}

	public void Clear()
	{
	}

	private void SetLights(bool on)
	{
		Light[] componentsInChildren;
		LightEx[] componentsInChildren2;
		if (precached)
		{
			componentsInChildren = lights;
			componentsInChildren2 = lightExs;
		}
		else
		{
			componentsInChildren = ((Component)this).GetComponentsInChildren<Light>();
			componentsInChildren2 = ((Component)this).GetComponentsInChildren<LightEx>();
		}
		LightEx[] array = componentsInChildren2;
		for (int i = 0; i < array.Length; i++)
		{
			((Behaviour)array[i]).enabled = on;
		}
		Light[] array2 = componentsInChildren;
		for (int i = 0; i < array2.Length; i++)
		{
			((Behaviour)array2[i]).enabled = on;
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (precached && clientside)
		{
			List<ParticleSystemGroup> list = new List<ParticleSystemGroup>();
			ParticleSystem[] componentsInChildren = ((Component)this).GetComponentsInChildren<ParticleSystem>();
			foreach (ParticleSystem val in componentsInChildren)
			{
				LODComponentParticleSystem[] components = ((Component)val).GetComponents<LODComponentParticleSystem>();
				ParticleSystemGroup particleSystemGroup = default(ParticleSystemGroup);
				particleSystemGroup.system = val;
				particleSystemGroup.lodComponents = components;
				ParticleSystemGroup item = particleSystemGroup;
				list.Add(item);
			}
			particleGroups = list.ToArray();
			if (includeLights)
			{
				lights = ((Component)this).GetComponentsInChildren<Light>();
				lightExs = ((Component)this).GetComponentsInChildren<LightEx>();
			}
		}
	}

	public bool IsPlaying()
	{
		ParticleSystemGroup[] array = particleGroups;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].system.isPlaying)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ParticleSystemGroup
{
	public ParticleSystem system;

	public LODComponentParticleSystem[] lodComponents;
}


using UnityEngine;

public class ParticleSystemIK : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class ParticleSystemPlayer : MonoBehaviour, IOnParentDestroying
{
	protected void OnEnable()
	{
		((Component)this).GetComponent<ParticleSystem>().enableEmission = true;
	}

	public void OnParentDestroying()
	{
		((Component)this).GetComponent<ParticleSystem>().enableEmission = false;
	}
}


using UnityEngine;

[DefaultExecutionOrder(16000)]
public class ParticleSystemPostIK : MonoBehaviour
{
}


using System;

public struct PerformanceSamplePoint
{
	public int UpdateCount;

	public int FixedUpdateCount;

	public int RenderCount;

	public TimeSpan PreCull;

	public TimeSpan Update;

	public TimeSpan LateUpdate;

	public TimeSpan PhysicsUpdate;

	public TimeSpan Render;

	public TimeSpan FixedUpdate;

	public TimeSpan TotalCPU;

	public int CpuUpdateCount;

	public PerformanceSamplePoint Add(PerformanceSamplePoint other)
	{
		PerformanceSamplePoint result = default(PerformanceSamplePoint);
		result.UpdateCount = UpdateCount + other.UpdateCount;
		result.FixedUpdateCount = FixedUpdateCount + other.FixedUpdateCount;
		result.RenderCount = RenderCount + other.RenderCount;
		result.PreCull = PreCull + other.PreCull;
		result.Update = Update + other.Update;
		result.LateUpdate = LateUpdate + other.LateUpdate;
		result.PhysicsUpdate = PhysicsUpdate + other.PhysicsUpdate;
		result.Render = Render + other.Render;
		result.FixedUpdate = FixedUpdate + other.FixedUpdate;
		result.TotalCPU = TotalCPU + other.TotalCPU;
		result.CpuUpdateCount = CpuUpdateCount + other.CpuUpdateCount;
		return result;
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public static class PerformanceMetrics
{
	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static UnityAction <>9__10_0;

		internal void <Setup>b__10_0()
		{
			OnBeforeRender?.Invoke();
		}
	}

	private static PerformanceSamplePoint current;

	private static Action OnBeforeRender;

	public static PerformanceSamplePoint LastFrame { get; private set; }

	public static PerformanceSamplePoint PerformancePerSecond { get; set; }

	public static void Setup()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Expected O, but got Unknown
		object obj = <>c.<>9__10_0;
		if (obj == null)
		{
			UnityAction val = delegate
			{
				OnBeforeRender?.Invoke();
			};
			<>c.<>9__10_0 = val;
			obj = (object)val;
		}
		Application.onBeforeRender += (UnityAction)obj;
		AddStopwatch(PerformanceSample.PreCull, ref OnBeforeRender, ref CameraUpdateHook.RustCamera_PreRender);
		AddStopwatch(PerformanceSample.Update, ref PreUpdateHook.OnUpdate, ref PostUpdateHook.OnUpdate);
		AddStopwatch(PerformanceSample.LateUpdate, ref PreUpdateHook.OnLateUpdate, ref PostUpdateHook.OnLateUpdate);
		AddStopwatch(PerformanceSample.Render, ref CameraUpdateHook.PreRender, ref CameraUpdateHook.PostRender);
		AddStopwatch(PerformanceSample.FixedUpdate, ref PreUpdateHook.OnFixedUpdate, ref PostUpdateHook.OnFixedUpdate);
		AddStopwatch(PerformanceSample.PhysicsUpdate, ref PostUpdateHook.OnFixedUpdate, ref PreUpdateHook.PostPhysicsUpdate);
		AddCPUTimeStopwatch();
	}

	private static void AddCPUTimeStopwatch()
	{
		Stopwatch watch = new Stopwatch();
		PreUpdateHook.StartOfFrame = (Action)Delegate.Combine(PreUpdateHook.StartOfFrame, (Action)delegate
		{
			PerformancePerSecond = PerformancePerSecond.Add(current);
			LastFrame = current;
			current = default(PerformanceSamplePoint);
			watch.Restart();
			current.CpuUpdateCount++;
		});
		PostUpdateHook.EndOfFrame = (Action)Delegate.Combine(PostUpdateHook.EndOfFrame, (Action)delegate
		{
			current.TotalCPU += watch.Elapsed;
		});
	}

	private static void AddStopwatch(PerformanceSample sample, ref Action pre, ref Action post)
	{
		Stopwatch watch = new Stopwatch();
		bool active = false;
		pre = (Action)Delegate.Combine(pre, (Action)delegate
		{
			if (!active)
			{
				active = true;
				watch.Restart();
			}
		});
		post = (Action)Delegate.Combine(post, (Action)delegate
		{
			if (active)
			{
				active = false;
				watch.Stop();
				switch (sample)
				{
				case PerformanceSample.Update:
					current.UpdateCount++;
					current.Update += watch.Elapsed;
					break;
				case PerformanceSample.LateUpdate:
					current.LateUpdate += watch.Elapsed;
					break;
				case PerformanceSample.FixedUpdate:
					current.FixedUpdate += watch.Elapsed;
					current.FixedUpdateCount++;
					break;
				case PerformanceSample.PreCull:
					current.PreCull += watch.Elapsed;
					break;
				case PerformanceSample.Render:
					current.Render += watch.Elapsed;
					current.RenderCount++;
					break;
				case PerformanceSample.PhysicsUpdate:
					current.PhysicsUpdate += watch.Elapsed;
					break;
				case PerformanceSample.NetworkMessage:
				case PerformanceSample.TotalCPU:
					break;
				}
			}
		});
	}
}


using System;
using System.Collections;
using Facepunch.Rust.Profiling;
using UnityEngine;

[DisallowMultipleComponent]
public class PostUpdateHook : MonoBehaviour
{
	public static Action OnUpdate;

	public static Action OnLateUpdate;

	public static Action OnFixedUpdate;

	public static Action EndOfFrame;

	private void Update()
	{
		OnUpdate?.Invoke();
		RuntimeProfiler.Update();
	}

	private void LateUpdate()
	{
		OnLateUpdate?.Invoke();
	}

	private void FixedUpdate()
	{
		OnFixedUpdate?.Invoke();
	}

	private void Start()
	{
		((MonoBehaviour)this).StartCoroutine(EndOfFrameRoutine());
	}

	private IEnumerator EndOfFrameRoutine()
	{
		while (Application.isPlaying)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			EndOfFrame?.Invoke();
		}
	}
}


public enum PerformanceSample
{
	Update,
	LateUpdate,
	PreCull,
	Render,
	FixedUpdate,
	NetworkMessage,
	TotalCPU,
	PhysicsUpdate,
	Last
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Development.Attributes;
using UnityEngine;
using UnityEngine.Assertions;

[ResetStaticFields]
public abstract class PrefabAttribute : MonoBehaviour, IPrefabPreProcess
{
	public class AttributeCollection
	{
		private Dictionary<Type, List<PrefabAttribute>> attributes = new Dictionary<Type, List<PrefabAttribute>>();

		private Dictionary<Type, object> cache = new Dictionary<Type, object>();

		internal List<PrefabAttribute> Find(Type t)
		{
			if (attributes.TryGetValue(t, out var value))
			{
				return value;
			}
			value = new List<PrefabAttribute>();
			attributes.Add(t, value);
			return value;
		}

		public T[] Find<T>()
		{
			if (cache == null)
			{
				cache = new Dictionary<Type, object>();
			}
			if (cache.TryGetValue(typeof(T), out var value))
			{
				return (T[])value;
			}
			value = Find(typeof(T)).Cast<T>().ToArray();
			cache.Add(typeof(T), value);
			return (T[])value;
		}

		public void Add(PrefabAttribute attribute)
		{
			List<PrefabAttribute> list = Find(attribute.GetIndexedType());
			Assert.IsTrue(!list.Contains(attribute), "AttributeCollection.Add: Adding twice to list");
			list.Add(attribute);
			cache = null;
		}
	}

	public class Library
	{
		public bool clientside;

		public bool serverside;

		public Dictionary<uint, AttributeCollection> prefabs = new Dictionary<uint, AttributeCollection>();

		public Library(bool clientside, bool serverside)
		{
			this.clientside = clientside;
			this.serverside = serverside;
		}

		public AttributeCollection Find(uint prefabID, bool warmup = true)
		{
			if (prefabs.TryGetValue(prefabID, out var value))
			{
				return value;
			}
			value = new AttributeCollection();
			prefabs.Add(prefabID, value);
			if (warmup && (!clientside || serverside))
			{
				if (!clientside && serverside)
				{
					GameManager.server.FindPrefab(prefabID);
				}
				else if (clientside)
				{
					_ = serverside;
				}
			}
			return value;
		}

		public T Find<T>(uint prefabID) where T : PrefabAttribute
		{
			T[] array = Find(prefabID).Find<T>();
			if (array.Length == 0)
			{
				return null;
			}
			return array[0];
		}

		public bool Find<T>(uint prefabID, out T result) where T : PrefabAttribute
		{
			result = null;
			T[] array = Find(prefabID).Find<T>();
			if (array.Length == 0)
			{
				return false;
			}
			result = array[0];
			return true;
		}

		public T[] FindAll<T>(uint prefabID) where T : PrefabAttribute
		{
			return Find(prefabID).Find<T>();
		}

		public void Add(uint prefabID, PrefabAttribute attribute)
		{
			Find(prefabID, warmup: false).Add(attribute);
		}

		public void Invalidate(uint prefabID)
		{
			prefabs.Remove(prefabID);
		}

		public void InvalidateAll()
		{
			prefabs.Clear();
		}
	}

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public Quaternion worldRotation;

	[NonSerialized]
	public Vector3 worldForward;

	[NonSerialized]
	public Vector3 localPosition;

	[NonSerialized]
	public Vector3 localScale;

	[NonSerialized]
	public Quaternion localRotation;

	[NonSerialized]
	public string fullName;

	[NonSerialized]
	public string hierachyName;

	[NonSerialized]
	public uint prefabID;

	[NonSerialized]
	public int instanceID;

	[NonSerialized]
	public Library prefabAttribute;

	[NonSerialized]
	public GameManager gameManager;

	[NonSerialized]
	public bool isServer;

	public static Library server = new Library(clientside: false, serverside: true);

	public bool isClient => !isServer;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		fullName = name;
		hierachyName = ((Component)this).transform.GetRecursiveName();
		prefabID = StringPool.Get(name);
		instanceID = ((Object)this).GetInstanceID();
		worldPosition = ((Component)this).transform.position;
		worldRotation = ((Component)this).transform.rotation;
		worldForward = ((Component)this).transform.forward;
		localPosition = ((Component)this).transform.localPosition;
		localScale = ((Component)this).transform.localScale;
		localRotation = ((Component)this).transform.localRotation;
		if (serverside)
		{
			prefabAttribute = server;
			gameManager = GameManager.server;
			isServer = true;
		}
		AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!bundling)
		{
			if (serverside)
			{
				server.Add(prefabID, this);
			}
			preProcess.RemoveComponent((Component)(object)this);
			preProcess.NominateForDeletion(((Component)this).gameObject);
		}
	}

	protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}

	protected abstract Type GetIndexedType();

	public static bool operator ==(PrefabAttribute x, PrefabAttribute y)
	{
		return ComparePrefabAttribute(x, y);
	}

	public static bool operator !=(PrefabAttribute x, PrefabAttribute y)
	{
		return !ComparePrefabAttribute(x, y);
	}

	public override bool Equals(object o)
	{
		if (o is PrefabAttribute y)
		{
			return ComparePrefabAttribute(this, y);
		}
		return false;
	}

	public override int GetHashCode()
	{
		if (hierachyName == null)
		{
			return ((Object)this).GetHashCode();
		}
		return hierachyName.GetHashCode();
	}

	public static implicit operator bool(PrefabAttribute exists)
	{
		return (object)exists != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static bool ComparePrefabAttribute(PrefabAttribute x, PrefabAttribute y)
	{
		bool flag = (object)x == null;
		bool flag2 = (object)y == null;
		if (flag && flag2)
		{
			return true;
		}
		if (flag || flag2)
		{
			return false;
		}
		if (x.instanceID == y.instanceID)
		{
			return true;
		}
		return false;
	}

	public override string ToString()
	{
		if ((object)this == null)
		{
			return "null";
		}
		return hierachyName;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Assertions;

public class AttributeCollection
{
	private Dictionary<Type, List<PrefabAttribute>> attributes = new Dictionary<Type, List<PrefabAttribute>>();

	private Dictionary<Type, object> cache = new Dictionary<Type, object>();

	internal List<PrefabAttribute> Find(Type t)
	{
		if (attributes.TryGetValue(t, out var value))
		{
			return value;
		}
		value = new List<PrefabAttribute>();
		attributes.Add(t, value);
		return value;
	}

	public T[] Find<T>()
	{
		if (cache == null)
		{
			cache = new Dictionary<Type, object>();
		}
		if (cache.TryGetValue(typeof(T), out var value))
		{
			return (T[])value;
		}
		value = Find(typeof(T)).Cast<T>().ToArray();
		cache.Add(typeof(T), value);
		return (T[])value;
	}

	public void Add(PrefabAttribute attribute)
	{
		List<PrefabAttribute> list = Find(attribute.GetIndexedType());
		Assert.IsTrue(!list.Contains(attribute), "AttributeCollection.Add: Adding twice to list");
		list.Add(attribute);
		cache = null;
	}
}


using System.Collections.Generic;

public class Library
{
	public bool clientside;

	public bool serverside;

	public Dictionary<uint, AttributeCollection> prefabs = new Dictionary<uint, AttributeCollection>();

	public Library(bool clientside, bool serverside)
	{
		this.clientside = clientside;
		this.serverside = serverside;
	}

	public AttributeCollection Find(uint prefabID, bool warmup = true)
	{
		if (prefabs.TryGetValue(prefabID, out var value))
		{
			return value;
		}
		value = new AttributeCollection();
		prefabs.Add(prefabID, value);
		if (warmup && (!clientside || serverside))
		{
			if (!clientside && serverside)
			{
				GameManager.server.FindPrefab(prefabID);
			}
			else if (clientside)
			{
				_ = serverside;
			}
		}
		return value;
	}

	public T Find<T>(uint prefabID) where T : PrefabAttribute
	{
		T[] array = Find(prefabID).Find<T>();
		if (array.Length == 0)
		{
			return null;
		}
		return array[0];
	}

	public bool Find<T>(uint prefabID, out T result) where T : PrefabAttribute
	{
		result = null;
		T[] array = Find(prefabID).Find<T>();
		if (array.Length == 0)
		{
			return false;
		}
		result = array[0];
		return true;
	}

	public T[] FindAll<T>(uint prefabID) where T : PrefabAttribute
	{
		return Find(prefabID).Find<T>();
	}

	public void Add(uint prefabID, PrefabAttribute attribute)
	{
		Find(prefabID, warmup: false).Add(attribute);
	}

	public void Invalidate(uint prefabID)
	{
		prefabs.Remove(prefabID);
	}

	public void InvalidateAll()
	{
		prefabs.Clear();
	}
}


using System;
using UnityEngine;

public class RigidbodyInfo : PrefabAttribute, IClientComponent
{
	[ReadOnly]
	public float mass;

	[ReadOnly]
	public float drag;

	[ReadOnly]
	public float angularDrag;

	protected override Type GetIndexedType()
	{
		return typeof(RigidbodyInfo);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!FileSystem.IsBundled)
		{
			Rigidbody component = rootObj.GetComponent<Rigidbody>();
			if ((Object)(object)component == (Object)null)
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": RigidbodyInfo couldn't find a rigidbody on " + name + "! If a RealmedRemove is removing it, make sure this script is above the RealmedRemove script so that this gets processed first."));
				return;
			}
			mass = component.mass;
			drag = component.drag;
			angularDrag = component.angularDrag;
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

[DisallowMultipleComponent]
public class PreUpdateHook : MonoBehaviour
{
	public static Action OnUpdate;

	public static Action OnLateUpdate;

	public static Action OnFixedUpdate;

	public static Action PostPhysicsUpdate;

	public static Action StartOfFrame;

	private static int lastStartOfFrame;

	private void Start()
	{
		((MonoBehaviour)this).StartCoroutine(AfterPhysicsUpdate());
	}

	private void Update()
	{
		TryRunStartOfFrame();
		OnUpdate?.Invoke();
	}

	private void LateUpdate()
	{
		OnLateUpdate?.Invoke();
	}

	private void FixedUpdate()
	{
		TryRunStartOfFrame();
		OnFixedUpdate?.Invoke();
	}

	private void TryRunStartOfFrame()
	{
		int frameCount = Time.frameCount;
		if (lastStartOfFrame != frameCount)
		{
			lastStartOfFrame = frameCount;
			StartOfFrame?.Invoke();
		}
	}

	private IEnumerator AfterPhysicsUpdate()
	{
		while (Application.isPlaying)
		{
			yield return CoroutineEx.waitForFixedUpdate;
			PostPhysicsUpdate?.Invoke();
		}
	}
}


using UnityEngine;

public class RotateCameraAroundObject : MonoBehaviour
{
	public GameObject m_goObjectToRotateAround;

	public float m_flRotateSpeed = 10f;

	private void FixedUpdate()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_goObjectToRotateAround != (Object)null)
		{
			((Component)this).transform.LookAt(m_goObjectToRotateAround.transform.position + Vector3.up * 0.75f);
			((Component)this).transform.Translate(Vector3.right * m_flRotateSpeed * Time.deltaTime);
		}
	}
}


using System;
using UnityEngine;

public class RunConsoleCommand : MonoBehaviour
{
	[SerializeField]
	private bool runQuiet;

	public void ClientRun(string command)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		Option val;
		if (!runQuiet)
		{
			val = Option.Client;
		}
		else
		{
			Option client = Option.Client;
			val = ((Option)(ref client)).Quiet();
		}
		ConsoleSystem.Run(val, command, Array.Empty<object>());
	}
}


public class Screenshot : SingletonComponent<Screenshot>
{
	public string screenshotPath;

	public int sizeMultiplier = 4;
}


using System;
using UnityEngine;

[DisallowMultipleComponent]
public class StripEmptyChildren : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(StripEmptyChildren);
	}
}


using UnityEngine;

public class TagComponent : MonoBehaviour
{
	public GameObjectTag Tag;

	public bool HasTag(GameObjectTag tag)
	{
		return (Tag & tag) == tag;
	}

	public void AddTag(GameObjectTag tag)
	{
		Tag |= tag;
	}

	public void RemoveTag(GameObjectTag tag)
	{
		Tag &= ~tag;
	}

	public void SetTag(GameObjectTag tag, bool state)
	{
		if (state)
		{
			AddTag(tag);
		}
		else
		{
			RemoveTag(tag);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using VLB;

public static class TagComponentEx
{
	private static Dictionary<GameObjectTag, string> strings;

	static TagComponentEx()
	{
		strings = new Dictionary<GameObjectTag, string>();
		foreach (object value in Enum.GetValues(typeof(GameObjectTag)))
		{
			strings[(GameObjectTag)value] = value.ToString();
		}
	}

	public static bool HasCustomTag(this GameObject gameObject, GameObjectTag tag)
	{
		string text = strings[tag];
		if (gameObject.CompareTag(text))
		{
			return true;
		}
		TagComponent component = gameObject.GetComponent<TagComponent>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		return component.HasTag(tag);
	}

	public static bool SetCustomTag(this GameObject gameObject, GameObjectTag tag, bool apply)
	{
		string text = strings[tag];
		if (apply)
		{
			if (gameObject.tag == text)
			{
				return false;
			}
			if (gameObject.CompareTag("Untagged"))
			{
				gameObject.tag = text;
				return true;
			}
			TagComponent orAddComponent = gameObject.GetOrAddComponent<TagComponent>();
			if (orAddComponent.HasTag(tag))
			{
				return false;
			}
			orAddComponent.AddTag(tag);
			return true;
		}
		if (gameObject.tag == text)
		{
			gameObject.CompareTag("Untagged");
			return true;
		}
		TagComponent component = gameObject.GetComponent<TagComponent>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		if (!component.HasTag(tag))
		{
			return false;
		}
		component.RemoveTag(tag);
		return true;
	}
}


using System;

[Flags]
public enum GameObjectTag
{
	AllowBarricadePlacement = 1,
	Road = 2,
	BlockBarricadePlacement = 4,
	BlockPlacement = 8
}


using UnityEngine;

public class TutorialOptionsPrompt : MonoBehaviour
{
	public CanvasGroup Group;

	public GameObject NotConnectedToValidServerRoot;

	public GameObject ServerValidRoot;

	public GameObject TutorialInProcessRoot;
}


using UnityEngine;

public class UnityHookHandler : SingletonComponent<UnityHookHandler>
{
	public static void EnsureCreated()
	{
		if ((Object)(object)SingletonComponent<UnityHookHandler>.Instance == (Object)null)
		{
			CreateInstance();
		}
	}

	private static void CreateInstance()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Expected O, but got Unknown
		GameObject val = new GameObject("UnityHookHandler");
		val.AddComponent<UnityHookHandler>();
		val.AddComponent<PreUpdateHook>();
		val.AddComponent<PostUpdateHook>();
		Object.DontDestroyOnLoad((Object)val);
		PerformanceMetrics.Setup();
		Debug.Log((object)"Setup unity update hooks");
	}
}


using UnityEngine;

public abstract class UpdateBehaviour : MonoBehaviour
{
}


public class UpdateHandler : SingletonComponent<UpdateHandler>
{
}


using UnityEngine;

public class VisualiseTrigger : MonoBehaviour, IEditorComponent
{
	[SerializeField]
	private Color colour;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class ArrayEx
{
	public static T[] New<T>(int length)
	{
		if (length == 0)
		{
			return Array.Empty<T>();
		}
		return new T[length];
	}

	public static T GetRandom<T>(this T[] array)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		return array[Random.Range(0, array.Length)];
	}

	public static T GetRandom<T>(this T[] array, uint seed)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		return array[SeedRandom.Range(ref seed, 0, array.Length)];
	}

	public static T GetRandom<T>(this T[] array, ref uint seed)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		return array[SeedRandom.Range(ref seed, 0, array.Length)];
	}

	public static void Shuffle<T>(this T[] array, uint seed)
	{
		array.Shuffle(ref seed);
	}

	public static void Shuffle<T>(this T[] array, ref uint seed)
	{
		for (int i = 0; i < array.Length; i++)
		{
			int num = SeedRandom.Range(ref seed, 0, array.Length);
			int num2 = SeedRandom.Range(ref seed, 0, array.Length);
			T val = array[num];
			array[num] = array[num2];
			array[num2] = val;
		}
	}

	public static void BubbleSort<T>(this T[] array) where T : IComparable<T>
	{
		for (int i = 1; i < array.Length; i++)
		{
			T val = array[i];
			for (int num = i - 1; num >= 0; num--)
			{
				T val2 = array[num];
				if (val.CompareTo(val2) >= 0)
				{
					break;
				}
				array[num + 1] = val2;
				array[num] = val;
			}
		}
	}

	public static int BinarySearch<TElement, TNeedle>(this TElement[] array, Func<TElement, TNeedle> selector, TNeedle needle, IComparer<TNeedle> comparer = null)
	{
		if (comparer == null)
		{
			comparer = Comparer<TNeedle>.Default;
		}
		int num = 0;
		int num2 = array.Length - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			TNeedle x = selector(array[num3]);
			int num4 = comparer.Compare(x, needle);
			if (num4 == 0)
			{
				return num3;
			}
			if (num4 < 0)
			{
				num = num3 + 1;
			}
			else
			{
				num2 = num3 - 1;
			}
		}
		return ~num;
	}
}


using System;
using UnityEngine;

public static class BoundsEx
{
	private static Vector3[] pts = (Vector3[])(object)new Vector3[8];

	public static Bounds XZ3D(this Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new Bounds(Vector3Ex.XZ3D(((Bounds)(ref bounds)).center), Vector3Ex.XZ3D(((Bounds)(ref bounds)).size));
	}

	public static Bounds Transform(this Bounds bounds, Matrix4x4 matrix)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(((Bounds)(ref bounds)).center);
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vector3 val = ((Matrix4x4)(ref matrix)).MultiplyVector(new Vector3(extents.x, 0f, 0f));
		Vector3 val2 = ((Matrix4x4)(ref matrix)).MultiplyVector(new Vector3(0f, extents.y, 0f));
		Vector3 val3 = ((Matrix4x4)(ref matrix)).MultiplyVector(new Vector3(0f, 0f, extents.z));
		extents.x = Mathf.Abs(val.x) + Mathf.Abs(val2.x) + Mathf.Abs(val3.x);
		extents.y = Mathf.Abs(val.y) + Mathf.Abs(val2.y) + Mathf.Abs(val3.y);
		extents.z = Mathf.Abs(val.z) + Mathf.Abs(val2.z) + Mathf.Abs(val3.z);
		Bounds result = default(Bounds);
		((Bounds)(ref result)).center = center;
		((Bounds)(ref result)).extents = extents;
		return result;
	}

	public static Rect ToScreenRect(this Bounds b, Camera cam)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Bounds.ToScreenRect", 0);
		try
		{
			pts[0] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[1] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			pts[2] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[3] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			pts[4] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[5] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			pts[6] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[7] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			Vector3 val2 = pts[0];
			Vector3 val3 = pts[0];
			for (int i = 1; i < pts.Length; i++)
			{
				val2 = Vector3.Min(val2, pts[i]);
				val3 = Vector3.Max(val3, pts[i]);
			}
			return Rect.MinMaxRect(val2.x, val2.y, val3.x, val3.y);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Rect ToCanvasRect(this Bounds b, RectTransform target, Camera cam)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Rect result = b.ToScreenRect(cam);
		((Rect)(ref result)).min = Vector2Ex.ToCanvas(((Rect)(ref result)).min, target, (Camera)null);
		((Rect)(ref result)).max = Vector2Ex.ToCanvas(((Rect)(ref result)).max, target, (Camera)null);
		return result;
	}

	public static float InnerDistToEdge2D(this Bounds b, Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Abs(point.x - ((Bounds)(ref b)).min.x);
		float num2 = Mathf.Abs(point.x - ((Bounds)(ref b)).max.x);
		float num3 = Mathf.Abs(point.z - ((Bounds)(ref b)).min.z);
		float num4 = Mathf.Abs(point.z - ((Bounds)(ref b)).max.z);
		return Mathf.Min(num, Mathf.Min(num2, Mathf.Min(num3, num4)));
	}

	public static float MaxExtent(this Bounds b)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Max(((Bounds)(ref b)).extents.x, Mathf.Max(((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).extents.z));
	}
}


using System.Collections.Generic;

public static class CollectionEx
{
	public static bool IsNullOrEmpty<T>(this ICollection<T> collection)
	{
		if (collection != null)
		{
			return collection.Count == 0;
		}
		return true;
	}

	public static bool IsEmpty<T>(this ICollection<T> collection)
	{
		return collection.Count == 0;
	}
}


using System;
using System.IO;
using System.Threading;

public static class DirectoryEx
{
	public static void Backup(DirectoryInfo parent, params string[] names)
	{
		for (int i = 0; i < names.Length; i++)
		{
			names[i] = Path.Combine(parent.FullName, names[i]);
		}
		Backup(names);
	}

	public static bool MoveToSafe(this DirectoryInfo parent, string target, int retries = 10)
	{
		for (int i = 0; i < retries; i++)
		{
			try
			{
				parent.MoveTo(target);
			}
			catch (Exception)
			{
				Thread.Sleep(5);
				continue;
			}
			return true;
		}
		return false;
	}

	public static void Backup(params string[] names)
	{
		for (int num = names.Length - 2; num >= 0; num--)
		{
			DirectoryInfo directoryInfo = new DirectoryInfo(names[num]);
			DirectoryInfo directoryInfo2 = new DirectoryInfo(names[num + 1]);
			if (directoryInfo.Exists)
			{
				if (directoryInfo2.Exists)
				{
					double totalHours = (DateTime.Now - directoryInfo2.LastWriteTime).TotalHours;
					int num2 = ((num != 0) ? (1 << num - 1) : 0);
					if (totalHours >= (double)num2)
					{
						directoryInfo2.Delete(recursive: true);
						directoryInfo.MoveToSafe(directoryInfo2.FullName);
					}
				}
				else
				{
					if (!directoryInfo2.Parent.Exists)
					{
						directoryInfo2.Parent.Create();
					}
					directoryInfo.MoveToSafe(directoryInfo2.FullName);
				}
			}
		}
	}

	public static void CopyAll(string sourceDirectory, string targetDirectory)
	{
		DirectoryInfo source = new DirectoryInfo(sourceDirectory);
		DirectoryInfo target = new DirectoryInfo(targetDirectory);
		CopyAll(source, target);
	}

	public static void CopyAll(DirectoryInfo source, DirectoryInfo target)
	{
		if (!(source.FullName.ToLower() == target.FullName.ToLower()) && source.Exists)
		{
			if (!target.Exists)
			{
				target.Create();
			}
			FileInfo[] files = source.GetFiles();
			foreach (FileInfo fileInfo in files)
			{
				FileInfo fileInfo2 = new FileInfo(Path.Combine(target.FullName, fileInfo.Name));
				fileInfo.CopyTo(fileInfo2.FullName, overwrite: true);
				fileInfo2.CreationTime = fileInfo.CreationTime;
				fileInfo2.LastAccessTime = fileInfo.LastAccessTime;
				fileInfo2.LastWriteTime = fileInfo.LastWriteTime;
			}
			DirectoryInfo[] directories = source.GetDirectories();
			foreach (DirectoryInfo directoryInfo in directories)
			{
				DirectoryInfo directoryInfo2 = target.CreateSubdirectory(directoryInfo.Name);
				CopyAll(directoryInfo, directoryInfo2);
				directoryInfo2.CreationTime = directoryInfo.CreationTime;
				directoryInfo2.LastAccessTime = directoryInfo.LastAccessTime;
				directoryInfo2.LastWriteTime = directoryInfo.LastWriteTime;
			}
		}
	}
}


using System;
using System.IO;
using System.Threading;

public static class FileEx
{
	public static void Backup(DirectoryInfo parent, params string[] names)
	{
		for (int i = 0; i < names.Length; i++)
		{
			names[i] = Path.Combine(parent.FullName, names[i]);
		}
		Backup(names);
	}

	public static bool MoveToSafe(this FileInfo parent, string target, int retries = 10)
	{
		for (int i = 0; i < retries; i++)
		{
			try
			{
				parent.MoveTo(target);
			}
			catch (Exception)
			{
				Thread.Sleep(5);
				continue;
			}
			return true;
		}
		return false;
	}

	public static void Backup(params string[] names)
	{
		for (int num = names.Length - 2; num >= 0; num--)
		{
			FileInfo fileInfo = new FileInfo(names[num]);
			FileInfo fileInfo2 = new FileInfo(names[num + 1]);
			if (fileInfo.Exists)
			{
				if (fileInfo2.Exists)
				{
					double totalHours = (DateTime.Now - fileInfo2.LastWriteTime).TotalHours;
					int num2 = ((num != 0) ? (1 << num - 1) : 0);
					if (totalHours >= (double)num2)
					{
						fileInfo2.Delete();
						fileInfo.MoveToSafe(fileInfo2.FullName);
					}
				}
				else
				{
					if (!fileInfo2.Directory.Exists)
					{
						fileInfo2.Directory.Create();
					}
					fileInfo.MoveToSafe(fileInfo2.FullName);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;

public static class LinqEx
{
	public static int MaxIndex<T>(this IEnumerable<T> sequence) where T : IComparable<T>
	{
		int num = -1;
		T other = default(T);
		int num2 = 0;
		foreach (T item in sequence)
		{
			if (item.CompareTo(other) > 0 || num == -1)
			{
				num = num2;
				other = item;
			}
			num2++;
		}
		return num;
	}
}


using Network;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class NetworkWriteEx
{
	public static void WriteObject<T>(this NetWrite write, T obj)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		if (typeof(T) == typeof(Vector3))
		{
			Vector3 val = GenericsUtil.Cast<T, Vector3>(obj);
			write.Vector3(ref val);
			return;
		}
		if (typeof(T) == typeof(Vector4))
		{
			Vector4 val2 = GenericsUtil.Cast<T, Vector4>(obj);
			write.Vector4(ref val2);
			return;
		}
		if (typeof(T) == typeof(Ray))
		{
			Ray val3 = GenericsUtil.Cast<T, Ray>(obj);
			write.Ray(ref val3);
			return;
		}
		if (typeof(T) == typeof(float))
		{
			write.Float(GenericsUtil.Cast<T, float>(obj));
			return;
		}
		if (typeof(T) == typeof(short))
		{
			write.Int16(GenericsUtil.Cast<T, short>(obj));
			return;
		}
		if (typeof(T) == typeof(ushort))
		{
			write.UInt16(GenericsUtil.Cast<T, ushort>(obj));
			return;
		}
		if (typeof(T) == typeof(int))
		{
			write.Int32(GenericsUtil.Cast<T, int>(obj));
			return;
		}
		if (typeof(T) == typeof(uint))
		{
			write.UInt32(GenericsUtil.Cast<T, uint>(obj));
			return;
		}
		if (typeof(T) == typeof(byte[]))
		{
			write.Bytes(GenericsUtil.Cast<T, byte[]>(obj));
			return;
		}
		if (typeof(T) == typeof(long))
		{
			write.Int64(GenericsUtil.Cast<T, long>(obj));
			return;
		}
		if (typeof(T) == typeof(ulong))
		{
			write.UInt64(GenericsUtil.Cast<T, ulong>(obj));
			return;
		}
		if (typeof(T) == typeof(string))
		{
			write.String(GenericsUtil.Cast<T, string>(obj), false);
			return;
		}
		if (typeof(T) == typeof(sbyte))
		{
			write.Int8(GenericsUtil.Cast<T, sbyte>(obj));
			return;
		}
		if (typeof(T) == typeof(byte))
		{
			write.UInt8(GenericsUtil.Cast<T, byte>(obj));
			return;
		}
		if (typeof(T) == typeof(bool))
		{
			write.Bool(GenericsUtil.Cast<T, bool>(obj));
			return;
		}
		if (typeof(T) == typeof(Color))
		{
			Color val4 = GenericsUtil.Cast<T, Color>(obj);
			write.Color(ref val4);
			return;
		}
		if (typeof(T) == typeof(Color32))
		{
			Color32 val5 = GenericsUtil.Cast<T, Color32>(obj);
			write.Color32(ref val5);
			return;
		}
		if (typeof(T) == typeof(NetworkableId))
		{
			write.EntityID(GenericsUtil.Cast<T, NetworkableId>(obj));
			return;
		}
		if (typeof(T) == typeof(ItemContainerId))
		{
			write.ItemContainerID(GenericsUtil.Cast<T, ItemContainerId>(obj));
			return;
		}
		if (typeof(T) == typeof(ItemId))
		{
			write.ItemID(GenericsUtil.Cast<T, ItemId>(obj));
			return;
		}
		object obj2 = obj;
		IProto val6 = (IProto)((obj2 is IProto) ? obj2 : null);
		if (val6 != null)
		{
			write.Proto<IProto>(val6);
			return;
		}
		T val7 = obj;
		Debug.LogError((object)("NetworkData.Write - no handler to write " + val7?.ToString() + " -> " + obj.GetType()));
	}
}


public static class ObjectEx
{
	public static bool IsUnityNull<T>(this T obj) where T : class
	{
		return obj?.Equals(null) ?? true;
	}
}


using UnityEngine;

public static class ParticleSystemEx
{
	public static void SetPlayingState(this ParticleSystem ps, bool play)
	{
		if (!((Object)(object)ps == (Object)null))
		{
			if (play && !ps.isPlaying)
			{
				ps.Play();
			}
			else if (!play && ps.isPlaying)
			{
				ps.Stop();
			}
		}
	}

	public static void SetEmitterState(this ParticleSystem ps, bool enable)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		EmissionModule emission = ps.emission;
		if (enable != ((EmissionModule)(ref emission)).enabled)
		{
			EmissionModule emission2 = ps.emission;
			((EmissionModule)(ref emission2)).enabled = enable;
		}
	}
}


using Rust;
using UnityEngine;

public static class RaycastHitEx
{
	public static Transform GetTransform(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).transform;
	}

	public static Rigidbody GetRigidbody(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).rigidbody;
	}

	public static Collider GetCollider(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).collider;
	}

	public static BaseEntity GetEntity(this RaycastHit hit)
	{
		if (!((Object)(object)((RaycastHit)(ref hit)).collider != (Object)null))
		{
			return null;
		}
		return ((RaycastHit)(ref hit)).collider.ToBaseEntity();
	}

	public static bool IsOnLayer(this RaycastHit hit, Layer rustLayer)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((RaycastHit)(ref hit)).collider != (Object)null)
		{
			return ((Component)((RaycastHit)(ref hit)).collider).gameObject.IsOnLayer(rustLayer);
		}
		return false;
	}

	public static bool IsOnLayer(this RaycastHit hit, int layer)
	{
		if ((Object)(object)((RaycastHit)(ref hit)).collider != (Object)null)
		{
			return ((Component)((RaycastHit)(ref hit)).collider).gameObject.IsOnLayer(layer);
		}
		return false;
	}

	public static bool IsWaterHit(this RaycastHit hit)
	{
		if (!((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null))
		{
			return ((Component)((RaycastHit)(ref hit)).collider).gameObject.IsOnLayer((Layer)4);
		}
		return true;
	}

	public static WaterBody GetWaterBody(this RaycastHit hit)
	{
		if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
		{
			return WaterSystem.Ocean;
		}
		Transform transform = ((Component)((RaycastHit)(ref hit)).collider).transform;
		WaterBody result = default(WaterBody);
		if (((Component)transform).TryGetComponent<WaterBody>(ref result))
		{
			return result;
		}
		return ((Component)transform.parent).GetComponentInChildren<WaterBody>();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class RendererEx
{
	private static readonly Memoized<Material[], int> ArrayCache = new Memoized<Material[], int>((Func<int, Material[]>)((int n) => (Material[])(object)new Material[n]));

	public static void SetSharedMaterials(this Renderer renderer, List<Material> materials)
	{
		if (materials.Count != 0)
		{
			if (materials.Count > 10)
			{
				throw new ArgumentOutOfRangeException("materials");
			}
			Material[] array = ArrayCache.Get(materials.Count);
			for (int i = 0; i < materials.Count; i++)
			{
				array[i] = materials[i];
			}
			renderer.sharedMaterials = array;
		}
	}
}


using System.IO;

public static class StreamEx
{
	private static readonly byte[] StaticBuffer = new byte[16384];

	public static void WriteToOtherStream(this Stream self, Stream target)
	{
		int count;
		while ((count = self.Read(StaticBuffer, 0, StaticBuffer.Length)) > 0)
		{
			target.Write(StaticBuffer, 0, count);
		}
	}
}


using System;

public static class TimeSpanEx
{
	public static string ToShortString(this TimeSpan timeSpan)
	{
		return $"{(int)timeSpan.TotalHours:00}:{timeSpan.Minutes:00}:{timeSpan.Seconds:00}";
	}

	public static string ToShortStringNoHours(this TimeSpan timeSpan)
	{
		return $"{timeSpan.Minutes:00}:{timeSpan.Seconds:00}";
	}
}


using UnityEngine;

public class FPSLogger : MonoBehaviour
{
}


using System;
using Facepunch;
using UnityEngine;

public static class FuzzySearch
{
	[ClientVar(Help = "How similar the server name must be to the search filter to be included in the results. (0 is exact match, 1 is no match at all)")]
	public static float search_similarity_modifier = 0.14f;

	private static ArrayPool<int> _levenshteinDistancePool;

	private static int DamerauLevenshteinDistance(string source, string target)
	{
		if (_levenshteinDistancePool == null)
		{
			_levenshteinDistancePool = new ArrayPool<int>(256);
		}
		if (string.IsNullOrEmpty(source))
		{
			if (!string.IsNullOrEmpty(target))
			{
				return target.Length;
			}
			return 0;
		}
		if (string.IsNullOrEmpty(target))
		{
			return source.Length;
		}
		if (source.Length > target.Length)
		{
			string text = target;
			string text2 = source;
			source = text;
			target = text2;
		}
		int length = source.Length;
		int length2 = target.Length;
		int[] array = _levenshteinDistancePool.Rent(length2 + 1);
		int[] array2 = _levenshteinDistancePool.Rent(length2 + 1);
		int[] array3 = _levenshteinDistancePool.Rent(length2 + 1);
		try
		{
			for (int i = 0; i <= length2; i++)
			{
				array[i] = i;
			}
			for (int j = 1; j <= length; j++)
			{
				array2[0] = j;
				for (int k = 1; k <= length2; k++)
				{
					int num = ((source[j - 1] != target[k - 1]) ? 1 : 0);
					int val = array[k] + 1;
					int val2 = array2[k - 1] + 1;
					int num2 = Math.Min(val2: array[k - 1] + num, val1: Math.Min(val, val2));
					if (j > 1 && k > 1 && source[j - 1] == target[k - 2] && source[j - 2] == target[k - 1])
					{
						num2 = Math.Min(num2, array3[k - 2] + num);
					}
					array2[k] = num2;
				}
				int[] array4 = array;
				int[] array5 = array2;
				int[] array6 = array3;
				array3 = array4;
				array = array5;
				array2 = array6;
			}
			return array[length2];
		}
		finally
		{
			_levenshteinDistancePool.Return(array);
			_levenshteinDistancePool.Return(array2);
			_levenshteinDistancePool.Return(array3);
		}
	}

	public static bool IsSimilarWithThreshold(string source, string target, float threshold)
	{
		bool flag = string.IsNullOrEmpty(source);
		bool flag2 = string.IsNullOrEmpty(target);
		if (flag && flag2)
		{
			return true;
		}
		if (flag || flag2)
		{
			return false;
		}
		string text = source.ToLower().Trim();
		string text2 = target.ToLower().Trim();
		int num = DamerauLevenshteinDistance(text, text2);
		if (num <= 3)
		{
			return true;
		}
		int num2 = Mathf.Max(text.Length, text2.Length);
		return 1f - (float)num / (float)num2 >= threshold;
	}

	public static bool IsSimilar(string source, string target)
	{
		return IsSimilarWithThreshold(source, target, search_similarity_modifier);
	}

	public static bool IsSimilarFuzzy(this string source, string target)
	{
		return IsSimilar(source, target);
	}

	public static bool IsSimilarFuzzy(this string source, string target, float threshold)
	{
		return IsSimilarWithThreshold(source, target, threshold);
	}
}


using UnityEngine;

public class BlendTexture : ProcessedTexture
{
	public BlendTexture(int width, int height, bool linear = true)
	{
		material = CreateMaterial("Hidden/BlitCopyAlpha");
		result = CreateRenderTexture("Blend Texture", width, height, linear);
	}

	public void Blend(Texture source, Texture target, float alpha)
	{
		material.SetTexture("_BlendTex", target);
		material.SetFloat("_Alpha", Mathf.Clamp01(alpha));
		Graphics.Blit(source, result, material);
	}

	public void CopyTo(BlendTexture target)
	{
		Graphics.Blit((Texture)(object)result, target.result);
	}
}


using UnityEngine;

public class BlurTexture : ProcessedTexture
{
	public BlurTexture(int width, int height, bool linear = true)
	{
		material = CreateMaterial("Hidden/Rust/SeparableBlur");
		result = CreateRenderTexture("Blur Texture", width, height, linear);
	}

	public void Blur(float radius)
	{
		Blur((Texture)(object)result, radius);
	}

	public void Blur(Texture source, float radius)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture val = CreateTemporary();
		material.SetVector("offsets", new Vector4(radius / (float)Screen.width, 0f, 0f, 0f));
		Graphics.Blit(source, val, material, 0);
		material.SetVector("offsets", new Vector4(0f, radius / (float)Screen.height, 0f, 0f));
		Graphics.Blit((Texture)(object)val, result, material, 0);
		ReleaseTemporary(val);
	}
}


using UnityEngine;

public static class CameraUtil
{
	public static void NormalizePlane(ref Plane plane)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((Plane)(ref plane)).normal;
		float num = 1f / ((Vector3)(ref normal)).magnitude;
		((Plane)(ref plane)).normal = ((Plane)(ref plane)).normal * num;
		((Plane)(ref plane)).distance = ((Plane)(ref plane)).distance * num;
	}

	public static void ExtractPlanes(Camera camera, ref Plane[] planes)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 worldToCameraMatrix = camera.worldToCameraMatrix;
		ExtractPlanes(GL.GetGPUProjectionMatrix(camera.projectionMatrix, false) * worldToCameraMatrix, ref planes);
	}

	public static void ExtractPlanes(Matrix4x4 viewProjMatrix, ref Plane[] planes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		((Plane)(ref planes[0])).normal = new Vector3(viewProjMatrix.m30 + viewProjMatrix.m00, viewProjMatrix.m31 + viewProjMatrix.m01, viewProjMatrix.m32 + viewProjMatrix.m02);
		((Plane)(ref planes[0])).distance = viewProjMatrix.m33 + viewProjMatrix.m03;
		NormalizePlane(ref planes[0]);
		((Plane)(ref planes[1])).normal = new Vector3(viewProjMatrix.m30 - viewProjMatrix.m00, viewProjMatrix.m31 - viewProjMatrix.m01, viewProjMatrix.m32 - viewProjMatrix.m02);
		((Plane)(ref planes[1])).distance = viewProjMatrix.m33 - viewProjMatrix.m03;
		NormalizePlane(ref planes[1]);
		((Plane)(ref planes[2])).normal = new Vector3(viewProjMatrix.m30 - viewProjMatrix.m10, viewProjMatrix.m31 - viewProjMatrix.m11, viewProjMatrix.m32 - viewProjMatrix.m12);
		((Plane)(ref planes[2])).distance = viewProjMatrix.m33 - viewProjMatrix.m13;
		NormalizePlane(ref planes[2]);
		((Plane)(ref planes[3])).normal = new Vector3(viewProjMatrix.m30 + viewProjMatrix.m10, viewProjMatrix.m31 + viewProjMatrix.m11, viewProjMatrix.m32 + viewProjMatrix.m12);
		((Plane)(ref planes[3])).distance = viewProjMatrix.m33 + viewProjMatrix.m13;
		NormalizePlane(ref planes[3]);
		((Plane)(ref planes[4])).normal = new Vector3(viewProjMatrix.m20, viewProjMatrix.m21, viewProjMatrix.m22);
		((Plane)(ref planes[4])).distance = viewProjMatrix.m23;
		NormalizePlane(ref planes[4]);
		((Plane)(ref planes[5])).normal = new Vector3(viewProjMatrix.m30 - viewProjMatrix.m20, viewProjMatrix.m31 - viewProjMatrix.m21, viewProjMatrix.m32 - viewProjMatrix.m22);
		((Plane)(ref planes[5])).distance = viewProjMatrix.m33 - viewProjMatrix.m23;
		NormalizePlane(ref planes[5]);
	}
}


using UnityEngine;

public class ClimateBlendTexture : ProcessedTexture
{
	public ClimateBlendTexture(int width, int height, bool linear = true)
	{
		material = CreateMaterial("Hidden/ClimateBlendLUTs");
		result = CreateRenderTexture("Climate Blend Texture", width, height, linear);
		((Texture)result).wrapMode = (TextureWrapMode)1;
	}

	public bool CheckLostData()
	{
		if (!result.IsCreated())
		{
			result.Create();
			return true;
		}
		return false;
	}

	public void Blend(Texture srcLut1, Texture dstLut1, float lerpLut1, Texture srcLut2, Texture dstLut2, float lerpLut2, float lerp, ClimateBlendTexture prevLut, float time)
	{
		material.SetTexture("_srcLut1", srcLut1);
		material.SetTexture("_dstLut1", dstLut1);
		material.SetTexture("_srcLut2", srcLut2);
		material.SetTexture("_dstLut2", dstLut2);
		material.SetTexture("_prevLut", (Texture)prevLut);
		material.SetFloat("_lerpLut1", lerpLut1);
		material.SetFloat("_lerpLut2", lerpLut2);
		material.SetFloat("_lerp", lerp);
		material.SetFloat("_time", time);
		Graphics.Blit((Texture)null, result, material);
	}

	public static void Swap(ref ClimateBlendTexture a, ref ClimateBlendTexture b)
	{
		ClimateBlendTexture climateBlendTexture = a;
		a = b;
		b = climateBlendTexture;
	}
}


using UnityEngine;

public class DistanceField
{
	private static readonly int[] GaussOffsets = new int[7] { -6, -4, -2, 0, 2, 4, 6 };

	private static readonly float[] GaussWeights = new float[7]
	{
		1f / 32f,
		7f / 64f,
		7f / 32f,
		9f / 32f,
		7f / 32f,
		7f / 64f,
		1f / 32f
	};

	public static void Generate(in int size, in byte threshold, in byte[] image, ref float[] distanceField)
	{
		int num = size + 2;
		int[] array = new int[num * num];
		int[] array2 = new int[num * num];
		float[] array3 = new float[num * num];
		int i = 0;
		int num2 = 0;
		for (; i < num; i++)
		{
			int num3 = 0;
			while (num3 < num)
			{
				array[num2] = -1;
				array2[num2] = -1;
				array3[num2] = float.PositiveInfinity;
				num3++;
				num2++;
			}
		}
		int num4 = 1;
		int num5 = num4 * size;
		int num6 = num4 * num;
		while (num4 < size - 2)
		{
			int num7 = 1;
			int num8 = num5 + num7;
			int num9 = num6 + num7;
			while (num7 < size - 2)
			{
				int num10 = num9 + num + 1;
				bool flag = image[num8] > threshold;
				if (flag && (image[num8 - 1] > threshold != flag || image[num8 + 1] > threshold != flag || image[num8 - size] > threshold != flag || image[num8 + size] > threshold != flag))
				{
					array[num10] = num7 + 1;
					array2[num10] = num4 + 1;
					array3[num10] = 0f;
				}
				num7++;
				num8++;
				num9++;
			}
			num4++;
			num5 += size;
			num6 += num;
		}
		int num11 = 1;
		int num12 = num11 * num;
		while (num11 < num - 1)
		{
			int num13 = 1;
			int num14 = num12 + num13;
			while (num13 < num - 1)
			{
				int num15 = num14 - 1;
				int num16 = num14 - num;
				int num17 = num16 - 1;
				int num18 = num16 + 1;
				float num19 = array3[num14];
				if (array3[num17] + 1.4142135f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num17])), (float)(num11 - (array2[num14] = array2[num17]))));
				}
				if (array3[num16] + 1f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num16])), (float)(num11 - (array2[num14] = array2[num16]))));
				}
				if (array3[num18] + 1.4142135f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num18])), (float)(num11 - (array2[num14] = array2[num18]))));
				}
				if (array3[num15] + 1f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num15])), (float)(num11 - (array2[num14] = array2[num15]))));
				}
				num13++;
				num14++;
			}
			num11++;
			num12 += num;
		}
		int num20 = num - 2;
		int num21 = num20 * num;
		while (num20 >= 1)
		{
			int num22 = num - 2;
			int num23 = num21 + num22;
			while (num22 >= 1)
			{
				int num24 = num23 + 1;
				int num25 = num23 + num;
				int num26 = num25 - 1;
				int num27 = num25 + 1;
				float num28 = array3[num23];
				if (array3[num24] + 1f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num24])), (float)(num20 - (array2[num23] = array2[num24]))));
				}
				if (array3[num26] + 1.4142135f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num26])), (float)(num20 - (array2[num23] = array2[num26]))));
				}
				if (array3[num25] + 1f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num25])), (float)(num20 - (array2[num23] = array2[num25]))));
				}
				if (array3[num27] + 1f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num27])), (float)(num20 - (array2[num23] = array2[num27]))));
				}
				num22--;
				num23--;
			}
			num20--;
			num21 -= num;
		}
		int num29 = 0;
		int num30 = 0;
		int num31 = num;
		while (num29 < size)
		{
			int num32 = 0;
			int num33 = num31 + 1;
			while (num32 < size)
			{
				distanceField[num30] = ((image[num30] > threshold) ? (0f - array3[num33]) : array3[num33]);
				num32++;
				num30++;
				num33++;
			}
			num29++;
			num31 += num;
		}
	}

	private static float SampleClamped(float[] data, int size, int x, int y)
	{
		x = ((x >= 0) ? x : 0);
		y = ((y >= 0) ? y : 0);
		x = ((x >= size) ? (size - 1) : x);
		y = ((y >= size) ? (size - 1) : y);
		return data[y * size + x];
	}

	private static Vector4 SampleClamped(Vector4[] data, int size, int x, int y)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		x = ((x >= 0) ? x : 0);
		y = ((y >= 0) ? y : 0);
		x = ((x >= size) ? (size - 1) : x);
		y = ((y >= size) ? (size - 1) : y);
		return data[y * size + x];
	}

	private static ushort SampleClamped(ushort[] data, int size, int x, int y)
	{
		x = ((x >= 0) ? x : 0);
		y = ((y >= 0) ? y : 0);
		x = ((x >= size) ? (size - 1) : x);
		y = ((y >= size) ? (size - 1) : y);
		return data[y * size + x];
	}

	public static void GenerateVectors(in int size, in float[] distanceField, ref Vector4[] vectorField)
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 1; i < size - 1; i++)
		{
			for (int j = 1; j < size - 1; j++)
			{
				float num = SampleClamped(distanceField, size, i, j);
				float num2 = SampleClamped(distanceField, size, i - 1, j - 1);
				float num3 = SampleClamped(distanceField, size, i - 1, j);
				float num4 = SampleClamped(distanceField, size, i - 1, j + 1);
				float num5 = SampleClamped(distanceField, size, i, j - 1);
				float num6 = SampleClamped(distanceField, size, i, j + 1);
				float num7 = SampleClamped(distanceField, size, i + 1, j - 1);
				float num8 = SampleClamped(distanceField, size, i + 1, j);
				float num9 = SampleClamped(distanceField, size, i + 1, j + 1);
				float num10 = num7 + 2f * num8 + num9 - (num2 + 2f * num3 + num4);
				float num11 = num4 + 2f * num6 + num9 - (num2 + 2f * num5 + num7);
				Vector2 val = new Vector2(0f - num10, 0f - num11);
				Vector2 normalized = ((Vector2)(ref val)).normalized;
				vectorField[j * size + i] = new Vector4(normalized.x, normalized.y, num, 0f);
			}
		}
		for (int k = 1; k < size - 1; k++)
		{
			vectorField[k] = SampleClamped(vectorField, size, k, 1);
			vectorField[(size - 1) * size + k] = SampleClamped(vectorField, size, k, size - 2);
		}
		for (int l = 0; l < size; l++)
		{
			vectorField[l * size] = SampleClamped(vectorField, size, 1, l);
			vectorField[l * size + size - 1] = SampleClamped(vectorField, size, size - 2, l);
		}
	}

	public static void ApplyGaussianBlur(int size, float[] distanceField, int steps = 1)
	{
		if (steps <= 0)
		{
			return;
		}
		float[] array = new float[size * size];
		int num = size - 1;
		for (int i = 0; i < steps; i++)
		{
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			while (num2 < size)
			{
				int num5 = 0;
				while (num5 < size)
				{
					float num6 = 0f;
					for (int j = 0; j < 7; j++)
					{
						int num7 = num5 + GaussOffsets[j];
						num7 = ((num7 >= 0) ? num7 : 0);
						num7 = ((num7 <= num) ? num7 : num);
						num6 += distanceField[num4 + num7] * GaussWeights[j];
					}
					array[num3] = num6;
					num5++;
					num3++;
				}
				num2++;
				num4 += size;
			}
			int k = 0;
			int num8 = 0;
			for (; k < size; k++)
			{
				int num9 = 0;
				while (num9 < size)
				{
					float num10 = 0f;
					for (int l = 0; l < 7; l++)
					{
						int num11 = k + GaussOffsets[l];
						num11 = ((num11 >= 0) ? num11 : 0);
						num11 = ((num11 <= num) ? num11 : num);
						num10 += array[num11 * size + num9] * GaussWeights[l];
					}
					distanceField[num8] = num10;
					num9++;
					num8++;
				}
			}
		}
	}
}


using UnityEngine;

public class ProcessedTexture
{
	protected RenderTexture result;

	protected Material material;

	public void Dispose()
	{
		DestroyRenderTexture(ref result);
		DestroyMaterial(ref material);
	}

	protected RenderTexture CreateRenderTexture(string name, int width, int height, bool linear)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected O, but got Unknown
		RenderTexture val = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)(linear ? 1 : 2))
		{
			hideFlags = (HideFlags)52,
			name = name,
			filterMode = (FilterMode)1,
			anisoLevel = 0
		};
		val.Create();
		return val;
	}

	protected void DestroyRenderTexture(ref RenderTexture rt)
	{
		if (!((Object)(object)rt == (Object)null))
		{
			Object.Destroy((Object)(object)rt);
			rt = null;
		}
	}

	protected RenderTexture CreateTemporary()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return RenderTexture.GetTemporary(((Texture)result).width, ((Texture)result).height, result.depth, result.format, (RenderTextureReadWrite)((!result.sRGB) ? 1 : 2));
	}

	protected void ReleaseTemporary(RenderTexture rt)
	{
		RenderTexture.ReleaseTemporary(rt);
	}

	protected Material CreateMaterial(string shader)
	{
		return CreateMaterial(Shader.Find(shader));
	}

	protected Material CreateMaterial(Shader shader)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Expected O, but got Unknown
		return new Material(shader)
		{
			hideFlags = (HideFlags)52
		};
	}

	protected void DestroyMaterial(ref Material mat)
	{
		if (!((Object)(object)mat == (Object)null))
		{
			Object.Destroy((Object)(object)mat);
			mat = null;
		}
	}

	public static implicit operator Texture(ProcessedTexture t)
	{
		return (Texture)(object)t.result;
	}
}


using UnityEngine;

public class sRGB
{
	public static byte[] to_linear;

	public static byte[] to_srgb;

	static sRGB()
	{
		to_linear = new byte[256];
		to_srgb = new byte[256];
		to_linear = new byte[256];
		to_srgb = new byte[256];
		for (int i = 0; i < 256; i++)
		{
			to_linear[i] = (byte)(srgb_to_linear((float)i * 0.003921569f) * 255f + 0.5f);
		}
		for (int j = 0; j < 256; j++)
		{
			to_srgb[j] = (byte)(linear_to_srgb((float)j * 0.003921569f) * 255f + 0.5f);
		}
	}

	public static float linear_to_srgb(float linear)
	{
		if (float.IsNaN(linear))
		{
			return 0f;
		}
		if (linear > 1f)
		{
			return 1f;
		}
		if (linear < 0f)
		{
			return 0f;
		}
		if (linear < 0.0031308f)
		{
			return 12.92f * linear;
		}
		return 1.055f * Mathf.Pow(linear, 0.41666f) - 0.055f;
	}

	public static float srgb_to_linear(float srgb)
	{
		if (srgb <= 0.04045f)
		{
			return srgb / 12.92f;
		}
		return Mathf.Pow((srgb + 0.055f) / 1.055f, 2.4f);
	}
}


using UnityEngine;

public static class AssetStorage
{
	public static void Save<T>(ref T asset, string path) where T : Object
	{
		Object.op_Implicit((Object)(object)asset);
	}

	public static void Save(ref Texture2D asset)
	{
	}

	public static void Save(ref Texture2D asset, string path, bool linear, bool compress)
	{
		Object.op_Implicit((Object)(object)asset);
	}

	public static void Load<T>(ref T asset, string path) where T : Object
	{
	}

	public static void Delete<T>(ref T asset) where T : Object
	{
		if (Object.op_Implicit((Object)(object)asset))
		{
			Object.Destroy((Object)(object)asset);
			asset = default(T);
		}
	}
}


using System;

public static class CollectionUtil
{
	public static void SortInplace<T>(Span<T> values, Span<int> indices)
	{
		for (int i = 0; i < indices.Length; i++)
		{
			int num = i;
			int num2 = indices[i];
			if (num2 != -1 && num != num2)
			{
				while (num2 != -1 && num != num2)
				{
					T val = values[num2];
					values[num2] = values[i];
					values[i] = val;
					indices[num] = -1;
					num = num2;
					num2 = indices[num2];
				}
			}
		}
	}

	public static void ScatterOutInplace<T>(Span<T> values, ReadOnlySpan<int> indices, T defValue = default(T))
	{
		int num = indices.Length;
		while (num > 0)
		{
			num--;
			int num2 = indices[num];
			if (num != num2)
			{
				values[num2] = values[num];
				values[num] = defValue;
			}
		}
	}

	public static void ScatterTo<T>(ReadOnlySpan<T> from, Span<T> to, ReadOnlySpan<int> indicesTo)
	{
		for (int i = 0; i < indicesTo.Length; i++)
		{
			to[indicesTo[i]] = from[i];
		}
	}
}


using System;

public static class Craptography
{
	private static readonly byte[] hash = new byte[256]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180
	};

	public static void XOR(uint seed, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		int num = hash.Length;
		int num2 = (int)(seed % num);
		for (int i = 0; i < src.Count; i++)
		{
			dst.Array[dst.Offset + i] = (byte)(src.Array[src.Offset + i] ^ hash[(num2 + i) % num]);
		}
		dst = new ArraySegment<byte>(dst.Array, dst.Offset, src.Count);
	}
}


using UnityEngine;

public class FixedRateStepped
{
	public float rate = 0.1f;

	public int maxSteps = 3;

	internal float nextCall;

	public bool ShouldStep()
	{
		if (nextCall > Time.time)
		{
			return false;
		}
		if (nextCall == 0f)
		{
			nextCall = Time.time;
		}
		if (nextCall + rate * (float)maxSteps < Time.time)
		{
			nextCall = Time.time - rate * (float)maxSteps;
		}
		nextCall += rate;
		return true;
	}
}


using System;

[Serializable]
public class FloatConditions
{
	[Serializable]
	public struct Condition
	{
		public enum Types
		{
			Equal,
			NotEqual,
			Higher,
			Lower
		}

		public Types type;

		public float value;

		public bool Test(float val)
		{
			return type switch
			{
				Types.Equal => val == value, 
				Types.NotEqual => val != value, 
				Types.Higher => val > value, 
				Types.Lower => val < value, 
				_ => false, 
			};
		}
	}

	public Condition[] conditions;

	public bool AllTrue(float val)
	{
		Condition[] array = conditions;
		foreach (Condition condition in array)
		{
			if (!condition.Test(val))
			{
				return false;
			}
		}
		return true;
	}
}


using System;

[Serializable]
public struct Condition
{
	public enum Types
	{
		Equal,
		NotEqual,
		Higher,
		Lower
	}

	public Types type;

	public float value;

	public bool Test(float val)
	{
		return type switch
		{
			Types.Equal => val == value, 
			Types.NotEqual => val != value, 
			Types.Higher => val > value, 
			Types.Lower => val < value, 
			_ => false, 
		};
	}
}


public enum Types
{
	Equal,
	NotEqual,
	Higher,
	Lower
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class FoliageGridMeshData
{
	public struct FoliageVertex
	{
		public Vector3 position;

		public Vector3 normal;

		public Vector4 tangent;

		public Color32 color;

		public Vector2 uv;

		public Vector4 uv2;

		public static readonly VertexAttributeDescriptor[] VertexLayout = (VertexAttributeDescriptor[])(object)new VertexAttributeDescriptor[6]
		{
			new VertexAttributeDescriptor((VertexAttribute)0, (VertexAttributeFormat)0, 3, 0),
			new VertexAttributeDescriptor((VertexAttribute)1, (VertexAttributeFormat)0, 3, 0),
			new VertexAttributeDescriptor((VertexAttribute)2, (VertexAttributeFormat)0, 4, 0),
			new VertexAttributeDescriptor((VertexAttribute)3, (VertexAttributeFormat)2, 4, 0),
			new VertexAttributeDescriptor((VertexAttribute)4, (VertexAttributeFormat)0, 2, 0),
			new VertexAttributeDescriptor((VertexAttribute)6, (VertexAttributeFormat)0, 4, 0)
		};
	}

	public List<FoliageVertex> vertices;

	public List<int> triangles;

	public Bounds bounds;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<FoliageVertex>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<FoliageVertex>(ref vertices);
		}
	}

	public void Clear()
	{
		triangles?.Clear();
		vertices?.Clear();
	}

	public void Combine(MeshGroup meshGroup)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		if (((List<MeshInstance>)(object)meshGroup).Count == 0)
		{
			return;
		}
		bounds = new Bounds(((List<MeshInstance>)(object)meshGroup)[0].position, Vector3.zero);
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshInstance>)(object)meshGroup).Count; i++)
		{
			MeshInstance meshInstance = ((List<MeshInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshInstance.position, meshInstance.rotation, meshInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshInstance.data.vertices.Length; k++)
			{
				Vector4 val2 = meshInstance.data.tangents[k];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				FoliageVertex item = default(FoliageVertex);
				item.position = ((Matrix4x4)(ref val)).MultiplyPoint3x4(meshInstance.data.vertices[k]);
				item.normal = ((Matrix4x4)(ref val)).MultiplyVector(meshInstance.data.normals[k]);
				item.uv = meshInstance.data.uv[k];
				item.uv2 = Vector4.op_Implicit(meshInstance.position);
				item.tangent = new Vector4(val4.x, val4.y, val4.z, val2.w);
				if (meshInstance.data.colors32.Length != 0)
				{
					item.color = meshInstance.data.colors32[k];
				}
				vertices.Add(item);
			}
			((Bounds)(ref bounds)).Encapsulate(new Bounds(meshInstance.position + ((Bounds)(ref meshInstance.data.bounds)).center, ((Bounds)(ref meshInstance.data.bounds)).size));
		}
		ref Bounds reference = ref bounds;
		((Bounds)(ref reference)).size = ((Bounds)(ref reference)).size + Vector3.one;
	}

	public void Apply(Mesh mesh)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		mesh.SetVertexBufferParams(vertices.Count, FoliageVertex.VertexLayout);
		mesh.SetVertexBufferData<FoliageVertex>(vertices, 0, 0, vertices.Count, 0, (MeshUpdateFlags)9);
		mesh.SetIndices(triangles, (MeshTopology)0, 0, false, 0);
		mesh.bounds = bounds;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public struct FoliageVertex
{
	public Vector3 position;

	public Vector3 normal;

	public Vector4 tangent;

	public Color32 color;

	public Vector2 uv;

	public Vector4 uv2;

	public static readonly VertexAttributeDescriptor[] VertexLayout = (VertexAttributeDescriptor[])(object)new VertexAttributeDescriptor[6]
	{
		new VertexAttributeDescriptor((VertexAttribute)0, (VertexAttributeFormat)0, 3, 0),
		new VertexAttributeDescriptor((VertexAttribute)1, (VertexAttributeFormat)0, 3, 0),
		new VertexAttributeDescriptor((VertexAttribute)2, (VertexAttributeFormat)0, 4, 0),
		new VertexAttributeDescriptor((VertexAttribute)3, (VertexAttributeFormat)2, 4, 0),
		new VertexAttributeDescriptor((VertexAttribute)4, (VertexAttributeFormat)0, 2, 0),
		new VertexAttributeDescriptor((VertexAttribute)6, (VertexAttributeFormat)0, 4, 0)
	};
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class FoliageGridBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private FoliageGridMeshData meshData;

	private MeshGroup meshGroup;

	private bool hasRunAwake;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		hasRunAwake = true;
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new FoliageGridMeshData();
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Invalid comparison between Unknown and I4
		if (!hasRunAwake)
		{
			Awake();
		}
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshData.Clear();
		meshData.Combine(meshGroup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshGroup>(ref meshGroup);
		}
	}
}


using UnityEngine;

public static class GameObjectUtil
{
	public static void GlobalBroadcast(string messageName, object param = null)
	{
		Transform[] rootObjects = TransformUtil.GetRootObjects();
		for (int i = 0; i < rootObjects.Length; i++)
		{
			((Component)rootObjects[i]).BroadcastMessage(messageName, param, (SendMessageOptions)1);
		}
	}
}


using System;
using UnityEngine;

public static class GizmosUtil
{
	public static void DrawWireCircleX(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(0f, 1f, 1f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCircleY(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 0f, 1f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCircleZ(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 1f, 0f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleX(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(0f, 1f, 1f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleY(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 0f, 1f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleZ(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 1f, 0f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCylinderX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleX(pos - new Vector3(0.5f * height, 0f, 0f), radius);
		DrawWireCircleX(pos + new Vector3(0.5f * height, 0f, 0f), radius);
	}

	public static void DrawWireCylinderY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleY(pos - new Vector3(0f, 0.5f * height, 0f), radius);
		DrawWireCircleY(pos + new Vector3(0f, 0.5f * height, 0f), radius);
	}

	public static void DrawWireCylinderZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleZ(pos - new Vector3(0f, 0f, 0.5f * height), radius);
		DrawWireCircleZ(pos + new Vector3(0f, 0f, 0.5f * height), radius);
	}

	public static void DrawCylinderX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleX(pos - new Vector3(0.5f * height, 0f, 0f), radius);
		DrawCircleX(pos + new Vector3(0.5f * height, 0f, 0f), radius);
	}

	public static void DrawCylinderY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleY(pos - new Vector3(0f, 0.5f * height, 0f), radius);
		DrawCircleY(pos + new Vector3(0f, 0.5f * height, 0f), radius);
	}

	public static void DrawCylinderZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleZ(pos - new Vector3(0f, 0f, 0.5f * height), radius);
		DrawCircleZ(pos + new Vector3(0f, 0f, 0.5f * height), radius);
	}

	public static void DrawWireCapsuleX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0.5f * height, 0f, 0f) + Vector3.right * radius;
		Vector3 val2 = pos + new Vector3(0.5f * height, 0f, 0f) - Vector3.right * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.forward * radius, val2 + Vector3.forward * radius);
		Gizmos.DrawLine(val + Vector3.up * radius, val2 + Vector3.up * radius);
		Gizmos.DrawLine(val + Vector3.back * radius, val2 + Vector3.back * radius);
		Gizmos.DrawLine(val + Vector3.down * radius, val2 + Vector3.down * radius);
	}

	public static void DrawWireCapsuleY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0.5f * height, 0f) + Vector3.up * radius;
		Vector3 val2 = pos + new Vector3(0f, 0.5f * height, 0f) - Vector3.up * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.forward * radius, val2 + Vector3.forward * radius);
		Gizmos.DrawLine(val + Vector3.right * radius, val2 + Vector3.right * radius);
		Gizmos.DrawLine(val + Vector3.back * radius, val2 + Vector3.back * radius);
		Gizmos.DrawLine(val + Vector3.left * radius, val2 + Vector3.left * radius);
	}

	public static void DrawWireCapsuleZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0f, 0.5f * height) + Vector3.forward * radius;
		Vector3 val2 = pos + new Vector3(0f, 0f, 0.5f * height) - Vector3.forward * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.up * radius, val2 + Vector3.up * radius);
		Gizmos.DrawLine(val + Vector3.right * radius, val2 + Vector3.right * radius);
		Gizmos.DrawLine(val + Vector3.down * radius, val2 + Vector3.down * radius);
		Gizmos.DrawLine(val + Vector3.left * radius, val2 + Vector3.left * radius);
	}

	public static void DrawCapsuleX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0.5f * height, 0f, 0f);
		Vector3 val2 = pos + new Vector3(0.5f * height, 0f, 0f);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawCapsuleY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0.5f * height, 0f);
		Vector3 val2 = pos + new Vector3(0f, 0.5f * height, 0f);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawCapsuleZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0f, 0.5f * height);
		Vector3 val2 = pos + new Vector3(0f, 0f, 0.5f * height);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix = Matrix4x4.TRS(pos, rot, size);
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
		Gizmos.matrix = matrix;
	}

	public static void DrawCube(Vector3 pos, Vector3 size, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix = Matrix4x4.TRS(pos, rot, size);
		Gizmos.DrawCube(Vector3.zero, Vector3.one);
		Gizmos.matrix = matrix;
	}

	public static void DrawWirePath(Vector3 a, Vector3 b, float thickness)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleY(a, thickness);
		DrawWireCircleY(b, thickness);
		Vector3 val = b - a;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Quaternion.Euler(0f, 90f, 0f) * normalized;
		Gizmos.DrawLine(b + val2 * thickness, a + val2 * thickness);
		Gizmos.DrawLine(b - val2 * thickness, a - val2 * thickness);
	}

	public static void DrawSemiCircle(float radius)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		float num = radius * (MathF.PI / 180f) * 0.5f;
		Vector3 val = Mathf.Cos(num) * Vector3.forward + Mathf.Sin(num) * Vector3.right;
		Gizmos.DrawLine(Vector3.zero, val);
		Vector3 val2 = Mathf.Cos(0f - num) * Vector3.forward + Mathf.Sin(0f - num) * Vector3.right;
		Gizmos.DrawLine(Vector3.zero, val2);
		float num2 = Mathf.Clamp(radius / 16f, 4f, 64f);
		float num3 = num / num2;
		for (float num4 = num; num4 > 0f; num4 -= num3)
		{
			Vector3 val3 = Mathf.Cos(num4) * Vector3.forward + Mathf.Sin(num4) * Vector3.right;
			Gizmos.DrawLine(Vector3.zero, val3);
			if (val != Vector3.zero)
			{
				Gizmos.DrawLine(val3, val);
			}
			val = val3;
			Vector3 val4 = Mathf.Cos(0f - num4) * Vector3.forward + Mathf.Sin(0f - num4) * Vector3.right;
			Gizmos.DrawLine(Vector3.zero, val4);
			if (val2 != Vector3.zero)
			{
				Gizmos.DrawLine(val4, val2);
			}
			val2 = val4;
		}
		Gizmos.DrawLine(val, val2);
	}

	public static void DrawArrowHead(Vector3 pos, Vector3 dir, float arrowHeadLength = 0.25f, float arrowHeadAngle = 20f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.LookRotation(dir) * Quaternion.Euler(arrowHeadAngle, 0f, 0f) * Vector3.back;
		Vector3 val2 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f - arrowHeadAngle, 0f, 0f) * Vector3.back;
		Vector3 val3 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f, arrowHeadAngle, 0f) * Vector3.back;
		Vector3 val4 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f, 0f - arrowHeadAngle, 0f) * Vector3.back;
		Gizmos.DrawRay(pos + dir, val * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val2 * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val3 * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val4 * arrowHeadLength);
	}

	public static void DrawMeshes(Transform transform)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderer[] componentsInChildren = ((Component)transform).GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer val in componentsInChildren)
		{
			if (!((Renderer)val).enabled)
			{
				continue;
			}
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				Transform transform2 = ((Component)val).transform;
				if ((Object)(object)transform2 != (Object)null && (Object)(object)component != (Object)null && (Object)(object)component.sharedMesh != (Object)null && component.sharedMesh.normals != null && component.sharedMesh.normals.Length != 0)
				{
					Gizmos.DrawMesh(component.sharedMesh, transform2.position, transform2.rotation, transform2.lossyScale);
				}
			}
		}
	}

	public static void DrawBounds(Transform transform)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = transform.GetBounds(includeRenderers: true, includeColliders: false);
		Vector3 lossyScale = transform.lossyScale;
		Quaternion rotation = transform.rotation;
		Vector3 pos = transform.position + rotation * Vector3.Scale(lossyScale, ((Bounds)(ref bounds)).center);
		Vector3 size = Vector3.Scale(lossyScale, ((Bounds)(ref bounds)).size);
		DrawCube(pos, size, rotation);
		DrawWireCube(pos, size, rotation);
	}
}


using Development.Attributes;

[ResetStaticFields]
public class GlobalMessages
{
}


public interface IInventoryChanged
{
}


public interface IPreInventoryChanged
{
}


public interface IViewModeChanged
{
}


public interface IClothingChanged
{
}


public interface IViewModelUpdated
{
}


public interface IBlueprintsChanged
{
}


public interface IItemAmountChanged
{
}


public interface IItemIconChanged
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class HierarchyUtil
{
	public static Dictionary<string, GameObject> rootDict = new Dictionary<string, GameObject>(StringComparer.OrdinalIgnoreCase);

	public static GameObject GetRoot(string strName, bool groupActive = true, bool persistant = false)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Expected O, but got Unknown
		if (rootDict.TryGetValue(strName, out var value))
		{
			if ((Object)(object)value != (Object)null)
			{
				return value;
			}
			rootDict.Remove(strName);
		}
		value = new GameObject(strName);
		value.SetActive(groupActive);
		rootDict.Add(strName, value);
		if (persistant)
		{
			Object.DontDestroyOnLoad((Object)(object)value);
		}
		return value;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class LocalClock
{
	public struct TimedEvent
	{
		public float time;

		public float delta;

		public float variance;

		public Action action;
	}

	public List<TimedEvent> events = new List<TimedEvent>();

	public void Add(float delta, float variance, Action action)
	{
		TimedEvent item = default(TimedEvent);
		item.time = Time.time + delta + Random.Range(0f - variance, variance);
		item.delta = delta;
		item.variance = variance;
		item.action = action;
		events.Add(item);
	}

	public void Tick()
	{
		for (int i = 0; i < events.Count; i++)
		{
			TimedEvent value = events[i];
			if (Time.time > value.time)
			{
				float delta = value.delta;
				float variance = value.variance;
				value.action();
				value.time = Time.time + delta + Random.Range(0f - variance, variance);
				events[i] = value;
			}
		}
	}
}


using System;

public struct TimedEvent
{
	public float time;

	public float delta;

	public float variance;

	public Action action;
}


using Rust;
using UnityEngine;

public abstract class MeshBatch : MonoBehaviour
{
	public bool NeedsRefresh { get; private set; }

	public int Count { get; private set; }

	public int BatchedCount { get; private set; }

	public int VertexCount { get; private set; }

	public abstract int VertexCapacity { get; }

	public abstract int VertexCutoff { get; }

	public int AvailableVertices => Mathf.Clamp(VertexCapacity, VertexCutoff, 65534) - VertexCount;

	protected abstract void AllocMemory();

	protected abstract void FreeMemory();

	protected abstract void RefreshMesh();

	protected abstract void ApplyMesh();

	protected abstract void ToggleMesh(bool state);

	protected abstract void OnPooled();

	public void Alloc()
	{
		AllocMemory();
	}

	public void Free()
	{
		FreeMemory();
	}

	public void Refresh()
	{
		RefreshMesh();
	}

	public void Apply()
	{
		NeedsRefresh = false;
		ApplyMesh();
	}

	public void Display()
	{
		ToggleMesh(state: true);
		BatchedCount = Count;
	}

	public void Invalidate()
	{
		ToggleMesh(state: false);
		BatchedCount = 0;
	}

	protected void AddVertices(int vertices)
	{
		NeedsRefresh = true;
		Count++;
		VertexCount += vertices;
	}

	protected void OnEnable()
	{
		NeedsRefresh = false;
		Count = 0;
		BatchedCount = 0;
		VertexCount = 0;
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			NeedsRefresh = false;
			Count = 0;
			BatchedCount = 0;
			VertexCount = 0;
			OnPooled();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class MeshDataBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private MeshData meshData;

	private MeshGroup meshGroup;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new MeshData();
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Invalid comparison between Unknown and I4
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshData.Clear();
		meshData.Combine(meshGroup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshGroup>(ref meshGroup);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class MeshRendererBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private MeshRendererData meshData;

	private MeshRendererGroup meshGroup;

	private MeshRendererLookup meshLookup;

	private static MaterialPropertyBlock propertyBlock;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new MeshRendererData();
		meshLookup = new MeshRendererLookup();
	}

	public void SetupColor(Color color)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		if (propertyBlock == null)
		{
			propertyBlock = new MaterialPropertyBlock();
		}
		((Renderer)meshRenderer).GetPropertyBlock(propertyBlock);
		((Renderer)meshRenderer).SetPropertyBlock(propertyBlock);
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer, Color color)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Invalid comparison between Unknown and I4
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		SetupColor(color);
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshRendererInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshRendererInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshRendererGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshRendererGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshLookup.dst.Clear();
		meshData.Clear();
		meshData.Combine(meshGroup, meshLookup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshLookup.Apply();
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		List<MeshRendererLookup.LookupEntry> data = meshLookup.src.data;
		for (int i = 0; i < data.Count; i++)
		{
			Renderer renderer = data[i].renderer;
			if (Object.op_Implicit((Object)(object)renderer))
			{
				renderer.enabled = !state;
			}
		}
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshRendererGroup>(ref meshGroup);
		}
		meshLookup.src.Clear();
		meshLookup.dst.Clear();
	}
}


using System.IO;
using System.Text;
using UnityEngine;

public static class ObjWriter
{
	public static string MeshToString(Mesh mesh)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("g ").Append(((Object)mesh).name).Append("\n");
		Vector3[] vertices = mesh.vertices;
		foreach (Vector3 val in vertices)
		{
			stringBuilder.Append($"v {0f - val.x} {val.y} {val.z}\n");
		}
		stringBuilder.Append("\n");
		vertices = mesh.normals;
		foreach (Vector3 val2 in vertices)
		{
			stringBuilder.Append($"vn {0f - val2.x} {val2.y} {val2.z}\n");
		}
		stringBuilder.Append("\n");
		Vector2[] uv = mesh.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			Vector3 val3 = Vector2.op_Implicit(uv[i]);
			stringBuilder.Append($"vt {val3.x} {val3.y}\n");
		}
		stringBuilder.Append("\n");
		int[] triangles = mesh.triangles;
		for (int j = 0; j < triangles.Length; j += 3)
		{
			int num = triangles[j] + 1;
			int num2 = triangles[j + 1] + 1;
			int num3 = triangles[j + 2] + 1;
			stringBuilder.Append(string.Format("f {1}/{1}/{1} {0}/{0}/{0} {2}/{2}/{2}\n", num, num2, num3));
		}
		return stringBuilder.ToString();
	}

	public static void Write(Mesh mesh, string path)
	{
		using StreamWriter streamWriter = new StreamWriter(path);
		streamWriter.Write(MeshToString(mesh));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathFinder
{
	public struct Point : IEquatable<Point>
	{
		public int x;

		public int y;

		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public static Point operator +(Point a, Point b)
		{
			return new Point(a.x + b.x, a.y + b.y);
		}

		public static Point operator -(Point a, Point b)
		{
			return new Point(a.x - b.x, a.y - b.y);
		}

		public static Point operator *(Point p, int i)
		{
			return new Point(p.x * i, p.y * i);
		}

		public static Point operator /(Point p, int i)
		{
			return new Point(p.x / i, p.y / i);
		}

		public static bool operator ==(Point a, Point b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(Point a, Point b)
		{
			return !a.Equals(b);
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Point))
			{
				return false;
			}
			return Equals((Point)other);
		}

		public bool Equals(Point other)
		{
			if (x == other.x)
			{
				return y == other.y;
			}
			return false;
		}
	}

	public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
	{
		public Point point;

		public int cost;

		public int heuristic;

		public Node next { get; set; }

		public Node child { get; set; }

		public int order => cost + heuristic;

		public Node(Point point, int cost, int heuristic, Node next = null)
		{
			this.point = point;
			this.cost = cost;
			this.heuristic = heuristic;
			this.next = next;
		}
	}

	private int[,] costmap;

	private int[,] visited;

	private Point[] neighbors;

	private bool diagonals;

	private bool directional;

	public Point PushPoint;

	public int PushRadius;

	public int PushDistance;

	public int PushMultiplier;

	public List<Point> PushPointsAdditional = new List<Point>();

	public HashSet<Point> BlockedPointsAdditional = new HashSet<Point>();

	private static Point[] mooreNeighbors = new Point[8]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1),
		new Point(-1, 1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(1, -1)
	};

	private static Point[] neumannNeighbors = new Point[4]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1)
	};

	public PathFinder(int[,] costmap, bool diagonals = true, bool directional = true)
	{
		this.costmap = costmap;
		neighbors = (diagonals ? mooreNeighbors : neumannNeighbors);
		this.diagonals = diagonals;
		this.directional = directional;
	}

	public int GetResolution(int index)
	{
		return costmap.GetLength(index);
	}

	public Node FindPath(Point start, Point end, int depth = int.MaxValue)
	{
		return FindPathReversed(end, start, depth);
	}

	private Node FindPathReversed(Point start, Point end, int depth = int.MaxValue)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		int num5 = Cost(start);
		if (num5 != int.MaxValue)
		{
			int heuristic = Heuristic(start, end);
			val.Add(new Node(start, num5, heuristic));
		}
		visited[start.x, start.y] = num5;
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x < num || point.x > num2 || point.y < num3 || point.y > num4)
				{
					continue;
				}
				int num6 = Cost(point, node);
				if (num6 != int.MaxValue)
				{
					int num7 = visited[point.x, point.y];
					if (num7 == 0 || num6 < num7)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point, end);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
				else
				{
					visited[point.x, point.y] = -1;
				}
			}
		}
		return null;
	}

	public Node FindPathDirected(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		if (startList.Count == 0 || endList.Count == 0)
		{
			return null;
		}
		return FindPathReversed(endList, startList, depth);
	}

	public Node FindPathUndirected(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		if (startList.Count == 0 || endList.Count == 0)
		{
			return null;
		}
		if (startList.Count > endList.Count)
		{
			return FindPathReversed(endList, startList, depth);
		}
		return FindPathReversed(startList, endList, depth);
	}

	private Node FindPathReversed(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		foreach (Point start in startList)
		{
			int num5 = Cost(start);
			if (num5 != int.MaxValue)
			{
				int heuristic = Heuristic(start, endList);
				val.Add(new Node(start, num5, heuristic));
			}
			visited[start.x, start.y] = num5;
		}
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x < num || point.x > num2 || point.y < num3 || point.y > num4)
				{
					continue;
				}
				int num6 = Cost(point, node);
				if (num6 != int.MaxValue)
				{
					int num7 = visited[point.x, point.y];
					if (num7 == 0 || num6 < num7)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point, endList);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
				else
				{
					visited[point.x, point.y] = -1;
				}
			}
		}
		return null;
	}

	public Node FindClosestWalkable(Point start, int depth = int.MaxValue)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		if (start.x < num)
		{
			return null;
		}
		if (start.x > num2)
		{
			return null;
		}
		if (start.y < num3)
		{
			return null;
		}
		if (start.y > num4)
		{
			return null;
		}
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		int num5 = 1;
		int heuristic = Heuristic(start);
		val.Add(new Node(start, num5, heuristic));
		visited[start.x, start.y] = num5;
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x >= num && point.x <= num2 && point.y >= num3 && point.y <= num4)
				{
					int num6 = 1;
					if (visited[point.x, point.y] == 0)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
			}
		}
		return null;
	}

	public bool IsWalkable(Point point)
	{
		return costmap[point.x, point.y] != int.MaxValue;
	}

	public bool IsWalkableWithNeighbours(Point point)
	{
		if (costmap[point.x, point.y] == int.MaxValue)
		{
			return false;
		}
		for (int i = 0; i < neighbors.Length; i++)
		{
			Point point2 = point + neighbors[i];
			if (costmap[point2.x, point2.y] == int.MaxValue)
			{
				return false;
			}
		}
		return true;
	}

	public Node Reverse(Node start)
	{
		Node node = null;
		Node next = null;
		for (Node node2 = start; node2 != null; node2 = node2.next)
		{
			if (node != null)
			{
				node.next = next;
			}
			next = node;
			node = node2;
		}
		if (node != null)
		{
			node.next = next;
		}
		return node;
	}

	public Node FindEnd(Node start)
	{
		for (Node node = start; node != null; node = node.next)
		{
			if (node.next == null)
			{
				return node;
			}
		}
		return start;
	}

	public int Cost(Point a)
	{
		int num = costmap[a.x, a.y];
		int num2 = 0;
		if (BlockedPointsAdditional.Contains(a))
		{
			num = int.MaxValue;
		}
		if (num == int.MaxValue)
		{
			return num;
		}
		if (PushMultiplier > 0)
		{
			int num3 = ((PushRadius > 0) ? Mathf.Max(0, Heuristic(a, PushPoint) - PushRadius) : (PushDistance * 2));
			for (int i = 0; i < PushPointsAdditional.Count; i++)
			{
				num3 = Mathf.Min(num3, Heuristic(a, PushPointsAdditional[i]));
			}
			float num4 = Mathf.Max(0f, (float)(PushDistance - num3)) / (float)PushDistance;
			num2 = ((PushMultiplier != int.MaxValue) ? Mathf.CeilToInt((float)PushMultiplier * num4) : ((num4 > 0f) ? int.MaxValue : 0));
		}
		if (num2 == int.MaxValue)
		{
			return num2;
		}
		return num + num2;
	}

	public int Cost(Point a, Node prev)
	{
		int num = Cost(a);
		int num2 = 0;
		if (num != int.MaxValue && directional && prev != null && prev.next != null && Heuristic(a, prev.next.point) <= 1)
		{
			num2 = 10000;
		}
		return num + num2;
	}

	public int Heuristic(Point a)
	{
		if (costmap[a.x, a.y] != int.MaxValue)
		{
			return 0;
		}
		return 1;
	}

	public int Heuristic(Point a, Point b)
	{
		int num = Mathf.Abs(a.x - b.x);
		int num2 = Mathf.Abs(a.y - b.y);
		if (diagonals)
		{
			return Mathf.Max(num, num2);
		}
		return num + num2;
	}

	public int Heuristic(Point a, List<Point> b)
	{
		int num = int.MaxValue;
		for (int i = 0; i < b.Count; i++)
		{
			num = Mathf.Min(num, Heuristic(a, b[i]));
		}
		return num;
	}

	public float Distance(Point a, Point b)
	{
		int num = a.x - b.x;
		int num2 = a.y - b.y;
		return Mathf.Sqrt((float)(num * num + num2 * num2));
	}

	public static Point GetPoint(Vector3 worldPos, int res)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.NormalizeX(worldPos.x);
		float num2 = TerrainMeta.NormalizeZ(worldPos.z);
		Point result = default(Point);
		result.x = Mathf.Clamp((int)(num * (float)res), 0, res - 1);
		result.y = Mathf.Clamp((int)(num2 * (float)res), 0, res - 1);
		return result;
	}
}


using System;

public struct Point : IEquatable<Point>
{
	public int x;

	public int y;

	public Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public static Point operator +(Point a, Point b)
	{
		return new Point(a.x + b.x, a.y + b.y);
	}

	public static Point operator -(Point a, Point b)
	{
		return new Point(a.x - b.x, a.y - b.y);
	}

	public static Point operator *(Point p, int i)
	{
		return new Point(p.x * i, p.y * i);
	}

	public static Point operator /(Point p, int i)
	{
		return new Point(p.x / i, p.y / i);
	}

	public static bool operator ==(Point a, Point b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Point a, Point b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Point))
		{
			return false;
		}
		return Equals((Point)other);
	}

	public bool Equals(Point other)
	{
		if (x == other.x)
		{
			return y == other.y;
		}
		return false;
	}
}


public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
{
	public Point point;

	public int cost;

	public int heuristic;

	public Node next { get; set; }

	public Node child { get; set; }

	public int order => cost + heuristic;

	public Node(Point point, int cost, int heuristic, Node next = null)
	{
		this.point = point;
		this.cost = cost;
		this.heuristic = heuristic;
		this.next = next;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathInterpolator
{
	public Vector3[] Points;

	public Vector3[] Tangents;

	protected bool initialized;

	public int MinIndex { get; set; }

	public int MaxIndex { get; set; }

	public virtual float Length { get; private set; }

	public virtual float StepSize { get; private set; }

	public bool Circular { get; private set; }

	public int DefaultMinIndex => 0;

	public int DefaultMaxIndex => Points.Length - 1;

	public float StartOffset => Length * (float)(MinIndex - DefaultMinIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public float EndOffset => Length * (float)(DefaultMaxIndex - MaxIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public PathInterpolator(Vector3[] points)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (points.Length < 2)
		{
			throw new ArgumentException("Point list too short.");
		}
		Points = points;
		MinIndex = DefaultMinIndex;
		MaxIndex = DefaultMaxIndex;
		Circular = Vector3.Distance(points[0], points[^1]) < 0.1f;
	}

	public PathInterpolator(Vector3[] points, Vector3[] tangents)
		: this(points)
	{
		if (tangents.Length != points.Length)
		{
			throw new ArgumentException("Points and tangents lengths must match. Points: " + points.Length + " Tangents: " + tangents.Length);
		}
		Tangents = tangents;
		RecalculateLength();
		initialized = true;
	}

	public void RecalculateTangents()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (Tangents == null || Tangents.Length != Points.Length)
		{
			Tangents = (Vector3[])(object)new Vector3[Points.Length];
		}
		for (int i = 0; i < Points.Length; i++)
		{
			int num = i - 1;
			int num2 = i + 1;
			if (num < 0)
			{
				num = (Circular ? (Points.Length - 2) : 0);
			}
			if (num2 > Points.Length - 1)
			{
				num2 = (Circular ? 1 : (Points.Length - 1));
			}
			Vector3 val = Points[num];
			Vector3 val2 = Points[num2];
			Vector3[] tangents = Tangents;
			int num3 = i;
			Vector3 val3 = val2 - val;
			tangents[num3] = ((Vector3)(ref val3)).normalized;
		}
		RecalculateLength();
		initialized = true;
	}

	public void RecalculateLength()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		for (int i = 0; i < Points.Length - 1; i++)
		{
			Vector3 val = Points[i];
			Vector3 val2 = Points[i + 1];
			float num2 = num;
			Vector3 val3 = val2 - val;
			num = num2 + ((Vector3)(ref val3)).magnitude;
		}
		Length = num;
		StepSize = num / (float)Points.Length;
	}

	public void Resample(float distance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		Vector3 val3;
		for (int i = 0; i < Points.Length - 1; i++)
		{
			Vector3 val = Points[i];
			Vector3 val2 = Points[i + 1];
			float num2 = num;
			val3 = val2 - val;
			num = num2 + ((Vector3)(ref val3)).magnitude;
		}
		int num3 = Mathf.RoundToInt(num / distance);
		if (num3 < 2)
		{
			return;
		}
		distance = num / (float)(num3 - 1);
		List<Vector3> list = new List<Vector3>(num3);
		float num4 = 0f;
		for (int j = 0; j < Points.Length - 1; j++)
		{
			int num5 = j;
			int num6 = j + 1;
			Vector3 val4 = Points[num5];
			Vector3 val5 = Points[num6];
			val3 = val5 - val4;
			float num7 = ((Vector3)(ref val3)).magnitude;
			if (num5 == 0)
			{
				list.Add(val4);
			}
			while (num4 + num7 > distance)
			{
				float num8 = distance - num4;
				float num9 = num8 / num7;
				Vector3 val6 = Vector3.Lerp(val4, val5, num9);
				list.Add(val6);
				val4 = val6;
				num4 = 0f;
				num7 -= num8;
			}
			num4 += num7;
			if (num6 == Points.Length - 1 && num4 > distance * 0.5f)
			{
				list.Add(val5);
			}
		}
		if (list.Count >= 2)
		{
			Points = list.ToArray();
			MinIndex = DefaultMinIndex;
			MaxIndex = DefaultMaxIndex;
			initialized = false;
		}
	}

	public void Smoothen(int iterations, Func<int, float> filter = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Smoothen(iterations, Vector3.one, filter);
	}

	public void Smoothen(int iterations, Vector3 multipliers, Func<int, float> filter = null)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < iterations; i++)
		{
			for (int j = MinIndex + ((!Circular) ? 1 : 0); j <= MaxIndex - 1; j += 2)
			{
				SmoothenIndex(j, multipliers, filter);
			}
			for (int k = MinIndex + (Circular ? 1 : 2); k <= MaxIndex - 1; k += 2)
			{
				SmoothenIndex(k, multipliers, filter);
			}
		}
		initialized = false;
	}

	private void SmoothenIndex(int i, Vector3 multipliers, Func<int, float> filter = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		int num = i - 1;
		int num2 = i + 1;
		if (i == 0)
		{
			num = Points.Length - 2;
		}
		Vector3 val = Points[num];
		Vector3 val2 = Points[i];
		Vector3 val3 = Points[num2];
		Vector3 val4 = (val + val2 + val2 + val3) * 0.25f;
		if (filter != null)
		{
			multipliers *= filter(i);
		}
		if (multipliers != Vector3.one)
		{
			val4.x = Mathf.LerpUnclamped(val2.x, val4.x, multipliers.x);
			val4.y = Mathf.LerpUnclamped(val2.y, val4.y, multipliers.y);
			val4.z = Mathf.LerpUnclamped(val2.z, val4.z, multipliers.z);
		}
		Points[i] = val4;
		if (i == 0)
		{
			Points[Points.Length - 1] = Points[0];
		}
	}

	public void Straighten(int diStart, int diEnd)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Points[diStart];
		Vector3 val2 = Points[diEnd];
		Vector3 val3 = Tangents[diStart];
		Vector3 val4 = Tangents[diEnd];
		float num = 1f / (float)(diEnd - diStart);
		for (int i = diStart + 1; i <= diEnd - 1; i++)
		{
			float num2 = (float)(i - diStart) * num;
			Points[i] = Vector3.Lerp(val, val2, num2);
			Tangents[i] = Vector3.Slerp(val3, val4, num2);
		}
	}

	public Vector3 GetStartPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Points[MinIndex];
	}

	public Vector3 GetEndPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Points[MaxIndex];
	}

	public Vector3 GetStartTangent()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MinIndex];
	}

	public Vector3 GetEndTangent()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MaxIndex];
	}

	public Vector3 GetPointByIndex(int i)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!Circular)
		{
			return Points[Mathf.Clamp(i, 0, Points.Length - 1)];
		}
		return Points[(i % Points.Length + Points.Length) % Points.Length];
	}

	public Vector3 GetTangentByIndex(int i)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = GetPoint(i + 1) - GetPoint(i - 1);
		return ((Vector3)(ref val)).normalized;
	}

	public int GetPrevIndex(float distance)
	{
		return Mathf.FloorToInt(distance / Length * (float)(Points.Length - 1));
	}

	public int GetNextIndex(float distance)
	{
		return Mathf.CeilToInt(distance / Length * (float)(Points.Length - 1));
	}

	public Vector3 GetPoint(int index)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		if (index <= MinIndex)
		{
			return GetStartPoint();
		}
		if (index >= MaxIndex)
		{
			return GetEndPoint();
		}
		return Points[index];
	}

	public Vector3 GetPoint(float distance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Points.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 val = Points[num2];
		Vector3 val2 = Points[num2 + 1];
		float num3 = num - (float)num2;
		return Vector3.Lerp(val, val2, num3);
	}

	public virtual Vector3 GetTangent(float distance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Tangents.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartTangent();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndTangent();
		}
		Vector3 val = Tangents[num2];
		Vector3 val2 = Tangents[num2 + 1];
		float num3 = num - (float)num2;
		return Vector3.Slerp(val, val2, num3);
	}

	public virtual Vector3 GetPointCubicHermite(float distance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Points.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 val = Points[num2];
		Vector3 val2 = Points[num2 + 1];
		Vector3 val3 = Tangents[num2] * StepSize;
		Vector3 val4 = Tangents[num2 + 1] * StepSize;
		float num3 = num - (float)num2;
		float num4 = num3 * num3;
		float num5 = num3 * num4;
		return (2f * num5 - 3f * num4 + 1f) * val + (num5 - 2f * num4 + num3) * val3 + (-2f * num5 + 3f * num4) * val2 + (num5 - num4) * val4;
	}
}


public class RadixSorter
{
	private uint[] histogram;

	private uint[] offset;

	public RadixSorter()
	{
		histogram = new uint[768];
		offset = new uint[768];
	}

	public void SortU8(uint[] values, uint[] remap, uint num)
	{
		for (int i = 0; i < 256; i++)
		{
			histogram[i] = 0u;
		}
		for (uint num2 = 0u; num2 < num; num2++)
		{
			histogram[values[num2] & 0xFF]++;
		}
		offset[0] = 0u;
		for (uint num3 = 0u; num3 < 255; num3++)
		{
			offset[num3 + 1] = offset[num3] + histogram[num3];
		}
		for (uint num4 = 0u; num4 < num; num4++)
		{
			remap[offset[values[num4] & 0xFF]++] = num4;
		}
	}

	public void SortU24(uint[] values, uint[] remap, uint[] remapTemp, uint num)
	{
		for (int i = 0; i < 768; i++)
		{
			histogram[i] = 0u;
		}
		for (uint num2 = 0u; num2 < num; num2++)
		{
			uint num3 = values[num2];
			histogram[num3 & 0xFF]++;
			histogram[256 + ((num3 >> 8) & 0xFF)]++;
			histogram[512 + ((num3 >> 16) & 0xFF)]++;
		}
		offset[0] = (offset[256] = (offset[512] = 0u));
		uint num4 = 0u;
		uint num5 = 256u;
		uint num6 = 512u;
		while (num4 < 255)
		{
			offset[num4 + 1] = offset[num4] + histogram[num4];
			offset[num5 + 1] = offset[num5] + histogram[num5];
			offset[num6 + 1] = offset[num6] + histogram[num6];
			num4++;
			num5++;
			num6++;
		}
		for (uint num7 = 0u; num7 < num; num7++)
		{
			remapTemp[offset[values[num7] & 0xFF]++] = num7;
		}
		for (uint num8 = 0u; num8 < num; num8++)
		{
			uint num9 = remapTemp[num8];
			remap[offset[256 + ((values[num9] >> 8) & 0xFF)]++] = num9;
		}
		for (uint num10 = 0u; num10 < num; num10++)
		{
			uint num9 = remap[num10];
			remapTemp[offset[512 + ((values[num9] >> 16) & 0xFF)]++] = num9;
		}
		for (uint num11 = 0u; num11 < num; num11++)
		{
			remap[num11] = remapTemp[num11];
		}
	}
}


using System.Collections.Generic;
using System.IO;

public static class RawWriter
{
	public static void Write(IEnumerable<byte> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (byte datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<int> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (int datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<short> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (short datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<ushort> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (ushort datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<float> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (float datum in data)
		{
			binaryWriter.Write(datum);
		}
	}
}


using Network;

public struct RealTimeSinceEx
{
	private double time;

	public static implicit operator double(RealTimeSinceEx ts)
	{
		return TimeEx.realtimeSinceStartup - ts.time;
	}

	public static implicit operator RealTimeSinceEx(double ts)
	{
		RealTimeSinceEx result = default(RealTimeSinceEx);
		result.time = TimeEx.realtimeSinceStartup - ts;
		return result;
	}

	public override string ToString()
	{
		return (TimeEx.realtimeSinceStartup - time).ToString();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SynchronizedClock
{
	public struct TimedEvent
	{
		public float time;

		public float delta;

		public float variance;

		public Action<uint> action;
	}

	public List<TimedEvent> events = new List<TimedEvent>();

	private static float CurrentTime => Time.realtimeSinceStartup;

	public void Add(float delta, float variance, Action<uint> action)
	{
		TimedEvent item = default(TimedEvent);
		item.time = CurrentTime;
		item.delta = delta;
		item.variance = variance;
		item.action = action;
		events.Add(item);
	}

	public void Tick()
	{
		for (int i = 0; i < events.Count; i++)
		{
			TimedEvent value = events[i];
			float time = value.time;
			float currentTime = CurrentTime;
			float delta = value.delta;
			float num = time - time % delta;
			uint obj = (uint)(time / delta);
			SeedRandom.Wanghash(ref obj);
			SeedRandom.Wanghash(ref obj);
			SeedRandom.Wanghash(ref obj);
			float num2 = SeedRandom.Range(ref obj, 0f - value.variance, value.variance);
			float num3 = num + delta + num2;
			if (time < num3 && currentTime >= num3)
			{
				value.action(obj);
				value.time = currentTime;
			}
			else if (currentTime > time || currentTime < num - 5f)
			{
				value.time = currentTime;
			}
			events[i] = value;
		}
	}
}


using System;

public struct TimedEvent
{
	public float time;

	public float delta;

	public float variance;

	public Action<uint> action;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using Facepunch;
using UnityEngine;

public static class ThreadUtil
{
	public enum ErrorLogging
	{
		None,
		LogExceptionAndBreak
	}

	public static async Task IterateBudgetUnbuffered<T>(IReadOnlyList<T> collection, TimeSpan budget, ErrorLogging errorLogging, Action<T> callback)
	{
		Stopwatch timer = Stopwatch.StartNew();
		for (int i = 0; i < collection.Count; i++)
		{
			try
			{
				callback(collection[i]);
			}
			catch (Exception ex)
			{
				if (errorLogging == ErrorLogging.LogExceptionAndBreak)
				{
					Debug.LogException(ex);
					break;
				}
			}
			if (timer.Elapsed > budget)
			{
				await Task.Delay(1);
				timer.Restart();
			}
		}
	}

	public static async Task IterateBudget<T>(IReadOnlyList<T> collection, TimeSpan budget, ErrorLogging errorLogging, Action<T> callback)
	{
		List<T> list = Pool.Get<List<T>>();
		list.AddRange(collection);
		await IterateBudgetUnbuffered(list, budget, errorLogging, callback);
		Pool.FreeUnmanaged<T>(ref list);
		await Task.CompletedTask;
	}
}


public enum ErrorLogging
{
	None,
	LogExceptionAndBreak
}


using UnityEngine;

public class TickHistory
{
	private Deque<Vector3> points = new Deque<Vector3>(8);

	public int Count => points.Count;

	public void Reset()
	{
		points.Clear();
	}

	public void Reset(Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		AddPoint(point);
	}

	public float Distance(BasePlayer player, Vector3 point)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (points.Count == 0)
		{
			return player.Distance(point);
		}
		Vector3 position = ((Component)player).transform.position;
		Quaternion rotation = ((Component)player).transform.rotation;
		Bounds bounds = player.bounds;
		Matrix4x4 tickHistoryMatrix = player.tickHistoryMatrix;
		float num = float.MaxValue;
		Line val3 = default(Line);
		OBB val5 = default(OBB);
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 val = ((Matrix4x4)(ref tickHistoryMatrix)).MultiplyPoint3x4(points[i]);
			Vector3 val2 = ((i == points.Count - 1) ? position : ((Matrix4x4)(ref tickHistoryMatrix)).MultiplyPoint3x4(points[i + 1]));
			((Line)(ref val3))..ctor(val, val2);
			Vector3 val4 = ((Line)(ref val3)).ClosestPoint(point);
			((OBB)(ref val5))..ctor(val4, rotation, bounds);
			num = Mathf.Min(num, ((OBB)(ref val5)).Distance(point));
		}
		return num;
	}

	public void AddPoint(Vector3 point, int limit = -1)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		while (limit > 0 && points.Count >= limit)
		{
			points.PopFront();
		}
		points.PushBack(point);
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 val = points[i];
			val = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(val);
			points[i] = val;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TickInterpolator
{
	public struct Segment
	{
		public Vector3 point;

		public readonly float length;

		public Segment(Vector3 a, Vector3 b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			point = b;
			length = Vector3.Distance(a, b);
		}

		public Segment(Vector3 b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			point = b;
			length = 0f;
		}
	}

	private readonly List<Segment> points = new List<Segment>();

	private int index;

	public float Length;

	public Vector3 CurrentPoint;

	public Vector3 StartPoint;

	public Vector3 EndPoint;

	public int Count => points.Count;

	public void Reset()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		index = 0;
		CurrentPoint = StartPoint;
	}

	public void Reset(Vector3 point)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		points.Clear();
		index = 0;
		Length = 0f;
		CurrentPoint = (StartPoint = (EndPoint = point));
	}

	public void AddPoint(Vector3 point)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Segment item = new Segment(EndPoint, point);
		points.Add(item);
		Length += item.length;
		EndPoint = item.point;
	}

	public bool MoveNext(float distance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		while (num < distance && index < points.Count)
		{
			Segment segment = points[index];
			CurrentPoint = segment.point;
			num += segment.length;
			index++;
		}
		return num > 0f;
	}

	public bool HasNext()
	{
		return index < points.Count;
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < points.Count; i++)
		{
			Segment value = points[i];
			value.point = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(value.point);
			points[i] = value;
		}
		CurrentPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(CurrentPoint);
		StartPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(StartPoint);
		EndPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(EndPoint);
	}
}


using UnityEngine;

public struct Segment
{
	public Vector3 point;

	public readonly float length;

	public Segment(Vector3 a, Vector3 b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		point = b;
		length = Vector3.Distance(a, b);
	}

	public Segment(Vector3 b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		point = b;
		length = 0f;
	}
}


using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class TickInterpolatorCache
{
	public struct PlayerInfo
	{
		public int Count;

		public float Length;
	}

	public struct ReadOnlyState
	{
		public readonly ReadOnly<TickInterpolator.Segment> Segments;

		public readonly ReadOnly<PlayerInfo> Infos;

		public readonly int BufferSize;

		public ReadOnlyState(ReadOnly<TickInterpolator.Segment> playerSegments, ReadOnly<PlayerInfo> playerInfos, int bufferSize)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Segments = playerSegments;
			Infos = playerInfos;
			BufferSize = bufferSize;
		}
	}

	public struct PlayerTickIterator
	{
		private readonly ReadOnlyState state;

		private readonly int playerIndex;

		private Vector3 currPoint;

		private int segmentIndex;

		public Vector3 CurrentPoint => currPoint;

		public Vector3 StartPoint => GetStartPoint(state, playerIndex);

		public Vector3 EndPoint => GetEndPoint(state, playerIndex);

		public float Length => state.Infos[playerIndex].Length;

		public PlayerTickIterator(ReadOnlyState state, int playerIndex)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			this.state = state;
			this.playerIndex = playerIndex;
			segmentIndex = 0;
			currPoint = GetStartPoint(state, playerIndex);
		}

		public bool MoveNext(float distance)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			float num = 0f;
			int num2 = playerIndex * state.BufferSize + 1;
			while (num < distance && HasNext())
			{
				TickInterpolator.Segment segment = state.Segments[num2 + segmentIndex];
				currPoint = segment.point;
				num += segment.length;
				segmentIndex++;
			}
			return num > 0f;
		}

		public void Reset()
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			segmentIndex = 0;
			currPoint = StartPoint;
		}

		public bool HasNext()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return segmentIndex < state.Infos[playerIndex].Count;
		}
	}

	private NativeArray<TickInterpolator.Segment> playerSegments;

	private NativeArray<PlayerInfo> playerInfos;

	private int bufferSize = 9;

	public ReadOnlyState ReadOnly => new ReadOnlyState(playerSegments.AsReadOnly(), playerInfos.AsReadOnly(), bufferSize);

	public TickInterpolatorCache(int capacity = 32)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		playerSegments = new NativeArray<TickInterpolator.Segment>(bufferSize * capacity, (Allocator)4, (NativeArrayOptions)0);
		playerInfos = new NativeArray<PlayerInfo>(capacity, (Allocator)4, (NativeArrayOptions)1);
	}

	public void Dispose()
	{
		NativeArrayEx.SafeDispose(ref playerSegments);
		NativeArrayEx.SafeDispose(ref playerInfos);
	}

	public void ReplacePlayer(int index)
	{
		playerInfos[index] = default(PlayerInfo);
	}

	public unsafe void AddTick(BasePlayer player, Vector3 point)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		int stableIndex = player.StableIndex;
		int num = player.StableIndex * bufferSize;
		ref PlayerInfo reference = ref UnsafeUtility.ArrayElementAsRef<PlayerInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<PlayerInfo>(playerInfos), stableIndex);
		int num2 = ++reference.Count;
		Vector3 point2 = playerSegments[num + num2 - 1].point;
		TickInterpolator.Segment segment = new TickInterpolator.Segment(point2, point);
		reference.Length += segment.length;
		if (num2 >= bufferSize)
		{
			GrowSegments(playerInfos.Length);
		}
		playerSegments[num + num2] = segment;
	}

	public unsafe void Reset(BasePlayer player, Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		int stableIndex = player.StableIndex;
		ref PlayerInfo reference = ref UnsafeUtility.ArrayElementAsRef<PlayerInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<PlayerInfo>(playerInfos), stableIndex);
		reference.Count = 0;
		reference.Length = 0f;
		int num = player.StableIndex * bufferSize;
		playerSegments[num] = new TickInterpolator.Segment(point);
	}

	public void Expand(int newCap)
	{
		int length = playerInfos.Length;
		if (newCap > length)
		{
			NativeArrayEx.Expand(ref playerInfos, newCap, (NativeArrayOptions)1);
			GrowSegments(length);
		}
	}

	public static Vector3 GetStartPoint(ReadOnlyState state, int playerIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return state.Segments[playerIndex * state.BufferSize].point;
	}

	public static Vector3 GetEndPoint(ReadOnlyState state, int playerIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		PlayerInfo info = state.Infos[playerIndex];
		return GetEndPoint(state, playerIndex, info);
	}

	public static Vector3 GetEndPoint(ReadOnlyState state, int playerIndex, PlayerInfo info)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return state.Segments[playerIndex * state.BufferSize + info.Count].point;
	}

	public void TransformEntries(int playerIndex, in Matrix4x4 matrix)
	{
		PlayerInfo info = playerInfos[playerIndex];
		TransformEntries(playerIndex, info, in matrix);
	}

	public unsafe void TransformEntries(int playerIndex, PlayerInfo info, in Matrix4x4 matrix)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<TickInterpolator.Segment> subArray = playerSegments.GetSubArray(playerIndex * bufferSize, info.Count + 1);
		void* unsafePtr = NativeArrayUnsafeUtility.GetUnsafePtr<TickInterpolator.Segment>(subArray);
		for (int i = 0; i < subArray.Length; i++)
		{
			ref TickInterpolator.Segment reference = ref UnsafeUtility.ArrayElementAsRef<TickInterpolator.Segment>(unsafePtr, i);
			Matrix4x4 val = matrix;
			reference.point = ((Matrix4x4)(ref val)).MultiplyPoint3x4(reference.point);
		}
	}

	public static PlayerTickIterator GetPlayerTickIterator(ReadOnlyState state, int playerIndex)
	{
		return new PlayerTickIterator(state, playerIndex);
	}

	private void GrowSegments(int oldPlayerCap)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		int length = playerInfos.Length;
		int num = bufferSize;
		if (length == oldPlayerCap)
		{
			bufferSize += 4;
		}
		NativeArray<TickInterpolator.Segment> val = default(NativeArray<TickInterpolator.Segment>);
		val..ctor(length * bufferSize, (Allocator)4, (NativeArrayOptions)0);
		for (int i = 0; i < oldPlayerCap; i++)
		{
			int count = playerInfos[i].Count;
			if (count > 0)
			{
				NativeArray<TickInterpolator.Segment> subArray = playerSegments.GetSubArray(i * num, count + 1);
				NativeArray<TickInterpolator.Segment> subArray2 = val.GetSubArray(i * bufferSize, count + 1);
				subArray.CopyTo(subArray2);
			}
			else
			{
				val[i * bufferSize] = playerSegments[i * num];
			}
		}
		playerSegments.Dispose();
		playerSegments = val;
	}
}


public struct PlayerInfo
{
	public int Count;

	public float Length;
}


using Unity.Collections;

public struct ReadOnlyState
{
	public readonly ReadOnly<TickInterpolator.Segment> Segments;

	public readonly ReadOnly<PlayerInfo> Infos;

	public readonly int BufferSize;

	public ReadOnlyState(ReadOnly<TickInterpolator.Segment> playerSegments, ReadOnly<PlayerInfo> playerInfos, int bufferSize)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Segments = playerSegments;
		Infos = playerInfos;
		BufferSize = bufferSize;
	}
}


using UnityEngine;

public struct PlayerTickIterator
{
	private readonly ReadOnlyState state;

	private readonly int playerIndex;

	private Vector3 currPoint;

	private int segmentIndex;

	public Vector3 CurrentPoint => currPoint;

	public Vector3 StartPoint => GetStartPoint(state, playerIndex);

	public Vector3 EndPoint => GetEndPoint(state, playerIndex);

	public float Length => state.Infos[playerIndex].Length;

	public PlayerTickIterator(ReadOnlyState state, int playerIndex)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		this.state = state;
		this.playerIndex = playerIndex;
		segmentIndex = 0;
		currPoint = GetStartPoint(state, playerIndex);
	}

	public bool MoveNext(float distance)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = playerIndex * state.BufferSize + 1;
		while (num < distance && HasNext())
		{
			TickInterpolator.Segment segment = state.Segments[num2 + segmentIndex];
			currPoint = segment.point;
			num += segment.length;
			segmentIndex++;
		}
		return num > 0f;
	}

	public void Reset()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		segmentIndex = 0;
		currPoint = StartPoint;
	}

	public bool HasNext()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return segmentIndex < state.Infos[playerIndex].Count;
	}
}


using System;
using UnityEngine;

public class TimeCachedValue<T>
{
	public float refreshCooldown;

	public float refreshRandomRange;

	public Func<T> updateValue;

	private T cachedValue;

	private TimeSince cooldown;

	private bool hasRun;

	private bool forceNextRun;

	public T Get(bool force)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(cooldown) < refreshCooldown && !force && hasRun && !forceNextRun)
		{
			return cachedValue;
		}
		hasRun = true;
		forceNextRun = false;
		cooldown = TimeSince.op_Implicit(0f - Random.Range(0f, refreshRandomRange));
		if (updateValue != null)
		{
			cachedValue = updateValue();
		}
		else
		{
			cachedValue = default(T);
		}
		return cachedValue;
	}

	public void ForceNextRun()
	{
		forceNextRun = true;
	}

	public void UpdateImmediately()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		hasRun = true;
		forceNextRun = false;
		cooldown = TimeSince.op_Implicit(0f - Random.Range(0f, refreshRandomRange));
		if (updateValue != null)
		{
			cachedValue = updateValue();
		}
		else
		{
			cachedValue = default(T);
		}
	}
}


using System.Diagnostics;
using Facepunch.Rust;
using UnityEngine;

public struct Timing
{
	private Stopwatch sw;

	private string name;

	public static Timing Start(string name)
	{
		return new Timing(name);
	}

	public void End()
	{
		if (sw.Elapsed.TotalSeconds > 0.30000001192092896)
		{
			Debug.Log((object)("[" + sw.Elapsed.TotalSeconds.ToString("0.0") + "s] " + name));
			PerformanceLogging.server?.SetTiming(name, sw.Elapsed);
		}
	}

	public Timing(string name)
	{
		sw = Stopwatch.StartNew();
		this.name = name;
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public static class TransformUtil
{
	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hit, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out hit, 100f, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hit, float range, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out hit, range, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hitOut, float range, LayerMask mask, Transform ignoreTransform = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		hitOut = default(RaycastHit);
		if (GamePhysics.Trace(new Ray(startPos, Vector3.down), 0f, out var hitInfo, range, LayerMask.op_Implicit(mask), (QueryTriggerInteraction)0))
		{
			if ((Object)(object)ignoreTransform != (Object)null && (Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null && ((Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).transform == (Object)(object)ignoreTransform || ((Component)((RaycastHit)(ref hitInfo)).collider).transform.IsChildOf(ignoreTransform)))
			{
				return GetGroundInfo(startPos - new Vector3(0f, 0.01f, 0f), out hitOut, range, mask, ignoreTransform);
			}
			hitOut = hitInfo;
			return true;
		}
		return false;
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out pos, out normal, 100f, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out pos, out normal, range, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, LayerMask mask, Transform ignoreTransform = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(startPos, Vector3.down), 0f, list, range, LayerMask.op_Implicit(mask), (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			Collider collider = ((RaycastHit)(ref current)).collider;
			if ((Object)(object)collider == (Object)null)
			{
				continue;
			}
			if ((Object)(object)ignoreTransform != (Object)null)
			{
				Transform transform = ((Component)collider).transform;
				if ((Object)(object)transform == (Object)null || (Object)(object)transform == (Object)(object)ignoreTransform || transform.IsChildOf(ignoreTransform))
				{
					continue;
				}
			}
			pos = ((RaycastHit)(ref current)).point;
			normal = ((RaycastHit)(ref current)).normal;
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			return true;
		}
		pos = startPos;
		normal = Vector3.up;
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfoTerrainOnly(startPos, out pos, out normal, 100f, LayerMask.op_Implicit(-1));
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfoTerrainOnly(startPos, out pos, out normal, range, LayerMask.op_Implicit(-1));
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, LayerMask mask)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(new Ray(startPos, Vector3.down), ref val, range, LayerMask.op_Implicit(mask)) && ((RaycastHit)(ref val)).collider is TerrainCollider)
		{
			pos = ((RaycastHit)(ref val)).point;
			normal = ((RaycastHit)(ref val)).normal;
			return true;
		}
		pos = startPos;
		normal = Vector3.up;
		return false;
	}

	public static Transform[] GetRootObjects()
	{
		return (from x in Object.FindObjectsOfType<Transform>()
			where (Object)(object)((Component)x).transform == (Object)(object)((Component)x).transform.root
			select x).ToArray();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class WorldSpline : MonoBehaviour
{
	public int dataIndex = -1;

	public Vector3[] points;

	public Vector3[] tangents;

	[Range(0.05f, 100f)]
	public float lutInterval = 0.25f;

	[SerializeField]
	private bool showGizmos = true;

	private static List<Vector3> visualSplineList = new List<Vector3>();

	private WorldSplineData privateData;

	public WorldSplineData GetData()
	{
		if (WorldSplineSharedData.TryGetDataFor(this, out var data))
		{
			return data;
		}
		if (Application.isPlaying && privateData == null)
		{
			privateData = new WorldSplineData(this);
		}
		return privateData;
	}

	public void SetAll(Vector3[] points, Vector3[] tangents, float lutInterval)
	{
		this.points = points;
		this.tangents = tangents;
		this.lutInterval = lutInterval;
	}

	public void CheckValidity()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		lutInterval = Mathf.Clamp(lutInterval, 0.05f, 100f);
		if (points == null || points.Length < 2)
		{
			points = (Vector3[])(object)new Vector3[2];
			points[0] = Vector3.zero;
			points[1] = Vector3.zero;
		}
		if (tangents != null && points.Length == tangents.Length)
		{
			return;
		}
		Vector3[] array = (Vector3[])(object)new Vector3[points.Length];
		for (int i = 0; i < array.Length; i++)
		{
			if (tangents != null && i < tangents.Length)
			{
				array[i] = tangents[i];
			}
			else
			{
				array[i] = Vector3.forward;
			}
		}
		tangents = array;
	}

	protected virtual void OnDrawGizmosSelected()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (showGizmos)
		{
			DrawSplineGizmo(this, Color.magenta);
		}
	}

	protected static void DrawSplineGizmo(WorldSpline ws, Color splineColour)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ws == (Object)null)
		{
			return;
		}
		WorldSplineData data = ws.GetData();
		if (data == null || ws.points.Length < 2 || ws.points.Length != ws.tangents.Length)
		{
			return;
		}
		Vector3[] pointsWorld = ws.GetPointsWorld();
		Vector3[] tangentsWorld = ws.GetTangentsWorld();
		for (int i = 0; i < pointsWorld.Length; i++)
		{
			Gizmos.color = Color.magenta;
			Gizmos.DrawSphere(pointsWorld[i], 0.25f);
			if (((Vector3)(ref tangentsWorld[i])).magnitude > 0f)
			{
				Gizmos.color = Color.cyan;
				Vector3 val = pointsWorld[i] + tangentsWorld[i] + Vector3.up * 0.1f;
				Gizmos.DrawLine(pointsWorld[i] + Vector3.up * 0.1f, val);
			}
		}
		Gizmos.color = splineColour;
		Vector3[] visualSpline = GetVisualSpline(ws, data, 1f);
		for (int j = 0; j < visualSpline.Length - 1; j++)
		{
			Gizmos.color = Color.Lerp(Color.white, splineColour, (float)j / (float)(visualSpline.Length - 1));
			Gizmos.DrawLine(visualSpline[j], visualSpline[j + 1]);
			Gizmos.DrawLine(visualSpline[j], visualSpline[j] + Vector3.up * 0.25f);
		}
	}

	private static Vector3[] GetVisualSpline(WorldSpline ws, WorldSplineData data, float distBetweenPoints)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		visualSplineList.Clear();
		if ((Object)(object)ws != (Object)null && ws.points.Length > 1)
		{
			Vector3 startPointWorld = ws.GetStartPointWorld();
			Vector3 endPointWorld = ws.GetEndPointWorld();
			visualSplineList.Add(startPointWorld);
			for (float num = distBetweenPoints; num <= data.Length - distBetweenPoints; num += distBetweenPoints)
			{
				visualSplineList.Add(ws.GetPointCubicHermiteWorld(num, data));
			}
			visualSplineList.Add(endPointWorld);
		}
		return visualSplineList.ToArray();
	}

	public Vector3 GetStartPointWorld()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(points[0]);
	}

	public Vector3 GetEndPointWorld()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(points[points.Length - 1]);
	}

	public Vector3 GetStartTangentWorld()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * tangents[0], ((Component)this).transform.localScale);
	}

	public Vector3 GetEndTangentWorld()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * tangents[tangents.Length - 1], ((Component)this).transform.localScale);
	}

	public Vector3 GetTangentCubicHermiteWorld(float distance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * GetData().GetTangentCubicHermite(distance), ((Component)this).transform.localScale);
	}

	public Vector3 GetTangentCubicHermiteWorld(float distance, WorldSplineData data)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * data.GetTangentCubicHermite(distance), ((Component)this).transform.localScale);
	}

	public Vector3 GetPointCubicHermiteWorld(float distance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(GetData().GetPointCubicHermite(distance));
	}

	public Vector3 GetPointCubicHermiteWorld(float distance, WorldSplineData data)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(data.GetPointCubicHermite(distance));
	}

	public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, out Vector3 tangent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermite = GetData().GetPointAndTangentCubicHermite(distance, out tangent);
		tangent = ((Component)this).transform.TransformVector(tangent);
		return ((Component)this).transform.TransformPoint(pointAndTangentCubicHermite);
	}

	public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, WorldSplineData data, out Vector3 tangent)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermite = data.GetPointAndTangentCubicHermite(distance, out tangent);
		tangent = ((Component)this).transform.TransformVector(tangent);
		return ((Component)this).transform.TransformPoint(pointAndTangentCubicHermite);
	}

	public Vector3[] GetPointsWorld()
	{
		return PointsToWorld(points, ((Component)this).transform);
	}

	public Vector3[] GetTangentsWorld()
	{
		return TangentsToWorld(tangents, ((Component)this).transform);
	}

	private static Vector3[] PointsToWorld(Vector3[] points, Transform tr)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[points.Length];
		for (int i = 0; i < points.Length; i++)
		{
			array[i] = tr.TransformPoint(points[i]);
		}
		return array;
	}

	private static Vector3[] TangentsToWorld(Vector3[] tangents, Transform tr)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[tangents.Length];
		for (int i = 0; i < tangents.Length; i++)
		{
			array[i] = Vector3.Scale(tr.rotation * tangents[i], tr.localScale);
		}
		return array;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class WorldSplineData
{
	[Serializable]
	public class LUTEntry
	{
		[Serializable]
		public struct LUTPoint
		{
			public float distance;

			public Vector3 pos;

			public LUTPoint(float distance, Vector3 pos)
			{
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				this.distance = distance;
				this.pos = pos;
			}
		}

		public List<LUTPoint> points = new List<LUTPoint>();
	}

	public Vector3[] inputPoints;

	public Vector3[] inputTangents;

	public float inputLUTInterval;

	public List<LUTEntry> LUTValues;

	public float Length;

	[SerializeField]
	private int maxPointsIndex;

	public WorldSplineData(WorldSpline worldSpline)
	{
		worldSpline.CheckValidity();
		LUTValues = new List<LUTEntry>();
		inputPoints = (Vector3[])(object)new Vector3[worldSpline.points.Length];
		worldSpline.points.CopyTo(inputPoints, 0);
		inputTangents = (Vector3[])(object)new Vector3[worldSpline.tangents.Length];
		worldSpline.tangents.CopyTo(inputTangents, 0);
		inputLUTInterval = worldSpline.lutInterval;
		maxPointsIndex = inputPoints.Length - 1;
		CreateLookupTable(worldSpline);
	}

	public bool IsSameAs(WorldSpline worldSpline)
	{
		if (inputPoints.SequenceEqual(worldSpline.points) && inputTangents.SequenceEqual(worldSpline.tangents))
		{
			return inputLUTInterval == worldSpline.lutInterval;
		}
		return false;
	}

	public bool IsDifferentTo(WorldSpline worldSpline)
	{
		return !IsSameAs(worldSpline);
	}

	public Vector3 GetStartPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return inputPoints[0];
	}

	public Vector3 GetEndPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return inputPoints[maxPointsIndex];
	}

	public Vector3 GetStartTangent()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return inputTangents[0];
	}

	public Vector3 GetEndTangent()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return inputTangents[maxPointsIndex];
	}

	public Vector3 GetPointCubicHermite(float distance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		Vector3 tangent;
		return GetPointAndTangentCubicHermite(distance, out tangent);
	}

	public Vector3 GetTangentCubicHermite(float distance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		GetPointAndTangentCubicHermite(distance, out var tangent);
		return tangent;
	}

	public Vector3 GetPointAndTangentCubicHermite(float distance, out Vector3 tangent)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		if (distance <= 0f)
		{
			tangent = GetStartTangent();
			return GetStartPoint();
		}
		if (distance >= Length)
		{
			tangent = GetEndTangent();
			return GetEndPoint();
		}
		int num = Mathf.FloorToInt(distance);
		if (LUTValues.Count > num)
		{
			int num2 = -1;
			while (num2 < 0 && (float)num > 0f)
			{
				LUTEntry lUTEntry = LUTValues[num];
				for (int i = 0; i < lUTEntry.points.Count && !(lUTEntry.points[i].distance > distance); i++)
				{
					num2 = i;
				}
				if (num2 < 0)
				{
					num--;
				}
			}
			float num3;
			Vector3 val;
			if (num2 < 0)
			{
				num3 = 0f;
				val = GetStartPoint();
			}
			else
			{
				LUTEntry.LUTPoint lUTPoint = LUTValues[num].points[num2];
				num3 = lUTPoint.distance;
				val = lUTPoint.pos;
			}
			num2 = -1;
			while (num2 < 0 && num < LUTValues.Count)
			{
				LUTEntry lUTEntry2 = LUTValues[num];
				for (int j = 0; j < lUTEntry2.points.Count; j++)
				{
					if (lUTEntry2.points[j].distance > distance)
					{
						num2 = j;
						break;
					}
				}
				if (num2 < 0)
				{
					num++;
				}
			}
			float num4;
			Vector3 val2;
			if (num2 < 0)
			{
				num4 = Length;
				val2 = GetEndPoint();
			}
			else
			{
				LUTEntry.LUTPoint lUTPoint2 = LUTValues[num].points[num2];
				num4 = lUTPoint2.distance;
				val2 = lUTPoint2.pos;
			}
			float num5 = Mathf.InverseLerp(num3, num4, distance);
			Vector3 val3 = val2 - val;
			tangent = ((Vector3)(ref val3)).normalized;
			return Vector3.Lerp(val, val2, num5);
		}
		tangent = GetEndTangent();
		return GetEndPoint();
	}

	public void SetDefaultTangents(WorldSpline worldSpline)
	{
		PathInterpolator pathInterpolator = new PathInterpolator(worldSpline.points, worldSpline.tangents);
		pathInterpolator.RecalculateTangents();
		worldSpline.tangents = pathInterpolator.Tangents;
	}

	public bool DetectSplineProblems(WorldSpline worldSpline)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		Vector3 val = GetTangentCubicHermite(0f);
		for (float num = 0.05f; num <= Length; num += 0.05f)
		{
			Vector3 tangentCubicHermite = GetTangentCubicHermite(num);
			float num2 = Vector3.Angle(tangentCubicHermite, val);
			if (num2 > 5f)
			{
				if ((Object)(object)worldSpline != (Object)null)
				{
					Vector3 tangent;
					Vector3 pointAndTangentCubicHermiteWorld = worldSpline.GetPointAndTangentCubicHermiteWorld(num, out tangent);
					Debug.DrawRay(pointAndTangentCubicHermiteWorld, tangent, Color.red, 30f);
					Debug.DrawRay(pointAndTangentCubicHermiteWorld, Vector3.up, Color.red, 30f);
				}
				Debug.Log((object)($"Spline may have a too-sharp bend at {num / Length:P0}. Angle change: " + num2));
				result = true;
			}
			val = tangentCubicHermite;
		}
		return result;
	}

	private void CreateLookupTable(WorldSpline worldSpline)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		PathInterpolator pathInterpolator = new PathInterpolator(worldSpline.points, worldSpline.tangents);
		Vector3 val = pathInterpolator.GetPointCubicHermite(0f);
		Length = 0f;
		AddEntry(0f, GetStartPoint());
		Vector3 pointCubicHermite;
		for (float num = worldSpline.lutInterval; num < pathInterpolator.Length; num += worldSpline.lutInterval)
		{
			pointCubicHermite = pathInterpolator.GetPointCubicHermite(num);
			Length += Vector3.Distance(pointCubicHermite, val);
			AddEntry(Length, pathInterpolator.GetPointCubicHermite(num));
			val = pointCubicHermite;
		}
		pointCubicHermite = GetEndPoint();
		Length += Vector3.Distance(pointCubicHermite, val);
		AddEntry(Length, pointCubicHermite);
	}

	private void AddEntry(float distance, Vector3 pos)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.FloorToInt(distance);
		if (LUTValues.Count < num + 1)
		{
			for (int i = LUTValues.Count; i < num + 1; i++)
			{
				LUTValues.Add(new LUTEntry());
			}
		}
		LUTValues[num].points.Add(new LUTEntry.LUTPoint(distance, pos));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class LUTEntry
{
	[Serializable]
	public struct LUTPoint
	{
		public float distance;

		public Vector3 pos;

		public LUTPoint(float distance, Vector3 pos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.distance = distance;
			this.pos = pos;
		}
	}

	public List<LUTPoint> points = new List<LUTPoint>();
}


using System;
using UnityEngine;

[Serializable]
public struct LUTPoint
{
	public float distance;

	public Vector3 pos;

	public LUTPoint(float distance, Vector3 pos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.distance = distance;
		this.pos = pos;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Vehicles/WorldSpline Shared Data", fileName = "WorldSpline Prefab Shared Data")]
public class WorldSplineSharedData : ScriptableObject
{
	[SerializeField]
	private List<WorldSplineData> dataList;

	public static WorldSplineSharedData _instance;

	private static readonly string[] worldSplineFolders = new string[2] { "Assets/Content/Structures", "Assets/bundled/Prefabs/autospawn" };

	public static WorldSplineSharedData instance
	{
		get
		{
			if ((Object)(object)_instance == (Object)null)
			{
				_instance = Resources.Load<WorldSplineSharedData>("WorldSpline Prefab Shared Data");
			}
			return _instance;
		}
	}

	public static bool TryGetDataFor(WorldSpline worldSpline, out WorldSplineData data)
	{
		if ((Object)(object)instance == (Object)null)
		{
			Debug.LogError((object)"No instance of WorldSplineSharedData found.");
			data = null;
			return false;
		}
		if (worldSpline.dataIndex < 0 || worldSpline.dataIndex >= instance.dataList.Count)
		{
			data = null;
			return false;
		}
		data = instance.dataList[worldSpline.dataIndex];
		return true;
	}
}


using System;
using UnityEngine;

public static class Ballistics
{
	private struct TheoreticalProjectile
	{
		public Vector3 pos;

		public Vector3 forward;

		public float gravity;

		public TheoreticalProjectile(Vector3 pos, Vector3 forward, float gravity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.pos = pos;
			this.forward = forward;
			this.gravity = gravity;
		}
	}

	public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, out float requiredGravity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetAimToTarget(origin, target, speed, maxAngle, idealGravity, 0f, out requiredGravity);
	}

	public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, float minRange, out float requiredGravity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		requiredGravity = idealGravity;
		Vector3 val = target - origin;
		float num = Vector3Ex.Magnitude2D(val);
		float y = val.y;
		float num2 = Mathf.Sqrt(speed * speed * speed * speed - requiredGravity * (requiredGravity * (num * num) + 2f * y * speed * speed));
		float num3 = Mathf.Atan((speed * speed + num2) / (requiredGravity * num)) * 57.29578f;
		float num4 = Mathf.Clamp(num3, 0f, 90f);
		if (float.IsNaN(num3))
		{
			num4 = 45f;
			requiredGravity = ProjectileDistToGravity(num, y, num4, speed);
		}
		else if (num3 > maxAngle)
		{
			num4 = maxAngle;
			requiredGravity = ProjectileDistToGravity(Mathf.Max(num, minRange), y, num4, speed);
		}
		((Vector3)(ref val)).Normalize();
		val.y = 0f;
		Vector3 val2 = Vector3.Cross(val, Vector3.up);
		val = Quaternion.AngleAxis(num4, val2) * val;
		return val;
	}

	public static bool TryGetPhysicsProjectileHitPos(Vector3 origin, Vector3 direction, float speed, float gravity, out Vector3 result, float flightTimePerUpwardCheck = 2f, float flightTimePerDownwardCheck = 0.66f, float maxRays = 128f, BaseNetworkable owner = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		TheoreticalProjectile projectile = new TheoreticalProjectile(origin, direction * speed, gravity);
		int num = 0;
		float dt = ((projectile.forward.y > 0f) ? flightTimePerUpwardCheck : flightTimePerDownwardCheck);
		while (!NextRayHitSomething(ref projectile, dt, owner) && (float)num < maxRays)
		{
			num++;
		}
		result = projectile.pos;
		return (float)num < maxRays;
	}

	public static Vector3 GetBulletHitPoint(Vector3 origin, Vector3 direction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return GetBulletHitPoint(new Ray(origin, direction));
	}

	public static Vector3 GetBulletHitPoint(Ray aimRay)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (GamePhysics.Trace(aimRay, 0f, out var hitInfo, 300f, 1220225809, (QueryTriggerInteraction)0))
		{
			return ((RaycastHit)(ref hitInfo)).point;
		}
		return ((Ray)(ref aimRay)).origin + ((Ray)(ref aimRay)).direction * 300f;
	}

	private static bool NextRayHitSomething(ref TheoreticalProjectile projectile, float dt, BaseNetworkable owner)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		float gravity = projectile.gravity;
		Vector3 pos = projectile.pos;
		float num = Vector3Ex.MagnitudeXZ(projectile.forward) * dt;
		float num2 = projectile.forward.y * dt + gravity * dt * dt * 0.5f;
		Vector2 val = Vector3Ex.XZ2D(projectile.forward);
		Vector2 val2 = ((Vector2)(ref val)).normalized * num;
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(val2.x, num2, val2.y);
		ref Vector3 pos2 = ref projectile.pos;
		pos2 += val3;
		float y = projectile.forward.y + gravity * dt;
		projectile.forward.y = y;
		RaycastHit hit = default(RaycastHit);
		if (Physics.Linecast(pos, projectile.pos, ref hit, 1084293393, (QueryTriggerInteraction)1))
		{
			projectile.pos = ((RaycastHit)(ref hit)).point;
			BaseEntity entity = hit.GetEntity();
			int num3;
			if ((Object)(object)entity != (Object)null)
			{
				num3 = (entity.EqualNetID(owner) ? 1 : 0);
				if (num3 != 0)
				{
					ref Vector3 pos3 = ref projectile.pos;
					pos3 += projectile.forward * 1f;
				}
			}
			else
			{
				num3 = 0;
			}
			return num3 == 0;
		}
		return false;
	}

	private static float ProjectileDistToGravity(float x, float y, float θ, float v)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		float num = θ * (MathF.PI / 180f);
		float num2 = (v * v * x * Mathf.Sin(2f * num) - 2f * v * v * y * Mathf.Cos(num) * Mathf.Cos(num)) / (x * x);
		if (float.IsNaN(num2) || num2 < 0.01f)
		{
			num2 = 0f - Physics.gravity.y;
		}
		return num2;
	}
}


using UnityEngine;

private struct TheoreticalProjectile
{
	public Vector3 pos;

	public Vector3 forward;

	public float gravity;

	public TheoreticalProjectile(Vector3 pos, Vector3 forward, float gravity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.pos = pos;
		this.forward = forward;
		this.gravity = gravity;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class Bezier
{
	public static void ApplyLineSlack(ref Vector3[] positions, float[] slackLevels, int tesselationLevel, Transform referenceTransform = null)
	{
		ApplyLineSlack(positions, slackLevels, ref positions, tesselationLevel, referenceTransform);
	}

	public static void ApplyLineSlack(Vector3[] positions, float[] slackLevels, ref Vector3[] result, int tesselationLevel, Transform referenceTransform = null)
	{
		List<Vector3> result2 = Pool.Get<List<Vector3>>();
		ApplyLineSlack(positions, slackLevels, ref result2, tesselationLevel, referenceTransform);
		if (result.Length >= 2 && result.Length != result2.Count)
		{
			result = (Vector3[])(object)new Vector3[result2.Count];
		}
		result2.CopyTo(result);
		Pool.FreeUnmanaged<Vector3>(ref result2);
	}

	public static int CalculateArraySize(int positionCount, int tesselationLevel)
	{
		return (positionCount - 1) * tesselationLevel + 2;
	}

	public static void ApplyLineSlack(Vector3[] positions, float[] slackLevels, ref List<Vector3> result, int tesselationLevel, Transform referenceTransform = null)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Length < 2 || slackLevels.Length == 0)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < slackLevels.Length; i++)
		{
			if (slackLevels[i] > 0f)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			result.AddRange(positions);
			return;
		}
		bool flag2 = (Object)(object)referenceTransform != (Object)null;
		float num = 1f / (float)tesselationLevel;
		for (int j = 0; j < positions.Length - 1; j++)
		{
			Vector3 val = positions[j];
			Vector3 val2 = positions[j + 1];
			if ((Object)(object)referenceTransform != (Object)null)
			{
				val = referenceTransform.TransformPoint(val);
				val2 = referenceTransform.TransformPoint(val2);
			}
			Vector3 val3 = Vector3.Lerp(val, val2, 0.5f);
			if (j < slackLevels.Length)
			{
				val3 += Vector3.down * slackLevels[j];
			}
			if (flag2)
			{
				result.Add(referenceTransform.InverseTransformPoint(val));
			}
			else
			{
				result.Add(val);
			}
			for (int k = 0; k < tesselationLevel; k++)
			{
				float num2 = (float)k * num;
				num2 = num2 * 0.8f + 0.1f;
				Vector3 val4 = Vector3.Lerp(val, val3, num2);
				Vector3 val5 = Vector3.Lerp(val3, val2, num2);
				Vector3 val6 = Vector3.Lerp(val4, val5, num2);
				if (flag2)
				{
					result.Add(referenceTransform.InverseTransformPoint(val6));
				}
				else
				{
					result.Add(val6);
				}
			}
		}
		Vector3 item = positions[^1];
		result.Add(item);
	}
}


using UnityEngine;

public struct FixedShort3
{
	private const int FracBits = 10;

	private const float MaxFrac = 1024f;

	private const float RcpMaxFrac = 0.0009765625f;

	public short x;

	public short y;

	public short z;

	public FixedShort3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		x = (short)(vec.x * 1024f);
		y = (short)(vec.y * 1024f);
		z = (short)(vec.z * 1024f);
	}

	public static explicit operator Vector3(FixedShort3 vec)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)vec.x * 0.0009765625f, (float)vec.y * 0.0009765625f, (float)vec.z * 0.0009765625f);
	}
}


using UnityEngine;

public struct FixedSByteNorm3
{
	private const int FracBits = 7;

	private const float MaxFrac = 128f;

	private const float RcpMaxFrac = 1f / 128f;

	public sbyte x;

	public sbyte y;

	public sbyte z;

	public FixedSByteNorm3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		x = (sbyte)(vec.x * 128f);
		y = (sbyte)(vec.y * 128f);
		z = (sbyte)(vec.z * 128f);
	}

	public static explicit operator Vector3(FixedSByteNorm3 vec)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)vec.x * (1f / 128f), (float)vec.y * (1f / 128f), (float)vec.z * (1f / 128f));
	}
}


using UnityEngine;

public struct FixedSByteNorm4
{
	private const int FracBits = 7;

	private const float MaxFrac = 128f;

	private const float RcpMaxFrac = 1f / 128f;

	public sbyte x;

	public sbyte y;

	public sbyte z;

	public sbyte w;

	public FixedSByteNorm4(Vector4 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		x = (sbyte)(vec.x * 128f);
		y = (sbyte)(vec.y * 128f);
		z = (sbyte)(vec.z * 128f);
		w = (sbyte)(vec.w * 128f);
	}

	public static explicit operator Vector4(FixedSByteNorm4 vec)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4((float)vec.x * (1f / 128f), (float)vec.y * (1f / 128f), (float)vec.z * (1f / 128f), (float)vec.w * (1f / 128f));
	}
}


using UnityEngine;

public struct Half3
{
	public ushort x;

	public ushort y;

	public ushort z;

	public Half3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		x = Mathf.FloatToHalf(vec.x);
		y = Mathf.FloatToHalf(vec.y);
		z = Mathf.FloatToHalf(vec.z);
	}

	public static explicit operator Vector3(Half3 vec)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Mathf.HalfToFloat(vec.x), Mathf.HalfToFloat(vec.y), Mathf.HalfToFloat(vec.z));
	}
}


using UnityEngine;

public struct Half4
{
	public ushort x;

	public ushort y;

	public ushort z;

	public ushort w;

	public Half4(Vector4 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		x = Mathf.FloatToHalf(vec.x);
		y = Mathf.FloatToHalf(vec.y);
		z = Mathf.FloatToHalf(vec.z);
		w = Mathf.FloatToHalf(vec.w);
	}

	public static explicit operator Vector4(Half4 vec)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4(Mathf.HalfToFloat(vec.x), Mathf.HalfToFloat(vec.y), Mathf.HalfToFloat(vec.z), Mathf.HalfToFloat(vec.w));
	}
}


using System.Collections.Concurrent;
using System.Collections.Generic;

public class ExactArrayPool<T>
{
	private readonly Dictionary<int, ConcurrentQueue<T[]>> _buffers = new Dictionary<int, ConcurrentQueue<T[]>>();

	public T[] Rent(int size)
	{
		if (!_buffers.TryGetValue(size, out var value))
		{
			value = new ConcurrentQueue<T[]>();
			_buffers[size] = value;
		}
		if (!value.TryDequeue(out var result))
		{
			return new T[size];
		}
		return result;
	}

	public void Return(T[] array)
	{
		if (!_buffers.TryGetValue(array.Length, out var value))
		{
			value = new ConcurrentQueue<T[]>();
			_buffers[array.Length] = value;
		}
		value.Enqueue(array);
	}
}


using System;
using System.Linq;
using ConVar;
using UnityEngine;

public class Poolable : MonoBehaviour, IClientComponent, IPrefabPostProcess
{
	[HideInInspector]
	public uint prefabID;

	[HideInInspector]
	public Behaviour[] behaviours;

	[HideInInspector]
	public Rigidbody[] rigidbodies;

	[HideInInspector]
	public Collider[] colliders;

	[HideInInspector]
	public LODGroup[] lodgroups;

	[HideInInspector]
	public Renderer[] renderers;

	[HideInInspector]
	public ParticleSystem[] particles;

	[HideInInspector]
	public bool[] behaviourStates;

	[HideInInspector]
	public bool[] rigidbodyStates;

	[HideInInspector]
	public bool[] colliderStates;

	[HideInInspector]
	public bool[] lodgroupStates;

	[HideInInspector]
	public bool[] rendererStates;

	public int ClientCount
	{
		get
		{
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<CodeLock>()))
			{
				return 200;
			}
			if ((Object)(object)((Component)this).GetComponent<LootPanel>() != (Object)null)
			{
				return 1;
			}
			if (((Component)this).GetComponent<DecorComponent>() != null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<BuildingBlock>() != (Object)null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<Door>() != (Object)null)
			{
				if ((bool)((Component)this).GetComponent<Construction>())
				{
					return 100;
				}
				return 1;
			}
			if ((Object)(object)((Component)this).GetComponent<Projectile>() != (Object)null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<Gib>() != (Object)null)
			{
				return 100;
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<UIMapVendingMachineMarker>()))
			{
				return 25;
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<UIMapVendingMachineMarkerCluster>()))
			{
				return 25;
			}
			if ((Object)(object)((Component)this).GetComponent<CollectableEasterEgg>() != (Object)null)
			{
				return 50;
			}
			return 1;
		}
	}

	public int ServerCount => 0;

	public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!bundling && !((Object)(object)((Component)this).gameObject != (Object)(object)rootObj))
		{
			Initialize(StringPool.Get(name));
		}
	}

	public void Initialize(uint id)
	{
		prefabID = id;
		behaviours = ((Component)this).gameObject.GetComponentsInChildren(typeof(Behaviour), true).OfType<Behaviour>().ToArray();
		rigidbodies = ((Component)this).gameObject.GetComponentsInChildren<Rigidbody>(true);
		colliders = ((Component)this).gameObject.GetComponentsInChildren<Collider>(true);
		lodgroups = ((Component)this).gameObject.GetComponentsInChildren<LODGroup>(true);
		renderers = ((Component)this).gameObject.GetComponentsInChildren<Renderer>(true);
		particles = ((Component)this).gameObject.GetComponentsInChildren<ParticleSystem>(true);
		if (behaviours.Length == 0)
		{
			behaviours = Array.Empty<Behaviour>();
		}
		if (rigidbodies.Length == 0)
		{
			rigidbodies = Array.Empty<Rigidbody>();
		}
		if (colliders.Length == 0)
		{
			colliders = Array.Empty<Collider>();
		}
		if (lodgroups.Length == 0)
		{
			lodgroups = Array.Empty<LODGroup>();
		}
		if (renderers.Length == 0)
		{
			renderers = Array.Empty<Renderer>();
		}
		if (particles.Length == 0)
		{
			particles = Array.Empty<ParticleSystem>();
		}
		behaviourStates = ArrayEx.New<bool>(behaviours.Length);
		rigidbodyStates = ArrayEx.New<bool>(rigidbodies.Length);
		colliderStates = ArrayEx.New<bool>(colliders.Length);
		lodgroupStates = ArrayEx.New<bool>(lodgroups.Length);
		rendererStates = ArrayEx.New<bool>(renderers.Length);
	}

	public void EnterPool()
	{
		if ((Object)(object)((Component)this).transform.parent != (Object)null)
		{
			((Component)this).transform.SetParent((Transform)null, false);
		}
		if (Pool.mode <= 1)
		{
			if (((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(false);
			}
			return;
		}
		SetBehaviourEnabled(state: false);
		SetComponentEnabled(state: false);
		if (!((Component)this).gameObject.activeSelf)
		{
			((Component)this).gameObject.SetActive(true);
		}
	}

	public void LeavePool()
	{
		if (Pool.mode > 1)
		{
			SetComponentEnabled(state: true);
		}
	}

	public void SetBehaviourEnabled(bool state)
	{
		try
		{
			if (!state)
			{
				for (int i = 0; i < behaviours.Length; i++)
				{
					Behaviour val = behaviours[i];
					behaviourStates[i] = val.enabled;
					val.enabled = false;
				}
				for (int j = 0; j < particles.Length; j++)
				{
					ParticleSystem obj = particles[j];
					obj.Stop();
					obj.Clear();
				}
				return;
			}
			for (int k = 0; k < particles.Length; k++)
			{
				ParticleSystem val2 = particles[k];
				if (val2.playOnAwake)
				{
					val2.Play();
				}
			}
			for (int l = 0; l < behaviours.Length; l++)
			{
				behaviours[l].enabled = behaviourStates[l];
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Pooling error: " + ((Object)this).name + " (" + ex.Message + ")"));
		}
	}

	public void SetComponentEnabled(bool state)
	{
		try
		{
			if (!state)
			{
				for (int i = 0; i < renderers.Length; i++)
				{
					Renderer val = renderers[i];
					rendererStates[i] = val.enabled;
					val.enabled = false;
				}
				for (int j = 0; j < lodgroups.Length; j++)
				{
					LODGroup val2 = lodgroups[j];
					lodgroupStates[j] = val2.enabled;
					val2.enabled = false;
				}
				for (int k = 0; k < colliders.Length; k++)
				{
					Collider val3 = colliders[k];
					colliderStates[k] = val3.enabled;
					val3.enabled = false;
				}
				for (int l = 0; l < rigidbodies.Length; l++)
				{
					Rigidbody val4 = rigidbodies[l];
					rigidbodyStates[l] = val4.isKinematic;
					val4.isKinematic = true;
					val4.detectCollisions = false;
				}
			}
			else
			{
				for (int m = 0; m < renderers.Length; m++)
				{
					renderers[m].enabled = rendererStates[m];
				}
				for (int n = 0; n < lodgroups.Length; n++)
				{
					lodgroups[n].enabled = lodgroupStates[n];
				}
				for (int num = 0; num < colliders.Length; num++)
				{
					colliders[num].enabled = colliderStates[num];
				}
				for (int num2 = 0; num2 < rigidbodies.Length; num2++)
				{
					Rigidbody obj = rigidbodies[num2];
					obj.isKinematic = rigidbodyStates[num2];
					obj.detectCollisions = true;
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Pooling error: " + ((Object)this).name + " (" + ex.Message + ")"));
		}
	}
}


using UnityEngine;

public static class PoolableEx
{
	public static bool SupportsPoolingInParent(this GameObject gameObject)
	{
		Poolable componentInParent = gameObject.GetComponentInParent<Poolable>();
		if ((Object)(object)componentInParent != (Object)null)
		{
			return componentInParent.prefabID != 0;
		}
		return false;
	}

	public static bool SupportsPooling(this GameObject gameObject)
	{
		Poolable component = gameObject.GetComponent<Poolable>();
		if ((Object)(object)component != (Object)null)
		{
			return component.prefabID != 0;
		}
		return false;
	}

	public static void AwakeFromInstantiate(this GameObject gameObject)
	{
		if (gameObject.activeSelf)
		{
			gameObject.GetComponent<Poolable>().SetBehaviourEnabled(state: true);
		}
		else
		{
			gameObject.SetActive(true);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class PrefabPool
{
	public Stack<Poolable> stack = new Stack<Poolable>();

	public string PrefabName { get; private set; }

	public int Missed { get; private set; }

	public int Pushed { get; private set; }

	public int Popped { get; private set; }

	public int Count => stack.Count;

	public int TargetCapacity { get; private set; }

	public PrefabPool(uint prefabId, int targetCapacity)
	{
		PrefabName = StringPool.Get(prefabId);
		TargetCapacity = targetCapacity;
	}

	public void Push(Poolable info)
	{
		Pushed++;
		stack.Push(info);
		info.EnterPool();
	}

	public void Push(GameObject instance)
	{
		Poolable component = instance.GetComponent<Poolable>();
		Push(component);
	}

	public GameObject Pop(Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		while (stack.Count > 0)
		{
			Poolable poolable = stack.Pop();
			Popped++;
			if (Object.op_Implicit((Object)(object)poolable))
			{
				((Component)poolable).transform.SetPositionAndRotation(pos, rot);
				poolable.LeavePool();
				return ((Component)poolable).gameObject;
			}
		}
		Missed++;
		return null;
	}

	public void Clear()
	{
		foreach (Poolable item in stack)
		{
			if (Object.op_Implicit((Object)(object)item))
			{
				Object.Destroy((Object)(object)((Component)item).gameObject);
			}
		}
		stack.Clear();
	}
}


using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

public class PrefabPoolCollection
{
	public Dictionary<uint, PrefabPool> storage = new Dictionary<uint, PrefabPool>();

	private bool isClient;

	public PrefabPoolCollection(bool client)
	{
		isClient = client;
	}

	public void Push(GameObject instance)
	{
		Poolable component = instance.GetComponent<Poolable>();
		if (!storage.TryGetValue(component.prefabID, out var value))
		{
			int targetCapacity = (isClient ? component.ClientCount : component.ServerCount);
			value = new PrefabPool(component.prefabID, targetCapacity);
			storage.Add(component.prefabID, value);
		}
		value.Push(component);
	}

	public GameObject Pop(uint id, Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (storage.TryGetValue(id, out var value))
		{
			return value.Pop(pos, rot);
		}
		return null;
	}

	public void Clear(string filter = null)
	{
		if (string.IsNullOrEmpty(filter))
		{
			foreach (KeyValuePair<uint, PrefabPool> item in storage)
			{
				item.Value.Clear();
			}
			return;
		}
		foreach (KeyValuePair<uint, PrefabPool> item2 in storage)
		{
			if (StringEx.Contains(StringPool.Get(item2.Key), filter, CompareOptions.IgnoreCase))
			{
				item2.Value.Clear();
			}
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Threading;
using ConVar;
using Rust;
using UnityEngine;

public class PrefabPoolWarmup
{
	public static void Run(string filter = null, int countOverride = 0)
	{
		if (Application.isLoadingPrefabs)
		{
			return;
		}
		Application.isLoadingPrefabs = true;
		string[] assetList = GetAssetList();
		if (string.IsNullOrEmpty(filter))
		{
			for (int i = 0; i < assetList.Length; i++)
			{
				PrefabWarmup(assetList[i], countOverride);
			}
		}
		else
		{
			foreach (string text in assetList)
			{
				if (StringEx.Contains(text, filter, CompareOptions.IgnoreCase))
				{
					PrefabWarmup(text, countOverride);
				}
			}
		}
		Application.isLoadingPrefabs = false;
	}

	public static IEnumerator Run(float deltaTime, Action<string> statusFunction = null, string format = null, CancellationToken ct = default(CancellationToken))
	{
		if (Application.isEditor || Application.isLoadingPrefabs || !Pool.prewarm)
		{
			yield break;
		}
		Application.isLoadingPrefabs = true;
		string[] prewarmAssets = GetAssetList();
		Timing timer = new Timing("prefab_warmup");
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < prewarmAssets.Length; i++)
		{
			if (ct.IsCancellationRequested)
			{
				Application.isLoadingPrefabs = false;
				yield break;
			}
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == prewarmAssets.Length - 1)
			{
				statusFunction?.Invoke(string.Format((format != null) ? format : "{0}/{1}", i + 1, prewarmAssets.Length));
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			PrefabWarmup(prewarmAssets[i]);
		}
		timer.End();
		Application.isLoadingPrefabs = false;
	}

	public static string[] GetAssetList()
	{
		return (from x in GameManifest.Current.prefabProperties
			where x.pool && FileSystem.HasAsset(x.name)
			select x.name).ToArray();
	}

	private static void PrefabWarmup(string path, int countOverride = 0)
	{
		if (string.IsNullOrEmpty(path))
		{
			return;
		}
		GameObject val = GameManager.server.FindPrefab(path);
		if ((Object)(object)val != (Object)null && val.SupportsPooling())
		{
			int num = val.GetComponent<Poolable>().ServerCount;
			List<GameObject> list = new List<GameObject>();
			if (num > 0 && countOverride > 0)
			{
				num = countOverride;
			}
			for (int i = 0; i < num; i++)
			{
				list.Add(GameManager.server.CreatePrefab(path));
			}
			for (int j = 0; j < num; j++)
			{
				GameManager.server.Retire(list[j]);
			}
		}
	}
}


using UnityEngine;

public static class PorabolaUtils
{
	public static Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t, bool useLevelDirection = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		float num = t * 2f - 1f;
		if (Mathf.Abs(start.y - end.y) < 0.1f)
		{
			Vector3 val = end - start;
			Vector3 result = start + t * val;
			result.y += ((0f - num) * num + 1f) * height;
			return result;
		}
		Vector3 val2 = end - start;
		Vector3 val3 = end - new Vector3(start.x, end.y, start.z);
		Vector3 val4 = Vector3.Cross(val2, val3);
		Vector3 val5 = ((!useLevelDirection) ? Vector3.Cross(val4, val2) : Vector3.Cross(val4, val3));
		if (end.y > start.y)
		{
			val5 = -val5;
		}
		return start + t * val2 + ((0f - num) * num + 1f) * height * ((Vector3)(ref val5)).normalized;
	}

	public static float FindT(Vector3 start, Vector3 end, float height, Vector3 targetPosition, bool useLevelDirection = false)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 0.01f;
		for (num = 0f; num <= 1f; num += num2)
		{
			if (Vector3.Distance(SampleParabola(start, end, height, num, useLevelDirection), targetPosition) < 0.01f)
			{
				return num;
			}
		}
		return -1f;
	}

	public static Vector3 RotateAroundWorldAxis(Vector3 point, Vector3 pivot, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = point - pivot;
		Vector3 val3 = val * val2;
		return pivot + val3;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct LayerSelect
{
	[SerializeField]
	private int layer;

	public int Mask => 1 << layer;

	public string Name => LayerMask.LayerToName(layer);

	public LayerSelect(int layer)
	{
		this.layer = layer;
	}

	public static implicit operator int(LayerSelect layer)
	{
		return layer.layer;
	}

	public static implicit operator LayerSelect(int layer)
	{
		return new LayerSelect(layer);
	}
}


using System;

public class NetworkedProperty<T> where T : IEquatable<T>
{
	private T val;

	private BaseEntity entity;

	public T Value
	{
		get
		{
			return val;
		}
		set
		{
			if (!val.Equals(value))
			{
				val = value;
				if (entity.isServer)
				{
					entity.SendNetworkUpdate();
				}
			}
		}
	}

	public NetworkedProperty(BaseEntity entity)
	{
		this.entity = entity;
	}

	public static implicit operator T(NetworkedProperty<T> value)
	{
		return value.Value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResettableFloat : ISerializationCallbackReceiver
{
	[SerializeField]
	private float defaultValue;

	[NonSerialized]
	private float currentValue;

	public float Value
	{
		get
		{
			return currentValue;
		}
		set
		{
			currentValue = value;
		}
	}

	public float DefaultValue => defaultValue;

	public ResettableFloat(float value)
	{
		defaultValue = value;
		currentValue = value;
	}

	public void OnBeforeSerialize()
	{
	}

	public void OnAfterDeserialize()
	{
		currentValue = defaultValue;
	}

	public void Reset()
	{
		currentValue = defaultValue;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BaseEntityRef : ResourceRef<BaseEntity>
{
	public override BaseEntity Get()
	{
		if ((Object)(object)_cachedObject != (Object)null)
		{
			return _cachedObject;
		}
		Object obj = GameManifest.GUIDToObject(guid);
		GameObject val = (GameObject)(object)((obj is GameObject) ? obj : null);
		BaseEntity baseEntity = null;
		if ((Object)(object)val != (Object)null && val.TryGetComponent<BaseEntity>(ref baseEntity))
		{
			_cachedObject = baseEntity;
		}
		return baseEntity;
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class GameObjectRef : ResourceRef<GameObject>
{
	public GameObject Instantiate(Transform parent = null)
	{
		return Instantiate.GameObject(Get(), parent);
	}

	public BaseEntity GetEntity()
	{
		GameObject val = Get();
		if (!((Object)(object)val == (Object)null))
		{
			return val.GetComponent<BaseEntity>();
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceRef<T> where T : Object
{
	public string guid;

	protected T _cachedObject;

	public bool isValid => !string.IsNullOrEmpty(guid);

	public string resourcePath => GameManifest.GUIDToPath(guid);

	public uint resourceID => StringPool.Get(resourcePath);

	public virtual T Get()
	{
		if ((Object)(object)_cachedObject == (Object)null)
		{
			ref T cachedObject = ref _cachedObject;
			Object obj = GameManifest.GUIDToObject(guid);
			cachedObject = (T)(object)((obj is T) ? obj : null);
		}
		return _cachedObject;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ScriptableObjectRef : ResourceRef<ScriptableObject>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2DRef : ResourceRef<Texture2D>
{
}


using UnityEngine;

public class RandomGameObject : MonoBehaviour
{
	public GameObject[] gameObjects;

	private void Awake()
	{
		EnableRandomObject();
	}

	private void EnableRandomObject()
	{
		if (gameObjects.Length != 0)
		{
			GameObject[] array = gameObjects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(false);
			}
			gameObjects.GetRandom().SetActive(true);
		}
	}
}


using UnityEngine;

public class RandomScale : MonoBehaviour
{
	[SerializeField]
	private bool multiplyByExistingScale = true;

	[SerializeField]
	private Vector3 minScale = Vector3.one * 0.8f;

	[SerializeField]
	private Vector3 maxScale = Vector3.one * 1.2f;

	private void Awake()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (multiplyByExistingScale)
		{
			Transform transform = ((Component)this).transform;
			transform.localScale *= Random.Range(minScale.x, maxScale.x);
		}
		else
		{
			((Component)this).transform.localScale = Vector3.one * Random.Range(minScale.x, maxScale.x);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using UnityEngine;

[Factory("log")]
public class RustLog : ConsoleSystem
{
	public enum EntryType
	{
		General,
		Network,
		Hierarchy,
		Serialization,
		Combat,
		Item,
		Audio
	}

	private static readonly string[] names = Enum.GetNames(typeof(EntryType));

	public static readonly int[] Levels = new int[names.Length];

	[ClientVar]
	[ServerVar]
	public static void Level(Arg args)
	{
		if (args.Args.Length == 0 || args.Args.Length > 2)
		{
			return;
		}
		string @string = args.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			return;
		}
		for (int i = 0; i < names.Length; i++)
		{
			string text = names[i];
			if (!(@string != text))
			{
				if (args.Args.Length == 2)
				{
					Levels[i] = args.GetInt(1, Levels[i]);
				}
				else
				{
					Debug.Log((object)GetLevel((EntryType)i));
				}
				break;
			}
		}
	}

	public static int GetLevel(EntryType type)
	{
		return Levels[(int)type];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log(EntryType type, int level, GameObject gameObject, string msg)
	{
		if (GetLevel(type) >= level)
		{
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3, T4>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3, arg4);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3, T4, T5>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3, arg4, arg5);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void LogImpl(EntryType type, string msg, GameObject gameObject)
	{
		Debug.Log((object)$"<color=white>[{type}]</color> {msg}", (Object)(object)gameObject);
	}
}


public enum EntryType
{
	General,
	Network,
	Hierarchy,
	Serialization,
	Combat,
	Item,
	Audio
}


using UnityEngine;

public class AlternateAttack : StateMachineBehaviour
{
	public bool random;

	public bool dontIncrement;

	public string[] targetTransitions;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (random)
		{
			string text = targetTransitions[Random.Range(0, targetTransitions.Length)];
			animator.Play(text, layerIndex, 0f);
			return;
		}
		int integer = animator.GetInteger("lastAttack");
		string text2 = targetTransitions[integer % targetTransitions.Length];
		animator.Play(text2, layerIndex, 0f);
		if (!dontIncrement)
		{
			animator.SetInteger("lastAttack", integer + 1);
		}
	}
}


using System.Collections.Generic;
using Rust.Workshop;
using UnityEngine;

public class BaseViewModel : FacepunchBehaviour, IPrefabPreProcess, IViewmodelWorkshopPreview, IWorkshopPreview
{
	public enum ViewmodelType
	{
		Regular,
		Gesture,
		Shield
	}

	[Header("BaseViewModel")]
	public LazyAimProperties lazyaimRegular;

	public LazyAimProperties lazyaimIronsights;

	public Transform pivot;

	public bool useViewModelCamera = true;

	public bool wantsHeldItemFlags;

	public GameObject[] hideSightMeshes;

	public ViewmodelType viewmodelType;

	public Transform MuzzlePoint;

	[Header("Skin")]
	public SubsurfaceProfile subsurfaceProfile;

	[HideInInspector]
	public List<SkinnedMeshRenderer> baseSkinPieces = new List<SkinnedMeshRenderer>();

	[Header("Shield Overrides")]
	public AnimationCurve leftArmShieldHideCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


public enum ViewmodelType
{
	Regular,
	Gesture,
	Shield
}


public interface IViewmodelComponent
{
}


using UnityEngine;

public class BinocularViewmodel : MonoBehaviour, IViewmodelComponent
{
}


using UnityEngine;

public class BlunderbussViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;

	public float ShotsLeftSpeed = 1f;

	public int HammerLayer = 1;
}


using UnityEngine;

public class CompassViewmodel : MonoBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	[SerializeField]
	private Transform needleBone;
}


using System;
using UnityEngine;

public class FishingRodViewmodel : MonoBehaviour
{
	[Serializable]
	public struct FishViewmodel
	{
		public ItemDefinition Item;

		public GameObject Root;
	}

	public Transform PitchTransform;

	public Transform YawTransform;

	public float YawLerpSpeed = 1f;

	public float PitchLerpSpeed = 1f;

	public Transform LineRendererStartPos;

	public ParticleSystem[] StrainParticles;

	public bool ApplyTransformRotation = true;

	public GameObject CatchRoot;

	public Transform CatchLinePoint;

	public FishViewmodel[] FishViewmodels;

	public float ShakeMaxScale = 0.1f;
}


using System;
using UnityEngine;

[Serializable]
public struct FishViewmodel
{
	public ItemDefinition Item;

	public GameObject Root;
}


public enum flamethrowerState
{
	OFF,
	PILOT_LIGHT,
	FLAME_ON
}


using UnityEngine;

public class flamethrowerFire : MonoBehaviour
{
	public ParticleSystem pilotLightFX;

	public ParticleSystem[] flameFX;

	public FlameJet jet;

	public AudioSource oneShotSound;

	public AudioSource loopSound;

	public AudioClip pilotlightIdle;

	public AudioClip flameLoop;

	public AudioClip flameStart;

	public flamethrowerState flameState;

	private flamethrowerState previousflameState;

	public void PilotLightOn()
	{
		pilotLightFX.enableEmission = true;
		SetFlameStatus(status: false);
	}

	public void SetFlameStatus(bool status)
	{
		ParticleSystem[] array = flameFX;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enableEmission = status;
		}
	}

	public void ShutOff()
	{
		pilotLightFX.enableEmission = false;
		SetFlameStatus(status: false);
	}

	public void FlameOn()
	{
		pilotLightFX.enableEmission = false;
		SetFlameStatus(status: true);
	}

	private void Start()
	{
		previousflameState = (flameState = flamethrowerState.OFF);
		ShutOff();
	}

	private void Update()
	{
		if (previousflameState != flameState)
		{
			switch (flameState)
			{
			case flamethrowerState.OFF:
				ShutOff();
				break;
			case flamethrowerState.PILOT_LIGHT:
				PilotLightOn();
				break;
			case flamethrowerState.FLAME_ON:
				FlameOn();
				break;
			}
			previousflameState = flameState;
			jet.SetOn(flameState == flamethrowerState.FLAME_ON);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class FoodViewModel : BaseViewModel
{
	[Serializable]
	public class FoodVisualConfig
	{
		public List<FoodVisualObject> VisualItems = new List<FoodVisualObject>();

		public string TintMaterialProperty;

		private MaterialPropertyBlock materialPB;

		private int detailAlbedo;

		public void InitForItem(Item item)
		{
			if (item != null && !((Object)(object)item.info == (Object)null))
			{
				InitForItemDef(item.info);
			}
		}

		public void InitForItemDef(ItemDefinition itemDef)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Expected O, but got Unknown
			if ((Object)(object)itemDef == (Object)null)
			{
				return;
			}
			if (materialPB == null)
			{
				materialPB = new MaterialPropertyBlock();
				detailAlbedo = Shader.PropertyToID(TintMaterialProperty);
			}
			FoodVisualObject foodVisualObject = null;
			foreach (FoodVisualObject visualItem in VisualItems)
			{
				if (visualItem != null)
				{
					visualItem.SetVisible(flag: false);
					if ((Object)(object)visualItem.ItemDef == (Object)(object)itemDef)
					{
						foodVisualObject = visualItem;
					}
				}
			}
			if (foodVisualObject != null)
			{
				foodVisualObject.SetVisible(flag: true);
				foodVisualObject.ApplyTint(materialPB, detailAlbedo);
			}
		}

		public void HideAll()
		{
			foreach (FoodVisualObject visualItem in VisualItems)
			{
				visualItem?.SetVisible(flag: false);
			}
		}
	}

	[Serializable]
	public class FoodVisualObject
	{
		public ItemDefinition ItemDef;

		public List<GameObject> GameObjects;

		public SkinnedMeshRenderer TintSkinnedRenderer;

		public List<MeshRenderer> TintRenderers;

		public Color ColorTint;

		public void SetVisible(bool flag)
		{
			if (GameObjects == null)
			{
				return;
			}
			foreach (GameObject gameObject in GameObjects)
			{
				gameObject.SetActive(flag);
			}
		}

		public void ApplyTint(MaterialPropertyBlock mpb, int matPropertyName)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (mpb == null || ((Object)(object)TintSkinnedRenderer == (Object)null && TintRenderers == null) || matPropertyName == 0)
			{
				return;
			}
			mpb.SetColor(matPropertyName, ColorTint);
			if ((Object)(object)TintSkinnedRenderer != (Object)null)
			{
				((Renderer)TintSkinnedRenderer).SetPropertyBlock(mpb, 0);
			}
			if (TintRenderers == null)
			{
				return;
			}
			foreach (MeshRenderer tintRenderer in TintRenderers)
			{
				if (!((Object)(object)tintRenderer == (Object)null))
				{
					((Renderer)tintRenderer).SetPropertyBlock(mpb, 0);
				}
			}
		}
	}

	public List<GameObject> VisualRoots;

	public FoodVisualConfig VisualConfig;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FoodVisualConfig
{
	public List<FoodVisualObject> VisualItems = new List<FoodVisualObject>();

	public string TintMaterialProperty;

	private MaterialPropertyBlock materialPB;

	private int detailAlbedo;

	public void InitForItem(Item item)
	{
		if (item != null && !((Object)(object)item.info == (Object)null))
		{
			InitForItemDef(item.info);
		}
	}

	public void InitForItemDef(ItemDefinition itemDef)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if ((Object)(object)itemDef == (Object)null)
		{
			return;
		}
		if (materialPB == null)
		{
			materialPB = new MaterialPropertyBlock();
			detailAlbedo = Shader.PropertyToID(TintMaterialProperty);
		}
		FoodVisualObject foodVisualObject = null;
		foreach (FoodVisualObject visualItem in VisualItems)
		{
			if (visualItem != null)
			{
				visualItem.SetVisible(flag: false);
				if ((Object)(object)visualItem.ItemDef == (Object)(object)itemDef)
				{
					foodVisualObject = visualItem;
				}
			}
		}
		if (foodVisualObject != null)
		{
			foodVisualObject.SetVisible(flag: true);
			foodVisualObject.ApplyTint(materialPB, detailAlbedo);
		}
	}

	public void HideAll()
	{
		foreach (FoodVisualObject visualItem in VisualItems)
		{
			visualItem?.SetVisible(flag: false);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FoodVisualObject
{
	public ItemDefinition ItemDef;

	public List<GameObject> GameObjects;

	public SkinnedMeshRenderer TintSkinnedRenderer;

	public List<MeshRenderer> TintRenderers;

	public Color ColorTint;

	public void SetVisible(bool flag)
	{
		if (GameObjects == null)
		{
			return;
		}
		foreach (GameObject gameObject in GameObjects)
		{
			gameObject.SetActive(flag);
		}
	}

	public void ApplyTint(MaterialPropertyBlock mpb, int matPropertyName)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (mpb == null || ((Object)(object)TintSkinnedRenderer == (Object)null && TintRenderers == null) || matPropertyName == 0)
		{
			return;
		}
		mpb.SetColor(matPropertyName, ColorTint);
		if ((Object)(object)TintSkinnedRenderer != (Object)null)
		{
			((Renderer)TintSkinnedRenderer).SetPropertyBlock(mpb, 0);
		}
		if (TintRenderers == null)
		{
			return;
		}
		foreach (MeshRenderer tintRenderer in TintRenderers)
		{
			if (!((Object)(object)tintRenderer == (Object)null))
			{
				((Renderer)tintRenderer).SetPropertyBlock(mpb, 0);
			}
		}
	}
}


using UnityEngine;

public class GrenadeViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;
}


using UnityEngine;

public class HandcuffsViewModel : BaseViewModel
{
	public SkinnedMeshRenderer handcuffsRenderer;
}


using UnityEngine;

public class IronsightAimPoint : MonoBehaviour
{
	public Transform targetPoint;

	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.cyan;
		Vector3 val = targetPoint.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Gizmos.color = Color.red;
		DrawArrow(((Component)this).transform.position, ((Component)this).transform.position + normalized * 0.1f, 0.1f);
		Gizmos.color = Color.cyan;
		DrawArrow(((Component)this).transform.position, targetPoint.position, 0.02f);
		Gizmos.color = Color.yellow;
		DrawArrow(targetPoint.position, targetPoint.position + normalized * 3f, 0.02f);
	}

	private void DrawArrow(Vector3 start, Vector3 end, float arrowLength)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = end - start;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 up = ((Component)Camera.current).transform.up;
		Gizmos.DrawLine(start, end);
		Gizmos.DrawLine(end, end + up * arrowLength - normalized * arrowLength);
		Gizmos.DrawLine(end, end - up * arrowLength - normalized * arrowLength);
		Gizmos.DrawLine(end + up * arrowLength - normalized * arrowLength, end - up * arrowLength - normalized * arrowLength);
	}
}


using UnityEngine;

public class IronSightOverride : MonoBehaviour
{
	public IronsightAimPoint aimPoint;

	public float fieldOfViewOffset = -20f;

	public float zoomFactor = -1f;

	[Tooltip("If set to 1, the FOV is set to what this override is set to. If set to 0.5 it's half way between the weapon iconsights default and this scope.")]
	public float fovBias = 0.5f;
}


using UnityEngine;

public class IronSights : MonoBehaviour
{
	[Header("View Setup")]
	public IronsightAimPoint aimPoint;

	public float fieldOfViewOffset = -20f;

	public float zoomFactor = 1f;

	[Header("Animation")]
	public float introSpeed = 1f;

	public AnimationCurve introCurve = new AnimationCurve();

	public float outroSpeed = 1f;

	public AnimationCurve outroCurve = new AnimationCurve();

	[Tooltip("Force the ironsight rotation every frame, don't lerp to the rotation. Can be useful if the ADS is animated and this component is conflicting")]
	public bool disableLerps;

	[Header("Sounds")]
	public SoundDefinition upSound;

	public SoundDefinition downSound;

	[Header("Info")]
	public IronSightOverride ironsightsOverride;

	public bool processUltrawideOffset;
}


using UnityEngine;

public class MagazineStateViewmodel : MonoBehaviour, IClientComponent, IViewmodelComponent, IAnimationEventReceiver
{
	public Animator TargetAnimator;

	[Tooltip("This gameobject will be toggled active if the gun has > 1 bullet")]
	public GameObject ShellRoot;

	[Tooltip("Will set layer 1 to full weight if the gun has no ammo")]
	public bool EmptyAmmoLayer;

	[Tooltip("Will update a parameter called 'hasAmmo' on the vm animator")]
	public bool SetHasAmmoParam;
}


using UnityEngine;

public class MetalDetectorViewmodel : BaseViewModel
{
	public GameObject[] LongRangeLights;

	public GameObject[] SweetspotLights;

	public GameObject LongRangeLight;

	public Transform YawTransform;

	public Transform DetectPos;

	public MetalDetectorViewmodelAnimEvents viewmodelAnimEvents;

	public SkinnedMeshRenderer MeshRenderer;

	[ColorUsage(false, true)]
	public Color BulbOffColor;

	[ColorUsage(false, true)]
	public Color BulbOnColor;
}


public class MetalDetectorViewmodelAnimEvents : BaseMonoBehaviour
{
	public float scanAmount = 1f;

	public SoundDefinition scanSwingSoundDef;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MultiSwapArrows : MonoBehaviour, IClientComponent
{
	public List<SwapArrows> arrowSlots;

	public void UpdateAmmoType(ItemDefinition ammoType, bool hidden = false, int? slotIndex = null)
	{
		if (slotIndex.HasValue)
		{
			int value = slotIndex.Value;
			if (value >= 0 && value < arrowSlots.Count)
			{
				if ((Object)(object)arrowSlots[value] != (Object)null)
				{
					arrowSlots[value].UpdateAmmoType(ammoType, hidden);
				}
			}
			else
			{
				Debug.Log((object)"Error in MultiSwapArrows: Slot index out of range");
			}
			return;
		}
		int num = 0;
		foreach (SwapArrows arrowSlot in arrowSlots)
		{
			if ((Object)(object)arrowSlot != (Object)null)
			{
				arrowSlot.UpdateAmmoType(ammoType, hidden);
			}
			num++;
		}
	}

	private void Cleanup()
	{
		foreach (SwapArrows arrowSlot in arrowSlots)
		{
			if ((Object)(object)arrowSlot != (Object)null)
			{
				arrowSlot.HideAllArrowHeads();
			}
		}
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}

	public void OnEnable()
	{
		Cleanup();
	}
}


using UnityEngine;

public class RagdollEditor : SingletonComponent<RagdollEditor>
{
	private Vector3 view;

	private Rigidbody grabbedRigid;

	private Vector3 grabPos;

	private Vector3 grabOffset;

	private void OnGUI()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		GUI.Box(new Rect((float)Screen.width * 0.5f - 2f, (float)Screen.height * 0.5f - 2f, 4f, 4f), "");
	}

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
	}

	private void Update()
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		Camera.main.fieldOfView = 75f;
		if (Input.GetKey((KeyCode)324))
		{
			view.y += Input.GetAxisRaw("Mouse X") * 3f;
			view.x -= Input.GetAxisRaw("Mouse Y") * 3f;
			Cursor.lockState = (CursorLockMode)1;
			Cursor.visible = false;
		}
		else
		{
			Cursor.lockState = (CursorLockMode)0;
			Cursor.visible = true;
		}
		((Component)Camera.main).transform.rotation = Quaternion.Euler(view);
		Vector3 val = Vector3.zero;
		if (Input.GetKey((KeyCode)119))
		{
			val += Vector3.forward;
		}
		if (Input.GetKey((KeyCode)115))
		{
			val += Vector3.back;
		}
		if (Input.GetKey((KeyCode)97))
		{
			val += Vector3.left;
		}
		if (Input.GetKey((KeyCode)100))
		{
			val += Vector3.right;
		}
		Transform transform = ((Component)Camera.main).transform;
		transform.position += ((Component)this).transform.rotation * val * 0.05f;
		if (Input.GetKeyDown((KeyCode)323))
		{
			StartGrab();
		}
		if (Input.GetKeyUp((KeyCode)323))
		{
			StopGrab();
		}
	}

	private void FixedUpdate()
	{
		if (Input.GetKey((KeyCode)323))
		{
			UpdateGrab();
		}
	}

	private void StartGrab()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position, ((Component)this).transform.forward, ref val, 100f))
		{
			grabbedRigid = ((Component)((RaycastHit)(ref val)).collider).GetComponent<Rigidbody>();
			if (!((Object)(object)grabbedRigid == (Object)null))
			{
				Matrix4x4 worldToLocalMatrix = ((Component)grabbedRigid).transform.worldToLocalMatrix;
				grabPos = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint(((RaycastHit)(ref val)).point);
				worldToLocalMatrix = ((Component)this).transform.worldToLocalMatrix;
				grabOffset = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint(((RaycastHit)(ref val)).point);
			}
		}
	}

	private void UpdateGrab()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)grabbedRigid == (Object)null))
		{
			Vector3 val = ((Component)this).transform.TransformPoint(grabOffset);
			Vector3 val2 = ((Component)grabbedRigid).transform.TransformPoint(grabPos);
			Vector3 val3 = val - val2;
			grabbedRigid.AddForceAtPosition(val3 * 100f, val2, (ForceMode)5);
		}
	}

	private void StopGrab()
	{
		grabbedRigid = null;
	}
}


using UnityEngine;

public class RandomParameterNumber : StateMachineBehaviour
{
	public string parameterName;

	public int min;

	public int max;

	public bool preventRepetition;

	public bool isFloat;

	private int last;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		int num = Random.Range(min, max);
		int num2 = 0;
		while (last == num && preventRepetition && num2 < 100)
		{
			num = Random.Range(min, max);
			num2++;
		}
		if (isFloat)
		{
			animator.SetFloat(parameterName, (float)num);
		}
		else
		{
			animator.SetInteger(parameterName, num);
		}
		last = num;
	}
}


using UnityEngine;

public class RandomParameterNumberFloat : StateMachineBehaviour
{
	public string parameterName;

	public int min;

	public int max;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!string.IsNullOrEmpty(parameterName))
		{
			animator.SetFloat(parameterName, Mathf.Floor(Random.Range((float)min, (float)max + 0.5f)));
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Animations;

public class SetParameterAnimatorBehaviour : StateMachineBehaviour
{
	public enum ParamType
	{
		Float,
		Bool,
		Int
	}

	public enum Timing
	{
		OnStateEnter,
		OnStateExit,
		PassThreshold
	}

	public string ParameterName;

	public ParamType ParameterType;

	public float FloatValue;

	public bool BoolValue;

	public int IntValue;

	public Timing SetParameterTiming;

	[Range(0f, 1f)]
	[Tooltip("Normalised time of animation")]
	public float ThresholdTiming;

	private float lastNormalisedTime;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		if (SetParameterTiming == Timing.OnStateEnter)
		{
			SetParameter(animator);
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex, controller);
		if (SetParameterTiming == Timing.OnStateExit)
		{
			SetParameter(animator);
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		if (SetParameterTiming == Timing.PassThreshold)
		{
			if (((AnimatorStateInfo)(ref stateInfo)).normalizedTime > ThresholdTiming && lastNormalisedTime < ThresholdTiming)
			{
				SetParameter(animator);
			}
			lastNormalisedTime = ((AnimatorStateInfo)(ref stateInfo)).normalizedTime;
		}
	}

	private void SetParameter(Animator animator)
	{
		switch (ParameterType)
		{
		case ParamType.Float:
			animator.SetFloat(ParameterName, FloatValue);
			break;
		case ParamType.Bool:
			animator.SetBool(ParameterName, BoolValue);
			break;
		case ParamType.Int:
			animator.SetInteger(ParameterName, IntValue);
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}
}


public enum ParamType
{
	Float,
	Bool,
	Int
}


public enum Timing
{
	OnStateEnter,
	OnStateExit,
	PassThreshold
}


using UnityEngine;

public class SetParameterCurveAnimatorBehaviour : StateMachineBehaviour
{
	public string FloatParameterName;

	public AnimationCurve ParameterCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		animator.SetFloat(FloatParameterName, ParameterCurve.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime));
	}
}


using System;
using UnityEngine;

public class SwapAmmo : MonoBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	[Serializable]
	public class AmmoSetup
	{
		public ItemDefinition TargetAmmo;

		public GameObject[] Roots;
	}

	public AmmoSetup[] Setups;

	public bool EventDriven;
}


using System;
using UnityEngine;

[Serializable]
public class AmmoSetup
{
	public ItemDefinition TargetAmmo;

	public GameObject[] Roots;
}


using System;
using Rust;
using UnityEngine;

public class SwapArrows : MonoBehaviour, IClientComponent
{
	public enum ArrowType
	{
		One,
		Two,
		Three,
		Four
	}

	public GameObject[] arrowModels;

	[NonSerialized]
	private ItemDefinition curAmmoType;

	private bool wasHidden;

	public ItemDefinition CurrentAmmoType
	{
		get
		{
			return curAmmoType;
		}
		set
		{
			curAmmoType = value;
		}
	}

	public bool WasHidden
	{
		get
		{
			return wasHidden;
		}
		set
		{
			wasHidden = value;
		}
	}

	public void SelectArrowType(int iType)
	{
		HideAllArrowHeads();
		if (iType < arrowModels.Length)
		{
			arrowModels[iType].SetActive(true);
		}
	}

	public void HideAllArrowHeads()
	{
		GameObject[] array = arrowModels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
	}

	public void UpdateAmmoType(ItemDefinition ammoType, bool hidden = false)
	{
		if (hidden)
		{
			wasHidden = hidden;
			HideAllArrowHeads();
		}
		else if (!((Object)(object)curAmmoType == (Object)(object)ammoType) || hidden != wasHidden)
		{
			curAmmoType = ammoType;
			wasHidden = hidden;
			if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.WoodenArrowItemDef)
			{
				HideAllArrowHeads();
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.BoneArrowItemDef)
			{
				SelectArrowType(0);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.FireArrowItemDef)
			{
				SelectArrowType(1);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.HvArrowItemDef)
			{
				SelectArrowType(2);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.PoisonArrowItemDef)
			{
				SelectArrowType(3);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.StoneArrowItemDef)
			{
				SelectArrowType(4);
			}
			else
			{
				HideAllArrowHeads();
			}
		}
	}

	private void Cleanup()
	{
		HideAllArrowHeads();
		curAmmoType = null;
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}

	public void OnEnable()
	{
		Cleanup();
	}
}


public enum ArrowType
{
	One,
	Two,
	Three,
	Four
}


using UnityEngine;

public class SwapKeycard : MonoBehaviour
{
	public GameObject[] accessLevels;

	public void UpdateAccessLevel(int level)
	{
		GameObject[] array = accessLevels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
		if (level > 0 && accessLevels.Length >= level)
		{
			accessLevels[level - 1].SetActive(true);
		}
	}

	public void SetRootActive(int index)
	{
		for (int i = 0; i < accessLevels.Length; i++)
		{
			accessLevels[i].SetActive(i == index);
		}
	}
}


using System;
using UnityEngine;

public class SwapRPG : MonoBehaviour
{
	public enum RPGType
	{
		One,
		Two,
		Three,
		Four
	}

	public GameObject[] rpgModels;

	[NonSerialized]
	private string curAmmoType = "";

	public void SelectRPGType(int iType)
	{
		GameObject[] array = rpgModels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
		rpgModels[iType].SetActive(true);
	}

	public void UpdateAmmoType(ItemDefinition ammoType)
	{
		if (!(curAmmoType == ammoType.shortname))
		{
			curAmmoType = ammoType.shortname;
			switch (curAmmoType)
			{
			default:
				SelectRPGType(0);
				break;
			case "ammo.rocket.fire":
				SelectRPGType(1);
				break;
			case "ammo.rocket.hv":
				SelectRPGType(2);
				break;
			case "ammo.rocket.smoke":
				SelectRPGType(3);
				break;
			}
		}
	}

	private void Start()
	{
	}
}


public enum RPGType
{
	One,
	Two,
	Three,
	Four
}


using UnityEngine;

public class ViewmodelAspectOffset : MonoBehaviour
{
	public Vector3 OffsetAmount = Vector3.zero;

	[Tooltip("What aspect ratio should we start moving the viewmodel? 16:9 = 1.7, 21:9 = 2.3")]
	public float aspectCutoff = 2f;
}


public class ViewmodelAttachment : EntityComponent<BaseEntity>, IClientComponent, IViewModeChanged, IViewModelUpdated
{
	public enum AttachmentType
	{
		None,
		Scope8x,
		SmallScope,
		BurstModule,
		ExtendedMags,
		Flashlight,
		Holosight,
		LaserSight,
		MuzzleBoost,
		MuzzleBrake,
		RedDotSight,
		Silencer
	}

	public GameObjectRef modelObject;

	public string targetBone;

	public bool hideViewModelIronSights;

	public AttachmentType attachmentType;
}


public enum AttachmentType
{
	None,
	Scope8x,
	SmallScope,
	BurstModule,
	ExtendedMags,
	Flashlight,
	Holosight,
	LaserSight,
	MuzzleBoost,
	MuzzleBrake,
	RedDotSight,
	Silencer
}


using System;
using UnityEngine;

public class ViewmodelAttachmentOverride : MonoBehaviour
{
	[Serializable]
	public struct Override
	{
		public Transform TargetRoot;

		public ViewmodelAttachment.AttachmentType ForAttachment;

		public GameObjectRef ForAttachmentObject;
	}

	public Override[] Overrides;
}


using System;
using UnityEngine;

[Serializable]
public struct Override
{
	public Transform TargetRoot;

	public ViewmodelAttachment.AttachmentType ForAttachment;

	public GameObjectRef ForAttachmentObject;
}


using UnityEngine;

public class ViewmodelBob : MonoBehaviour
{
	public float bobSpeedWalk = 9f;

	public float bobSpeedRun = 13f;

	public float bobAmountWalk = 0.005f;

	public float bobAmountRun = 0.02f;

	public float leftOffsetRun = 0.04f;
}


using UnityEngine;

public class ViewModelCamera : MonoBehaviour
{
}


public enum RenderType
{
	OPAQUE_DEFERRED,
	OPAQUE_FORWARDBASE,
	TRANSPARENT_FORWARDBASE,
	TRANSPARENT,
	UNDEFINED
}


using System;
using UnityEngine;

[Serializable]
public struct ViewModelDrawEvent : IEquatable<ViewModelDrawEvent>
{
	public ViewModelRenderer viewModelRenderer;

	public Renderer renderer;

	public bool skipDepthPrePass;

	public Material material;

	public int subMesh;

	public int pass;

	public bool Equals(ViewModelDrawEvent other)
	{
		if (object.Equals(viewModelRenderer, other.viewModelRenderer) && object.Equals(renderer, other.renderer) && skipDepthPrePass == other.skipDepthPrePass && object.Equals(material, other.material) && subMesh == other.subMesh)
		{
			return pass == other.pass;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ViewModelDrawEvent other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((((((((((((Object)(object)viewModelRenderer != (Object)null) ? ((object)viewModelRenderer).GetHashCode() : 0) * 397) ^ (((Object)(object)renderer != (Object)null) ? ((object)renderer).GetHashCode() : 0)) * 397) ^ skipDepthPrePass.GetHashCode()) * 397) ^ (((Object)(object)material != (Object)null) ? ((object)material).GetHashCode() : 0)) * 397) ^ subMesh) * 397) ^ pass;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ViewModelRenderer : MonoBehaviour
{
	public List<Texture2D> cachedTextureRefs = new List<Texture2D>();

	public List<ViewModelDrawEvent> opaqueEvents = new List<ViewModelDrawEvent>();

	public List<ViewModelDrawEvent> transparentEvents = new List<ViewModelDrawEvent>();

	public Matrix4x4 prevModelMatrix;

	private Renderer viewModelRenderer;
}


using UnityEngine;

public class ViewmodelCameraAnimation : MonoBehaviour
{
	public Transform CameraModifyBone;

	public bool ShouldSuppressLeftHandScreenShake;

	public float FadeInTime;

	public Vector3 PositionOffset;

	public Vector3 RotationOffset;

	public Animator CameraAnimator;
}


using UnityEngine;

public class ViewmodelCameraAnimationSync : StateMachineBehaviour
{
}


public class ViewmodelEditor : SingletonComponent<ViewmodelEditor>
{
}


using UnityEngine;

public class ViewmodelIk : MonoBehaviour
{
}


using UnityEngine;

public class ViewmodelLower : MonoBehaviour
{
	public bool lowerOnSprint = true;

	public bool lowerWhenCantAttack = true;

	public bool forceLower;

	public float lowerScale = 1f;

	public void SetShouldLower(bool shouldLower)
	{
	}
}


using UnityEngine;

public class ViewmodelMountedAnchor : MonoBehaviour
{
	public ViewmodelIk IkController;
}


using UnityEngine;

public class ViewmodelPunch : MonoBehaviour
{
	public AnimationCurve punchScale;

	public Vector3 punchDirection;

	public float punchDuration = 0.1f;

	public float punchMagnitude = 1f;
}


using UnityEngine;

public class ViewmodelSway : MonoBehaviour
{
	public float positionalSwaySpeed = 1f;

	public float positionalSwayAmount = 1f;

	public float rotationSwaySpeed = 1f;

	public float rotationSwayAmount = 1f;

	public float rotateAmountTest = 20f;
}


using System;
using UnityEngine;

[AddComponentMenu("")]
public class AmplifyOcclusionBase : MonoBehaviour
{
	public enum ApplicationMethod
	{
		PostEffect,
		Deferred,
		Debug
	}

	public enum PerPixelNormalSource
	{
		None,
		Camera,
		GBuffer,
		GBufferOctaEncoded
	}

	public enum SampleCountLevel
	{
		Low,
		Medium,
		High,
		VeryHigh
	}

	[Header("Ambient Occlusion")]
	public ApplicationMethod ApplyMethod;

	[Tooltip("Number of samples per pass.")]
	public SampleCountLevel SampleCount = SampleCountLevel.Medium;

	public PerPixelNormalSource PerPixelNormals = PerPixelNormalSource.Camera;

	[Range(0f, 1f)]
	[Tooltip("Final applied intensity of the occlusion effect.")]
	public float Intensity = 1f;

	public Color Tint = Color.black;

	[Range(0f, 32f)]
	[Tooltip("Radius spread of the occlusion.")]
	public float Radius = 2f;

	[NonSerialized]
	[Tooltip("Max sampling range in pixels.")]
	[Range(32f, 1024f)]
	public int PixelRadiusLimit = 512;

	[NonSerialized]
	[Tooltip("Occlusion contribution amount on relation to radius.")]
	[Range(0f, 2f)]
	public float RadiusIntensity = 1f;

	[Tooltip("Power exponent attenuation of the occlusion.")]
	[Range(0f, 16f)]
	public float PowerExponent = 1.8f;

	[Range(0f, 0.99f)]
	[Tooltip("Controls the initial occlusion contribution offset.")]
	public float Bias = 0.05f;

	[Tooltip("Controls the thickness occlusion contribution.")]
	[Range(0f, 1f)]
	public float Thickness = 1f;

	[Tooltip("Compute the Occlusion and Blur at half of the resolution.")]
	public bool Downsample = true;

	[Header("Distance Fade")]
	[Tooltip("Control parameters at faraway.")]
	public bool FadeEnabled;

	[Tooltip("Distance in Unity unities that start to fade.")]
	public float FadeStart = 100f;

	[Tooltip("Length distance to performe the transition.")]
	public float FadeLength = 50f;

	[Tooltip("Final Intensity parameter.")]
	[Range(0f, 1f)]
	public float FadeToIntensity;

	public Color FadeToTint = Color.black;

	[Range(0f, 32f)]
	[Tooltip("Final Radius parameter.")]
	public float FadeToRadius = 2f;

	[Range(0f, 16f)]
	[Tooltip("Final PowerExponent parameter.")]
	public float FadeToPowerExponent = 1.8f;

	[Tooltip("Final Thickness parameter.")]
	[Range(0f, 1f)]
	public float FadeToThickness = 1f;

	[Header("Bilateral Blur")]
	public bool BlurEnabled = true;

	[Tooltip("Radius in screen pixels.")]
	[Range(1f, 4f)]
	public int BlurRadius = 3;

	[Tooltip("Number of times that the Blur will repeat.")]
	[Range(1f, 4f)]
	public int BlurPasses = 1;

	[Tooltip("0 - Blured, 1 - Sharpened.")]
	[Range(0f, 20f)]
	public float BlurSharpness = 10f;

	[Header("Temporal Filter")]
	[Tooltip("Accumulates the effect over the time.")]
	public bool FilterEnabled = true;

	[Tooltip("Controls the accumulation decayment. 0 - Faster update, more flicker. 1 - Slow update (ghosting on moving objects), less flicker.")]
	[Range(0f, 1f)]
	public float FilterBlending = 0.5f;

	[Tooltip("Controls the discard sensibility based on the motion of the scene and objects. 0 - Discard less, reuse more (more ghost effect). 1 - Discard more, reuse less (less ghost effect).")]
	[Range(0f, 1f)]
	public float FilterResponse = 0.5f;

	[NonSerialized]
	[Tooltip("Enables directional variations.")]
	public bool TemporalDirections = true;

	[NonSerialized]
	[Tooltip("Enables offset variations.")]
	public bool TemporalOffsets = true;

	[NonSerialized]
	[Tooltip("Reduces ghosting effect near the objects's edges while moving.")]
	public bool TemporalDilation;

	[NonSerialized]
	[Tooltip("Uses the object movement information for calc new areas of occlusion.")]
	public bool UseMotionVectors = true;
}


public enum ApplicationMethod
{
	PostEffect,
	Deferred,
	Debug
}


public enum PerPixelNormalSource
{
	None,
	Camera,
	GBuffer,
	GBufferOctaEncoded
}


public enum SampleCountLevel
{
	Low,
	Medium,
	High,
	VeryHigh
}


using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("Image Effects/Amplify Occlusion")]
public class AmplifyOcclusionEffect : AmplifyOcclusionBase
{
}


using System;
using System.Collections;
using UnityEngine;

internal class UVTextureAnimator : MonoBehaviour
{
	public int Rows = 4;

	public int Columns = 4;

	public float Fps = 20f;

	public int OffsetMat;

	public bool IsLoop = true;

	public float StartDelay;

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		deltaFps = 1f / Fps;
		count = Rows * Columns;
		index = Columns - 1;
		Vector3 zero = Vector3.zero;
		OffsetMat -= OffsetMat / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)Columns, 1f / (float)Rows);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		while (isVisible && (IsLoop || allCount != count))
		{
			UpdateCorutineFrame();
			if (!IsLoop && allCount == count)
			{
				break;
			}
			yield return (object)new WaitForSeconds(deltaFps);
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateCorutineFrame()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(CathodeRenderer), PostProcessEvent.AfterStack, "Custom/Cathode - Analogue Video", true)]
public class Cathode : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Range(1f, 16f)]
	public IntParameter downscale = new IntParameter
	{
		value = 1
	};

	[Range(1f, 16f)]
	public IntParameter downscaleTemporal = new IntParameter
	{
		value = 1
	};

	[Range(0f, 3f)]
	public FloatParameter horizontalBlur = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 3f)]
	public FloatParameter verticalBlur = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 5f)]
	public FloatParameter chromaSubsampling = new FloatParameter
	{
		value = 1.7f
	};

	[Range(0f, 5f)]
	public FloatParameter sharpen = new FloatParameter
	{
		value = 1.2f
	};

	[Range(0f, 5f)]
	public FloatParameter sharpenRadius = new FloatParameter
	{
		value = 1.2f
	};

	[Range(0f, 0.5f)]
	public FloatParameter colorNoise = new FloatParameter
	{
		value = 0.05f
	};

	[Range(0f, 5f)]
	public FloatParameter restlessFoot = new FloatParameter
	{
		value = 0.2f
	};

	[Range(0f, 0.1f)]
	public FloatParameter footAmplitude = new FloatParameter
	{
		value = 0.02f
	};

	[Range(0f, 3f)]
	public FloatParameter chromaIntensity = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter chromaInstability = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 0.1f)]
	public FloatParameter chromaOffset = new FloatParameter
	{
		value = 0.02f
	};

	[Range(-2f, 2f)]
	public FloatParameter responseCurve = new FloatParameter
	{
		value = 0f
	};

	[Range(-1f, 1f)]
	public FloatParameter saturation = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter cometTrailing = new FloatParameter
	{
		value = 0.3f
	};

	[Range(0f, 1f)]
	public FloatParameter burnIn = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter tapeDust = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 2f)]
	public FloatParameter wobble = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public Vector2Parameter blackWhiteLevels = new Vector2Parameter
	{
		value = new Vector2(0f, 1f)
	};

	[Range(0f, 1f)]
	public Vector2Parameter dynamicRange = new Vector2Parameter
	{
		value = new Vector2(0f, 1f)
	};

	[Range(-1f, 1f)]
	public FloatParameter whiteBallance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class CathodeRenderer : PostProcessEffectRenderer<Cathode>
{
	private Texture2D noiseTex;

	private RenderTexture temporalRT;

	private Shader grayShader = Shader.Find("Hidden/Shader/Gray");

	private Shader primaryShader = Shader.Find("Hidden/Shader/PrimaryTransform");

	private Shader tvShader = Shader.Find("Hidden/Shader/TV");

	private Shader postTVShader = Shader.Find("Hidden/Shader/PostTV");

	private Shader trailShader = Shader.Find("Hidden/Shader/Trail");

	private readonly int _CathodeRT1 = Shader.PropertyToID("CathodeRT1");

	private readonly int _CathodeRT2 = Shader.PropertyToID("CathodeRT2");

	private readonly int _Intensity = Shader.PropertyToID("_Intensity");

	private readonly int _SizeX = Shader.PropertyToID("_SizeX");

	private readonly int _SizeY = Shader.PropertyToID("_SizeY");

	private readonly int _ChromaSubsampling = Shader.PropertyToID("_ChromaSubsampling");

	private readonly int _Sharpen = Shader.PropertyToID("_Sharpen");

	private readonly int _SharpenRadius = Shader.PropertyToID("_SharpenRadius");

	private readonly int _ColorNoise = Shader.PropertyToID("_ColorNoise");

	private readonly int _RestlessFoot = Shader.PropertyToID("_RestlessFoot");

	private readonly int _FootAmplitude = Shader.PropertyToID("_FootAmplitude");

	private readonly int _ChromaOffset = Shader.PropertyToID("_ChromaOffset");

	private readonly int _ChromaIntensity = Shader.PropertyToID("_ChromaIntensity");

	private readonly int _ChromaInstability = Shader.PropertyToID("_ChromaInstability");

	private readonly int _BurnIn = Shader.PropertyToID("_BurnIn");

	private readonly int _TapeDust = Shader.PropertyToID("_TapeDust");

	private readonly int _TrailTex = Shader.PropertyToID("_TrailTex");

	private readonly int _NoiseTex = Shader.PropertyToID("_NoiseTex");

	private readonly int _Gamma = Shader.PropertyToID("_Gamma");

	private readonly int _ResponseCurve = Shader.PropertyToID("_ResponseCurve");

	private readonly int _Saturation = Shader.PropertyToID("_Saturation");

	private readonly int _Wobble = Shader.PropertyToID("_Wobble");

	private readonly int _Black = Shader.PropertyToID("_Black");

	private readonly int _White = Shader.PropertyToID("_White");

	private readonly int _DynamicRangeMin = Shader.PropertyToID("_DynamicRangeMin");

	private readonly int _DynamicRangeMax = Shader.PropertyToID("_DynamicRangeMax");

	private readonly int _ScreenWhiteBal = Shader.PropertyToID("_ScreenWhiteBal");

	private readonly int _Trailing = Shader.PropertyToID("_Trailing");

	public override void Init()
	{
		base.Init();
		grayShader = Shader.Find("Hidden/Shader/Gray");
		primaryShader = Shader.Find("Hidden/Shader/PrimaryTransform");
		tvShader = Shader.Find("Hidden/Shader/TV");
		postTVShader = Shader.Find("Hidden/Shader/PostTV");
		trailShader = Shader.Find("Hidden/Shader/Trail");
		noiseTex = Resources.Load<Texture2D>("Noise");
	}

	public override void Release()
	{
		if ((Object)(object)noiseTex != (Object)null)
		{
			Resources.UnloadAsset((Object)(object)noiseTex);
			noiseTex = null;
		}
		if ((Object)(object)temporalRT != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)temporalRT);
			temporalRT = null;
		}
		base.Release();
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Expected O, but got Unknown
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_081e: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0713: Unknown result type (might be due to invalid IL or missing references)
		//IL_0715: Unknown result type (might be due to invalid IL or missing references)
		//IL_071e: Unknown result type (might be due to invalid IL or missing references)
		//IL_072d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_0742: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_076b: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0795: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e4: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("CathodeAnalogueVideo");
		int num = context.width / (int)base.settings.downscaleTemporal;
		int num2 = context.height / (int)base.settings.downscaleTemporal;
		if ((Object)(object)temporalRT == (Object)null || ((Texture)temporalRT).width != num || ((Texture)temporalRT).height != num2)
		{
			if ((Object)(object)temporalRT != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)temporalRT);
			}
			temporalRT = new RenderTexture(num, num2, 0, (RenderTextureFormat)9);
		}
		if ((float)base.settings.intensity > 0f)
		{
			PropertySheet propertySheet = context.propertySheets.Get(grayShader);
			PropertySheet propertySheet2 = context.propertySheets.Get(primaryShader);
			PropertySheet propertySheet3 = context.propertySheets.Get(tvShader);
			PropertySheet propertySheet4 = context.propertySheets.Get(postTVShader);
			PropertySheet propertySheet5 = context.propertySheets.Get(trailShader);
			propertySheet.properties.Clear();
			propertySheet2.properties.Clear();
			propertySheet3.properties.Clear();
			propertySheet4.properties.Clear();
			propertySheet5.properties.Clear();
			propertySheet.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet.properties.SetFloat(_SizeX, (float)base.settings.horizontalBlur);
			propertySheet.properties.SetFloat(_SizeY, (float)base.settings.verticalBlur);
			propertySheet2.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaSubsampling, (float)base.settings.chromaSubsampling * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_Sharpen, (float)base.settings.sharpen * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_SharpenRadius, (float)base.settings.sharpenRadius * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ColorNoise, (float)base.settings.colorNoise * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_RestlessFoot, (float)base.settings.restlessFoot * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_FootAmplitude, (float)base.settings.footAmplitude * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaOffset, (float)base.settings.chromaOffset * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaIntensity, Mathf.Lerp(1f, (float)base.settings.chromaIntensity, (float)base.settings.intensity));
			propertySheet2.properties.SetFloat(_ChromaInstability, (float)base.settings.chromaInstability * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_BurnIn, (float)base.settings.burnIn * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_TapeDust, 1f - (float)base.settings.tapeDust * (float)base.settings.intensity);
			propertySheet2.properties.SetTexture(_TrailTex, (Texture)(object)temporalRT);
			propertySheet2.properties.SetTexture(_NoiseTex, (Texture)(object)noiseTex);
			propertySheet3.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet3.properties.SetFloat(_Gamma, 1f);
			propertySheet4.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_ResponseCurve, (float)base.settings.responseCurve * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_Saturation, Mathf.Lerp(1f, (float)base.settings.saturation, (float)base.settings.intensity));
			propertySheet4.properties.SetFloat(_Wobble, (float)base.settings.wobble * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_Black, base.settings.blackWhiteLevels.value.x * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_White, 1f - (1f - base.settings.blackWhiteLevels.value.y) * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_DynamicRangeMin, base.settings.dynamicRange.value.x * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_DynamicRangeMax, 1f - (1f - base.settings.dynamicRange.value.y) * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_ScreenWhiteBal, (float)base.settings.whiteBallance * (float)base.settings.intensity);
			propertySheet5.properties.SetFloat(_Trailing, 1f - (float)base.settings.cometTrailing * (float)base.settings.intensity);
			RenderTextureDescriptor val = default(RenderTextureDescriptor);
			((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)2;
			((RenderTextureDescriptor)(ref val)).width = context.width / (int)base.settings.downscale;
			((RenderTextureDescriptor)(ref val)).height = context.height / (int)base.settings.downscale;
			((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
			((RenderTextureDescriptor)(ref val)).colorFormat = (RenderTextureFormat)9;
			((RenderTextureDescriptor)(ref val)).useMipMap = true;
			((RenderTextureDescriptor)(ref val)).autoGenerateMips = true;
			((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
			RenderTextureDescriptor val2 = val;
			command.GetTemporaryRT(_CathodeRT1, val2, (FilterMode)2);
			command.GetTemporaryRT(_CathodeRT2, val2, (FilterMode)2);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(_CathodeRT1), propertySheet, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), RenderTargetIdentifier.op_Implicit(_CathodeRT2), propertySheet2, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), RenderTargetIdentifier.op_Implicit((Texture)(object)temporalRT), propertySheet5, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT2), RenderTargetIdentifier.op_Implicit(_CathodeRT1), propertySheet4, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), context.destination, propertySheet3, 0, clear: false, null);
			command.ReleaseTemporaryRT(_CathodeRT1);
			command.ReleaseTemporaryRT(_CathodeRT2);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		command.EndSample("CathodeAnalogueVideo");
	}
}


public class cui
{
	[ServerUserVar]
	public static void cui_test(Arg args)
	{
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", args.Connection), "[\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"parent\": \"Overlay\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Tiled\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"url\": \"http://files.facepunch.com/garry/2015/June/03/2015-06-03_12-19-17.jpg\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0 0\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"1 1\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"NeedsCursor\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"name\": \"buttonText\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"Do you want to press a button?\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":32,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleCenter\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0 0.5\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"1 0.9\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"Button88\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Button\",\r\n\t\t\t\t\t\t\t\t\t\"close\":\"TestPanel7766\",\r\n\t\t\t\t\t\t\t\t\t\"command\":\"cui.endtest\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"0.9 0.8 0.3 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Tiled\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0.3 0.15\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"0.7 0.2\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"parent\": \"Button88\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"YES\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":20,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleCenter\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIcon\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Simple\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -151838493,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.4 0.4\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.4 0.4\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIconSkinTest\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Simple\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -733625651,\r\n\t\t\t\t\t\t\t\t\t\"skinid\": 13035\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.6 0.6\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.6 0.6\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"UpdateLabelTest\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"This should go away once you update!\",\r\n\t\t\t\t\t\t\t\t\t\"font\":\"DroidSansMono.ttf\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":32,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleRight\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"SteamAvatar\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"steamid\": \"76561197960279927\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.8 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.8 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t]\r\n\t\t\t\t\t");
	}

	[ServerUserVar]
	public static void cui_test_update(Arg args)
	{
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", args.Connection), "[\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"url\": \"https://files.facepunch.com/paddy/20220405/zipline_01.jpg\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"buttonText\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"This text just got updated!\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIcon\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -2067472972,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"Button88\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Button\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"0.9 0.3 0.3 0.8\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"UpdateLabelTest\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"enabled\": false,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t]\r\n\t\t\t\t\t");
	}

	[ServerUserVar]
	public static void endtest(Arg args)
	{
		args.ReplyWith("Ending Test!");
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("DestroyUI", args.Connection), "TestPanel7766");
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
public class CoverageQueries : MonoBehaviour
{
	public class BufferSet
	{
		public int width;

		public int height;

		public Texture2D inputTexture;

		public RenderTexture resultTexture;

		public Color[] inputData = (Color[])(object)new Color[0];

		public Color32[] resultData = (Color32[])(object)new Color32[0];

		private Material coverageMat;

		private const int MaxAsyncGPUReadbackRequests = 10;

		private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

		public void Attach(Material coverageMat)
		{
			this.coverageMat = coverageMat;
		}

		public void Dispose(bool data = true)
		{
			if ((Object)(object)inputTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)inputTexture);
				inputTexture = null;
			}
			if ((Object)(object)resultTexture != (Object)null)
			{
				RenderTexture.active = null;
				resultTexture.Release();
				Object.DestroyImmediate((Object)(object)resultTexture);
				resultTexture = null;
			}
			if (data)
			{
				inputData = (Color[])(object)new Color[0];
				resultData = (Color32[])(object)new Color32[0];
			}
		}

		public bool CheckResize(int count)
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Expected O, but got Unknown
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
			{
				Dispose(data: false);
				width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
				height = Mathf.CeilToInt((float)count / (float)width);
				inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
				((Object)inputTexture).name = "_Input";
				((Texture)inputTexture).filterMode = (FilterMode)0;
				((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
				resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
				((Object)resultTexture).name = "_Result";
				((Texture)resultTexture).filterMode = (FilterMode)0;
				((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				int num = resultData.Length;
				int num2 = width * height;
				Array.Resize(ref inputData, num2);
				Array.Resize(ref resultData, num2);
				Color32 val = default(Color32);
				((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
				for (int i = num; i < num2; i++)
				{
					resultData[i] = val;
				}
				return true;
			}
			return false;
		}

		public void UploadData()
		{
			if (inputData.Length != 0)
			{
				inputTexture.SetPixels(inputData);
				inputTexture.Apply();
			}
		}

		public void Dispatch(int count)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			if (inputData.Length != 0)
			{
				RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
				RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
				coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
				Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
				Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
			}
		}

		public void IssueRead()
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (asyncRequests.Count < 10)
			{
				asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
			}
		}

		public void GetResults()
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (resultData.Length == 0)
			{
				return;
			}
			while (asyncRequests.Count > 0)
			{
				AsyncGPUReadbackRequest val = asyncRequests.Peek();
				if (((AsyncGPUReadbackRequest)(ref val)).hasError)
				{
					asyncRequests.Dequeue();
					continue;
				}
				if (((AsyncGPUReadbackRequest)(ref val)).done)
				{
					NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
					for (int i = 0; i < data.Length; i++)
					{
						resultData[i] = data[i];
					}
					asyncRequests.Dequeue();
					continue;
				}
				break;
			}
		}
	}

	public enum RadiusSpace
	{
		ScreenNormalized,
		World
	}

	public class Query
	{
		public struct Input
		{
			public Vector3 position;

			public RadiusSpace radiusSpace;

			public float radius;

			public int sampleCount;

			public float smoothingSpeed;
		}

		public struct Internal
		{
			public int id;

			public void Reset()
			{
				id = -1;
			}
		}

		public struct Result
		{
			public int passed;

			public float coverage;

			public float smoothCoverage;

			public float weightedCoverage;

			public float weightedSmoothCoverage;

			public bool originOccluded;

			public int frame;

			public float originVisibility;

			public float originSmoothVisibility;

			public void Reset()
			{
				passed = 0;
				coverage = 0f;
				smoothCoverage = 0f;
				weightedCoverage = 0f;
				weightedSmoothCoverage = 0f;
				originOccluded = true;
				frame = -1;
				originVisibility = 0f;
				originSmoothVisibility = 0f;
			}
		}

		public Input input;

		public Internal intern;

		public Result result;

		public bool IsRegistered => intern.id >= 0;
	}

	public float depthBias = -0.1f;

	public bool debug;
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public int width;

	public int height;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private Material coverageMat;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public void Attach(Material coverageMat)
	{
		this.coverageMat = coverageMat;
	}

	public void Dispose(bool data = true)
	{
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
		}
	}

	public bool CheckResize(int count)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Expected O, but got Unknown
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
			height = Mathf.CeilToInt((float)count / (float)width);
			inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
			((Object)inputTexture).name = "_Input";
			((Texture)inputTexture).filterMode = (FilterMode)0;
			((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
			resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
			((Object)resultTexture).name = "_Result";
			((Texture)resultTexture).filterMode = (FilterMode)0;
			((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
			resultTexture.useMipMap = false;
			resultTexture.Create();
			int num = resultData.Length;
			int num2 = width * height;
			Array.Resize(ref inputData, num2);
			Array.Resize(ref resultData, num2);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
			for (int i = num; i < num2; i++)
			{
				resultData[i] = val;
			}
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (inputData.Length != 0)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
	}

	public void Dispatch(int count)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (inputData.Length != 0)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
	}

	public void IssueRead()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (asyncRequests.Count < 10)
		{
			asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
		}
	}

	public void GetResults()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (resultData.Length == 0)
		{
			return;
		}
		while (asyncRequests.Count > 0)
		{
			AsyncGPUReadbackRequest val = asyncRequests.Peek();
			if (((AsyncGPUReadbackRequest)(ref val)).hasError)
			{
				asyncRequests.Dequeue();
				continue;
			}
			if (((AsyncGPUReadbackRequest)(ref val)).done)
			{
				NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
				for (int i = 0; i < data.Length; i++)
				{
					resultData[i] = data[i];
				}
				asyncRequests.Dequeue();
				continue;
			}
			break;
		}
	}
}


public enum RadiusSpace
{
	ScreenNormalized,
	World
}


using UnityEngine;

public class Query
{
	public struct Input
	{
		public Vector3 position;

		public RadiusSpace radiusSpace;

		public float radius;

		public int sampleCount;

		public float smoothingSpeed;
	}

	public struct Internal
	{
		public int id;

		public void Reset()
		{
			id = -1;
		}
	}

	public struct Result
	{
		public int passed;

		public float coverage;

		public float smoothCoverage;

		public float weightedCoverage;

		public float weightedSmoothCoverage;

		public bool originOccluded;

		public int frame;

		public float originVisibility;

		public float originSmoothVisibility;

		public void Reset()
		{
			passed = 0;
			coverage = 0f;
			smoothCoverage = 0f;
			weightedCoverage = 0f;
			weightedSmoothCoverage = 0f;
			originOccluded = true;
			frame = -1;
			originVisibility = 0f;
			originSmoothVisibility = 0f;
		}
	}

	public Input input;

	public Internal intern;

	public Result result;

	public bool IsRegistered => intern.id >= 0;
}


using UnityEngine;

public struct Input
{
	public Vector3 position;

	public RadiusSpace radiusSpace;

	public float radius;

	public int sampleCount;

	public float smoothingSpeed;
}


public struct Internal
{
	public int id;

	public void Reset()
	{
		id = -1;
	}
}


public struct Result
{
	public int passed;

	public float coverage;

	public float smoothCoverage;

	public float weightedCoverage;

	public float weightedSmoothCoverage;

	public bool originOccluded;

	public int frame;

	public float originVisibility;

	public float originSmoothVisibility;

	public void Reset()
	{
		passed = 0;
		coverage = 0f;
		smoothCoverage = 0f;
		weightedCoverage = 0f;
		weightedSmoothCoverage = 0f;
		originOccluded = true;
		frame = -1;
		originVisibility = 0f;
		originSmoothVisibility = 0f;
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class ERVegetationStudio : ScriptableObject
{
	public static bool VegetationStudio()
	{
		return false;
	}

	public static bool VegetationStudioPro()
	{
		return false;
	}

	public static void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateHeightmap(Bounds bounds)
	{
	}

	public static void RemoveVegetationMaskLine(GameObject go)
	{
	}

	public static void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise)
	{
	}

	public static void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise)
	{
	}

	public static void RemoveBiomeArea(GameObject go)
	{
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class runtimeScript : MonoBehaviour
{
	public ERRoadNetwork roadNetwork;

	public ERRoad road;

	public GameObject go;

	public int currentElement;

	public float distance;

	public float speed = 5f;

	private void Start()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Please read the comments at the top of the runtime script (/Assets/EasyRoads3D/Scripts/runtimeScript) before using the runtime API!");
		roadNetwork = new ERRoadNetwork();
		ERRoadType val = new ERRoadType();
		val.roadWidth = 6f;
		ref Material roadMaterial = ref val.roadMaterial;
		Object obj = Resources.Load("Materials/roads/road material");
		roadMaterial = (Material)(object)((obj is Material) ? obj : null);
		val.layer = 1;
		val.tag = "Untagged";
		Vector3[] array = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(200f, 5f, 200f),
			new Vector3(250f, 5f, 200f),
			new Vector3(250f, 5f, 250f),
			new Vector3(300f, 5f, 250f)
		};
		road = roadNetwork.CreateRoad("road 1", val, array);
		road.AddMarker(new Vector3(300f, 5f, 300f));
		road.InsertMarker(new Vector3(275f, 5f, 235f));
		road.DeleteMarker(2);
		roadNetwork.BuildRoadNetwork();
		go = GameObject.CreatePrimitive((PrimitiveType)3);
	}

	private void Update()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (roadNetwork != null)
		{
			float num = Time.deltaTime * speed;
			distance += num;
			Vector3 position = road.GetPosition(distance, ref currentElement);
			position.y += 1f;
			go.transform.position = position;
			go.transform.forward = road.GetLookatSmooth(distance, currentElement);
		}
	}

	private void OnDestroy()
	{
		if (roadNetwork != null && roadNetwork.isInBuildMode)
		{
			roadNetwork.RestoreRoadNetwork();
			Debug.Log((object)"Restore Road Network");
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_RMCharacterController : FSimpleFitter
{
	protected FAnimationClips clips;

	protected Animator animator;

	private float gravity;

	protected override void Start()
	{
		base.Start();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Walk");
		clips.AddClip("RotateL");
		clips.AddClip("RotateR");
	}

	public void Update()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)optionalCharContr))
		{
			if (optionalCharContr.isGrounded)
			{
				gravity = 0f;
			}
			else
			{
				gravity += Time.deltaTime * 10f;
				optionalCharContr.Move(Vector3.down * gravity * Time.deltaTime);
			}
		}
		if (Input.GetKey((KeyCode)97))
		{
			clips.CrossFade("RotateL");
		}
		else if (Input.GetKey((KeyCode)100))
		{
			clips.CrossFade("RotateR");
		}
		else if (Input.GetKey((KeyCode)119))
		{
			clips.CrossFade("Walk");
		}
		else
		{
			clips.CrossFade("Idle");
		}
	}
}


using System;
using UnityEngine;

public static class FEasing
{
	public enum EFease
	{
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInOutElastic,
		EaseInElastic,
		EaseOutElastic,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		Linear
	}

	public delegate float Function(float s, float e, float v, float extraParameter = 1f);

	public static float EaseInCubic(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * value * value * value + start;
	}

	public static float EaseOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	public static float EaseInOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	public static float EaseOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 * 0.25f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return num3 * Mathf.Pow(2f, -10f * value * rangeMul) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + end + start;
	}

	public static float EaseInElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return 0f - num3 * Mathf.Pow(2f, 10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + start;
	}

	public static float EaseInOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		if (value < 1f)
		{
			return -0.5f * (num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2)) + start;
		}
		return num3 * Mathf.Pow(2f, -10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) * 0.5f + end + start;
	}

	public static float EaseInExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	public static float EaseOutExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	public static float EaseInOutExpo(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	public static float Linear(float start, float end, float value, float ignore = 1f)
	{
		return Mathf.Lerp(start, end, value);
	}

	public static Function GetEasingFunction(EFease easingFunction)
	{
		return easingFunction switch
		{
			EFease.EaseInCubic => EaseInCubic, 
			EFease.EaseOutCubic => EaseOutCubic, 
			EFease.EaseInOutCubic => EaseInOutCubic, 
			EFease.EaseInElastic => EaseInElastic, 
			EFease.EaseOutElastic => EaseOutElastic, 
			EFease.EaseInOutElastic => EaseInOutElastic, 
			EFease.EaseInExpo => EaseInExpo, 
			EFease.EaseOutExpo => EaseOutExpo, 
			EFease.EaseInOutExpo => EaseInOutExpo, 
			EFease.Linear => Linear, 
			_ => null, 
		};
	}
}


public enum EFease
{
	EaseInCubic,
	EaseOutCubic,
	EaseInOutCubic,
	EaseInOutElastic,
	EaseInElastic,
	EaseOutElastic,
	EaseInExpo,
	EaseOutExpo,
	EaseInOutExpo,
	Linear
}


public delegate float Function(float s, float e, float v, float extraParameter = 1f);


using UnityEngine;

public class FHierarchyIcons
{
	static FHierarchyIcons()
	{
	}

	private static void EvaluateIcons(int instanceId, Rect selectionRect)
	{
	}

	private static void DrawIcon(string texName, Rect rect)
	{
	}

	private static Texture2D GetTex(string name)
	{
		return null;
	}
}


public interface IFHierarchyIcon
{
	string EditorIconPath { get; }
}


using System;
using UnityEngine;

public static class FSceneIcons
{
	public static void SetGizmoIconEnabled(MonoBehaviour beh, bool on)
	{
		if (!((Object)(object)beh == (Object)null))
		{
			SetGizmoIconEnabled(((object)beh).GetType(), on);
		}
	}

	public static void SetGizmoIconEnabled(Type type, bool on)
	{
	}
}


using UnityEngine;

public class FPD_FixedCurveWindowAttribute : PropertyAttribute
{
	public float StartTime;

	public float EndTime;

	public float StartValue;

	public float EndValue;

	public Color Color;

	public FPD_FixedCurveWindowAttribute(float startTime = 0f, float startValue = 0f, float endTime = 1f, float endValue = 1f, float r = 0f, float g = 1f, float b = 1f, float a = 1f)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		StartTime = startTime;
		StartValue = startValue;
		EndTime = endTime;
		EndValue = endValue;
		Color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_FoldableAttribute : PropertyAttribute
{
	public string FoldVariable;

	public FPD_FoldableAttribute(string boolFoldVariable)
	{
		FoldVariable = boolFoldVariable;
	}
}


using UnityEngine;

public class FPD_HeaderAttribute : PropertyAttribute
{
	public string HeaderText;

	public float UpperPadding;

	public float BottomPadding;

	public float Height;

	public FPD_HeaderAttribute(string headerText, float upperPadding = 6f, float bottomPadding = 4f, int addHeight = 2)
	{
		HeaderText = headerText;
		UpperPadding = upperPadding;
		BottomPadding = bottomPadding;
		Height = addHeight;
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, Inherited = true)]
public class FPD_HideOnBoolAttribute : PropertyAttribute
{
	public string BoolVarName = "";

	public bool HideInInspector;

	public FPD_HideOnBoolAttribute(string boolVariableName)
	{
		BoolVarName = boolVariableName;
		HideInInspector = false;
	}

	public FPD_HideOnBoolAttribute(string conditionalSourceField, bool hideInInspector)
	{
		BoolVarName = conditionalSourceField;
		HideInInspector = hideInInspector;
	}
}


using UnityEngine;

public class FPD_LayersAttribute : PropertyAttribute
{
}


using UnityEngine;

public class FPD_MinMaxSliderAttribute : PropertyAttribute
{
	public float MinValue = -60f;

	public float MaxValue = 60f;

	public FPD_MinMaxSliderAttribute(int min, int max)
	{
		MinValue = min;
		MaxValue = max;
	}
}


using UnityEngine;

public class FPD_OverridableFloatAttribute : PropertyAttribute
{
	public string BoolVarName;

	public string TargetVarName;

	public int LabelWidth;

	public FPD_OverridableFloatAttribute(string boolVariableName, string targetVariableName, int labelWidth = 90)
	{
		BoolVarName = boolVariableName;
		TargetVarName = targetVariableName;
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class BackgroundColorAttribute : PropertyAttribute
{
	public float r;

	public float g;

	public float b;

	public float a;

	public Color Color => new Color(r, g, b, a);

	public BackgroundColorAttribute()
	{
		r = (g = (b = (a = 1f)));
	}

	public BackgroundColorAttribute(float aR, float aG, float aB, float aA)
	{
		r = aR;
		g = aG;
		b = aB;
		a = aA;
	}
}


using UnityEngine;

public class FPD_WidthAttribute : PropertyAttribute
{
	public float LabelWidth;

	public FPD_WidthAttribute(int labelWidth)
	{
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class FPD_IndentAttribute : PropertyAttribute
{
	public int IndentCount = 1;

	public int LabelsWidth;

	public int SpaceAfter;

	public FPD_IndentAttribute(int indent = 1, int labelsWidth = 0, int spaceAfter = 0)
	{
		IndentCount = indent;
		LabelsWidth = labelsWidth;
		SpaceAfter = spaceAfter;
	}
}


using UnityEngine;

public class FPD_HorizontalLineAttribute : PropertyAttribute
{
	public Color color;

	public FPD_HorizontalLineAttribute(float r = 0.55f, float g = 0.55f, float b = 0.55f, float a = 0.7f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_PercentageAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly string Suffix;

	public readonly bool from0to100;

	public readonly bool editableValue;

	public readonly bool basic;

	public FPD_PercentageAttribute(float min, float max, bool goOver100Perc = false, bool editable = true, string suffix = "%", bool basicFromTo = false)
	{
		Min = min;
		Max = max;
		from0to100 = !goOver100Perc;
		editableValue = editable;
		Suffix = suffix;
		basic = basicFromTo;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_SuffixAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly SuffixMode Mode;

	public readonly string Suffix;

	public readonly bool editableValue;

	public readonly int widerField;

	public FPD_SuffixAttribute(float min, float max, SuffixMode mode = SuffixMode.From0to100, string suffix = "%", bool editable = true, int wider = 0)
	{
		Min = min;
		Max = max;
		Mode = mode;
		Suffix = suffix;
		editableValue = editable;
		widerField = wider;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_TabAttribute : PropertyAttribute
{
	public string HeaderText;

	public float R;

	public float G;

	public float B;

	public string IconContent;

	public string ResourcesIconPath;

	public int IconSize;

	public string FoldVariable;

	public FPD_TabAttribute(string headerText, float r = 0.5f, float g = 0.5f, float b = 1f, string iconContent = "", string resourcesIconPath = "", int iconSize = 24, string foldVariable = "")
	{
		HeaderText = headerText;
		R = r;
		G = g;
		B = b;
		IconContent = iconContent;
		ResourcesIconPath = resourcesIconPath;
		IconSize = iconSize;
		FoldVariable = foldVariable;
	}
}


using UnityEngine;

[AddComponentMenu("Image Effects/FXAA")]
public class FXAA : FXAAPostEffectsBase, IImageEffect
{
	public Shader shader;

	private Material mat;

	private void CreateMaterials()
	{
		if ((Object)(object)mat == (Object)null)
		{
			mat = CheckShaderAndCreateMaterial(shader, mat);
		}
	}

	private void Start()
	{
		CreateMaterials();
		CheckSupport(needDepth: false);
	}

	public bool IsActive()
	{
		return ((Behaviour)this).enabled;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		CreateMaterials();
		float num = 1f / (float)Screen.width;
		float num2 = 1f / (float)Screen.height;
		mat.SetVector("_rcpFrame", new Vector4(num, num2, 0f, 0f));
		mat.SetVector("_rcpFrameOpt", new Vector4(num * 2f, num2 * 2f, num * 0.5f, num2 * 0.5f));
		Graphics.Blit((Texture)(object)source, destination, mat);
	}
}


using UnityEngine;

public class FXAAPostEffectsBase : MonoBehaviour
{
	protected bool supportHDRTextures = true;

	protected bool isSupported = true;

	public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			((Behaviour)this).enabled = false;
			return null;
		}
		if (s.isSupported && Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			NotSupported();
			Debug.LogError((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not supported on this platform!"));
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private Material CreateMaterial(Shader s, Material m2Create)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			return null;
		}
		if (Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s && s.isSupported)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private void OnEnable()
	{
		isSupported = true;
	}

	private bool CheckSupport()
	{
		return CheckSupport(needDepth: false);
	}

	private bool CheckResources()
	{
		Debug.LogWarning((object)("CheckResources () for " + ((object)this).ToString() + " should be overwritten."));
		return isSupported;
	}

	private void Start()
	{
		CheckResources();
	}

	public bool CheckSupport(bool needDepth)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		isSupported = true;
		supportHDRTextures = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2);
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			NotSupported();
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			NotSupported();
			return false;
		}
		if (needDepth)
		{
			Camera component = ((Component)this).GetComponent<Camera>();
			component.depthTextureMode = (DepthTextureMode)(component.depthTextureMode | 1);
		}
		return true;
	}

	private bool CheckSupport(bool needDepth, bool needHdr)
	{
		if (!CheckSupport(needDepth))
		{
			return false;
		}
		if (needHdr && !supportHDRTextures)
		{
			NotSupported();
			return false;
		}
		return true;
	}

	private void ReportAutoDisable()
	{
		Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it's not supported on the current platform."));
	}

	private bool CheckShader(Shader s)
	{
		Debug.Log((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package."));
		if (!s.isSupported)
		{
			NotSupported();
			return false;
		}
		return false;
	}

	private void NotSupported()
	{
		((Behaviour)this).enabled = false;
		isSupported = false;
	}

	private void DrawBorder(RenderTexture dest, Material material)
	{
		RenderTexture.active = dest;
		bool flag = true;
		GL.PushMatrix();
		GL.LoadOrtho();
		for (int i = 0; i < material.passCount; i++)
		{
			material.SetPass(i);
			float num;
			float num2;
			if (flag)
			{
				num = 1f;
				num2 = 0f;
			}
			else
			{
				num = 0f;
				num2 = 1f;
			}
			float num3 = 0f + 1f / ((float)((Texture)dest).width * 1f);
			float num4 = 0f;
			float num5 = 1f;
			GL.Begin(7);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			float num6 = 1f - 1f / ((float)((Texture)dest).width * 1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(num6, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(num6, num5, 0.1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 0f + 1f / ((float)((Texture)dest).height * 1f);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			num3 = 1f;
			num4 = 1f - 1f / ((float)((Texture)dest).height * 1f);
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			GL.End();
		}
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[ImageEffectAllowedInSceneView]
[AddComponentMenu("KriptoFX/Explosion_Bloom")]
[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
public class Explosion_Bloom : MonoBehaviour
{
	[Serializable]
	public struct Settings
	{
		[SerializeField]
		[Tooltip("Filters out pixels under this level of brightness.")]
		public float threshold;

		[Range(0f, 1f)]
		[Tooltip("Makes transition between under/over-threshold gradual.")]
		[SerializeField]
		public float softKnee;

		[SerializeField]
		[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
		[Range(1f, 7f)]
		public float radius;

		[SerializeField]
		[Tooltip("Blend factor of the result image.")]
		public float intensity;

		[Tooltip("Controls filter quality and buffer resolution.")]
		[SerializeField]
		public bool highQuality;

		[SerializeField]
		[Tooltip("Reduces flashing noise with an additional filter.")]
		public bool antiFlicker;

		public float thresholdGamma
		{
			get
			{
				return Mathf.Max(0f, threshold);
			}
			set
			{
				threshold = value;
			}
		}

		public float thresholdLinear
		{
			get
			{
				return Mathf.GammaToLinearSpace(thresholdGamma);
			}
			set
			{
				threshold = Mathf.LinearToGammaSpace(value);
			}
		}

		public static Settings defaultSettings
		{
			get
			{
				Settings result = default(Settings);
				result.threshold = 2f;
				result.softKnee = 0f;
				result.radius = 7f;
				result.intensity = 0.7f;
				result.highQuality = true;
				result.antiFlicker = true;
				return result;
			}
		}
	}

	[SerializeField]
	public Settings settings = Settings.defaultSettings;

	[SerializeField]
	[HideInInspector]
	private Shader m_Shader;

	private Material m_Material;

	private const int kMaxIterations = 16;

	private RenderTexture[] m_blurBuffer1 = (RenderTexture[])(object)new RenderTexture[16];

	private RenderTexture[] m_blurBuffer2 = (RenderTexture[])(object)new RenderTexture[16];

	private int m_Threshold;

	private int m_Curve;

	private int m_PrefilterOffs;

	private int m_SampleScale;

	private int m_Intensity;

	private int m_BaseTex;

	public Shader shader
	{
		get
		{
			if ((Object)(object)m_Shader == (Object)null)
			{
				m_Shader = Shader.Find("Hidden/KriptoFX/PostEffects/Explosion_Bloom");
			}
			return m_Shader;
		}
	}

	public Material material
	{
		get
		{
			if ((Object)(object)m_Material == (Object)null)
			{
				m_Material = CheckShaderAndCreateMaterial(shader);
			}
			return m_Material;
		}
	}

	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			Debug.LogWarningFormat("Missing shader for image effect {0}", new object[1] { effect });
			return false;
		}
		if (!SystemInfo.supportsImageEffects)
		{
			Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2))
		{
			Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = (HideFlags)52
		};
	}

	private void Awake()
	{
		m_Threshold = Shader.PropertyToID("_Threshold");
		m_Curve = Shader.PropertyToID("_Curve");
		m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
		m_SampleScale = Shader.PropertyToID("_SampleScale");
		m_Intensity = Shader.PropertyToID("_Intensity");
		m_BaseTex = Shader.PropertyToID("_BaseTex");
	}

	private void OnEnable()
	{
		if (!IsSupported(shader, needDepth: true, needHdr: false, (MonoBehaviour)(object)this))
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void OnDisable()
	{
		if ((Object)(object)m_Material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)m_Material);
		}
		m_Material = null;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		bool isMobilePlatform = Application.isMobilePlatform;
		int num = ((Texture)source).width;
		int num2 = ((Texture)source).height;
		if (!settings.highQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat val = (RenderTextureFormat)(isMobilePlatform ? 7 : 9);
		float num3 = Mathf.Log((float)num2, 2f) + settings.radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float thresholdLinear = settings.thresholdLinear;
		material.SetFloat(m_Threshold, thresholdLinear);
		float num6 = thresholdLinear * settings.softKnee + 1E-05f;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
		material.SetVector(m_Curve, Vector4.op_Implicit(val2));
		bool flag = !settings.highQuality && settings.antiFlicker;
		material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
		material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
		material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, val);
		Graphics.Blit((Texture)(object)source, temporary, material, settings.antiFlicker ? 1 : 0);
		RenderTexture val3 = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(((Texture)val3).width / 2, ((Texture)val3).height / 2, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
			val3 = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture val4 = m_blurBuffer1[num7];
			material.SetTexture(m_BaseTex, (Texture)(object)val4);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(((Texture)val4).width, ((Texture)val4).height, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
			val3 = m_blurBuffer2[num7];
		}
		int num8 = 7;
		num8 += (settings.highQuality ? 1 : 0);
		material.SetTexture(m_BaseTex, (Texture)(object)source);
		Graphics.Blit((Texture)(object)val3, destination, material, num8);
		for (int j = 0; j < 16; j++)
		{
			if ((Object)(object)m_blurBuffer1[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if ((Object)(object)m_blurBuffer2[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Settings
{
	[SerializeField]
	[Tooltip("Filters out pixels under this level of brightness.")]
	public float threshold;

	[Range(0f, 1f)]
	[Tooltip("Makes transition between under/over-threshold gradual.")]
	[SerializeField]
	public float softKnee;

	[SerializeField]
	[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
	[Range(1f, 7f)]
	public float radius;

	[SerializeField]
	[Tooltip("Blend factor of the result image.")]
	public float intensity;

	[Tooltip("Controls filter quality and buffer resolution.")]
	[SerializeField]
	public bool highQuality;

	[SerializeField]
	[Tooltip("Reduces flashing noise with an additional filter.")]
	public bool antiFlicker;

	public float thresholdGamma
	{
		get
		{
			return Mathf.Max(0f, threshold);
		}
		set
		{
			threshold = value;
		}
	}

	public float thresholdLinear
	{
		get
		{
			return Mathf.GammaToLinearSpace(thresholdGamma);
		}
		set
		{
			threshold = Mathf.LinearToGammaSpace(value);
		}
	}

	public static Settings defaultSettings
	{
		get
		{
			Settings result = default(Settings);
			result.threshold = 2f;
			result.softKnee = 0f;
			result.radius = 7f;
			result.intensity = 0.7f;
			result.highQuality = true;
			result.antiFlicker = true;
			return result;
		}
	}
}


using UnityEngine;

public class ExplosionDemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float reactivateTime = 4f;

	public Light Sun;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float sunIntensity;

	private float dpiScale;

	private void Start()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
		sunIntensity = Sun.intensity;
	}

	private void OnGUI()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT"))
		{
			ChangeCurrent(1);
		}
		sunIntensity = GUI.HorizontalSlider(new Rect(10f * dpiScale, 70f * dpiScale, 285f * dpiScale, 15f * dpiScale), sunIntensity, 0f, 0.6f);
		Sun.intensity = sunIntensity;
		GUI.Label(new Rect(300f * dpiScale, 70f * dpiScale, 30f * dpiScale, 30f * dpiScale), "SUN INTENSITY", guiStyleHeader);
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + ((Object)Prefabs[currentNomber]).name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
	}

	private void ChangeCurrent(int delta)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if ((Object)(object)currentInstance != (Object)null)
		{
			Object.Destroy((Object)(object)currentInstance);
		}
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
	}
}


using UnityEngine;

public class ExplosionDemoReactivator : MonoBehaviour
{
	public float TimeDelayToReactivate = 3f;

	private void Start()
	{
		((MonoBehaviour)this).InvokeRepeating("Reactivate", 0f, TimeDelayToReactivate);
	}

	private void Reactivate()
	{
		Transform[] componentsInChildren = ((Component)this).GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			((Component)obj).gameObject.SetActive(false);
			((Component)obj).gameObject.SetActive(true);
		}
	}
}


using UnityEngine;

public class ExplosionPlatformActivator : MonoBehaviour
{
	public GameObject Effect;

	public float TimeDelay;

	public float DefaultRepeatTime = 5f;

	public float NearRepeatTime = 3f;

	private float currentTime;

	private float currentRepeatTime;

	private bool canUpdate;

	private void Start()
	{
		currentRepeatTime = DefaultRepeatTime;
		((MonoBehaviour)this).Invoke("Init", TimeDelay);
	}

	private void Init()
	{
		canUpdate = true;
		Effect.SetActive(true);
	}

	private void Update()
	{
		if (canUpdate && !((Object)(object)Effect == (Object)null))
		{
			currentTime += Time.deltaTime;
			if (currentTime > currentRepeatTime)
			{
				currentTime = 0f;
				Effect.SetActive(false);
				Effect.SetActive(true);
			}
		}
	}

	private void OnTriggerEnter(Collider coll)
	{
		currentRepeatTime = NearRepeatTime;
	}

	private void OnTriggerExit(Collider other)
	{
		currentRepeatTime = DefaultRepeatTime;
	}
}


using UnityEngine;

public class ExplosionsFPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}


using UnityEngine;

public class ExplosionsBillboard : MonoBehaviour
{
	public Camera Camera;

	public bool Active = true;

	public bool AutoInitCamera = true;

	private GameObject myContainer;

	private Transform t;

	private Transform camT;

	private Transform contT;

	private void Awake()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (AutoInitCamera)
		{
			Camera = Camera.main;
			Active = true;
		}
		t = ((Component)this).transform;
		Vector3 localScale = ((Component)t.parent).transform.localScale;
		localScale.z = localScale.x;
		((Component)t.parent).transform.localScale = localScale;
		camT = ((Component)Camera).transform;
		Transform parent = t.parent;
		myContainer = new GameObject
		{
			name = "Billboard_" + ((Object)((Component)t).gameObject).name
		};
		contT = myContainer.transform;
		contT.position = t.position;
		t.parent = myContainer.transform;
		contT.parent = parent;
	}

	private void Update()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Active)
		{
			contT.LookAt(contT.position + camT.rotation * Vector3.back, camT.rotation * Vector3.up);
		}
	}
}


using UnityEngine;

public class ExplosionsDeactivateRendererByTime : MonoBehaviour
{
	public float TimeDelay = 1f;

	private Renderer rend;

	private void Awake()
	{
		rend = ((Component)this).GetComponent<Renderer>();
	}

	private void DeactivateRenderer()
	{
		rend.enabled = false;
	}

	private void OnEnable()
	{
		rend.enabled = true;
		((MonoBehaviour)this).Invoke("DeactivateRenderer", TimeDelay);
	}
}


using UnityEngine;

public class ExplosionsLightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = ((Component)this).GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class ExplosionsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class ExplosionsScaleCurves : MonoBehaviour
{
	public AnimationCurve ScaleCurveX = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveY = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveZ = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public Vector3 GraphTimeMultiplier = Vector3.one;

	public Vector3 GraphScaleMultiplier = Vector3.one;

	private float startTime;

	private Transform t;

	private float evalX;

	private float evalY;

	private float evalZ;

	private void Awake()
	{
		t = ((Component)this).transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		evalX = 0f;
		evalY = 0f;
		evalZ = 0f;
	}

	private void Update()
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (num <= GraphTimeMultiplier.x)
		{
			evalX = ScaleCurveX.Evaluate(num / GraphTimeMultiplier.x) * GraphScaleMultiplier.x;
		}
		if (num <= GraphTimeMultiplier.y)
		{
			evalY = ScaleCurveY.Evaluate(num / GraphTimeMultiplier.y) * GraphScaleMultiplier.y;
		}
		if (num <= GraphTimeMultiplier.z)
		{
			evalZ = ScaleCurveZ.Evaluate(num / GraphTimeMultiplier.z) * GraphScaleMultiplier.z;
		}
		t.localScale = new Vector3(evalX, evalY, evalZ);
	}
}


using UnityEngine;

public class ExplosionsShaderColorGradient : MonoBehaviour
{
	public string ShaderProperty = "_TintColor";

	public int MaterialID;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private Color oldColor;

	private void Start()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
		oldColor = matInstance.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color val = Color.Evaluate(num / TimeMultiplier);
			matInstance.SetColor(propertyID, val * oldColor);
		}
		if (num >= TimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderFloatCurves : MonoBehaviour
{
	public string ShaderProperty = "_BumpAmt";

	public int MaterialID;

	public AnimationCurve FloatPropertyCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphScaleMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private void Start()
	{
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatPropertyCurve.Evaluate(num / GraphTimeMultiplier) * GraphScaleMultiplier;
			matInstance.SetFloat(propertyID, num2);
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderQueue : MonoBehaviour
{
	public int AddQueue = 1;

	private Renderer rend;

	private void Start()
	{
		rend = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)rend != (Object)null)
		{
			Material sharedMaterial = rend.sharedMaterial;
			sharedMaterial.renderQueue += AddQueue;
		}
		else
		{
			((MonoBehaviour)this).Invoke("SetProjectorQueue", 0.1f);
		}
	}

	private void SetProjectorQueue()
	{
		Material material = ((Component)this).GetComponent<Projector>().material;
		material.renderQueue += AddQueue;
	}

	private void OnDisable()
	{
		if ((Object)(object)rend != (Object)null)
		{
			rend.sharedMaterial.renderQueue = -1;
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

internal class ExplosionsSpriteSheetAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public float AnimationFPS = 30f;

	public bool IsInterpolateFrames;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float animationLifeTime;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private float currentInterpolatedTime;

	private float animationStartTime;

	private bool animationStoped;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		animationStoped = false;
		animationLifeTime = (float)(TilesX * TilesY) / AnimationFPS;
		count = TilesY * TilesX;
		index = TilesX - 1;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		animationStartTime = Time.time;
		while (isVisible && (IsLoop || !animationStoped))
		{
			UpdateFrame();
			if (!IsLoop && animationStoped)
			{
				break;
			}
			float num = (Time.time - animationStartTime) / animationLifeTime;
			float num2 = FrameOverTime.Evaluate(Mathf.Clamp01(num));
			yield return (object)new WaitForSeconds(1f / (AnimationFPS * num2));
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateFrame()
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		if (count == allCount)
		{
			animationStartTime = Time.time;
			allCount = 0;
			animationStoped = true;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)TilesX - (float)(index / TilesX), 1f - (float)(index / TilesX) / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime = 0f;
		}
	}

	private void Update()
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime += Time.deltaTime;
			int num = index + 1;
			if (allCount == 0)
			{
				num = index;
			}
			Vector4 val = default(Vector4);
			((Vector4)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY, (float)num / (float)TilesX - (float)(num / TilesX), 1f - (float)(num / TilesX) / (float)TilesY);
			if ((Object)(object)currentRenderer != (Object)null)
			{
				instanceMaterial.SetVector("_MainTex_NextFrame", val);
				float num2 = (Time.time - animationStartTime) / animationLifeTime;
				float num3 = FrameOverTime.Evaluate(Mathf.Clamp01(num2));
				instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * AnimationFPS * num3));
			}
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using ConVar;
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Light))]
public class NGSS_Directional : MonoBehaviour
{
	public enum SAMPLER_COUNT
	{
		SAMPLERS_16,
		SAMPLERS_25,
		SAMPLERS_32,
		SAMPLERS_64
	}

	[Range(0f, 0.02f)]
	[Tooltip("Overall softness for both PCF and PCSS shadows.\nRecommended value: 0.01.")]
	public float PCSS_GLOBAL_SOFTNESS = 0.01f;

	[Range(0f, 1f)]
	[Tooltip("PCSS softness when shadows is close to caster.\nRecommended value: 0.05.")]
	public float PCSS_FILTER_DIR_MIN = 0.05f;

	[Range(0f, 0.5f)]
	[Tooltip("PCSS softness when shadows is far from caster.\nRecommended value: 0.25.\nIf too high can lead to visible artifacts when early bailout is enabled.")]
	public float PCSS_FILTER_DIR_MAX = 0.25f;

	[Tooltip("Amount of banding or noise. Example: 0.0 gives 100 % Banding and 10.0 gives 100 % Noise.")]
	[Range(0f, 10f)]
	public float BANDING_NOISE_AMOUNT = 1f;

	[Tooltip("Recommended values: Mobile = 16, Consoles = 25, Desktop Low = 32, Desktop High = 64")]
	public SAMPLER_COUNT SAMPLERS_COUNT;

	private void Update()
	{
		bool globalSettings = Graphics.shadowquality >= 2;
		SetGlobalSettings(globalSettings);
	}

	private void SetGlobalSettings(bool enabled)
	{
		if (enabled)
		{
			Shader.SetGlobalFloat("NGSS_PCSS_GLOBAL_SOFTNESS", PCSS_GLOBAL_SOFTNESS);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MIN", (PCSS_FILTER_DIR_MIN > PCSS_FILTER_DIR_MAX) ? PCSS_FILTER_DIR_MAX : PCSS_FILTER_DIR_MIN);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MAX", (PCSS_FILTER_DIR_MAX < PCSS_FILTER_DIR_MIN) ? PCSS_FILTER_DIR_MIN : PCSS_FILTER_DIR_MAX);
			Shader.SetGlobalFloat("NGSS_POISSON_SAMPLING_NOISE_DIR", BANDING_NOISE_AMOUNT);
		}
	}
}


public enum SAMPLER_COUNT
{
	SAMPLERS_16,
	SAMPLERS_25,
	SAMPLERS_32,
	SAMPLERS_64
}


using UnityEngine;

public struct OccludeeSphere
{
	public int id;

	public OccludeeState state;

	public OcclusionCulling.Sphere sphere;

	public bool IsRegistered => id >= 0;

	public void Invalidate()
	{
		id = -1;
		state = null;
		sphere = default(OcclusionCulling.Sphere);
	}

	public OccludeeSphere(int id)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		sphere = new OcclusionCulling.Sphere(Vector3.zero, 0f);
	}

	public OccludeeSphere(int id, OcclusionCulling.Sphere sphere)
	{
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		this.sphere = sphere;
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

public class OccludeeState : OcclusionCulling.SmartListValue
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
	public struct State
	{
		[FieldOffset(0)]
		public Vector4 sphereBounds;

		[FieldOffset(16)]
		public float minTimeVisible;

		[FieldOffset(20)]
		public float waitTime;

		[FieldOffset(24)]
		public uint waitFrame;

		[FieldOffset(28)]
		public byte isVisible;

		[FieldOffset(29)]
		public byte active;

		[FieldOffset(30)]
		public byte callback;

		[FieldOffset(31)]
		public byte pad1;

		public static State Unused = new State
		{
			active = 0
		};
	}

	public int slot;

	public bool isStatic;

	public int layer;

	public OcclusionCulling.OnVisibilityChanged onVisibilityChanged;

	public OcclusionCulling.Cell cell;

	public OcclusionCulling.SimpleList<State> states;

	public bool isVisible => states[slot].isVisible != 0;

	public OccludeeState Initialize(OcclusionCulling.SimpleList<State> states, OcclusionCulling.BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OcclusionCulling.OnVisibilityChanged onVisibilityChanged)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		states[slot] = new State
		{
			sphereBounds = sphereBounds,
			minTimeVisible = minTimeVisible,
			waitTime = (isVisible ? (Time.time + minTimeVisible) : 0f),
			waitFrame = (uint)(Time.frameCount + 1),
			isVisible = (byte)(isVisible ? 1 : 0),
			active = 1,
			callback = ((onVisibilityChanged != null) ? ((byte)1) : ((byte)0))
		};
		this.slot = slot;
		this.isStatic = isStatic;
		this.layer = layer;
		this.onVisibilityChanged = onVisibilityChanged;
		cell = null;
		this.states = states;
		return this;
	}

	public void Invalidate()
	{
		states[slot] = State.Unused;
		slot = -1;
		onVisibilityChanged = null;
		cell = null;
	}

	public void MakeVisible()
	{
		states.array[slot].waitTime = Time.time + states[slot].minTimeVisible;
		states.array[slot].isVisible = 1;
		if (onVisibilityChanged != null)
		{
			onVisibilityChanged(visible: true);
		}
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
public struct State
{
	[FieldOffset(0)]
	public Vector4 sphereBounds;

	[FieldOffset(16)]
	public float minTimeVisible;

	[FieldOffset(20)]
	public float waitTime;

	[FieldOffset(24)]
	public uint waitFrame;

	[FieldOffset(28)]
	public byte isVisible;

	[FieldOffset(29)]
	public byte active;

	[FieldOffset(30)]
	public byte callback;

	[FieldOffset(31)]
	public byte pad1;

	public static State Unused = new State
	{
		active = 0
	};
}


using UnityEngine;

public class Occludee : MonoBehaviour
{
	public float minTimeVisible = 0.1f;

	public bool isStatic = true;

	public bool autoRegister;

	public bool stickyGizmos;

	public OccludeeState state;

	protected int occludeeId = -1;

	protected Vector3 center;

	protected float radius;

	protected Renderer renderer;

	protected Collider collider;

	protected virtual void Awake()
	{
		renderer = ((Component)this).GetComponent<Renderer>();
		collider = ((Component)this).GetComponent<Collider>();
	}

	public void OnEnable()
	{
		if (autoRegister && (Object)(object)collider != (Object)null)
		{
			Register();
		}
	}

	public void OnDisable()
	{
		if (autoRegister && occludeeId >= 0)
		{
			Unregister();
		}
	}

	public void Register()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = collider.bounds;
		center = ((Bounds)(ref bounds)).center;
		bounds = collider.bounds;
		float x = ((Bounds)(ref bounds)).extents.x;
		bounds = collider.bounds;
		float num = Mathf.Max(x, ((Bounds)(ref bounds)).extents.y);
		bounds = collider.bounds;
		radius = Mathf.Max(num, ((Bounds)(ref bounds)).extents.z);
		occludeeId = OcclusionCulling.RegisterOccludee(center, radius, renderer.enabled, minTimeVisible, isStatic, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (occludeeId < 0)
		{
			Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
		}
		state = OcclusionCulling.GetStateById(occludeeId);
	}

	public void Unregister()
	{
		OcclusionCulling.UnregisterOccludee(occludeeId);
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		if ((Object)(object)renderer != (Object)null)
		{
			renderer.enabled = visible;
		}
	}
}


public class OcclusionCPUTest
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using RustNative;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
public class OcclusionCulling : MonoBehaviour
{
	public class BufferSet
	{
		public ComputeBuffer inputBuffer;

		public ComputeBuffer resultBuffer;

		public int width;

		public int height;

		public int capacity;

		public int count;

		public Texture2D inputTexture;

		public RenderTexture resultTexture;

		public Texture2D resultReadTexture;

		public Color[] inputData = (Color[])(object)new Color[0];

		public Color32[] resultData = (Color32[])(object)new Color32[0];

		private OcclusionCulling culling;

		private const int MaxAsyncGPUReadbackRequests = 10;

		private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

		public IntPtr readbackInst = IntPtr.Zero;

		public bool Ready => resultData.Length != 0;

		public void Attach(OcclusionCulling culling)
		{
			this.culling = culling;
		}

		public void Dispose(bool data = true)
		{
			if (inputBuffer != null)
			{
				inputBuffer.Dispose();
				inputBuffer = null;
			}
			if (resultBuffer != null)
			{
				resultBuffer.Dispose();
				resultBuffer = null;
			}
			if ((Object)(object)inputTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)inputTexture);
				inputTexture = null;
			}
			if ((Object)(object)resultTexture != (Object)null)
			{
				RenderTexture.active = null;
				resultTexture.Release();
				Object.DestroyImmediate((Object)(object)resultTexture);
				resultTexture = null;
			}
			if ((Object)(object)resultReadTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)resultReadTexture);
				resultReadTexture = null;
			}
			if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.Destroy(readbackInst);
				readbackInst = IntPtr.Zero;
			}
			if (data)
			{
				inputData = (Color[])(object)new Color[0];
				resultData = (Color32[])(object)new Color32[0];
				capacity = 0;
				count = 0;
			}
		}

		public bool CheckResize(int count, int granularity)
		{
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Expected O, but got Unknown
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cf: Expected O, but got Unknown
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Expected O, but got Unknown
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Expected O, but got Unknown
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Expected O, but got Unknown
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Expected I4, but got Unknown
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024b: Unknown result type (might be due to invalid IL or missing references)
			if (count > capacity || (culling.usePixelShaderFallback && (Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
			{
				Dispose(data: false);
				int num = capacity;
				int num2 = count / granularity * granularity + granularity;
				if (culling.usePixelShaderFallback)
				{
					width = Mathf.CeilToInt(Mathf.Sqrt((float)num2));
					height = Mathf.CeilToInt((float)num2 / (float)width);
					inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
					((Object)inputTexture).name = "_Input";
					((Texture)inputTexture).filterMode = (FilterMode)0;
					((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
					resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
					((Object)resultTexture).name = "_Result";
					((Texture)resultTexture).filterMode = (FilterMode)0;
					((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
					resultTexture.useMipMap = false;
					resultTexture.Create();
					resultReadTexture = new Texture2D(width, height, (TextureFormat)5, false, true);
					((Object)resultReadTexture).name = "_ResultRead";
					((Texture)resultReadTexture).filterMode = (FilterMode)0;
					((Texture)resultReadTexture).wrapMode = (TextureWrapMode)1;
					if (!culling.useAsyncReadAPI)
					{
						readbackInst = BufferReadback.CreateForTexture(((Texture)resultTexture).GetNativeTexturePtr(), (uint)width, (uint)height, (uint)(int)resultTexture.format);
					}
					capacity = width * height;
				}
				else
				{
					inputBuffer = new ComputeBuffer(num2, 16);
					resultBuffer = new ComputeBuffer(num2, 4);
					if (!culling.useAsyncReadAPI)
					{
						uint num3 = (uint)(capacity * 4);
						readbackInst = BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), num3);
					}
					capacity = num2;
				}
				Array.Resize(ref inputData, capacity);
				Array.Resize(ref resultData, capacity);
				Color32 val = default(Color32);
				((Color32)(ref val))..ctor(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = num; i < capacity; i++)
				{
					resultData[i] = val;
				}
				this.count = count;
				return true;
			}
			return false;
		}

		public void UploadData()
		{
			if (culling.usePixelShaderFallback)
			{
				inputTexture.SetPixels(inputData);
				inputTexture.Apply();
			}
			else
			{
				inputBuffer.SetData((Array)inputData);
			}
		}

		private int AlignDispatchSize(int dispatchSize)
		{
			return (dispatchSize + 63) / 64;
		}

		public void Dispatch(int count)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (culling.usePixelShaderFallback)
			{
				RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
				RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
				culling.fallbackMat.SetTexture("_Input", (Texture)(object)inputTexture);
				Graphics.Blit((Texture)(object)inputTexture, resultTexture, culling.fallbackMat, 0);
				Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
			}
			else if (inputBuffer != null)
			{
				culling.computeShader.SetBuffer(0, "_Input", inputBuffer);
				culling.computeShader.SetBuffer(0, "_Result", resultBuffer);
				culling.computeShader.Dispatch(0, AlignDispatchSize(count), 1, 1);
			}
		}

		public void IssueRead()
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			if (SafeMode)
			{
				return;
			}
			if (culling.useAsyncReadAPI)
			{
				if (asyncRequests.Count < 10)
				{
					AsyncGPUReadbackRequest item = ((!culling.usePixelShaderFallback) ? AsyncGPUReadback.Request(resultBuffer, (Action<AsyncGPUReadbackRequest>)null) : AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
					asyncRequests.Enqueue(item);
				}
			}
			else if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.IssueRead(readbackInst);
			}
		}

		public void GetResults()
		{
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			if (resultData == null || resultData.Length == 0)
			{
				return;
			}
			if (!SafeMode)
			{
				if (culling.useAsyncReadAPI)
				{
					while (asyncRequests.Count > 0)
					{
						AsyncGPUReadbackRequest val = asyncRequests.Peek();
						if (((AsyncGPUReadbackRequest)(ref val)).hasError)
						{
							asyncRequests.Dequeue();
							continue;
						}
						if (((AsyncGPUReadbackRequest)(ref val)).done)
						{
							NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
							for (int i = 0; i < data.Length; i++)
							{
								resultData[i] = data[i];
							}
							asyncRequests.Dequeue();
							continue;
						}
						break;
					}
				}
				else if (readbackInst != IntPtr.Zero)
				{
					BufferReadback.GetData(readbackInst, ref resultData[0]);
				}
			}
			else if (culling.usePixelShaderFallback)
			{
				RenderTexture.active = resultTexture;
				resultReadTexture.ReadPixels(new Rect(0f, 0f, (float)width, (float)height), 0, 0);
				resultReadTexture.Apply();
				Array.Copy(resultReadTexture.GetPixels32(), resultData, resultData.Length);
			}
			else
			{
				resultBuffer.GetData((Array)resultData);
			}
		}
	}

	public delegate void OnVisibilityChanged(bool visible);

	public enum DebugFilter
	{
		Off,
		Dynamic,
		Static,
		Grid,
		All
	}

	[Flags]
	public enum DebugMask
	{
		Off = 0,
		Dynamic = 1,
		Static = 2,
		Grid = 4,
		All = 7
	}

	[Serializable]
	public class DebugSettings
	{
		public bool log;

		public bool showAllVisible;

		public bool showMipChain;

		public bool showMain;

		public int showMainLod;

		public bool showFallback;

		public bool showStats;

		public bool showScreenBounds;

		public DebugMask showMask;

		public LayerMask layerFilter = LayerMask.op_Implicit(-1);
	}

	public class HashedPoolValue
	{
		public ulong hashedPoolKey = ulong.MaxValue;

		public int hashedPoolIndex = -1;
	}

	public class HashedPool<TValueType> where TValueType : HashedPoolValue, new()
	{
		private int granularity;

		private Dictionary<ulong, TValueType> dict;

		private List<TValueType> pool;

		private List<TValueType> list;

		private Queue<TValueType> recycled;

		public int Size => list.Count;

		public int Count => dict.Count;

		public TValueType this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		public HashedPool(int capacity, int granularity)
		{
			this.granularity = granularity;
			dict = new Dictionary<ulong, TValueType>(capacity);
			pool = new List<TValueType>(capacity);
			list = new List<TValueType>(capacity);
			recycled = new Queue<TValueType>();
		}

		public void Clear()
		{
			dict.Clear();
			pool.Clear();
			list.Clear();
			recycled.Clear();
		}

		public TValueType Add(ulong key, int capacityGranularity = 16)
		{
			TValueType val;
			if (recycled.Count > 0)
			{
				val = recycled.Dequeue();
				list[val.hashedPoolIndex] = val;
			}
			else
			{
				int count = pool.Count;
				if (count == pool.Capacity)
				{
					pool.Capacity += granularity;
				}
				val = new TValueType
				{
					hashedPoolIndex = count
				};
				pool.Add(val);
				list.Add(val);
			}
			val.hashedPoolKey = key;
			dict.Add(key, val);
			return val;
		}

		public void Remove(TValueType value)
		{
			dict.Remove(value.hashedPoolKey);
			list[value.hashedPoolIndex] = null;
			recycled.Enqueue(value);
			value.hashedPoolKey = ulong.MaxValue;
		}

		public bool TryGetValue(ulong key, out TValueType value)
		{
			return dict.TryGetValue(key, out value);
		}

		public bool ContainsKey(ulong key)
		{
			return dict.ContainsKey(key);
		}
	}

	public class SimpleList<T>
	{
		private const int defaultCapacity = 16;

		private static readonly T[] emptyArray = new T[0];

		public T[] array;

		public int count;

		public int Count => count;

		public int Capacity
		{
			get
			{
				return array.Length;
			}
			set
			{
				if (value == array.Length)
				{
					return;
				}
				if (value > 0)
				{
					T[] destinationArray = new T[value];
					if (count > 0)
					{
						Array.Copy(array, 0, destinationArray, 0, count);
					}
					array = destinationArray;
				}
				else
				{
					array = emptyArray;
				}
			}
		}

		public T this[int index]
		{
			get
			{
				return array[index];
			}
			set
			{
				array[index] = value;
			}
		}

		public SimpleList()
		{
			array = emptyArray;
		}

		public SimpleList(int capacity)
		{
			array = ((capacity == 0) ? emptyArray : new T[capacity]);
		}

		public void Add(T item)
		{
			if (count == array.Length)
			{
				EnsureCapacity(count + 1);
			}
			array[count++] = item;
		}

		public void Clear()
		{
			if (count > 0)
			{
				Array.Clear(array, 0, count);
				count = 0;
			}
		}

		public bool Contains(T item)
		{
			for (int i = 0; i < count; i++)
			{
				if (array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}

		public void CopyTo(T[] array)
		{
			Array.Copy(this.array, 0, array, 0, count);
		}

		public void EnsureCapacity(int min)
		{
			if (array.Length < min)
			{
				int num = ((array.Length == 0) ? 16 : (array.Length * 2));
				num = ((num < min) ? min : num);
				Capacity = num;
			}
		}
	}

	public class SmartListValue
	{
		public int hashedListIndex = -1;
	}

	public class SmartList
	{
		private const int defaultCapacity = 16;

		private static readonly OccludeeState[] emptyList = new OccludeeState[0];

		private static readonly int[] emptySlots = new int[0];

		private OccludeeState[] list;

		private int[] slots;

		private Queue<int> recycled;

		private int count;

		public OccludeeState[] List => list;

		public int[] Slots => slots;

		public int Size => count;

		public int Count => count - recycled.Count;

		public OccludeeState this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		public int Capacity
		{
			get
			{
				return list.Length;
			}
			set
			{
				if (value == list.Length)
				{
					return;
				}
				if (value > 0)
				{
					OccludeeState[] destinationArray = new OccludeeState[value];
					int[] destinationArray2 = new int[value];
					if (count > 0)
					{
						Array.Copy(list, destinationArray, count);
						Array.Copy(slots, destinationArray2, count);
					}
					list = destinationArray;
					slots = destinationArray2;
				}
				else
				{
					list = emptyList;
					slots = emptySlots;
				}
			}
		}

		public SmartList(int capacity)
		{
			list = new OccludeeState[capacity];
			slots = new int[capacity];
			recycled = new Queue<int>();
			count = 0;
		}

		public void Add(OccludeeState value, int capacityGranularity = 16)
		{
			int num;
			if (recycled.Count > 0)
			{
				num = recycled.Dequeue();
				list[num] = value;
				slots[num] = value.slot;
			}
			else
			{
				num = count;
				if (num == list.Length)
				{
					EnsureCapacity(count + 1);
				}
				list[num] = value;
				slots[num] = value.slot;
				count++;
			}
			value.hashedListIndex = num;
		}

		public void Remove(OccludeeState value)
		{
			int hashedListIndex = value.hashedListIndex;
			list[hashedListIndex] = null;
			slots[hashedListIndex] = -1;
			recycled.Enqueue(hashedListIndex);
			value.hashedListIndex = -1;
		}

		public bool Contains(OccludeeState value)
		{
			int hashedListIndex = value.hashedListIndex;
			if (hashedListIndex >= 0)
			{
				return list[hashedListIndex] != null;
			}
			return false;
		}

		public void EnsureCapacity(int min)
		{
			if (list.Length < min)
			{
				int num = ((list.Length == 0) ? 16 : (list.Length * 2));
				num = ((num < min) ? min : num);
				Capacity = num;
			}
		}
	}

	[Serializable]
	public class Cell : HashedPoolValue
	{
		public int x;

		public int y;

		public int z;

		public Bounds bounds;

		public Vector4 sphereBounds;

		public bool isVisible;

		public SmartList staticBucket;

		public SmartList dynamicBucket;

		public void Reset()
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			x = (y = (z = 0));
			bounds = default(Bounds);
			sphereBounds = Vector4.zero;
			isVisible = true;
			staticBucket = null;
			dynamicBucket = null;
		}

		public Cell Initialize(int x, int y, int z, Bounds bounds)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			this.x = x;
			this.y = y;
			this.z = z;
			this.bounds = bounds;
			float num = ((Bounds)(ref bounds)).center.x;
			float num2 = ((Bounds)(ref bounds)).center.y;
			float num3 = ((Bounds)(ref bounds)).center.z;
			Vector3 extents = ((Bounds)(ref bounds)).extents;
			sphereBounds = new Vector4(num, num2, num3, ((Vector3)(ref extents)).magnitude);
			isVisible = true;
			staticBucket = new SmartList(32);
			dynamicBucket = new SmartList(32);
			return this;
		}
	}

	public struct Sphere
	{
		public Vector3 position;

		public float radius;

		public bool IsValid()
		{
			return radius > 0f;
		}

		public Sphere(Vector3 position, float radius)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			this.position = position;
			this.radius = radius;
		}
	}

	public ComputeShader computeShader;

	public bool usePixelShaderFallback = true;

	public bool useAsyncReadAPI;

	private Camera camera;

	private const int ComputeThreadsPerGroup = 64;

	private const int InputBufferStride = 16;

	private const int ResultBufferStride = 4;

	private const int OccludeeMaxSlotsPerPool = 1048576;

	private const int OccludeePoolGranularity = 2048;

	private const int StateBufferGranularity = 2048;

	private const int GridBufferGranularity = 256;

	private static Queue<OccludeeState> statePool = new Queue<OccludeeState>();

	private static SimpleList<OccludeeState> staticOccludees = new SimpleList<OccludeeState>(2048);

	private static SimpleList<OccludeeState.State> staticStates = new SimpleList<OccludeeState.State>(2048);

	private static SimpleList<int> staticVisibilityChanged = new SimpleList<int>(1024);

	private static SimpleList<OccludeeState> dynamicOccludees = new SimpleList<OccludeeState>(2048);

	private static SimpleList<OccludeeState.State> dynamicStates = new SimpleList<OccludeeState.State>(2048);

	private static SimpleList<int> dynamicVisibilityChanged = new SimpleList<int>(1024);

	private static List<int> staticChanged = new List<int>(256);

	private static Queue<int> staticRecycled = new Queue<int>();

	private static List<int> dynamicChanged = new List<int>(1024);

	private static Queue<int> dynamicRecycled = new Queue<int>();

	private static BufferSet staticSet = new BufferSet();

	private static BufferSet dynamicSet = new BufferSet();

	private static BufferSet gridSet = new BufferSet();

	private Vector4[] frustumPlanes = (Vector4[])(object)new Vector4[6];

	private string[] frustumPropNames = new string[6];

	private float[] matrixToFloatTemp = new float[16];

	private Material fallbackMat;

	private Material depthCopyMat;

	private Matrix4x4 viewMatrix;

	private Matrix4x4 projMatrix;

	private Matrix4x4 viewProjMatrix;

	private Matrix4x4 prevViewProjMatrix;

	private Matrix4x4 invViewProjMatrix;

	private bool useNativePath = true;

	private static OcclusionCulling instance;

	public static bool Passthrough = false;

	private static GraphicsDeviceType[] supportedDeviceTypes = (GraphicsDeviceType[])(object)new GraphicsDeviceType[1] { (GraphicsDeviceType)2 };

	private static bool _enabled = false;

	private static bool _safeMode = false;

	private static DebugFilter _debugShow = DebugFilter.Off;

	public DebugSettings debugSettings = new DebugSettings();

	private Material debugMipMat;

	private const float debugDrawDuration = 0.0334f;

	private Material downscaleMat;

	private Material blitCopyMat;

	private int hiZLevelCount;

	private int hiZWidth;

	private int hiZHeight;

	private RenderTexture depthTexture;

	private RenderTexture hiZTexture;

	private RenderTexture[] hiZLevels;

	private const int GridCellsPerAxis = 2097152;

	private const int GridHalfCellsPerAxis = 1048576;

	private const int GridMinHalfCellsPerAxis = -1048575;

	private const int GridMaxHalfCellsPerAxis = 1048575;

	private const float GridCellSize = 100f;

	private const float GridHalfCellSize = 50f;

	private const float GridRcpCellSize = 0.01f;

	private const int GridPoolCapacity = 16384;

	private const int GridPoolGranularity = 4096;

	private static HashedPool<Cell> grid = new HashedPool<Cell>(16384, 4096);

	private static Queue<Cell> gridChanged = new Queue<Cell>();

	public static OcclusionCulling Instance => instance;

	public static bool Supported => supportedDeviceTypes.Contains(SystemInfo.graphicsDeviceType);

	public static bool Enabled
	{
		get
		{
			return _enabled;
		}
		set
		{
			_enabled = value;
			if ((Object)(object)instance != (Object)null)
			{
				((Behaviour)instance).enabled = value;
			}
		}
	}

	public static bool SafeMode
	{
		get
		{
			return _safeMode;
		}
		set
		{
			_safeMode = value;
		}
	}

	public static DebugFilter DebugShow
	{
		get
		{
			return _debugShow;
		}
		set
		{
			_debugShow = value;
		}
	}

	public bool HiZReady
	{
		get
		{
			if ((Object)(object)hiZTexture != (Object)null && hiZWidth > 0)
			{
				return hiZHeight > 0;
			}
			return false;
		}
	}

	private static void GrowStatePool()
	{
		for (int i = 0; i < 2048; i++)
		{
			statePool.Enqueue(new OccludeeState());
		}
	}

	private static OccludeeState Allocate()
	{
		if (statePool.Count == 0)
		{
			GrowStatePool();
		}
		return statePool.Dequeue();
	}

	private static void Release(OccludeeState state)
	{
		statePool.Enqueue(state);
	}

	private void Awake()
	{
		instance = this;
		camera = ((Component)this).GetComponent<Camera>();
		for (int i = 0; i < 6; i++)
		{
			frustumPropNames[i] = "_FrustumPlane" + i;
		}
	}

	private void OnEnable()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Invalid comparison between Unknown and I4
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Expected O, but got Unknown
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Expected O, but got Unknown
		if (!Enabled)
		{
			Enabled = false;
			return;
		}
		GraphicsDeviceType graphicsDeviceType;
		if (!Supported)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogWarning((object)("[OcclusionCulling] Disabled due to graphics device type " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString() + " not supported."));
			Enabled = false;
			return;
		}
		usePixelShaderFallback = usePixelShaderFallback || !SystemInfo.supportsComputeShaders || (Object)(object)computeShader == (Object)null || !computeShader.HasKernel("compute_cull");
		useNativePath = (int)SystemInfo.graphicsDeviceType == 2 && SupportsNativePath();
		useAsyncReadAPI = !useNativePath && SystemInfo.supportsAsyncGPUReadback;
		if (!useNativePath && !useAsyncReadAPI)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogWarning((object)("[OcclusionCulling] Disabled due to unsupported Async GPU Reads on device " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString()));
			Enabled = false;
			return;
		}
		for (int i = 0; i < staticOccludees.Count; i++)
		{
			staticChanged.Add(i);
		}
		for (int j = 0; j < dynamicOccludees.Count; j++)
		{
			dynamicChanged.Add(j);
		}
		if (usePixelShaderFallback)
		{
			fallbackMat = new Material(Shader.Find("Hidden/OcclusionCulling/Culling"))
			{
				hideFlags = (HideFlags)61
			};
		}
		staticSet.Attach(this);
		dynamicSet.Attach(this);
		gridSet.Attach(this);
		depthCopyMat = new Material(Shader.Find("Hidden/OcclusionCulling/DepthCopy"))
		{
			hideFlags = (HideFlags)61
		};
		InitializeHiZMap();
		UpdateCameraMatrices(starting: true);
	}

	private bool SupportsNativePath()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		try
		{
			OccludeeState.State states = default(OccludeeState.State);
			Color32 results = default(Color32);
			((Color32)(ref results))..ctor((byte)0, (byte)0, (byte)0, (byte)0);
			Vector4 zero = Vector4.zero;
			int bucket = 0;
			int changed = 0;
			int changedCount = 0;
			ProcessOccludees_Native(ref states, ref bucket, 0, ref results, 0, ref changed, ref changedCount, ref zero, 0f, 0u);
		}
		catch (EntryPointNotFoundException)
		{
			Debug.Log((object)"[OcclusionCulling] Fast native path not available. Reverting to managed fallback.");
			result = false;
		}
		return result;
	}

	private void OnDisable()
	{
		if ((Object)(object)fallbackMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)fallbackMat);
			fallbackMat = null;
		}
		if ((Object)(object)depthCopyMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)depthCopyMat);
			depthCopyMat = null;
		}
		staticSet.Dispose();
		dynamicSet.Dispose();
		gridSet.Dispose();
		FinalizeHiZMap();
	}

	public static void MakeAllVisible()
	{
		for (int i = 0; i < staticOccludees.Count; i++)
		{
			if (staticOccludees[i] != null)
			{
				staticOccludees[i].MakeVisible();
			}
		}
		for (int j = 0; j < dynamicOccludees.Count; j++)
		{
			if (dynamicOccludees[j] != null)
			{
				dynamicOccludees[j].MakeVisible();
			}
		}
	}

	private void Update()
	{
		if (!Enabled)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		CheckResizeHiZMap();
		DebugUpdate();
		DebugDraw();
	}

	public static void RecursiveAddOccludees<T>(Transform transform, float minTimeVisible = 0.1f, bool isStatic = true, bool stickyGizmos = false) where T : Occludee
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Expected O, but got Unknown
		Renderer component = ((Component)transform).GetComponent<Renderer>();
		Collider component2 = ((Component)transform).GetComponent<Collider>();
		if ((Object)(object)component != (Object)null && (Object)(object)component2 != (Object)null)
		{
			T component3 = ((Component)component).gameObject.GetComponent<T>();
			component3 = (((Object)(object)component3 == (Object)null) ? ((Component)component).gameObject.AddComponent<T>() : component3);
			component3.minTimeVisible = minTimeVisible;
			component3.isStatic = isStatic;
			component3.stickyGizmos = stickyGizmos;
			component3.Register();
		}
		foreach (Transform item in transform)
		{
			RecursiveAddOccludees<T>(item, minTimeVisible, isStatic, stickyGizmos);
		}
	}

	private static int FindFreeSlot(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, Queue<int> recycled)
	{
		int result;
		if (recycled.Count > 0)
		{
			result = recycled.Dequeue();
		}
		else
		{
			if (occludees.Count == occludees.Capacity)
			{
				int num = Mathf.Min(occludees.Capacity + 2048, 1048576);
				if (num > 0)
				{
					occludees.Capacity = num;
					states.Capacity = num;
				}
			}
			if (occludees.Count < occludees.Capacity)
			{
				result = occludees.Count;
				occludees.Add(null);
				states.Add(default(OccludeeState.State));
			}
			else
			{
				result = -1;
			}
		}
		return result;
	}

	public static OccludeeState GetStateById(int id)
	{
		if (id >= 0 && id < 2097152)
		{
			bool num = id < 1048576;
			int index = (num ? id : (id - 1048576));
			if (num)
			{
				return staticOccludees[index];
			}
			return dynamicOccludees[index];
		}
		return null;
	}

	public static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged = null)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		num = ((!isStatic) ? RegisterOccludee(center, radius, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged, dynamicOccludees, dynamicStates, dynamicRecycled, dynamicChanged, dynamicSet, dynamicVisibilityChanged) : RegisterOccludee(center, radius, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged, staticOccludees, staticStates, staticRecycled, staticChanged, staticSet, staticVisibilityChanged));
		if (!(num < 0 || isStatic))
		{
			return num + 1048576;
		}
		return num;
	}

	private static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged, SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, Queue<int> recycled, List<int> changed, BufferSet set, SimpleList<int> visibilityChanged)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		int num = FindFreeSlot(occludees, states, recycled);
		if (num >= 0)
		{
			Vector4 sphereBounds = default(Vector4);
			((Vector4)(ref sphereBounds))..ctor(center.x, center.y, center.z, radius);
			OccludeeState occludeeState = Allocate().Initialize(states, set, num, sphereBounds, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged);
			occludeeState.cell = RegisterToGrid(occludeeState);
			occludees[num] = occludeeState;
			changed.Add(num);
			if (states.array[num].isVisible != 0 != occludeeState.cell.isVisible)
			{
				visibilityChanged.Add(num);
			}
		}
		return num;
	}

	public static void UnregisterOccludee(int id)
	{
		if (id >= 0 && id < 2097152)
		{
			bool num = id < 1048576;
			int slot = (num ? id : (id - 1048576));
			if (num)
			{
				UnregisterOccludee(slot, staticOccludees, staticRecycled, staticChanged);
			}
			else
			{
				UnregisterOccludee(slot, dynamicOccludees, dynamicRecycled, dynamicChanged);
			}
		}
	}

	private static void UnregisterOccludee(int slot, SimpleList<OccludeeState> occludees, Queue<int> recycled, List<int> changed)
	{
		OccludeeState occludeeState = occludees[slot];
		UnregisterFromGrid(occludeeState);
		recycled.Enqueue(slot);
		changed.Add(slot);
		Release(occludeeState);
		occludees[slot] = null;
		occludeeState.Invalidate();
	}

	public static void UpdateDynamicOccludee(int id, Vector3 center, float radius)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = id - 1048576;
		if (num >= 0 && num < 1048576)
		{
			dynamicStates.array[num].sphereBounds = new Vector4(center.x, center.y, center.z, radius);
			dynamicChanged.Add(num);
		}
	}

	private void UpdateBuffers(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, BufferSet set, List<int> changed, bool isStatic)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		int count = occludees.Count;
		bool flag = changed.Count > 0;
		set.CheckResize(count, 2048);
		for (int i = 0; i < changed.Count; i++)
		{
			int num = changed[i];
			OccludeeState occludeeState = occludees[num];
			if (occludeeState != null)
			{
				if (!isStatic)
				{
					UpdateInGrid(occludeeState);
				}
				set.inputData[num] = Color.op_Implicit(states[num].sphereBounds);
			}
			else
			{
				set.inputData[num] = Color.op_Implicit(Vector4.zero);
			}
		}
		changed.Clear();
		if (flag)
		{
			set.UploadData();
		}
	}

	private void UpdateCameraMatrices(bool starting = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (!starting)
		{
			prevViewProjMatrix = viewProjMatrix;
		}
		Matrix4x4 val = Matrix4x4.Perspective(camera.fieldOfView, camera.aspect, camera.nearClipPlane, camera.farClipPlane);
		viewMatrix = camera.worldToCameraMatrix;
		projMatrix = GL.GetGPUProjectionMatrix(val, false);
		viewProjMatrix = projMatrix * viewMatrix;
		invViewProjMatrix = Matrix4x4.Inverse(viewProjMatrix);
		if (starting)
		{
			prevViewProjMatrix = viewProjMatrix;
		}
	}

	private void OnPreCull()
	{
		UpdateCameraMatrices();
		GenerateHiZMipChain();
		PrepareAndDispatch();
		IssueRead();
		if (grid.Size <= gridSet.resultData.Length)
		{
			RetrieveAndApplyVisibility();
		}
		else
		{
			Debug.LogWarning((object)("[OcclusionCulling] Grid size and result capacity are out of sync: " + grid.Size + ", " + gridSet.resultData.Length));
		}
	}

	private void OnPostRender()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		bool sRGBWrite = GL.sRGBWrite;
		RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
		RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
		GrabDepthTexture();
		Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		GL.sRGBWrite = sRGBWrite;
	}

	private float[] MatrixToFloatArray(Matrix4x4 m)
	{
		int i = 0;
		int num = 0;
		for (; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				matrixToFloatTemp[num++] = ((Matrix4x4)(ref m))[j, i];
			}
		}
		return matrixToFloatTemp;
	}

	private void PrepareAndDispatch()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)hiZWidth, (float)hiZHeight);
		ExtractFrustum(viewProjMatrix, ref frustumPlanes);
		bool flag = true;
		if (usePixelShaderFallback)
		{
			fallbackMat.SetTexture("_HiZMap", (Texture)(object)hiZTexture);
			fallbackMat.SetFloat("_HiZMaxLod", (float)(hiZLevelCount - 1));
			fallbackMat.SetMatrix("_ViewMatrix", viewMatrix);
			fallbackMat.SetMatrix("_ProjMatrix", projMatrix);
			fallbackMat.SetMatrix("_ViewProjMatrix", viewProjMatrix);
			fallbackMat.SetVector("_CameraWorldPos", Vector4.op_Implicit(((Component)this).transform.position));
			fallbackMat.SetVector("_ViewportSize", Vector4.op_Implicit(val));
			fallbackMat.SetFloat("_FrustumCull", flag ? 0f : 1f);
			for (int i = 0; i < 6; i++)
			{
				fallbackMat.SetVector(frustumPropNames[i], frustumPlanes[i]);
			}
		}
		else
		{
			computeShader.SetTexture(0, "_HiZMap", (Texture)(object)hiZTexture);
			computeShader.SetFloat("_HiZMaxLod", (float)(hiZLevelCount - 1));
			computeShader.SetFloats("_ViewMatrix", MatrixToFloatArray(viewMatrix));
			computeShader.SetFloats("_ProjMatrix", MatrixToFloatArray(projMatrix));
			computeShader.SetFloats("_ViewProjMatrix", MatrixToFloatArray(viewProjMatrix));
			computeShader.SetVector("_CameraWorldPos", Vector4.op_Implicit(((Component)this).transform.position));
			computeShader.SetVector("_ViewportSize", Vector4.op_Implicit(val));
			computeShader.SetFloat("_FrustumCull", flag ? 0f : 1f);
			for (int j = 0; j < 6; j++)
			{
				computeShader.SetVector(frustumPropNames[j], frustumPlanes[j]);
			}
		}
		if (staticOccludees.Count > 0)
		{
			UpdateBuffers(staticOccludees, staticStates, staticSet, staticChanged, isStatic: true);
			staticSet.Dispatch(staticOccludees.Count);
		}
		if (dynamicOccludees.Count > 0)
		{
			UpdateBuffers(dynamicOccludees, dynamicStates, dynamicSet, dynamicChanged, isStatic: false);
			dynamicSet.Dispatch(dynamicOccludees.Count);
		}
		UpdateGridBuffers();
		gridSet.Dispatch(grid.Size);
	}

	private void IssueRead()
	{
		if (staticOccludees.Count > 0)
		{
			staticSet.IssueRead();
		}
		if (dynamicOccludees.Count > 0)
		{
			dynamicSet.IssueRead();
		}
		if (grid.Count > 0)
		{
			gridSet.IssueRead();
		}
		GL.IssuePluginEvent(Graphics.GetRenderEventFunc(), 2);
	}

	public void ResetTiming(SmartList bucket)
	{
		for (int i = 0; i < bucket.Size; i++)
		{
			OccludeeState occludeeState = bucket[i];
			if (occludeeState != null)
			{
				occludeeState.states.array[occludeeState.slot].waitTime = 0f;
			}
		}
	}

	public void ResetTiming()
	{
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell != null)
			{
				ResetTiming(cell.staticBucket);
				ResetTiming(cell.dynamicBucket);
			}
		}
	}

	private void ProcessCallbacks(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, SimpleList<int> changed)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Expected O, but got Unknown
		for (int i = 0; i < changed.Count; i++)
		{
			int num = changed[i];
			OccludeeState occludeeState = occludees[num];
			if (occludeeState != null)
			{
				bool flag = states.array[num].isVisible == 0;
				OnVisibilityChanged onVisibilityChanged = occludeeState.onVisibilityChanged;
				if (onVisibilityChanged != null && (Object)onVisibilityChanged.Target != (Object)null)
				{
					onVisibilityChanged(flag);
				}
				if (occludeeState.slot >= 0)
				{
					states.array[occludeeState.slot].isVisible = (byte)(flag ? 1 : 0);
				}
			}
		}
		changed.Clear();
	}

	public void RetrieveAndApplyVisibility()
	{
		if (staticOccludees.Count > 0)
		{
			staticSet.GetResults();
		}
		if (dynamicOccludees.Count > 0)
		{
			dynamicSet.GetResults();
		}
		if (grid.Count > 0)
		{
			gridSet.GetResults();
		}
		if (debugSettings.showAllVisible)
		{
			for (int i = 0; i < staticSet.resultData.Length; i++)
			{
				staticSet.resultData[i].r = 1;
			}
			for (int j = 0; j < dynamicSet.resultData.Length; j++)
			{
				dynamicSet.resultData[j].r = 1;
			}
			for (int k = 0; k < gridSet.resultData.Length; k++)
			{
				gridSet.resultData[k].r = 1;
			}
		}
		staticVisibilityChanged.EnsureCapacity(staticOccludees.Count);
		dynamicVisibilityChanged.EnsureCapacity(dynamicOccludees.Count);
		float time = Time.time;
		uint frameCount = (uint)Time.frameCount;
		if (!Passthrough)
		{
			if (useNativePath)
			{
				ApplyVisibility_Native(time, frameCount);
			}
			else
			{
				ApplyVisibility_Fast(time, frameCount);
			}
		}
		else
		{
			ApplyVisibility_Passthrough(time, frameCount);
		}
		ProcessCallbacks(staticOccludees, staticStates, staticVisibilityChanged);
		ProcessCallbacks(dynamicOccludees, dynamicStates, dynamicVisibilityChanged);
	}

	public static bool DebugFilterIsDynamic(int filter)
	{
		if (filter != 1)
		{
			return filter == 4;
		}
		return true;
	}

	public static bool DebugFilterIsStatic(int filter)
	{
		if (filter != 2)
		{
			return filter == 4;
		}
		return true;
	}

	public static bool DebugFilterIsGrid(int filter)
	{
		if (filter != 3)
		{
			return filter == 4;
		}
		return true;
	}

	private void DebugInitialize()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		debugMipMat = new Material(Shader.Find("Hidden/OcclusionCulling/DebugMip"))
		{
			hideFlags = (HideFlags)61
		};
	}

	private void DebugShutdown()
	{
		if ((Object)(object)debugMipMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)debugMipMat);
			debugMipMat = null;
		}
	}

	private void DebugUpdate()
	{
		if (HiZReady)
		{
			debugSettings.showMainLod = Mathf.Clamp(debugSettings.showMainLod, 0, hiZLevels.Length - 1);
		}
	}

	private void DebugDraw()
	{
	}

	public static void NormalizePlane(ref Vector4 plane)
	{
		float num = Mathf.Sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);
		plane.x /= num;
		plane.y /= num;
		plane.z /= num;
		plane.w /= num;
	}

	public static void ExtractFrustum(Matrix4x4 viewProjMatrix, ref Vector4[] planes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		planes[0].x = viewProjMatrix.m30 + viewProjMatrix.m00;
		planes[0].y = viewProjMatrix.m31 + viewProjMatrix.m01;
		planes[0].z = viewProjMatrix.m32 + viewProjMatrix.m02;
		planes[0].w = viewProjMatrix.m33 + viewProjMatrix.m03;
		NormalizePlane(ref planes[0]);
		planes[1].x = viewProjMatrix.m30 - viewProjMatrix.m00;
		planes[1].y = viewProjMatrix.m31 - viewProjMatrix.m01;
		planes[1].z = viewProjMatrix.m32 - viewProjMatrix.m02;
		planes[1].w = viewProjMatrix.m33 - viewProjMatrix.m03;
		NormalizePlane(ref planes[1]);
		planes[2].x = viewProjMatrix.m30 - viewProjMatrix.m10;
		planes[2].y = viewProjMatrix.m31 - viewProjMatrix.m11;
		planes[2].z = viewProjMatrix.m32 - viewProjMatrix.m12;
		planes[2].w = viewProjMatrix.m33 - viewProjMatrix.m13;
		NormalizePlane(ref planes[2]);
		planes[3].x = viewProjMatrix.m30 + viewProjMatrix.m10;
		planes[3].y = viewProjMatrix.m31 + viewProjMatrix.m11;
		planes[3].z = viewProjMatrix.m32 + viewProjMatrix.m12;
		planes[3].w = viewProjMatrix.m33 + viewProjMatrix.m13;
		NormalizePlane(ref planes[3]);
		planes[4].x = viewProjMatrix.m20;
		planes[4].y = viewProjMatrix.m21;
		planes[4].z = viewProjMatrix.m22;
		planes[4].w = viewProjMatrix.m23;
		NormalizePlane(ref planes[4]);
		planes[5].x = viewProjMatrix.m30 - viewProjMatrix.m20;
		planes[5].y = viewProjMatrix.m31 - viewProjMatrix.m21;
		planes[5].z = viewProjMatrix.m32 - viewProjMatrix.m22;
		planes[5].w = viewProjMatrix.m33 - viewProjMatrix.m23;
		NormalizePlane(ref planes[5]);
	}

	public void CheckResizeHiZMap()
	{
		int pixelWidth = camera.pixelWidth;
		int pixelHeight = camera.pixelHeight;
		if (pixelWidth <= 0 || pixelHeight <= 0)
		{
			return;
		}
		int num = pixelWidth / 4;
		int num2 = pixelHeight / 4;
		if (hiZLevels == null || hiZWidth != num || hiZHeight != num2)
		{
			InitializeHiZMap(num, num2);
			hiZWidth = num;
			hiZHeight = num2;
			if (debugSettings.log)
			{
				Debug.Log((object)("[OcclusionCulling] Resized HiZ Map to " + hiZWidth + " x " + hiZHeight));
			}
		}
	}

	private void InitializeHiZMap()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		Shader val = Shader.Find("Hidden/OcclusionCulling/DepthDownscale");
		Shader val2 = Shader.Find("Hidden/OcclusionCulling/BlitCopy");
		downscaleMat = new Material(val)
		{
			hideFlags = (HideFlags)61
		};
		blitCopyMat = new Material(val2)
		{
			hideFlags = (HideFlags)61
		};
		CheckResizeHiZMap();
	}

	private void FinalizeHiZMap()
	{
		DestroyHiZMap();
		if ((Object)(object)downscaleMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)downscaleMat);
			downscaleMat = null;
		}
		if ((Object)(object)blitCopyMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)blitCopyMat);
			blitCopyMat = null;
		}
	}

	private void InitializeHiZMap(int width, int height)
	{
		DestroyHiZMap();
		width = Mathf.Clamp(width, 1, 65536);
		height = Mathf.Clamp(height, 1, 65536);
		int num = Mathf.Min(width, height);
		hiZLevelCount = (int)(Mathf.Log((float)num, 2f) + 1f);
		hiZLevels = (RenderTexture[])(object)new RenderTexture[hiZLevelCount];
		depthTexture = CreateDepthTexture("DepthTex", width, height);
		hiZTexture = CreateDepthTexture("HiZMapTex", width, height, mips: true);
		for (int i = 0; i < hiZLevelCount; i++)
		{
			hiZLevels[i] = CreateDepthTextureMip("HiZMap" + i, width, height, i);
		}
	}

	private void DestroyHiZMap()
	{
		if ((Object)(object)depthTexture != (Object)null)
		{
			RenderTexture.active = null;
			Object.DestroyImmediate((Object)(object)depthTexture);
			depthTexture = null;
		}
		if ((Object)(object)hiZTexture != (Object)null)
		{
			RenderTexture.active = null;
			Object.DestroyImmediate((Object)(object)hiZTexture);
			hiZTexture = null;
		}
		if (hiZLevels != null)
		{
			for (int i = 0; i < hiZLevels.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)hiZLevels[i]);
			}
			hiZLevels = null;
		}
	}

	private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		RenderTexture val = new RenderTexture(width, height, 0, (RenderTextureFormat)14, (RenderTextureReadWrite)1)
		{
			name = name,
			useMipMap = mips,
			autoGenerateMips = false,
			wrapMode = (TextureWrapMode)1,
			filterMode = (FilterMode)0
		};
		val.Create();
		return val;
	}

	private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		int num = width >> mip;
		int num2 = height >> mip;
		RenderTexture val = new RenderTexture(num, num2, 0, (RenderTextureFormat)14, (RenderTextureReadWrite)1)
		{
			name = name,
			useMipMap = false,
			wrapMode = (TextureWrapMode)1,
			filterMode = (FilterMode)0
		};
		val.Create();
		return val;
	}

	public void GrabDepthTexture()
	{
		if ((Object)(object)depthTexture != (Object)null)
		{
			Graphics.Blit((Texture)null, depthTexture, depthCopyMat, 0);
		}
	}

	public void GenerateHiZMipChain()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (HiZReady)
		{
			bool flag = true;
			depthCopyMat.SetMatrix("_CameraReprojection", prevViewProjMatrix * invViewProjMatrix);
			depthCopyMat.SetFloat("_FrustumNoDataDepth", flag ? 1f : 0f);
			Graphics.Blit((Texture)(object)depthTexture, hiZLevels[0], depthCopyMat, 1);
			for (int i = 1; i < hiZLevels.Length; i++)
			{
				RenderTexture val = hiZLevels[i - 1];
				RenderTexture val2 = hiZLevels[i];
				int num = (((((Texture)val).width & 1) != 0 || (((Texture)val).height & 1) != 0) ? 1 : 0);
				downscaleMat.SetTexture("_MainTex", (Texture)(object)val);
				Graphics.Blit((Texture)(object)val, val2, downscaleMat, num);
			}
			for (int j = 0; j < hiZLevels.Length; j++)
			{
				Graphics.SetRenderTarget(hiZTexture, j);
				Graphics.Blit((Texture)(object)hiZLevels[j], blitCopyMat);
			}
		}
	}

	private void DebugDrawGizmos()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Camera component = ((Component)this).GetComponent<Camera>();
		Gizmos.color = new Color(0.75f, 0.75f, 0f, 0.5f);
		Gizmos.matrix = Matrix4x4.TRS(((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one);
		Gizmos.DrawFrustum(Vector3.zero, component.fieldOfView, component.farClipPlane, component.nearClipPlane, component.aspect);
		Gizmos.color = Color.red;
		Gizmos.matrix = Matrix4x4.identity;
		Matrix4x4 worldToCameraMatrix = component.worldToCameraMatrix;
		Matrix4x4 val = GL.GetGPUProjectionMatrix(component.projectionMatrix, false) * worldToCameraMatrix;
		Vector4[] planes = (Vector4[])(object)new Vector4[6];
		ExtractFrustum(val, ref planes);
		for (int i = 0; i < planes.Length; i++)
		{
			Vector3 val2 = new Vector3(planes[i].x, planes[i].y, planes[i].z);
			float w = planes[i].w;
			Vector3 val3 = -val2 * w;
			Gizmos.DrawLine(val3, val3 * 2f);
		}
	}

	private static int floor(float x)
	{
		int num = (int)x;
		if (!(x < (float)num))
		{
			return num;
		}
		return num - 1;
	}

	public static Cell RegisterToGrid(OccludeeState occludee)
	{
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		int num = floor(occludee.states.array[occludee.slot].sphereBounds.x * 0.01f);
		int num2 = floor(occludee.states.array[occludee.slot].sphereBounds.y * 0.01f);
		int num3 = floor(occludee.states.array[occludee.slot].sphereBounds.z * 0.01f);
		int num4 = Mathf.Clamp(num, -1048575, 1048575);
		int num5 = Mathf.Clamp(num2, -1048575, 1048575);
		int num6 = Mathf.Clamp(num3, -1048575, 1048575);
		long num7 = ((num4 >= 0) ? num4 : (num4 + 1048575));
		ulong num8 = (ulong)((num5 >= 0) ? num5 : (num5 + 1048575));
		ulong num9 = (ulong)((num6 >= 0) ? num6 : (num6 + 1048575));
		ulong key = (ulong)(num7 << 42) | (num8 << 21) | num9;
		Cell value;
		bool num10 = grid.TryGetValue(key, out value);
		if (!num10)
		{
			Vector3 val = new Vector3
			{
				x = (float)num * 100f + 50f,
				y = (float)num2 * 100f + 50f,
				z = (float)num3 * 100f + 50f
			};
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(100f, 100f, 100f);
			value = grid.Add(key).Initialize(num, num2, num3, new Bounds(val, val2));
		}
		SmartList smartList = (occludee.isStatic ? value.staticBucket : value.dynamicBucket);
		if (!num10 || !smartList.Contains(occludee))
		{
			occludee.cell = value;
			smartList.Add(occludee);
			gridChanged.Enqueue(value);
		}
		return value;
	}

	public static void UpdateInGrid(OccludeeState occludee)
	{
		int num = floor(occludee.states.array[occludee.slot].sphereBounds.x * 0.01f);
		int num2 = floor(occludee.states.array[occludee.slot].sphereBounds.y * 0.01f);
		int num3 = floor(occludee.states.array[occludee.slot].sphereBounds.z * 0.01f);
		if (num != occludee.cell.x || num2 != occludee.cell.y || num3 != occludee.cell.z)
		{
			UnregisterFromGrid(occludee);
			RegisterToGrid(occludee);
		}
	}

	public static void UnregisterFromGrid(OccludeeState occludee)
	{
		Cell cell = occludee.cell;
		SmartList obj = (occludee.isStatic ? cell.staticBucket : cell.dynamicBucket);
		gridChanged.Enqueue(cell);
		obj.Remove(occludee);
		if (cell.staticBucket.Count == 0 && cell.dynamicBucket.Count == 0)
		{
			grid.Remove(cell);
			cell.Reset();
		}
		occludee.cell = null;
	}

	public void UpdateGridBuffers()
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		if (gridSet.CheckResize(grid.Size, 256))
		{
			if (debugSettings.log)
			{
				Debug.Log((object)("[OcclusionCulling] Resized grid to " + grid.Size));
			}
			for (int i = 0; i < grid.Size; i++)
			{
				if (grid[i] != null)
				{
					gridChanged.Enqueue(grid[i]);
				}
			}
		}
		bool flag = gridChanged.Count > 0;
		while (gridChanged.Count > 0)
		{
			Cell cell = gridChanged.Dequeue();
			gridSet.inputData[cell.hashedPoolIndex] = Color.op_Implicit(cell.sphereBounds);
		}
		if (flag)
		{
			gridSet.UploadData();
		}
	}

	private static bool FrustumCull(Vector4[] planes, Vector4 testSphere)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 6; i++)
		{
			if (planes[i].x * testSphere.x + planes[i].y * testSphere.y + planes[i].z * testSphere.z + planes[i].w < 0f - testSphere.w)
			{
				return false;
			}
		}
		return true;
	}

	private static int ProcessOccludees_Safe(SimpleList<OccludeeState.State> states, SmartList bucket, Color32[] results, SimpleList<int> changed, Vector4[] frustumPlanes, float time, uint frame)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < bucket.Size; i++)
		{
			OccludeeState occludeeState = bucket[i];
			if (occludeeState == null || occludeeState.slot >= results.Length)
			{
				continue;
			}
			int slot = occludeeState.slot;
			OccludeeState.State value = states[slot];
			bool flag = FrustumCull(frustumPlanes, value.sphereBounds);
			bool flag2 = results[slot].r > 0 && flag;
			if (flag2 || frame < value.waitFrame)
			{
				value.waitTime = time + value.minTimeVisible;
			}
			if (!flag2)
			{
				flag2 = time < value.waitTime;
			}
			if (flag2 != (value.isVisible != 0))
			{
				if (value.callback != 0)
				{
					changed.Add(slot);
				}
				else
				{
					value.isVisible = (byte)(flag2 ? 1 : 0);
				}
			}
			states[slot] = value;
			num += value.isVisible;
		}
		return num;
	}

	private static int ProcessOccludees_Fast(OccludeeState.State[] states, int[] bucket, int bucketCount, Color32[] results, int resultCount, int[] changed, ref int changedCount, Vector4[] frustumPlanes, float time, uint frame)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < bucketCount; i++)
		{
			int num2 = bucket[i];
			if (num2 < 0 || num2 >= resultCount || states[num2].active == 0)
			{
				continue;
			}
			OccludeeState.State state = states[num2];
			bool flag = FrustumCull(frustumPlanes, state.sphereBounds);
			bool flag2 = results[num2].r > 0 && flag;
			if (flag2 || frame < state.waitFrame)
			{
				state.waitTime = time + state.minTimeVisible;
			}
			if (!flag2)
			{
				flag2 = time < state.waitTime;
			}
			if (flag2 != (state.isVisible != 0))
			{
				if (state.callback != 0)
				{
					changed[changedCount++] = num2;
				}
				else
				{
					state.isVisible = (byte)(flag2 ? 1 : 0);
				}
			}
			states[num2] = state;
			num += ((!flag2) ? 1 : 0);
		}
		return num;
	}

	[DllImport("Renderer", EntryPoint = "CULL_ProcessOccludees")]
	private static extern int ProcessOccludees_Native(ref OccludeeState.State states, ref int bucket, int bucketCount, ref Color32 results, int resultCount, ref int changed, ref int changedCount, ref Vector4 frustumPlanes, float time, uint frame);

	private void ApplyVisibility_Safe(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Safe(staticStates, cell.staticBucket, staticSet.resultData, staticVisibilityChanged, frustumPlanes, time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Safe(dynamicStates, cell.dynamicBucket, dynamicSet.resultData, dynamicVisibilityChanged, frustumPlanes, time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Fast(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Fast(staticStates.array, cell.staticBucket.Slots, cell.staticBucket.Size, staticSet.resultData, staticSet.resultData.Length, staticVisibilityChanged.array, ref staticVisibilityChanged.count, frustumPlanes, time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Fast(dynamicStates.array, cell.dynamicBucket.Slots, cell.dynamicBucket.Size, dynamicSet.resultData, dynamicSet.resultData.Length, dynamicVisibilityChanged.array, ref dynamicVisibilityChanged.count, frustumPlanes, time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Native(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Native(ref staticStates.array[0], ref cell.staticBucket.Slots[0], cell.staticBucket.Size, ref staticSet.resultData[0], staticSet.resultData.Length, ref staticVisibilityChanged.array[0], ref staticVisibilityChanged.count, ref frustumPlanes[0], time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Native(ref dynamicStates.array[0], ref cell.dynamicBucket.Slots[0], cell.dynamicBucket.Size, ref dynamicSet.resultData[0], dynamicSet.resultData.Length, ref dynamicVisibilityChanged.array[0], ref dynamicVisibilityChanged.count, ref frustumPlanes[0], time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Passthrough(float time, uint frame)
	{
		OccludeeState.State[] array = staticStates.array;
		OccludeeState.State[] array2 = dynamicStates.array;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null)
			{
				continue;
			}
			int[] slots = cell.staticBucket.Slots;
			int size = cell.staticBucket.Size;
			int num = staticSet.resultData.Length;
			for (int j = 0; j < size; j++)
			{
				int num2 = slots[j];
				if (num2 >= 0 && num2 < num && array[num2].active != 0 && array[num2].isVisible == 0)
				{
					if (array[num2].callback != 0)
					{
						staticVisibilityChanged.array[staticVisibilityChanged.count++] = num2;
					}
					else
					{
						array[num2].isVisible = 1;
					}
				}
			}
			int[] slots2 = cell.dynamicBucket.Slots;
			int size2 = cell.dynamicBucket.Size;
			int num3 = dynamicSet.resultData.Length;
			for (int k = 0; k < size2; k++)
			{
				int num4 = slots2[k];
				if (num4 >= 0 && num4 < num3 && array2[num4].active != 0 && array2[num4].isVisible == 0)
				{
					if (array2[num4].callback != 0)
					{
						dynamicVisibilityChanged.array[dynamicVisibilityChanged.count++] = num4;
					}
					else
					{
						array2[num4].isVisible = 1;
					}
				}
			}
			cell.isVisible = true;
		}
	}
}


using System;
using System.Collections.Generic;
using RustNative;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public ComputeBuffer inputBuffer;

	public ComputeBuffer resultBuffer;

	public int width;

	public int height;

	public int capacity;

	public int count;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Texture2D resultReadTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private OcclusionCulling culling;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public IntPtr readbackInst = IntPtr.Zero;

	public bool Ready => resultData.Length != 0;

	public void Attach(OcclusionCulling culling)
	{
		this.culling = culling;
	}

	public void Dispose(bool data = true)
	{
		if (inputBuffer != null)
		{
			inputBuffer.Dispose();
			inputBuffer = null;
		}
		if (resultBuffer != null)
		{
			resultBuffer.Dispose();
			resultBuffer = null;
		}
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if ((Object)(object)resultReadTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)resultReadTexture);
			resultReadTexture = null;
		}
		if (readbackInst != IntPtr.Zero)
		{
			BufferReadback.Destroy(readbackInst);
			readbackInst = IntPtr.Zero;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
			capacity = 0;
			count = 0;
		}
	}

	public bool CheckResize(int count, int granularity)
	{
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Expected O, but got Unknown
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Expected O, but got Unknown
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Expected O, but got Unknown
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Expected O, but got Unknown
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Expected O, but got Unknown
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Expected I4, but got Unknown
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		if (count > capacity || (culling.usePixelShaderFallback && (Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			int num = capacity;
			int num2 = count / granularity * granularity + granularity;
			if (culling.usePixelShaderFallback)
			{
				width = Mathf.CeilToInt(Mathf.Sqrt((float)num2));
				height = Mathf.CeilToInt((float)num2 / (float)width);
				inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
				((Object)inputTexture).name = "_Input";
				((Texture)inputTexture).filterMode = (FilterMode)0;
				((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
				resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
				((Object)resultTexture).name = "_Result";
				((Texture)resultTexture).filterMode = (FilterMode)0;
				((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				resultReadTexture = new Texture2D(width, height, (TextureFormat)5, false, true);
				((Object)resultReadTexture).name = "_ResultRead";
				((Texture)resultReadTexture).filterMode = (FilterMode)0;
				((Texture)resultReadTexture).wrapMode = (TextureWrapMode)1;
				if (!culling.useAsyncReadAPI)
				{
					readbackInst = BufferReadback.CreateForTexture(((Texture)resultTexture).GetNativeTexturePtr(), (uint)width, (uint)height, (uint)(int)resultTexture.format);
				}
				capacity = width * height;
			}
			else
			{
				inputBuffer = new ComputeBuffer(num2, 16);
				resultBuffer = new ComputeBuffer(num2, 4);
				if (!culling.useAsyncReadAPI)
				{
					uint num3 = (uint)(capacity * 4);
					readbackInst = BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), num3);
				}
				capacity = num2;
			}
			Array.Resize(ref inputData, capacity);
			Array.Resize(ref resultData, capacity);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
			for (int i = num; i < capacity; i++)
			{
				resultData[i] = val;
			}
			this.count = count;
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (culling.usePixelShaderFallback)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
		else
		{
			inputBuffer.SetData((Array)inputData);
		}
	}

	private int AlignDispatchSize(int dispatchSize)
	{
		return (dispatchSize + 63) / 64;
	}

	public void Dispatch(int count)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (culling.usePixelShaderFallback)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			culling.fallbackMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, culling.fallbackMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
		else if (inputBuffer != null)
		{
			culling.computeShader.SetBuffer(0, "_Input", inputBuffer);
			culling.computeShader.SetBuffer(0, "_Result", resultBuffer);
			culling.computeShader.Dispatch(0, AlignDispatchSize(count), 1, 1);
		}
	}

	public void IssueRead()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (SafeMode)
		{
			return;
		}
		if (culling.useAsyncReadAPI)
		{
			if (asyncRequests.Count < 10)
			{
				AsyncGPUReadbackRequest item = ((!culling.usePixelShaderFallback) ? AsyncGPUReadback.Request(resultBuffer, (Action<AsyncGPUReadbackRequest>)null) : AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
				asyncRequests.Enqueue(item);
			}
		}
		else if (readbackInst != IntPtr.Zero)
		{
			BufferReadback.IssueRead(readbackInst);
		}
	}

	public void GetResults()
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (resultData == null || resultData.Length == 0)
		{
			return;
		}
		if (!SafeMode)
		{
			if (culling.useAsyncReadAPI)
			{
				while (asyncRequests.Count > 0)
				{
					AsyncGPUReadbackRequest val = asyncRequests.Peek();
					if (((AsyncGPUReadbackRequest)(ref val)).hasError)
					{
						asyncRequests.Dequeue();
						continue;
					}
					if (((AsyncGPUReadbackRequest)(ref val)).done)
					{
						NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
						for (int i = 0; i < data.Length; i++)
						{
							resultData[i] = data[i];
						}
						asyncRequests.Dequeue();
						continue;
					}
					break;
				}
			}
			else if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.GetData(readbackInst, ref resultData[0]);
			}
		}
		else if (culling.usePixelShaderFallback)
		{
			RenderTexture.active = resultTexture;
			resultReadTexture.ReadPixels(new Rect(0f, 0f, (float)width, (float)height), 0, 0);
			resultReadTexture.Apply();
			Array.Copy(resultReadTexture.GetPixels32(), resultData, resultData.Length);
		}
		else
		{
			resultBuffer.GetData((Array)resultData);
		}
	}
}


public delegate void OnVisibilityChanged(bool visible);


public enum DebugFilter
{
	Off,
	Dynamic,
	Static,
	Grid,
	All
}


using System;

[Flags]
public enum DebugMask
{
	Off = 0,
	Dynamic = 1,
	Static = 2,
	Grid = 4,
	All = 7
}


using System;
using UnityEngine;

[Serializable]
public class DebugSettings
{
	public bool log;

	public bool showAllVisible;

	public bool showMipChain;

	public bool showMain;

	public int showMainLod;

	public bool showFallback;

	public bool showStats;

	public bool showScreenBounds;

	public DebugMask showMask;

	public LayerMask layerFilter = LayerMask.op_Implicit(-1);
}


public class HashedPoolValue
{
	public ulong hashedPoolKey = ulong.MaxValue;

	public int hashedPoolIndex = -1;
}


using System.Collections.Generic;

public class HashedPool<TValueType> where TValueType : HashedPoolValue, new()
{
	private int granularity;

	private Dictionary<ulong, TValueType> dict;

	private List<TValueType> pool;

	private List<TValueType> list;

	private Queue<TValueType> recycled;

	public int Size => list.Count;

	public int Count => dict.Count;

	public TValueType this[int i]
	{
		get
		{
			return list[i];
		}
		set
		{
			list[i] = value;
		}
	}

	public HashedPool(int capacity, int granularity)
	{
		this.granularity = granularity;
		dict = new Dictionary<ulong, TValueType>(capacity);
		pool = new List<TValueType>(capacity);
		list = new List<TValueType>(capacity);
		recycled = new Queue<TValueType>();
	}

	public void Clear()
	{
		dict.Clear();
		pool.Clear();
		list.Clear();
		recycled.Clear();
	}

	public TValueType Add(ulong key, int capacityGranularity = 16)
	{
		TValueType val;
		if (recycled.Count > 0)
		{
			val = recycled.Dequeue();
			list[val.hashedPoolIndex] = val;
		}
		else
		{
			int count = pool.Count;
			if (count == pool.Capacity)
			{
				pool.Capacity += granularity;
			}
			val = new TValueType
			{
				hashedPoolIndex = count
			};
			pool.Add(val);
			list.Add(val);
		}
		val.hashedPoolKey = key;
		dict.Add(key, val);
		return val;
	}

	public void Remove(TValueType value)
	{
		dict.Remove(value.hashedPoolKey);
		list[value.hashedPoolIndex] = null;
		recycled.Enqueue(value);
		value.hashedPoolKey = ulong.MaxValue;
	}

	public bool TryGetValue(ulong key, out TValueType value)
	{
		return dict.TryGetValue(key, out value);
	}

	public bool ContainsKey(ulong key)
	{
		return dict.ContainsKey(key);
	}
}


using System;

public class SimpleList<T>
{
	private const int defaultCapacity = 16;

	private static readonly T[] emptyArray = new T[0];

	public T[] array;

	public int count;

	public int Count => count;

	public int Capacity
	{
		get
		{
			return array.Length;
		}
		set
		{
			if (value == array.Length)
			{
				return;
			}
			if (value > 0)
			{
				T[] destinationArray = new T[value];
				if (count > 0)
				{
					Array.Copy(array, 0, destinationArray, 0, count);
				}
				array = destinationArray;
			}
			else
			{
				array = emptyArray;
			}
		}
	}

	public T this[int index]
	{
		get
		{
			return array[index];
		}
		set
		{
			array[index] = value;
		}
	}

	public SimpleList()
	{
		array = emptyArray;
	}

	public SimpleList(int capacity)
	{
		array = ((capacity == 0) ? emptyArray : new T[capacity]);
	}

	public void Add(T item)
	{
		if (count == array.Length)
		{
			EnsureCapacity(count + 1);
		}
		array[count++] = item;
	}

	public void Clear()
	{
		if (count > 0)
		{
			Array.Clear(array, 0, count);
			count = 0;
		}
	}

	public bool Contains(T item)
	{
		for (int i = 0; i < count; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public void CopyTo(T[] array)
	{
		Array.Copy(this.array, 0, array, 0, count);
	}

	public void EnsureCapacity(int min)
	{
		if (array.Length < min)
		{
			int num = ((array.Length == 0) ? 16 : (array.Length * 2));
			num = ((num < min) ? min : num);
			Capacity = num;
		}
	}
}


public class SmartListValue
{
	public int hashedListIndex = -1;
}


using System;
using System.Collections.Generic;

public class SmartList
{
	private const int defaultCapacity = 16;

	private static readonly OccludeeState[] emptyList = new OccludeeState[0];

	private static readonly int[] emptySlots = new int[0];

	private OccludeeState[] list;

	private int[] slots;

	private Queue<int> recycled;

	private int count;

	public OccludeeState[] List => list;

	public int[] Slots => slots;

	public int Size => count;

	public int Count => count - recycled.Count;

	public OccludeeState this[int i]
	{
		get
		{
			return list[i];
		}
		set
		{
			list[i] = value;
		}
	}

	public int Capacity
	{
		get
		{
			return list.Length;
		}
		set
		{
			if (value == list.Length)
			{
				return;
			}
			if (value > 0)
			{
				OccludeeState[] destinationArray = new OccludeeState[value];
				int[] destinationArray2 = new int[value];
				if (count > 0)
				{
					Array.Copy(list, destinationArray, count);
					Array.Copy(slots, destinationArray2, count);
				}
				list = destinationArray;
				slots = destinationArray2;
			}
			else
			{
				list = emptyList;
				slots = emptySlots;
			}
		}
	}

	public SmartList(int capacity)
	{
		list = new OccludeeState[capacity];
		slots = new int[capacity];
		recycled = new Queue<int>();
		count = 0;
	}

	public void Add(OccludeeState value, int capacityGranularity = 16)
	{
		int num;
		if (recycled.Count > 0)
		{
			num = recycled.Dequeue();
			list[num] = value;
			slots[num] = value.slot;
		}
		else
		{
			num = count;
			if (num == list.Length)
			{
				EnsureCapacity(count + 1);
			}
			list[num] = value;
			slots[num] = value.slot;
			count++;
		}
		value.hashedListIndex = num;
	}

	public void Remove(OccludeeState value)
	{
		int hashedListIndex = value.hashedListIndex;
		list[hashedListIndex] = null;
		slots[hashedListIndex] = -1;
		recycled.Enqueue(hashedListIndex);
		value.hashedListIndex = -1;
	}

	public bool Contains(OccludeeState value)
	{
		int hashedListIndex = value.hashedListIndex;
		if (hashedListIndex >= 0)
		{
			return list[hashedListIndex] != null;
		}
		return false;
	}

	public void EnsureCapacity(int min)
	{
		if (list.Length < min)
		{
			int num = ((list.Length == 0) ? 16 : (list.Length * 2));
			num = ((num < min) ? min : num);
			Capacity = num;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Cell : HashedPoolValue
{
	public int x;

	public int y;

	public int z;

	public Bounds bounds;

	public Vector4 sphereBounds;

	public bool isVisible;

	public SmartList staticBucket;

	public SmartList dynamicBucket;

	public void Reset()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		x = (y = (z = 0));
		bounds = default(Bounds);
		sphereBounds = Vector4.zero;
		isVisible = true;
		staticBucket = null;
		dynamicBucket = null;
	}

	public Cell Initialize(int x, int y, int z, Bounds bounds)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		this.x = x;
		this.y = y;
		this.z = z;
		this.bounds = bounds;
		float num = ((Bounds)(ref bounds)).center.x;
		float num2 = ((Bounds)(ref bounds)).center.y;
		float num3 = ((Bounds)(ref bounds)).center.z;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		sphereBounds = new Vector4(num, num2, num3, ((Vector3)(ref extents)).magnitude);
		isVisible = true;
		staticBucket = new SmartList(32);
		dynamicBucket = new SmartList(32);
		return this;
	}
}


using UnityEngine;

public struct Sphere
{
	public Vector3 position;

	public float radius;

	public bool IsValid()
	{
		return radius > 0f;
	}

	public Sphere(Vector3 position, float radius)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.position = position;
		this.radius = radius;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Sonic Ether/SE Screen-Space Shadows")]
public class SEScreenSpaceShadows : SingletonComponent<SEScreenSpaceShadows>, IClientComponent
{
	private CommandBuffer blendShadowsCommandBuffer;

	private CommandBuffer renderShadowsCommandBuffer;

	private Camera attachedCamera;

	public Light sun;

	[Range(0f, 1f)]
	public float blendStrength = 1f;

	[Range(0f, 1f)]
	public float accumulation = 0.9f;

	[Range(0.1f, 5f)]
	public float lengthFade = 0.7f;

	[Range(0.01f, 5f)]
	public float range = 0.7f;

	[Range(0f, 1f)]
	public float zThickness = 0.1f;

	[Range(2f, 92f)]
	public int samples = 32;

	[Range(0.5f, 4f)]
	public float nearSampleQuality = 1.5f;

	[Range(0f, 1f)]
	public float traceBias = 0.03f;

	public bool stochasticSampling = true;

	public bool leverageTemporalAA;

	public bool bilateralBlur = true;

	[Range(1f, 2f)]
	public int blurPasses = 1;

	[Range(0.01f, 0.5f)]
	public float blurDepthTolerance = 0.1f;
}


using UnityEngine;

public class VTP : MonoBehaviour
{
	public static Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i++)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		return colors[num2];
	}

	public static Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = triangles[triangleIndex * 3];
		return (colors[num] + colors[num + 1] + colors[num + 2]) / 3f;
	}

	public static void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i += 3)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		Color val = VertexColorLerp(colors[num2], color, strength);
		colors[num2] = val;
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors = colors;
	}

	public static void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = 0;
		for (int i = 0; i < 3; i++)
		{
			num = triangles[triangleIndex * 3 + i];
			Color val = VertexColorLerp(colors[num], color, strength);
			colors[num] = val;
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors = colors;
	}

	public static void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Vector3[] normals = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.normals;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i++)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		int num4 = 1;
		if (!up)
		{
			num4 = -1;
		}
		ref Vector3 reference = ref vertices[num2];
		reference += (float)num4 * 0.1f * strength * normals[num2];
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices = vertices;
		if (recalculateNormals)
		{
			((Component)transform).GetComponent<MeshFilter>().sharedMesh.RecalculateNormals();
		}
		if (recalculateCollider)
		{
			((Component)transform).GetComponent<MeshCollider>().sharedMesh = ((Component)transform).GetComponent<MeshFilter>().sharedMesh;
		}
		if (recalculateFlow)
		{
			Vector4[] array = calculateMeshTangents(triangles, vertices, ((Component)transform).GetComponent<MeshCollider>().sharedMesh.uv, normals);
			((Component)transform).GetComponent<MeshCollider>().sharedMesh.tangents = array;
			recalculateMeshForFlow(transform, vertices, normals, array);
		}
	}

	public static void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Vector3[] normals = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.normals;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = 0;
		int num2 = 1;
		if (!up)
		{
			num2 = -1;
		}
		for (int i = 0; i < 3; i++)
		{
			num = triangles[triangleIndex * 3 + i];
			ref Vector3 reference = ref vertices[num];
			reference += (float)num2 * 0.1f * strength * normals[num];
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices = vertices;
		if (recalculateNormals)
		{
			((Component)transform).GetComponent<MeshFilter>().sharedMesh.RecalculateNormals();
		}
		if (recalculateCollider)
		{
			((Component)transform).GetComponent<MeshCollider>().sharedMesh = ((Component)transform).GetComponent<MeshFilter>().sharedMesh;
		}
		if (recalculateFlow)
		{
			Vector4[] array = calculateMeshTangents(triangles, vertices, ((Component)transform).GetComponent<MeshCollider>().sharedMesh.uv, normals);
			((Component)transform).GetComponent<MeshCollider>().sharedMesh.tangents = array;
			recalculateMeshForFlow(transform, vertices, normals, array);
		}
	}

	private static void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Vector2[] uv = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.uv4;
		for (int i = 0; i < currentVertices.Length; i++)
		{
			Vector3 val = Vector3.Cross(currentNormals[i], new Vector3(currentTangents[i].x, currentTangents[i].y, currentTangents[i].z));
			Vector3 val2 = transform.TransformDirection(((Vector3)(ref val)).normalized * currentTangents[i].w);
			Vector3 val3 = transform.TransformDirection(Vector4.op_Implicit(((Vector4)(ref currentTangents[i])).normalized));
			float num = 0.5f + 0.5f * val3.y;
			float num2 = 0.5f + 0.5f * val2.y;
			uv[i] = new Vector2(num, num2);
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.uv4 = uv;
	}

	private static Vector4[] calculateMeshTangents(int[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		int num = triangles.Length;
		int num2 = vertices.Length;
		Vector3[] array = (Vector3[])(object)new Vector3[num2];
		Vector3[] array2 = (Vector3[])(object)new Vector3[num2];
		Vector4[] array3 = (Vector4[])(object)new Vector4[num2];
		Vector3 val7 = default(Vector3);
		Vector3 val8 = default(Vector3);
		for (long num3 = 0L; num3 < num; num3 += 3)
		{
			long num4 = triangles[num3];
			long num5 = triangles[num3 + 1];
			long num6 = triangles[num3 + 2];
			Vector3 val = vertices[num4];
			Vector3 val2 = vertices[num5];
			Vector3 val3 = vertices[num6];
			Vector2 val4 = uv[num4];
			Vector2 val5 = uv[num5];
			Vector2 val6 = uv[num6];
			float num7 = val2.x - val.x;
			float num8 = val3.x - val.x;
			float num9 = val2.y - val.y;
			float num10 = val3.y - val.y;
			float num11 = val2.z - val.z;
			float num12 = val3.z - val.z;
			float num13 = val5.x - val4.x;
			float num14 = val6.x - val4.x;
			float num15 = val5.y - val4.y;
			float num16 = val6.y - val4.y;
			float num17 = num13 * num16 - num14 * num15;
			float num18 = ((num17 == 0f) ? 0f : (1f / num17));
			((Vector3)(ref val7))..ctor((num16 * num7 - num15 * num8) * num18, (num16 * num9 - num15 * num10) * num18, (num16 * num11 - num15 * num12) * num18);
			((Vector3)(ref val8))..ctor((num13 * num8 - num14 * num7) * num18, (num13 * num10 - num14 * num9) * num18, (num13 * num12 - num14 * num11) * num18);
			ref Vector3 reference = ref array[num4];
			reference += val7;
			ref Vector3 reference2 = ref array[num5];
			reference2 += val7;
			ref Vector3 reference3 = ref array[num6];
			reference3 += val7;
			ref Vector3 reference4 = ref array2[num4];
			reference4 += val8;
			ref Vector3 reference5 = ref array2[num5];
			reference5 += val8;
			ref Vector3 reference6 = ref array2[num6];
			reference6 += val8;
		}
		for (long num19 = 0L; num19 < num2; num19++)
		{
			Vector3 val9 = normals[num19];
			Vector3 val10 = array[num19];
			Vector3.OrthoNormalize(ref val9, ref val10);
			array3[num19].x = val10.x;
			array3[num19].y = val10.y;
			array3[num19].z = val10.z;
			array3[num19].w = ((Vector3.Dot(Vector3.Cross(val9, val10), array2[num19]) < 0f) ? (-1f) : 1f);
		}
		return array3;
	}

	public static Color VertexColorLerp(Color colorA, Color colorB, float value)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (value >= 1f)
		{
			return colorB;
		}
		if (value <= 0f)
		{
			return colorA;
		}
		return new Color(colorA.r + (colorB.r - colorA.r) * value, colorA.g + (colorB.g - colorA.g) * value, colorA.b + (colorB.b - colorA.b) * value, colorA.a + (colorB.a - colorA.a) * value);
	}
}


using System;
using UnityEngine;

[Serializable]
public class MeshHolder
{
	[HideInInspector]
	public Vector3[] _vertices;

	[HideInInspector]
	public Vector3[] _normals;

	[HideInInspector]
	public int[] _triangles;

	[HideInInspector]
	public trisPerSubmesh[] _TrianglesOfSubs;

	[HideInInspector]
	public Matrix4x4[] _bindPoses;

	[HideInInspector]
	public BoneWeight[] _boneWeights;

	[HideInInspector]
	public Bounds _bounds;

	[HideInInspector]
	public int _subMeshCount;

	[HideInInspector]
	public Vector4[] _tangents;

	[HideInInspector]
	public Vector2[] _uv;

	[HideInInspector]
	public Vector2[] _uv2;

	[HideInInspector]
	public Vector2[] _uv3;

	[HideInInspector]
	public Color[] _colors;

	[HideInInspector]
	public Vector2[] _uv4;

	public void setAnimationData(Mesh mesh)
	{
		_colors = mesh.colors;
	}
}


using System;

[Serializable]
public class trisPerSubmesh
{
	public int[] triangles;
}


using System.Collections.Generic;
using UnityEngine;

public class VertexColorAnimator : MonoBehaviour
{
	public List<MeshHolder> animationMeshes;

	public List<float> animationKeyframes;

	public float timeScale = 2f;

	public int mode;

	private float elapsedTime;

	public void initLists()
	{
		animationMeshes = new List<MeshHolder>();
		animationKeyframes = new List<float>();
	}

	public void addMesh(Mesh mesh, float atPosition)
	{
		MeshHolder meshHolder = new MeshHolder();
		meshHolder.setAnimationData(mesh);
		animationMeshes.Add(meshHolder);
		animationKeyframes.Add(atPosition);
	}

	private void Start()
	{
		elapsedTime = 0f;
	}

	public void replaceKeyframe(int frameIndex, Mesh mesh)
	{
		animationMeshes[frameIndex].setAnimationData(mesh);
	}

	public void deleteKeyframe(int frameIndex)
	{
		animationMeshes.RemoveAt(frameIndex);
		animationKeyframes.RemoveAt(frameIndex);
	}

	public void scrobble(float scrobblePos)
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (animationMeshes.Count == 0)
		{
			return;
		}
		Color[] array = (Color[])(object)new Color[((Component)this).GetComponent<MeshFilter>().sharedMesh.colors.Length];
		int num = 0;
		for (int i = 0; i < animationKeyframes.Count; i++)
		{
			if (scrobblePos >= animationKeyframes[i])
			{
				num = i;
			}
		}
		if (num >= animationKeyframes.Count - 1)
		{
			((Component)this).GetComponent<VertexColorStream>().setColors(animationMeshes[num]._colors);
			return;
		}
		float num2 = animationKeyframes[num + 1] - animationKeyframes[num];
		float num3 = animationKeyframes[num];
		float num4 = (scrobblePos - num3) / num2;
		for (int j = 0; j < array.Length; j++)
		{
			array[j] = Color.Lerp(animationMeshes[num]._colors[j], animationMeshes[num + 1]._colors[j], num4);
		}
		((Component)this).GetComponent<VertexColorStream>().setColors(array);
	}

	private void Update()
	{
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		if (mode == 0)
		{
			elapsedTime += Time.fixedDeltaTime / timeScale;
		}
		else if (mode == 1)
		{
			elapsedTime += Time.fixedDeltaTime / timeScale;
			if (elapsedTime > 1f)
			{
				elapsedTime = 0f;
			}
		}
		else if (mode == 2)
		{
			if (Mathf.FloorToInt(Time.fixedTime / timeScale) % 2 == 0)
			{
				elapsedTime += Time.fixedDeltaTime / timeScale;
			}
			else
			{
				elapsedTime -= Time.fixedDeltaTime / timeScale;
			}
		}
		Color[] array = (Color[])(object)new Color[((Component)this).GetComponent<MeshFilter>().sharedMesh.colors.Length];
		int num = 0;
		for (int i = 0; i < animationKeyframes.Count; i++)
		{
			if (elapsedTime >= animationKeyframes[i])
			{
				num = i;
			}
		}
		if (num < animationKeyframes.Count - 1)
		{
			float num2 = animationKeyframes[num + 1] - animationKeyframes[num];
			float num3 = animationKeyframes[num];
			float num4 = (elapsedTime - num3) / num2;
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = Color.Lerp(animationMeshes[num]._colors[j], animationMeshes[num + 1]._colors[j], num4);
			}
		}
		else
		{
			array = animationMeshes[num]._colors;
		}
		((Component)this).GetComponent<VertexColorStream>().setColors(array);
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class VertexColorStream : MonoBehaviour
{
	[HideInInspector]
	public Mesh originalMesh;

	[HideInInspector]
	public Mesh paintedMesh;

	[HideInInspector]
	public MeshHolder meshHold;

	[HideInInspector]
	public Vector3[] _vertices;

	[HideInInspector]
	public Vector3[] _normals;

	[HideInInspector]
	public int[] _triangles;

	[HideInInspector]
	public int[][] _Subtriangles;

	[HideInInspector]
	public Matrix4x4[] _bindPoses;

	[HideInInspector]
	public BoneWeight[] _boneWeights;

	[HideInInspector]
	public Bounds _bounds;

	[HideInInspector]
	public int _subMeshCount;

	[HideInInspector]
	public Vector4[] _tangents;

	[HideInInspector]
	public Vector2[] _uv;

	[HideInInspector]
	public Vector2[] _uv2;

	[HideInInspector]
	public Vector2[] _uv3;

	[HideInInspector]
	public Color[] _colors;

	[HideInInspector]
	public Vector2[] _uv4;

	private void OnDidApplyAnimationProperties()
	{
	}

	public void init(Mesh origMesh, bool destroyOld)
	{
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		originalMesh = origMesh;
		paintedMesh = Object.Instantiate<Mesh>(origMesh);
		if (destroyOld)
		{
			Object.DestroyImmediate((Object)(object)origMesh);
		}
		((Object)paintedMesh).hideFlags = (HideFlags)0;
		((Object)paintedMesh).name = "vpp_" + ((Object)((Component)this).gameObject).name;
		meshHold = new MeshHolder();
		meshHold._vertices = paintedMesh.vertices;
		meshHold._normals = paintedMesh.normals;
		meshHold._triangles = paintedMesh.triangles;
		meshHold._TrianglesOfSubs = new trisPerSubmesh[paintedMesh.subMeshCount];
		for (int i = 0; i < paintedMesh.subMeshCount; i++)
		{
			meshHold._TrianglesOfSubs[i] = new trisPerSubmesh();
			meshHold._TrianglesOfSubs[i].triangles = paintedMesh.GetTriangles(i);
		}
		meshHold._bindPoses = paintedMesh.bindposes;
		meshHold._boneWeights = paintedMesh.boneWeights;
		meshHold._bounds = paintedMesh.bounds;
		meshHold._subMeshCount = paintedMesh.subMeshCount;
		meshHold._tangents = paintedMesh.tangents;
		meshHold._uv = paintedMesh.uv;
		meshHold._uv2 = paintedMesh.uv2;
		meshHold._uv3 = paintedMesh.uv3;
		meshHold._colors = paintedMesh.colors;
		meshHold._uv4 = paintedMesh.uv4;
		((Component)this).GetComponent<MeshFilter>().sharedMesh = paintedMesh;
		if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshCollider>()))
		{
			((Component)this).GetComponent<MeshCollider>().sharedMesh = paintedMesh;
		}
	}

	public void setWholeMesh(Mesh tmpMesh)
	{
		paintedMesh.vertices = tmpMesh.vertices;
		paintedMesh.triangles = tmpMesh.triangles;
		paintedMesh.normals = tmpMesh.normals;
		paintedMesh.colors = tmpMesh.colors;
		paintedMesh.uv = tmpMesh.uv;
		paintedMesh.uv2 = tmpMesh.uv2;
		paintedMesh.uv3 = tmpMesh.uv3;
		meshHold._vertices = tmpMesh.vertices;
		meshHold._triangles = tmpMesh.triangles;
		meshHold._normals = tmpMesh.normals;
		meshHold._colors = tmpMesh.colors;
		meshHold._uv = tmpMesh.uv;
		meshHold._uv2 = tmpMesh.uv2;
		meshHold._uv3 = tmpMesh.uv3;
	}

	public Vector3[] setVertices(Vector3[] _deformedVertices)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		paintedMesh.vertices = _deformedVertices;
		meshHold._vertices = _deformedVertices;
		paintedMesh.RecalculateNormals();
		paintedMesh.RecalculateBounds();
		meshHold._normals = paintedMesh.normals;
		meshHold._bounds = paintedMesh.bounds;
		((Component)this).GetComponent<MeshCollider>().sharedMesh = null;
		if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshCollider>()))
		{
			((Component)this).GetComponent<MeshCollider>().sharedMesh = paintedMesh;
		}
		return meshHold._normals;
	}

	public Vector3[] getVertices()
	{
		return paintedMesh.vertices;
	}

	public Vector3[] getNormals()
	{
		return paintedMesh.normals;
	}

	public int[] getTriangles()
	{
		return paintedMesh.triangles;
	}

	public void setTangents(Vector4[] _meshTangents)
	{
		paintedMesh.tangents = _meshTangents;
		meshHold._tangents = _meshTangents;
	}

	public Vector4[] getTangents()
	{
		return paintedMesh.tangents;
	}

	public void setColors(Color[] _vertexColors)
	{
		paintedMesh.colors = _vertexColors;
		meshHold._colors = _vertexColors;
	}

	public Color[] getColors()
	{
		return paintedMesh.colors;
	}

	public Vector2[] getUVs()
	{
		return paintedMesh.uv;
	}

	public void setUV4s(Vector2[] _uv4s)
	{
		paintedMesh.uv4 = _uv4s;
		meshHold._uv4 = _uv4s;
	}

	public Vector2[] getUV4s()
	{
		return paintedMesh.uv4;
	}

	public void unlink()
	{
		init(paintedMesh, destroyOld: false);
	}

	public void rebuild()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshFilter>()))
		{
			return;
		}
		paintedMesh = new Mesh();
		((Object)paintedMesh).hideFlags = (HideFlags)61;
		((Object)paintedMesh).name = "vpp_" + ((Object)((Component)this).gameObject).name;
		if (meshHold == null || meshHold._vertices.Length == 0 || meshHold._TrianglesOfSubs.Length == 0)
		{
			paintedMesh.subMeshCount = _subMeshCount;
			paintedMesh.vertices = _vertices;
			paintedMesh.normals = _normals;
			paintedMesh.triangles = _triangles;
			meshHold._TrianglesOfSubs = new trisPerSubmesh[paintedMesh.subMeshCount];
			for (int i = 0; i < paintedMesh.subMeshCount; i++)
			{
				meshHold._TrianglesOfSubs[i] = new trisPerSubmesh();
				meshHold._TrianglesOfSubs[i].triangles = paintedMesh.GetTriangles(i);
			}
			paintedMesh.bindposes = _bindPoses;
			paintedMesh.boneWeights = _boneWeights;
			paintedMesh.bounds = _bounds;
			paintedMesh.tangents = _tangents;
			paintedMesh.uv = _uv;
			paintedMesh.uv2 = _uv2;
			paintedMesh.uv3 = _uv3;
			paintedMesh.colors = _colors;
			paintedMesh.uv4 = _uv4;
			init(paintedMesh, destroyOld: true);
		}
		else
		{
			paintedMesh.subMeshCount = meshHold._subMeshCount;
			paintedMesh.vertices = meshHold._vertices;
			paintedMesh.normals = meshHold._normals;
			for (int j = 0; j < meshHold._subMeshCount; j++)
			{
				paintedMesh.SetTriangles(meshHold._TrianglesOfSubs[j].triangles, j);
			}
			paintedMesh.bindposes = meshHold._bindPoses;
			paintedMesh.boneWeights = meshHold._boneWeights;
			paintedMesh.bounds = meshHold._bounds;
			paintedMesh.tangents = meshHold._tangents;
			paintedMesh.uv = meshHold._uv;
			paintedMesh.uv2 = meshHold._uv2;
			paintedMesh.uv3 = meshHold._uv3;
			paintedMesh.colors = meshHold._colors;
			paintedMesh.uv4 = meshHold._uv4;
			init(paintedMesh, destroyOld: true);
		}
	}

	private void Start()
	{
		if (!Object.op_Implicit((Object)(object)paintedMesh) || meshHold == null)
		{
			rebuild();
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class VertexStreamChildrenRebuilder : MonoBehaviour
{
}


using System;
using UnityEngine;

[AddComponentMenu("Rendering/Visualize Texture Density")]
[ExecuteInEditMode]
[ImageEffectAllowedInSceneView]
public class VisualizeTexelDensity : MonoBehaviour
{
	public Shader shader;

	public string shaderTag = "RenderType";

	[Range(1f, 1024f)]
	public int texelsPerMeter = 256;

	[Range(0f, 1f)]
	public float overlayOpacity = 0.5f;

	public bool showHUD = true;

	private Camera mainCamera;

	private bool initialized;

	private int screenWidth;

	private int screenHeight;

	private Camera texelDensityCamera;

	private RenderTexture texelDensityRT;

	private Texture texelDensityGradTex;

	private Material texelDensityOverlayMat;

	private static VisualizeTexelDensity instance;

	public static VisualizeTexelDensity Instance => instance;

	private void Awake()
	{
		instance = this;
		mainCamera = ((Component)this).GetComponent<Camera>();
	}

	private void OnEnable()
	{
		mainCamera = ((Component)this).GetComponent<Camera>();
		screenWidth = Screen.width;
		screenHeight = Screen.height;
		LoadResources();
		initialized = true;
	}

	private void OnDisable()
	{
		SafeDestroyViewTexelDensity();
		SafeDestroyViewTexelDensityRT();
		initialized = false;
	}

	private void LoadResources()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		if ((Object)(object)texelDensityGradTex == (Object)null)
		{
			ref Texture reference = ref texelDensityGradTex;
			Object obj = Resources.Load("TexelDensityGrad");
			reference = (Texture)(object)((obj is Texture) ? obj : null);
		}
		if ((Object)(object)texelDensityOverlayMat == (Object)null)
		{
			texelDensityOverlayMat = new Material(Shader.Find("Hidden/TexelDensityOverlay"))
			{
				hideFlags = (HideFlags)52
			};
		}
	}

	private void SafeDestroyViewTexelDensity()
	{
		if ((Object)(object)texelDensityCamera != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)((Component)texelDensityCamera).gameObject);
			texelDensityCamera = null;
		}
		if ((Object)(object)texelDensityGradTex != (Object)null)
		{
			Resources.UnloadAsset((Object)(object)texelDensityGradTex);
			texelDensityGradTex = null;
		}
		if ((Object)(object)texelDensityOverlayMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)texelDensityOverlayMat);
			texelDensityOverlayMat = null;
		}
	}

	private void SafeDestroyViewTexelDensityRT()
	{
		if ((Object)(object)texelDensityRT != (Object)null)
		{
			Graphics.SetRenderTarget((RenderTexture)null);
			texelDensityRT.Release();
			Object.DestroyImmediate((Object)(object)texelDensityRT);
			texelDensityRT = null;
		}
	}

	private void UpdateViewTexelDensity(bool screenResized)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		if ((Object)(object)texelDensityCamera == (Object)null)
		{
			GameObject val = new GameObject("Texel Density Camera", new Type[1] { typeof(Camera) })
			{
				hideFlags = (HideFlags)61
			};
			val.transform.parent = ((Component)mainCamera).transform;
			val.transform.localPosition = Vector3.zero;
			val.transform.localRotation = Quaternion.identity;
			texelDensityCamera = val.GetComponent<Camera>();
			texelDensityCamera.CopyFrom(mainCamera);
			texelDensityCamera.renderingPath = (RenderingPath)1;
			texelDensityCamera.allowMSAA = false;
			texelDensityCamera.allowHDR = false;
			texelDensityCamera.clearFlags = (CameraClearFlags)1;
			texelDensityCamera.depthTextureMode = (DepthTextureMode)0;
			texelDensityCamera.SetReplacementShader(shader, shaderTag);
			((Behaviour)texelDensityCamera).enabled = false;
		}
		if ((Object)(object)texelDensityRT == (Object)null || screenResized || !texelDensityRT.IsCreated())
		{
			texelDensityCamera.targetTexture = null;
			SafeDestroyViewTexelDensityRT();
			texelDensityRT = new RenderTexture(screenWidth, screenHeight, 24, (RenderTextureFormat)0)
			{
				hideFlags = (HideFlags)52
			};
			((Object)texelDensityRT).name = "TexelDensityRT";
			((Texture)texelDensityRT).filterMode = (FilterMode)0;
			((Texture)texelDensityRT).wrapMode = (TextureWrapMode)1;
			texelDensityRT.Create();
		}
		if ((Object)(object)texelDensityCamera.targetTexture != (Object)(object)texelDensityRT)
		{
			texelDensityCamera.targetTexture = texelDensityRT;
		}
		Shader.SetGlobalFloat("global_TexelsPerMeter", (float)texelsPerMeter);
		Shader.SetGlobalTexture("global_TexelDensityGrad", texelDensityGradTex);
		texelDensityCamera.fieldOfView = mainCamera.fieldOfView;
		texelDensityCamera.nearClipPlane = mainCamera.nearClipPlane;
		texelDensityCamera.farClipPlane = mainCamera.farClipPlane;
		texelDensityCamera.cullingMask = mainCamera.cullingMask;
	}

	private bool CheckScreenResized(int width, int height)
	{
		if (screenWidth != width || screenHeight != height)
		{
			screenWidth = width;
			screenHeight = height;
			return true;
		}
		return false;
	}

	private void OnPreCull()
	{
		if ((Object)(object)texelDensityCamera != (Object)null)
		{
			texelDensityCamera.Render();
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (initialized)
		{
			UpdateViewTexelDensity(CheckScreenResized(((Texture)source).width, ((Texture)source).height));
			texelDensityOverlayMat.SetTexture("_TexelDensityMap", (Texture)(object)texelDensityRT);
			texelDensityOverlayMat.SetFloat("_Opacity", overlayOpacity);
			Graphics.Blit((Texture)(object)source, destination, texelDensityOverlayMat, 0);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, destination);
		}
	}

	private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		fontStyle.normal.textColor = Color.black;
		GUI.Label(new Rect(x - 1f, y + 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x + 1f, y - 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x + 1f, y + 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x - 1f, y - 1f, size.x, size.y), text, fontStyle);
		fontStyle.normal.textColor = Color.white;
		GUI.Label(new Rect(x, y, size.x, size.y), text, fontStyle);
	}

	private void OnGUI()
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Expected O, but got Unknown
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Expected O, but got Unknown
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Expected O, but got Unknown
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Expected O, but got Unknown
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Expected O, but got Unknown
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		if (initialized && showHUD)
		{
			string text = "Texels Per Meter";
			string text2 = "0";
			string text3 = texelsPerMeter.ToString();
			string text4 = (texelsPerMeter << 1) + "+";
			float num = texelDensityGradTex.width;
			float num2 = texelDensityGradTex.height * 2;
			float num3 = (Screen.width - texelDensityGradTex.width) / 2;
			float num4 = 32f;
			GL.PushMatrix();
			GL.LoadPixelMatrix(0f, (float)Screen.width, (float)Screen.height, 0f);
			Graphics.DrawTexture(new Rect(num3 - 2f, num4 - 2f, num + 4f, num2 + 4f), (Texture)(object)Texture2D.whiteTexture);
			Graphics.DrawTexture(new Rect(num3, num4, num, num2), texelDensityGradTex);
			GL.PopMatrix();
			GUIStyle val = new GUIStyle();
			val.fontSize = 13;
			Vector2 val2 = val.CalcSize(new GUIContent(text));
			Vector2 size = val.CalcSize(new GUIContent(text2));
			Vector2 val3 = val.CalcSize(new GUIContent(text3));
			Vector2 val4 = val.CalcSize(new GUIContent(text4));
			DrawGUIText(((float)Screen.width - val2.x) / 2f, num4 - val2.y - 5f, val2, text, val);
			DrawGUIText(num3, num4 + num2 + 6f, size, text2, val);
			DrawGUIText(((float)Screen.width - val3.x) / 2f, num4 + num2 + 6f, val3, text3, val);
			DrawGUIText(num3 + num - val4.x, num4 + num2 + 6f, val4, text4, val);
		}
	}
}


using System;
using Facepunch;
using UnityEngine;

public class ViewmodelClothing : MonoBehaviour
{
	[Flags]
	public enum SkinArea
	{
		Arms = 1,
		Hands = 2
	}

	public enum Slot
	{
		Under,
		Over
	}

	public SkeletonSkin[] SkeletonSkins;

	public bool DisableHandsEntirely;

	[Header("Conditional Logic")]
	public bool isConditional;

	[Tooltip("This is the slot the clothing will fit into. Over clothing will use MaxSkins when on top of under clothing.")]
	public Slot ClothingSlot;

	[Tooltip("A mask to allow multiple over clothing on the same model, but affecting different areas.")]
	public SkinArea AreasCovered = SkinArea.Arms | SkinArea.Hands;

	[Tooltip("Max Skins are the skins displayed if clothing is on top.")]
	public SkeletonSkin[] MaxSkin;
}


using System;

[Flags]
public enum SkinArea
{
	Arms = 1,
	Hands = 2
}


public enum Slot
{
	Under,
	Over
}


using UnityEngine;

public class WorkshopIconRender : MonoBehaviour
{
	public int MinimumId;

	public int MaximumId = -1;
}


