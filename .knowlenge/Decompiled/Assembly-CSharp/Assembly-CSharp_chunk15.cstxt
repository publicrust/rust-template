using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;

public class TriggerHurtEx : TriggerBase, IServerComponent, IHurtTrigger
{
	public enum HurtType
	{
		Simple,
		IncludeBleedingAndScreenShake
	}

	public class EntityTriggerInfo
	{
		public Vector3 lastPosition;
	}

	public float repeatRate = 0.1f;

	[Header("LOS Settings")]
	public bool LOSCheck;

	public float LOSDistance = 2f;

	[Header("On Enter")]
	public List<DamageTypeEntry> damageOnEnter;

	public GameObjectRef effectOnEnter;

	public HurtType hurtTypeOnEnter;

	[Header("On Timer (damage per second)")]
	public List<DamageTypeEntry> damageOnTimer;

	public GameObjectRef effectOnTimer;

	public HurtType hurtTypeOnTimer;

	[Header("On Move (damage per meter)")]
	public List<DamageTypeEntry> damageOnMove;

	public GameObjectRef effectOnMove;

	public HurtType hurtTypeOnMove;

	[Header("On Leave")]
	public List<DamageTypeEntry> damageOnLeave;

	public GameObjectRef effectOnLeave;

	public HurtType hurtTypeOnLeave;

	public bool damageEnabled = true;

	internal Dictionary<BaseEntity, EntityTriggerInfo> entityInfo;

	internal List<BaseEntity> entityAddList;

	internal List<BaseEntity> entityLeaveList;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (!(baseEntity is BaseCombatEntity))
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (baseEntity.IsNpc && baseEntity is NPCPlayer)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal void DoDamage(BaseEntity ent, HurtType type, List<DamageTypeEntry> damage, GameObjectRef effect, float multiply = 1f)
	{
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		if (!damageEnabled)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("TriggerHurtEx.DoDamage", 0);
		try
		{
			if (damage != null && damage.Count > 0)
			{
				if (LOSCheck)
				{
					Vector3 val2 = ((Component)this).transform.position + new Vector3(0f, 0.1f, 0f);
					Vector3 val3 = ((Component)ent).transform.position - ((Component)this).transform.position;
					if (GamePhysics.Trace(new Ray(val2, ((Vector3)(ref val3)).normalized), 0f, out var _, LOSDistance, 1218519297, (QueryTriggerInteraction)1, ((Component)this).gameObject.ToBaseEntity()))
					{
						return;
					}
				}
				BaseCombatEntity baseCombatEntity = ent as BaseCombatEntity;
				if (Object.op_Implicit((Object)(object)baseCombatEntity))
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.damageTypes.Add(damage);
					hitInfo2.damageTypes.ScaleAll(multiply);
					hitInfo2.DoHitEffects = true;
					hitInfo2.DidHit = true;
					hitInfo2.Initiator = ((Component)this).gameObject.ToBaseEntity();
					hitInfo2.PointStart = ((Component)this).transform.position;
					hitInfo2.PointEnd = ((Component)baseCombatEntity).transform.position;
					ModifyHit(hitInfo2);
					if (type == HurtType.Simple)
					{
						baseCombatEntity.Hurt(hitInfo2);
					}
					else
					{
						baseCombatEntity.OnAttacked(hitInfo2);
					}
				}
			}
			if (effect.isValid)
			{
				Effect.server.Run(effect.resourcePath, ent, StringPool.closest, ((Component)this).transform.position, Vector3.up);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected virtual void ModifyHit(HitInfo info)
	{
	}

	public override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if (!((Object)(object)ent == (Object)null))
		{
			if (entityAddList == null)
			{
				entityAddList = new List<BaseEntity>();
			}
			entityAddList.Add(ent);
			((FacepunchBehaviour)this).Invoke((Action)ProcessQueues, 0.1f);
		}
	}

	public override void OnEntityLeave(BaseEntity ent)
	{
		base.OnEntityLeave(ent);
		if (!((Object)(object)ent == (Object)null))
		{
			if (entityLeaveList == null)
			{
				entityLeaveList = new List<BaseEntity>();
			}
			entityLeaveList.Add(ent);
			((FacepunchBehaviour)this).Invoke((Action)ProcessQueues, 0.1f);
		}
	}

	public override void OnObjects()
	{
		((FacepunchBehaviour)this).InvokeRepeating((Action)OnTick, repeatRate, repeatRate);
	}

	public override void OnEmpty()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)OnTick);
	}

	private void OnTick()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		ProcessQueues();
		if (entityInfo == null)
		{
			return;
		}
		KeyValuePair<BaseEntity, EntityTriggerInfo>[] array = entityInfo.ToArray();
		for (int i = 0; i < array.Length; i++)
		{
			KeyValuePair<BaseEntity, EntityTriggerInfo> keyValuePair = array[i];
			if (keyValuePair.Key.IsValid())
			{
				Vector3 position = ((Component)keyValuePair.Key).transform.position;
				Vector3 val = position - keyValuePair.Value.lastPosition;
				float magnitude = ((Vector3)(ref val)).magnitude;
				if (magnitude > 0.01f)
				{
					keyValuePair.Value.lastPosition = position;
					DoDamage(keyValuePair.Key, hurtTypeOnMove, damageOnMove, effectOnMove, magnitude);
				}
				DoDamage(keyValuePair.Key, hurtTypeOnTimer, damageOnTimer, effectOnTimer, repeatRate);
			}
		}
	}

	private void ProcessQueues()
	{
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		if (entityAddList != null)
		{
			foreach (BaseEntity entityAdd in entityAddList)
			{
				if (entityAdd.IsValid())
				{
					DoDamage(entityAdd, hurtTypeOnEnter, damageOnEnter, effectOnEnter);
					if (entityInfo == null)
					{
						entityInfo = new Dictionary<BaseEntity, EntityTriggerInfo>();
					}
					if (!entityInfo.ContainsKey(entityAdd))
					{
						entityInfo.Add(entityAdd, new EntityTriggerInfo
						{
							lastPosition = ((Component)entityAdd).transform.position
						});
					}
				}
			}
			entityAddList = null;
		}
		if (entityLeaveList == null)
		{
			return;
		}
		foreach (BaseEntity entityLeave in entityLeaveList)
		{
			if (!entityLeave.IsValid())
			{
				continue;
			}
			DoDamage(entityLeave, hurtTypeOnLeave, damageOnLeave, effectOnLeave);
			if (entityInfo != null)
			{
				entityInfo.Remove(entityLeave);
				if (entityInfo.Count == 0)
				{
					entityInfo = null;
				}
			}
		}
		entityLeaveList.Clear();
	}
}


public enum HurtType
{
	Simple,
	IncludeBleedingAndScreenShake
}


using UnityEngine;

public class EntityTriggerInfo
{
	public Vector3 lastPosition;
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Math;
using Facepunch.Nexus;
using Facepunch.Rust;
using Facepunch.Sqlite;
using ProtoBuf;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public class UserPersistance : IDisposable
{
	public static Database blueprints;

	public static Database deaths;

	public static Database identities;

	public static Database tokens;

	public static Database playerState;

	public static Dictionary<ulong, string> nameCache;

	private static Dictionary<ulong, string> wipeIdCache;

	public static MruDictionary<ulong, (int Token, bool Locked)> tokenCache;

	public UserPersistance(string strFolder)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Expected O, but got Unknown
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Expected O, but got Unknown
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Expected O, but got Unknown
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Expected O, but got Unknown
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Expected O, but got Unknown
		blueprints = new Database();
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		string text = strFolder + "/player.blueprints.";
		if ((Object)(object)activeGameMode != (Object)null && activeGameMode.wipeBpsOnProtocol)
		{
			text = text + 271 + ".";
		}
		blueprints.Open(text + 5 + ".db", true);
		if (!blueprints.TableExists("data"))
		{
			blueprints.Execute("CREATE TABLE data ( userid TEXT PRIMARY KEY, info BLOB, updated INTEGER )");
		}
		deaths = new Database();
		deaths.Open(strFolder + "/player.deaths." + 5 + ".db", true);
		if (!deaths.TableExists("data"))
		{
			deaths.Execute("CREATE TABLE data ( userid TEXT, born INTEGER, died INTEGER, info BLOB )");
			deaths.Execute("CREATE INDEX IF NOT EXISTS userindex ON data ( userid )");
			deaths.Execute("CREATE INDEX IF NOT EXISTS diedindex ON data ( died )");
		}
		identities = new Database();
		identities.Open(strFolder + "/player.identities." + 5 + ".db", true);
		if (!identities.TableExists("data"))
		{
			identities.Execute("CREATE TABLE data ( userid INT PRIMARY KEY, username TEXT )");
		}
		tokens = new Database();
		tokens.Open(strFolder + "/player.tokens.db", true);
		if (!tokens.TableExists("data"))
		{
			tokens.Execute("CREATE TABLE data ( userid INT PRIMARY KEY, token INT, locked BOOLEAN DEFAULT 0 )");
		}
		if (!tokens.ColumnExists("data", "locked"))
		{
			tokens.Execute("ALTER TABLE data ADD COLUMN locked BOOLEAN DEFAULT 0");
		}
		playerState = new Database();
		playerState.Open(strFolder + "/player.states." + 271 + ".db", true);
		if (!playerState.TableExists("data"))
		{
			playerState.Execute("CREATE TABLE data ( userid INT PRIMARY KEY, state BLOB )");
		}
		nameCache = new Dictionary<ulong, string>();
		tokenCache = new MruDictionary<ulong, (int, bool)>(500, (Action<ulong, (int, bool)>)null);
		wipeIdCache = new Dictionary<ulong, string>();
	}

	public virtual void Dispose()
	{
		if (blueprints != null)
		{
			blueprints.Close();
			blueprints = null;
		}
		if (deaths != null)
		{
			deaths.Close();
			deaths = null;
		}
		if (identities != null)
		{
			identities.Close();
			identities = null;
		}
		if (tokens != null)
		{
			tokens.Close();
			tokens = null;
		}
		if (playerState != null)
		{
			playerState.Close();
			playerState = null;
		}
	}

	public PersistantPlayer GetPlayerInfo(ulong playerID)
	{
		PersistantPlayer val = FetchFromDatabase(playerID);
		if (val == null)
		{
			val = Pool.Get<PersistantPlayer>();
		}
		if (val.unlockedItems == null)
		{
			val.unlockedItems = Pool.Get<List<int>>();
		}
		return val;
	}

	private PersistantPlayer FetchFromDatabase(ulong playerID)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			byte[] array = null;
			NexusPlayer player;
			Variable val = default(Variable);
			if (!NexusServer.Started)
			{
				array = blueprints.Query<byte[], ulong>("SELECT info FROM data WHERE userid = ?", playerID);
			}
			else if (NexusServer.TryGetPlayer(playerID, out player) && player.TryGetVariable(NexusVariables.Blueprints, ref val) && (int)val.Type == 0)
			{
				array = val.GetAsBinary();
			}
			if (array != null)
			{
				return PersistantPlayer.Deserialize(array);
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Error loading player blueprints: (" + ex.Message + ")"));
		}
		return null;
	}

	public void SetPlayerInfo(ulong playerID, PersistantPlayer info)
	{
		TimeWarning val = TimeWarning.New("SetPlayerInfo", 0);
		try
		{
			TimeWarning val2 = TimeWarning.New("ToProtoBytes", 0);
			byte[] array;
			try
			{
				array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)info);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			NexusPlayer player;
			if (!NexusServer.Started)
			{
				blueprints.Execute<ulong, byte[], int>("INSERT OR REPLACE INTO data ( userid, info, updated ) VALUES ( ?, ?, ? )", playerID, array, Epoch.Current);
			}
			else if (!NexusServer.TryGetPlayer(playerID, out player))
			{
				Debug.LogError((object)$"Couldn't find NexusPlayer to save player info! {playerID}");
			}
			else
			{
				player.SetVariable(NexusVariables.Blueprints, array, false, true);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void AddLifeStory(ulong playerID, PlayerLifeStory lifeStory)
	{
		if (deaths == null || lifeStory == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("AddLifeStory", 0);
		try
		{
			TimeWarning val2 = TimeWarning.New("ToProtoBytes", 0);
			byte[] array;
			try
			{
				array = ProtoStreamExtensions.ToProtoBytes((IProto)(object)lifeStory);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			deaths.Execute<ulong, int, int, byte[]>("INSERT INTO data ( userid, born, died, info ) VALUES ( ?, ?, ?, ? )", playerID, (int)lifeStory.timeBorn, (int)lifeStory.timeDied, array);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public PlayerLifeStory GetLastLifeStory(ulong playerID)
	{
		if (deaths == null)
		{
			return null;
		}
		TimeWarning val = TimeWarning.New("GetLastLifeStory", 0);
		try
		{
			try
			{
				byte[] array = deaths.Query<byte[], ulong>("SELECT info FROM data WHERE userid = ? ORDER BY died DESC LIMIT 1", playerID);
				if (array == null)
				{
					return null;
				}
				PlayerLifeStory obj = PlayerLifeStory.Deserialize(array);
				obj.ShouldPool = false;
				return obj;
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Error loading lifestory from database: (" + ex.Message + ")"));
			}
			return null;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool DoesPlayerExist(ulong steamId)
	{
		return GetPlayerName(steamId) != null;
	}

	public string GetPlayerName(ulong playerID)
	{
		if (playerID == 0L)
		{
			return null;
		}
		if (nameCache.TryGetValue(playerID, out var value))
		{
			return value;
		}
		string text = identities.Query<string, ulong>("SELECT username FROM data WHERE userid = ?", playerID);
		nameCache[playerID] = text;
		return text;
	}

	public void SetPlayerName(ulong playerID, string name)
	{
		if (playerID != 0L && !string.IsNullOrEmpty(name))
		{
			if (string.IsNullOrEmpty(GetPlayerName(playerID)))
			{
				identities.Execute<ulong, string>("INSERT INTO data ( userid, username ) VALUES ( ?, ? )", playerID, name);
			}
			else
			{
				identities.Execute<string, ulong>("UPDATE data SET username = ? WHERE userid = ?", name, playerID);
			}
			nameCache[playerID] = name;
		}
	}

	public void SetDefaultPlayerName(ulong playerID, string name)
	{
		if (string.IsNullOrEmpty(GetPlayerName(playerID)))
		{
			SetPlayerName(playerID, name);
		}
	}

	public int GetOrGenerateAppToken(ulong playerID, out bool locked)
	{
		if (tokens == null)
		{
			locked = false;
			return 0;
		}
		TimeWarning val = TimeWarning.New("GetOrGenerateAppToken", 0);
		try
		{
			(int, bool) tuple = default((int, bool));
			if (tokenCache.TryGetValue(playerID, ref tuple))
			{
				locked = tuple.Item2;
				return tuple.Item1;
			}
			int num = tokens.Query<int, ulong>("SELECT token FROM data WHERE userid = ?", playerID);
			if (num != 0)
			{
				bool flag = tokens.Query<int, ulong>("SELECT locked FROM data WHERE userid = ?", playerID) != 0;
				tokenCache.Add(playerID, (num, flag));
				locked = flag;
				return num;
			}
			int num2 = GenerateAppToken();
			tokens.Execute<ulong, int>("INSERT INTO data ( userid, token ) VALUES ( ?, ? )", playerID, num2);
			tokenCache.Add(playerID, (num2, false));
			locked = false;
			return num2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RegenerateAppToken(ulong playerID)
	{
		if (tokens == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("RegenerateAppToken", 0);
		try
		{
			tokenCache.Remove(playerID);
			bool flag = tokens.Query<int, ulong>("SELECT locked FROM data WHERE userid = ?", playerID) != 0;
			int num = GenerateAppToken();
			tokens.Execute<ulong, int, bool>("INSERT OR REPLACE INTO data ( userid, token, locked ) VALUES ( ?, ?, ? )", playerID, num, flag);
			tokenCache.Add(playerID, (num, false));
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private static int GenerateAppToken()
	{
		int num = Random.Range(int.MinValue, int.MaxValue);
		if (num == 0)
		{
			num++;
		}
		return num;
	}

	public bool SetAppTokenLocked(ulong playerID, bool locked)
	{
		if (tokens == null)
		{
			return false;
		}
		GetOrGenerateAppToken(playerID, out var locked2);
		if (locked2 == locked)
		{
			return false;
		}
		tokens.Execute<int, ulong>("UPDATE data SET locked = ? WHERE userid = ?", locked ? 1 : 0, playerID);
		tokenCache.Remove(playerID);
		return true;
	}

	public byte[] GetPlayerState(ulong playerID)
	{
		if (playerID == 0L)
		{
			return null;
		}
		return playerState.Query<byte[], ulong>("SELECT state FROM data WHERE userid = ?", playerID);
	}

	public void SetPlayerState(ulong playerID, byte[] state)
	{
		if (playerID != 0L && state != null)
		{
			playerState.Execute<ulong, byte[]>("INSERT OR REPLACE INTO data ( userid, state ) VALUES ( ?, ? )", playerID, state);
		}
	}

	public string GetUserWipeId(ulong playerID)
	{
		if (playerID <= 10000000)
		{
			return null;
		}
		if (wipeIdCache.TryGetValue(playerID, out var value))
		{
			return value;
		}
		value = StringEx.HexString(StringEx.Sha256(playerID + SaveRestore.WipeId));
		wipeIdCache[playerID] = value;
		Analytics.Azure.OnPlayerInitializedWipeId(playerID, value);
		return value;
	}

	public void ResetPlayerState(ulong playerID)
	{
		if (playerID != 0L)
		{
			playerState.Execute<ulong>("DELETE FROM data WHERE userid = ?", playerID);
		}
	}
}


using System;
using System.Net;
using Newtonsoft.Json;

[JsonModel]
public class IPAddressJsonConverter : JsonConverter
{
	public override bool CanConvert(Type objectType)
	{
		return objectType == typeof(IPAddress);
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		string text = ((value is IPAddress iPAddress) ? iPAddress.ToString() : null);
		writer.WriteValue(text);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Invalid comparison between Unknown and I4
		if ((int)reader.TokenType != 9)
		{
			return null;
		}
		if (!IPAddress.TryParse((string)reader.Value, out IPAddress address))
		{
			return null;
		}
		return address;
	}
}


public class PremiumClientCache
{
}


using System.Collections.Generic;
using UnityEngine;

public static class AssetNameCache
{
	private static Dictionary<Object, string> mixed = new Dictionary<Object, string>();

	private static Dictionary<Object, string> lower = new Dictionary<Object, string>();

	private static Dictionary<Object, string> upper = new Dictionary<Object, string>();

	private static string LookupName(Object obj)
	{
		if (obj == (Object)null)
		{
			return string.Empty;
		}
		if (!mixed.TryGetValue(obj, out var value))
		{
			value = obj.name;
			mixed.Add(obj, value);
		}
		return value;
	}

	private static string LookupNameLower(Object obj)
	{
		if (obj == (Object)null)
		{
			return string.Empty;
		}
		if (!lower.TryGetValue(obj, out var value))
		{
			value = obj.name.ToLower();
			lower.Add(obj, value);
		}
		return value;
	}

	private static string LookupNameUpper(Object obj)
	{
		if (obj == (Object)null)
		{
			return string.Empty;
		}
		if (!upper.TryGetValue(obj, out var value))
		{
			value = obj.name.ToUpper();
			upper.Add(obj, value);
		}
		return value;
	}

	public static string GetName(this PhysicMaterial mat)
	{
		return LookupName((Object)(object)mat);
	}

	public static string GetNameLower(this PhysicMaterial mat)
	{
		return LookupNameLower((Object)(object)mat);
	}

	public static string GetNameUpper(this PhysicMaterial mat)
	{
		return LookupNameUpper((Object)(object)mat);
	}

	public static string GetName(this Material mat)
	{
		return LookupName((Object)(object)mat);
	}

	public static string GetNameLower(this Material mat)
	{
		return LookupNameLower((Object)(object)mat);
	}

	public static string GetNameUpper(this Material mat)
	{
		return LookupNameUpper((Object)(object)mat);
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Building Grade")]
public class BuildingGrade : ScriptableObject
{
	public enum Enum
	{
		None = -1,
		Twigs,
		Wood,
		Stone,
		Metal,
		TopTier,
		Count
	}

	public Enum type;

	public ulong skin;

	public bool enabledInStandalone;

	[Tooltip("Will bypass the inventory check if this is enabled, allowing anyone to craft this item, enabledInStandalone will still need to be true")]
	public bool alwaysUnlock;

	public float baseHealth;

	public List<ItemAmount> baseCost;

	public PhysicMaterial physicMaterial;

	public ProtectionProperties damageProtecton;

	public bool supportsColourChange;

	public BaseEntity.Menu.Option upgradeMenu;
}


public enum Enum
{
	None = -1,
	Twigs,
	Wood,
	Stone,
	Metal,
	TopTier,
	Count
}


using System;
using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using Facepunch.Sqlite;
using Ionic.Crc;
using ProtoBuf;
using UnityEngine.Assertions;

public class FileStorage : IDisposable
{
	private class CacheData
	{
		public byte[] data;

		public NetworkableId entityID;

		public uint numID;
	}

	public enum Type
	{
		png,
		jpg,
		ogg,
		sculpt
	}

	private class FileDatabase : Database
	{
		public IEnumerable<AssociatedFile> QueryAll(NetworkableId entityID)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			IntPtr intPtr = ((Database)this).Prepare("SELECT filetype, crc, part, data FROM data WHERE entid = ?");
			Database.Bind<ulong>(intPtr, 1, entityID.Value);
			return ((Database)this).ExecuteAndReadQueryResults<AssociatedFile>(intPtr, (Func<IntPtr, AssociatedFile>)ReadAssociatedFileRow);
		}

		private static AssociatedFile ReadAssociatedFileRow(IntPtr stmHandle)
		{
			AssociatedFile obj = Pool.Get<AssociatedFile>();
			obj.type = Database.GetColumnValue<int>(stmHandle, 0);
			obj.crc = (uint)Database.GetColumnValue<int>(stmHandle, 1);
			obj.numID = (uint)Database.GetColumnValue<int>(stmHandle, 2);
			obj.data = Database.GetColumnValue<byte[]>(stmHandle, 3);
			return obj;
		}
	}

	private FileDatabase db;

	private CRC32 crc = new CRC32();

	private MruDictionary<uint, CacheData> _cache = new MruDictionary<uint, CacheData>(1000, (Action<uint, CacheData>)null);

	public static FileStorage server = new FileStorage("sv.files." + 271, server: true);

	protected FileStorage(string name, bool server)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		if (server)
		{
			string text = Server.filesStorageFolder + "/" + name + ".db";
			db = new FileDatabase();
			((Database)db).Open(text, true);
			if (!((Database)db).TableExists("data"))
			{
				((Database)db).Execute("CREATE TABLE data ( crc INTEGER PRIMARY KEY, data BLOB, updated INTEGER, entid INTEGER, filetype INTEGER, part INTEGER )");
				((Database)db).Execute("CREATE INDEX IF NOT EXISTS entindex ON data ( entid )");
			}
		}
	}

	~FileStorage()
	{
		Dispose();
	}

	public void Dispose()
	{
		if (db != null)
		{
			((Database)db).Close();
			db = null;
		}
	}

	private uint GetCRC(byte[] data, Type type)
	{
		TimeWarning val = TimeWarning.New("FileStorage.GetCRC", 0);
		try
		{
			crc.Reset();
			crc.SlurpBlock(data, 0, data.Length);
			crc.UpdateCRC((byte)type);
			return (uint)crc.Crc32Result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public uint Store(byte[] data, Type type, NetworkableId entityID, uint numID = 0u)
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.Store", 0);
		try
		{
			uint cRC = GetCRC(data, type);
			if (db != null)
			{
				((Database)db).Execute<int, byte[], long, int, int>("INSERT OR REPLACE INTO data ( crc, data, entid, filetype, part ) VALUES ( ?, ?, ?, ?, ? )", (int)cRC, data, (long)entityID.Value, (int)type, (int)numID);
			}
			_cache.Remove(cRC);
			_cache.Add(cRC, new CacheData
			{
				data = data,
				entityID = entityID,
				numID = numID
			});
			return cRC;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public byte[] Get(uint crc, Type type, NetworkableId entityID, uint numID = 0u)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.Get", 0);
		try
		{
			CacheData cacheData = default(CacheData);
			if (_cache.TryGetValue(crc, ref cacheData))
			{
				Assert.IsTrue(cacheData.data != null, "FileStorage cache contains a null texture");
				return cacheData.data;
			}
			if (db == null)
			{
				return null;
			}
			byte[] array = ((Database)db).Query<byte[], int, int, int, int>("SELECT data FROM data WHERE crc = ? AND filetype = ? AND entid = ? AND part = ? LIMIT 1", (int)crc, (int)type, (int)entityID.Value, (int)numID);
			if (array == null)
			{
				return null;
			}
			_cache.Remove(crc);
			_cache.Add(crc, new CacheData
			{
				data = array,
				entityID = entityID,
				numID = 0u
			});
			return array;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(uint crc, Type type, NetworkableId entityID)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.Remove", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<int, int, long>("DELETE FROM data WHERE crc = ? AND filetype = ? AND entid = ?", (int)crc, (int)type, (long)entityID.Value);
			}
			_cache.Remove(crc);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveExact(uint crc, Type type, NetworkableId entityID, uint numid)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.RemoveExact", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<int, int, long, int>("DELETE FROM data WHERE crc = ? AND filetype = ? AND entid = ? AND part = ?", (int)crc, (int)type, (long)entityID.Value, (int)numid);
			}
			_cache.Remove(crc);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveEntityNum(NetworkableId entityid, uint numid)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.RemoveEntityNum", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<long, int>("DELETE FROM data WHERE entid = ? AND part = ?", (long)entityid.Value, (int)numid);
			}
			uint[] array = (from x in (IEnumerable<KeyValuePair<uint, CacheData>>)_cache
				where x.Value.entityID == entityid && x.Value.numID == numid
				select x.Key).ToArray();
			foreach (uint num in array)
			{
				_cache.Remove(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void RemoveAllByEntity(NetworkableId entityid)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.RemoveAllByEntity", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<long>("DELETE FROM data WHERE entid = ?", (long)entityid.Value);
			}
			uint[] array = (from x in (IEnumerable<KeyValuePair<uint, CacheData>>)_cache
				where x.Value.entityID == entityid
				select x.Key).ToArray();
			foreach (uint num in array)
			{
				_cache.Remove(num);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ReassignEntityId(NetworkableId oldId, NetworkableId newId)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("FileStorage.ReassignEntityId", 0);
		try
		{
			if (db != null)
			{
				((Database)db).Execute<long, long>("UPDATE data SET entid = ? WHERE entid = ?", (long)newId.Value, (long)oldId.Value);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public IEnumerable<AssociatedFile> QueryAllByEntity(NetworkableId entityID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return db.QueryAll(entityID);
	}
}


private class CacheData
{
	public byte[] data;

	public NetworkableId entityID;

	public uint numID;
}


public enum Type
{
	png,
	jpg,
	ogg,
	sculpt
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Sqlite;
using ProtoBuf;

private class FileDatabase : Database
{
	public IEnumerable<AssociatedFile> QueryAll(NetworkableId entityID)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		IntPtr intPtr = ((Database)this).Prepare("SELECT filetype, crc, part, data FROM data WHERE entid = ?");
		Database.Bind<ulong>(intPtr, 1, entityID.Value);
		return ((Database)this).ExecuteAndReadQueryResults<AssociatedFile>(intPtr, (Func<IntPtr, AssociatedFile>)ReadAssociatedFileRow);
	}

	private static AssociatedFile ReadAssociatedFileRow(IntPtr stmHandle)
	{
		AssociatedFile obj = Pool.Get<AssociatedFile>();
		obj.type = Database.GetColumnValue<int>(stmHandle, 0);
		obj.crc = (uint)Database.GetColumnValue<int>(stmHandle, 1);
		obj.numID = (uint)Database.GetColumnValue<int>(stmHandle, 2);
		obj.data = Database.GetColumnValue<byte[]>(stmHandle, 3);
		return obj;
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class GameManifest : ScriptableObject
{
	[Serializable]
	public struct PooledString
	{
		[HideInInspector]
		public string str;

		public uint hash;
	}

	[Serializable]
	public class PrefabProperties
	{
		[HideInInspector]
		public string name;

		public string guid;

		public uint hash;

		public bool pool;
	}

	[Serializable]
	public class EffectCategory
	{
		[HideInInspector]
		public string folder;

		public List<string> prefabs;
	}

	[Serializable]
	public class GuidPath
	{
		[HideInInspector]
		public string name;

		public string guid;
	}

	internal static GameManifest loadedManifest;

	public static Dictionary<string, string> guidToPath = new Dictionary<string, string>();

	public static Dictionary<string, string> pathToGuid = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

	public static Dictionary<string, Object> guidToObject = new Dictionary<string, Object>();

	public PooledString[] pooledStrings;

	public PrefabProperties[] prefabProperties;

	public EffectCategory[] effectCategories;

	public GuidPath[] guidPaths;

	public string[] entities;

	public static GameManifest Current
	{
		get
		{
			if ((Object)(object)loadedManifest != (Object)null)
			{
				return loadedManifest;
			}
			Load();
			return loadedManifest;
		}
	}

	public static void Load()
	{
		if ((Object)(object)loadedManifest != (Object)null)
		{
			return;
		}
		loadedManifest = FileSystem.Load<GameManifest>("Assets/manifest.asset", true);
		PrefabProperties[] array = loadedManifest.prefabProperties;
		foreach (PrefabProperties prefabProperties in array)
		{
			guidToPath.Add(prefabProperties.guid, prefabProperties.name);
			pathToGuid.Add(prefabProperties.name, prefabProperties.guid);
		}
		GuidPath[] array2 = loadedManifest.guidPaths;
		foreach (GuidPath guidPath in array2)
		{
			if (!guidToPath.ContainsKey(guidPath.guid))
			{
				guidToPath.Add(guidPath.guid, guidPath.name);
				pathToGuid.Add(guidPath.name, guidPath.guid);
			}
		}
		DebugEx.Log((object)GetMetadataStatus(), (StackTraceLogType)0);
	}

	public static void LoadAssets()
	{
		if (Skinnable.All == null)
		{
			Skinnable.All = FileSystem.LoadAllFromBundle<Skinnable>("skinnables.preload.bundle", "t:Skinnable");
			if (Skinnable.All == null || Skinnable.All.Length == 0)
			{
				throw new Exception("Error loading skinnables");
			}
			DebugEx.Log((object)GetAssetStatus(), (StackTraceLogType)0);
		}
	}

	internal static Dictionary<string, string[]> LoadEffectDictionary()
	{
		EffectCategory[] array = loadedManifest.effectCategories;
		Dictionary<string, string[]> dictionary = new Dictionary<string, string[]>();
		EffectCategory[] array2 = array;
		foreach (EffectCategory effectCategory in array2)
		{
			dictionary.Add(effectCategory.folder, effectCategory.prefabs.ToArray());
		}
		return dictionary;
	}

	internal static string GUIDToPath(string guid)
	{
		if (string.IsNullOrEmpty(guid))
		{
			Debug.LogError((object)"GUIDToPath: guid is empty");
			return string.Empty;
		}
		Load();
		if (guidToPath.TryGetValue(guid, out var value))
		{
			return value;
		}
		Debug.LogWarning((object)("GUIDToPath: no path found for guid " + guid));
		return string.Empty;
	}

	internal static Object GUIDToObject(string guid)
	{
		Object value = null;
		if (guidToObject.TryGetValue(guid, out value))
		{
			return value;
		}
		string text = GUIDToPath(guid);
		if (string.IsNullOrEmpty(text))
		{
			Debug.LogWarning((object)("Missing file for guid " + guid));
			guidToObject.Add(guid, null);
			return null;
		}
		Object val = FileSystem.Load<Object>(text, true);
		guidToObject.Add(guid, val);
		return val;
	}

	public static void Invalidate(string path)
	{
		if (pathToGuid.TryGetValue(path, out var value) && guidToObject.TryGetValue(value, out var value2))
		{
			if (value2 != (Object)null)
			{
				Object.DestroyImmediate(value2, true);
			}
			guidToObject.Remove(value);
		}
	}

	private static string GetMetadataStatus()
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)loadedManifest != (Object)null)
		{
			stringBuilder.Append("Manifest Metadata Loaded");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.pooledStrings.Length.ToString());
			stringBuilder.Append(" pooled strings");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.prefabProperties.Length.ToString());
			stringBuilder.Append(" prefab properties");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.effectCategories.Length.ToString());
			stringBuilder.Append(" effect categories");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append(loadedManifest.entities.Length.ToString());
			stringBuilder.Append(" entity names");
			stringBuilder.AppendLine();
		}
		else
		{
			stringBuilder.Append("Manifest Metadata Missing");
		}
		return stringBuilder.ToString();
	}

	private static string GetAssetStatus()
	{
		StringBuilder stringBuilder = new StringBuilder();
		if ((Object)(object)loadedManifest != (Object)null)
		{
			stringBuilder.Append("Manifest Assets Loaded");
			stringBuilder.AppendLine();
			stringBuilder.Append("\t");
			stringBuilder.Append((Skinnable.All != null) ? Skinnable.All.Length.ToString() : "0");
			stringBuilder.Append(" skinnable objects");
		}
		else
		{
			stringBuilder.Append("Manifest Assets Missing");
		}
		return stringBuilder.ToString();
	}
}


using System;
using UnityEngine;

[Serializable]
public struct PooledString
{
	[HideInInspector]
	public string str;

	public uint hash;
}


using System;
using UnityEngine;

[Serializable]
public class PrefabProperties
{
	[HideInInspector]
	public string name;

	public string guid;

	public uint hash;

	public bool pool;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class EffectCategory
{
	[HideInInspector]
	public string folder;

	public List<string> prefabs;
}


using System;
using UnityEngine;

[Serializable]
public class GuidPath
{
	[HideInInspector]
	public string name;

	public string guid;
}


using System;
using UnityEngine;

[Serializable]
public class HairDye
{
	public enum CopyProperty
	{
		DyeColor,
		RootColor,
		TipColor,
		Brightness,
		DyeRoughness,
		DyeScatter,
		Specular,
		Roughness,
		Count
	}

	[Flags]
	public enum CopyPropertyMask
	{
		DyeColor = 1,
		RootColor = 2,
		TipColor = 4,
		Brightness = 8,
		DyeRoughness = 0x10,
		DyeScatter = 0x20,
		Specular = 0x40,
		Roughness = 0x80
	}

	[ColorUsage(false, true)]
	public Color capBaseColor;

	public Material sourceMaterial;

	[InspectorFlags]
	public CopyPropertyMask copyProperties;

	private static MaterialPropertyDesc[] transferableProps = new MaterialPropertyDesc[8]
	{
		new MaterialPropertyDesc("_DyeColor", typeof(Color)),
		new MaterialPropertyDesc("_RootColor", typeof(Color)),
		new MaterialPropertyDesc("_TipColor", typeof(Color)),
		new MaterialPropertyDesc("_Brightness", typeof(float)),
		new MaterialPropertyDesc("_DyeRoughness", typeof(float)),
		new MaterialPropertyDesc("_DyeScatter", typeof(float)),
		new MaterialPropertyDesc("_HairSpecular", typeof(float)),
		new MaterialPropertyDesc("_HairRoughness", typeof(float))
	};

	public static int _HairBaseColorUV1 = Shader.PropertyToID("_HairBaseColorUV1");

	public static int _HairBaseColorUV2 = Shader.PropertyToID("_HairBaseColorUV2");

	public static int _HairPackedMapUV1 = Shader.PropertyToID("_HairPackedMapUV1");

	public static int _HairPackedMapUV2 = Shader.PropertyToID("_HairPackedMapUV2");

	public void Apply(HairDyeCollection collection, MaterialPropertyBlock block)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)sourceMaterial != (Object)null))
		{
			return;
		}
		for (int i = 0; i < 8; i++)
		{
			if (((uint)copyProperties & (uint)(1 << i)) == 0)
			{
				continue;
			}
			MaterialPropertyDesc materialPropertyDesc = transferableProps[i];
			if (sourceMaterial.HasProperty(materialPropertyDesc.nameID))
			{
				if (materialPropertyDesc.type == typeof(Color))
				{
					block.SetColor(materialPropertyDesc.nameID, sourceMaterial.GetColor(materialPropertyDesc.nameID));
				}
				else if (materialPropertyDesc.type == typeof(float))
				{
					block.SetFloat(materialPropertyDesc.nameID, sourceMaterial.GetFloat(materialPropertyDesc.nameID));
				}
			}
		}
	}

	public void ApplyCap(HairDyeCollection collection, HairType type, MaterialPropertyBlock block)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (collection.applyCap)
		{
			switch (type)
			{
			case HairType.Head:
			case HairType.Armpit:
			case HairType.Pubic:
				block.SetColor(_HairBaseColorUV1, ((Color)(ref capBaseColor)).gamma);
				block.SetTexture(_HairPackedMapUV1, (Texture)(((Object)(object)collection.capMask != (Object)null) ? ((object)collection.capMask) : ((object)Texture2D.blackTexture)));
				break;
			case HairType.Facial:
				block.SetColor(_HairBaseColorUV2, ((Color)(ref capBaseColor)).gamma);
				block.SetTexture(_HairPackedMapUV2, (Texture)(((Object)(object)collection.capMask != (Object)null) ? ((object)collection.capMask) : ((object)Texture2D.blackTexture)));
				break;
			}
		}
	}
}


public enum CopyProperty
{
	DyeColor,
	RootColor,
	TipColor,
	Brightness,
	DyeRoughness,
	DyeScatter,
	Specular,
	Roughness,
	Count
}


using System;

[Flags]
public enum CopyPropertyMask
{
	DyeColor = 1,
	RootColor = 2,
	TipColor = 4,
	Brightness = 8,
	DyeRoughness = 0x10,
	DyeScatter = 0x20,
	Specular = 0x40,
	Roughness = 0x80
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Hair Dye Collection")]
public class HairDyeCollection : ScriptableObject
{
	public Texture capMask;

	public bool applyCap;

	public HairDye[] Variations;

	public HairDye Get(float seed)
	{
		if (Variations.Length != 0)
		{
			return Variations[Mathf.Clamp(Mathf.FloorToInt(seed * (float)Variations.Length), 0, Variations.Length - 1)];
		}
		return null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Hair Set")]
public class HairSet : ScriptableObject
{
	[Serializable]
	public class MeshReplace
	{
		[HideInInspector]
		public string FindName;

		public Mesh Find;

		public Mesh[] ReplaceShapes;

		public bool Test(string materialName)
		{
			return FindName == materialName;
		}
	}

	public MeshReplace[] MeshReplacements;

	public void Process(PlayerModelHair playerModelHair, HairDyeCollection dyeCollection, HairDye dye, MaterialPropertyBlock block)
	{
		List<SkinnedMeshRenderer> list = Pool.Get<List<SkinnedMeshRenderer>>();
		((Component)playerModelHair).gameObject.GetComponentsInChildren<SkinnedMeshRenderer>(true, list);
		foreach (SkinnedMeshRenderer item in list)
		{
			if (!((Object)(object)item.sharedMesh == (Object)null) && !((Object)(object)((Renderer)item).sharedMaterial == (Object)null))
			{
				string name = ((Object)item.sharedMesh).name;
				_ = ((Object)((Renderer)item).sharedMaterial).name;
				if (!((Component)item).gameObject.activeSelf)
				{
					((Component)item).gameObject.SetActive(true);
				}
				for (int i = 0; i < MeshReplacements.Length; i++)
				{
					MeshReplacements[i].Test(name);
				}
				if (dye != null && ((Component)item).gameObject.activeSelf)
				{
					dye.Apply(dyeCollection, block);
				}
			}
		}
		Pool.FreeUnmanaged<SkinnedMeshRenderer>(ref list);
	}

	public void ProcessMorphs(GameObject obj, int blendShapeIndex = -1)
	{
	}
}


using System;
using UnityEngine;

[Serializable]
public class MeshReplace
{
	[HideInInspector]
	public string FindName;

	public Mesh Find;

	public Mesh[] ReplaceShapes;

	public bool Test(string materialName)
	{
		return FindName == materialName;
	}
}


using System;

[Serializable]
public enum HairType
{
	Head,
	Eyebrow,
	Facial,
	Armpit,
	Pubic,
	Count
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Hair Set Collection")]
public class HairSetCollection : ScriptableObject
{
	[Serializable]
	public struct HairSetEntry
	{
		public HairSet HairSet;

		public GameObjectRef HairPrefab;

		public HairDyeCollection HairDyeCollection;
	}

	public HairSetEntry[] Head;

	public HairSetEntry[] Eyebrow;

	public HairSetEntry[] Facial;

	public HairSetEntry[] Armpit;

	public HairSetEntry[] Pubic;

	public HairSetEntry[] GetListByType(HairType hairType)
	{
		return hairType switch
		{
			HairType.Head => Head, 
			HairType.Eyebrow => Eyebrow, 
			HairType.Facial => Facial, 
			HairType.Armpit => Armpit, 
			HairType.Pubic => Pubic, 
			_ => null, 
		};
	}

	public int GetIndex(HairSetEntry[] list, float typeNum)
	{
		return Mathf.Clamp(Mathf.FloorToInt(typeNum * (float)list.Length), 0, list.Length - 1);
	}

	public int GetIndex(HairType hairType, float typeNum)
	{
		HairSetEntry[] listByType = GetListByType(hairType);
		return GetIndex(listByType, typeNum);
	}

	public HairSetEntry Get(HairType hairType, float typeNum)
	{
		HairSetEntry[] listByType = GetListByType(hairType);
		return listByType[GetIndex(listByType, typeNum)];
	}
}


using System;

[Serializable]
public struct HairSetEntry
{
	public HairSet HairSet;

	public GameObjectRef HairPrefab;

	public HairDyeCollection HairDyeCollection;
}


using Rust.Workshop;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skins/ItemSkin")]
public class ItemSkin : SteamInventoryItem
{
	public Skinnable Skinnable;

	public Material[] Materials;

	[Tooltip("If set, whenever we make an item with this skin, we'll spawn this item without a skin instead")]
	public ItemDefinition Redirect;

	public bool UnlockedByDefault;

	public void ApplySkin(GameObject obj)
	{
		if (!((Object)(object)Skinnable == (Object)null))
		{
			Skin.Apply(obj, Skinnable, Materials);
		}
	}

	public override bool HasUnlocked(ulong playerId)
	{
		if (UnlockedByDefault)
		{
			return true;
		}
		if ((Object)(object)Redirect != (Object)null && (Object)(object)Redirect.isRedirectOf != (Object)null && (Object)(object)Redirect.isRedirectOf.steamItem != (Object)null)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(playerId);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.blueprints.CheckSkinOwnership(Redirect.isRedirectOf.steamItem.id, basePlayer.userID))
			{
				return true;
			}
		}
		return base.HasUnlocked(playerId);
	}
}


using System;
using System.Linq;
using UnityEngine;

public class ItemSkinDirectory : ScriptableObject
{
	[Serializable]
	public struct Skin
	{
		public int id;

		public int itemid;

		public string name;

		public bool isSkin;

		private SteamInventoryItem _invItem;

		public SteamInventoryItem invItem
		{
			get
			{
				if ((Object)(object)_invItem == (Object)null && !string.IsNullOrEmpty(name))
				{
					_invItem = FileSystem.Load<SteamInventoryItem>(name, true);
				}
				return _invItem;
			}
		}
	}

	private static ItemSkinDirectory _Instance;

	public Skin[] skins;

	public static ItemSkinDirectory Instance
	{
		get
		{
			if ((Object)(object)_Instance == (Object)null)
			{
				_Instance = FileSystem.Load<ItemSkinDirectory>("assets/skins.asset", true);
				if ((Object)(object)_Instance == (Object)null)
				{
					throw new Exception("Couldn't load assets/skins.asset");
				}
				if (_Instance.skins == null || _Instance.skins.Length == 0)
				{
					throw new Exception("Loaded assets/skins.asset but something is wrong");
				}
			}
			return _Instance;
		}
	}

	public static Skin[] ForItem(ItemDefinition item)
	{
		return Instance.skins.Where((Skin x) => x.isSkin && x.itemid == item.itemid).ToArray();
	}

	public static Skin FindByInventoryDefinitionId(int id)
	{
		return Instance.skins.Where((Skin x) => x.id == id).FirstOrDefault();
	}

	public static bool TryGetItemFromDefinitionID(int id, out ItemDefinition result)
	{
		result = null;
		Skin skin = FindByInventoryDefinitionId(id);
		if ((Object)(object)skin.invItem != (Object)null)
		{
			result = skin.invItem.itemDefinition;
			if (skin.invItem is ItemSkin itemSkin && (Object)(object)itemSkin.Redirect != (Object)null)
			{
				result = itemSkin.Redirect;
			}
		}
		return (Object)(object)result != (Object)null;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Skin
{
	public int id;

	public int itemid;

	public string name;

	public bool isSkin;

	private SteamInventoryItem _invItem;

	public SteamInventoryItem invItem
	{
		get
		{
			if ((Object)(object)_invItem == (Object)null && !string.IsNullOrEmpty(name))
			{
				_invItem = FileSystem.Load<SteamInventoryItem>(name, true);
			}
			return _invItem;
		}
	}
}


using System;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Loot Spawn")]
public class LootSpawn : ScriptableObject
{
	[Serializable]
	public struct Entry
	{
		[Tooltip("If this category is chosen, we will spawn 1+ this amount")]
		public int extraSpawns;

		[Tooltip("If a subcategory exists we'll choose from there instead of any items specified")]
		public LootSpawn category;

		[Tooltip("The higher this number, the more likely this will be chosen")]
		public int weight;

		[Tooltip("Adding eras to this list will restrict the loot table to only work in these eras")]
		public Era[] restrictedEras;

		public int RuntimeWeightBonus()
		{
			return (BaseGameMode.GetActiveGameMode(serverside: true)?.GetLootWeightModifier(GetWeightBonusItem())).GetValueOrDefault();
		}

		public ItemDefinition GetWeightBonusItem()
		{
			if (category.allowedItems.Length == 1)
			{
				return category.allowedItems[0].itemDef;
			}
			return null;
		}
	}

	public ItemAmountRanged[] items;

	public Entry[] subSpawn;

	[NonSerialized]
	private Entry[] allowedSubSpawn;

	[NonSerialized]
	private ItemAmountRanged[] allowedItems;

	private Era era;

	private uint lastGameModeFilterApplied;

	public bool HasAnySpawns()
	{
		EnsureFilterUpdated();
		if (allowedSubSpawn.Length == 0)
		{
			return allowedItems.Length != 0;
		}
		return true;
	}

	public void ClearCache()
	{
		allowedItems = null;
		allowedSubSpawn = null;
		if (subSpawn != null)
		{
			Entry[] array = subSpawn;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].category?.ClearCache();
			}
		}
	}

	private void EnsureFilterUpdated()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool num = era != ConVar.Server.Era;
		bool flag = lastGameModeFilterApplied != BaseGameMode.GetActiveGameModeId(serverside: true);
		if (!num && !flag && allowedSubSpawn != null)
		{
			return;
		}
		era = ConVar.Server.Era;
		lastGameModeFilterApplied = BaseGameMode.GetActiveGameModeId(serverside: true);
		Entry[] array = subSpawn;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].category.EnsureFilterUpdated();
		}
		if (subSpawn == null || subSpawn.Length == 0)
		{
			allowedSubSpawn = Array.Empty<Entry>();
		}
		else
		{
			allowedSubSpawn = subSpawn.Where((Entry x) => x.category.HasAnySpawns() && (x.restrictedEras == null || x.restrictedEras.Length == 0 || Array.IndexOf(x.restrictedEras, ConVar.Server.Era) != -1)).ToArray();
		}
		if (items == null || items.Length == 0)
		{
			allowedItems = Array.Empty<ItemAmountRanged>();
			return;
		}
		allowedItems = items.Where((ItemAmountRanged x) => x.itemDef.IsAllowed((EraRestriction)2)).ToArray();
	}

	public ItemDefinition GetBlueprintBaseDef()
	{
		return ItemManager.FindItemDefinition("blueprintbase");
	}

	public void SpawnIntoContainer(ItemContainer container, ItemOwnershipShare ownership = default(ItemOwnershipShare), ItemContainer fallbackContainer = null)
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		EnsureFilterUpdated();
		if (allowedSubSpawn != null && allowedSubSpawn.Length != 0)
		{
			SubCategoryIntoContainer(container, ownership, fallbackContainer);
		}
		else
		{
			if (allowedItems == null)
			{
				return;
			}
			ItemAmountRanged[] array = allowedItems;
			foreach (ItemAmountRanged itemAmountRanged in array)
			{
				if (itemAmountRanged == null)
				{
					continue;
				}
				Item item = null;
				if (itemAmountRanged.itemDef.spawnAsBlueprint)
				{
					ItemDefinition blueprintBaseDef = GetBlueprintBaseDef();
					if ((Object)(object)blueprintBaseDef == (Object)null)
					{
						continue;
					}
					Item item2 = ItemManager.Create(blueprintBaseDef, 1, 0uL);
					item2.blueprintTarget = itemAmountRanged.itemDef.itemid;
					item = item2;
				}
				else
				{
					item = ItemManager.CreateByItemID(itemAmountRanged.itemid, (int)itemAmountRanged.GetAmount(), 0uL);
				}
				if (item == null)
				{
					continue;
				}
				item.OnVirginSpawn();
				if (ownership.IsValid())
				{
					item.SetItemOwnership(ownership.username, ownership.reason);
				}
				if (!item.MoveToContainer(container) && (fallbackContainer == null || !item.MoveToContainer(fallbackContainer)))
				{
					if (Object.op_Implicit((Object)(object)container.playerOwner))
					{
						item.Drop(container.playerOwner.GetDropPosition(), container.playerOwner.GetDropVelocity());
					}
					else
					{
						item.Remove();
					}
				}
			}
		}
	}

	private void SubCategoryIntoContainer(ItemContainer container, ItemOwnershipShare ownership = default(ItemOwnershipShare), ItemContainer fallbackContainer = null)
	{
		int num = allowedSubSpawn.Sum((Entry x) => x.weight + x.RuntimeWeightBonus());
		int num2 = Random.Range(0, num);
		for (int i = 0; i < allowedSubSpawn.Length; i++)
		{
			if ((Object)(object)allowedSubSpawn[i].category == (Object)null)
			{
				continue;
			}
			num -= allowedSubSpawn[i].weight + allowedSubSpawn[i].RuntimeWeightBonus();
			if (num2 >= num)
			{
				for (int j = 0; j < 1 + allowedSubSpawn[i].extraSpawns; j++)
				{
					allowedSubSpawn[i].category.SpawnIntoContainer(container, ownership, fallbackContainer);
				}
				return;
			}
		}
		string text = (((Object)(object)container.entityOwner != (Object)null) ? ((Object)container.entityOwner).name : "Unknown");
		Debug.LogWarning((object)$"SubCategoryIntoContainer for loot '{((Object)this).name}' for entity '{text}' ended with randomWeight ({num2}) < totalWeight ({num}). This should never happen! ", (Object)(object)this);
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public struct Entry
{
	[Tooltip("If this category is chosen, we will spawn 1+ this amount")]
	public int extraSpawns;

	[Tooltip("If a subcategory exists we'll choose from there instead of any items specified")]
	public LootSpawn category;

	[Tooltip("The higher this number, the more likely this will be chosen")]
	public int weight;

	[Tooltip("Adding eras to this list will restrict the loot table to only work in these eras")]
	public Era[] restrictedEras;

	public int RuntimeWeightBonus()
	{
		return (BaseGameMode.GetActiveGameMode(serverside: true)?.GetLootWeightModifier(GetWeightBonusItem())).GetValueOrDefault();
	}

	public ItemDefinition GetWeightBonusItem()
	{
		if (category.allowedItems.Length == 1)
		{
			return category.allowedItems[0].itemDef;
		}
		return null;
	}
}


using System;
using UnityEngine;

public static class MapImageRenderer
{
	private readonly struct Array2D<T>
	{
		private readonly T[] _items;

		private readonly int _width;

		private readonly int _height;

		public ref T this[int x, int y]
		{
			get
			{
				int num = Mathf.Clamp(x, 0, _width - 1);
				int num2 = Mathf.Clamp(y, 0, _height - 1);
				return ref _items[num2 * _width + num];
			}
		}

		public Array2D(T[] items, int width, int height)
		{
			_items = items;
			_width = width;
			_height = height;
		}
	}

	private static readonly Vector4 StartColor = new Vector4(0.28627452f, 23f / 85f, 0.24705884f, 1f);

	private static readonly Vector4 WaterColor = new Vector4(0.16941601f, 0.31755757f, 0.36200002f, 1f);

	private static readonly Vector4 GravelColor = new Vector4(0.25f, 37f / 152f, 0.22039475f, 1f);

	private static readonly Vector4 DirtColor = new Vector4(0.6f, 0.47959462f, 0.33f, 1f);

	private static readonly Vector4 SandColor = new Vector4(0.7f, 0.65968585f, 0.5277487f, 1f);

	private static readonly Vector4 GrassColor = new Vector4(0.35486364f, 0.37f, 0.2035f, 1f);

	private static readonly Vector4 ForestColor = new Vector4(0.24843751f, 0.3f, 9f / 128f, 1f);

	private static readonly Vector4 RockColor = new Vector4(0.4f, 0.39379844f, 0.37519377f, 1f);

	private static readonly Vector4 SnowColor = new Vector4(0.86274517f, 0.9294118f, 0.94117653f, 1f);

	private static readonly Vector4 PebbleColor = new Vector4(7f / 51f, 0.2784314f, 0.2761563f, 1f);

	private static readonly Vector4 OffShoreColor = new Vector4(0.04090196f, 0.22060032f, 14f / 51f, 1f);

	private static readonly Vector3 SunDirection = Vector3.Normalize(new Vector3(0.95f, 2.87f, 2.37f));

	private const float SunPower = 0.65f;

	private const float Brightness = 1.05f;

	private const float Contrast = 0.94f;

	private const float OceanWaterLevel = 0f;

	private static readonly Vector4 Half = new Vector4(0.5f, 0.5f, 0.5f, 0.5f);

	public static byte[] Render(out int imageWidth, out int imageHeight, out Color background, float scale = 0.5f, bool lossy = true, bool transparent = false, int oceanMargin = 500)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		if (lossy && transparent)
		{
			throw new ArgumentException("Rendering a transparent map is not possible when using lossy compression (JPG)");
		}
		imageWidth = 0;
		imageHeight = 0;
		background = Color.op_Implicit(OffShoreColor);
		TerrainTexturing instance = TerrainTexturing.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			return null;
		}
		Terrain component = ((Component)instance).GetComponent<Terrain>();
		TerrainMeta component2 = ((Component)instance).GetComponent<TerrainMeta>();
		TerrainHeightMap terrainHeightMap = ((Component)instance).GetComponent<TerrainHeightMap>();
		TerrainSplatMap terrainSplatMap = ((Component)instance).GetComponent<TerrainSplatMap>();
		TerrainTopologyMap terrainTopologyMap = ((Component)instance).GetComponent<TerrainTopologyMap>();
		if ((Object)(object)component == (Object)null || (Object)(object)component2 == (Object)null || (Object)(object)terrainHeightMap == (Object)null || (Object)(object)terrainSplatMap == (Object)null || (Object)(object)terrainTopologyMap == (Object)null)
		{
			return null;
		}
		int mapRes = (int)((float)World.Size * Mathf.Clamp(scale, 0.1f, 4f));
		float invMapRes = 1f / (float)mapRes;
		if (mapRes <= 0)
		{
			return null;
		}
		imageWidth = mapRes + oceanMargin * 2;
		imageHeight = mapRes + oceanMargin * 2;
		Color[] array = (Color[])(object)new Color[imageWidth * imageHeight];
		Array2D<Color> output = new Array2D<Color>(array, imageWidth, imageHeight);
		float maxDepth = (transparent ? Mathf.Max(Mathf.Abs(GetHeight(0f, 0f)), 5f) : 50f);
		Vector4 offShoreColor = (transparent ? Vector4.zero : OffShoreColor);
		Vector4 waterColor = (Vector4)(transparent ? new Vector4(WaterColor.x, WaterColor.y, WaterColor.z, 0.5f) : WaterColor);
		Parallel.For(0, imageHeight, (Action<int>)delegate(int y)
		{
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0086: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
			//IL_010a: Unknown result type (might be due to invalid IL or missing references)
			//IL_010f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0111: Unknown result type (might be due to invalid IL or missing references)
			//IL_0113: Unknown result type (might be due to invalid IL or missing references)
			//IL_012d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0132: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_0136: Unknown result type (might be due to invalid IL or missing references)
			//IL_0150: Unknown result type (might be due to invalid IL or missing references)
			//IL_0155: Unknown result type (might be due to invalid IL or missing references)
			//IL_0157: Unknown result type (might be due to invalid IL or missing references)
			//IL_0159: Unknown result type (might be due to invalid IL or missing references)
			//IL_0172: Unknown result type (might be due to invalid IL or missing references)
			//IL_0177: Unknown result type (might be due to invalid IL or missing references)
			//IL_0179: Unknown result type (might be due to invalid IL or missing references)
			//IL_017b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0194: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_0231: Unknown result type (might be due to invalid IL or missing references)
			//IL_0241: Unknown result type (might be due to invalid IL or missing references)
			//IL_0243: Unknown result type (might be due to invalid IL or missing references)
			//IL_0248: Unknown result type (might be due to invalid IL or missing references)
			//IL_024d: Unknown result type (might be due to invalid IL or missing references)
			//IL_024f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0251: Unknown result type (might be due to invalid IL or missing references)
			//IL_0256: Unknown result type (might be due to invalid IL or missing references)
			//IL_0260: Unknown result type (might be due to invalid IL or missing references)
			//IL_0265: Unknown result type (might be due to invalid IL or missing references)
			//IL_026a: Unknown result type (might be due to invalid IL or missing references)
			//IL_026f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0206: Unknown result type (might be due to invalid IL or missing references)
			//IL_0208: Unknown result type (might be due to invalid IL or missing references)
			//IL_020b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0228: Unknown result type (might be due to invalid IL or missing references)
			//IL_022d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0271: Unknown result type (might be due to invalid IL or missing references)
			//IL_0278: Unknown result type (might be due to invalid IL or missing references)
			//IL_027d: Unknown result type (might be due to invalid IL or missing references)
			//IL_02be: Unknown result type (might be due to invalid IL or missing references)
			//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
			//IL_02da: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
			//IL_02df: Unknown result type (might be due to invalid IL or missing references)
			y -= oceanMargin;
			float y2 = (float)y * invMapRes;
			int num = mapRes + oceanMargin;
			for (int i = -oceanMargin; i < num; i++)
			{
				float x2 = (float)i * invMapRes;
				Vector4 startColor = StartColor;
				float num2 = GetHeight(x2, y2);
				Vector3 val = GetNormal(x2, y2);
				float num3 = GetShoreDist(x2, y2);
				bool flag = (GetTopology(x2, y2) & 0x180) != 0;
				float num4 = Math.Max(Vector3.Dot(val, SunDirection), 0f);
				startColor = Vector4.Lerp(startColor, GravelColor, GetSplat(x2, y2, 128) * GravelColor.w);
				startColor = Vector4.Lerp(startColor, PebbleColor, GetSplat(x2, y2, 64) * PebbleColor.w);
				startColor = Vector4.Lerp(startColor, RockColor, GetSplat(x2, y2, 8) * RockColor.w);
				startColor = Vector4.Lerp(startColor, DirtColor, GetSplat(x2, y2, 1) * DirtColor.w);
				startColor = Vector4.Lerp(startColor, GrassColor, GetSplat(x2, y2, 16) * GrassColor.w);
				startColor = Vector4.Lerp(startColor, ForestColor, GetSplat(x2, y2, 32) * ForestColor.w);
				startColor = Vector4.Lerp(startColor, SandColor, GetSplat(x2, y2, 4) * SandColor.w);
				startColor = Vector4.Lerp(startColor, SnowColor, GetSplat(x2, y2, 2) * SnowColor.w);
				float num5 = 0f;
				if (num3 > 0f)
				{
					num5 = 0f - num2;
					if (num5 <= 0f || !flag)
					{
						num5 = Mathf.Max(num5, 0.1f * num3);
					}
				}
				if (num5 > 0f)
				{
					startColor = Vector4.Lerp(startColor, waterColor, Mathf.Clamp(0.5f + num5 / 5f, 0f, 1f));
					startColor = Vector4.Lerp(startColor, offShoreColor, Mathf.Clamp(num5 / maxDepth, 0f, 1f));
				}
				else
				{
					startColor += (num4 - 0.5f) * 0.65f * startColor;
					startColor = (startColor - Half) * 0.94f + Half;
				}
				startColor *= 1.05f;
				output[i + oceanMargin, y + oceanMargin] = (transparent ? new Color(startColor.x, startColor.y, startColor.z, startColor.w) : new Color(startColor.x, startColor.y, startColor.z));
			}
		});
		background = output[0, 0];
		return EncodeToFile(imageWidth, imageHeight, array, lossy);
		float GetHeight(float x, float y)
		{
			return terrainHeightMap.GetHeight(x, y);
		}
		Vector3 GetNormal(float x, float y)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			return terrainHeightMap.GetNormal(x, y);
		}
		static float GetShoreDist(float x, float y)
		{
			return TerrainTexturing.Instance.GetCoarseVectorToShore(x, y).shoreDist;
		}
		float GetSplat(float x, float y, int mask)
		{
			return terrainSplatMap.GetSplat(x, y, mask);
		}
		int GetTopology(float x, float y)
		{
			return terrainTopologyMap.GetTopology(x, y, 16f);
		}
	}

	private static byte[] EncodeToFile(int width, int height, Color[] pixels, bool lossy)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Expected O, but got Unknown
		Texture2D val = null;
		try
		{
			val = new Texture2D(width, height, (TextureFormat)4, false);
			val.SetPixels(pixels);
			val.Apply();
			return lossy ? ImageConversion.EncodeToJPG(val, 85) : ImageConversion.EncodeToPNG(val);
		}
		finally
		{
			if ((Object)(object)val != (Object)null)
			{
				Object.Destroy((Object)(object)val);
			}
		}
	}

	private static Vector3 UnpackNormal(Vector4 value)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		value.x *= value.w;
		Vector3 val = default(Vector3);
		val.x = value.x * 2f - 1f;
		val.y = value.y * 2f - 1f;
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor(val.x, val.y);
		val.z = Mathf.Sqrt(1f - Mathf.Clamp(Vector2.Dot(val2, val2), 0f, 1f));
		return val;
	}
}


using UnityEngine;

private readonly struct Array2D<T>
{
	private readonly T[] _items;

	private readonly int _width;

	private readonly int _height;

	public ref T this[int x, int y]
	{
		get
		{
			int num = Mathf.Clamp(x, 0, _width - 1);
			int num2 = Mathf.Clamp(y, 0, _height - 1);
			return ref _items[num2 * _width + num];
		}
	}

	public Array2D(T[] items, int width, int height)
	{
		_items = items;
		_width = width;
		_height = height;
	}
}


using Development.Attributes;
using Facepunch;
using UnityEngine;

[ResetStaticFields]
public static class NameHelper
{
	public static string FilterGenericName(string name)
	{
		return name;
	}

	public static string Get(ulong userId, string name, bool isClient = true, bool forceFriendly = false)
	{
		return name;
	}

	public static string Get(IPlayerInfo playerInfo, bool isClient = true)
	{
		return Get(playerInfo.UserId, playerInfo.UserName, isClient);
	}

	public static string GetPlayerNameStreamSafe(BasePlayer from, BasePlayer target)
	{
		if ((Object)(object)from == (Object)null || (Object)(object)target == (Object)null)
		{
			return string.Empty;
		}
		if (!from.net.connection.info.GetBool("global.streamermode", false))
		{
			return target.displayName;
		}
		return RandomUsernames.Get((ulong)target.userID);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Nexus.Models;
using UnityEngine;

public static class NexusUtil
{
	private static readonly char[] ScheduleSeparators = new char[1] { ',' };

	public static bool TryParseFerrySchedule(string zone, string scheduleString, out string[] entries)
	{
		if (string.IsNullOrWhiteSpace(zone) || string.IsNullOrWhiteSpace(scheduleString))
		{
			entries = null;
			return false;
		}
		string[] array = scheduleString.Split(ScheduleSeparators, StringSplitOptions.RemoveEmptyEntries);
		if (!array.Contains<string>(zone, StringComparer.InvariantCultureIgnoreCase))
		{
			Array.Resize(ref array, array.Length + 1);
			Array.Copy(array, 0, array, 1, array.Length - 1);
			array[0] = zone;
		}
		if (array.Length <= 1)
		{
			Debug.LogWarning((object)("Ferry schedule for '" + zone + "' needs at least two zones in it: " + scheduleString));
			entries = null;
			return false;
		}
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = array[i].Trim();
			string text = array[i];
			if (string.IsNullOrWhiteSpace(text))
			{
				Debug.LogWarning((object)("Ferry schedule for '" + zone + "' has empty entries: " + scheduleString));
				entries = null;
				return false;
			}
			string b = ((i == 0) ? array[^1] : array[i - 1]);
			if (string.Equals(text, b, StringComparison.InvariantCultureIgnoreCase))
			{
				Debug.LogWarning((object)("Ferry schedule for '" + zone + "' has the same zone twice in a row: " + scheduleString));
				entries = null;
				return false;
			}
		}
		entries = array;
		return true;
	}

	public static string ConnectionProtocol(this NexusZoneDetails zone)
	{
		if (zone == null || !zone.Variables.TryGetString("protocol", out var value))
		{
			return "";
		}
		return value ?? "";
	}

	public static bool IsStarterZone(this ZoneDetails zone)
	{
		return ((zone != null) ? zone.Variables : null).IsStarterZone();
	}

	public static bool IsStarterZone(this NexusZoneDetails zone)
	{
		return ((zone != null) ? zone.Variables : null).IsStarterZone();
	}

	private static bool IsStarterZone(this VariableDictionary variables)
	{
		string value;
		bool result = default(bool);
		return variables.TryGetString("starterZone", out value) && bool.TryParse(value, out result) && result;
	}

	public static bool TryGetString(this VariableDictionary variables, string key, out string value)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Invalid comparison between Unknown and I4
		if (variables != null && ((Dictionary<string, VariableData>)(object)variables).TryGetValue(key, out VariableData value2) && (int)((VariableData)(ref value2)).Type == 1 && !string.IsNullOrWhiteSpace(((VariableData)(ref value2)).Value))
		{
			value = ((VariableData)(ref value2)).Value;
			return true;
		}
		value = null;
		return false;
	}
}


using System;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Player/Player Bone Pos Data", fileName = "Player Bone Pos Data")]
public class PlayerBonePosData : ScriptableObject
{
	[Serializable]
	public class BonePosData
	{
		public AnimationClip sourceAnim;

		public float animStartTime;

		public Vector3 rootRotationOffset;

		[ReadOnly]
		public Vector3[] bonePositions;

		[ReadOnly]
		public Quaternion[] boneRotations;
	}

	public SkeletonDefinition skeletonDef;

	public GameObjectRef playerModel;

	[ReadOnly]
	public string[] boneNames;

	public BonePosData crawling;

	public BonePosData ducking;

	public BonePosData incapacitated;

	public BonePosData onladder;

	public BonePosData sleeping;

	public BonePosData standing;

	public BonePosData swimming;

	public BonePosData[] mountedPoses;

	public BonePosData GetBonePositionData(BasePlayer.PlayerFlags flagsOnDeath, ModelState modelState)
	{
		if (flagsOnDeath.HasFlag(BasePlayer.PlayerFlags.Sleeping))
		{
			return sleeping;
		}
		if (flagsOnDeath.HasFlag(BasePlayer.PlayerFlags.Incapacitated))
		{
			return incapacitated;
		}
		if (flagsOnDeath.HasFlag(BasePlayer.PlayerFlags.Wounded))
		{
			return crawling;
		}
		if (modelState.onLadder)
		{
			return onladder;
		}
		if (modelState.ducked)
		{
			return ducking;
		}
		if (modelState.waterLevel >= 0.75f)
		{
			return swimming;
		}
		if (modelState.mounted)
		{
			if (modelState.poseType < mountedPoses.Length)
			{
				return mountedPoses[modelState.poseType];
			}
			if (modelState.poseType == 128)
			{
				return standing;
			}
			Debug.LogWarning((object)$"PlayerCorpse GetBonePositionData: No saved bone position data for mount pose {modelState.poseType}. Falling back to SitGeneric. Please update the 'Server Side Ragdoll Bone Pos Data' file with the new mount pose.");
			return mountedPoses[7];
		}
		return standing;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BonePosData
{
	public AnimationClip sourceAnim;

	public float animStartTime;

	public Vector3 rootRotationOffset;

	[ReadOnly]
	public Vector3[] bonePositions;

	[ReadOnly]
	public Quaternion[] boneRotations;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Player/Player Inventory Properties")]
public class PlayerInventoryProperties : BaseScriptableObject
{
	[Serializable]
	public class ItemAmountSkinned : ItemAmount
	{
		public ulong skinOverride;

		public bool blueprint;
	}

	public enum LoadoutCategory
	{
		Tiers,
		NPCs,
		Other
	}

	public string niceName;

	public int order = 100;

	public LoadoutCategory category = LoadoutCategory.Other;

	public List<ItemAmountSkinned> belt;

	public List<ItemAmountSkinned> main;

	public List<ItemAmountSkinned> wear;

	public bool StripBelt = true;

	public bool StripMain = true;

	public bool StripWear = true;

	public GameObjectRef DeathIconPrefab;

	public PlayerInventoryProperties giveBase;

	private static PlayerInventoryProperties[] allInventories;

	public void GiveToPlayer(BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return;
		}
		if (player is HumanNPC humanNPC && DeathIconPrefab.isValid)
		{
			humanNPC.DeathIconOverride = DeathIconPrefab;
		}
		if (giveBase != null)
		{
			giveBase.GiveToPlayer(player);
		}
		if (belt != null && belt.Count > 0)
		{
			if (StripBelt)
			{
				player.inventory.containerBelt.Clear();
			}
			foreach (ItemAmountSkinned item2 in belt)
			{
				CreateItem(item2, player.inventory.containerBelt);
			}
		}
		if (main != null && main.Count > 0)
		{
			if (StripMain)
			{
				player.inventory.containerMain.Clear();
			}
			foreach (ItemAmountSkinned item3 in main)
			{
				CreateItem(item3, player.inventory.containerMain);
			}
		}
		if (wear == null || wear.Count <= 0)
		{
			return;
		}
		if (StripWear)
		{
			player.inventory.containerWear.Clear();
		}
		foreach (ItemAmountSkinned item4 in wear)
		{
			CreateItem(item4, player.inventory.containerWear);
		}
		void CreateItem(ItemAmountSkinned toCreate, ItemContainer destination)
		{
			Item item = null;
			if (toCreate.blueprint)
			{
				item = ItemManager.Create(ItemManager.blueprintBaseDef, 1, 0uL);
				item.blueprintTarget = (((Object)(object)toCreate.itemDef.isRedirectOf != (Object)null) ? toCreate.itemDef.isRedirectOf.itemid : toCreate.itemDef.itemid);
			}
			else
			{
				item = ItemManager.Create(toCreate.itemDef, (int)toCreate.amount, toCreate.skinOverride);
			}
			player.inventory.GiveItem(item, destination);
		}
	}

	public static PlayerInventoryProperties GetInventoryConfig(string name)
	{
		if (allInventories == null)
		{
			allInventories = FileSystem.LoadAll<PlayerInventoryProperties>("assets/content/properties/playerinventory", "");
			Debug.Log((object)$"Found {allInventories.Length} inventories");
		}
		if (allInventories != null)
		{
			PlayerInventoryProperties[] array = allInventories;
			foreach (PlayerInventoryProperties playerInventoryProperties in array)
			{
				if (playerInventoryProperties.niceName.ToLower() == name.ToLower())
				{
					return playerInventoryProperties;
				}
			}
		}
		return null;
	}
}


using System;

[Serializable]
public class ItemAmountSkinned : ItemAmount
{
	public ulong skinOverride;

	public bool blueprint;
}


public enum LoadoutCategory
{
	Tiers,
	NPCs,
	Other
}


using UnityEngine;

public class PolymorphicAttribute : PropertyAttribute
{
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Protection Properties")]
public class ProtectionProperties : ScriptableObject
{
	[TextArea]
	public string comments;

	[Range(0f, 100f)]
	public float density = 1f;

	[ArrayIndexIsEnumRanged(enumType = typeof(DamageType), min = -4f, max = 3f)]
	public float[] amounts = new float[26];

	public void OnValidate()
	{
		if (amounts.Length >= 26)
		{
			return;
		}
		float[] array = new float[26];
		for (int i = 0; i < array.Length; i++)
		{
			if (i >= amounts.Length)
			{
				if (i == 21)
				{
					array[i] = amounts[9];
				}
			}
			else
			{
				array[i] = amounts[i];
			}
		}
		amounts = array;
	}

	public void Clear()
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			amounts[i] = 0f;
		}
	}

	public void Add(float amount)
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			amounts[i] += amount;
		}
	}

	public void Add(DamageType index, float amount)
	{
		amounts[(int)index] += amount;
	}

	public void Add(ProtectionProperties other, float scale)
	{
		for (int i = 0; i < Mathf.Min(other.amounts.Length, amounts.Length); i++)
		{
			amounts[i] += other.amounts[i] * scale;
		}
	}

	public void Add(List<Item> items, HitArea area = (HitArea)(-1))
	{
		for (int i = 0; i < items.Count; i++)
		{
			Item item = items[i];
			ItemModWearable component = ((Component)item.info).GetComponent<ItemModWearable>();
			if (!((Object)(object)component == (Object)null) && component.ProtectsArea(area))
			{
				component.CollectProtection(item, this);
			}
		}
	}

	public void Multiply(float multiplier)
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			amounts[i] *= multiplier;
		}
	}

	public void Multiply(DamageType index, float multiplier)
	{
		amounts[(int)index] *= multiplier;
	}

	public void Scale(DamageTypeList damageList, float ProtectionAmount = 1f)
	{
		for (int i = 0; i < amounts.Length; i++)
		{
			if (amounts[i] != 0f)
			{
				damageList.Scale((DamageType)i, 1f - Mathf.Clamp(amounts[i] * ProtectionAmount, -1f, 1f));
			}
		}
	}

	public float Get(DamageType damageType)
	{
		return amounts[(int)damageType];
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Recipe")]
public class Recipe : ScriptableObject
{
	[Serializable]
	public struct RecipeIngredient
	{
		public ItemDefinition Ingredient;

		[SerializeField]
		private int Count;

		public int GetIngredientCount(ItemDefinition producedItem)
		{
			BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
			float num = 1f;
			if ((Object)(object)activeGameMode != (Object)null)
			{
				num = activeGameMode.GetCraftingCostModifier(producedItem);
			}
			return Mathf.RoundToInt((float)Count * num);
		}
	}

	[Header("Produced Item")]
	public ItemDefinition ProducedItem;

	public int ProducedItemCount = 1;

	public bool CanQueueMultiple = true;

	[Header("Spawned Item")]
	public GameObjectRef SpawnedItem;

	public string SpawnedItemName;

	public string SpawnedItemDescription;

	public Sprite SpawnedItemIcon;

	[Header("Misc")]
	public bool RequiresBlueprint;

	public RecipeIngredient[] Ingredients;

	public float MixingDuration;

	public string DisplayName
	{
		get
		{
			if ((Object)(object)ProducedItem != (Object)null)
			{
				return ProducedItem.displayName.translated;
			}
			if (SpawnedItem != null)
			{
				return SpawnedItemName;
			}
			return null;
		}
	}

	public string DisplayDescription
	{
		get
		{
			if ((Object)(object)ProducedItem != (Object)null)
			{
				return ProducedItem.displayDescription.translated;
			}
			if (SpawnedItem != null)
			{
				return SpawnedItemDescription;
			}
			return null;
		}
	}

	public Sprite DisplayIcon
	{
		get
		{
			if ((Object)(object)ProducedItem != (Object)null)
			{
				return ProducedItem.iconSprite;
			}
			if (SpawnedItem != null)
			{
				return SpawnedItemIcon;
			}
			return null;
		}
	}

	public bool ContainsItem(Item item)
	{
		if (item == null)
		{
			return false;
		}
		if (Ingredients == null)
		{
			return false;
		}
		RecipeIngredient[] ingredients = Ingredients;
		for (int i = 0; i < ingredients.Length; i++)
		{
			RecipeIngredient recipeIngredient = ingredients[i];
			if ((Object)(object)item.info == (Object)(object)recipeIngredient.Ingredient)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct RecipeIngredient
{
	public ItemDefinition Ingredient;

	[SerializeField]
	private int Count;

	public int GetIngredientCount(ItemDefinition producedItem)
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		float num = 1f;
		if ((Object)(object)activeGameMode != (Object)null)
		{
			num = activeGameMode.GetCraftingCostModifier(producedItem);
		}
		return Mathf.RoundToInt((float)Count * num);
	}
}


using System.Collections.Generic;
using UnityEngine;

public static class RecipeDictionary
{
	private static Dictionary<uint, Dictionary<int, List<Recipe>>> recipeListsDict = new Dictionary<uint, Dictionary<int, List<Recipe>>>();

	public static void CacheRecipes(RecipeList recipeList)
	{
		if (recipeList == null || recipeListsDict.TryGetValue(recipeList.FilenameStringId, out var _))
		{
			return;
		}
		Dictionary<int, List<Recipe>> dictionary = new Dictionary<int, List<Recipe>>();
		recipeListsDict.Add(recipeList.FilenameStringId, dictionary);
		foreach (Recipe allRecipe in recipeList.AllRecipes)
		{
			List<Recipe> value2 = null;
			if (!dictionary.TryGetValue(allRecipe.Ingredients[0].Ingredient.itemid, out value2))
			{
				value2 = new List<Recipe>();
				dictionary.Add(allRecipe.Ingredients[0].Ingredient.itemid, value2);
			}
			value2.Add(allRecipe);
		}
	}

	public static Recipe GetMatchingRecipeAndQuantity(RecipeList recipeList, List<Item> orderedIngredients, out int quantity)
	{
		quantity = 0;
		if (recipeList == null)
		{
			return null;
		}
		if (orderedIngredients == null || orderedIngredients.Count == 0)
		{
			return null;
		}
		List<Recipe> recipesByFirstIngredient = GetRecipesByFirstIngredient(recipeList, orderedIngredients[0]);
		if (recipesByFirstIngredient == null)
		{
			return null;
		}
		foreach (Recipe item2 in recipesByFirstIngredient)
		{
			if ((Object)(object)item2 == (Object)null || item2.Ingredients.Length != orderedIngredients.Count)
			{
				continue;
			}
			bool flag = true;
			int num = int.MaxValue;
			int num2 = 0;
			Recipe.RecipeIngredient[] ingredients = item2.Ingredients;
			for (int i = 0; i < ingredients.Length; i++)
			{
				Recipe.RecipeIngredient recipeIngredient = ingredients[i];
				Item item = orderedIngredients[num2];
				int ingredientCount = recipeIngredient.GetIngredientCount(item2.ProducedItem);
				if ((Object)(object)recipeIngredient.Ingredient != (Object)(object)item.info || item.amount < ingredientCount)
				{
					flag = false;
					break;
				}
				int num3 = item.amount / ingredientCount;
				if (num2 == 0)
				{
					num = num3;
				}
				else if (num3 < num)
				{
					num = num3;
				}
				num2++;
			}
			if (flag)
			{
				quantity = num;
				if (quantity > 1 && !item2.CanQueueMultiple)
				{
					quantity = 1;
				}
				return item2;
			}
		}
		return null;
	}

	private static List<Recipe> GetRecipesByFirstIngredient(RecipeList recipeList, Item firstIngredient)
	{
		if (recipeList == null)
		{
			return null;
		}
		if (firstIngredient == null)
		{
			return null;
		}
		if (!recipeListsDict.TryGetValue(recipeList.FilenameStringId, out var value))
		{
			CacheRecipes(recipeList);
			if (!recipeListsDict.TryGetValue(recipeList.FilenameStringId, out value))
			{
				return null;
			}
		}
		if (value == null)
		{
			return null;
		}
		if (!value.TryGetValue(firstIngredient.info.itemid, out var value2))
		{
			return null;
		}
		return value2;
	}

	public static bool ValidIngredientForARecipe(Item ingredient, RecipeList recipeList)
	{
		if (ingredient == null)
		{
			return false;
		}
		if (recipeList == null)
		{
			return false;
		}
		foreach (Recipe allRecipe in recipeList.AllRecipes)
		{
			if (!((Object)(object)allRecipe == (Object)null) && allRecipe.ContainsItem(ingredient))
			{
				return true;
			}
		}
		return false;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Recipe List")]
public class RecipeList : BaseScriptableObject
{
	public Recipe[] Recipes;

	public RecipeList[] AdditionalRecipeLists;

	private bool initd;

	private List<Recipe> _recipes;

	public List<Recipe> AllRecipes
	{
		get
		{
			if (initd)
			{
				return _recipes;
			}
			initd = true;
			_recipes = new List<Recipe>();
			if (Recipes != null)
			{
				_recipes.AddRange(Recipes);
			}
			if (AdditionalRecipeLists != null)
			{
				RecipeList[] additionalRecipeLists = AdditionalRecipeLists;
				foreach (RecipeList recipeList in additionalRecipeLists)
				{
					_recipes.AddRange(recipeList.Recipes);
				}
			}
			return _recipes;
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Recoil Properties")]
public class RecoilProperties : ScriptableObject
{
	public float recoilYawMin;

	public float recoilYawMax;

	public float recoilPitchMin;

	public float recoilPitchMax;

	public float timeToTakeMin;

	public float timeToTakeMax = 0.1f;

	public float ADSScale = 0.5f;

	public float movementPenalty;

	public float clampPitch = float.NegativeInfinity;

	public AnimationCurve pitchCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public AnimationCurve yawCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public bool useCurves;

	public bool curvesAsScalar;

	public int shotsUntilMax = 30;

	public float maxRecoilRadius = 5f;

	[Header("AimCone")]
	public bool overrideAimconeWithCurve;

	public float aimconeCurveScale = 1f;

	[Tooltip("How much to scale aimcone by based on how far into the shot sequence we are (shots v shotsUntilMax)")]
	public AnimationCurve aimconeCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	[Tooltip("Randomly select how much to scale final aimcone by per shot, you can use this to weigh a fraction of shots closer to the center")]
	public AnimationCurve aimconeProbabilityCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 1f),
		new Keyframe(0.5f, 0f),
		new Keyframe(1f, 1f)
	});

	[Tooltip("Scale the actual final aimcone produced by the ammunition itself if the ammo contains multiple projectiles")]
	public float ammoAimconeScaleMultiProjectile = 1f;

	[Tooltip("Scale the actual final aimcone produced by the ammunition itself if the ammo contains only one projectile")]
	public float ammoAimconeScaleSingleProjectile = 1f;

	public RecoilProperties newRecoilOverride;

	public RecoilProperties GetRecoil()
	{
		if (!((Object)(object)newRecoilOverride != (Object)null))
		{
			return this;
		}
		return newRecoilOverride;
	}
}


using System;

[Serializable]
public class SkinReplacement
{
	public enum SkinType
	{
		NONE,
		Hands,
		Head,
		Feet,
		Torso,
		Legs
	}

	public SkinType skinReplacementType;

	public GameObjectRef targetReplacement;
}


public enum SkinType
{
	NONE,
	Hands,
	Head,
	Feet,
	Torso,
	Legs
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skin Set")]
public class SkinSet : ScriptableObject
{
	public string Label;

	public Gradient SkinColour;

	public HairSetCollection HairCollection;

	[Header("Models")]
	public GameObjectRef Head;

	public GameObjectRef Torso;

	public GameObjectRef Legs;

	public GameObjectRef Feet;

	public GameObjectRef Hands;

	[Header("Censored Variants")]
	public GameObjectRef CensoredTorso;

	public GameObjectRef CensoredLegs;

	[Header("Materials")]
	public Material HeadMaterial;

	public Material BodyMaterial;

	public Material EyeMaterial;

	internal Color GetSkinColor(float skinNumber)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return SkinColour.Evaluate(skinNumber);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skin Set Collection")]
public class SkinSetCollection : ScriptableObject
{
	public SkinSet[] Skins;

	public int GetIndex(float MeshNumber)
	{
		return Mathf.Clamp(Mathf.FloorToInt(MeshNumber * (float)Skins.Length), 0, Skins.Length - 1);
	}

	public SkinSet Get(float MeshNumber)
	{
		return Skins[GetIndex(MeshNumber)];
	}
}


using System;

[AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
public sealed class SoftRequireComponent : Attribute
{
	public Type m_Type0;

	public Type m_Type1;

	public Type m_Type2;

	public SoftRequireComponent(Type requiredComponent)
	{
		m_Type0 = requiredComponent;
	}

	public SoftRequireComponent(Type requiredComponent, Type requiredComponent2)
	{
		m_Type0 = requiredComponent;
		m_Type1 = requiredComponent2;
	}

	public SoftRequireComponent(Type requiredComponent, Type requiredComponent2, Type requiredComponent3)
	{
		m_Type0 = requiredComponent;
		m_Type1 = requiredComponent2;
		m_Type2 = requiredComponent3;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Steam DLC Item")]
public class SteamDLCItem : ScriptableObject
{
	public Phrase dlcName;

	public int dlcAppID;

	public bool bypassLicenseCheck;

	public bool HasLicense(ulong steamid)
	{
		if (bypassLicenseCheck)
		{
			return true;
		}
		if (!PlatformService.Instance.IsValid)
		{
			return false;
		}
		return PlatformService.Instance.PlayerOwnsDownloadableContent(steamid, dlcAppID);
	}

	public bool CanUse(BasePlayer player)
	{
		if (player.isServer)
		{
			if (!HasLicense(player.userID))
			{
				return (ulong)player.userID < 10000000;
			}
			return true;
		}
		return false;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Generic Steam Inventory Category")]
public class SteamInventoryCategory : ScriptableObject
{
	public enum Price
	{
		CannotBuy,
		VLV25,
		VLV50,
		VLV75,
		VLV100,
		VLV150,
		VLV200,
		VLV250,
		VLV300,
		VLV350,
		VLV400,
		VLV450,
		VLV500,
		VLV550,
		VLV600,
		VLV650,
		VLV700,
		VLV750,
		VLV800,
		VLV850,
		VLV900,
		VLV950,
		VLV1000,
		VLV1100,
		VLV1200,
		VLV1300,
		VLV1400,
		VLV1500,
		VLV1600,
		VLV1700,
		VLV1800,
		VLV1900,
		VLV2000,
		VLV2500,
		VLV3000,
		VLV3500,
		VLV4000,
		VLV4500,
		VLV5000,
		VLV6000,
		VLV7000,
		VLV8000,
		VLV9000,
		VLV10000
	}

	public enum DropChance
	{
		NeverDrop,
		VeryRare,
		Rare,
		Common,
		VeryCommon,
		ExtremelyRare
	}

	[Header("Steam Inventory")]
	public bool canBeSoldToOtherUsers;

	public bool canBeTradedWithOtherUsers;

	public bool isCommodity;

	public Price price;

	public DropChance dropChance;

	public bool CanBeInCrates = true;
}


public enum Price
{
	CannotBuy,
	VLV25,
	VLV50,
	VLV75,
	VLV100,
	VLV150,
	VLV200,
	VLV250,
	VLV300,
	VLV350,
	VLV400,
	VLV450,
	VLV500,
	VLV550,
	VLV600,
	VLV650,
	VLV700,
	VLV750,
	VLV800,
	VLV850,
	VLV900,
	VLV950,
	VLV1000,
	VLV1100,
	VLV1200,
	VLV1300,
	VLV1400,
	VLV1500,
	VLV1600,
	VLV1700,
	VLV1800,
	VLV1900,
	VLV2000,
	VLV2500,
	VLV3000,
	VLV3500,
	VLV4000,
	VLV4500,
	VLV5000,
	VLV6000,
	VLV7000,
	VLV8000,
	VLV9000,
	VLV10000
}


public enum DropChance
{
	NeverDrop,
	VeryRare,
	Rare,
	Common,
	VeryCommon,
	ExtremelyRare
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Skins/Inventory Item")]
public class SteamInventoryItem : ScriptableObject
{
	public enum Category
	{
		None,
		Clothing,
		Weapon,
		Decoration,
		Crate,
		Resource
	}

	public enum SubCategory
	{
		None,
		Shirt,
		Pants,
		Jacket,
		Hat,
		Mask,
		Footwear,
		Weapon,
		Misc,
		Crate,
		Resource,
		CrateUncraftable
	}

	public int id;

	public Sprite icon;

	public Phrase displayName;

	public Phrase displayDescription;

	[Tooltip("Images to show on the Steam store page for this item. Should all be square and hosted on https://files.facepunch.com/")]
	public string[] storeImages = Array.Empty<string>();

	[Header("Steam Inventory")]
	public Category category;

	public SubCategory subcategory;

	public SteamInventoryCategory steamCategory;

	[Tooltip("If true then this item will be placed under the Limited tab, otherwise it goes under General.")]
	public bool isLimitedTimeOffer = true;

	[Tooltip("Stop this item being broken down into cloth etc")]
	public bool PreventBreakingDown;

	[Tooltip("Set to true to allow players to delete the item from their inventory")]
	public bool IsTwitchDrop;

	[Header("Meta")]
	public string itemname;

	public ulong workshopID;

	public SteamDLCItem DlcItem;

	[Tooltip("Does nothing currently")]
	public bool forceCraftableItemDesc;

	[Tooltip("If enabled the item store will not show this as a 3d model")]
	public bool forceDisableTurntableInItemStore;

	[Tooltip("If the player owns this steam item, we will consider ourselves unlocked")]
	public SteamInventoryItem UnlockedViaSteamItem;

	public ItemDefinition itemDefinition => ItemManager.FindItemDefinition(itemname);

	public virtual bool HasUnlocked(ulong playerId)
	{
		if ((Object)(object)DlcItem != (Object)null && DlcItem.HasLicense(playerId))
		{
			return true;
		}
		if ((Object)(object)UnlockedViaSteamItem != (Object)null)
		{
			BasePlayer basePlayer = BasePlayer.FindByID(playerId);
			if ((Object)(object)basePlayer != (Object)null && basePlayer.blueprints.CheckSkinOwnership(UnlockedViaSteamItem.id, basePlayer.userID))
			{
				return true;
			}
		}
		return false;
	}
}


public enum Category
{
	None,
	Clothing,
	Weapon,
	Decoration,
	Crate,
	Resource
}


public enum SubCategory
{
	None,
	Shirt,
	Pants,
	Jacket,
	Hat,
	Mask,
	Footwear,
	Weapon,
	Misc,
	Crate,
	Resource,
	CrateUncraftable
}


using System;
using System.Collections.Generic;

public static class StringFormatCache
{
	private struct Key1 : IEquatable<Key1>
	{
		public string format;

		public string value1;

		public Key1(string format, string value1)
		{
			this.format = format;
			this.value1 = value1;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key1))
			{
				return false;
			}
			return Equals((Key1)other);
		}

		public bool Equals(Key1 other)
		{
			if (format == other.format)
			{
				return value1 == other.value1;
			}
			return false;
		}
	}

	private struct Key2 : IEquatable<Key2>
	{
		public string format;

		public string value1;

		public string value2;

		public Key2(string format, string value1, string value2)
		{
			this.format = format;
			this.value1 = value1;
			this.value2 = value2;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key2))
			{
				return false;
			}
			return Equals((Key2)other);
		}

		public bool Equals(Key2 other)
		{
			if (format == other.format && value1 == other.value1)
			{
				return value2 == other.value2;
			}
			return false;
		}
	}

	private struct Key3 : IEquatable<Key3>
	{
		public string format;

		public string value1;

		public string value2;

		public string value3;

		public Key3(string format, string value1, string value2, string value3)
		{
			this.format = format;
			this.value1 = value1;
			this.value2 = value2;
			this.value3 = value3;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key3))
			{
				return false;
			}
			return Equals((Key3)other);
		}

		public bool Equals(Key3 other)
		{
			if (format == other.format && value1 == other.value1 && value2 == other.value2)
			{
				return value3 == other.value3;
			}
			return false;
		}
	}

	private struct Key4 : IEquatable<Key4>
	{
		public string format;

		public string value1;

		public string value2;

		public string value3;

		public string value4;

		public Key4(string format, string value1, string value2, string value3, string value4)
		{
			this.format = format;
			this.value1 = value1;
			this.value2 = value2;
			this.value3 = value3;
			this.value4 = value4;
		}

		public override int GetHashCode()
		{
			return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode() ^ value4.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Key4))
			{
				return false;
			}
			return Equals((Key4)other);
		}

		public bool Equals(Key4 other)
		{
			if (format == other.format && value1 == other.value1 && value2 == other.value2 && value3 == other.value3)
			{
				return value4 == other.value4;
			}
			return false;
		}
	}

	private static Dictionary<Key1, string> dict1 = new Dictionary<Key1, string>();

	private static Dictionary<Key2, string> dict2 = new Dictionary<Key2, string>();

	private static Dictionary<Key3, string> dict3 = new Dictionary<Key3, string>();

	private static Dictionary<Key4, string> dict4 = new Dictionary<Key4, string>();

	public static string Get(string format, string value1)
	{
		Key1 key = new Key1(format, value1);
		if (!dict1.TryGetValue(key, out var value2))
		{
			value2 = string.Format(format, value1);
			dict1.Add(key, value2);
		}
		return value2;
	}

	public static string Get(string format, string value1, string value2)
	{
		Key2 key = new Key2(format, value1, value2);
		if (!dict2.TryGetValue(key, out var value3))
		{
			value3 = string.Format(format, value1, value2);
			dict2.Add(key, value3);
		}
		return value3;
	}

	public static string Get(string format, string value1, string value2, string value3)
	{
		Key3 key = new Key3(format, value1, value2, value3);
		if (!dict3.TryGetValue(key, out var value4))
		{
			value4 = string.Format(format, value1, value2, value3);
			dict3.Add(key, value4);
		}
		return value4;
	}

	public static string Get(string format, string value1, string value2, string value3, string value4)
	{
		Key4 key = new Key4(format, value1, value2, value3, value4);
		if (!dict4.TryGetValue(key, out var value5))
		{
			value5 = string.Format(format, value1, value2, value3, value4);
			dict4.Add(key, value5);
		}
		return value5;
	}
}


using System;

private struct Key1 : IEquatable<Key1>
{
	public string format;

	public string value1;

	public Key1(string format, string value1)
	{
		this.format = format;
		this.value1 = value1;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key1))
		{
			return false;
		}
		return Equals((Key1)other);
	}

	public bool Equals(Key1 other)
	{
		if (format == other.format)
		{
			return value1 == other.value1;
		}
		return false;
	}
}


using System;

private struct Key2 : IEquatable<Key2>
{
	public string format;

	public string value1;

	public string value2;

	public Key2(string format, string value1, string value2)
	{
		this.format = format;
		this.value1 = value1;
		this.value2 = value2;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key2))
		{
			return false;
		}
		return Equals((Key2)other);
	}

	public bool Equals(Key2 other)
	{
		if (format == other.format && value1 == other.value1)
		{
			return value2 == other.value2;
		}
		return false;
	}
}


using System;

private struct Key3 : IEquatable<Key3>
{
	public string format;

	public string value1;

	public string value2;

	public string value3;

	public Key3(string format, string value1, string value2, string value3)
	{
		this.format = format;
		this.value1 = value1;
		this.value2 = value2;
		this.value3 = value3;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key3))
		{
			return false;
		}
		return Equals((Key3)other);
	}

	public bool Equals(Key3 other)
	{
		if (format == other.format && value1 == other.value1 && value2 == other.value2)
		{
			return value3 == other.value3;
		}
		return false;
	}
}


using System;

private struct Key4 : IEquatable<Key4>
{
	public string format;

	public string value1;

	public string value2;

	public string value3;

	public string value4;

	public Key4(string format, string value1, string value2, string value3, string value4)
	{
		this.format = format;
		this.value1 = value1;
		this.value2 = value2;
		this.value3 = value3;
		this.value4 = value4;
	}

	public override int GetHashCode()
	{
		return format.GetHashCode() ^ value1.GetHashCode() ^ value2.GetHashCode() ^ value3.GetHashCode() ^ value4.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Key4))
		{
			return false;
		}
		return Equals((Key4)other);
	}

	public bool Equals(Key4 other)
	{
		if (format == other.format && value1 == other.value1 && value2 == other.value2 && value3 == other.value3)
		{
			return value4 == other.value4;
		}
		return false;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class StringPool
{
	public static Dictionary<uint, string> toString;

	public static Dictionary<string, uint> toNumber;

	private static bool initialized;

	public static uint closest;

	private static void Init()
	{
		if (initialized)
		{
			return;
		}
		toString = new Dictionary<uint, string>();
		toNumber = new Dictionary<string, uint>(StringComparer.OrdinalIgnoreCase);
		GameManifest gameManifest = FileSystem.Load<GameManifest>("Assets/manifest.asset", true);
		for (uint num = 0u; num < gameManifest.pooledStrings.Length; num++)
		{
			string str = gameManifest.pooledStrings[num].str;
			uint hash = gameManifest.pooledStrings[num].hash;
			if (toString.TryGetValue(hash, out var value))
			{
				if (str != value)
				{
					Debug.LogWarning((object)$"Hash collision: {hash} already exists in string pool. `{str}` and `{value}` have the same hash.");
				}
			}
			else
			{
				toString.Add(hash, str);
				toNumber.Add(str, hash);
			}
		}
		initialized = true;
		closest = Get("closest");
	}

	public static string Get(uint i)
	{
		if (i == 0)
		{
			return string.Empty;
		}
		Init();
		if (toString.TryGetValue(i, out var value))
		{
			return value;
		}
		Debug.LogWarning((object)("StringPool.GetString - no string for ID" + i));
		return "";
	}

	public static uint Get(string str)
	{
		if (string.IsNullOrEmpty(str))
		{
			return 0u;
		}
		Init();
		if (toNumber.TryGetValue(str, out var value))
		{
			return value;
		}
		Debug.LogWarning((object)("StringPool.GetNumber - no number for string " + str));
		return 0u;
	}

	public static uint Add(string str)
	{
		uint value = 0u;
		if (!toNumber.TryGetValue(str, out value))
		{
			value = StringEx.ManifestHash(str);
			toString.Add(value, str);
			toNumber.Add(str, value);
		}
		return value;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Underwear")]
public class Underwear : ScriptableObject
{
	public string shortname = "";

	public Phrase displayName;

	public Sprite icon;

	public Sprite iconFemale;

	public SkinReplacement[] replacementsMale;

	public SkinReplacement[] replacementsFemale;

	[Tooltip("User can craft this item on any server if they have this steam item")]
	public SteamInventoryItem steamItem;

	[Tooltip("User can craft this item if they have this DLC purchased")]
	public SteamDLCItem steamDLC;

	public bool adminOnly;

	public uint GetID()
	{
		return StringPool.Get(shortname);
	}

	public bool HasMaleParts()
	{
		return replacementsMale.Length != 0;
	}

	public bool HasFemaleParts()
	{
		return replacementsFemale.Length != 0;
	}

	public bool ValidForPlayer(BasePlayer player)
	{
		if (HasMaleParts() && HasFemaleParts())
		{
			return true;
		}
		bool flag = IsFemale(player);
		if (flag && HasFemaleParts())
		{
			return true;
		}
		if (!flag && HasMaleParts())
		{
			return true;
		}
		return false;
	}

	public static bool IsFemale(BasePlayer player)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		ulong num = player.userID.Get();
		long num2 = 4332L;
		State state = Random.state;
		Random.InitState((int)(num2 + (long)num));
		float num3 = Random.Range(0f, 1f);
		Random.state = state;
		if (!(num3 > 0.5f))
		{
			return false;
		}
		return true;
	}

	public static bool Validate(Underwear underwear, BasePlayer player)
	{
		if ((Object)(object)underwear == (Object)null)
		{
			return true;
		}
		if (!underwear.ValidForPlayer(player))
		{
			return false;
		}
		if (underwear.adminOnly && (!player.IsAdmin || !player.IsDeveloper))
		{
			return false;
		}
		bool num = (Object)(object)underwear.steamItem == (Object)null || player.blueprints.steamInventory.HasItem(underwear.steamItem.id);
		bool flag = false;
		if (player.isServer && ((Object)(object)underwear.steamDLC == (Object)null || underwear.steamDLC.HasLicense(player.userID)))
		{
			flag = true;
		}
		return num && flag;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Underwear Manifest")]
public class UnderwearManifest : ScriptableObject
{
	public static UnderwearManifest instance;

	public List<Underwear> underwears;

	public static UnderwearManifest Get()
	{
		if ((Object)(object)instance == (Object)null)
		{
			instance = Resources.Load<UnderwearManifest>("UnderwearManifest");
		}
		return instance;
	}

	public void PrintManifest()
	{
		Debug.Log((object)"MANIFEST CONTENTS");
		foreach (Underwear underwear in underwears)
		{
			Debug.Log((object)("Underwear name : " + underwear.shortname + " underwear ID : " + underwear.GetID()));
		}
	}

	public Underwear GetUnderwear(uint id)
	{
		foreach (Underwear underwear in underwears)
		{
			if (underwear.GetID() == id)
			{
				return underwear;
			}
		}
		return null;
	}

	public Underwear GetUnderwearWithSkinId(int skinId)
	{
		foreach (Underwear underwear in underwears)
		{
			if ((Object)(object)underwear.steamItem != (Object)null && underwear.steamItem.id == skinId)
			{
				return underwear;
			}
		}
		return null;
	}
}


using System;
using UnityEngine;

public class SpringUtil
{
	public static void SimpleDampedSpring(ref float val, ref float velocity, float targetValue, float dampening, float frequency, float delta)
	{
		float num = 1f + 2f * delta * dampening * frequency;
		float num2 = frequency * frequency;
		float num3 = delta * num2;
		float num4 = delta * num3;
		float num5 = 1f / (num + num4);
		float num6 = num * val + delta * velocity + num4 * targetValue;
		float num7 = velocity + num3 * (targetValue - val);
		val = num6 * num5;
		velocity = num7 * num5;
	}

	public static void DampedSpring(ref float val, ref float velocity, float targetValue, float reductionAmount, float reductionDuration, float frequency, float delta)
	{
		float num = FrequencyInHertz(frequency);
		float dampening = DampeningInDuration(reductionAmount, reductionDuration, num);
		SimpleDampedSpring(ref val, ref velocity, targetValue, dampening, num, delta);
	}

	public static void DampedSpring(ref Vector3 val, ref Vector3 velocity, Vector3 targetValue, float reductionAmount, float reductionDuration, float frequency, float delta)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float num = FrequencyInHertz(frequency);
		float dampening = DampeningInDuration(reductionAmount, reductionDuration, num);
		SimpleDampedSpring(ref val.x, ref velocity.x, targetValue.x, dampening, num, delta);
		SimpleDampedSpring(ref val.y, ref velocity.y, targetValue.y, dampening, num, delta);
		SimpleDampedSpring(ref val.z, ref velocity.z, targetValue.z, dampening, num, delta);
	}

	private static float FrequencyInHertz(float rawFrequency)
	{
		return MathF.PI * 2f * rawFrequency;
	}

	private static float DampeningInDuration(float reductionRate, float duration, float freqHertz)
	{
		float num = Mathf.Log(reductionRate);
		float num2 = freqHertz * (0f - duration);
		return num / num2;
	}
}


using UnityEngine;

public class OpenSteamURL : MonoBehaviour
{
	public bool openInSteam = true;
}


public class SteamClientWrapper : SingletonComponent<SteamClientWrapper>
{
}


public class WorkshopSkin : WorkshopSkinBase
{
}


using UnityEngine;
using UnityEngine.Playables;

public class DemoTimelineController : MonoBehaviour
{
	public PlayableDirector Director;
}


using UnityEngine.Playables;

public class DemoTrackBehaviour : PlayableBehaviour
{
	public string DemoName;
}


using System;
using UnityEngine;
using UnityEngine.Playables;
using UnityEngine.Timeline;

[Serializable]
public class TimelineConvarController : PlayableAsset, ITimelineClipAsset
{
	public string convarName = string.Empty;

	public TimelineConvarPlayable template = new TimelineConvarPlayable();

	public ClipCaps clipCaps => (ClipCaps)2;

	public override Playable CreatePlayable(PlayableGraph graph, GameObject owner)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		ScriptPlayable<TimelineConvarPlayable> val = ScriptPlayable<TimelineConvarPlayable>.Create(graph, template, 0);
		val.GetBehaviour().convar = convarName;
		return ScriptPlayable<TimelineConvarPlayable>.op_Implicit(val);
	}
}


using System;
using UnityEngine.Playables;

[Serializable]
public class TimelineConvarPlayable : PlayableBehaviour
{
	[NonSerialized]
	public string convar;

	public float ConvarValue;

	public override void ProcessFrame(Playable playable, FrameData info, object playerData)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class Achievements : SingletonComponent<Achievements>
{
	public SoundDefinition listComplete;

	public SoundDefinition itemComplete;

	public SoundDefinition popup;

	public Canvas Canvas;

	public Text titleText;
}


using UnityEngine;
using UnityEngine.UI;

public class AchievementTodo : BaseMonoBehaviour
{
	public Text text;

	public RectTransform checkIcon;

	public RectTransform checkBox;

	public Color AliveColor;

	public Color DeadColor;

	public Color HighlightColor;
}


using UnityEngine;

public class AdminUI : MonoBehaviour
{
	public bool AllowInDemo;

	public GameObject TargetGameObject;
}


using UnityEngine;

public class AddNewEventUIButton : MonoBehaviour
{
}


using UnityEngine;

public class AddNewStateUIButton : MonoBehaviour
{
}


public class AggressionTimerEventUI : BaseEventUI
{
}


public class AmmoBelowEventUI : BaseEventUI
{
}


public class AndEventUI : BaseEventUI
{
}


public class AttackedEventUI : BaseEventUI
{
}


public class AttackTickEventUI : BaseEventUI
{
}


using Rust.UI;
using UnityEngine;

public class BaseEventUI : MonoBehaviour
{
	public RustText TextEventType;

	public RustText TextOutput;

	public RustButton ToggleInvert;

	public Dropdown DropdownInputMemorySlot;

	public Dropdown DropdownOutputMemorySlot;

	public RustInput InputFloatValue;

	public RustInput InputFloatValue2;

	[HideInInspector]
	public AIEventType EventType;

	[HideInInspector]
	public BaseStateUI Output;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BaseStateUI : MonoBehaviour
{
	public Dropdown DropdownInputMemorySlot;

	public Transform PrefabAddNewEvent;

	public Transform PrefabTimerEvent;

	public Transform PrefabPlayerDetectedEvent;

	public Transform PrefabStateErrorEvent;

	public Transform PrefabStateFinishedEvent;

	public Transform PrefabAttackedEvent;

	public Transform PrefabInAttackRangeEvent;

	public Transform PrefabHealthBelowEvent;

	public Transform PrefabInRangeEvent;

	public Transform PrefabPerformedAttackEvent;

	public Transform PrefabTirednessAboveEvent;

	public Transform PrefabHungerAboveEvent;

	public Transform PrefabThreatDetectevEvent;

	public Transform PrefabTargetDetectevEvent;

	public Transform PrefabAmmoBelowEvent;

	public Transform PrefabBestTargetDetectedEvent;

	public Transform PrefabIsVisibleEvent;

	public Transform PrefabAttackTickEvent;

	public Transform PrefabIsMountedEvent;

	public Transform PrefabAndEvent;

	public Transform PrefabChanceEvent;

	public Transform PrefabTargetLostEvent;

	public Transform PrefabTimeSinceThreatEvent;

	public Transform PrefabOnPositionMemorySetEvent;

	public Transform PrefabAggressionTimerEvent;

	public Transform PrefabReloadingEvent;

	public Transform PrefabInRangeOfHomeEvent;

	public Transform PrefabIsBlindedEvent;

	public RustText TextStateName;

	public Transform EventContainer;

	public ScrollRect Scroll;
}


public class BestTargetDetectedEventUI : BaseEventUI
{
}


public class ChanceEventUI : BaseEventUI
{
}


using UnityEngine;
using UnityEngine.EventSystems;

public class DeleteEventButton : MonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public void OnPointerDown(PointerEventData eventData)
	{
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class EnumListItemUI : MonoBehaviour
{
	public object Value;

	public RustText TextValue;

	private EnumListUI list;

	public void Init(object value, string valueText, EnumListUI list)
	{
		Value = value;
		this.list = list;
		((TMP_Text)TextValue).text = valueText;
	}

	public void Clicked()
	{
		list.ItemClicked(Value);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class EnumListUI : MonoBehaviour
{
	public Transform PrefabItem;

	public Transform Container;

	private Action<object> clickedAction;

	private CanvasScaler canvasScaler;

	private void Awake()
	{
		Hide();
	}

	public void Show(List<object> values, Action<object> clicked)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).gameObject.SetActive(true);
		clickedAction = clicked;
		foreach (Transform item in Container)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
		foreach (object value in values)
		{
			Transform obj = Object.Instantiate<Transform>(PrefabItem);
			obj.SetParent(Container, false);
			((Component)obj).GetComponent<EnumListItemUI>().Init(value, value.ToString(), this);
		}
	}

	public void ItemClicked(object value)
	{
		clickedAction?.Invoke(value);
		Hide();
	}

	public void Hide()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


public class HealthBelowEventUI : BaseEventUI
{
}


public class HungerAboveEventUI : BaseEventUI
{
}


public class InAttackRangeEventUI : BaseEventUI
{
}


public class InRangeEventUI : BaseEventUI
{
}


public class InRangeOfHomeEventUI : BaseEventUI
{
}


public class IsBlindedEventUI : BaseEventUI
{
}


public class IsMountedEventUI : BaseEventUI
{
}


public class IsVisibleEventUI : BaseEventUI
{
}


using Rust.UI;
using UnityEngine;

public class MemorySlotUI : MonoBehaviour
{
	public RustText Label;
}


public class OnPositionMemorySetEventUI : BaseEventUI
{
}


public class PerformedAttackedEventUI : BaseEventUI
{
}


public class PlayerDetectedEventUI : BaseEventUI
{
}


public class ReloadEventUI : BaseEventUI
{
}


public class StateErrorEventUI : BaseEventUI
{
}


public class StateFinishedEventUI : BaseEventUI
{
}


public class TargetDetectedEventUI : BaseEventUI
{
}


public class TargetLostEventUI : BaseEventUI
{
}


public class ThreatDetectedEventUI : BaseEventUI
{
}


public class TimerEventUI : BaseEventUI
{
}


public class TimeSinceThreatEventUI : BaseEventUI
{
}


public class TirednessAboveEventUI : BaseEventUI
{
}


using Rust.UI;
using UnityEngine;

public class UIAIDesignerScreen : SingletonComponent<UIAIDesignerScreen>, IUIScreen
{
	public GameObject SaveEntityButton;

	public GameObject SaveServerButton;

	public GameObject SaveDefaultButton;

	public RustInput InputAIDescription;

	public RustText TextDefaultStateContainer;

	public Transform PrefabAddNewStateButton;

	public Transform StateContainer;

	public Transform PrefabState;

	public EnumListUI PopupList;

	public static EnumListUI EnumList;

	public NeedsCursor needsCursor;

	protected CanvasGroup canvasGroup;

	public GameObject RootPanel;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class AspectRatioGuide : MonoBehaviour
{
	public AspectRatioFitter aspectRatioFitter;

	public RustText label;

	public float aspect;

	public float ratio;

	private void Populate()
	{
		aspect = CameraMan.GuideAspect;
		ratio = Mathf.Max(CameraMan.GuideRatio, 1f);
		aspectRatioFitter.aspectRatio = aspect / ratio;
		((TMP_Text)label).text = $"{aspect}:{ratio}";
	}

	public void Awake()
	{
		Populate();
	}

	public void Update()
	{
		Populate();
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class BlurManager : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;

	public PostProcessProfile standardBlurProfile;

	public PostProcessProfile heavyBlurProfile;
}


using TMPro;
using UnityEngine;

public class Branding : BaseMonoBehaviour
{
	public TextMeshProUGUI versionText;

	public CanvasGroup canvasGroup;

	private string oldChangeId;
}


using UnityEngine;

public class BuildCostIndicator : SingletonComponent<BuildCostIndicator>, IClientComponent
{
	public BuildCostIndicatorRow[] Rows;

	public CanvasGroup Fader;
}


public class BuildCostIndicatorRow : CostIndicatorRow
{
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChatEntry : MonoBehaviour
{
	public TextMeshProUGUI text;

	public RawImage avatar;

	public HttpImage httpAvatar;

	public CanvasGroup canvasGroup;

	public Phrase LocalPhrase = new Phrase("local", "local");

	public Phrase CardsPhrase = new Phrase("cards", "cards");

	public Phrase TeamPhrase = new Phrase("team", "team");

	public TmProEmojiRedirector EmojiRedirector;

	public Phrase ClanPhrase = new Phrase("clan", "clan");
}


using UnityEngine;

public class EmojiAutocomplete : MonoBehaviour
{
	public RectTransform Parent;

	public GameObjectRef EmojiPrefab;

	public RectTransform Selector;
}


using UnityEngine;
using UnityEngine.UI;

public class EmojiController : ListComponent<EmojiController>
{
	public Image Image;

	public RawImage VideoImage;

	public RectTransform rectTransform;
}


using Rust.UI;

public class EmojiControllerGallery : EmojiController
{
	public RustText NameText;
}


using Rust.UI;
using UnityEngine;

public class EmojiGallery : MonoBehaviour
{
	public GameObjectRef EmojiPrefab;

	public Transform Parent;

	public RustEmojiLibrary Library;

	public GameObject HighlightRoot;

	public RustText HighlightText;

	public EmojiController SkinIndicator;

	public EmojiController[] SkinToneGallery;

	public RustEmojiConfig SkinDemoConfig;

	public GameObject SkinPickerRoot;

	public TmProEmojiInputField TargetInputField;
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Emoji Config")]
public class RustEmojiConfig : ScriptableObject
{
	public bool Hide;

	public RustEmojiLibrary.EmojiSource Source;
}


using System;
using System.Collections.Generic;
using System.IO;
using ConVar;
using UnityEngine;
using UnityEngine.Experimental.Rendering;

public class RustEmojiLibrary : BaseScriptableObject
{
	public enum EmojiType
	{
		Core,
		Item,
		Server
	}

	[Serializable]
	public struct EmojiSource
	{
		public string Name;

		public EmojiType Type;

		public EmojiResult[] Emoji;

		public SteamDLCItem RequiredDLC;

		public SteamInventoryItem RequiredItem;

		public uint ServerCrc;

		public FileStorage.Type ServerFileType;

		public bool HasSkinTone => Emoji.Length > 1;

		public EmojiResult GetEmojiIndex(int index)
		{
			return Emoji[Mathf.Clamp(index, 0, Emoji.Length - 1)];
		}

		public bool CanBeUsedBy(BasePlayer p, ulong userId)
		{
			if ((Object)(object)p != (Object)null && p.UnlockAllSkins)
			{
				return true;
			}
			if ((Object)(object)RequiredDLC != (Object)null && !RequiredDLC.CanUse(p))
			{
				return false;
			}
			if ((Object)(object)RequiredItem != (Object)null)
			{
				if ((Object)(object)p == (Object)null)
				{
					p = BasePlayer.FindByID(userId);
				}
				if ((Object)(object)p != (Object)null && p.blueprints.CheckSkinOwnership(RequiredItem.id, p.userID))
				{
					return true;
				}
				return false;
			}
			return true;
		}

		public bool StringMatch(string input, out int index)
		{
			index = 0;
			if (Name.Equals(input, StringComparison.CurrentCultureIgnoreCase))
			{
				return true;
			}
			for (int i = 0; i < Emoji.Length; i++)
			{
				if ($"{Name}+{i}".Equals(input, StringComparison.CurrentCultureIgnoreCase))
				{
					index = i;
					return true;
				}
			}
			return false;
		}
	}

	public struct ServerEmojiConfig
	{
		public uint CRC;

		public FileStorage.Type FileType;
	}

	public static NetworkableId EmojiStorageNetworkId = new NetworkableId(0uL);

	[HideInInspector]
	public RustEmojiConfig[] Configs;

	public RenderTextureDescriptor RenderTextureDesc = new RenderTextureDescriptor(256, 256, (GraphicsFormat)8, 0);

	public int InitialPoolSize = 10;

	private List<EmojiSource> all = new List<EmojiSource>();

	private List<EmojiSource> conditionalAccessOnly = new List<EmojiSource>();

	public GameObjectRef VideoPlayerRef;

	private static RustEmojiLibrary _instance = null;

	private static bool hasPrewarmed = false;

	private const long MAX_FILE_SIZE_BYTES = 250000L;

	public const int MAX_TEX_SIZE_PIXELS = 256;

	public static Dictionary<string, ServerEmojiConfig> allServerEmoji = new Dictionary<string, ServerEmojiConfig>();

	private static bool hasLoaded = false;

	[NonSerialized]
	public static List<string> cachedServerList = new List<string>();

	public static RustEmojiLibrary Instance
	{
		get
		{
			if (_instance == null)
			{
				_instance = FileSystem.Load<RustEmojiLibrary>("assets/content/ui/gameui/emoji/rustemojilibrary.asset", true);
				_instance.Prewarm();
			}
			return _instance;
		}
	}

	private void Prewarm()
	{
		if (hasPrewarmed)
		{
			return;
		}
		hasPrewarmed = true;
		all.Clear();
		conditionalAccessOnly.Clear();
		RustEmojiConfig[] configs = Configs;
		foreach (RustEmojiConfig rustEmojiConfig in configs)
		{
			if (!rustEmojiConfig.Hide)
			{
				all.Add(rustEmojiConfig.Source);
				if ((Object)(object)rustEmojiConfig.Source.RequiredItem != (Object)null || (Object)(object)rustEmojiConfig.Source.RequiredDLC != (Object)null)
				{
					conditionalAccessOnly.Add(rustEmojiConfig.Source);
				}
			}
		}
		foreach (ItemDefinition item in ItemManager.itemList)
		{
			if (!item.Hidden() && !((Object)(object)item.iconSprite == (Object)null))
			{
				all.Add(new EmojiSource
				{
					Name = item.shortname,
					Type = EmojiType.Item,
					Emoji = new EmojiResult[1]
					{
						new EmojiResult
						{
							Sprite = item.iconSprite
						}
					}
				});
			}
		}
	}

	public bool TryGetEmoji(string key, out EmojiSource er, out int skinVariantIndex, out int allIndex, bool serverSide = false)
	{
		er = default(EmojiSource);
		skinVariantIndex = 0;
		allIndex = 0;
		Prewarm();
		foreach (EmojiSource item in serverSide ? conditionalAccessOnly : all)
		{
			if (item.Type != EmojiType.Server || !Global.blockServerEmoji)
			{
				if (item.StringMatch(key, out skinVariantIndex))
				{
					er = item;
					return true;
				}
				allIndex++;
			}
		}
		return false;
	}

	public static void FindAllServerEmoji()
	{
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		if (hasLoaded)
		{
			return;
		}
		hasLoaded = true;
		string serverFolder = Server.GetServerFolder("serveremoji");
		if (!Directory.Exists(serverFolder))
		{
			return;
		}
		foreach (string item in Directory.EnumerateFiles(serverFolder))
		{
			try
			{
				FileInfo fileInfo = new FileInfo(item);
				bool flag = fileInfo.Extension == ".png";
				bool flag2 = fileInfo.Extension == ".jpg";
				if (!CheckByteArray(fileInfo.Length))
				{
					Debug.Log((object)$"{serverFolder} file size is too big for emoji, max file size is {250000L} bytes");
					continue;
				}
				byte[] data = File.ReadAllBytes(item);
				if (flag && !ImageProcessing.IsValidPNG(data, 256))
				{
					Debug.Log((object)(item + " is an invalid png"));
				}
				else if (flag2 && !ImageProcessing.IsValidJPG(data, 256))
				{
					Debug.Log((object)(item + " is an invalid jpg"));
				}
				else if (flag || flag2)
				{
					FileStorage.Type type = FileStorage.Type.jpg;
					if (flag)
					{
						type = FileStorage.Type.png;
					}
					uint cRC = FileStorage.server.Store(data, type, EmojiStorageNetworkId);
					string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(item);
					if (!allServerEmoji.ContainsKey(fileNameWithoutExtension))
					{
						allServerEmoji.Add(fileNameWithoutExtension, new ServerEmojiConfig
						{
							CRC = cRC,
							FileType = type
						});
					}
				}
			}
			catch (Exception arg)
			{
				Debug.Log((object)$"Exception loading {item} - {arg}");
			}
		}
		cachedServerList = new List<string>();
		foreach (KeyValuePair<string, ServerEmojiConfig> item2 in allServerEmoji)
		{
			cachedServerList.Add(item2.Key);
			cachedServerList.Add(item2.Value.CRC.ToString());
			List<string> list = cachedServerList;
			int fileType = (int)item2.Value.FileType;
			list.Add(fileType.ToString());
		}
	}

	public static void ResetServerEmoji()
	{
		hasLoaded = false;
		allServerEmoji.Clear();
		FindAllServerEmoji();
	}

	private static bool CheckByteArray(long arrayLength)
	{
		return arrayLength <= 250000;
	}

	public static bool CheckByteArray(int arrayLength)
	{
		return (long)arrayLength <= 250000L;
	}
}


public enum EmojiType
{
	Core,
	Item,
	Server
}


using System;
using UnityEngine;

[Serializable]
public struct EmojiSource
{
	public string Name;

	public EmojiType Type;

	public EmojiResult[] Emoji;

	public SteamDLCItem RequiredDLC;

	public SteamInventoryItem RequiredItem;

	public uint ServerCrc;

	public FileStorage.Type ServerFileType;

	public bool HasSkinTone => Emoji.Length > 1;

	public EmojiResult GetEmojiIndex(int index)
	{
		return Emoji[Mathf.Clamp(index, 0, Emoji.Length - 1)];
	}

	public bool CanBeUsedBy(BasePlayer p, ulong userId)
	{
		if ((Object)(object)p != (Object)null && p.UnlockAllSkins)
		{
			return true;
		}
		if ((Object)(object)RequiredDLC != (Object)null && !RequiredDLC.CanUse(p))
		{
			return false;
		}
		if ((Object)(object)RequiredItem != (Object)null)
		{
			if ((Object)(object)p == (Object)null)
			{
				p = BasePlayer.FindByID(userId);
			}
			if ((Object)(object)p != (Object)null && p.blueprints.CheckSkinOwnership(RequiredItem.id, p.userID))
			{
				return true;
			}
			return false;
		}
		return true;
	}

	public bool StringMatch(string input, out int index)
	{
		index = 0;
		if (Name.Equals(input, StringComparison.CurrentCultureIgnoreCase))
		{
			return true;
		}
		for (int i = 0; i < Emoji.Length; i++)
		{
			if ($"{Name}+{i}".Equals(input, StringComparison.CurrentCultureIgnoreCase))
			{
				index = i;
				return true;
			}
		}
		return false;
	}
}


public struct ServerEmojiConfig
{
	public uint CRC;

	public FileStorage.Type FileType;
}


using System;
using UnityEngine;
using UnityEngine.Video;

[Serializable]
public struct EmojiResult
{
	public Sprite Sprite;

	public VideoClip Video;
}


public class TmProEmojiInputField : RTLTMP_InputField
{
	public TmProEmojiRedirector Redirector;

	public EmojiAutocomplete Autocomplete;
}


using System.Collections.Generic;
using TMPro;
using UnityEngine;

public class TmProEmojiRedirector : MonoBehaviour
{
	public struct EmojiSub
	{
		public int targetCharIndex;

		public int targetCharIndexWithRichText;

		public string targetEmoji;

		public RustEmojiLibrary.EmojiSource targetEmojiResult;

		public TMP_CharacterInfo charToReplace;
	}

	public GameObjectRef SpritePrefab;

	public float EmojiScale = 1.5f;

	public bool NonDestructiveChange;

	public bool CanTextHaveLegitimateRichText = true;

	public static void FindEmojiSubstitutions(string text, RustEmojiLibrary library, List<(EmojiSub, int)> foundSubs, bool richText, bool isServer = false, int messageLength = 0)
	{
		EmojiSub item = default(EmojiSub);
		bool flag = false;
		int num = 0;
		int num2 = 0;
		bool flag2 = false;
		int num3 = 0;
		int length = text.Length;
		if (messageLength > 0)
		{
			num3 = length - messageLength;
		}
		foundSubs.Clear();
		for (int i = 0; i < length; i++)
		{
			char c = text[i];
			num2++;
			if (richText)
			{
				if (c == '<')
				{
					bool flag3 = false;
					for (int j = i + 1; j < length && text[j] != '\u200b'; j++)
					{
						if (text[j] == '>')
						{
							flag3 = true;
							break;
						}
						if (text[j] == '<')
						{
							break;
						}
					}
					if (flag3)
					{
						flag2 = true;
						continue;
					}
				}
				if (flag2 && c == '>')
				{
					flag2 = false;
					continue;
				}
				if (flag2)
				{
					continue;
				}
			}
			if (num2 < num3)
			{
				num++;
				continue;
			}
			if (c == ':')
			{
				if (!flag)
				{
					flag = true;
					item.targetCharIndex = num;
					item.targetCharIndexWithRichText = num2 - 1;
				}
				else
				{
					if (library.TryGetEmoji(item.targetEmoji, out item.targetEmojiResult, out var skinVariantIndex, out var _, isServer))
					{
						foundSubs.Add((item, skinVariantIndex));
					}
					item = default(EmojiSub);
					flag = false;
				}
			}
			else if (flag)
			{
				item.targetEmoji += c;
				if (c == ' ')
				{
					item = default(EmojiSub);
					flag = false;
				}
			}
			num++;
		}
	}
}


using TMPro;

public struct EmojiSub
{
	public int targetCharIndex;

	public int targetCharIndexWithRichText;

	public string targetEmoji;

	public RustEmojiLibrary.EmojiSource targetEmojiResult;

	public TMP_CharacterInfo charToReplace;
}


using ConVar;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class UIChat : PriorityListComponent<UIChat>
{
	public GameObject inputArea;

	public GameObject chatArea;

	public TMP_InputField inputField;

	public TextMeshProUGUI channelLabel;

	public ScrollRect scrollRect;

	public CanvasGroup canvasGroup;

	public bool allowOpeningWhileCursorVisible;

	public GameObjectRef chatItemPlayer;

	public GameObject userPopup;

	public EmojiGallery emojiGallery;

	public GameObject dmPicker;

	public GameObject dmNameSection;

	public RustText dmName;

	public CanvasGroup backgroundCanvasGroup;

	public int maxMessageCount = 16;

	public bool fadeOutMessages = true;

	public bool enableSingleChannel;

	public Chat.ChatChannel singleChannel;

	public UIFriendsList friendsList;

	[Header("Disable Settings")]
	[Tooltip("Disable the text input field rather than hiding it.")]
	public bool useDisable;

	public RustInput rustInput;

	[FormerlySerializedAs("forceOpen")]
	public bool isMainMenuChat;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIChatPopup : MonoBehaviour
{
	public static Phrase MutePhrase = new Phrase("chat.mute", "Mute");

	public static Phrase UnmutePhrase = new Phrase("chat.unmute", "Unmute");

	public static Phrase MutedGlobalChatPhrase = new Phrase("chat.mutedglobal", "Muted global chat.");

	public static Phrase UnmutedGlobalChatPhrase = new Phrase("chat.unmutedglobal", "Unmuted global chat.");

	public UIChat Chat;

	public RustText TextToggleMute;

	public RustText TextToggleGlobalMute;

	public Button SendMessageButton;

	public Button SteamProfileButton;

	public Button MuteButton;

	public Button ReportButton;

	public GameObject AddFriendRow;

	public Button AddSteamFriendButton;

	public Button AddDiscordFriendButton;

	public GameObject InviteToTeamButton;

	public GameObject ViewInDiscordButton;

	public GameObject AcceptInviteButton;
}


using Rust.UI;
using UnityEngine;

public class UI_MainMenuChat : UIChat
{
	public static UI_MainMenuChat MenuChatInstance;

	[Header("Menu Chat")]
	public RustText placeholderText;

	public GameObject dmTargetIconSteam;

	public GameObject dmTargetIconDiscord;

	public GameObject dmTargetIconDefault;

	[Space]
	public RectTransform windowMovingParent;

	public UIEscapeCapture escapeCapture;

	public CanvasGroup dismisser;

	public override int Priority => 0;
}


using UnityEngine;

public class UI_MenuDMPicker : UIFriendsListBase
{
	public UI_MainMenuChat chat;

	public GameObjectRef FriendPrefab;

	public FriendStyleDef FriendStyle;

	public RectTransform Container;
}


using System.Collections;
using UnityEngine;
using UnityEngine.SceneManagement;

public class ChildrenFromScene : MonoBehaviour
{
	public string SceneName;

	public bool StartChildrenDisabled;

	private IEnumerator Start()
	{
		Debug.LogWarning((object)("WARNING: CHILDRENFROMSCENE(" + SceneName + ") - WE SHOULDN'T BE USING THIS SHITTY COMPONENT NOW WE HAVE AWESOME PREFABS"), (Object)(object)((Component)this).gameObject);
		Scene sceneByName = SceneManager.GetSceneByName(SceneName);
		if (!((Scene)(ref sceneByName)).isLoaded)
		{
			yield return SceneManager.LoadSceneAsync(SceneName, (LoadSceneMode)1);
		}
		sceneByName = SceneManager.GetSceneByName(SceneName);
		GameObject[] rootGameObjects = ((Scene)(ref sceneByName)).GetRootGameObjects();
		foreach (GameObject val in rootGameObjects)
		{
			val.transform.SetParent(((Component)this).transform, false);
			val.Identity();
			Transform transform = val.transform;
			RectTransform val2 = (RectTransform)(object)((transform is RectTransform) ? transform : null);
			if (Object.op_Implicit((Object)(object)val2))
			{
				val2.pivot = Vector2.zero;
				val2.anchoredPosition = Vector2.zero;
				val2.anchorMin = Vector2.zero;
				val2.anchorMax = Vector2.one;
				val2.sizeDelta = Vector2.one;
			}
			SingletonComponent[] componentsInChildren = val.GetComponentsInChildren<SingletonComponent>(true);
			for (int j = 0; j < componentsInChildren.Length; j++)
			{
				componentsInChildren[j].SingletonSetup();
			}
			if (StartChildrenDisabled)
			{
				val.SetActive(false);
			}
		}
		SceneManager.UnloadSceneAsync(sceneByName);
	}
}


using Rust.UI;

public class UIClanConfirmation : BaseMonoBehaviour
{
	public RustText Text;

	public RustText TryAgainText;
}


using Rust.UI;

public class UIClanCreator : BaseMonoBehaviour
{
	public static readonly Phrase CreateNameBlank = (Phrase)(object)new TokenisedPhrase("clan.create.name_blank", "You need to type in a name for your clan.");

	public static readonly Phrase CreateNameInvalid = (Phrase)(object)new TokenisedPhrase("clan.create.name_invalid", "The clan name you typed in is not valid.");

	public static readonly Phrase CreateAlreadyInClan = (Phrase)(object)new TokenisedPhrase("clan.create.already_in_clan", "You are already in a clan. You will need to leave your clan if you want to make a new one.");

	public static readonly Phrase CreateDuplicateName = (Phrase)(object)new TokenisedPhrase("clan.create.duplicate_name", "There is already a clan using the name you typed in. Please try a different name.");

	public static readonly Phrase CreateFailure = (Phrase)(object)new TokenisedPhrase("clan.create.fail", "Failed to create a new clan.");

	public UIClans UiClans;

	public RustInput ClanName;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIClanInvitation : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase AcceptInvitationFailure = (Phrase)(object)new TokenisedPhrase("clan.accept_invitation.fail", "Failed to accept the clan invitation.");

	public static readonly Phrase AcceptInvitationFull = (Phrase)(object)new TokenisedPhrase("clan.accept_invitation.full", "Cannot accept this clan invitation because the clan is full.");

	public static readonly Phrase DeclineInvitationFailure = (Phrase)(object)new TokenisedPhrase("clan.decline_invitation.fail", "Failed to decline the clan invitation.");

	public RustText ClanName;

	public RustText ClanMembers;

	public Image ClanBanner;

	public RawImage RecruiterAvatar;

	public RustText RecruiterName;

	public GameObject ActionsContainer;
}


using UnityEngine;

public class UIClanInvitations : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform InvitationList;

	public GameObjectRef InvitationPrefab;
}


using Rust.UI;
using UnityEngine.UI;

public class UIClanInvite : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase CancelInviteFailure = (Phrase)(object)new TokenisedPhrase("clan.cancel_invite.fail", "Failed to revoke the clan invitation.");

	public RawImage Avatar;

	public RustText Name;

	public RustText Recruiter;

	public RustText Created;

	public RustButton CancelButton;
}


using UnityEngine;

public class UIClanInvites : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform InviteList;

	public GameObjectRef InvitePrefab;
}


using UnityEngine;

public class UIClanLeaderboard : BaseMonoBehaviour
{
	public UIClans UiClans;

	public GameObject LoadingIndicator;

	public GameObject Content;

	public RectTransform EntryList;

	public GameObjectRef EntryPrefab;
}


using Rust.UI;
using UnityEngine;

public class UIClanLeaderboardEntry : MonoBehaviour
{
	public RustText ClanName;

	public RustText Score;
}


using UnityEngine;

public class UIClanLog : BaseMonoBehaviour
{
	public static readonly Phrase RefreshFailure = (Phrase)(object)new TokenisedPhrase("clan.refresh_log.fail", "Failed to load the clan event log from the server.");

	public UIClans UiClans;

	public RectTransform EntryList;

	public GameObjectRef EntryPrefab;
}


using Rust.UI;

public class UIClanLogEntry : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase FoundedEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.founded", "The clan was founded by {0}.");

	public static readonly Phrase SetMotdEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_motd", "{0} has updated the clan's message of the day.");

	public static readonly Phrase SetLogoEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_logo", "{0} has updated the clan's logo.");

	public static readonly Phrase SetColorEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_color", "{0} has changed the clan's banner color to #{1}.");

	public static readonly Phrase InviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.invite", "{1} was invited to the clan by {0}.");

	public static readonly Phrase LeaveEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.leave", "{0} has left the clan.");

	public static readonly Phrase KickEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.kick", "{1} was kicked out of the clan by {0}.");

	public static readonly Phrase AcceptInviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.accept_invite", "{0} has joined the clan.");

	public static readonly Phrase DeclineInviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.decline_invite", "{0} has declined their clan invitation.");

	public static readonly Phrase CancelInviteEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.cancel_invite", "{0} has cancelled {1}'s clan invitation.");

	public static readonly Phrase CreateRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.create_role", "{0} has created a new role {1}.");

	public static readonly Phrase UpdateRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.update_role", "{0} has updated the role {1}.");

	public static readonly Phrase UpdateRoleRenamedEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.update_role_renamed", "{0} has updated the role {1} and renamed it to {2}.");

	public static readonly Phrase SwapRolesEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.swap_roles", "{0} has swapped the positions of roles {1} and {2}.");

	public static readonly Phrase DeleteRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.delete_role", "{0} has deleted the role {1}.");

	public static readonly Phrase ChangeRoleEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.change_role", "{0} has changed the role of {1} from {2} to {3}.");

	public static readonly Phrase SetNotesEvent = (Phrase)(object)new TokenisedPhrase("clan.log_event.set_notes", "{0} set the notes for {1} to {2}.");

	public RustText Event;

	public RustText Time;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIClanMember : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static Phrase OnlinePhrase = new Phrase("clan.member.online", "Online");

	public Image Highlight;

	public Color HighlightColor;

	public Color SelectedColor;

	public RawImage Avatar;

	public RustText Name;

	public RustText Rank;

	public RustText LastSeen;
}


using Rust.UI;
using UnityEngine;

public class UIClanMemberDetails : UIClanMember
{
	public static readonly Phrase KickConfirmation = new Phrase("clan.confirmation.kick", "Are you sure you want to kick this player out of your clan?");

	public static readonly Phrase SaveNotesFailure = (Phrase)(object)new TokenisedPhrase("clan.set_member_notes.fail", "Failed to save your updated player notes.");

	public static readonly Phrase ChangeRankCannotDemoteLeader = (Phrase)(object)new TokenisedPhrase("clan.change_member_rank.cannot_demote_leader", "As a clan leader, you cannot demote yourself unless you promote another clan member to the leader role.");

	public static readonly Phrase ChangeRankFailure = (Phrase)(object)new TokenisedPhrase("clan.change_member_rank.fail", "Failed to change the rank of the player.");

	public static readonly Phrase KickFailure = (Phrase)(object)new TokenisedPhrase("clan.kick_member.fail", "Failed to kick the player out of the clan.");

	public UIClans UiClans;

	public RustInput NoteEditor;

	public RustButton SaveNoteButton;

	public GameObject ChangeRankSection;

	public Dropdown ChangeRankDropdown;

	public GameObject KickSection;

	public RustButton KickButton;
}


using UnityEngine;

public class UIClanMembers : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform MemberList;

	public GameObjectRef MemberPrefab;

	public UIClanMemberDetails MemberDetails;
}


using Rust.UI;
using UnityEngine.UI;

public class UIClanOverview : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase SetMotdFailure = (Phrase)(object)new TokenisedPhrase("clan.set_motd.fail", "Failed to update the message of the day.");

	public UIClans UiClans;

	public RawImage MotdAuthorAvatar;

	public RustText MotdAuthorName;

	public RustText MotdTime;

	public RustInput MotdInput;

	public RustButton MotdSaveButton;

	public RustButton MotdCancelButton;
}


using System;
using Rust.UI;
using UnityEngine.UI;

public class UIClanRank : BaseMonoBehaviour
{
	public static readonly Phrase MoveUpFailure = (Phrase)(object)new TokenisedPhrase("clan.move_rank_up.fail", "Failed to move the rank up.");

	public static readonly Phrase MoveDownFailure = (Phrase)(object)new TokenisedPhrase("clan.move_rank_down.fail", "Failed to move the rank down.");

	public static readonly Phrase DeleteRankFailure = (Phrase)(object)new TokenisedPhrase("clan.delete_rank.fail", "Failed to delete the rank.");

	public static readonly Phrase DeleteRankNotEmpty = new Phrase("clan.delete_rank.not_empty", "Some clan members are still be assigned this rank. You will need to assign them to a different rank before you can delete this one.");

	private static readonly Memoized<string, int> IndexToString = new Memoized<string, int>((Func<int, string>)((int i) => (i + 1).ToString("G")));

	public Image Highlight;

	public RustText IndexLabel;

	public RustText Name;

	public RustButton MoveUpButton;

	public RustButton MoveDownButton;

	public RustButton DeleteButton;
}


using Rust.UI;

public class UIClanRankCreator : BaseMonoBehaviour
{
	public static readonly Phrase CreateRankFailure = (Phrase)(object)new TokenisedPhrase("clan.create_rank.fail", "Failed to create the new rank.");

	public static readonly Phrase CreateRankDuplicate = (Phrase)(object)new TokenisedPhrase("clan.create_rank.duplicate", "There is already a rank in your clan with that name.");

	public static readonly Phrase CreateRankNameInvalid = (Phrase)(object)new TokenisedPhrase("clan.create_rank.name_invalid", "The clan rank name you typed in is not valid.");

	public UIClans UiClans;

	public RustInput RankName;

	public RustButton Submit;
}


using Rust.UI;

public class UIClanRankEditor : BaseMonoBehaviour
{
	public static readonly Phrase SaveRankFailure = (Phrase)(object)new TokenisedPhrase("clan.save_rank.fail", "Failed to save your changes to the rank.");

	public static readonly Phrase SaveRankDuplicate = (Phrase)(object)new TokenisedPhrase("clan.save_rank.duplicate", "There is already a rank in your clan with that name.");

	public UIClans UiClans;

	public RustInput NameEditor;

	public RustButton SetMotd;

	public RustButton SetLogo;

	public RustButton Invite;

	public RustButton Kick;

	public RustButton Promote;

	public RustButton Demote;

	public RustButton SetPlayerNotes;

	public RustButton AccessLogs;

	public RustButton AccessScoreEvents;

	public RustButton CancelButton;

	public RustButton SubmitButton;
}


using UnityEngine;

public class UIClanRanks : BaseMonoBehaviour
{
	public UIClans UiClans;

	public RectTransform RankContainer;

	public GameObjectRef RankPrefab;

	public UIClanRankCreator RankCreator;

	[Header("Sections")]
	public RectTransform RankListing;

	public UIClanRankEditor RankEditor;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIClans : SingletonComponent<UIClans>
{
	public static readonly Phrase LeaveConfirmation = new Phrase("clan.confirmation.leave", "Are you sure you want to leave your clan?");

	public static readonly Phrase GetInvitationsFailure = (Phrase)(object)new TokenisedPhrase("clan.get_invitations.fail", "Failed to load your clan invitations from the server.");

	public static readonly Phrase GetClanFailure = (Phrase)(object)new TokenisedPhrase("clan.get_clan.fail", "Failed to load your clan from the server.");

	public static readonly Phrase LeaveFailure = (Phrase)(object)new TokenisedPhrase("clan.leave.fail", "Failed to leave your clan.");

	public static readonly Phrase LeaveNoOtherLeader = (Phrase)(object)new TokenisedPhrase("clan.leave.no_other_leader", "As a clan leader, you cannot leave your clan unless it is empty or you promote another member to the leader role.");

	public CanvasGroup CanvasGroup;

	public UIEscapeCapture EscapeCapture;

	public NeedsCursor NeedsCursor;

	public NeedsKeyboard NeedsKeyboard;

	public GameObject ClanTableRequired;

	[Header("States")]
	public GameObject EmptyState;

	public GameObject CreateState;

	public GameObject InvitesState;

	public GameObject MainState;

	[Header("General")]
	public RustText ClanName;

	public Image ClanBanner;

	public RawImage ClanLogo;

	public RustText ClanMembers;

	public RustText ClanScore;

	public RustButton LeaveButton;

	public Texture2D DefaultLogo;

	public RustButton OverviewButton;

	public RustButton ScoreEventsButton;

	public RustButton LogsButton;

	public RustButton SettingsButton;

	public RustButton CreatePrompt;

	public CanvasGroup LoadingIndicator;

	public UIClanLeaderboard Leaderboard;

	public UIClanConfirmation Confirmation;

	public UIClanConfirmation Error;

	[Header("Tabs")]
	public UIClanInvitations Invitations;

	public UIClanOverview Overview;

	public UIClanMembers Members;

	public UIClanInvites Invites;

	public UIClanRanks Ranks;

	public UIClanScoreEvents ScoreEvents;

	public UIClanLog Logs;

	public UIClanSettings Settings;
}


using UnityEngine;

public class UIClanScoreEvents : BaseMonoBehaviour
{
	public static readonly Phrase RefreshFailure = (Phrase)(object)new TokenisedPhrase("clan.refresh_score_events.fail", "Failed to load the clan score event log from the server.");

	public UIClans UiClans;

	public RectTransform EntryList;

	public GameObjectRef EntryPrefab;
}


using Rust.UI;

public class UIClanScoreEventsEntry : BaseMonoBehaviour, IUIPlayerRefreshCallback
{
	public static readonly Phrase ClanPlayerKilledEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.clan_player_killed", "{0} killed {1}, member of clan {2}.");

	public static readonly Phrase ClanPlayerDiedEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.clan_player_died", "{0} was killed by {1}, member of clan {2}.");

	public static readonly Phrase KilledUnarmedEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.killed_unarmed", "{0} killed {1} when they were unarmed.");

	public static readonly Phrase DestroyedToolCupboardEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.destroyed_tool_cupboard", "{0} destroyed a Tool Cupboard owned by clan {1}.");

	public static readonly Phrase HackedCrateEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.hacked_crate", "{0} hacked a locked crate.");

	public static readonly Phrase OpenedHackedCrateEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.opened_hacked_crate", "{0} opened a hacked crate.");

	public static readonly Phrase DestroyedBradleyEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.destroyed_bradley", "{0} destroyed Bradley APC.");

	public static readonly Phrase RanExcavatorEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.ran_excavator", "{0} ran the Giant Excavator.");

	public static readonly Phrase ReachedCargoShipEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.boarded_cargo_ship", "{0} has boarded a Cargo Ship.");

	public static readonly Phrase LootedEliteCrateEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.looted_elite_crate", "{0} has looted an Elite Crate.");

	public static readonly Phrase UnknownEvent = (Phrase)(object)new TokenisedPhrase("clan.score_event.unknown", "{0} did something (event type = {1}).");

	public RustText Event;

	public RustText Score;

	public RustText Multiplier;

	public RustText Time;
}


using Rust.UI;
using UnityEngine;

public class UIClanSettings : BaseMonoBehaviour
{
	public static readonly Phrase SetLogoFailure = (Phrase)(object)new TokenisedPhrase("clan.set_logo.fail", "Failed to update the clan logo.");

	public static readonly Phrase SetColorFailure = (Phrase)(object)new TokenisedPhrase("clan.set_color.fail", "Failed to update the clan banner color.");

	public UIClans UiClans;

	[Header("Logo Editing")]
	public RustButton EditLogoButton;

	public GameObjectRef ChangeSignDialog;

	public MeshPaintableSource[] PaintableSources;

	[Header("Banner Colors")]
	public RectTransform ColorsContainer;
}


public interface IUIPlayerRefreshCallback
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class CompassMapMarker : MonoBehaviour
{
	public Image MarkerImage;

	public Image MarkerImageOuter;

	public GameObject LeaderRoot;

	public RustText MarkerLabel;
}


using UnityEngine;
using UnityEngine.UI;

public class CompassMissionMarker : MonoBehaviour
{
	public Image Icon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ConsoleUI : SingletonComponent<ConsoleUI>
{
	public RustText text;

	public InputField outputField;

	public InputField inputField;

	public GameObject AutocompleteDropDown;

	public GameObject ItemTemplate;

	public Color errorColor;

	public Color warningColor;

	public Color inputColor;
}


public static class ContextMenuUI
{
	public enum MenuType
	{
		Use,
		RightClick,
		Reload,
		Gesture,
		Pet,
		Ping
	}
}


public enum MenuType
{
	Use,
	RightClick,
	Reload,
	Gesture,
	Pet,
	Ping
}


using UnityEngine;

public class ConvarToggleChildren : MonoBehaviour
{
	public string ConvarName;

	public string ConvarEnabled = "True";

	private bool state;

	private Command Command;

	protected void Awake()
	{
		Command = Client.Find(ConvarName);
		if (Command == null)
		{
			Command = Server.Find(ConvarName);
		}
		if (Command != null)
		{
			SetState(Command.String == ConvarEnabled);
		}
	}

	protected void Update()
	{
		if (Command != null)
		{
			bool flag = Command.String == ConvarEnabled;
			if (state != flag)
			{
				SetState(flag);
			}
		}
	}

	private void SetState(bool newState)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in ((Component)this).transform)
		{
			((Component)item).gameObject.SetActive(newState);
		}
		state = newState;
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;

public class CopyText : MonoBehaviour
{
	public RustText TargetText;

	public void TriggerCopy()
	{
		if ((Object)(object)TargetText != (Object)null)
		{
			GUIUtility.systemCopyBuffer = ((TMP_Text)TargetText).text;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public abstract class CostIndicatorRow : MonoBehaviour
{
	public RustText ItemName;

	public Image ItemSprite;

	public RustText Amount;

	public RectTransform FillRect;

	public Image BackgroundImage;

	public Color OkColour;

	public Color MissingColour;

	public ItemDefinition currentDef { get; private set; }
}


using UnityEngine;
using UnityEngine.UI;

public class Crosshair : BaseMonoBehaviour
{
	public static bool Enabled = true;

	public Image Image;

	public RectTransform reticleTransform;

	public CanvasGroup reticleAlpha;

	public RectTransform hitNotifyMarker;

	public CanvasGroup hitNotifyAlpha;

	public static Crosshair instance;

	public static float lastHitTime = 0f;

	public float crosshairAlpha = 0.75f;

	public float aimconeMultiplier = 3f;

	public float aimconeLerpSpeed = 15f;

	public GameObjectRef pointsSplashEffect;
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class CursorManager : SingletonComponent<CursorManager>
{
	private static int iHoldOpen;

	private static int iPreviousOpen;

	private static float lastTimeVisible;

	private static float lastTimeInvisible;

	private void Update()
	{
		if (!((Object)(object)SingletonComponent<CursorManager>.Instance != (Object)(object)this))
		{
			if (iHoldOpen == 0 && iPreviousOpen == 0)
			{
				SwitchToGame();
			}
			else
			{
				SwitchToUI();
			}
			iPreviousOpen = iHoldOpen;
			iHoldOpen = 0;
		}
	}

	public void SwitchToGame()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Invalid comparison between Unknown and I4
		if ((int)Cursor.lockState != 1)
		{
			Cursor.lockState = (CursorLockMode)1;
		}
		if (Cursor.visible)
		{
			Cursor.visible = false;
		}
		lastTimeInvisible = Time.time;
	}

	private void SwitchToUI()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		if ((int)Cursor.lockState != 0)
		{
			Cursor.lockState = (CursorLockMode)0;
		}
		if (!Cursor.visible)
		{
			Cursor.visible = true;
		}
		lastTimeVisible = Time.time;
	}

	public static void HoldOpen(int frames = 1)
	{
		iHoldOpen += frames;
	}

	public static bool WasVisible(float deltaTime)
	{
		return Time.time - lastTimeVisible <= deltaTime;
	}

	public static bool WasInvisible(float deltaTime)
	{
		return Time.time - lastTimeInvisible <= deltaTime;
	}
}


using UnityEngine;

public class NeedsCursor : MonoBehaviour, IClientComponent
{
	private void Update()
	{
		CursorManager.HoldOpen();
	}
}


public class NeedsMouseWheel : ListComponent<NeedsMouseWheel>
{
	public static bool AnyActive()
	{
		return ListComponent<NeedsMouseWheel>.InstanceList.Count > 0;
	}
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(Toggle))]
public class DamageToggle : MonoBehaviour
{
	public Toggle toggle;

	private void Reset()
	{
		toggle = ((Component)this).GetComponent<Toggle>();
	}
}


public class ContainerSourceLocalPlayer : ItemContainerSource
{
	public PlayerInventory.Type type;

	public bool hideInvalidIcons;

	private ItemIcon[] allIcons;

	public override ItemContainer GetItemContainer()
	{
		return null;
	}
}


public class ContainerSourceLoot : ItemContainerSource
{
	public int container;

	public override ItemContainer GetItemContainer()
	{
		return null;
	}
}


public class ContainerSourceSelectedItem : ItemContainerSource
{
	public override ItemContainer GetItemContainer()
	{
		return null;
	}
}


using UnityEngine;

public abstract class ItemContainerSource : MonoBehaviour
{
	public abstract ItemContainer GetItemContainer();
}


using Rust.UI;
using UnityEngine.UI;

public class ButtonIcon : RustButton
{
	public Image Image;
}


using Rust.UI;

public class DebugCameraInfoReadout : SingletonComponent<DebugCameraInfoReadout>
{
	public RustText ReadoutText;
}


using UnityEngine;

public class DemoPlaybackUI : SingletonComponent<DemoPlaybackUI>
{
	public GameObject Root;
}


using Rust.UI;
using UnityEngine;

public class DemoPlaybackWidget : SingletonComponent<DemoPlaybackWidget>
{
	public RustSlider DemoProgress;

	public RustText DemoName;

	public RustText DemoDuration;

	public RustText DemoCurrentTime;

	public GameObject PausedRoot;

	public GameObject PlayingRoot;

	public RectTransform DemoPlaybackHandle;

	public RectTransform ShotPlaybackWindow;

	public RustButton LoopButton;

	public GameObject ShotButtonRoot;

	public RustText ShotNameText;

	public GameObject ShotNameRoot;

	public RectTransform ShotRecordWindow;

	public CanvasGroup InteractionBlocker;
}


using UnityEngine;

public class DemoRootFade : MonoBehaviour
{
	public CanvasGroup Canvas;
}


using Rust.UI;
using UnityEngine.EventSystems;

public class DemoShotButton : RustButton, IPointerClickHandler, IEventSystemHandler
{
	public bool FireEventOnClicked;

	public override void OnPointerDown(PointerEventData eventData)
	{
		if (!FireEventOnClicked)
		{
			((RustButton)this).OnPointerDown(eventData);
		}
	}

	public override void OnPointerUp(PointerEventData eventData)
	{
		if (!FireEventOnClicked)
		{
			((RustButton)this).OnPointerUp(eventData);
		}
	}

	public void OnPointerClick(PointerEventData eventData)
	{
		if (FireEventOnClicked)
		{
			((RustButton)this).Press();
		}
	}
}


using Rust.UI;
using UnityEngine;

public class DemoShotEntry : MonoBehaviour
{
	public RustButton PlayButton;

	public Sprite DragSprite;

	public RustInput RenameInput;
}


using Rust.UI;
using UnityEngine;

public class DemoShotListFolderWidget : MonoBehaviour
{
	public RustButton FolderName;

	public Transform ChildRoot;

	public GameObject UpArrow;

	public GameObject DownArrow;

	public RustText CountText;

	public GameObject OpenRoot;

	public GameObject ModifyRoot;

	public RustInput FolderRenameInput;
}


using UnityEngine;

public class DemoShotListRootFolder : MonoBehaviour
{
}


using Rust.UI;
using UnityEngine;

public class DemoShotListWidget : SingletonComponent<DemoShotListWidget>
{
	public GameObjectRef ShotListEntry;

	public GameObjectRef FolderEntry;

	public Transform ShotListParent;

	public RustInput FolderNameInput;

	public GameObject ShotsRoot;

	public GameObject NoShotsRoot;

	public GameObject TopUpArrow;

	public GameObject TopDownArrow;

	public Canvas DragCanvas;
}


using Rust.UI;
using UnityEngine;

public class DemoShotRecordWidget : MonoBehaviour
{
	public RustInput NameInput;

	public GameObject RecordingRoot;

	public GameObject PreRecordingRoot;

	public RustButton CountdownToggle;

	public RustButton PauseOnSaveToggle;

	public RustButton ReturnToStartToggle;

	public RustButton RecordDofToggle;

	public RustOption FolderDropdown;

	public GameObject RecordingUnderlay;

	public AudioSource CountdownAudio;

	public GameObject ShotRecordTime;

	public RustText ShotRecordTimeText;

	public RustText ShotNameText;

	public GameObject RecordingInProcessRoot;

	public GameObject CountdownActiveRoot;

	public GameObject CountdownActiveSliderRoot;

	public RustSlider CountdownActiveSlider;

	public RustText CountdownActiveText;
}


using Rust.UI;
using UnityEngine;

public class DemoText : MonoBehaviour
{
	public RustText TimeText;

	public RustText TotalSecondText;

	public RustText TimeScaleText;

	public RustText FilenameText;

	public RustText DateTimeText;

	public RustText ParentText;

	public RustText DofText;

	public RustText ParentBone;

	public GameObject InternalRoot;

	public GameObject ParentRoot;

	public GameObject DofRoot;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class KeyframeView : MonoBehaviour
{
	public ScrollRect Scroller;

	public GameObjectRef KeyframePrefab;

	public RectTransform KeyframeRoot;

	public Transform CurrentPositionIndicator;

	public bool LockScrollToCurrentPosition;

	public RustText TrackName;
}


using UnityEngine;

public class KeyframeWidget : MonoBehaviour
{
	public Tooltip AttachedTooltip;
}


using Rust.UI;
using UnityEngine;

public class DemoRecorder : SingletonComponent<DemoRecorder>
{
	public RustInput nameInputField;

	public GameObject RecordingUnderlay;

	public GameObject Panel;

	public CanvasGroup CanvasGroup;

	public UIConfirmationPopup confirmationPopup;

	public RustButton autofillButton;

	private bool autoFill;

	public static readonly Phrase overwritePhrase = new Phrase("demo.overwrite", "You are about to overwrite a demo with the same name as {0} - proceed?");
}


using Rust.UI;
using UnityEngine;

public class DemoRecorderProgress : SingletonComponent<DemoRecorderProgress>
{
	public RustText RecordingLabel;

	public RustText ProgressLabel;

	public GameObject RecordingUnderlay;
}


using UnityEngine;
using UnityEngine.UI;

public class DeveloperTools : SingletonComponent<DeveloperTools>
{
	public GameObject developerTools;

	public GameObject navButton;

	public GameObject panelContainer;

	public Text ConsoleInput;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackMainScreenUI : FacepunchBehaviour
{
	[SerializeField]
	private Canvas inGameDisplay;

	[SerializeField]
	private Canvas notInGameDisplay;

	[SerializeField]
	private Sprite faceNeutral;

	[SerializeField]
	private Sprite faceShocked;

	[SerializeField]
	private Sprite faceSad;

	[SerializeField]
	private Sprite faceCool;

	[SerializeField]
	private Sprite faceHappy;

	[SerializeField]
	private Sprite faceLove;

	[SerializeField]
	private Image faceInGame;

	[SerializeField]
	private Image faceNotInGame;

	[SerializeField]
	private Sprite[] faceNeutralVariants;

	[SerializeField]
	private Sprite[] faceHalloweenVariants;

	[SerializeField]
	private RustText cardCountText;

	[SerializeField]
	private RustText payoutText;

	[SerializeField]
	private RustText insuranceText;

	[SerializeField]
	private Canvas placeBetsCanvas;

	[SerializeField]
	private HorizontalLayoutGroup cardsLayout;

	[SerializeField]
	private BlackjackScreenCardUI[] cards;

	[SerializeField]
	private Phrase phraseBust;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackScreenCardUI : FacepunchBehaviour
{
	[SerializeField]
	private Canvas baseCanvas;

	[SerializeField]
	private Canvas cardFront;

	[SerializeField]
	private Canvas cardBack;

	[SerializeField]
	private Image image;

	[SerializeField]
	private RustText text;

	[SerializeField]
	private Sprite heartSprite;

	[SerializeField]
	private Sprite diamondSprite;

	[SerializeField]
	private Sprite spadeSprite;

	[SerializeField]
	private Sprite clubSprite;
}


using Rust.UI;
using UnityEngine;

public class BlackjackScreenInputUI : MonoBehaviour
{
	[SerializeField]
	private Canvas availableOption;

	[SerializeField]
	private Canvas unavailableOption;

	[SerializeField]
	private RustText availableOptionText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackSmallScreenUI : FacepunchBehaviour
{
	[SerializeField]
	private Canvas notInGameDisplay;

	[SerializeField]
	private Canvas inGameDisplay;

	[SerializeField]
	private RustText cardCountText;

	[SerializeField]
	private RustText betText;

	[SerializeField]
	private RustText splitBetText;

	[SerializeField]
	private RustText insuranceText;

	[SerializeField]
	private RustText bankText;

	[SerializeField]
	private RustText splitText;

	[SerializeField]
	private Canvas infoTextCanvas;

	[SerializeField]
	private RustText inGameText;

	[SerializeField]
	private RustText notInGameText;

	[SerializeField]
	private HorizontalLayoutGroup cardsLayout;

	[SerializeField]
	private BlackjackScreenCardUI[] cards;

	[SerializeField]
	private BlackjackScreenInputUI[] inputs;

	[SerializeField]
	private Phrase phraseBust;

	[SerializeField]
	private Phrase phraseBet;

	[SerializeField]
	private Phrase phrasePlaceYourBet;

	[SerializeField]
	private Phrase phraseStandoff;

	[SerializeField]
	private Phrase phraseYouWin;

	[SerializeField]
	private Phrase phraseYouLose;

	[SerializeField]
	private Phrase phraseWaitingForOtherPlayers;

	[SerializeField]
	private Phrase phraseAddFunds;

	[SerializeField]
	private Phrase phraseWaitingForPlayer;

	[SerializeField]
	private Phrase phraseSplitStored;

	[SerializeField]
	private Phrase phraseSplitActive;

	[SerializeField]
	private Phrase phraseHand;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class BlackjackUI : MonoBehaviour
{
	[SerializeField]
	private Image[] playerCardImages;

	[SerializeField]
	private Image[] dealerCardImages;

	[SerializeField]
	private Image[] splitCardImages;

	[SerializeField]
	private Image[] playerCardBackings;

	[SerializeField]
	private Image[] dealerCardBackings;

	[SerializeField]
	private Image[] splitCardBackings;

	[SerializeField]
	private CardGamePlayerWidget[] playerWidgets;

	[SerializeField]
	private GameObject dealerValueObj;

	[SerializeField]
	private RustText dealerValueText;

	[SerializeField]
	private GameObject yourValueObj;

	[SerializeField]
	private RustText yourValueText;

	[SerializeField]
	private Phrase phrasePlaceYourBet;

	[SerializeField]
	private Phrase phraseHit;

	[SerializeField]
	private Phrase phraseStand;

	[SerializeField]
	private Phrase phraseSplit;

	[SerializeField]
	private Phrase phraseDouble;

	[SerializeField]
	private Phrase phraseInsurance;

	[SerializeField]
	private Phrase phraseBust;

	[SerializeField]
	private Phrase phraseBlackjack;

	[SerializeField]
	private Phrase phraseStandoff;

	[SerializeField]
	private Phrase phraseYouWin;

	[SerializeField]
	private Phrase phraseYouLose;

	[SerializeField]
	private Phrase phraseWaitingForOtherPlayers;

	[SerializeField]
	private Phrase phraseHand;

	[SerializeField]
	private Phrase phraseInsurancePaidOut;

	[SerializeField]
	private Sprite insuranceIcon;

	[SerializeField]
	private Sprite noIcon;

	[SerializeField]
	private Color bustTextColour;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class CardGamePlayerWidget : MonoBehaviour
{
	[SerializeField]
	private GameObjectRef cardImageSmallPrefab;

	[SerializeField]
	private RawImage avatar;

	[SerializeField]
	private RustText playerName;

	[SerializeField]
	private RustText scrapTotal;

	[SerializeField]
	private RustText betText;

	[SerializeField]
	private Image background;

	[SerializeField]
	private Color inactiveBackground;

	[SerializeField]
	private Color activeBackground;

	[SerializeField]
	private Color foldedBackground;

	[SerializeField]
	private Color winnerBackground;

	[SerializeField]
	private Animation actionShowAnimation;

	[SerializeField]
	private RustText actionText;

	[SerializeField]
	private Sprite canSeeIcon;

	[SerializeField]
	private Sprite cannotSeeIcon;

	[SerializeField]
	private Sprite blankSprite;

	[SerializeField]
	private Image cornerIcon;

	[SerializeField]
	private Transform cardDisplayParent;

	[SerializeField]
	private GridLayoutGroup cardDisplayGridLayout;

	[SerializeField]
	private GameObject circle;

	[SerializeField]
	private RustText circleText;
}


using System;
using Facepunch.CardGames;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class CardGameUI : UIDialog
{
	[Serializable]
	public class PlayingCardImage
	{
		public Rank rank;

		public Suit suit;

		public Sprite image;

		public Sprite imageSmall;

		public Sprite imageTransparent;
	}

	[Serializable]
	public class InfoTextUI
	{
		public enum Attitude
		{
			Neutral,
			Good,
			Bad
		}

		public GameObject gameObj;

		public RustText rustText;

		public Image background;
	}

	public interface ICardGameSubUI
	{
		int DynamicBetAmount { get; }

		void UpdateInGameUI(CardGameUI ui, CardGameController game);

		string GetSecondaryInfo(CardGameUI ui, CardGameController game, out InfoTextUI.Attitude attitude);

		void UpdateInGameUI_NoPlayer(CardGameUI ui);
	}

	[Header("Card Game")]
	[SerializeField]
	private InfoTextUI primaryInfo;

	[SerializeField]
	private InfoTextUI secondaryInfo;

	[SerializeField]
	private InfoTextUI playerLeaveInfo;

	[SerializeField]
	private GameObject playingUI;

	[SerializeField]
	private PlayingCardImage[] cardImages;

	[SerializeField]
	private CardInputWidget[] inputWidgets;

	[SerializeField]
	private RustSlider dismountProgressSlider;

	[SerializeField]
	private Phrase phraseLoading;

	[SerializeField]
	private Phrase phraseWaitingForNextRound;

	[SerializeField]
	private Phrase phraseNotEnoughPlayers;

	[SerializeField]
	private Phrase phrasePlayerLeftGame;

	[SerializeField]
	private Phrase phraseNotEnoughBuyIn;

	[SerializeField]
	private Phrase phraseTooMuchBuyIn;

	public Phrase phraseYourTurn;

	public Phrase phraseYouWinTheRound;

	public Phrase phraseRoundWinner;

	public Phrase phraseRoundWinners;

	public Phrase phraseScrapWon;

	public Phrase phraseScrapReturned;

	public Phrase phraseChangeBetAmount;

	public Phrase phraseBet;

	public Phrase phraseBetAdd;

	public Phrase phraseAllIn;

	public GameObject amountChangeRoot;

	public RustText amountChangeText;

	public Color colourNeutralUI;

	public Color colourGoodUI;

	public Color colourBadUI;

	[SerializeField]
	private CanvasGroup timerCanvas;

	[SerializeField]
	private RustSlider timerSlider;

	[SerializeField]
	private UIChat chat;

	[SerializeField]
	private HudElement Hunger;

	[SerializeField]
	private HudElement Thirst;

	[SerializeField]
	private HudElement Health;

	[SerializeField]
	private HudElement PendingHealth;

	public Sprite cardNone;

	public Sprite cardBackLarge;

	public Sprite cardBackSmall;

	private static Sprite cardBackLargeStatic;

	private static Sprite cardBackSmallStatic;

	[SerializeField]
	private TexasHoldEmUI texasHoldEmUI;

	[SerializeField]
	private BlackjackUI blackjackUI;
}


using System;
using Facepunch.CardGames;
using UnityEngine;

[Serializable]
public class PlayingCardImage
{
	public Rank rank;

	public Suit suit;

	public Sprite image;

	public Sprite imageSmall;

	public Sprite imageTransparent;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

[Serializable]
public class InfoTextUI
{
	public enum Attitude
	{
		Neutral,
		Good,
		Bad
	}

	public GameObject gameObj;

	public RustText rustText;

	public Image background;
}


public enum Attitude
{
	Neutral,
	Good,
	Bad
}


using Facepunch.CardGames;

public interface ICardGameSubUI
{
	int DynamicBetAmount { get; }

	void UpdateInGameUI(CardGameUI ui, CardGameController game);

	string GetSecondaryInfo(CardGameUI ui, CardGameController game, out InfoTextUI.Attitude attitude);

	void UpdateInGameUI_NoPlayer(CardGameUI ui);
}


using Rust.UI;
using UnityEngine;

public class CardInputWidget : MonoBehaviour
{
	public RustText InputText;

	public RustText ActionText;

	public RustText ExtraText;
}


using UnityEngine;
using UnityEngine.UI;

public class PlayingCardSprite : MonoBehaviour
{
	[SerializeField]
	private Image image;

	[SerializeField]
	private Animation anim;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class TexasHoldEmUI : MonoBehaviour
{
	[SerializeField]
	private Image[] holeCardImages;

	[SerializeField]
	private Image[] holeCardBackings;

	[SerializeField]
	[FormerlySerializedAs("flopCardImages")]
	private Image[] communityCardImages;

	[SerializeField]
	private Image[] communityCardBackings;

	[SerializeField]
	private RustText potText;

	[SerializeField]
	private CardGamePlayerWidget[] playerWidgets;

	[SerializeField]
	private Phrase phraseWinningHand;

	[SerializeField]
	private Phrase foldPhrase;

	[SerializeField]
	private Phrase raisePhrase;

	[SerializeField]
	private Phrase checkPhrase;

	[SerializeField]
	private Phrase callPhrase;

	[SerializeField]
	private Phrase phraseRoyalFlush;

	[SerializeField]
	private Phrase phraseStraightFlush;

	[SerializeField]
	private Phrase phraseFourOfAKind;

	[SerializeField]
	private Phrase phraseFullHouse;

	[SerializeField]
	private Phrase phraseFlush;

	[SerializeField]
	private Phrase phraseStraight;

	[SerializeField]
	private Phrase phraseThreeOfAKind;

	[SerializeField]
	private Phrase phraseTwoPair;

	[SerializeField]
	private Phrase phrasePair;

	[SerializeField]
	private Phrase phraseHighCard;

	[SerializeField]
	private Phrase phraseRaiseAmount;

	[SerializeField]
	private Sprite dealerChip;

	[SerializeField]
	private Sprite smallBlindChip;

	[SerializeField]
	private Sprite bigBlindChip;

	[SerializeField]
	private Sprite noIcon;
}


using System;
using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ChangeSignText : UIDialog
{
	public Action<int, Texture2D> onUpdateTexture;

	public Action onClose;

	public GameObject objectContainer;

	public Transform panTransform;

	public Transform rotateTransform;

	public GameObject currentFrameSection;

	public GameObject[] frameOptions;

	public Canvas canvas;

	public RectTransform rightPanelRect;

	public Camera cameraPreview;

	public Camera camera3D;

	public Light previewLight;

	public Vector3 homeRotation;

	public RectTransform toolsContainer;

	public RectTransform brushesContainer;

	public RustSlider brushSizeSlider;

	public RustSlider brushSpacingSlider;

	public RustSlider brushOpacitySlider;

	public GameObject chatToggleButton;

	public Toggle autoSaveToggle;

	[Header("Layout")]
	public FlexElement rootElement;

	public FlexElement bodyElement;

	public FlexElement controlsElement;

	public FlexElement floatElement;
}


using UnityEngine;

public class CinematicDialog : UIDialog
{
	public CanvasGroup FullFadeGroup;
}


using UnityEngine;
using UnityEngine.UI;

public class UIColorPickerButton : MonoBehaviour
{
	public Image Image;

	public Color Color = Color.white;
}


using Rust.UI;
using UnityEngine;

public class UIFireworkDesigner : UIDialog
{
	public RustInput Title;

	public RustText StarsPlaced;

	public RectTransform Canvas;

	public RectTransform InnerCanvas;

	public GameObject StarPrefab;
}


using Rust.UI;
using UnityEngine;

public class UIFireworkDesignItem : MonoBehaviour
{
	public static readonly Phrase EmptyPhrase = new Phrase("firework.pattern.design.empty", "Empty");

	public static readonly Phrase UntitledPhrase = new Phrase("firework.pattern.design.untitled", "Untitled");

	public RustText Title;

	public RustButton LoadButton;

	public RustButton SaveButton;

	public RustButton EraseButton;

	public UIFireworkDesigner Designer;

	public int Index;
}


using Rust.UI;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class UIFireworkStar : EventTrigger
{
	public Image Image;

	public RustText Text;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class KeyCodeEntry : UIDialog
{
	public Text textDisplay;

	public Action onClosed;

	public Text typeDisplay;

	public Phrase masterCodePhrase;

	public Phrase guestCodePhrase;

	public GameObject memoryKeycodeButton;
}


using UnityEngine;
using UnityEngine.UI;

public class StampClanLogo : MonoBehaviour
{
	public GameObject UiElement;

	public RawImage LogoPreview;

	public MeshPaintController Controller;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class PhoneDialler : UIDialog
{
	public GameObject DialingRoot;

	public GameObject CallInProcessRoot;

	public GameObject IncomingCallRoot;

	public RustText ThisPhoneNumber;

	public RustInput PhoneNameInput;

	public RustText textDisplay;

	public RustText CallTimeText;

	public RustButton DefaultDialViewButton;

	public RustText[] IncomingCallNumber;

	public GameObject NumberDialRoot;

	public GameObject PromptVoicemailRoot;

	public RustButton ContactsButton;

	public RustText FailText;

	public NeedsCursor CursorController;

	public NeedsKeyboard KeyboardController;

	public Phrase WrongNumberPhrase;

	public Phrase NetworkBusy;

	public Phrase Engaged;

	public GameObjectRef DirectoryEntryPrefab;

	public Transform DirectoryRoot;

	public GameObject NoDirectoryRoot;

	public RustButton DirectoryPageUp;

	public RustButton DirectoryPageDown;

	public Transform ContactsRoot;

	public RustInput ContactsNameInput;

	public RustInput ContactsNumberInput;

	public GameObject NoContactsRoot;

	public RustButton AddContactButton;

	public SoundDefinition DialToneSfx;

	public Button[] NumberButtons;

	public Phrase AnsweringMachine;

	public VoicemailDialog Voicemail;

	public GameObject VoicemailRoot;
}


using Rust.UI;
using UnityEngine;

public class PhoneDirectoryEntry : MonoBehaviour
{
	public RustText PhoneNumber;

	public RustText PhoneName;

	public GameObject DeleteIcon;

	public GameObject CensorIcon;
}


using Rust.UI;
using UnityEngine;

public class VoicemailDialog : MonoBehaviour
{
	public GameObject RecordingRoot;

	public RustSlider RecordingProgress;

	public GameObject BrowsingRoot;

	public PhoneDialler ParentDialler;

	public GameObjectRef VoicemailEntry;

	public Transform VoicemailEntriesRoot;

	public GameObject NoVoicemailRoot;

	public GameObject NoCassetteRoot;
}


using Rust.UI;
using UnityEngine;

public class VoicemailEntry : MonoBehaviour
{
	public GameObject PlayingRoot;

	public RustText DisplayName;

	public RustIcon PlayIcon;

	public RustSlider ProgressSlider;
}


using System;
using Rust.UI;
using UnityEngine;

public class PickAFriend : UIDialog
{
	public RustInput rustInput;

	public bool AutoSelectInputField;

	public bool AllowMultiple;

	public Action<ulong, string> onSelected;

	public SteamFriendsList friendsList;

	public Func<ulong, bool> shouldShowPlayer
	{
		set
		{
			if ((Object)(object)friendsList != (Object)null)
			{
				friendsList.shouldShowPlayer = value;
			}
		}
	}
}


using Rust.UI;
using UnityEngine;

public class FavouriteRadioStation : MonoBehaviour
{
	public RustText UrlText;

	public GameObject XmasRoot;
}


using Rust.UI;
using UnityEngine;

public class RadioDialog : UIDialog
{
	public RustInput IpInput;

	public GameObjectRef FavouritePrefab;

	public Transform FavouritesContainer;

	public GameObject HasCassetteRoot;

	public static RadioDialog Instance;
}


using Rust.UI;

public class SoundLightDialog : UIDialog
{
	public RustOption ColourOption;

	public RustOption VolumeOption;

	public RustOption SpeedOption;

	public RustOption PatternOption;

	public RustOption GradientOption;
}


using Rust.UI;

public class RenameSleepingBag : UIDialog
{
	public RustInput input;

	public SleepingBag bag;
}


using Rust.UI;

public class SetupAppNotification : UIDialog
{
	public RustInput titleInput;

	public RustInput bodyInput;
}


public class SprayCanSkinSelect : UIDialog
{
	public IconSkinPicker skinPicker;
}


using Rust.UI;
using UnityEngine;

public class TechTreeDialog : UIDialog, IInventoryChanged
{
	private const string techTreeLevelPrefKey = "techTreeLevel";

	private TechTreeData[] dataOptions;

	public float graphScale = 1f;

	public RustButton[] tierButtons;

	public GameObjectRef entryPrefab;

	public GameObjectRef groupPrefab;

	public GameObjectRef linePrefab;

	public RectTransform contents;

	public RectTransform contentParent;

	public TechTreeSelectedNodeUI selectedNodeUI;

	public const float nodeSize = 128f;

	public const float gridSize = 64f;

	public GameObjectRef unlockEffect;

	public RustText scrapCount;

	private Vector2 startPos = Vector2.zero;

	public ScrollRectZoom zoom;

	public TechTreeData data
	{
		get
		{
			if (dataOptions == null)
			{
				return null;
			}
			return dataOptions[selectedDataIndex];
		}
	}

	private int selectedDataIndex
	{
		get
		{
			return PlayerPrefs.GetInt("techTreeLevel", 0);
		}
		set
		{
			PlayerPrefs.SetInt("techTreeLevel", value);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class TechTreeEntry : TechTreeWidget
{
	public RawImage icon;

	public GameObject ableToUnlockBackground;

	public GameObject unlockedBackground;

	public GameObject lockedBackground;

	public GameObject lockOverlay;

	public GameObject selectedBackground;

	public Image radialUnlock;

	public float holdTime = 1f;
}


public class TechTreeGroup : TechTreeWidget
{
}


using UnityEngine.UI;

public class TechTreeLine : TechTreeWidget
{
	public RawImage center;

	public RawImage topLeft;

	public RawImage topRight;

	public RawImage bottomLeft;

	public RawImage bottomRight;

	public RawImage centerDotted;

	public RawImage topLeftDotted;

	public RawImage topRightDotted;

	public RawImage bottomLeftDotted;

	public RawImage bottomRightDotted;

	public int from;

	public int to;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class TechTreeSelectedNodeUI : MonoBehaviour
{
	public RustText selectedTitle;

	public RawImage selectedIcon;

	public RustText selectedDescription;

	public RustText costText;

	public RustText craftingCostText;

	public GameObject costObject;

	public GameObject cantAffordObject;

	public GameObject unlockedObject;

	public GameObject unlockButton;

	public GameObject noPathObject;

	public TechTreeDialog dialog;

	public Color ColorAfford;

	public Color ColorCantAfford;

	public GameObject totalRequiredRoot;

	public RustText totalRequiredText;

	public ItemInformationPanel[] informationPanels;

	public GameObject workbenchTaxRoot;

	public RustText workbenchTaxText;

	public Tooltip workbenchTaxTooltip;
}


using UnityEngine;

public class TechTreeWidget : BaseMonoBehaviour
{
	public int id;

	public RectTransform rectTransform => ((Component)this).GetComponent<RectTransform>();
}


using UnityEngine;
using UnityEngine.EventSystems;

public class ZoomImage : MonoBehaviour, IScrollHandler, IEventSystemHandler
{
	[SerializeField]
	private float _minimumScale = 0.5f;

	[SerializeField]
	private float _initialScale = 1f;

	[SerializeField]
	private float _maximumScale = 3f;

	[SerializeField]
	private float _scaleIncrement = 0.5f;

	[HideInInspector]
	private Vector3 _scale;

	private RectTransform _thisTransform;

	private void Awake()
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		ref RectTransform thisTransform = ref _thisTransform;
		Transform transform = ((Component)this).transform;
		thisTransform = (RectTransform)(object)((transform is RectTransform) ? transform : null);
		((Vector3)(ref _scale)).Set(_initialScale, _initialScale, 1f);
		((Transform)_thisTransform).localScale = _scale;
	}

	public void OnScroll(PointerEventData eventData)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		RectTransformUtility.ScreenPointToLocalPointInRectangle(_thisTransform, Vector2.op_Implicit(Input.mousePosition), (Camera)null, ref val);
		float y = eventData.scrollDelta.y;
		if (y > 0f && _scale.x < _maximumScale)
		{
			((Vector3)(ref _scale)).Set(_scale.x + _scaleIncrement, _scale.y + _scaleIncrement, 1f);
			((Transform)_thisTransform).localScale = _scale;
			RectTransform thisTransform = _thisTransform;
			thisTransform.anchoredPosition -= val * _scaleIncrement;
		}
		else if (y < 0f && _scale.x > _minimumScale)
		{
			((Vector3)(ref _scale)).Set(_scale.x - _scaleIncrement, _scale.y - _scaleIncrement, 1f);
			((Transform)_thisTransform).localScale = _scale;
			RectTransform thisTransform2 = _thisTransform;
			thisTransform2.anchoredPosition += val * _scaleIncrement;
		}
	}
}


public class UIDialog : ListComponent<UIDialog>
{
	public SoundDefinition openSoundDef;

	public SoundDefinition closeSoundDef;
}


using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class UIVideoPlayer : UIDialog
{
	public AspectRatioFitter aspectRatioFitter;

	public GameObject closeButton;

	public VideoPlayer videoPlayer;

	public RawImage videoCanvas;

	public RectTransform videoProgressBar;

	public GameObject loadingIndicator;

	public float audioDuckingAmount = 0.333f;

	public float timeoutAfter = 5f;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;

public class DynamicMouseCursor : MonoBehaviour
{
	public Texture2D RegularCursor;

	public Vector2 RegularCursorPos;

	public Texture2D HoverCursor;

	public Vector2 HoverCursorPos;

	private Texture2D current;

	private void LateUpdate()
	{
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (!Cursor.visible)
		{
			return;
		}
		GameObject val = CurrentlyHoveredItem();
		TimeWarning val2;
		if ((Object)(object)val != (Object)null)
		{
			val2 = TimeWarning.New("RustControl", 0);
			try
			{
				RustControl componentInParent = val.GetComponentInParent<RustControl>();
				if ((Object)(object)componentInParent != (Object)null && componentInParent.IsDisabled)
				{
					UpdateCursor(RegularCursor, RegularCursorPos);
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("ISubmitHandler", 0);
			try
			{
				if (val.GetComponentInParent<ISubmitHandler>() != null)
				{
					UpdateCursor(HoverCursor, HoverCursorPos);
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("IPointerDownHandler", 0);
			try
			{
				if (val.GetComponentInParent<IPointerDownHandler>() != null)
				{
					UpdateCursor(HoverCursor, HoverCursorPos);
					return;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		val2 = TimeWarning.New("UpdateCursor", 0);
		try
		{
			UpdateCursor(RegularCursor, RegularCursorPos);
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	private void UpdateCursor(Texture2D cursor, Vector2 offs)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)current == (Object)(object)cursor))
		{
			current = cursor;
			Cursor.SetCursor(cursor, offs, (CursorMode)0);
		}
	}

	private GameObject CurrentlyHoveredItem()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		FpStandaloneInputModule obj = EventSystem.current.currentInputModule as FpStandaloneInputModule;
		if (obj == null)
		{
			return null;
		}
		RaycastResult pointerCurrentRaycast = obj.CurrentData.pointerCurrentRaycast;
		return ((RaycastResult)(ref pointerCurrentRaycast)).gameObject;
	}
}


using UnityEngine;

public class EntityHUDRender : MonoBehaviour
{
}


using System.Diagnostics;
using Facepunch;
using Rust;
using TMPro;
using UnityEngine;

public class ErrorText : MonoBehaviour
{
	public TextMeshProUGUI text;

	public int maxLength = 1024;

	private Stopwatch stopwatch;

	public void OnEnable()
	{
		Output.OnMessage += CaptureLog;
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Output.OnMessage -= CaptureLog;
		}
	}

	internal void CaptureLog(string error, string stacktrace, LogType type)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Invalid comparison between Unknown and I4
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Invalid comparison between Unknown and I4
		if (((int)type == 0 || (int)type == 4 || (int)type == 1) && !((Object)(object)text == (Object)null))
		{
			TextMeshProUGUI val = text;
			((TMP_Text)val).text = ((TMP_Text)val).text + error + "\n" + stacktrace + "\n\n";
			if (((TMP_Text)text).text.Length > maxLength)
			{
				((TMP_Text)text).text = ((TMP_Text)text).text.Substring(((TMP_Text)text).text.Length - maxLength, maxLength);
			}
			stopwatch = Stopwatch.StartNew();
		}
	}

	protected void Update()
	{
		if (stopwatch != null && stopwatch.Elapsed.TotalSeconds > 30.0)
		{
			((TMP_Text)text).text = string.Empty;
			stopwatch = null;
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class ExpandedLifeStats : MonoBehaviour
{
	[Serializable]
	public struct GenericStatDisplay
	{
		public string statKey;

		public Sprite statSprite;

		public Phrase displayPhrase;
	}

	public GameObject DisplayRoot;

	public GameObjectRef GenericStatRow;

	[Header("Resources")]
	public Transform ResourcesStatRoot;

	public List<GenericStatDisplay> ResourceStats;

	[Header("Weapons")]
	public GameObjectRef WeaponStatRow;

	public Transform WeaponsRoot;

	[Header("Misc")]
	public Transform MiscRoot;

	public List<GenericStatDisplay> MiscStats;

	public LifeInfographic Infographic;

	public RectTransform MoveRoot;

	public Vector2 OpenPosition;

	public Vector2 ClosedPosition;

	public GameObject OpenButtonRoot;

	public GameObject CloseButtonRoot;

	public GameObject ScrollGradient;

	public ScrollRect Scroller;
}


using System;
using UnityEngine;

[Serializable]
public struct GenericStatDisplay
{
	public string statKey;

	public Sprite statSprite;

	public Phrase displayPhrase;
}


using System;
using System.Collections.Generic;
using System.Linq;
using TMPro;
using UnityEngine;

public class LocalizationFontFallbackSettings : BaseScriptableObject
{
	[Serializable]
	public class FontConfig
	{
		[Serializable]
		public struct LanguageFallbackFonts
		{
			public string languageName;

			public TMP_FontAsset[] fallbackFonts;
		}

		public TMP_FontAsset baseFont;

		public List<TMP_FontAsset> baseFallback;

		public List<LanguageFallbackFonts> fallbacksPerLanguage;
	}

	public List<FontConfig> fontConfigs;

	public static LocalizationFontFallbackSettings Get()
	{
		return FileSystem.Load<LocalizationFontFallbackSettings>("Assets/Content/UI/Fonts/Localization Font Fallback Settings.asset", true);
	}

	public static void UpdateFonts()
	{
		string language = Translate.GetLanguage();
		LocalizationFontFallbackSettings localizationFontFallbackSettings = Get();
		if (localizationFontFallbackSettings == null)
		{
			return;
		}
		foreach (FontConfig fontConfig in localizationFontFallbackSettings.fontConfigs)
		{
			if (!((Object)(object)fontConfig.baseFont == (Object)null))
			{
				FontConfig.LanguageFallbackFonts languageFallbackFonts = fontConfig.fallbacksPerLanguage.Find((FontConfig.LanguageFallbackFonts x) => x.languageName == language);
				if (languageFallbackFonts.fallbackFonts != null && languageFallbackFonts.fallbackFonts.Length != 0)
				{
					fontConfig.baseFont.fallbackFontAssetTable = languageFallbackFonts.fallbackFonts.Concat(fontConfig.baseFallback).Distinct().ToList();
				}
				else
				{
					fontConfig.baseFont.fallbackFontAssetTable = fontConfig.baseFallback;
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using TMPro;

[Serializable]
public class FontConfig
{
	[Serializable]
	public struct LanguageFallbackFonts
	{
		public string languageName;

		public TMP_FontAsset[] fallbackFonts;
	}

	public TMP_FontAsset baseFont;

	public List<TMP_FontAsset> baseFallback;

	public List<LanguageFallbackFonts> fallbacksPerLanguage;
}


using System;
using TMPro;

[Serializable]
public struct LanguageFallbackFonts
{
	public string languageName;

	public TMP_FontAsset[] fallbackFonts;
}


using UnityEngine.EventSystems;

public class FpStandaloneInputModule : StandaloneInputModule
{
	public PointerEventData CurrentData
	{
		get
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Expected O, but got Unknown
			if (!((PointerInputModule)this).m_PointerData.ContainsKey(-1))
			{
				return new PointerEventData(EventSystem.current);
			}
			return ((PointerInputModule)this).m_PointerData[-1];
		}
	}
}


using System.Diagnostics;
using UnityEngine;
using UnityEngine.UI;

public class FPSText : MonoBehaviour
{
	public Text text;

	private Stopwatch fpsTimer = Stopwatch.StartNew();

	protected void Update()
	{
		if (!(fpsTimer.Elapsed.TotalSeconds < 0.5))
		{
			((Behaviour)this.text).enabled = true;
			fpsTimer.Reset();
			fpsTimer.Start();
			string text = Performance.current.frameRate + " FPS";
			this.text.text = text;
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Friend Style")]
public class FriendStyleDef : ScriptableObject
{
	public Color32 OnlineColor;

	public Sprite OnlineIcon;

	public Color32 AwayColor;

	public Sprite AwayIcon;

	public Color32 BusyColor;

	public Sprite BusyIcon;

	public Color32 OfflineColor;

	public Sprite OfflineIcon;

	public Sprite SteamIcon;

	public Sprite DiscordIcon;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UIFriends : UI_Window
{
	public static UIFriends Instance;

	public CanvasGroup CanvasGroup;

	public RectTransform Body;

	public UIFriendsListBase FriendsList;

	public UIFriendsListButton Button;

	public GameObject DiscordSettingsButton;

	public GameObject DiscordSettingsPanel;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class UIFriendsList : UIFriendsListBase
{
	public GameObjectRef FriendPrefab;

	public FriendStyleDef FriendStyle;

	public RustInput SearchInput;

	public RustButton ShowPendingToggle;

	public RustButton ShowOfflineToggle;

	public FlexElement RootElement;

	public GameObject PendingSection;

	public RustText PendingCount;

	public RectTransform PendingContainer;

	public GameObject InGameSection;

	public RustText InGameCount;

	public RectTransform InGameContainer;

	public GameObject OnlineSection;

	public RustText OnlineCount;

	public RectTransform OnlineContainer;

	public GameObject OfflineSection;

	public RustText OfflineCount;

	public RectTransform OfflineContainer;

	public GameObject LinkDiscordSection;

	public UIChat Chat;

	public UIFriendsListContextMenu ContextMenu;

	public UIParty Party;

	public UIParty FooterParty;
}


public abstract class UIFriendsListBase : ListComponent<UIFriendsListBase>
{
}


using Rust.UI;
using UnityEngine;

[RequireComponent(typeof(RustButton))]
public class UIFriendsListButton : UIFriendsListBase
{
	public GameObject OnlineTag;

	public RustFlexText OnlineCount;

	public GameObject Callout;

	public GameObject Notification;

	public CanvasGroup NotificationCanvasGroup;

	public ChatEntry ChatEntry;

	public float NotificationDuration = 5f;

	public UI_MainMenuChat chat;
}


using UnityEngine;

public class UIFriendsListContextMenu : MonoBehaviour
{
	public UIFriendsList FriendsList;

	[SerializeField]
	private CanvasGroup canvasGroup;

	public GameObject SendMessageButton;

	public GameObject InviteToGameButton;

	public GameObject JoinGameButton;

	public GameObject AddFriendSteamButton;

	public GameObject AddFriendDiscordButton;

	public GameObject PromotePartyLeaderButton;

	public GameObject KickPartyMemberButton;

	public GameObject InviteToPartyButton;

	public GameObject LeavePartyButton;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIFriendsListItem : MonoBehaviour
{
	public HttpImage Avatar;

	public RawImage AvatarImage;

	public Image StatusIndicator;

	public RustText Name;

	public GameObject NicknameSection;

	public RustText Nickname;

	public RustText Subtitle;

	public Image PlatformIcon;

	public GameObject SteamAccountTag;

	public RustText SteamAccountName;

	public GameObject PendingFriendControls;

	public GameObject PartyOwnerIcon;

	public static Phrase InvitedToPartyPhrase = new Phrase("party_invite.invited_to_party", "has invited you to a party");
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class GameStat : MonoBehaviour
{
	[Serializable]
	public struct Stat
	{
		public string statName;

		public string statTitle;
	}

	public float refreshTime = 5f;

	public Text title;

	public Text globalStat;

	public Text localStat;

	private long globalValue;

	private long localValue;

	private float secondsSinceRefresh;

	private float secondsUntilUpdate;

	private float secondsUntilChange;

	public Stat[] stats;
}


using System;

[Serializable]
public struct Stat
{
	public string statName;

	public string statTitle;
}


using UnityEngine;
using UnityEngine.UI;

public class CustomGestureWidget : MonoBehaviour, IClientComponent
{
	public PieShape Shape;

	public Image GestureIcon;

	public Color HighlightedColor = Color.red;

	public Color NeutralColor = Color.white;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class GestureCustomiser : MonoBehaviour
{
	public CustomGestureWidget[] Shapes;

	public float Padding = 1f;

	public float Offset;

	public RustText SelectedGestureName;

	public Image SelectedGestureIcon;

	public Phrase EmptySlotName = new Phrase("empty_gesture_slot", "Empty Slot");

	public Sprite EmptySlotIcon;

	public GameObject PickerRoot;

	public GameObjectRef PickerPrefab;

	public Transform PickerContent;

	public RustText WheelHeader;

	public RustButton WheelRightButton;

	public RustButton WheelLeftButton;

	public VideoPlayer PreviewVideo;

	public RawImage VideoImage;

	public GameObject NoValidGesturesText;

	public GameObject EmptySlotInputHelp;

	public GameObject FilledSlotInputHelp;
}


using ConVar;
using UnityEngine;

public class FPSGraph : Graph
{
	public void Refresh()
	{
		((Behaviour)this).enabled = FPS.graph > 0;
		((Rect)(ref Area)).width = (Resolution = Mathf.Clamp(FPS.graph, 0, Screen.width));
	}

	protected void OnEnable()
	{
		Refresh();
	}

	protected override float GetValue()
	{
		return 1f / Time.deltaTime;
	}

	protected override Color GetColor(float value)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!(value < 10f))
		{
			if (!(value < 30f))
			{
				return Color.green;
			}
			return Color.yellow;
		}
		return Color.red;
	}
}


using UnityEngine;

public abstract class Graph : MonoBehaviour
{
	public Material Material;

	public int Resolution = 128;

	public Vector2 ScreenFill = new Vector2(0f, 0f);

	public Vector2 ScreenOrigin = new Vector2(0f, 0f);

	public Vector2 Pivot = new Vector2(0f, 0f);

	public Rect Area = new Rect(0f, 0f, 128f, 32f);

	internal float CurrentValue;

	private int index;

	private float[] values;

	private float max;

	protected abstract float GetValue();

	protected abstract Color GetColor(float value);

	protected Vector3 GetVertex(float x, float y)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(x, y, 0f);
	}

	protected void Update()
	{
		if (values == null || values.Length != Resolution)
		{
			values = new float[Resolution];
		}
		max = 0f;
		for (int i = 0; i < values.Length - 1; i++)
		{
			max = Mathf.Max(max, values[i] = values[i + 1]);
		}
		max = Mathf.Max(max, CurrentValue = (values[values.Length - 1] = GetValue()));
	}

	protected void OnGUI()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Invalid comparison between Unknown and I4
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		if ((int)Event.current.type == 7 && values != null && values.Length != 0)
		{
			float num = Mathf.Max(((Rect)(ref Area)).width, ScreenFill.x * (float)Screen.width);
			float num2 = Mathf.Max(((Rect)(ref Area)).height, ScreenFill.y * (float)Screen.height);
			float num3 = ((Rect)(ref Area)).x - Pivot.x * num + ScreenOrigin.x * (float)Screen.width;
			float num4 = ((Rect)(ref Area)).y - Pivot.y * num2 + ScreenOrigin.y * (float)Screen.height;
			GL.PushMatrix();
			Material.SetPass(0);
			GL.LoadPixelMatrix();
			GL.Begin(7);
			for (int i = 0; i < values.Length; i++)
			{
				float num5 = values[i];
				float num6 = num / (float)values.Length;
				float num7 = num2 * num5 / max;
				float num8 = num3 + (float)i * num6;
				float num9 = num4;
				GL.Color(GetColor(num5));
				GL.Vertex(GetVertex(num8 + 0f, num9 + num7));
				GL.Vertex(GetVertex(num8 + num6, num9 + num7));
				GL.Vertex(GetVertex(num8 + num6, num9 + 0f));
				GL.Vertex(GetVertex(num8 + 0f, num9 + 0f));
			}
			GL.End();
			GL.PopMatrix();
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class HostileNote : MonoBehaviour, IClientComponent
{
	public CanvasGroup warnGroup;

	public CanvasGroup group;

	public CanvasGroup timerGroup;

	public CanvasGroup smallWarning;

	public Text timerText;

	public RustText smallWarningText;

	public static float unhostileTime;

	public static float weaponDrawnDuration;

	public Color warnColor;

	public Color hostileColor;

	public float requireDistanceToSafeZone = 200f;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class HudElement : MonoBehaviour
{
	public Text[] ValueText;

	public Image[] FilledImage;

	public float lastValue;

	private float lastMax;

	public void SetValue(float value, float max = 1f)
	{
		TimeWarning val = TimeWarning.New("HudElement.SetValue", 0);
		try
		{
			value = Mathf.CeilToInt(value);
			if (value != lastValue || max != lastMax)
			{
				lastValue = value;
				lastMax = max;
				float image = value / max;
				SetText(value.ToString("0"));
				SetImage(image);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SetText(string v)
	{
		for (int i = 0; i < ValueText.Length; i++)
		{
			ValueText[i].text = v;
		}
	}

	private void SetImage(float f)
	{
		for (int i = 0; i < FilledImage.Length; i++)
		{
			FilledImage[i].fillAmount = f;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class InfoBar : MonoBehaviour
{
	public Text TextValue;

	public RustText RustTextValue;

	public Image ImageFill;

	public Color GoodColor;

	public Color BadColor;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ContactsEntry : MonoBehaviour
{
	public RustText nameText;

	public RustText reputationText;

	public RawImage smallMugshot;

	public RelationshipManager.PlayerRelationshipInfo info;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ContactsPanel : SingletonComponent<ContactsPanel>
{
	public enum SortMode
	{
		None,
		RecentlySeen
	}

	public RectTransform alliesBucket;

	public RectTransform seenBucket;

	public RectTransform enemiesBucket;

	public RectTransform contentsBucket;

	public ContactsEntry contactEntryPrefab;

	public RawImage mugshotTest;

	public RawImage fullBodyTest;

	public RustButton[] filterButtons;

	public RelationshipManager.RelationshipType selectedRelationshipType = RelationshipManager.RelationshipType.Friend;

	public RustButton lastSeenToggle;

	public Phrase sortingByLastSeenPhrase;

	public Phrase sortingByFirstSeen;

	public RustText sortText;
}


public enum SortMode
{
	None,
	RecentlySeen
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class GameTip : SingletonComponent<GameTip>
{
	public enum Styles
	{
		Blue_Normal = 0,
		Red_Normal = 1,
		Blue_Long = 2,
		Blue_Short = 3,
		Server_Event = 4,
		Error = 5,
		LAST = 5
	}

	[Serializable]
	public struct Theme
	{
		public Styles style;

		public Icons Icon;

		public Color BackgroundColor;

		public Color ForegroundColor;

		public float duration;

		public float fadeTime;

		public bool bump;
	}

	public Canvas canvas;

	public CanvasGroup canvasGroup;

	public RustIcon icon;

	public Image background;

	public RustText text;

	public Theme[] themes;
}


public enum Styles
{
	Blue_Normal = 0,
	Red_Normal = 1,
	Blue_Long = 2,
	Blue_Short = 3,
	Server_Event = 4,
	Error = 5,
	LAST = 5
}


using System;
using Rust.UI;
using UnityEngine;

[Serializable]
public struct Theme
{
	public Styles style;

	public Icons Icon;

	public Color BackgroundColor;

	public Color ForegroundColor;

	public float duration;

	public float fadeTime;

	public bool bump;
}


using System;
using Painting;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class ImagePainter : MonoBehaviour, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IBeginDragHandler, IEndDragHandler, IDragHandler, IInitializePotentialDragHandler
{
	[Serializable]
	public class OnDrawingEvent : UnityEvent<Vector2, Brush>
	{
	}

	internal class PointerState
	{
		public Vector2 lastPos;

		public bool isDown;
	}

	public OnDrawingEvent onDrawing = new OnDrawingEvent();

	public MonoBehaviour redirectRightClick;

	[Tooltip("Spacing scale will depend on your texel size, tweak to what's right.")]
	public float spacingScale = 1f;

	internal Brush brush;

	internal PointerState[] pointerState = new PointerState[3]
	{
		new PointerState(),
		new PointerState(),
		new PointerState()
	};

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		if ((int)eventData.button != 1)
		{
			Vector2 position = default(Vector2);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, eventData.position, eventData.pressEventCamera, ref position);
			DrawAt(position, eventData.button);
			pointerState[eventData.button].isDown = true;
		}
	}

	public virtual void OnPointerUp(PointerEventData eventData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		pointerState[eventData.button].isDown = false;
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		if ((int)eventData.button == 1)
		{
			if (Object.op_Implicit((Object)(object)redirectRightClick))
			{
				((Component)redirectRightClick).SendMessage("OnDrag", (object)eventData);
			}
		}
		else
		{
			Vector2 position = default(Vector2);
			RectTransformUtility.ScreenPointToLocalPointInRectangle(rectTransform, eventData.position, eventData.pressEventCamera, ref position);
			DrawAt(position, eventData.button);
		}
	}

	public virtual void OnBeginDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1 && Object.op_Implicit((Object)(object)redirectRightClick))
		{
			((Component)redirectRightClick).SendMessage("OnBeginDrag", (object)eventData);
		}
	}

	public virtual void OnEndDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1 && Object.op_Implicit((Object)(object)redirectRightClick))
		{
			((Component)redirectRightClick).SendMessage("OnEndDrag", (object)eventData);
		}
	}

	public virtual void OnInitializePotentialDrag(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1 && Object.op_Implicit((Object)(object)redirectRightClick))
		{
			((Component)redirectRightClick).SendMessage("OnInitializePotentialDrag", (object)eventData);
		}
	}

	private void DrawAt(Vector2 position, InputButton button)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		if (brush == null)
		{
			return;
		}
		PointerState pointerState = this.pointerState[button];
		Vector2 val = rectTransform.Unpivot(position);
		if (pointerState.isDown)
		{
			Vector2 val2 = pointerState.lastPos - val;
			Vector2 normalized = ((Vector2)(ref val2)).normalized;
			for (float num = 0f; num < ((Vector2)(ref val2)).magnitude; num += Mathf.Max(brush.spacing, 1f) * Mathf.Max(spacingScale, 0.1f))
			{
				((UnityEvent<Vector2, Brush>)onDrawing).Invoke(val + num * normalized, brush);
			}
			pointerState.lastPos = val;
		}
		else
		{
			((UnityEvent<Vector2, Brush>)onDrawing).Invoke(val, brush);
			pointerState.lastPos = val;
		}
	}

	private void Start()
	{
	}

	public void UpdateBrush(Brush brush)
	{
		this.brush = brush;
	}
}


using System;
using Painting;
using UnityEngine;
using UnityEngine.Events;

[Serializable]
public class OnDrawingEvent : UnityEvent<Vector2, Brush>
{
}


using UnityEngine;

internal class PointerState
{
	public Vector2 lastPos;

	public bool isDown;
}


using UnityEngine;

public class IndependentScale : MonoBehaviour, IClientComponent
{
	public Transform scaleParent;

	public Vector3 initialScale = Vector3.one;
}


using UnityEngine;
using UnityEngine.UI;

public class IndependentScaleImagePPU : MonoBehaviour, IClientComponent
{
	public Transform scaleParent;

	public Image image;
}


public enum MapLayer
{
	Overworld = -1,
	TrainTunnels = 0,
	Underwater1 = 1,
	Underwater2 = 2,
	Underwater3 = 3,
	Underwater4 = 4,
	Underwater5 = 5,
	Underwater6 = 6,
	Underwater7 = 7,
	Underwater8 = 8,
	Dungeons = 10
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Rendering;

public class MapLayerRenderer : SingletonComponent<MapLayerRenderer>
{
	public Camera renderCamera;

	public CameraEvent cameraEvent;

	public Material renderMaterial;

	private MapLayer? _currentlyRenderedLayer;

	private NetworkableId? _currentlyRenderedDungeon;

	private int? _underwaterLabFloorCount;

	[ClientVar(ClientAdmin = true)]
	public static bool DebugLabs;

	public void Render(MapLayer layer)
	{
		if (layer < MapLayer.TrainTunnels)
		{
			return;
		}
		if (layer == MapLayer.Dungeons)
		{
			RenderDungeonsLayer();
		}
		else if (layer != _currentlyRenderedLayer)
		{
			_currentlyRenderedLayer = layer;
			switch (layer)
			{
			case MapLayer.TrainTunnels:
				RenderTrainLayer();
				break;
			case MapLayer.Underwater1:
			case MapLayer.Underwater2:
			case MapLayer.Underwater3:
			case MapLayer.Underwater4:
			case MapLayer.Underwater5:
			case MapLayer.Underwater6:
			case MapLayer.Underwater7:
			case MapLayer.Underwater8:
				RenderUnderwaterLabs((int)(layer - 1));
				break;
			}
		}
	}

	private void RenderImpl(CommandBuffer cb)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		double num = (double)World.Size * 1.5;
		renderCamera.orthographicSize = (float)num / 2f;
		renderCamera.RemoveAllCommandBuffers();
		renderCamera.AddCommandBuffer(cameraEvent, cb);
		renderCamera.Render();
		renderCamera.RemoveAllCommandBuffers();
	}

	public static MapLayerRenderer GetOrCreate()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)SingletonComponent<MapLayerRenderer>.Instance != (Object)null)
		{
			return SingletonComponent<MapLayerRenderer>.Instance;
		}
		return GameManager.server.CreatePrefab("assets/prefabs/engine/maplayerrenderer.prefab", Vector3.zero, Quaternion.identity).GetComponent<MapLayerRenderer>();
	}

	private void RenderDungeonsLayer()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon proceduralDynamicDungeon = FindDungeon(MainCamera.isValid ? MainCamera.position : Vector3.zero);
		if (_currentlyRenderedLayer == MapLayer.Dungeons)
		{
			NetworkableId? currentlyRenderedDungeon = _currentlyRenderedDungeon;
			NetworkableId? val = proceduralDynamicDungeon?.net?.ID;
			if (currentlyRenderedDungeon.HasValue == val.HasValue && (!currentlyRenderedDungeon.HasValue || currentlyRenderedDungeon.GetValueOrDefault() == val.GetValueOrDefault()))
			{
				return;
			}
		}
		_currentlyRenderedLayer = MapLayer.Dungeons;
		_currentlyRenderedDungeon = proceduralDynamicDungeon?.net?.ID;
		CommandBuffer val2 = BuildCommandBufferDungeons(proceduralDynamicDungeon);
		try
		{
			RenderImpl(val2);
		}
		finally
		{
			((IDisposable)val2)?.Dispose();
		}
	}

	private CommandBuffer BuildCommandBufferDungeons(ProceduralDynamicDungeon closest)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer val = new CommandBuffer
		{
			name = "DungeonsLayer Render"
		};
		if ((Object)(object)closest != (Object)null && closest.spawnedCells != null)
		{
			Matrix4x4 val2 = Matrix4x4.Translate(closest.mapOffset);
			foreach (ProceduralDungeonCell spawnedCell in closest.spawnedCells)
			{
				if ((Object)(object)spawnedCell == (Object)null || spawnedCell.mapRendererLods == null || spawnedCell.mapRendererLods.Length == 0)
				{
					continue;
				}
				RendererLOD[] mapRendererLods = spawnedCell.mapRendererLods;
				foreach (RendererLOD rendererLOD in mapRendererLods)
				{
					if ((Object)(object)rendererLOD == (Object)null)
					{
						continue;
					}
					Matrix4x4 localToWorldMatrix;
					Mesh finalLodMesh = rendererLOD.GetFinalLodMesh(out localToWorldMatrix);
					if (!((Object)(object)finalLodMesh == (Object)null))
					{
						int subMeshCount = finalLodMesh.subMeshCount;
						Matrix4x4 val3 = val2 * localToWorldMatrix;
						for (int j = 0; j < subMeshCount; j++)
						{
							val.DrawMesh(finalLodMesh, val3, renderMaterial, j);
						}
					}
				}
			}
		}
		return val;
	}

	public static ProceduralDynamicDungeon FindDungeon(Vector3 position, float maxDist = 200f)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		ProceduralDynamicDungeon result = null;
		float num = 100000f;
		foreach (ProceduralDynamicDungeon dungeon in ProceduralDynamicDungeon.dungeons)
		{
			if (!((Object)(object)dungeon == (Object)null) && dungeon.isClient)
			{
				float num2 = Vector3.Distance(position, ((Component)dungeon).transform.position);
				if (!(num2 > maxDist) && !(num2 > num))
				{
					result = dungeon;
					num = num2;
				}
			}
		}
		return result;
	}

	private void RenderTrainLayer()
	{
		CommandBuffer val = BuildCommandBufferTrainTunnels();
		try
		{
			RenderImpl(val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private CommandBuffer BuildCommandBufferTrainTunnels()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer val = new CommandBuffer
		{
			name = "TrainLayer Render"
		};
		foreach (DungeonGridCell dungeonGridCell in TerrainMeta.Path.DungeonGridCells)
		{
			if (dungeonGridCell.MapRendererLods == null || dungeonGridCell.MapRendererLods.Length == 0)
			{
				continue;
			}
			RendererLOD[] mapRendererLods = dungeonGridCell.MapRendererLods;
			for (int i = 0; i < mapRendererLods.Length; i++)
			{
				Matrix4x4 localToWorldMatrix;
				Mesh finalLodMesh = mapRendererLods[i].GetFinalLodMesh(out localToWorldMatrix);
				if (!((Object)(object)finalLodMesh == (Object)null))
				{
					int subMeshCount = finalLodMesh.subMeshCount;
					for (int j = 0; j < subMeshCount; j++)
					{
						val.DrawMesh(finalLodMesh, localToWorldMatrix, renderMaterial, j);
					}
				}
			}
		}
		return val;
	}

	private void RenderUnderwaterLabs(int floor)
	{
		CommandBuffer val = BuildCommandBufferUnderwaterLabs(floor);
		try
		{
			RenderImpl(val);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int GetUnderwaterLabFloorCount()
	{
		if (_underwaterLabFloorCount.HasValue)
		{
			return _underwaterLabFloorCount.Value;
		}
		List<DungeonBaseInfo> dungeonBaseEntrances = TerrainMeta.Path.DungeonBaseEntrances;
		_underwaterLabFloorCount = ((dungeonBaseEntrances != null && dungeonBaseEntrances.Count > 0) ? dungeonBaseEntrances.Max((DungeonBaseInfo l) => l.Floors.Count) : 0);
		if (DebugLabs && dungeonBaseEntrances != null)
		{
			Debug.Log((object)$"Setup underwater lab: count: {dungeonBaseEntrances.Count} floors: {_underwaterLabFloorCount.Value}");
		}
		return _underwaterLabFloorCount.Value;
	}

	private CommandBuffer BuildCommandBufferUnderwaterLabs(int floor)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer val = new CommandBuffer
		{
			name = "UnderwaterLabLayer Render"
		};
		foreach (DungeonBaseInfo dungeonBaseEntrance in TerrainMeta.Path.DungeonBaseEntrances)
		{
			if (dungeonBaseEntrance.Floors.Count <= floor)
			{
				continue;
			}
			foreach (DungeonBaseLink link in dungeonBaseEntrance.Floors[floor].Links)
			{
				if (link.MapRendererLods == null || link.MapRendererLods.Length == 0)
				{
					if (DebugLabs)
					{
						Debug.Log((object)$"{link} has no renderers");
					}
					continue;
				}
				RendererLOD[] mapRendererLods = link.MapRendererLods;
				foreach (RendererLOD rendererLOD in mapRendererLods)
				{
					if ((Object)(object)rendererLOD == (Object)null)
					{
						if (DebugLabs)
						{
							Debug.Log((object)$"{link} has a null renderer");
						}
						continue;
					}
					Matrix4x4 localToWorldMatrix;
					Mesh finalLodMesh = rendererLOD.GetFinalLodMesh(out localToWorldMatrix);
					if (!((Object)(object)finalLodMesh == (Object)null))
					{
						int subMeshCount = finalLodMesh.subMeshCount;
						for (int j = 0; j < subMeshCount; j++)
						{
							val.DrawMesh(finalLodMesh, localToWorldMatrix, renderMaterial, j);
						}
					}
				}
			}
		}
		return val;
	}
}


using System.Text.RegularExpressions;
using UnityEngine;

public static class MapHelper
{
	public static Vector2i? StringToGrid(string text)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		Match match = new Regex("^([a-zA-Z]+)(\\d+)$").Match(text);
		if (!match.Success)
		{
			return null;
		}
		int num = 0;
		string text2 = match.Groups[1].Value.ToLower();
		foreach (char c in text2)
		{
			num = num * 26 + c - 97 + 1;
		}
		num--;
		if (!int.TryParse(match.Groups[2].Value, out var result))
		{
			return null;
		}
		return new Vector2i(num, result);
	}

	public static Vector3 GridToPosition(Vector2i grid)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		float num = 146.28572f;
		int num2 = Mathf.FloorToInt((float)World.Size / num + 0.001f);
		float num3 = World.Size / num2;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(0L - (long)World.Size) / 2f, (float)World.Size / 2f);
		Vector2 val2 = default(Vector2);
		((Vector2)(ref val2))..ctor((float)grid.x * num3, (float)grid.y * num3);
		return new Vector3(val.x + val2.x, 0f, val.y - val2.y) + new Vector3(num3 / 2f, 0f, num3 / -2f);
	}

	public static Vector3? StringToPosition(string text)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Vector2i? val = StringToGrid(text);
		if (!val.HasValue)
		{
			return null;
		}
		return GridToPosition(val.Value);
	}

	public static string PositionToString(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GridToString(PositionToGrid(position));
	}

	public static Vector2i PositionToGrid(Vector3 position)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		float num = 146.28572f;
		int num2 = Mathf.FloorToInt((float)World.Size / num + 0.001f);
		float num3 = World.Size / num2;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)(0L - (long)World.Size) / 2f, (float)World.Size / 2f);
		Vector2 val2 = new Vector2(position.x - val.x, val.y - position.z);
		int num4 = Mathf.FloorToInt(val2.x / num3);
		int num5 = Mathf.FloorToInt(val2.y / num3);
		return new Vector2i(num4, num5);
	}

	public static string GridToString(Vector2i grid)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		grid.x = Mathf.Max(grid.x, 0);
		int num = grid.x + 1;
		string text = "";
		while (num > 0)
		{
			num--;
			text = (char)(65 + num % 26) + text;
			num /= 26;
		}
		return $"{text}{grid.y}";
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MapInterface : SingletonComponent<MapInterface>
{
	[Serializable]
	public struct PointOfInterestSpriteConfig
	{
		public Sprite inner;

		public Sprite outer;
	}

	public static bool IsOpen;

	public static bool HasPreviouslyOpenedInThisSession;

	public Image cameraPositon;

	public ScrollRectEx scrollRect;

	public ScrollRectZoom scrollRectZoom;

	public RustButton showGridToggle;

	public RustButton FocusButton;

	public CanvasGroup CanvasGroup;

	public SoundDefinition PlaceMarkerSound;

	public SoundDefinition ClearMarkerSound;

	public MapView View;

	public UINexusMap NexusMap;

	public GameObject NexusButtonGroup;

	public RustButton NexusToggle;

	public Color[] PointOfInterestColours;

	public PointOfInterestSpriteConfig[] PointOfInterestSprites;

	public Sprite PingBackground;

	public bool DebugStayOpen;

	public GameObject MarkerListSection;

	public GameObject ControlsRoot;

	public GameObjectRef MarkerListPrefab;

	public GameObject MarkerHeader;

	public Transform LocalPlayerMarkerListParent;

	public Transform TeamMarkerListParent;

	public GameObject TeamLeaderHeader;

	public GameObject MissionListHeader;

	public Transform MissionListContent;

	public GameObjectRef MissionListPrefab;

	public VendorList VendorList;

	public RustButton HideTeamLeaderMarkersToggle;

	public CanvasGroup TeamMarkersCanvas;

	public RustImageButton ShowSleepingBagsButton;

	public RustImageButton ShowVendingMachinesButton;

	public RustImageButton ShowMissionProvidersButton;

	public UIEscapeCapture EscapeCapture;
}


using System;
using UnityEngine;

[Serializable]
public struct PointOfInterestSpriteConfig
{
	public Sprite inner;

	public Sprite outer;
}


using UnityEngine;
using UnityEngine.UI;

public class MapMarkerIconSelector : MonoBehaviour
{
	public Image OuterImage;

	public Image InnerImage;

	public GameObject Selected;
}


public class MapScaleIndependent : IndependentScale
{
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class MapView : FacepunchBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public RawImage mapImage;

	public Image cameraPositon;

	public GameObject cameraPositionDirectionIndicator;

	public GameObject cameraPositionNoDirectionIndicator;

	public ScrollRectEx scrollRect;

	public CanvasGroup contentCanvasGroup;

	public GameObject monumentMarkerContainer;

	public Transform clusterMarkerContainer;

	public GameObjectRef monumentMarkerPrefab;

	public GameObject missionMarkerContainer;

	public GameObjectRef missionMarkerPrefab;

	public Transform activeInteractionParent;

	public Transform localPlayerInterestPointRoot;

	public GameObject shelterMarkerContainer;

	public GameObjectRef shelterMapMarkerPrefab;

	public TeamMemberMapMarker[] teamPositions;

	public TeamMemberMapMarker[] clanPositions;

	public List<PointOfInterestMapMarker> PointOfInterestMarkers;

	public List<PointOfInterestMapMarker> TeamPointOfInterestMarkers;

	public List<PointOfInterestMapMarker> LocalPings;

	public List<PointOfInterestMapMarker> TeamPings;

	public GameObject PlayerDeathMarker;

	public List<SleepingBagMapMarker> SleepingBagMarkers = new List<SleepingBagMapMarker>();

	public List<SleepingBagClusterMapMarker> SleepingBagClusters = new List<SleepingBagClusterMapMarker>();

	public RectTransform FogIndependentInteractionRoot;

	[FormerlySerializedAs("TrainLayer")]
	public RawImage UndergroundLayer;

	public bool ShowGrid;

	public bool ShowPointOfInterestMarkers;

	public bool ShowDeathMarker = true;

	public bool ShowSleepingBags = true;

	public bool AllowSleepingBagDeletion;

	public bool ShowLocalPlayer = true;

	public bool ShowTeamMembers = true;

	public bool ShowBagsOnBottom;

	public bool ShowTrainLayer;

	public bool ShowMissions;

	public bool ForceShowVendingMachines;

	[FormerlySerializedAs("ShowTrainLayer")]
	public bool ShowUndergroundLayers;

	public bool MLRSMarkerMode;

	public RustImageButton LockButton;

	public RustImageButton OverworldButton;

	public RustImageButton TrainButton;

	public RustImageButton[] UnderwaterButtons;

	public RustImageButton DungeonButton;

	public CanvasLineRenderer CargoPatrolPath;

	public CanvasLineRenderer[] HarborPaths;

	public CanvasLineRenderer FerryPath;

	public CanvasLineRenderer HeliPath;

	public PaintableImageGrid FogOfWarGrid;

	public Texture2D FogOfWarTex;

	public UnityEvent onClicked;

	public void OnPointerDown(PointerEventData eventData)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class MissionMapMarker : MonoBehaviour
{
	public Image Icon;

	public Tooltip TooltipComponent;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MissionPointMapMarker : MonoBehaviour
{
	public RustText MissionName;

	public Image Icon;
}


using System;
using Facepunch;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class MonumentMarker : MonoBehaviour
{
	public RustText text;

	public Image imageBackground;

	public Image image;

	public Color dayColor;

	public Color nightColor;

	public void Setup(LandmarkInfo info)
	{
		if (info.displayPhrase.IsValid())
		{
			this.text.SetPhrase(info.displayPhrase, Array.Empty<object>());
		}
		else
		{
			string text = (string.IsNullOrEmpty(info.untranslatedName) ? ((Object)((Component)info).transform.root).name : info.untranslatedName);
			this.text.SetText(text, false, false);
		}
		if ((Object)(object)info.mapIcon != (Object)null)
		{
			image.sprite = info.mapIcon;
			ComponentExtensions.SetActive<RustText>(this.text, false);
			ComponentExtensions.SetActive<Image>(imageBackground, true);
		}
		else
		{
			ComponentExtensions.SetActive<RustText>(this.text, true);
			ComponentExtensions.SetActive<Image>(imageBackground, false);
		}
		SetNightMode(nightMode: false);
	}

	public void SetNightMode(bool nightMode)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Color color = (nightMode ? nightColor : dayColor);
		Color color2 = (nightMode ? dayColor : nightColor);
		if ((Object)(object)text != (Object)null)
		{
			((Graphic)text).color = color;
		}
		if ((Object)(object)image != (Object)null)
		{
			((Graphic)image).color = color;
		}
		if ((Object)(object)imageBackground != (Object)null)
		{
			((Graphic)imageBackground).color = color2;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class PointOfInterestMapMarker : MonoBehaviour
{
	public Image MapIcon;

	public Image MapIconOuter;

	public GameObject LeaderRoot;

	public GameObject EditPopup;

	public Tooltip Tooltip;

	public GameObject MarkerLabelRoot;

	public RustText MarkerLabel;

	public RustText NoMarkerLabel;

	public RustInput MarkerLabelModify;

	public MapMarkerIconSelector[] IconSelectors;

	public MapMarkerIconSelector[] ColourSelectors;

	public bool IsListWidget;

	public GameObject DeleteButton;
}


using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SleepingBagClusterMapMarker : MonoBehaviour
{
	public TextMeshProUGUI CountText;

	public List<SleepingBagButton> SleepingBagButtons;

	public GameObject OpenRoot;

	public Tooltip SummaryTooltip;

	public Image RimImage;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SleepingBagMapMarker : MonoBehaviour
{
	public Image MapIcon;

	public Image SleepingBagIcon;

	public Sprite SleepingBagSprite;

	public Sprite BedSprite;

	public Sprite BeachTowelSprite;

	public Sprite CamperSprite;

	public Tooltip MarkerTooltip;

	public GameObject LockRoot;

	public TextMeshProUGUI LockTime;

	public GameObject OccupiedRoot;

	public Image CircleRim;

	public Image CircleFill;

	public RustButton DeleteButton;

	public Image ConfirmSlider;

	public GameObject CorpseRoot;

	public Image CorpseImage;
}


using UnityEngine;
using UnityEngine.UI;

public class TeamMemberMapMarker : MonoBehaviour
{
	public RectTransform rectTransform;

	public Text nameTagText;

	public Tooltip toolTip;

	public Image innerImage;
}


using UnityEngine;

public class UIMapExplosion : MonoBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class UIMapGenericRadius : MonoBehaviour
{
	public Image radialImage;

	public Image outlineImage;

	public float radius;

	public CanvasGroup fade;

	public RectTransform rect;
}


using Rust.UI;
using UnityEngine;

public class UIMapMissionProvider : MonoBehaviour
{
	public Tooltip TargetTooltip;

	public RustText CountText;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIMapVendingMachineMarker : MonoBehaviour
{
	public Color inStock;

	public Color outOfStock;

	public Image colorBackground;

	public string displayName;

	public Tooltip toolTip;

	public RustButton button;
}


using TMPro;
using UnityEngine;

public class UIMapVendingMachineMarkerCluster : MonoBehaviour
{
	public GameObject OpenRoot;

	public TextMeshProUGUI CountText;

	public GameObjectRef MarkerPrefab;

	public Transform MarkerParent;
}


public class UINexusMap : UINexusMapBase
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public abstract class UINexusMapBase : BaseMonoBehaviour, IPointerDownHandler, IEventSystemHandler
{
	public RawImage BackgroundImage;

	public RawImage BackgroundFillImage;

	public RectTransform LoadingView;

	public RectTransform MissingView;

	public ScrollRectEx MapScrollRect;

	public ScrollRectZoom MapScrollZoom;

	public RectTransform CameraPositon;

	public CanvasGroup ZoneNameCanvasGroup;

	public RectTransform ZoneNameContainer;

	public GameObjectRef ZoneNameMarkerPrefab;

	[Header("Zone Details")]
	public CanvasGroup ZoneDetails;

	public RustText ZoneName;

	public RustText OnlineCount;

	public RustText MaxCount;

	public GameObjectRef ZoneNameLabelPrefab;

	public GameObject InboundFerriesSection;

	public RectTransform InboundFerriesList;

	public GameObject OutboundFerriesSection;

	public RectTransform OutboundFerriesList;

	public GameObject ConnectionsSection;

	public RectTransform ConnectionsList;

	[Header("Behavior")]
	public bool ShowLocalPlayer;

	public float OutOfBoundsScaleFactor = 5f;

	public float ZoneNameAlphaPower = 100f;

	public UnityEvent OnMapLoaded = new UnityEvent();

	public UnityEvent OnClicked = new UnityEvent();

	public void OnPointerDown(PointerEventData eventData)
	{
	}
}


using Facepunch.Flexbox;
using Rust.UI;

public class UINexusMapWidget : UINexusMapBase
{
	public RustButton FocusButton;

	public FlexTransition RevealTransition;
}


using System;
using Painting;
using UnityEngine;
using UnityEngine.Events;

public class UIPaintBox : MonoBehaviour
{
	[Serializable]
	public class OnBrushChanged : UnityEvent<Brush>
	{
	}

	public OnBrushChanged onBrushChanged = new OnBrushChanged();

	public Brush brush;

	public void UpdateBrushSize(int size)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		brush.brushSize = Vector2.one * (float)size;
		brush.spacing = Mathf.Clamp((float)size * 0.1f, 1f, 3f);
		OnChanged();
	}

	public void UpdateBrushTexture(Texture2D tex)
	{
		brush.texture = tex;
		OnChanged();
	}

	public void UpdateBrushColor(Color col)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		brush.color.r = col.r;
		brush.color.g = col.g;
		brush.color.b = col.b;
		OnChanged();
	}

	public void UpdateBrushAlpha(float a)
	{
		brush.color.a = a;
		OnChanged();
	}

	public void UpdateBrushEraser(bool b)
	{
		brush.erase = b;
	}

	private void OnChanged()
	{
		((UnityEvent<Brush>)onBrushChanged).Invoke(brush);
	}
}


using System;
using Painting;
using UnityEngine.Events;

[Serializable]
public class OnBrushChanged : UnityEvent<Brush>
{
}


using System;
using System.Collections.Generic;
using Facepunch.Flexbox;
using ProtoBuf;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SingleVendor : FacepunchBehaviour, IComparable<SingleVendor>
{
	public RustText VendorName;

	public TmProEmojiRedirector emojiRedirector;

	public Transform ListingsParent;

	public Transform AccordionRow;

	public Transform AccordionChevron;

	public Image[] AccordionImages = (Image[])(object)new Image[3];

	public GameObjectRef VendorListingPrefab;

	[Header("References")]
	public GameObject NoListings;

	public FlexTransition VendorListingsTransition;

	public Image OwnerImage;

	public RustText OwnerName;

	public SellOrderContainer SellOrdersContainer;

	private List<VendorListing> listings;

	public const int COUNT_FOR_ACCORDION = 5;

	public int CompareTo(SingleVendor other)
	{
		SellOrderContainer sellOrdersContainer = SellOrdersContainer;
		bool flag = sellOrdersContainer != null && sellOrdersContainer.sellOrders.Count >= 5;
		SellOrderContainer sellOrdersContainer2 = other.SellOrdersContainer;
		bool flag2 = sellOrdersContainer2 != null && sellOrdersContainer2.sellOrders.Count >= 5;
		if (flag && !flag2)
		{
			return 1;
		}
		if (!flag && flag2)
		{
			return -1;
		}
		SellOrderContainer sellOrdersContainer3 = SellOrdersContainer;
		if (sellOrdersContainer3 != null && sellOrdersContainer3.sellOrders.Count == 0)
		{
			SellOrderContainer sellOrdersContainer4 = other.SellOrdersContainer;
			if (sellOrdersContainer4 != null && sellOrdersContainer4.sellOrders.Count > 0)
			{
				return -1;
			}
		}
		SellOrderContainer sellOrdersContainer5 = SellOrdersContainer;
		if (sellOrdersContainer5 != null && sellOrdersContainer5.sellOrders.Count > 0)
		{
			SellOrderContainer sellOrdersContainer6 = other.SellOrdersContainer;
			if (sellOrdersContainer6 != null && sellOrdersContainer6.sellOrders.Count == 0)
			{
				return 1;
			}
		}
		return 0;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class VendorList : MonoBehaviour
{
	public GameObject singleHeader;

	public GameObject multiHeader;

	public Transform ListParent;

	public GameObjectRef SingleVendorPrefab;

	public ScrollRect scrollRect;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class VendorListing : FacepunchBehaviour
{
	public Image panelBacking;

	[Header("Text")]
	public RustText AvailableText;

	public RustText CostText;

	public RustText AvailableAmount;

	public RustText CostAmount;

	public RustText InStockAmount;

	public RustText InStockText;

	public VendingPriceMultiplierWidget PriceMultiplier;

	public VendingPriceMultiplierWidget RecievedCurrencyMultiplier;

	[Header("Icons")]
	public VirtualItemIcon AvaliableIcon;

	public VirtualItemIcon CostIcon;

	[Header("Tooltips")]
	public Tooltip avaliableIconTooltip;

	public Tooltip costIconTooltip;

	[SerializeField]
	private FlexTransition transition;

	public static Phrase inStockPhrase = new Phrase("vendor_in_stock", "In Stock");

	public static Phrase outOfStockPhrase = new Phrase("vendor_out_stock", "Sold Out");

	public static Phrase attachmentsPhrase = new Phrase("vendor_attachments", "Attachments");

	public static Phrase ammoPhrase = new Phrase("vendor_ammo", "Ammo");
}


using System;
using Facepunch.Extend;
using Rust.UI;
using UnityEngine;

public class MenuTip : MonoBehaviour
{
	public RustText text;

	public RustIcon icon;

	public LoadingScreen screen;

	public static Phrase[] MenuTips = (Phrase[])(object)new Phrase[34]
	{
		new TokenisedPhrase("menutip_bag", "Don't forget to create a sleeping bag! You can pick which one to respawn at on the death screen."),
		new TokenisedPhrase("menutip_baggive", "You can give a sleeping bag to a Steam friend."),
		new TokenisedPhrase("menutip_sneakanimal", "Some animals have blind spots. Sneak up from behind to get close enough to make the kill."),
		new TokenisedPhrase("menutip_humanmeat", "Human meat will severely dehydrate you."),
		new TokenisedPhrase("menutip_hammerpickup", "You can use the Hammer tool to pick up objects. Providing they are unlocked and/or opened."),
		new TokenisedPhrase("menutip_seedsun", "Ensure seeds are placed in full sunlight for faster growth."),
		new TokenisedPhrase("menutip_lakeriverdrink", "You can drink from lakes and rivers to recover a portion of your health."),
		new TokenisedPhrase("menutip_cookmeat", "Cook meat in a campfire to increase its healing abilities."),
		new TokenisedPhrase("menutip_rotatedeployables", "Rotate deployables before placing them by pressing [R]"),
		new TokenisedPhrase("menutip_repairblocked", "You cannot repair or upgrade building parts for 30 seconds after they've been damaged."),
		new TokenisedPhrase("menutip_hammerrepair", "Hit objects with your hammer to repair them, providing you have the necessary resources."),
		new TokenisedPhrase("menutip_altlook", "Hold [+altlook] to check your surroundings."),
		new TokenisedPhrase("menutip_upkeepwarning", "The larger you expand your base the more it'll cost to upkeep"),
		new TokenisedPhrase("menutip_report", "If you wish to report any in-game issues try pressing F7"),
		new TokenisedPhrase("menutip_radwash", "Submerge yourself in water and slosh around to remove radiation"),
		new TokenisedPhrase("menutip_riverplants", "Edible plants are commonly found on river sides."),
		new TokenisedPhrase("menutip_buildwarnmonument", "Building near monuments may attract unwanted attention."),
		new TokenisedPhrase("menutip_vending", "Sell your unwanted items safely by crafting a vending machine."),
		new TokenisedPhrase("menutip_switchammo", "Switch between ammo types by holding the [+reload] key."),
		new TokenisedPhrase("menutip_oretip", "Stone and Ore Nodes are most commonly found around cliffs, mountains and other rock formations."),
		new TokenisedPhrase("menutip_crouchwalk", "Crouching allows you to move silently."),
		new TokenisedPhrase("menutip_accuracy", "Standing still or crouching while shooting increases accuracy."),
		new TokenisedPhrase("menutip_crashharvest", "You can harvest metal from helicopter and apc crash sites."),
		new TokenisedPhrase("menutip_canmelt", "You can melt Empty Cans in a campfire to receive Metal Fragments."),
		new TokenisedPhrase("menutip_stacksplit", "You can split a stack of items in half by holding [Middle Mouse] and dragging"),
		new TokenisedPhrase("menutip_divesite", "Floating Buoys on the ocean indicate a potential dive site, You may find treasure below"),
		new TokenisedPhrase("menutip_craftingqueue", "You can move crafting items to the front of the crafting queue by right clicking on the item in the crafting queue"),
		new TokenisedPhrase("menutip_thirdsplit", "You can split stacks of items into a third by holding Shift and [Middle Mouse] dragging"),
		new TokenisedPhrase("menutip_removeitemquickcraft", "You can cancel crafting an item by right clicking the item in the quick craft menu"),
		new TokenisedPhrase("menutip_quickcraftmulti", "[Middle Mouse] an item in quick craft menu will add 5x to your crafting queue"),
		new TokenisedPhrase("menutip_inputsplit", "You can split items by the exact amount by right clicking the split bar"),
		new TokenisedPhrase("menutip_gestures", "Cheer on your friends by pressing [+gestures] to open the gesture menu"),
		new TokenisedPhrase("menutip_horsesharperturns", "Hold [+duck] while riding to make your horse take sharper turns"),
		new TokenisedPhrase("menutip_horseskid", "Pressing [+duck] while galloping will make your horse skid and stop faster")
	};

	private int currentTipIndex;

	private float nextTipTime;

	private bool disabled;

	public void OnEnable()
	{
		disabled = false;
		icon.SetIcon((Icons)61530);
		currentTipIndex = Random.Range(0, MenuTips.Length);
	}

	public void Update()
	{
		if (LoadingScreen.isOpen && !disabled && Time.realtimeSinceStartup >= nextTipTime)
		{
			currentTipIndex++;
			if (currentTipIndex >= MenuTips.Length)
			{
				currentTipIndex = 0;
			}
			nextTipTime = Time.realtimeSinceStartup + 6f;
			UpdateTip();
		}
	}

	public void SetCustomTip(string iconString, string tip)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!Enum.TryParse<Icons>(iconString, ignoreCase: true, out Icons result))
		{
			result = (Icons)61737;
		}
		icon.SetIcon(result);
		text.SetText(StringExtensions.Truncate(StringEx.FilterRichText(tip, true, new string[4] { "color", "u", "b", "i" }), 400, (string)null));
		disabled = true;
	}

	public void UpdateTip()
	{
		text.SetPhrase(MenuTips[currentTipIndex], Array.Empty<object>());
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SelectedContact : SingletonComponent<SelectedContact>
{
	public RustText nameText;

	public RustText seenText;

	public RawImage mugshotImage;

	public Texture2D unknownMugshot;

	public InputField noteInput;

	public GameObject[] relationshipTypeTags;

	public Phrase lastSeenPrefix;

	public Phrase nowPhrase;

	public Phrase agoSuffix;

	public RustButton FriendlyButton;

	public RustButton SeenButton;

	public RustButton EnemyButton;

	public RustButton chatMute;
}


using UnityEngine;

public class UIBuffs : SingletonComponent<UIBuffs>
{
	public bool Enabled = true;

	public Transform PrefabBuffIcon;

	public void Refresh(PlayerModifiers modifiers)
	{
		if (!Enabled)
		{
			return;
		}
		RemoveAll();
		if ((Object)(object)modifiers == (Object)null)
		{
			return;
		}
		foreach (Modifier item in modifiers.All)
		{
			if (item != null)
			{
				Object.Instantiate<Transform>(PrefabBuffIcon).SetParent(((Component)this).transform);
			}
		}
	}

	private void RemoveAll()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		foreach (Transform item in ((Component)this).transform)
		{
			Object.Destroy((Object)(object)((Component)item).gameObject);
		}
	}
}


using TMPro;
using UnityEngine;

public abstract class UIBuffsIcon<T, T2> : SingletonComponent<UIBuffsIcon<T, T2>> where T : BaseModifiers<T2> where T2 : BaseCombatEntity
{
	public TextMeshProUGUI Text;

	public Tooltip ToolTip;

	public CanvasGroup Group;

	protected UIBuffsIcon()
	{
		((SingletonComponent<UIBuffsIcon<UIBuffsIcon<T, T2>, ?>>)(object)this)..ctor();
	}
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UICompass : MonoBehaviour
{
	public RawImage compassStrip;

	public CanvasGroup compassGroup;

	public List<CompassMapMarker> CompassMarkers;

	public List<CompassMapMarker> TeamCompassMarkers;

	public List<CompassMissionMarker> MissionMarkers;

	public CompassMapMarker DeathMarker;

	public static readonly Phrase IslandInfoPhrase = new Phrase("nexus.compass.island_info", "Continue for {distance} to travel to {zone}");

	public RectTransform IslandInfoContainer;

	public RustText IslandInfoText;

	public float IslandInfoDistanceThreshold = 250f;

	public float IslandLookThreshold = -0.8f;

	public RectTransform IslandInfoFullContainer;

	public List<CompassMapMarker> LocalPings;

	public List<CompassMapMarker> TeamPings;

	public Image LeftPingPulse;

	public Image RightPingPulse;
}


using UnityEngine;

public class UIFadeOut : MonoBehaviour
{
	public float secondsToFadeOut = 3f;

	public bool destroyOnFaded = true;

	public CanvasGroup targetGroup;

	public float fadeDelay;
}


using UnityEngine;
using UnityEngine.UI;

public class UIFishing : SingletonComponent<UIFishing>
{
	public Slider TensionLine;

	public Image FillImage;

	public Gradient FillGradient;

	private void Start()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


public class UIHorseBuffsIcon : UIBuffsIcon<HorseModifiers, RidableHorse>
{
}


using UnityEngine;

public class UIHUD : SingletonComponent<UIHUD>, IUIScreen
{
	public UIChat chatPanel;

	public HudElement Hunger;

	public HudElement Thirst;

	public HudElement Health;

	public HudElement PendingHealth;

	public HudElement VehicleHealth;

	public HudElement AnimalStamina;

	public HudElement AnimalStaminaMax;

	public HudElement ShieldHealth;

	public RectTransform vitalsRect;

	public RectTransform noticesRect;

	public Canvas healthCanvas;

	public UICompass CompassWidget;

	public GameObject KeyboardCaptureMode;
}


public class UIPlayerBuffsIcon : UIBuffsIcon<PlayerModifiers, BasePlayer>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIRecordingInfo : SingletonComponent<UIRecordingInfo>
{
	public RustText CountdownText;

	public Slider TapeProgressSlider;

	public GameObject CountdownRoot;

	public GameObject RecordingRoot;

	public Transform Spinner;

	public float SpinSpeed = 180f;

	public Image CassetteImage;

	private void Start()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIRestrained : SingletonComponent<UIRestrained>
{
	public Image Fill;

	private void Start()
	{
		SetActive(state: false);
		SetProgress(0f);
	}

	public void SetActive(bool state)
	{
		((Component)this).gameObject.SetActive(state);
	}

	public void SetProgress(Item handcuffItem)
	{
		if (handcuffItem == null)
		{
			SetProgress(0f);
		}
		else
		{
			SetProgress(1f - handcuffItem.condition / handcuffItem.maxCondition);
		}
	}

	public void SetProgress(float progress)
	{
		Fill.fillAmount = progress;
	}
}


public class UIUnderlay : SingletonComponent<UIUnderlay>
{
	public GameObjectRef damageDirectional;

	public GameObjectRef waterDirectional;
}


using UnityEngine;

public class IngameMenuBackground : MonoBehaviour
{
	public static bool Enabled;

	public CanvasGroup canvasGroup;
}


public class AmmoInformationPanel : ItemInformationPanel
{
	public ItemTextValue[] modifierValues;

	public ItemTextValue durationValue;

	public ItemStatValue damageDisplay;

	public ItemStatValue velocityDisplay;

	public ItemStatValue spreadDisplay;

	public ItemTextValue pelletsDisplay;

	public ItemStatValue falloffRangeDisplay;

	public ItemTextValue thicknessDisplay;
}


using UnityEngine;
using UnityEngine.UI;

public class ArmorInformationPanel : ItemInformationPanel
{
	public ItemTextValue projectileDisplay;

	public ItemTextValue meleeDisplay;

	public ItemTextValue coldDisplay;

	public ItemTextValue explosionDisplay;

	public ItemTextValue radiationDisplay;

	public ItemTextValue biteDisplay;

	public ItemTextValue speedDisplay;

	public ItemTextValue spacer;

	public Text areaProtectionText;

	public Phrase LegText;

	public Phrase ChestText;

	public Phrase HeadText;

	public Phrase ChestLegsText;

	public Phrase WholeBodyText;

	public ItemTextValue eggVision;

	public ItemIcon[] insertIcons;

	public GridLayoutGroup informationGridLayout;

	public RectOffset paddingOnResize;

	public Vector2 cellSizeOnResize;

	public Vector2 spacingOnResize;

	private RectOffset originalPadding;

	private Vector2 originalCellSize;

	private Vector2 originalSpacing;

	private ProtectionProperties protection;
}


public class ArmorInsertInformationPanel : ItemInformationPanel
{
	public ItemTextValue projectileDisplay;

	public ItemTextValue meleeDisplay;

	public ItemTextValue coldDisplay;

	public ItemTextValue explosionDisplay;

	public ItemTextValue radiationDisplay;

	public ItemTextValue biteDisplay;

	public ItemTextValue spacer;
}


using UnityEngine;

public class BackpackInventoryPanel : MonoBehaviour
{
	private ItemIcon icon;

	public GameObject[] ShowWhenSelected;

	public GameObject[] HideWhenSelected;

	public Vector3 BackpackTargetRotation = new Vector3(0f, 0f, 0f);

	public Vector3 BackpackTargetUIShift = Vector2.op_Implicit(new Vector2(160f, 0f));

	public AnimationCurve BackpackModelRotateCurve;

	public AnimationCurve BackpackUIShiftCurve;

	public AnimationCurve BackpackTransparencyCurve;

	public AnimationCurve FadeOutWhenOpenCurve;

	public float OpenScale = 1f;

	public float CloseScale = 1f;

	public float BackpackAlphaActiveThreshold = 1f;

	public RectTransform PreviewModelRectTransform;

	public CanvasGroup BackpackInventoryCanvas;

	public CanvasGroup[] FadeOutWhenOpen;
}


using Rust.UI;
using UnityEngine;

public class BeltBarIcon : MonoBehaviour
{
	public RustText TextBind;

	public string bind;
}


using UnityEngine;

public class BlueprintInformationPanel : ItemInformationPanel
{
	public GameObject LearnedRoot;

	public GameObject NotLearnedRoot;

	public GameObject NotLearnableRoot;
}


using UnityEngine;
using UnityEngine.UI;

public class BlueprintButton : MonoBehaviour, IClientComponent, IInventoryChanged
{
	public Image image;

	public Image imageFavourite;

	public Button button;

	public CanvasGroup group;

	public GameObject newNotification;

	public GameObject lockedOverlay;

	public Tooltip Tip;

	public Image FavouriteIcon;

	public PingWidget TutorialHighlight;
}


using TMPro;
using UnityEngine;

public class BlueprintCategoryButton : MonoBehaviour, IInventoryChanged
{
	public TextMeshProUGUI amountLabel;

	public ItemCategory Category;

	public bool AlwaysShow;

	public bool ShowItemCount = true;

	public GameObject BackgroundHighlight;

	public SoundDefinition clickSound;

	public SoundDefinition hoverSound;

	public PingWidget tutorialHighlight;
}


using Rust.UI;
using UnityEngine;

public class BlueprintCraftGridRow : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public RustText amountText;

	public RustText itemNameText;

	public RustText totalText;

	public RustText haveText;

	public Color colorOK;

	public Color colorBad;
}


using UnityEngine;
using UnityEngine.UI;

public class BlueprintHeader : MonoBehaviour
{
	public Text categoryName;

	public Text unlockCount;

	public void Setup(ItemCategory name, int unlocked, int total)
	{
		categoryName.text = name.ToString().ToUpper();
		unlockCount.text = $"UNLOCKED {unlocked}/{total}";
	}
}


using TMPro;
using UnityEngine;

public class CraftingNotice : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public TextMeshProUGUI itemName;

	public TextMeshProUGUI craftSeconds;
}


using UnityEngine;
using UnityEngine.UI;

public class CraftingQueue : SingletonComponent<CraftingQueue>
{
	public GameObject queueContainer;

	public GameObject queueItemPrefab;

	private ScrollRect scrollRect;
}


using UnityEngine;
using UnityEngine.UI;

public class CraftingQueueIcon : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public Image icon;

	public Image iconCancel;

	public GameObject timeLeft;

	public GameObject craftingCount;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SelectedBlueprint : SingletonComponent<SelectedBlueprint>, IInventoryChanged
{
	public ItemBlueprint blueprint;

	public InputField craftAmountText;

	public GameObject ingredientGrid;

	public IconSkinPicker skinPicker;

	public Image iconImage;

	public RustText titleText;

	public RustText descriptionText;

	public CanvasGroup CraftArea;

	public Button CraftButton;

	public RustText CraftingTime;

	public RustText CraftingAmount;

	public GameObject TutorialCraftButtonHighlight;

	public Sprite FavouriteOnSprite;

	public Sprite FavouriteOffSprite;

	public Image FavouriteButtonStatusMarker;

	public GameObject[] workbenchReqs;

	private ItemInformationPanel[] informationPanels;

	public static bool isOpen
	{
		get
		{
			if ((Object)(object)SingletonComponent<SelectedBlueprint>.Instance == (Object)null)
			{
				return false;
			}
			return (Object)(object)SingletonComponent<SelectedBlueprint>.Instance.blueprint != (Object)null;
		}
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UIBlueprints : ListComponent<UIBlueprints>
{
	public GameObjectRef buttonPrefab;

	public ScrollRect scrollRect;

	public CanvasGroup ScrollRectCanvasGroup;

	public TMP_InputField searchField;

	public GameObject searchFieldPlaceholder;

	public GameObject listAvailable;

	public GameObject listLocked;

	public GameObject Categories;

	public VerticalLayoutGroup CategoryVerticalLayoutGroup;

	public BlueprintCategoryButton FavouriteCategoryButton;
}


using System;
using Rust.UI;
using UnityEngine;

public class ChangelogButton : MonoBehaviour
{
	public RustButton Button;

	public CanvasGroup CanvasGroup;

	private void Update()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Expected O, but got Unknown
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: false);
		if ((Object)(object)activeGameMode != (Object)null)
		{
			if (CanvasGroup.alpha != 1f)
			{
				CanvasGroup.alpha = 1f;
				CanvasGroup.blocksRaycasts = true;
				Button.Text.SetPhrase(new Phrase(activeGameMode.shortname, activeGameMode.shortname), Array.Empty<object>());
			}
		}
		else if (CanvasGroup.alpha != 0f)
		{
			CanvasGroup.alpha = 0f;
			CanvasGroup.blocksRaycasts = false;
		}
	}
}


using Rust.UI;
using UnityEngine;

public class ChangelogPanel : MonoBehaviour
{
	public GameObject AddedHeader;

	public GameObject RemovedHeader;

	public GameObject ChangedHeader;

	public RustText AddedContent;

	public RustText RemovedContent;

	public RustText ChangedContent;

	public RectTransform MainPanelRectTransform;

	public RectTransform ContentPanelRectTransform;
}


using UnityEngine;
using UnityEngine.UI;

public class ChickenCoopStatusNeedWidget : MonoBehaviour
{
	public Image ProgressImage;

	public Image BackgroundImage;

	public Color BackgroundPositiveColour;

	public Color BackgroundNegativeColour;

	public Color ProgressPositiveColour;

	public Color ProgressNegativeColour;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ChickenCoopStatusWidget : MonoBehaviour
{
	public RustText HatchTime;

	public Image HatchProgressBar;

	public GameObject HatchingRoot;

	public GameObject AliveRoot;

	public RustText NameText;

	public ChickenCoopStatusNeedWidget HungerWidget;

	public ChickenCoopStatusNeedWidget ThirstWidget;

	public ChickenCoopStatusNeedWidget LoveWidget;

	public ChickenCoopStatusNeedWidget SunlightWidget;

	public GameObject HappyFace;

	public GameObject NeutralFace;

	public GameObject SadFace;

	public TMP_InputField NameInput;

	public GameObject NameEditRoot;

	public bool IsLootPanel;
}


public class ConstructableInformationPanel : ItemInformationPanel
{
	public BlueprintCraftGridRow[] ingredientRows;
}


using UnityEngine;
using UnityEngine.UI;

public class ConsumableInformationPanel : ItemInformationPanel
{
	public ItemTextValue[] values;

	public UIGenesDisplay Genes;

	public Text TextUnknownGenetics;

	public Text LabelGenetics;

	public GameObject GeneticsGameObject;

	public ItemTextValue durationValue;

	public ItemTextValue baitValue;

	public ItemTextValue baitStackSize;

	public ItemTextValue spoilTime;

	public GameObject refrigeratedIcon;

	public GameObject chickenFood;
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class DragReceiver : MonoBehaviour
{
	[Serializable]
	public class TriggerEvent : UnityEvent<BaseEventData>
	{
	}

	public TriggerEvent onEndDrag;
}


using System;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[Serializable]
public class TriggerEvent : UnityEvent<BaseEventData>
{
}


using Rust.UI;

public class DroneInformationPanel : ItemInformationPanel
{
	public RustText identifierLabel;
}


using UnityEngine;
using UnityEngine.UI;

public class EngineItemInformationPanel : ItemInformationPanel
{
	[SerializeField]
	private Text tier;

	[SerializeField]
	private Phrase low;

	[SerializeField]
	private Phrase medium;

	[SerializeField]
	private Phrase high;

	[SerializeField]
	private GameObject accelerationRoot;

	[SerializeField]
	private GameObject topSpeedRoot;

	[SerializeField]
	private GameObject fuelEconomyRoot;
}


using UnityEngine.UI;

public class ExplosiveInformationPanel : ItemInformationPanel
{
	public ItemTextValue explosiveDmgDisplay;

	public ItemTextValue lethalDmgDisplay;

	public ItemTextValue throwDistanceDisplay;

	public ItemTextValue projectileDistanceDisplay;

	public ItemTextValue fuseLengthDisplay;

	public ItemTextValue blastRadiusDisplay;

	public Text unreliableText;
}


public class FlameThrowerInformationPanel : ItemInformationPanel
{
	public ItemStatValue damageDisplay;

	public ItemStatValue rangeDisplay;
}


public class FrankensteinPartInformationPanel : ItemInformationPanel
{
	public ItemTextValue healthDisplay;

	public ItemTextValue speedDisplay;

	public ItemTextValue attackRateDisplay;

	public ItemTextValue attackDamageDisplay;
}


public class GunModInformationPanel : ItemInformationPanel
{
	public ItemTextValue fireRateDisplay;

	public ItemTextValue velocityDisplay;

	public ItemTextValue damageDisplay;

	public ItemTextValue accuracyDisplay;

	public ItemTextValue recoilDisplay;

	public ItemTextValue zoomDisplay;

	public ItemTextValue ammoDisplay;
}


using UnityEngine;
using UnityEngine.UI;

public class HeadInformationPanel : ItemInformationPanel
{
	public ItemDefinition HeadInfo;

	public GameObject PlayerRoot;

	public GameObject NPCRoot;

	public GameObject HorseRoot;

	public Image NPCImage;

	public Text NPCText;

	public Text PlayerNameText;

	public Text PlayerIdText;

	public Text HorseBreedText;
}


public class HorseEquipmentInformationPanel : ItemInformationPanel
{
	public ItemTextValue horseProtectionDisplay;

	public ItemTextValue riderProtectionDisplay;

	public ItemTextValue maxSpeedDisplay;

	public ItemTextValue storageAmountDisplay;
}


public class IOEntityInformationPanel : ItemInformationPanel
{
	public ItemTextValue requiredPowerDisplay;

	public ItemTextValue requiredFluidDisplay;

	public ItemTextValue generatedPowerDisplay;

	public ItemTextValue capacityDisplay;

	public ItemTextValue chargeDisplay;

	public ItemTextValue rangeDisplay;
}


using UnityEngine;

public class ItemDropCommand : MonoBehaviour
{
	public string command = "drop";
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ItemIcon : BaseMonoBehaviour, IPointerClickHandler, IEventSystemHandler, IPointerEnterHandler, IPointerExitHandler, IDraggable, IPreInventoryChanged, IItemAmountChanged, IItemIconChanged
{
	private Color backgroundColor;

	public Color selectedBackgroundColor = new Color(0.12156863f, 0.41960785f, 32f / 51f, 40f / 51f);

	public float unoccupiedAlpha = 1f;

	public Color unoccupiedColor;

	public ItemContainerSource containerSource;

	public int slotOffset;

	[Range(0f, 64f)]
	public int slot;

	public bool setSlotFromSiblingIndex = true;

	public GameObject slots;

	public CanvasGroup iconContents;

	public CanvasGroup canvasGroup;

	public Image iconImage;

	public Image underlayImage;

	public Text amountText;

	public Text hoverText;

	public Image hoverOutline;

	public Image cornerIcon;

	public Image lockedImage;

	public Image progressImage;

	public Image backgroundImage;

	public Image backgroundUnderlayImage;

	public Image progressPanel;

	public Sprite emptySlotBackgroundSprite;

	public CanvasGroup conditionObject;

	public Image conditionFill;

	public Image maxConditionFill;

	public GameObject lightEnabled;

	public GameObject burstEnabled;

	public bool allowSelection = true;

	public bool allowDropping = true;

	public bool allowMove = true;

	public bool showCountDropShadow;

	[NonSerialized]
	public Item item;

	[NonSerialized]
	public bool invalidSlot;

	public SoundDefinition hoverSound;

	public virtual void OnPointerClick(PointerEventData eventData)
	{
	}

	public void OnPointerEnter(PointerEventData eventData)
	{
	}

	public void OnPointerExit(PointerEventData eventData)
	{
	}
}


using UnityEngine;

public class ItemInformationPanel : MonoBehaviour
{
	public bool ForceHidden(ItemDefinition info)
	{
		if ((Object)(object)info == (Object)null)
		{
			return false;
		}
		return (Object)(object)((Component)info).GetComponent<ItemModHideInfoPanel>() != (Object)null;
	}

	public virtual bool EligableForDisplay(ItemDefinition info)
	{
		return false;
	}

	public virtual void SetupForItem(ItemDefinition info, Item item = null)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ItemModifiableStatValue : MonoBehaviour
{
	public Text text;

	public Slider slider;

	public Slider positiveModificationSlider;

	public Slider negativeModificationSlider;

	public Tooltip modificationNumbersTooltip;

	public bool smallerIsBetter;

	public bool asPercentage;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ItemOptionButton : MonoBehaviour
{
	public RustText name;

	public Image icon;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ItemOwnershipPanel : MonoBehaviour
{
	public LayoutElement Layout;

	public Image BackgroundImage;

	public Tooltip Tooltip;

	public RustText Label;

	public Color[] Colors;
}


public class ItemPanel : SingletonComponent<ItemPanel>
{
}


public interface IItemPanel
{
}


using TMPro;
using UnityEngine;

public class ItemPickupNotice : MonoBehaviour
{
	public TextMeshProUGUI Text;

	public TextMeshProUGUI Amount;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class ItemPreviewIcon : BaseMonoBehaviour, IInventoryChanged, IItemAmountChanged, IItemIconChanged
{
	public ItemContainerSource containerSource;

	[Range(0f, 64f)]
	public int slot;

	public bool setSlotFromSiblingIndex = true;

	public CanvasGroup iconContents;

	public Image iconImage;

	public Text amountText;

	[NonSerialized]
	public Item item;
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ItemSplitter : MonoBehaviour
{
	public Slider slider;

	public TextMeshProUGUI textValue;

	public TextMeshProUGUI splitAmountText;

	public TMP_InputField amountInputField;
}


using UnityEngine;

public class ItemSplitterDragOut : MonoBehaviour, IDraggable
{
	public ItemSplitter rootSplitter;
}


using UnityEngine;

public class ItemSplitterSlider : MonoBehaviour
{
	public ItemSplitter Splitter;
}


using UnityEngine;
using UnityEngine.UI;

public class ItemStatValue : MonoBehaviour
{
	public Text text;

	public Slider slider;

	public bool smallerIsBetter;

	public bool asPercentage;
}


public class ItemSubmitPanel : LootPanel
{
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class ItemTextValue : MonoBehaviour
{
	public Text text;

	public Color bad;

	public Color good;

	public bool negativestat;

	public bool asPercentage;

	public bool useColors = true;

	public bool signed = true;

	public string affix;

	public string suffix;

	public float multiplier = 1f;

	public float addition;

	public void SetValue(float val, int numDecimals = 0, string overrideText = "")
	{
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		val = val * multiplier + addition;
		text.text = ((overrideText == "") ? string.Format("{0}{1:n" + numDecimals + "}", (val > 0f && signed) ? "+" : "", val) : overrideText);
		if (!string.IsNullOrEmpty(affix))
		{
			text.text = affix + text.text;
		}
		if (asPercentage)
		{
			Text obj = text;
			obj.text += " %";
		}
		if (suffix != "" && !float.IsPositiveInfinity(val))
		{
			Text obj2 = text;
			obj2.text += suffix;
		}
		bool flag = val > 0f;
		if (negativestat)
		{
			flag = !flag;
		}
		if (useColors)
		{
			((Graphic)text).color = (flag ? good : bad);
		}
	}

	public void SetValue(TimeSpan time)
	{
		text.text = time.ToShortString();
	}

	public void SetValue(string display)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		text.text = display;
		if (!string.IsNullOrEmpty(affix))
		{
			text.text = affix + text.text;
		}
		bool flag = true;
		if (negativestat)
		{
			flag = !flag;
		}
		if (useColors)
		{
			((Graphic)text).color = (flag ? good : bad);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class KeyInformationPanel : ItemInformationPanel
{
	[SerializeField]
	private Text id;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LootPanel : MonoBehaviour
{
	public interface IHasLootPanel
	{
		Phrase LootPanelTitle { get; }
	}

	public Text Title;

	public RustText TitleText;

	public bool hideInvalidIcons;

	[Tooltip("Only needed if hideInvalidIcons is true")]
	public CanvasGroup canvasGroup;
}


public interface IHasLootPanel
{
	Phrase LootPanelTitle { get; }
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelCardTableTerminal : LootPanel
{
	[SerializeField]
	private Text buyInInfoText;

	[SerializeField]
	private Phrase phraseMin;

	[SerializeField]
	private Phrase phraseMax;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelChickenCoop : LootPanel
{
	public ChickenCoopStatusWidget[] StatusWidgets;

	public CanvasGroup ControlsGroup;

	public Button fromButton;

	public Button toButton;

	public Tooltip FoodTooltip;
}


using UnityEngine;

public class LootPanelContainer : MonoBehaviour
{
	public static string containerName = "generic";

	public GameObject NoLootPanel;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LootPanelEngine : LootPanel
{
	[SerializeField]
	private Image engineImage;

	[SerializeField]
	private ItemIcon[] icons;

	[SerializeField]
	private GameObject warning;

	[SerializeField]
	private RustText hp;

	[SerializeField]
	private RustText power;

	[SerializeField]
	private RustText acceleration;

	[SerializeField]
	private RustText topSpeed;

	[SerializeField]
	private RustText fuelEconomy;
}


using UnityEngine.UI;

public class LootPanelFrankensteinTable : LootPanel, IInventoryChanged
{
	public Button StartCreatingButton;
}


using Rust.UI;
using UnityEngine;

public class LootPanelHorse : LootPanel
{
	public RustText breedTitle;

	public RustText healthText;

	public RustText maxSpeedText;

	public RustText staminaText;

	public GameObject[] storageSlots;

	public GameObject buffs;
}


using Rust.UI;
using UnityEngine;

public class LootPanelIndustrialCrafter : LootPanel
{
	public GameObject CraftingRoot;

	public RustSlider ProgressSlider;

	public Transform Spinner;

	public float SpinSpeed = 90f;

	public GameObject WorkbenchLevelRoot;
}


using UnityEngine;

public class LootPanelLocker : LootPanel
{
	public GameObject[] controls;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelMixingTable : LootPanel, IInventoryChanged
{
	public GameObject controlsOn;

	public GameObject controlsOff;

	public Button StartMixingButton;

	public InfoBar ProgressBar;

	public GameObjectRef recipeItemPrefab;

	public RectTransform recipeContentRect;

	public ScrollRect ScrollView;

	public static readonly Phrase MixingPhrase = new Phrase("mixingtable.mixing", "Mixing... {0} seconds remaining");

	public static readonly Phrase CookingPhrase = new Phrase("cookingworkbench.cooking", "Cooking... {0} seconds remaining");
}


public class LootPanelOven : LootPanel
{
}


using UnityEngine;

public class LootPanelPlayerCorpse : LootPanel
{
	public GameObject[] BeltRoots;

	public GameObject[] ClothingRoots;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelReclaim : LootPanel
{
	public int oldOverflow = -1;

	public Text overflowText;

	public GameObject overflowObject;

	public static readonly Phrase MorePhrase = new Phrase("reclaim.more", "additional items...");
}


using UnityEngine;

public class LootPanelRecycler : LootPanel
{
	public GameObject controlsOn;

	public GameObject controlsOff;

	public GameObject recycle_efficiency_safezone;

	public GameObject recycle_efficiency_radtown;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LootPanelTrophyStand : LootPanel
{
	public GameObject SubmitButton;

	public GameObject NonMatchingTrophyButton;

	public Text CountText;

	public GameObject CountRoot;

	public GameObject NameRoot;

	public RustText NameText;

	public GameObject ClearButton;
}


using UnityEngine;
using UnityEngine.UI;

public class LootPanelWaterCatcher : LootPanel
{
	public ItemIcon sourceItem;

	public Image capacityImage;

	public CanvasGroup helpCanvas;

	public CanvasGroup buttonsCanvas;

	public Button fromButton;

	public Button toButton;

	public Button drinkButton;
}


using UnityEngine;

public class MeleeWeaponInformationPanel : ItemInformationPanel
{
	public ItemStatValue damageDisplay;

	public ItemStatValue attackRateDisplay;

	public ItemStatValue attackSizeDisplay;

	public ItemStatValue attackRangeDisplay;

	public ItemStatValue oreGatherDisplay;

	public ItemStatValue treeGatherDisplay;

	public ItemStatValue fleshGatherDisplay;

	public GameObject untieCrateDisplay;

	public GameObject shieldCompatible;
}


using UnityEngine;

public class NoticeArea : SingletonComponent<NoticeArea>
{
	public GameObjectRef itemPickupPrefab;

	public GameObjectRef itemPickupCondensedText;

	public GameObjectRef itemDroppedPrefab;

	public AnimationCurve pickupSizeCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve pickupAlphaCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve reuseAlphaCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public AnimationCurve reuseSizeCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	private IVitalNotice[] notices;

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		notices = ((Component)this).GetComponentsInChildren<IVitalNotice>(true);
	}
}


using System;
using UnityEngine;

public class LootAllButton : MonoBehaviour
{
	public Func<Item, bool> Filter;

	public OvenLootPanel inventoryGrid;
}


using System.Collections.Generic;
using UnityEngine;

public class LootGrid : MonoBehaviour
{
	public int Container;

	public int Offset;

	public int Count = 1;

	public GameObject ItemIconPrefab;

	public Sprite BackgroundImage;

	public ItemContainerSource Inventory;

	private List<ItemIcon> _icons = new List<ItemIcon>();

	public void CreateInventory(ItemContainerSource inventory, int? slots = null, int? offset = null)
	{
		foreach (ItemIcon icon in _icons)
		{
			Object.Destroy((Object)(object)((Component)icon).gameObject);
		}
		_icons.Clear();
		Inventory = inventory;
		Count = slots ?? Count;
		Offset = offset ?? Offset;
		for (int i = 0; i < Count; i++)
		{
			ItemIcon component = Object.Instantiate<GameObject>(ItemIconPrefab, ((Component)this).transform).GetComponent<ItemIcon>();
			component.slot = Offset + i;
			component.emptySlotBackgroundSprite = BackgroundImage ?? component.emptySlotBackgroundSprite;
			component.containerSource = inventory;
			_icons.Add(component);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust.UI;
using UnityEngine;

public class OvenItemIcon : MonoBehaviour
{
	[Serializable]
	public class OvenSlotConfig
	{
		public OvenSlotType Type;

		public Sprite BackgroundImage;

		public Phrase SlotPhrase;
	}

	public ItemIcon ItemIcon;

	public RustText ItemLabel;

	public RustText MaterialLabel;

	public OvenSlotType SlotType;

	public Phrase EmptyPhrase = new Phrase("empty", "empty");

	public List<OvenSlotConfig> SlotConfigs = new List<OvenSlotConfig>();

	public float DisabledAlphaScale;

	public CanvasGroup CanvasGroup;

	private Item _item;

	private void Start()
	{
		OvenSlotConfig ovenSlotConfig = SlotConfigs.FirstOrDefault((OvenSlotConfig x) => x.Type == SlotType);
		if (ovenSlotConfig == null)
		{
			Debug.LogError((object)$"Can't find slot config for '{SlotType}'");
			return;
		}
		ItemIcon.emptySlotBackgroundSprite = ovenSlotConfig.BackgroundImage;
		MaterialLabel.SetPhrase(ovenSlotConfig.SlotPhrase, Array.Empty<object>());
		UpdateLabels();
	}

	private void Update()
	{
		if (ItemIcon.item != _item)
		{
			_item = ItemIcon.item;
			UpdateLabels();
		}
	}

	private void UpdateLabels()
	{
		CanvasGroup.alpha = ((_item != null) ? 1f : DisabledAlphaScale);
		RustText itemLabel = ItemLabel;
		if (itemLabel != null)
		{
			itemLabel.SetPhrase((_item == null) ? EmptyPhrase : _item.info.displayName, Array.Empty<object>());
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class OvenSlotConfig
{
	public OvenSlotType Type;

	public Sprite BackgroundImage;

	public Phrase SlotPhrase;
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class OvenLineRow : MonoBehaviour
{
	public LootGrid Above;

	public LootGrid Below;

	public Transform Container;

	public Color Color = Color.white;

	public Sprite TriangleSprite;

	public int LineWidth = 2;

	public int ArrowWidth = 6;

	public int ArrowHeight = 4;

	public int Padding = 2;

	private int _topCount;

	private int _bottomCount;

	private List<GameObject> images = new List<GameObject>();

	private void Update()
	{
		LootGrid above = Above;
		int num = ((above != null) ? ((Component)above).transform.childCount : 0);
		LootGrid below = Below;
		int num2 = ((below != null) ? ((Component)below).transform.childCount : 0);
		if (num2 == _bottomCount && num == _topCount)
		{
			return;
		}
		_bottomCount = num2;
		_topCount = num;
		foreach (GameObject image in images)
		{
			Object.Destroy((Object)(object)image);
		}
		CreateRow(above: true);
		CreateRow(above: false);
	}

	private void CreateRow(bool above)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		LootGrid lootGrid = (above ? Above : Below);
		int num = (above ? _topCount : _bottomCount);
		if (num == 0)
		{
			return;
		}
		int num2 = num;
		GridLayoutGroup component = ((Component)lootGrid).GetComponent<GridLayoutGroup>();
		float x = component.cellSize.x;
		float x2 = component.spacing.x;
		float num3 = x + x2;
		float num4 = num3 * (float)(num - 1) / 2f;
		if (above)
		{
			for (int i = 0; i < num; i++)
			{
				if (i == 0 || i == num - 1)
				{
					Image obj = CreateImage();
					((Graphic)obj).rectTransform.anchorMin = new Vector2(0.5f, above ? 0.5f : 0f);
					((Graphic)obj).rectTransform.anchorMax = new Vector2(0.5f, above ? 1f : 0.5f);
					((Graphic)obj).rectTransform.offsetMin = new Vector2(0f - num4 + (float)i * num3 - (float)(LineWidth / 2), (float)(above ? (LineWidth / 2) : Padding));
					((Graphic)obj).rectTransform.offsetMax = new Vector2(0f - num4 + (float)i * num3 + (float)(LineWidth / 2), (float)(above ? (-Padding) : (-LineWidth / 2)));
				}
			}
		}
		else
		{
			Image obj2 = CreateImage();
			((Graphic)obj2).rectTransform.anchorMin = new Vector2(0.5f, 0f);
			((Graphic)obj2).rectTransform.anchorMax = new Vector2(0.5f, 0.5f);
			((Graphic)obj2).rectTransform.offsetMin = new Vector2((float)(-LineWidth / 2), (float)Padding);
			((Graphic)obj2).rectTransform.offsetMax = new Vector2((float)(LineWidth / 2), (float)(-LineWidth / 2));
			Image obj3 = CreateImage();
			obj3.sprite = TriangleSprite;
			((Object)((Component)obj3).gameObject).name = "triangle";
			obj3.useSpriteMesh = true;
			((Transform)((Graphic)obj3).rectTransform).localRotation = Quaternion.Euler(0f, 0f, 180f);
			((Graphic)obj3).rectTransform.anchorMin = new Vector2(0.5f, 0f);
			((Graphic)obj3).rectTransform.anchorMax = new Vector2(0.5f, 0f);
			((Graphic)obj3).rectTransform.pivot = new Vector2(0.5f, 0f);
			((Graphic)obj3).rectTransform.offsetMin = new Vector2((float)(-ArrowWidth / 2), 0f);
			((Graphic)obj3).rectTransform.offsetMax = new Vector2((float)(ArrowWidth / 2), (float)ArrowHeight);
		}
		if (above && num2 >= 1)
		{
			float num5 = num3 * (float)(num2 - 1) + (float)LineWidth;
			Image obj4 = CreateImage();
			((Graphic)obj4).rectTransform.anchorMin = new Vector2(0.5f, 0.5f);
			((Graphic)obj4).rectTransform.anchorMax = new Vector2(0.5f, 0.5f);
			((Graphic)obj4).rectTransform.offsetMin = new Vector2(num5 / -2f, (float)(-LineWidth / 2));
			((Graphic)obj4).rectTransform.offsetMax = new Vector2(num5 / 2f, (float)(LineWidth / 2));
		}
	}

	private Image CreateImage()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Expected O, but got Unknown
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		GameObject val = new GameObject("Line");
		Image obj = val.AddComponent<Image>();
		images.Add(val);
		((Transform)((Graphic)obj).rectTransform).SetParent(Container ?? ((Component)this).transform);
		((Component)obj).transform.localScale = Vector3.one;
		((Graphic)obj).color = Color;
		return obj;
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class OvenLootPanel : MonoBehaviour
{
	public GameObject controlsOn;

	public GameObject controlsOff;

	public Image TitleBackground;

	public RustText TitleText;

	public Color AlertBackgroundColor;

	public Color AlertTextColor;

	public Color OffBackgroundColor;

	public Color OffTextColor;

	public Color OnBackgroundColor;

	public Color OnTextColor;

	private Phrase OffPhrase = new Phrase("off", "off");

	private Phrase OnPhrase = new Phrase("on", "on");

	private Phrase NoFuelPhrase = new Phrase("no_fuel", "No Fuel");

	public GameObject FuelRowPrefab;

	public GameObject MaterialRowPrefab;

	public GameObject ItemRowPrefab;

	public Sprite IconBackground_Wood;

	public Sprite IconBackGround_Input;

	public LootGrid LootGrid_Wood;

	public LootGrid LootGrid_Input;

	public LootGrid LootGrid_Output;

	public GameObject Contents;

	public GameObject[] ElectricDisableRoots = (GameObject[])(object)new GameObject[0];
}


public enum OvenSlotType
{
	Fuel,
	Charcoal,
	Material,
	Smelted,
	FoodInput,
	FoodOutput
}


public enum OvenStatus
{
	NoFuel,
	Off,
	On
}


using UnityEngine.UI;

public class PaperDollSegment : BaseMonoBehaviour
{
	public static HitArea selectedAreas;

	[InspectorFlags]
	public HitArea area;

	public Image overlayImg;
}


using UnityEngine;

public class ProjectileWeaponInformationPanel : ItemInformationPanel
{
	public ItemModifiableStatValue damageDisplay;

	public ItemModifiableStatValue recoilDisplay;

	public ItemModifiableStatValue rofDisplay;

	public ItemModifiableStatValue accuracyDisplay;

	public ItemModifiableStatValue rangeDisplay;

	public ItemStatValue minigunMoveDisplay;

	public GameObject shieldCompatible;

	public GameObject bypassModTogglesButtonParent;

	public ItemIcon[] attachmentIcons;

	public void SetBypassModToggles(bool toggle)
	{
	}
}


using Rust;
using TMPro;
using UnityEngine;

public class ProtectionValue : MonoBehaviour, IClothingChanged
{
	public CanvasGroup group;

	public TextMeshProUGUI text;

	public DamageType damageType;

	public bool selectedItem;

	public bool displayBaseProtection;
}


using UnityEngine;

public class QuickCraft : SingletonComponent<QuickCraft>, IInventoryChanged
{
	public GameObjectRef craftButton;

	public GameObject empty;

	public Sprite FavouriteOnSprite;

	public Sprite FavouriteOffSprite;

	public Color FavouriteOnColor;

	public Color FavouriteOffColor;
}


using UnityEngine;
using UnityEngine.UI;

public class QuickCraftButton : MonoBehaviour
{
	public Image icon;

	public Image favourite;

	public Tooltip tooltip;

	public Text CraftCount;

	public Image FavouriteIcon;

	public const int QuickCraftMultipleCount = 5;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;

public class RepairBenchPanel : LootPanel
{
	public RustText infoText;

	public GameObject repairButton;

	public GameObject skinLinkButton;

	public Color gotColor;

	public Color notGotColor;

	public Color skinColour;

	public Phrase phraseEmpty;

	public Phrase phraseNotRepairable;

	public Phrase phraseRepairNotNeeded;

	public Phrase phraseNoBlueprint;

	public GameObject skinsPanel;

	public GameObject changeSkinDialog;

	public IconSkinPicker picker;

	public GameObject costIconsParent;

	public List<VirtualItemIcon> costIcons;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class ResearchTablePanel : LootPanel
{
	public Button researchButton;

	public RustText timerText;

	public GameObject itemDescNoItem;

	public GameObject itemDescTooBroken;

	public GameObject itemDescNotResearchable;

	public GameObject itemDescTooMany;

	public GameObject itemTakeBlueprint;

	public GameObject itemDescAlreadyResearched;

	public GameObject itemDescDefaultBlueprint;

	public RustText researchCostText;

	public ItemIcon scrapIcon;

	[NonSerialized]
	public bool wasResearching;

	public GameObject[] workbenchReqs;
}


using UnityEngine;
using UnityEngine.UI;

public class SeedInformationPanel : ItemInformationPanel
{
	public ItemTextValue maxHarvestsDisplay;

	public UIGenesDisplay GeneticsDisplay;

	public Text TextUnknownGenetics;

	public GameObject GeneticsGameObject;

	public ItemStatValue WaterResilience;

	public ItemStatValue GroundResilience;

	public ItemStatValue LightResilience;

	public ItemStatValue TemperatureResilience;
}


using System.Collections.Generic;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SelectedItem : SingletonComponent<SelectedItem>, IInventoryChanged
{
	public static readonly Phrase DropTitle = new Phrase("drop", "Drop");

	public static readonly Phrase DropDesc = new Phrase("drop_desc", "");

	public Image icon;

	public Image iconSplitter;

	public RustText title;

	public RustText description;

	public GameObject splitPanel;

	public GameObject itemProtection;

	public GameObject OwnershipContainer;

	public ItemOwnershipPanel OwnershipItem;

	private List<ItemOwnershipPanel> ownershipPanels = new List<ItemOwnershipPanel>();

	public GameObject menuOption;

	public GameObject optionsParent;

	public GameObject innerPanelContainer;
}


public class ShieldInformationPanel : ItemInformationPanel
{
	public ItemStatValue damageMitigationDisplay;
}


using UnityEngine;
using UnityEngine.UI;

public class SquareBorder : MonoBehaviour
{
	public float Size;

	public Color Color;

	public RectTransform Top;

	public RectTransform Bottom;

	public RectTransform Left;

	public RectTransform Right;

	public Image TopImage;

	public Image BottomImage;

	public Image LeftImage;

	public Image RightImage;

	private float _lastSize;

	private Color _lastColor;

	private void Update()
	{
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (_lastSize != Size)
		{
			Top.offsetMin = new Vector2(0f, 0f - Size);
			Bottom.offsetMax = new Vector2(0f, Size);
			Left.offsetMin = new Vector2(0f, Size);
			Left.offsetMax = new Vector2(Size, 0f - Size);
			Right.offsetMin = new Vector2(0f - Size, Size);
			Right.offsetMax = new Vector2(0f, 0f - Size);
			_lastSize = Size;
		}
		if (_lastColor != Color)
		{
			((Graphic)TopImage).color = Color;
			((Graphic)BottomImage).color = Color;
			((Graphic)LeftImage).color = Color;
			((Graphic)RightImage).color = Color;
			_lastColor = Color;
		}
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class UIBelt : SingletonComponent<UIBelt>
{
	public List<ItemIcon> ItemIcons;

	protected override void Awake()
	{
		ItemIcons = (from s in ((Component)this).GetComponentsInChildren<ItemIcon>()
			orderby s.slot
			select s).ToList();
	}

	public ItemIcon GetItemIconAtSlot(int slot)
	{
		if (slot < 0 || slot >= ItemIcons.Count)
		{
			return null;
		}
		return ItemIcons[slot];
	}
}


public class UIContacts : SingletonComponent<UIContacts>
{
	public static bool isOpen;

	public static float LastOpened;

	public ContactsPanel contactsPanel;
}


using UnityEngine;

public class UICrafting : SingletonComponent<UICrafting>
{
	public GameObject skinViewerPrefab;

	public static bool isOpen;

	public static float LastOpened;
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class UIIntegerEntry : MonoBehaviour
{
	public InputField textEntry;

	public event Action textChanged;

	public void OnAmountTextChanged()
	{
		this.textChanged();
	}

	public void SetAmount(int amount)
	{
		if (amount != GetIntAmount())
		{
			textEntry.text = amount.ToString();
		}
	}

	public int GetIntAmount()
	{
		int result = 0;
		int.TryParse(textEntry.text, out result);
		return result;
	}

	public void PlusMinus(int delta)
	{
		SetAmount(GetIntAmount() + delta);
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class UIInventory : SingletonComponent<UIInventory>
{
	public TextMeshProUGUI PlayerName;

	public static bool isOpen;

	public static float LastOpened;

	public VerticalLayoutGroup rightContents;

	public GameObject QuickCraft;

	public Transform InventoryIconContainer;

	public RustButton ChangelogPanelButton;

	public ContactsPanel contactsPanel;

	public GameObject backpackSlot;

	public UnderwearSkinPicker underwearSkinPicker;
}


public interface IContainerSounds
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using VLB;

public class UIMixingTableItem : MonoBehaviour
{
	public Image ItemIcon;

	public Tooltip ItemTooltip;

	public RustText TextItemNameAndQuantity;

	public UIMixingTableItemIngredient[] Ingredients;

	public bool Available;

	public Recipe Recipe;

	public void Init(Recipe r, UnityAction<Recipe> onClicked)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected O, but got Unknown
		Recipe = r;
		if ((Object)(object)Recipe == (Object)null)
		{
			return;
		}
		((UnityEvent)((Component)this).gameObject.GetOrAddComponent<Button>().onClick).AddListener((UnityAction)delegate
		{
			onClicked.Invoke(Recipe);
		});
		ItemIcon.sprite = Recipe.DisplayIcon;
		TextItemNameAndQuantity.SetText($"{Recipe.ProducedItemCount} x {Recipe.DisplayName}", true, false);
		ItemTooltip.Text = Recipe.DisplayDescription;
		for (int i = 0; i < Ingredients.Length; i++)
		{
			if (i >= Recipe.Ingredients.Length)
			{
				Ingredients[i].InitBlank();
			}
			else
			{
				Ingredients[i].Init(Recipe.Ingredients[i], Recipe.ProducedItem);
			}
		}
	}

	public void CleanUp()
	{
		Button component = ((Component)this).gameObject.GetComponent<Button>();
		if ((Object)(object)component != (Object)null)
		{
			((UnityEventBase)component.onClick).RemoveAllListeners();
		}
	}

	public void SetAvailable(bool flag)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Available = flag;
		((Graphic)TextItemNameAndQuantity).color = (Color)(flag ? new Color(0.78f, 0.78f, 0.78f) : Color.grey);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIMixingTableItemIngredient : MonoBehaviour
{
	public Image ItemIcon;

	public Text ItemCount;

	public Tooltip ToolTip;

	public void Init(Recipe.RecipeIngredient ingredient, ItemDefinition producedItem)
	{
		ItemIcon.sprite = ingredient.Ingredient.iconSprite;
		int ingredientCount = ingredient.GetIngredientCount(producedItem);
		ItemCount.text = ingredientCount.ToString();
		((Behaviour)ItemIcon).enabled = true;
		((Behaviour)ItemCount).enabled = true;
		ToolTip.Text = $"{ingredientCount} x {ingredient.Ingredient.displayName.translated}";
		((Behaviour)ToolTip).enabled = true;
	}

	public void InitBlank()
	{
		((Behaviour)ItemIcon).enabled = false;
		((Behaviour)ItemCount).enabled = false;
		((Behaviour)ToolTip).enabled = false;
	}
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(ItemIcon))]
public class VehicleEditingItemIcon : MonoBehaviour, IInventoryChanged
{
	[SerializeField]
	private Image foregroundImage;

	[SerializeField]
	private Image linkImage;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class VehicleEditingPanel : LootPanel
{
	[Serializable]
	private class CreateChassisEntry
	{
		public byte garageChassisIndex;

		public Button craftButton;

		public Text craftButtonText;

		public Text requirementsText;

		public ItemDefinition GetChassisItemDef(ModularCarGarage garage)
		{
			return garage.chassisBuildOptions[garageChassisIndex].itemDef;
		}
	}

	[SerializeField]
	[Range(0f, 1f)]
	private float disabledAlpha = 0.25f;

	[SerializeField]
	[Header("Edit Vehicle")]
	private CanvasGroup editGroup;

	[SerializeField]
	private GameObject moduleInternalItemsGroup;

	[SerializeField]
	private GameObject moduleInternalLiquidsGroup;

	[SerializeField]
	private GameObject destroyChassisGroup;

	[SerializeField]
	private Button itemTakeButton;

	[SerializeField]
	private Button liquidTakeButton;

	[SerializeField]
	private GameObject liquidHelp;

	[SerializeField]
	private GameObject liquidButton;

	[SerializeField]
	private Color gotColor;

	[SerializeField]
	private Color notGotColor;

	[SerializeField]
	private Text generalInfoText;

	[SerializeField]
	private Text generalWarningText;

	[SerializeField]
	private Image generalWarningImage;

	[SerializeField]
	private Text repairInfoText;

	[SerializeField]
	private Button repairButton;

	[SerializeField]
	private Text destroyChassisButtonText;

	[SerializeField]
	private Text destroyChassisCountdown;

	[SerializeField]
	private Phrase phraseEditingInfo;

	[SerializeField]
	private Phrase phraseNoOccupant;

	[SerializeField]
	private Phrase phraseBadOccupant;

	[SerializeField]
	private Phrase phrasePlayerObstructing;

	[SerializeField]
	private Phrase phraseNotDriveable;

	[SerializeField]
	private Phrase phraseNotRepairable;

	[SerializeField]
	private Phrase phraseRepairNotNeeded;

	[SerializeField]
	private Phrase phraseRepairSelectInfo;

	[SerializeField]
	private Phrase phraseRepairEnactInfo;

	[SerializeField]
	private Phrase phraseHasLock;

	[SerializeField]
	private Phrase phraseHasNoLock;

	[SerializeField]
	private Phrase phraseAddLock;

	[SerializeField]
	private Phrase phraseAddLockButton;

	[SerializeField]
	private Phrase phraseChangeLockCodeButton;

	[SerializeField]
	private Text carLockInfoText;

	[SerializeField]
	private RustText carLockButtonText;

	[SerializeField]
	private Button actionLockButton;

	[SerializeField]
	private Button removeLockButton;

	[SerializeField]
	private GameObjectRef keyEnterDialog;

	[SerializeField]
	private Phrase phraseEmptyStorage;

	[Header("Create Chassis")]
	[SerializeField]
	private CreateChassisEntry[] chassisOptions;
}


using System;
using UnityEngine.UI;

[Serializable]
private class CreateChassisEntry
{
	public byte garageChassisIndex;

	public Button craftButton;

	public Text craftButtonText;

	public Text requirementsText;

	public ItemDefinition GetChassisItemDef(ModularCarGarage garage)
	{
		return garage.chassisBuildOptions[garageChassisIndex].itemDef;
	}
}


public class VehicleModuleInformationPanel : ItemInformationPanel
{
	public interface IVehicleModuleInfo
	{
		int SocketsTaken { get; }
	}

	public ItemStatValue socketsDisplay;

	public ItemStatValue hpDisplay;
}


public interface IVehicleModuleInfo
{
	int SocketsTaken { get; }
}


using UnityEngine;
using UnityEngine.UI;

public class VirtualItemIcon : MonoBehaviour
{
	public ItemDefinition itemDef;

	public int itemAmount;

	public bool asBlueprint;

	public Image iconImage;

	public Image bpUnderlay;

	public Text amountText;

	public Text hoverText;

	public CanvasGroup iconContents;

	public Tooltip ToolTip;

	public CanvasGroup conditionObject;

	public Image conditionFill;

	public Image maxConditionFill;

	public Image cornerIcon;

	[Header("Slots")]
	public GameObject slots;

	public Image[] slotImages;

	public static Phrase attachmentsPhrase = new Phrase("vendor_attachments", "Attachments");

	public static Phrase ammoPhrase = new Phrase("vendor_ammo", "Ammo");
}


using UnityEngine;

[RequireComponent(typeof(ItemIcon))]
public class WearableFeedbackItemIcon : FacepunchBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class WorkbenchPanel : LootPanel, IInventoryChanged
{
	public GameObject openTechTreeButton;

	public Text timerText;

	public Text costText;

	public GameObject expermentCostParent;

	public GameObject controlsParent;

	public GameObject allUnlockedNotification;

	public GameObject informationParent;

	public GameObject cycleIcon;

	public GameObjectRef techTreeDialog;
}


using UnityEngine;

public class InventoryUI : MonoBehaviour
{
	public GameObject ContactsButton;

	public GameObject ClanButton;
}


using UnityEngine;
using UnityEngine.UI;

public class IOEntityUISlotEntry : MonoBehaviour
{
	public RawImage icon;

	public Text leftText;

	public Text rightText;
}


using System;
using System.Globalization;
using System.Linq;
using UnityEngine;

public static class ItemSearchUtils
{
	public static IOrderedEnumerable<ItemDefinition> SearchForItems(string searchString, Func<ItemDefinition, bool> validFilter = null)
	{
		if (searchString == "")
		{
			searchString = "BALLS BALLS BALLS";
		}
		return from y in ItemManager.itemList.Where((ItemDefinition x) => IsValidSearchResult(searchString, x, validFilter == null) && (validFilter == null || validFilter(x))).Take(60)
			orderby ScoreSearchResult(searchString, y)
			select y;
	}

	public static bool IsValidSearchResult(string search, ItemDefinition target, bool checkItemIsValid)
	{
		if (checkItemIsValid && (!((Object)(object)target.isRedirectOf != (Object)null) || target.redirectVendingBehaviour != ItemDefinition.RedirectVendingBehaviour.ListAsUniqueItem) && target.Hidden())
		{
			return false;
		}
		if (string.IsNullOrEmpty(target.displayName.translated) || string.IsNullOrEmpty(target.displayDescription.translated))
		{
			return false;
		}
		if (!StringEx.Contains(target.shortname, search, CompareOptions.IgnoreCase) && !StringEx.Contains(target.displayName.translated, search, CompareOptions.IgnoreCase) && !StringEx.Contains(target.displayDescription.translated, search, CompareOptions.IgnoreCase) && CultureInfo.CurrentCulture.CompareInfo.IndexOf(target.displayName.translated, search, CompareOptions.IgnoreCase | CompareOptions.IgnoreNonSpace) < 0)
		{
			return CultureInfo.CurrentCulture.CompareInfo.IndexOf(target.displayDescription.translated, search, CompareOptions.IgnoreCase | CompareOptions.IgnoreNonSpace) >= 0;
		}
		return true;
	}

	private static float ScoreSearchResult(string search, ItemDefinition target)
	{
		float num = 0f;
		if (target.shortname.Equals(search, StringComparison.CurrentCultureIgnoreCase) || target.displayName.translated.Equals(search, StringComparison.CurrentCultureIgnoreCase))
		{
			num -= (float)(500 - search.Length);
		}
		float num2 = (StringEx.Contains(target.shortname, search, CompareOptions.IgnoreCase) ? ((float)search.Length / (float)target.shortname.Length) : 0f);
		float num3 = (StringEx.Contains(target.displayName.translated, search, CompareOptions.IgnoreCase) ? ((float)search.Length / (float)target.displayName.translated.Length) : 0f);
		float num4 = Mathf.Max(num2, num3);
		num -= 50f * num4;
		if (StringEx.Contains(target.displayDescription.translated, search, CompareOptions.IgnoreCase))
		{
			num -= (float)search.Length;
		}
		return num;
	}
}


using System.Collections.Generic;
using System.Linq;
using Rust.UI.MainMenu;
using UnityEngine;

public class KeybindCategory : MonoBehaviour
{
	private List<UI_SettingsTweakKeyBind> keybinds = new List<UI_SettingsTweakKeyBind>();

	private void Awake()
	{
		for (int i = ((Component)this).transform.GetSiblingIndex() + 1; i < ((Component)this).transform.parent.childCount; i++)
		{
			Transform child = ((Component)this).transform.parent.GetChild(i);
			if (!((Object)(object)((Component)child).GetComponent<KeybindCategory>() != (Object)null))
			{
				UI_SettingsTweakKeyBind component = ((Component)child).GetComponent<UI_SettingsTweakKeyBind>();
				if (!((Object)(object)component == (Object)null))
				{
					keybinds.Add(component);
				}
				continue;
			}
			break;
		}
	}

	public void UpdateVisibility()
	{
		((Component)this).gameObject.SetActive(keybinds.Any((UI_SettingsTweakKeyBind x) => ((Behaviour)x).isActiveAndEnabled));
	}
}


using TMPro;
using UnityEngine;

public class KeybindSearch : MonoBehaviour
{
	public GameObject rootPanel;

	public TMP_InputField input;
}


using System;
using System.Collections.Generic;
using System.Linq;
using ProtoBuf;
using Rust;
using UnityEngine;
using UnityEngine.UI;

public class LifeInfographic : SingletonComponent<LifeInfographic>, IPrefabPreProcess
{
	[Serializable]
	public struct DamageSetting
	{
		public DamageType ForType;

		public string Display;

		public Sprite DamageSprite;
	}

	[Serializable]
	public struct EntityNameToItemDefinition
	{
		public string Name;

		public ItemDefinition ItemDefinition;
	}

	[NonSerialized]
	public PlayerLifeStory life;

	public GameObject container;

	public RawImage AttackerAvatarImage;

	public Image DamageSourceImage;

	public LifeInfographicStat[] Stats;

	public Animator[] AllAnimators;

	public GameObject WeaponRoot;

	public GameObject DistanceRoot;

	public GameObject DistanceDivider;

	public Image WeaponImage;

	public DamageSetting[] DamageDisplays;

	public Texture2D defaultAvatarTexture;

	public bool ShowDebugData;

	[Tooltip("Automatically filled in by prefab preprocess")]
	[ReadOnly]
	public EntityNameToItemDefinition[] EntityNameToItemDefinitions;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (bundling || !FileSystem.IsBundled)
		{
			EntityNameToItemDefinitions = BuildEntityNameToItemDefinitionTable();
		}
	}

	private static EntityNameToItemDefinition[] BuildEntityNameToItemDefinitionTable()
	{
		List<ItemDefinition> list = GetItemList();
		Dictionary<string, ItemDefinition> dictionary = new Dictionary<string, ItemDefinition>(StringComparer.OrdinalIgnoreCase);
		ItemModEntity itemModEntity = default(ItemModEntity);
		ThrownWeapon thrownWeapon = default(ThrownWeapon);
		ItemModDeployable itemModDeployable = default(ItemModDeployable);
		foreach (ItemDefinition item in list)
		{
			dictionary.TryAdd(item.shortname, item);
			try
			{
				if (((Component)item).TryGetComponent<ItemModEntity>(ref itemModEntity) && itemModEntity.entityPrefab.isValid)
				{
					GameObject val = itemModEntity.entityPrefab.Get();
					dictionary.TryAdd(((Object)val).name, item);
					if (val.TryGetComponent<ThrownWeapon>(ref thrownWeapon) && thrownWeapon.prefabToThrow.isValid)
					{
						dictionary.TryAdd(((Object)thrownWeapon.prefabToThrow.Get()).name, item);
					}
				}
				if (((Component)item).TryGetComponent<ItemModDeployable>(ref itemModDeployable) && itemModDeployable.entityPrefab != null && itemModDeployable.entityPrefab.isValid)
				{
					dictionary.TryAdd(((Object)itemModDeployable.entityPrefab.Get()).name, item);
				}
				ItemModProjectile[] components = ((Component)item).GetComponents<ItemModProjectile>();
				foreach (ItemModProjectile itemModProjectile in components)
				{
					if (itemModProjectile.projectileObject != null && itemModProjectile.projectileObject.isValid)
					{
						dictionary.TryAdd(((Object)itemModProjectile.projectileObject.Get()).name, item);
					}
				}
			}
			catch (Exception ex)
			{
				Debug.LogError((object)("Invalid entity found in LifeInfographic.PreProcess - likely a corrupt prefab: " + item.shortname));
				Debug.LogError((object)ex);
			}
		}
		return dictionary.Select(delegate(KeyValuePair<string, ItemDefinition> kvp)
		{
			EntityNameToItemDefinition result = default(EntityNameToItemDefinition);
			result.Name = kvp.Key;
			result.ItemDefinition = kvp.Value;
			return result;
		}).OrderBy<EntityNameToItemDefinition, string>((EntityNameToItemDefinition x) => x.Name, StringComparer.OrdinalIgnoreCase).ToArray();
		static List<ItemDefinition> GetItemList()
		{
			return ItemManager.itemList;
		}
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public struct DamageSetting
{
	public DamageType ForType;

	public string Display;

	public Sprite DamageSprite;
}


using System;

[Serializable]
public struct EntityNameToItemDefinition
{
	public string Name;

	public ItemDefinition ItemDefinition;
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class LifeInfographicStat : MonoBehaviour
{
	public enum DataType
	{
		None,
		AliveTime_Short,
		SleepingTime_Short,
		KillerName,
		KillerWeapon,
		AliveTime_Long,
		KillerDistance,
		GenericStat,
		DistanceTravelledWalk,
		DistanceTravelledRun,
		DamageTaken,
		DamageHealed,
		WeaponInfo,
		SecondsWilderness,
		SecondsSwimming,
		SecondsInBase,
		SecondsInMonument,
		SecondsFlying,
		SecondsBoating,
		PlayersKilled,
		ScientistsKilled,
		AnimalsKilled,
		SecondsDriving
	}

	public enum WeaponInfoType
	{
		TotalShots,
		ShotsHit,
		ShotsMissed,
		AccuracyPercentage
	}

	public DataType dataSource;

	[Header("Generic Stats")]
	public string genericStatKey;

	[Header("Weapon Info")]
	public string targetWeaponName;

	public WeaponInfoType weaponInfoType;

	public TextMeshProUGUI targetText;

	public Image StatImage;
}


public enum DataType
{
	None,
	AliveTime_Short,
	SleepingTime_Short,
	KillerName,
	KillerWeapon,
	AliveTime_Long,
	KillerDistance,
	GenericStat,
	DistanceTravelledWalk,
	DistanceTravelledRun,
	DamageTaken,
	DamageHealed,
	WeaponInfo,
	SecondsWilderness,
	SecondsSwimming,
	SecondsInBase,
	SecondsInMonument,
	SecondsFlying,
	SecondsBoating,
	PlayersKilled,
	ScientistsKilled,
	AnimalsKilled,
	SecondsDriving
}


public enum WeaponInfoType
{
	TotalShots,
	ShotsHit,
	ShotsMissed,
	AccuracyPercentage
}


using System;
using Rust.UI;

public class LifeInfographicStatDynamicRow : LifeInfographicStat
{
	public RustText StatName;

	public void SetStatName(Phrase phrase)
	{
		StatName.SetPhrase(phrase, Array.Empty<object>());
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LifeInfographicStatWeapon : MonoBehaviour
{
	public RustText WeaponName;

	public RustText ShotsFired;

	public RustText ShotsHit;

	public RustText ShotsPercent;

	public Image WeaponIcon;
}


using UnityEngine;

public class LookAtFarmableAnimal : MonoBehaviour
{
	public CanvasGroup Group;

	public ChickenCoopStatusWidget Status;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LookatHealth : MonoBehaviour
{
	public interface IHealthBarName
	{
	}

	public static bool Enabled = true;

	public GameObject container;

	public RustText textHealth;

	public RustText textStability;

	public Image healthBar;

	public Image healthBarBG;

	public Color barBGColorNormal;

	public Color barBGColorUnstable;
}


public interface IHealthBarName
{
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LookAtIOEnt : MonoBehaviour
{
	[Serializable]
	public struct HandleSet
	{
		public IOEntity.IOType ForIO;

		public GameObjectRef handlePrefab;

		public GameObjectRef handleOccupiedPrefab;

		public GameObjectRef selectedHandlePrefab;

		public GameObjectRef pluggedHandlePrefab;
	}

	public RustText objectTitle;

	public RectTransform slotToolTip;

	public Text slotTitle;

	public RustText slotConnectionText;

	public RustText slotPowerText;

	public RustText powerText;

	public RustText passthroughText;

	public RustText chargeLeftText;

	public RustText capacityText;

	public RustText maxOutputText;

	public RustText activeOutputText;

	public RustText turretInterferenceText;

	public RustText creativeModeText;

	public IOEntityUISlotEntry[] inputEntries;

	public IOEntityUISlotEntry[] outputEntries;

	public Color NoPowerColor;

	public GameObject ShortCircuitWarning;

	public GameObject GravityWarning;

	public GameObject DistanceWarning;

	public GameObject LineOfSightWarning;

	public GameObject TooManyInputsWarning;

	public GameObject TooManyOutputsWarning;

	public GameObject BuildPrivilegeWarning;

	public GameObject InfinitePowerText;

	public CanvasGroup group;

	public HandleSet[] handleSets;

	public RectTransform clearNotification;

	public CanvasGroup wireInfoGroup;

	public RustText wireLengthText;

	public RustText wireClipsText;

	public RustText errorReasonTextTooFar;

	public RustText errorReasonTextNoSurface;

	public RawImage ConnectionTypeIcon;

	public Texture ElectricSprite;

	public Texture FluidSprite;

	public Texture IndustrialSprite;

	public GameObject IndustrialIcon;
}


using System;

[Serializable]
public struct HandleSet
{
	public IOEntity.IOType ForIO;

	public GameObjectRef handlePrefab;

	public GameObjectRef handleOccupiedPrefab;

	public GameObjectRef selectedHandlePrefab;

	public GameObjectRef pluggedHandlePrefab;
}


using UnityEngine;
using UnityEngine.UI;

public class LookAtPlant : MonoBehaviour
{
	public CanvasGroup group;

	public UIGenesDisplay GeneDisplay;

	public UIGenesDisplay GeneDisplay2;

	public Text TextPlant;

	public Image PlantIcon;

	public InfoBar Age;

	public InfoBar Stage;

	public InfoBar WaterIntake;

	public Text TextYieldLabel;

	public InfoBar Yield;

	public InfoBar Health;

	public InfoBar Light;

	public InfoBar WaterSaturation;

	public InfoBar Ground;

	public InfoBar Temperature;

	public InfoBar Overall;
}


using UnityEngine;
using UnityEngine.UI;

public class LookAtPlanter : MonoBehaviour
{
	public CanvasGroup group;

	public Text waterText;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class LookAtSleepingBag : MonoBehaviour
{
	public FlexTransition Transition;

	public RustText Text;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class LookatTooltip : MonoBehaviour
{
	public static bool Enabled = true;

	[NonSerialized]
	public BaseEntity currentlyLookingAt;

	public RustText textLabel;

	public RustText moreOptionsLabel;

	public Image icon;

	public Phrase moreOptionsDefaultPhrase;

	public CanvasGroup canvasGroup;

	public CanvasGroup infoGroup;

	public CanvasGroup minimiseGroup;

	[ClientVar(Saved = true, Help = "Changes the interaction crosshair visuals (0 = default, 1 = no texts, 2 = no texts and no icon)")]
	public static int crosshairMode = 0;
}


using UnityEngine;
using UnityEngine.UI;

public class LookAtWeaponRack : MonoBehaviour
{
	public CanvasGroup weaponInfoGroup;

	public CanvasGroup rotationGroup;

	public Text TextWeapon;

	public Image IconWeapon;

	public Image IconAmmo;

	public RawImage IconHorizontal;

	public RawImage IconVertical;

	public InfoBar AmmoBar;

	public InfoBar ConditionBar;

	public Color ValidRotationColor;

	public Color InvalidRotationColor;
}


using UnityEngine;
using UnityEngine.UI;

public class AboutYou : BaseMonoBehaviour
{
	public Text username;

	public RawImage avatar;

	public Text subtitle;

	public GameObject PremiumIcon;
}


using Rust.UI;
using UnityEngine;

public class ConnectionScreen : SingletonComponent<ConnectionScreen>
{
	public RustText statusText;

	public GameObject disconnectButton;

	public GameObject retryButton;

	public ServerBrowserInfo browserInfo;
}


using Rust.UI;
using UnityEngine;

public class UI_DemoItem : RustButton
{
	[HideInInspector]
	public UI_DemosMenuWindow demos;

	public int itemId;

	public RustText nameText;

	public RustText dateText;

	public RustText lengthText;
}


using Rust.UI.MainMenu;
using UnityEngine;

public class UI_DemosMenuWindow : UI_Window
{
	[SerializeField]
	private FlexVirtualScroll virtualScroll;

	[SerializeField]
	private GameObject deleteButton;

	[SerializeField]
	private GameObject playButton;
}


using UnityEngine;

public class DeveloperUI : MonoBehaviour
{
}


using UnityEngine;

public class DisableWithMainMenu : MonoBehaviour
{
}


using UnityEngine;

public class LanguageSelection : MonoBehaviour
{
	public GameObject buttonContainer;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class LoadingScreen : SingletonComponent<LoadingScreen>
{
	private bool _isOpen;

	[Header("Loading Screen References - UI")]
	public CanvasGroup panel;

	public CanvasGroup blackout;

	public NeedsCursor needsCursor;

	public TextMeshProUGUI title;

	public TextMeshProUGUI subtitle;

	public RawImage backgroundImage;

	public Texture2D defaultBackground;

	public GameObject infoHeader;

	public GameObject demoBlock;

	public GameObject serverBlock;

	public RustButton cancelButton;

	[Header("Loading Screen References - Server Info")]
	public RustText serverName;

	public RustText serverPlayers;

	public RustText serverMode;

	public RustText serverMap;

	public RustText serverWiped;

	public HttpImage serverLogoImage;

	public ServerBrowserTagList serverTags;

	[Header("Loading Screen References - Demo Info")]
	public RustText demoName;

	public RustText demoLength;

	public RustText demoDate;

	public RustText demoMap;

	[Header("Loading Screen References - Tips and Warnings")]
	public MenuTip menuTip;

	public GameObject performanceWarning;

	public GameObject pingWarning;

	public RustText pingWarningText;

	[Header("Loading Screen References - Audio")]
	public AudioSource music;

	[Header("Loading Screen References - Settings")]
	[Tooltip("Ping must be at least this many ms higher than the server browser ping")]
	public int minPingDiffToShowWarning = 50;

	[Tooltip("Ping must be this many times higher than the server browser ping")]
	public float pingDiffFactorToShowWarning = 2f;

	[Tooltip("Number of ping samples required before showing the warning")]
	public int requiredPingSampleCount = 10;

	public static Phrase pingWarningPhrase = new Phrase("loading.ping-warning", "<color=#FFF><size=20>PING WARNING</size></color>\nThis server's ping on the server browser ({0} ms) is much lower than the ping you are getting after connecting to the server ({1} ms). This could mean that this server is located far away and you will have a less than ideal playing experience while on this server.");

	public static Phrase vanillaPhrase = new Phrase("loading.mode.vanilla", "vanilla");

	public static bool isOpen
	{
		get
		{
			if ((Object)(object)SingletonComponent<LoadingScreen>.Instance != (Object)null)
			{
				return SingletonComponent<LoadingScreen>.Instance._isOpen;
			}
			return false;
		}
	}

	public static string Text { get; private set; }

	public static void Update(string strType)
	{
	}

	public static void Update(string strType, string strSubtitle)
	{
	}
}


using System;
using System.Collections.Generic;
using Development.Attributes;
using Rust.UI;
using UnityEngine;

[ResetStaticFields]
public class MainMenuSystem : SingletonComponent<MainMenuSystem>
{
	public static bool isOpen = true;

	public static Action OnOpenStateChanged;

	public RustButton SessionButton;

	public GameObject SessionPanel;

	public GameObject NewsStoriesAlert;

	public GameObject ItemStoreAlert;

	public GameObject CompanionAlert;

	public GameObject DemoBrowser;

	public GameObject DemoBrowserButton;

	public GameObject SuicideButton;

	public GameObject EndDemoButton;

	public List<GameObject> ReturnToOptionsPanels;

	public RustButton OptionsButton;

	public GameObject ReflexModeOption;

	public GameObject ReflexLatencyMarkerOption;

	[SerializeField]
	private GameObject QuitConfirmation;

	public GameObject QuitTutorialOption;

	[SerializeField]
	private GameObject Connection;

	[SerializeField]
	private UISafeZoneWarning safeZoneWarning;
}


using UnityEngine;

public class MenuBackgroundOverride : MonoBehaviour
{
	public Texture2D Background;

	public Color Tint = Color.white;
}


public class MenuBackgroundPanel : SingletonComponent<MenuBackgroundPanel>
{
	public CoverImage Image;

	public float FadeDuration = 0.15f;
}


using System;
using System.Collections;
using System.IO;
using System.Linq;
using Rust;
using UnityEngine;
using UnityEngine.Video;

public class MenuBackgroundVideo : SingletonComponent<MenuBackgroundVideo>
{
	[ClientVar]
	public static bool RestrictMP4 = true;

	private int index;

	private bool errored;

	private string[] mp4Videos;

	private string[] webmVideos;

	private bool forceWebmOnly;

	private VideoPlayer _videoPlayer;

	protected override void Awake()
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Invalid comparison between Unknown and I4
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Invalid comparison between Unknown and I4
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Expected O, but got Unknown
		((SingletonComponent)this).Awake();
		if (RestrictMP4)
		{
			forceWebmOnly = true;
		}
		_videoPlayer = ((Component)this).GetComponent<VideoPlayer>();
		_videoPlayer.source = (VideoSource)1;
		if ((int)Application.platform == 13 || (int)Application.platform == 16)
		{
			forceWebmOnly = true;
		}
		_videoPlayer.errorReceived += new ErrorEventHandler(OnVideoError);
		LoadVideoList();
		NextVideo();
	}

	private void OnVideoError(VideoPlayer source, string message)
	{
		errored = true;
		forceWebmOnly = true;
		_videoPlayer.Stop();
		NextVideo();
	}

	public void LoadVideoList()
	{
		string path = Path.Combine(Application.streamingAssetsPath, "MenuVideo");
		string path2 = Path.Combine(path, "mp4");
		string path3 = Path.Combine(path, "webm");
		if (Directory.Exists(path2))
		{
			mp4Videos = (from x in Directory.EnumerateFiles(path2, "*.mp4")
				orderby Guid.NewGuid()
				select x).ToArray();
		}
		else
		{
			mp4Videos = Array.Empty<string>();
		}
		if (Directory.Exists(path3))
		{
			webmVideos = (from x in Directory.EnumerateFiles(path3, "*.webm")
				orderby Guid.NewGuid()
				select x).ToArray();
		}
		else
		{
			webmVideos = Array.Empty<string>();
		}
	}

	public void Update()
	{
		if (Input.GetKeyDown((KeyCode)258))
		{
			LoadVideoList();
		}
		if (Input.GetKeyDown((KeyCode)257))
		{
			NextVideo();
		}
	}

	private void NextVideo()
	{
		if (Application.isQuitting)
		{
			return;
		}
		errored = false;
		string[] array = (forceWebmOnly ? webmVideos : mp4Videos);
		if (array.Length == 0)
		{
			Debug.LogWarning((object)"[MenuBackgroundVideo] No available videos to play.");
			return;
		}
		string text = array[index++ % array.Length];
		if (!forceWebmOnly && Global.LaunchCountThisVersion <= 3)
		{
			string text2 = mp4Videos.FirstOrDefault((string x) => x.EndsWith("whatsnew.mp4", StringComparison.OrdinalIgnoreCase));
			if (!string.IsNullOrEmpty(text2))
			{
				text = text2;
			}
		}
		_videoPlayer.url = "file://" + text;
		_videoPlayer.Play();
	}

	internal IEnumerator ReadyVideo()
	{
		if (!errored)
		{
			if ((Object)(object)_videoPlayer == (Object)null)
			{
				_videoPlayer = ((Component)this).GetComponent<VideoPlayer>();
			}
			NextVideo();
			while (!_videoPlayer.isPrepared && !errored)
			{
				yield return null;
			}
		}
	}

	[ClientVar]
	public static void ForceNextVideo()
	{
		MenuBackgroundVideo[] array = Object.FindObjectsOfType<MenuBackgroundVideo>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].NextVideo();
		}
	}

	[ClientVar]
	public static void EmulateError()
	{
		Object.FindObjectOfType<MenuBackgroundVideo>().OnVideoError(null, null);
	}
}


using UnityEngine;

public class MenuServerPanel : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;

public class NewsParagraph : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public RustText Text;

	public List<string> Links;

	public void OnPointerClick(PointerEventData eventData)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Text == (Object)null || Links == null || (int)eventData.button != 0)
		{
			return;
		}
		int num = TMP_TextUtilities.FindIntersectingLink((TMP_Text)(object)Text, Vector2.op_Implicit(eventData.position), eventData.pressEventCamera);
		if (num < 0 || num >= ((TMP_Text)Text).textInfo.linkCount)
		{
			return;
		}
		TMP_LinkInfo val = ((TMP_Text)Text).textInfo.linkInfo[num];
		if (int.TryParse(((TMP_LinkInfo)(ref val)).GetLinkID(), out var result) && result >= 0 && result < Links.Count)
		{
			string text = Links[result];
			if (text.StartsWith("http", StringComparison.InvariantCultureIgnoreCase))
			{
				Application.OpenURL(text);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;
using Facepunch;
using Facepunch.Extend;
using Facepunch.Flexbox;
using Facepunch.Math;
using Facepunch.Models;
using Facepunch.Rust;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class NewsSource : MonoBehaviour
{
	private struct ParagraphBuilder
	{
		public StringBuilder StringBuilder;

		public List<string> Links;

		public static ParagraphBuilder New()
		{
			ParagraphBuilder result = default(ParagraphBuilder);
			result.StringBuilder = new StringBuilder();
			result.Links = new List<string>();
			return result;
		}

		public void AppendLine()
		{
			StringBuilder.AppendLine();
		}

		public void Append(string text)
		{
			StringBuilder.Append(text);
		}
	}

	private static readonly Regex BbcodeParse = new Regex("([^\\[]*)(?:\\[(\\w+)(?:=([^\\]]+))?\\](.*?)\\[\\/\\2\\])?", RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Singleline);

	public RustText title;

	public RustText date;

	public RustText authorName;

	public HttpImage coverImage;

	public RectTransform container;

	public Button button;

	public FlexElement layoutRoot;

	public RustText paragraphTemplate;

	public HttpImage imageTemplate;

	public HttpImage youtubeTemplate;

	private static readonly string[] BulletSeparators = new string[1] { "[*]" };

	public void Awake()
	{
		EventRecord eventRecord = EventRecord.New("news", isServer: false);
		eventRecord.AddField("action", "view");
		eventRecord.Submit();
	}

	public void OnEnable()
	{
		if (SteamNewsSource.Stories != null && SteamNewsSource.Stories.Length != 0)
		{
			SetStory(SteamNewsSource.Stories[0]);
		}
	}

	public void SetStory(SteamNewsSource.Story story)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Expected O, but got Unknown
		PlayerPrefs.SetInt("lastNewsDate", story.date);
		TransformEx.DestroyAllChildren((Transform)(object)container, false);
		((TMP_Text)title).text = story.name;
		((TMP_Text)authorName).text = "by " + story.author;
		string text = NumberExtensions.FormatSecondsLong((long)(Epoch.Current - story.date));
		((TMP_Text)date).text = "Posted " + text + " ago";
		((UnityEventBase)button.onClick).RemoveAllListeners();
		((UnityEvent)button.onClick).AddListener((UnityAction)delegate
		{
			string text2 = GetBlogPost()?.Url ?? story.url;
			Debug.Log((object)("Opening URL: " + text2));
			Application.OpenURL(text2);
		});
		string firstImage = GetBlogPost()?.HeaderImage;
		ParagraphBuilder currentParagraph = ParagraphBuilder.New();
		ParseBbcode(ref currentParagraph, story.text, ref firstImage);
		AppendParagraph(ref currentParagraph);
		if (firstImage != null)
		{
			coverImage.Load(firstImage);
		}
		BlogInfo GetBlogPost()
		{
			Manifest manifest = Application.Manifest;
			if (manifest == null)
			{
				return null;
			}
			NewsInfo news = manifest.News;
			if (news == null)
			{
				return null;
			}
			BlogInfo[] blogs = news.Blogs;
			if (blogs == null)
			{
				return null;
			}
			return List.FindWith<BlogInfo, string>((IReadOnlyCollection<BlogInfo>)(object)blogs, (Func<BlogInfo, string>)((BlogInfo b) => b.Title), story.name, (IEqualityComparer<string>)StringComparer.InvariantCultureIgnoreCase);
		}
	}

	private void ParseBbcode(ref ParagraphBuilder currentParagraph, string bbcode, ref string firstImage, int depth = 0)
	{
		foreach (Match item in BbcodeParse.Matches(bbcode))
		{
			string value = item.Groups[1].Value;
			string value2 = item.Groups[2].Value;
			string value3 = item.Groups[3].Value;
			string value4 = item.Groups[4].Value;
			currentParagraph.Append(value);
			switch (value2.ToLowerInvariant())
			{
			case "previewyoutube":
				if (depth == 0)
				{
					string[] array2 = value3.Split(';');
					AppendYouTube(ref currentParagraph, array2[0]);
				}
				break;
			case "h1":
			case "h2":
				currentParagraph.Append("<size=200%>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</size>");
				break;
			case "h3":
				currentParagraph.Append("<size=175%>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</size>");
				break;
			case "h4":
				currentParagraph.Append("<size=150%>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</size>");
				break;
			case "b":
				currentParagraph.Append("<b>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</b>");
				break;
			case "u":
				currentParagraph.Append("<u>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</u>");
				break;
			case "i":
				currentParagraph.Append("<i>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</i>");
				break;
			case "strike":
				currentParagraph.Append("<s>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</s>");
				break;
			case "noparse":
				currentParagraph.Append(value4);
				break;
			case "url":
			{
				if (value4.Contains("[img]", StringComparison.InvariantCultureIgnoreCase))
				{
					ParseBbcode(ref currentParagraph, value4, ref firstImage, depth);
					break;
				}
				int count = currentParagraph.Links.Count;
				currentParagraph.Links.Add(value3);
				currentParagraph.Append($"<link={count}><u>");
				ParseBbcode(ref currentParagraph, value4, ref firstImage, depth + 1);
				currentParagraph.Append("</u></link>");
				break;
			}
			case "list":
			{
				currentParagraph.AppendLine();
				string[] array = GetBulletPoints(value4);
				foreach (string text3 in array)
				{
					if (!string.IsNullOrWhiteSpace(text3))
					{
						currentParagraph.Append("\t• ");
						ParseBbcode(ref currentParagraph, text3.Trim(), ref firstImage, depth + 1);
						currentParagraph.AppendLine();
					}
				}
				break;
			}
			case "olist":
			{
				currentParagraph.AppendLine();
				string[] bulletPoints = GetBulletPoints(value4);
				int num = 1;
				string[] array = bulletPoints;
				foreach (string text2 in array)
				{
					if (!string.IsNullOrWhiteSpace(text2))
					{
						currentParagraph.Append($"\t{num++} ");
						ParseBbcode(ref currentParagraph, text2.Trim(), ref firstImage, depth + 1);
						currentParagraph.AppendLine();
					}
				}
				break;
			}
			case "img":
				if (depth == 0)
				{
					string text = value4.Trim();
					if (firstImage == null)
					{
						firstImage = text;
					}
					AppendImage(ref currentParagraph, text);
				}
				break;
			}
		}
	}

	private static string[] GetBulletPoints(string listContent)
	{
		return listContent?.Split(BulletSeparators, StringSplitOptions.RemoveEmptyEntries) ?? Array.Empty<string>();
	}

	private void AppendParagraph(ref ParagraphBuilder currentParagraph)
	{
		if (currentParagraph.StringBuilder.Length > 0)
		{
			string text = currentParagraph.StringBuilder.ToString();
			RustText obj = Object.Instantiate<RustText>(paragraphTemplate, (Transform)(object)container);
			ComponentExtensions.SetActive<RustText>(obj, true);
			obj.SetText(text);
			NewsParagraph newsParagraph = default(NewsParagraph);
			if (((Component)obj).TryGetComponent<NewsParagraph>(ref newsParagraph))
			{
				newsParagraph.Links = currentParagraph.Links;
			}
		}
		currentParagraph = ParagraphBuilder.New();
	}

	private void AppendImage(ref ParagraphBuilder currentParagraph, string url)
	{
		AppendParagraph(ref currentParagraph);
		HttpImage obj = Object.Instantiate<HttpImage>(imageTemplate, (Transform)(object)container);
		ComponentExtensions.SetActive<HttpImage>(obj, true);
		obj.Load(url);
	}

	private void AppendYouTube(ref ParagraphBuilder currentParagraph, string videoId)
	{
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Expected O, but got Unknown
		AppendParagraph(ref currentParagraph);
		HttpImage obj = Object.Instantiate<HttpImage>(youtubeTemplate, (Transform)(object)container);
		ComponentExtensions.SetActive<HttpImage>(obj, true);
		obj.Load("https://img.youtube.com/vi/" + videoId + "/maxresdefault.jpg");
		RustButton component = ((Component)obj).GetComponent<RustButton>();
		if ((Object)(object)component != (Object)null)
		{
			string videoUrl = "https://www.youtube.com/watch?v=" + videoId;
			component.OnReleased.AddListener((UnityAction)delegate
			{
				Debug.Log((object)("Opening URL: " + videoUrl));
				Application.OpenURL(videoUrl);
			});
		}
	}
}


using System.Collections.Generic;
using System.Text;

private struct ParagraphBuilder
{
	public StringBuilder StringBuilder;

	public List<string> Links;

	public static ParagraphBuilder New()
	{
		ParagraphBuilder result = default(ParagraphBuilder);
		result.StringBuilder = new StringBuilder();
		result.Links = new List<string>();
		return result;
	}

	public void AppendLine()
	{
		StringBuilder.AppendLine();
	}

	public void Append(string text)
	{
		StringBuilder.Append(text);
	}
}


using System.Collections;
using System.Collections.Generic;
using JSON;
using UnityEngine;

public static class SteamNewsSource
{
	public struct Story
	{
		public string name;

		public string url;

		public int date;

		public string text;

		public string author;
	}

	public static Story[] Stories;

	public static IEnumerator GetStories()
	{
		WWW www = new WWW("https://api.steampowered.com/ISteamNews/GetNewsForApp/v0002/?appid=252490&count=8&format=json&feeds=steam_community_announcements");
		yield return www;
		Object val = Object.Parse(www.text);
		www.Dispose();
		if (val == null)
		{
			yield break;
		}
		Array array = val.GetObject("appnews").GetArray("newsitems");
		List<Story> list = new List<Story>();
		foreach (Value item in array)
		{
			string @string = item.Obj.GetString("contents", "Missing Contents");
			@string = @string.Replace("\\n", "\n").Replace("\\r", "").Replace("\\\"", "\"");
			list.Add(new Story
			{
				name = item.Obj.GetString("title", "Missing Title"),
				url = item.Obj.GetString("url", "Missing URL"),
				date = item.Obj.GetInt("date", 0),
				text = @string,
				author = item.Obj.GetString("author", "Missing Author")
			});
		}
		Stories = list.ToArray();
	}
}


public struct Story
{
	public string name;

	public string url;

	public int date;

	public string text;

	public string author;
}


using Facepunch.Extend;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ToggleHUDLayer : MonoBehaviour, IClientComponent
{
	public Toggle toggleControl;

	public TextMeshProUGUI textControl;

	public string hudComponentName;

	protected void OnEnable()
	{
		UIHUD instance = SingletonComponent<UIHUD>.Instance;
		if (!((Object)(object)instance != (Object)null))
		{
			return;
		}
		Transform val = TransformEx.FindChildRecursive(((Component)instance).transform, hudComponentName);
		if ((Object)(object)val != (Object)null)
		{
			Canvas component = ((Component)val).GetComponent<Canvas>();
			if ((Object)(object)component != (Object)null)
			{
				toggleControl.isOn = ((Behaviour)component).enabled;
			}
			else
			{
				toggleControl.isOn = ((Component)val).gameObject.activeSelf;
			}
		}
		else
		{
			Debug.LogWarning((object)(((object)this).GetType().Name + ": Couldn't find child: " + hudComponentName));
		}
	}

	public void OnToggleChanged()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Client, "global.hudcomponent", new object[2] { hudComponentName, toggleControl.isOn });
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ToggleLayer : MonoBehaviour, IClientComponent
{
	public Toggle toggleControl;

	public TextMeshProUGUI textControl;

	public LayerSelect layer;

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
		{
			toggleControl.isOn = (MainCamera.mainCamera.cullingMask & layer.Mask) != 0;
		}
	}

	public void OnToggleChanged()
	{
		if (Object.op_Implicit((Object)(object)MainCamera.mainCamera))
		{
			if (toggleControl.isOn)
			{
				Camera mainCamera = MainCamera.mainCamera;
				mainCamera.cullingMask |= layer.Mask;
			}
			else
			{
				Camera mainCamera2 = MainCamera.mainCamera;
				mainCamera2.cullingMask &= ~layer.Mask;
			}
		}
	}

	protected void OnValidate()
	{
		if (Object.op_Implicit((Object)(object)textControl))
		{
			((TMP_Text)textControl).text = layer.Name;
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ToggleTerrainRenderer : MonoBehaviour
{
	public Toggle toggleControl;

	public Text textControl;

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			toggleControl.isOn = Terrain.activeTerrain.drawHeightmap;
		}
	}

	public void OnToggleChanged()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			Terrain.activeTerrain.drawHeightmap = toggleControl.isOn;
		}
	}

	protected void OnValidate()
	{
		if (Object.op_Implicit((Object)(object)textControl))
		{
			textControl.text = "Terrain Renderer";
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class ToggleTerrainTrees : MonoBehaviour
{
	public Toggle toggleControl;

	public Text textControl;

	protected void OnEnable()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			toggleControl.isOn = Terrain.activeTerrain.drawTreesAndFoliage;
		}
	}

	public void OnToggleChanged()
	{
		if (Object.op_Implicit((Object)(object)Terrain.activeTerrain))
		{
			Terrain.activeTerrain.drawTreesAndFoliage = toggleControl.isOn;
		}
	}

	protected void OnValidate()
	{
		if (Object.op_Implicit((Object)(object)textControl))
		{
			textControl.text = "Terrain Trees";
		}
	}
}


using System;
using UnityEngine;

public class TweakUI : SingletonComponent<TweakUI>
{
	public static bool isOpen;

	private void Update()
	{
		if (Input.GetKeyDown((KeyCode)283) && CanToggle())
		{
			SetVisible(!isOpen);
		}
	}

	protected bool CanToggle()
	{
		if (!LevelManager.isLoaded)
		{
			return false;
		}
		return true;
	}

	public void SetVisible(bool b)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (b)
		{
			isOpen = true;
			return;
		}
		isOpen = false;
		ConsoleSystem.Run(Option.Client, "writecfg", Array.Empty<object>());
	}
}


using Rust.UI.MainMenu;
using UnityEngine.UI;

public class TweakUIMultiSelect : UI_SettingsTweakConvar
{
	public ToggleGroup toggleGroup;
}


using System.Threading;
using Rust.UI;
using UnityEngine;

public class PartyInviteModal : SingletonComponent<PartyInviteModal>
{
	public RustText InviteLabel;

	public RustButton AcceptButton;

	public static Phrase InvitePhrase = new Phrase("party.invite", "{0} has invited you to a party");

	private ulong pendingLobbyId;

	private TimeSince age;

	public HttpImage ProfilePicture;

	public RectTransform ProgressBar;

	private CancellationTokenSource cancel;

	private ulong lastUserId;

	public bool IsShown => ((Component)this).gameObject.activeInHierarchy;

	public void Show(string username, ulong userId, ulong lobbyId)
	{
	}

	public void OnClientStartup()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (lastUserId != 0L)
		{
			age = TimeSince.op_Implicit(0f);
		}
	}

	public void Hide()
	{
	}

	public void OnAcceptButtonClicked()
	{
	}
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class PremiumModal : SingletonComponent<PremiumModal>
{
	public RustText UsernameLabel;

	public RustText MoneyLabel;

	public RustText ActiveStatusLabel;

	public RawImage ProfilePicture;

	public RustButton RefreshButton;

	public Phrase ActivePhrase;

	public Phrase InactivePhrase;

	public Phrase SearchingPhrase;

	public static Phrase ErrorPhrase = new Phrase("premium.error", "Error");

	public GameObject[] BackgroundImages;

	public static TimeSpan ButtonTimeout = TimeSpan.FromSeconds(65.0);

	public void Open()
	{
	}

	public void Close()
	{
	}

	private void UpdateInfo()
	{
	}

	public void RefreshButtonClicked()
	{
	}
}


using Rust.UI;
using UnityEngine;

public class ServerBrowser : MonoBehaviour
{
	public string orderBy = "pingDesc";

	public RustButton cacheBrowserToggle;

	public RustButton filterTutorialButton;

	public GameObject pingEstimationButton;
}


using Rust.UI;
using UnityEngine;

public class ServerBrowserCategory : MonoBehaviour
{
	public RustText serverCountText;

	public bool useServerCount;
}


public static class ServerBrowserEx
{
	public static string GetPingString(this ServerInfo server)
	{
		if (((ServerInfo)(ref server)).Ping != int.MaxValue)
		{
			return ((ServerInfo)(ref server)).Ping.ToString();
		}
		return "?";
	}
}


using Rust.UI;
using UnityEngine.UI;

public class ServerBrowserInfo : SingletonComponent<ServerBrowserInfo>
{
	public bool isMain;

	public RustText serverName;

	public RustText serverMeta;

	public Text serverText;

	public Button viewWebpage;

	public Button refresh;

	public ServerInfo? currentServer;

	public HttpImage headerImage;

	public HttpImage logoImage;
}


using Facepunch.Flexbox;
using Rust.UI;
using UnityEngine;

public class ServerBrowserInfoNexus : SingletonComponent<ServerBrowserInfoNexus>
{
	public GameObject loadingIndicator;

	public GameObject errorIndicator;

	public GameObject errorGenericText;

	public GameObject errorSteamAuthNullText;

	public RustText serverName;

	public RustText serverDesc;

	public RustText playerCount;

	public RustText zoneCount;

	public RustText lastWiped;

	public HttpImage coverImage;

	public HttpImage logoImage;

	public UINexusMapWidget mapWidget;

	public FlexTransition zoneListReveal;

	public RectTransform zoneListParent;

	public GameObjectRef zoneListItem;

	public RustButton joinServer;

	public RustButton viewWebpage;
}


using Rust.UI;
using UnityEngine;

public class ServerBrowserInfoNexusZone : MonoBehaviour
{
	public RustButton button;

	public GameObject checkbox;

	public GameObject checkboxIndicator;

	public RectTransform currentServerIndicator;

	public RustText zoneName;

	public RustText ping;

	public RustText playerCount;
}


using System;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ServerBrowserItem : MonoBehaviour
{
	[Serializable]
	public struct PremiumGameObject
	{
		public GameObject GameObject;

		public bool ShowIfEligible;
	}

	public TextMeshProUGUI serverName;

	public RustFlexText mapName;

	public TextMeshProUGUI playerCount;

	public TextMeshProUGUI ping;

	public TextMeshProUGUI pendingPing;

	public Toggle favourited;

	public ServerBrowserTagList serverTagList;

	public Color pingColor;

	public Color pingWarningColor;

	public Tooltip pingWarningTooltip;

	public PremiumGameObject[] PremiumOptions;
}


using System;
using UnityEngine;

[Serializable]
public struct PremiumGameObject
{
	public GameObject GameObject;

	public bool ShowIfEligible;
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ServerBrowserItemNexus : MonoBehaviour
{
	public TextMeshProUGUI serverName;

	public RustFlexText mapName;

	public TextMeshProUGUI playerCount;

	public Toggle favourited;

	public ServerBrowserTagList serverTagList;

	public TextMeshProUGUI changeset;
}


using System;
using Facepunch;
using UnityEngine;

public class ServerBrowserList : ServerBrowserListBase, VirtualScroll.IDataSource, VirtualScroll.IVisualUpdate
{
	[Serializable]
	public struct Rules
	{
		public string tag;

		public ServerBrowserList serverList;

		public bool keepInList;

		public string CompressedTag { get; set; }
	}

	public enum QueryType
	{
		RegularInternet,
		Friends,
		History,
		LAN,
		Favourites,
		None
	}

	[Serializable]
	public struct ServerKeyvalues
	{
		public string key;

		public string value;
	}

	public bool legacyUIDisplay = true;

	public bool UseOfficialServers;

	public VirtualScroll VirtualScroll;

	public FlexVirtualScroll VirtualScrollFlex;

	public bool prioritizePremiumServers;

	public Rules[] rules;

	public bool hideOfficialServers;

	public bool excludeEmptyServersUsingQuery;

	public bool alwaysIncludeEmptyServers;

	public bool clampPlayerCountsToTrustedValues = true;

	public bool replacePingWithTimeSinceLastPlayed;

	private static string[] pingStrings = new string[3] { ".", "..", "..." };

	public QueryType queryType;

	public static string VersionTag = "v" + 2597;

	public ServerKeyvalues[] keyValues = new ServerKeyvalues[0];

	public void OnVisualUpdate(int i, GameObject obj)
	{
	}

	public int GetItemCount()
	{
		return 0;
	}

	public void SetItemData(int i, GameObject obj)
	{
	}

	private void VisualUpdate(int i, GameObject obj)
	{
	}

	private void VisualUpdateLegacy(int i, GameObject obj)
	{
	}
}


using System;

[Serializable]
public struct Rules
{
	public string tag;

	public ServerBrowserList serverList;

	public bool keepInList;

	public string CompressedTag { get; set; }
}


public enum QueryType
{
	RegularInternet,
	Friends,
	History,
	LAN,
	Favourites,
	None
}


using System;

[Serializable]
public struct ServerKeyvalues
{
	public string key;

	public string value;
}


public abstract class ServerBrowserListBase : BaseMonoBehaviour
{
	public ServerBrowserCategory categoryButton;

	public string sortOrder = "pingDesc";
}


using Facepunch;

public class ServerBrowserListNexus : ServerBrowserListBase
{
	public VirtualScroll VirtualScroll;
}


using System.Collections.Generic;
using Facepunch;
using Facepunch.Nexus.Models;

public class NexusEx : Nexus
{
	public static HashSet<StringView> Empty = new HashSet<StringView>();

	public string Key { get; }

	public HashSet<StringView> TagsSet { get; }

	public NexusEx(string endpoint, Nexus nexus)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		((Nexus)this).NexusId = nexus.NexusId;
		((Nexus)this).Name = nexus.Name;
		((Nexus)this).LastReset = nexus.LastReset;
		((Nexus)this).ZoneCount = nexus.ZoneCount;
		((Nexus)this).MaxPlayers = nexus.MaxPlayers;
		((Nexus)this).OnlinePlayers = nexus.OnlinePlayers;
		((Nexus)this).QueuedPlayers = nexus.QueuedPlayers;
		((Nexus)this).Build = nexus.Build;
		((Nexus)this).Protocol = nexus.Protocol;
		((Nexus)this).Tags = nexus.Tags;
		Key = $"{endpoint}#{nexus.NexusId}";
		if (!string.IsNullOrEmpty(((Nexus)this).Tags))
		{
			List<StringView> list = Pool.Get<List<StringView>>();
			StringView val = StringView.op_Implicit(((Nexus)this).Tags);
			((StringView)(ref val)).Split(',', (ICollection<StringView>)list);
			TagsSet = new HashSet<StringView>(list, (IEqualityComparer<StringView>?)ComparerIgnoreCase.Instance);
		}
		else
		{
			TagsSet = Empty;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.UI;
using UnityEngine;

public class ServerBrowserTag : MonoBehaviour
{
	public string serverTag;

	[Tooltip("Priority will choose what tag will show if multiple in group are defined. Seperate from display order")]
	public int priority;

	public bool excludeOnly;

	private string _tag;

	public RustButton button;

	public string CompactTag
	{
		get
		{
			if (_tag == null)
			{
				_tag = ServerTagCompressor.ShortenTag(serverTag);
			}
			return _tag;
		}
	}

	public bool IsActive
	{
		get
		{
			if ((Object)(object)button != (Object)null)
			{
				return ((RustControl)button).IsPressed;
			}
			return false;
		}
	}

	public bool ContainsTag(HashSet<StringView> tags)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		if (tags.Contains(StringView.op_Implicit(CompactTag)) || tags.Contains(StringView.op_Implicit(serverTag)))
		{
			return true;
		}
		if (CompactTag != serverTag)
		{
			foreach (StringView tag in tags)
			{
				StringView current = tag;
				if (((StringView)(ref current)).Contains(StringView.op_Implicit(CompactTag)))
				{
					return true;
				}
			}
		}
		return excludeOnly;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class ServerBrowserTagFilters : MonoBehaviour
{
	public UnityEvent TagFiltersChanged = new UnityEvent();

	private ServerBrowserTagGroup[] _groups;

	private List<bool> _previousState;

	public void Start()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Expected O, but got Unknown
		_groups = ((Component)this).gameObject.GetComponentsInChildren<ServerBrowserTagGroup>();
		UnityAction val = (UnityAction)delegate
		{
			UnityEvent tagFiltersChanged = TagFiltersChanged;
			if (tagFiltersChanged != null)
			{
				tagFiltersChanged.Invoke();
			}
		};
		ServerBrowserTagGroup[] groups = _groups;
		for (int i = 0; i < groups.Length; i++)
		{
			ServerBrowserTag[] tags = groups[i].tags;
			foreach (ServerBrowserTag obj in tags)
			{
				obj.button.OnPressed.AddListener(val);
				obj.button.OnReleased.AddListener(val);
			}
		}
	}

	public void DeselectAll()
	{
		if (_groups == null)
		{
			return;
		}
		ServerBrowserTagGroup[] groups = _groups;
		foreach (ServerBrowserTagGroup serverBrowserTagGroup in groups)
		{
			if (serverBrowserTagGroup.tags != null)
			{
				ServerBrowserTag[] tags = serverBrowserTagGroup.tags;
				for (int j = 0; j < tags.Length; j++)
				{
					tags[j].button.SetToggleFalse(true);
				}
			}
		}
	}

	public void GetTags(out List<HashSet<string>> searchTagGroups, out HashSet<string> excludeTags)
	{
		searchTagGroups = new List<HashSet<string>>();
		excludeTags = new HashSet<string>();
		ServerBrowserTagGroup[] groups = _groups;
		foreach (ServerBrowserTagGroup serverBrowserTagGroup in groups)
		{
			if (!serverBrowserTagGroup.AnyActive())
			{
				continue;
			}
			ServerBrowserTag[] tags;
			if (serverBrowserTagGroup.isExclusive)
			{
				HashSet<string> hashSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
				tags = serverBrowserTagGroup.tags;
				foreach (ServerBrowserTag serverBrowserTag in tags)
				{
					if (serverBrowserTag.IsActive)
					{
						if (!serverBrowserTag.excludeOnly)
						{
							hashSet.Add(serverBrowserTag.CompactTag);
							hashSet.Add(serverBrowserTag.serverTag);
						}
					}
					else if (serverBrowserTagGroup.isExclusive)
					{
						excludeTags.Add(serverBrowserTag.CompactTag);
						excludeTags.Add(serverBrowserTag.serverTag);
					}
				}
				if (hashSet.Count > 0)
				{
					searchTagGroups.Add(hashSet);
				}
				continue;
			}
			tags = serverBrowserTagGroup.tags;
			foreach (ServerBrowserTag serverBrowserTag2 in tags)
			{
				if (serverBrowserTag2.IsActive)
				{
					HashSet<string> hashSet2 = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
					hashSet2.Add(serverBrowserTag2.CompactTag);
					hashSet2.Add(serverBrowserTag2.serverTag);
					searchTagGroups.Add(hashSet2);
				}
				else if (serverBrowserTag2.excludeOnly)
				{
					excludeTags.Add(serverBrowserTag2.CompactTag);
					excludeTags.Add(serverBrowserTag2.serverTag);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public class ServerBrowserTagGroup : MonoBehaviour
{
	[Tooltip("If set then queries will filter out servers matching unselected tags in the group")]
	public bool isExclusive;

	[NonSerialized]
	public ServerBrowserTag[] tags;

	private void Initialize()
	{
		if (tags == null)
		{
			tags = (from x in ((Component)this).GetComponentsInChildren<ServerBrowserTag>(true)
				orderby x.priority descending
				select x).ToArray();
		}
	}

	public void Awake()
	{
		Initialize();
	}

	public bool AnyActive()
	{
		ServerBrowserTag[] array = tags;
		foreach (ServerBrowserTag serverBrowserTag in array)
		{
			if (serverBrowserTag.IsActive)
			{
				return true;
			}
			if (serverBrowserTag.excludeOnly)
			{
				return true;
			}
		}
		return false;
	}

	public void Refresh(HashSet<StringView> serverTags, ref int tagsEnabled, int maxTags)
	{
		Initialize();
		bool flag = false;
		ServerBrowserTag[] array = tags;
		foreach (ServerBrowserTag serverBrowserTag in array)
		{
			if ((!isExclusive || !flag) && tagsEnabled < maxTags && serverBrowserTag.ContainsTag(serverTags))
			{
				ComponentExtensions.SetActive<ServerBrowserTag>(serverBrowserTag, true);
				tagsEnabled++;
				flag = true;
			}
			else
			{
				ComponentExtensions.SetActive<ServerBrowserTag>(serverBrowserTag, false);
			}
		}
		((Component)this).gameObject.SetActive(flag);
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ServerBrowserTagList : MonoBehaviour
{
	public int maxTagsToShow = 3;

	private ServerBrowserTagGroup[] _groups;

	private void Initialize()
	{
		if (_groups == null)
		{
			_groups = ((Component)this).GetComponentsInChildren<ServerBrowserTagGroup>(true);
		}
	}

	public void Awake()
	{
		Initialize();
	}

	public bool Refresh(HashSet<StringView> serverTags)
	{
		Initialize();
		int tagsEnabled = 0;
		ServerBrowserTagGroup[] groups = _groups;
		for (int i = 0; i < groups.Length; i++)
		{
			groups[i].Refresh(serverTags, ref tagsEnabled, maxTagsToShow);
		}
		return tagsEnabled > 0;
	}

	public void PremiumButtonClicked()
	{
		SingletonComponent<PremiumModal>.Instance.Open();
	}
}


using UnityEngine;

public class ServerHistory : MonoBehaviour
{
	public ServerHistoryItem prefab;

	public GameObject panelList;

	internal IServerQuery Request;
}


using UnityEngine;
using UnityEngine.UI;

public class ServerHistoryItem : MonoBehaviour
{
	private ServerInfo serverInfo;

	public Text serverName;

	public Text players;

	public Text lastJoinDate;

	public uint order;
}


using Rust.UI;
using UnityEngine;

public class UIConfirmationPopup : MonoBehaviour
{
	[SerializeField]
	private Transform buttonsParent;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private RustButton buttonTemplate;

	public RustButton[] buttons;
}


using Rust.UI;
using UnityEngine;

public class UISafeModeWarning : MonoBehaviour, IClientComponent
{
	public RustButton ApplyButton;

	public RustSlider TimeSlider;

	public float TimeToWait = 5f;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UISafeZoneWarning : MonoBehaviour
{
	[SerializeField]
	private Transform buttonsParent;

	[SerializeField]
	private RustText messageText;

	[SerializeField]
	private Button buttonTemplate;
}


using Rust.UI;
using UnityEngine;

public class UnreadMessages : SingletonComponent<UnreadMessages>
{
	public StyleAsset AllRead;

	public StyleAsset Unread;

	public RustButton Button;

	public GameObject UnreadTextObject;

	public RustText UnreadText;

	public GameObject MessageList;

	public GameObject MessageListContainer;

	public GameObject MessageListEmpty;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(RawImage))]
[ExecuteAlways]
public class RawImagePreserveAspect : MonoBehaviour, IClientComponent
{
	public RawImage rawImage;

	public RectTransform rectTransform;

	private Texture lastTexture;
}


using UnityEngine;
using UnityEngine.UI;

public class UI_FullscreenSkinViewer : SingletonComponent<UI_FullscreenSkinViewer>
{
	public CanvasGroup background;

	public Image glowImage;

	private UI_SkinViewerControls _source;
}


using UnityEngine;

public class UI_SkinViewerControls : MonoBehaviour
{
	[SerializeField]
	private Canvas canvas;

	[SerializeField]
	private CoverImage coverImage;

	[SerializeField]
	private float maxYaw = 8f;

	[SerializeField]
	private float maxPitch = 4f;

	[SerializeField]
	private float lerpSpeed = 6f;

	[SerializeField]
	private float responseCurve = 1.5f;

	[Header("Drag")]
	[SerializeField]
	private float inertiaDecay = 5f;

	[SerializeField]
	private float rotationSpeed = 300f;

	[SerializeField]
	[Header("Pan")]
	private Vector2 panLimitX = new Vector2(-1f, 1f);

	[SerializeField]
	private Vector2 panLimitY = new Vector2(-1f, 1f);

	[SerializeField]
	private float panSpeed = 0.005f;

	[SerializeField]
	[Header("Zoom")]
	private float zoomSpeed = 0.1f;

	[SerializeField]
	private Vector2 minMaxFov = new Vector2(20f, 8f);

	[Header("Idle")]
	[SerializeField]
	private float idleSwaySpeed = 1f;

	[SerializeField]
	private float idleSwayAmount = 1.5f;

	[SerializeField]
	private float swayEaseSpeed = 1f;

	[SerializeField]
	private float swayDelay = 0.3f;
}


using UnityEngine;
using UnityEngine.UI;

[RequireComponent(typeof(AudioSource), typeof(Toggle))]
public class UI_StoreSongPreview : BaseMonoBehaviour
{
}


using Rust.UI;
using UnityEngine;

public class MissionsHUD : SingletonComponent<MissionsHUD>
{
	public SoundDefinition listComplete;

	public SoundDefinition itemComplete;

	public SoundDefinition popup;

	public Canvas Canvas;

	public RustText titleText;

	public GameObject timerObject;

	public RustText timerText;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.Serialization;

public class MissionsHUDToDo : BaseMonoBehaviour
{
	private static readonly Memoized<string, (float Current, float Target)> FormatProgres = new Memoized<string, (float, float)>((Func<(float, float), string>)delegate((float Current, float Target) d)
	{
		float num = Mathf.Min(d.Current, d.Target);
		return $" ({num:0.#}/{d.Target:0.#})";
	});

	public RustText text;

	public RectTransform checkIcon;

	public RectTransform checkBox;

	public Phrase optionalPrefix;

	public CanvasGroup group;

	[FormerlySerializedAs("AliveColor")]
	public Color DefaultColor;

	[FormerlySerializedAs("DeadColor")]
	public Color CompletedColor;

	[FormerlySerializedAs("HighlightColor")]
	public Color CompletedHighlightColor;

	public Color FailedColor;

	public Color FailedHighlightColor;

	public PingWidget PingWidget;
}


using UnityEngine;

public class NoRespawnIcon : FacepunchBehaviour
{
	[SerializeField]
	private CanvasGroup noRespawnWarning;

	[SerializeField]
	private GameObject noRespawnWarningGO;
}


using UnityEngine;

public class ObjectRotation : MonoBehaviour
{
	public Camera cam;

	public bool ignoreNeedsKeyboard = true;

	public Transform panTransform;
}


using UnityEngine;

public class OpenURL : MonoBehaviour
{
	public bool OpenWebURL = true;
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RawImage))]
public class ImageAlphaRaycastFilter : UIBehaviour, ICanvasRaycastFilter
{
	[NonSerialized]
	private RawImage m_rawImage;

	public float rChannelHitTestMinimumThreshold = 1f;

	protected RawImage rawImage => m_rawImage ?? (m_rawImage = ((Component)this).GetComponent<RawImage>());

	public virtual bool IsRaycastLocationValid(Vector2 screenPoint, Camera eventCamera)
	{
		//IL_0101: Expected O, but got Unknown
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		if (rChannelHitTestMinimumThreshold <= 0f)
		{
			return true;
		}
		if (rChannelHitTestMinimumThreshold > 1f)
		{
			return false;
		}
		Texture mainTexture = ((Graphic)rawImage).mainTexture;
		Texture2D val = (Texture2D)(object)((mainTexture is Texture2D) ? mainTexture : null);
		Vector2 val2 = default(Vector2);
		if (!RectTransformUtility.ScreenPointToLocalPointInRectangle(((Graphic)rawImage).rectTransform, screenPoint, eventCamera, ref val2))
		{
			return false;
		}
		Rect pixelAdjustedRect = ((Graphic)rawImage).GetPixelAdjustedRect();
		val2.x += ((Graphic)rawImage).rectTransform.pivot.x * ((Rect)(ref pixelAdjustedRect)).width;
		val2.y += ((Graphic)rawImage).rectTransform.pivot.y * ((Rect)(ref pixelAdjustedRect)).height;
		((Vector2)(ref val2))..ctor(val2.x / ((Rect)(ref pixelAdjustedRect)).width, val2.y / ((Rect)(ref pixelAdjustedRect)).height);
		if ((Object)(object)val != (Object)null && !((Texture)val).isReadable)
		{
			return false;
		}
		try
		{
			return val.GetPixelBilinear(val2.x, val2.y).r <= rChannelHitTestMinimumThreshold;
		}
		catch (UnityException val3)
		{
			UnityException val4 = val3;
			Debug.LogError((object)("Using alphaHitTestMinimumThreshold greater than 0 on Graphic whose sprite texture cannot be read. " + ((Exception)(object)val4).Message + " Also make sure to disable sprite packing for this sprite."), (Object)(object)this);
			return true;
		}
	}
}


using UnityEngine.EventSystems;

public class PaintableImageGrid : UIBehaviour, IServerFileReceiver
{
	public GameObjectRef templateImage;

	public int cols = 4;

	public int rows = 4;

	public bool readOnly;
}


using UnityEngine;
using UnityEngine.UI;

public class UIPaintableImage : MonoBehaviour
{
	public enum DrawMode
	{
		AlphaBlended,
		Additive,
		Lighten,
		Erase
	}

	public RawImage image;

	public int texSize = 64;

	public Color clearColor = Color.clear;

	public FilterMode filterMode = (FilterMode)1;

	public bool mipmaps;

	public bool readOnly;

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)this).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}
}


public enum DrawMode
{
	AlphaBlended,
	Additive,
	Lighten,
	Erase
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class UIParticle : BaseMonoBehaviour
{
	public Vector2 LifeTime;

	public Vector2 Gravity = new Vector2(1000f, 1000f);

	public Vector2 InitialX;

	public Vector2 InitialY;

	public Vector2 InitialScale = Vector2.one;

	public Vector2 InitialDelay;

	public Vector2 ScaleVelocity;

	public Gradient InitialColor;

	private float lifetime;

	private float gravity;

	private Vector2 velocity;

	private float scaleVelocity;

	public static void Add(UIParticle particleSource, RectTransform spawnPosition, RectTransform particleCanvas)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = Object.Instantiate<GameObject>(((Component)particleSource).gameObject);
		obj.transform.SetParent((Transform)(object)spawnPosition, false);
		Transform transform = obj.transform;
		Rect rect = spawnPosition.rect;
		float num = Random.Range(0f, ((Rect)(ref rect)).width);
		rect = spawnPosition.rect;
		float num2 = num - ((Rect)(ref rect)).width * spawnPosition.pivot.x;
		rect = spawnPosition.rect;
		float num3 = Random.Range(0f, ((Rect)(ref rect)).height);
		rect = spawnPosition.rect;
		transform.localPosition = new Vector3(num2, num3 - ((Rect)(ref rect)).height * spawnPosition.pivot.y, 0f);
		obj.transform.SetParent((Transform)(object)particleCanvas, true);
		obj.transform.localScale = Vector3.one;
		obj.transform.localRotation = Quaternion.identity;
	}

	private void Start()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		transform.localScale *= Random.Range(InitialScale.x, InitialScale.y);
		velocity.x = Random.Range(InitialX.x, InitialX.y);
		velocity.y = Random.Range(InitialY.x, InitialY.y);
		gravity = Random.Range(Gravity.x, Gravity.y);
		scaleVelocity = Random.Range(ScaleVelocity.x, ScaleVelocity.y);
		Image component = ((Component)this).GetComponent<Image>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Graphic)component).color = InitialColor.Evaluate(Random.Range(0f, 1f));
		}
		lifetime = Random.Range(InitialDelay.x, InitialDelay.y) * -1f;
		if (lifetime < 0f)
		{
			((Component)this).GetComponent<CanvasGroup>().alpha = 0f;
		}
		((FacepunchBehaviour)this).Invoke((Action)Die, Random.Range(LifeTime.x, LifeTime.y) + lifetime * -1f);
	}

	private void Update()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		if (lifetime < 0f)
		{
			lifetime += Time.deltaTime;
			if (lifetime < 0f)
			{
				return;
			}
			((Component)this).GetComponent<CanvasGroup>().alpha = 1f;
		}
		else
		{
			lifetime += Time.deltaTime;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 localScale = ((Component)this).transform.localScale;
		velocity.y -= gravity * Time.deltaTime;
		position.x += velocity.x * Time.deltaTime;
		position.y += velocity.y * Time.deltaTime;
		localScale += Vector3.one * scaleVelocity * Time.deltaTime;
		if (localScale.x <= 0f || localScale.y <= 0f)
		{
			Die();
			return;
		}
		((Component)this).transform.position = position;
		((Component)this).transform.localScale = localScale;
	}

	private void Die()
	{
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}
}


using Rust.UI;
using UnityEngine;

public class UIParty : BaseMonoBehaviour
{
	public GameObjectRef PartyMemberPrefab;

	public GameObjectRef InvitePrefab;

	public int MaxPartyMembersToRender = 6;

	public GameObject HiddenPartyMemberContainer;

	public RustText HiddenPartyMemberCountText;

	public RectTransform PartyMemberContainer;

	public GameObject PartySection;

	public RustText PartyMemberCount;

	public RectTransform InvitesContainer;

	public GameObject InvitesSection;

	public RustText InviteCountLabel;

	public FriendStyleDef Style;

	public UIFriendsList FriendsList;

	public bool RenderParty = true;

	public bool ShouldShowInvites = true;

	public void LeavePartyClicked()
	{
	}
}


using UnityEngine;

public class PeacekeeperHostileIcon : FacepunchBehaviour
{
	[SerializeField]
	private CanvasGroup turretWarningCanvasGroup;

	[SerializeField]
	private GameObject noRespawnWarningGO;
}


using TMPro;
using UnityEngine;

public class PerformanceText : MonoBehaviour
{
	public TextMeshProUGUI text;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[ExecuteInEditMode]
public class PieMenu : UIBehaviour
{
	[Serializable]
	public class MenuOption
	{
		public struct ColorMode
		{
			public enum PieMenuSpriteColorOption
			{
				CustomColor,
				SpriteColor
			}

			public PieMenuSpriteColorOption Mode;

			public Color CustomColor;
		}

		public Phrase name;

		public Phrase desc;

		public string requirements;

		public Sprite sprite;

		public bool disabled;

		public int order;

		public ColorMode? overrideColorMode;

		public bool showOverlay;

		public float time;

		public BasePlayer.PingType? showTutorialHighlight;

		public float sizeRatio = 1f;

		public float iconScale = 1f;

		[NonSerialized]
		public Action<BasePlayer> action;

		[NonSerialized]
		public Action<BasePlayer> actionDisabled;

		[NonSerialized]
		public Action<BasePlayer> actionPrev;

		[NonSerialized]
		public Action<BasePlayer> actionNext;

		[NonSerialized]
		public PieOption option;

		[NonSerialized]
		public bool selected;

		[NonSerialized]
		public bool allowMerge;
	}

	public static PieMenu Instance;

	public Image middleBox;

	public PieShape pieBackgroundBlur;

	public PieShape pieBackground;

	public PieShape pieSelection;

	public GameObject pieOptionPrefab;

	public GameObject optionsCanvas;

	public MenuOption[] options;

	public GameObject scaleTarget;

	public GameObject arrowLeft;

	public GameObject arrowRight;

	public float sliceGaps = 10f;

	[Range(0f, 1f)]
	public float outerSize = 1f;

	[Range(0f, 1f)]
	public float innerSize = 0.5f;

	[Range(0f, 1f)]
	public float iconSize = 0.8f;

	[Range(0f, 360f)]
	public float startRadius;

	[Range(0f, 360f)]
	public float radiusSize = 360f;

	public Image middleImage;

	public RustText middleTitle;

	public RustText middleDesc;

	public RustText middleRequired;

	public Color colorIconActive;

	public Color colorIconHovered;

	public Color colorIconDisabled;

	public Color colorBackgroundDisabled;

	public SoundDefinition clipOpen;

	public SoundDefinition clipCancel;

	public SoundDefinition clipChanged;

	public SoundDefinition clipSelected;

	public MenuOption defaultOption;

	public Material IconMaterial;

	public bool IsOpen { get; private set; }
}


using System;
using UnityEngine;

[Serializable]
public class MenuOption
{
	public struct ColorMode
	{
		public enum PieMenuSpriteColorOption
		{
			CustomColor,
			SpriteColor
		}

		public PieMenuSpriteColorOption Mode;

		public Color CustomColor;
	}

	public Phrase name;

	public Phrase desc;

	public string requirements;

	public Sprite sprite;

	public bool disabled;

	public int order;

	public ColorMode? overrideColorMode;

	public bool showOverlay;

	public float time;

	public BasePlayer.PingType? showTutorialHighlight;

	public float sizeRatio = 1f;

	public float iconScale = 1f;

	[NonSerialized]
	public Action<BasePlayer> action;

	[NonSerialized]
	public Action<BasePlayer> actionDisabled;

	[NonSerialized]
	public Action<BasePlayer> actionPrev;

	[NonSerialized]
	public Action<BasePlayer> actionNext;

	[NonSerialized]
	public PieOption option;

	[NonSerialized]
	public bool selected;

	[NonSerialized]
	public bool allowMerge;
}


using UnityEngine;

public struct ColorMode
{
	public enum PieMenuSpriteColorOption
	{
		CustomColor,
		SpriteColor
	}

	public PieMenuSpriteColorOption Mode;

	public Color CustomColor;
}


public enum PieMenuSpriteColorOption
{
	CustomColor,
	SpriteColor
}


using ConVar;
using UnityEngine;

public static class UISound
{
	private static AudioSource source;

	private static AudioSource GetAudioSource()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)source != (Object)null)
		{
			return source;
		}
		source = new GameObject("UISound").AddComponent<AudioSource>();
		source.spatialBlend = 0f;
		source.volume = 1f;
		return source;
	}

	public static void Play(AudioClip clip, float volume = 1f)
	{
		if (!((Object)(object)clip == (Object)null))
		{
			GetAudioSource().volume = volume * Audio.master * 0.4f;
			GetAudioSource().PlayOneShot(clip);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class PieOption : MonoBehaviour
{
	public PieShape background;

	public Image imageIcon;

	public Image overlayIcon;

	public PingWidget tutorialHighlight;
}


using System;
using UnityEngine;
using UnityEngine.UI;

[ExecuteInEditMode]
public class PieShape : Graphic
{
	[Range(0f, 1f)]
	public float outerSize = 1f;

	[Range(0f, 1f)]
	public float innerSize = 0.5f;

	public float startRadius = -45f;

	public float endRadius = 45f;

	public float border;

	public bool debugDrawing;

	public bool calculateAverage;

	public Rect drawRect { get; private set; }

	public Vector2 centrePosition { get; private set; }

	public Vector2 firstPosition { get; private set; }

	public Vector2 lastPosition { get; private set; }

	public Vector3 averagePosition { get; private set; } = Vector2.op_Implicit(default(Vector2));

	protected override void OnPopulateMesh(VertexHelper vbo)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0416: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0198: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		Rect val2 = (drawRect = default(Rect));
		vbo.Clear();
		UIVertex simpleVert = UIVertex.simpleVert;
		float num = startRadius;
		float num2 = endRadius;
		if (startRadius > endRadius)
		{
			num2 = endRadius + 360f;
		}
		float num3 = Mathf.Floor((num2 - num) / 6f);
		if (num3 <= 1f)
		{
			return;
		}
		float num4 = (num2 - num) / num3;
		float num5 = num + (num2 - num) * 0.5f;
		averagePosition = default(Vector3);
		Color val3 = ((Graphic)this).color;
		val2 = ((Graphic)this).rectTransform.rect;
		float num6 = ((Rect)(ref val2)).height * 0.5f;
		Vector2 val4 = new Vector2(Mathf.Sin(num5 * (MathF.PI / 180f)), Mathf.Cos(num5 * (MathF.PI / 180f))) * border;
		int num7 = 0;
		firstPosition = Vector2.zero;
		lastPosition = Vector2.zero;
		for (float num8 = num; num8 < num2; num8 += num4)
		{
			if (debugDrawing)
			{
				val3 = ((!(val3 == Color.red)) ? Color.red : Color.white);
			}
			simpleVert.color = Color32.op_Implicit(val3);
			float num9 = Mathf.Sin(num8 * (MathF.PI / 180f));
			float num10 = Mathf.Cos(num8 * (MathF.PI / 180f));
			float num11 = num8 + num4;
			if (num11 > num2)
			{
				num11 = num2;
			}
			float num12 = Mathf.Sin(num11 * (MathF.PI / 180f));
			float num13 = Mathf.Cos(num11 * (MathF.PI / 180f));
			simpleVert.position = Vector2.op_Implicit(new Vector2(num9 * outerSize * num6, num10 * outerSize * num6) + val4);
			if (vbo.currentVertCount == 0)
			{
				firstPosition = Vector2.op_Implicit(simpleVert.position);
				if (calculateAverage)
				{
					averagePosition = simpleVert.position;
				}
			}
			else if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			vbo.AddVert(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num12 * outerSize * num6, num13 * outerSize * num6) + val4);
			if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			vbo.AddVert(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num12 * innerSize * num6, num13 * innerSize * num6) + val4);
			if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			lastPosition = Vector2.op_Implicit(simpleVert.position);
			vbo.AddVert(simpleVert);
			simpleVert.position = Vector2.op_Implicit(new Vector2(num9 * innerSize * num6, num10 * innerSize * num6) + val4);
			if (calculateAverage)
			{
				averagePosition += simpleVert.position;
			}
			vbo.AddVert(simpleVert);
			vbo.AddTriangle(num7, num7 + 1, num7 + 2);
			vbo.AddTriangle(num7 + 2, num7 + 3, num7);
			num7 += 4;
		}
		if (calculateAverage)
		{
			averagePosition = new Vector3(averagePosition.x / (float)vbo.currentVertCount, averagePosition.y / (float)vbo.currentVertCount, averagePosition.z / (float)vbo.currentVertCount);
		}
		drawRect = new Rect(Mathf.Min(firstPosition.x, lastPosition.x), Mathf.Min(firstPosition.y, lastPosition.y), Mathf.Abs(firstPosition.x - lastPosition.x), Mathf.Abs(firstPosition.y - lastPosition.y));
		centrePosition = Vector2.Lerp(firstPosition, lastPosition, 0.5f);
	}
}


using UnityEngine;

public class PingManager : ListComponent<PingManager>
{
	public GameObjectRef PingWidgetRef;

	public RectTransform PingParent;

	public RectTransform TeamPingParent;

	public CanvasGroup AlphaCanvas;
}


using UnityEngine;
using UnityEngine.UI;

public class PingWidget : MonoBehaviour
{
	public RectTransform MoveTransform;

	public RectTransform ScaleTransform;

	public Image InnerImage;

	public Image OuterImage;

	public GameObject TeamLeaderRoot;

	public GameObject CancelHoverRoot;

	public SoundDefinition PingDeploySoundHostile;

	public SoundDefinition PingDeploySoundGoTo;

	public SoundDefinition PingDeploySoundDollar;

	public SoundDefinition PingDeploySoundLoot;

	public SoundDefinition PingDeploySoundNode;

	public SoundDefinition PingDeploySoundGun;

	public CanvasGroup FadeCanvas;
}


using UnityEngine;
using UnityEngine.Rendering;

[ExecuteInEditMode]
public class CameraEx : MonoBehaviour
{
	public bool overrideAmbientLight;

	public AmbientMode ambientMode;

	public Color ambientGroundColor;

	public Color ambientEquatorColor;

	public Color ambientLight;

	public float ambientIntensity;

	public ReflectionProbe reflectionProbe;

	internal Color old_ambientLight;

	internal Color old_ambientGroundColor;

	internal Color old_ambientEquatorColor;

	internal float old_ambientIntensity;

	internal AmbientMode old_ambientMode;

	public float aspect;

	private Camera camera;
}


using UnityEngine;

public class SegmentMaskPositioning : MonoBehaviour
{
	public PlayerModel source;

	public GameObject headMask;

	public GameObject chestMask;

	public GameObject legsMask;

	public float xOffset = 0.75f;
}


using UnityEngine;

public class uiPlayerPreview : SingletonComponent<uiPlayerPreview>
{
	public enum EffectMode
	{
		Poster,
		Polaroid
	}

	public Camera previewCamera;

	public PlayerModel playermodel;

	public GameObject wantedSnapshotEffectPosterRoot;

	public GameObject wantedSnapshotEffectPolaroidRoot;

	public SegmentMaskPositioning segmentMask;
}


public enum EffectMode
{
	Poster,
	Polaroid
}


public class UIPlayerPreviewControls : SingletonComponent<UIPlayerPreviewControls>
{
	public float RotationSpeed = 90f;

	public float RotationLerpSpeed = 5f;

	public float RotationStopLerpSpeed = 2.5f;
}


using UnityEngine;
using UnityEngine.UI;

public class PowerBar : MonoBehaviour
{
	public static PowerBar Instance;

	public Image powerInner;

	public float fullSize;

	public CanvasGroup group;
}


using UnityEngine;
using UnityEngine.UI;

public class UIInvertedMaskImage : Image
{
	private Material cachedMaterial;

	public override Material materialForRendering
	{
		get
		{
			if ((Object)(object)cachedMaterial == (Object)null)
			{
				cachedMaterial = Object.Instantiate<Material>(((Graphic)this).materialForRendering);
				cachedMaterial.SetInt("_StencilComp", 6);
			}
			return cachedMaterial;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ProgressBar : UIBehaviour
{
	public static ProgressBar Instance;

	private Action<BasePlayer> action;

	public float timeFinished;

	private float timeCounter;

	public GameObject scaleTarget;

	public Image progressField;

	public Image iconField;

	public Text leftField;

	public Text rightField;

	public SoundDefinition clipOpen;

	public SoundDefinition clipCancel;

	private bool isOpen;

	public bool InstanceIsOpen
	{
		get
		{
			if ((Object)(object)Instance == (Object)(object)this)
			{
				return isOpen;
			}
			return Instance.InstanceIsOpen;
		}
	}
}


public static class ProgressBarUI
{
}


using UnityEngine;

public class RandomObjectEnableOnEnable : MonoBehaviour
{
	public GameObject[] objects;

	public void OnEnable()
	{
		objects[Random.Range(0, objects.Length)].SetActive(true);
	}
}


using Rust.UI;

public class RecordingSaved : SingletonComponent<RecordingSaved>
{
	public RustText Label;
}


using UnityEngine;

public class RepairCostIndicator : SingletonComponent<RepairCostIndicator>, IClientComponent
{
	public RepairCostIndicatorRow[] Rows;

	public CanvasGroup Fader;
}


public class RepairCostIndicatorRow : CostIndicatorRow
{
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

public abstract class RevealTransitionBase : BaseMonoBehaviour
{
	[Serializable]
	public struct Reveal
	{
		public FlexTransition Transition;

		[Min(0f)]
		public float Delay;
	}

	public Reveal[] Reveals = Array.Empty<Reveal>();
}


using System;
using Facepunch.Flexbox;
using UnityEngine;

[Serializable]
public struct Reveal
{
	public FlexTransition Transition;

	[Min(0f)]
	public float Delay;
}


public class RevealTransitionOnEnable : RevealTransitionBase
{
}


using RTLTMPro;
using TMPro;

public class RTLTMP_InputField : TMP_InputField
{
	private static readonly FastStringBuilder inputBuilder = new FastStringBuilder(2048);

	public bool changeAlignment = true;
}


using Rust.UI;
using UnityEngine;

public class Scoreboard : MonoBehaviour, IClientComponent
{
	public class TeamColumn
	{
		public GameObject nameColumn;

		public GameObject[] activeColumns;
	}

	public static Scoreboard instance;

	public RustText scoreboardTitle;

	public RectTransform scoreboardRootContents;

	public RustText scoreLimitText;

	public GameObject teamPrefab;

	public GameObject columnPrefab;

	public GameObject dividerPrefab;

	public Color localPlayerColor;

	public Color otherPlayerColor;

	public TeamColumn[] teamColumns;

	public GameObject[] TeamPanels;
}


using UnityEngine;

public class TeamColumn
{
	public GameObject nameColumn;

	public GameObject[] activeColumns;
}


public class ScrollRectDisable : ListComponent<ScrollRectDisable>
{
}


using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class ScrollRectZoom : MonoBehaviour, IScrollHandler, IEventSystemHandler
{
	public ScrollRectEx scrollRect;

	public float zoom = 1f;

	public float max = 1.5f;

	public float min = 0.5f;

	public bool mouseWheelZoom = true;

	public float scrollAmount = 0.2f;

	public RectTransform rectTransform
	{
		get
		{
			Transform transform = ((Component)scrollRect).transform;
			return (RectTransform)(object)((transform is RectTransform) ? transform : null);
		}
	}

	private void OnEnable()
	{
		SetZoom(zoom);
	}

	public void OnScroll(PointerEventData data)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (mouseWheelZoom)
		{
			SetZoom(zoom + scrollAmount * data.scrollDelta.y);
		}
	}

	public void SetZoom(float z, bool expZoom = true)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		z = Mathf.Clamp(z, min, max);
		zoom = z;
		Vector2 normalizedPosition = scrollRect.normalizedPosition;
		if (expZoom)
		{
			((Transform)scrollRect.content).localScale = Vector3.one * Mathf.Exp(zoom);
		}
		else
		{
			((Transform)scrollRect.content).localScale = Vector3.one * zoom;
		}
		scrollRect.normalizedPosition = normalizedPosition;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class SetMemorySlider : MonoBehaviour
{
	private void Awake()
	{
		((Component)this).GetComponent<Slider>().maxValue = Mathf.Min(4096, SystemInfo.systemMemorySize / 8);
	}
}


using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class SleepingBagButton : MonoBehaviour
{
	public GameObject TimeLockRoot;

	public GameObject LockRoot;

	public GameObject UnavailableRoot;

	public Tooltip unavailableTooltip;

	public Phrase occupied;

	public Phrase underwater;

	public Phrase noRespawnZone;

	public Button ClickButton;

	public TextMeshProUGUI BagName;

	public TextMeshProUGUI ZoneName;

	public TextMeshProUGUI LockTime;

	public Image Icon;

	public Sprite SleepingBagSprite;

	public Sprite BedSprite;

	public Sprite BeachTowelSprite;

	public Sprite CamperSprite;

	public Image CircleRim;

	public Image CircleFill;

	public Image Background;

	public RustButton DeleteButton;

	public Image ConfirmSlider;

	public static Phrase toastHoldToUnclaimBag = new Phrase("hold_unclaim_bag", "Hold down the delete button to unclaim a sleeping bag");

	public GameObject CorpseRoot;

	public Image CorpseBackground;
}


using System.Globalization;
using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class SliderCookie : MonoBehaviour
{
	public void OnEnable()
	{
		RustSlider val = default(RustSlider);
		if (((Component)this).TryGetComponent<RustSlider>(ref val))
		{
			float result;
			float num = (float.TryParse(PlayerPrefs.GetString("SliderCookie_" + ((Object)this).name), NumberStyles.Float, CultureInfo.InvariantCulture, out result) ? result : val.ValueInternal);
			val.ValueInternal = num + 1f;
			val.Value = num;
			((UnityEvent<float>)(object)val.OnChanged).AddListener((UnityAction<float>)OnSliderChanged);
		}
	}

	public void OnDisable()
	{
		RustSlider val = default(RustSlider);
		if (!Application.isQuitting && ((Component)this).TryGetComponent<RustSlider>(ref val))
		{
			((UnityEvent<float>)(object)val.OnChanged).RemoveListener((UnityAction<float>)OnSliderChanged);
		}
	}

	private void OnSliderChanged(float v)
	{
		PlayerPrefs.SetString("SliderCookie_" + ((Object)this).name, v.ToString(CultureInfo.InvariantCulture));
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class StatusPanel : MonoBehaviour
{
	[SerializeField]
	[Header("On Status")]
	private RustText onStatusText;

	[SerializeField]
	private Image onStatusImage;

	[SerializeField]
	[Header("Off Status")]
	private RustText offStatusText;

	[SerializeField]
	private Image offStatusImage;

	public void SetStatus(bool status)
	{
		((Component)onStatusText).gameObject.SetActive(status);
		((Component)offStatusText).gameObject.SetActive(!status);
		((Component)onStatusImage).gameObject.SetActive(status);
		((Component)offStatusImage).gameObject.SetActive(!status);
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;

public class SteamFriendsList : MonoBehaviour
{
	[Serializable]
	public class onFriendSelectedEvent : UnityEvent<ulong, string>
	{
	}

	public RectTransform targetPanel;

	public SteamUserButton userButton;

	public bool IncludeFriendsList = true;

	public bool IncludeRecentlySeen;

	public bool IncludeLastAttacker;

	public bool IncludeRecentlyPlayedWith;

	public bool ShowTeamFirst;

	public bool ExcludeTeamMembers;

	public bool HideSteamIdsInStreamerMode;

	public bool IncludeContacts;

	public bool EnableCopy;

	public bool RefreshOnEnable = true;

	public onFriendSelectedEvent onFriendSelected;

	public Func<ulong, bool> shouldShowPlayer;
}


using System;
using UnityEngine.Events;

[Serializable]
public class onFriendSelectedEvent : UnityEvent<ulong, string>
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class SteamUserButton : MonoBehaviour
{
	public RustButton copyButton;

	public RustText steamName;

	public RustText steamInfo;

	public RawImage avatar;

	public Color colorTeamOnline;

	public Color colorTeamOffline;

	public Color colorFriendOnline;

	public Color colorFriendOffline;

	public Color colorOnline;

	public Color colorOffline;

	public ulong SteamId { get; private set; }

	public string Username { get; private set; }

	public void CopySteamId()
	{
		GUIUtility.systemCopyBuffer = SteamId.ToString();
	}
}


using System;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class TabToggle : MonoBehaviour
{
	public Transform TabHolder;

	public Transform ContentHolder;

	public bool FadeIn;

	public bool FadeOut;

	public void Awake()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)TabHolder))
		{
			return;
		}
		for (int i = 0; i < TabHolder.childCount; i++)
		{
			Button c = ((Component)TabHolder.GetChild(i)).GetComponent<Button>();
			if (Object.op_Implicit((Object)(object)c))
			{
				((UnityEvent)c.onClick).AddListener((UnityAction)delegate
				{
					SwitchTo(c);
				});
			}
		}
	}

	public void SwitchTo(Button sourceTab)
	{
		string name = ((Object)((Component)sourceTab).transform).name;
		if (Object.op_Implicit((Object)(object)TabHolder))
		{
			for (int i = 0; i < TabHolder.childCount; i++)
			{
				Button component = ((Component)TabHolder.GetChild(i)).GetComponent<Button>();
				if (Object.op_Implicit((Object)(object)component))
				{
					((Selectable)component).interactable = ((Object)component).name != name;
				}
			}
		}
		if (!Object.op_Implicit((Object)(object)ContentHolder))
		{
			return;
		}
		for (int j = 0; j < ContentHolder.childCount; j++)
		{
			Transform child = ContentHolder.GetChild(j);
			if (((Object)child).name == name)
			{
				Show(((Component)child).gameObject);
			}
			else
			{
				Hide(((Component)child).gameObject);
			}
		}
	}

	private void Hide(GameObject go)
	{
		if (!go.activeSelf)
		{
			return;
		}
		CanvasGroup val = default(CanvasGroup);
		if (FadeOut && go.TryGetComponent<CanvasGroup>(ref val))
		{
			LeanTween.alphaCanvas(val, 0f, 0.1f).setOnComplete((Action)delegate
			{
				go.SetActive(false);
			});
		}
		else
		{
			go.SetActive(false);
		}
	}

	private void Show(GameObject go)
	{
		if (!go.activeSelf)
		{
			CanvasGroup val = default(CanvasGroup);
			if (FadeIn && go.TryGetComponent<CanvasGroup>(ref val))
			{
				val.alpha = 0f;
				LeanTween.alphaCanvas(val, 1f, 0.1f);
			}
			go.SetActive(true);
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class TeamMemberElement : MonoBehaviour
{
	public RustText nameText;

	public RawImage icon;

	public Color onlineColor;

	public Color offlineColor;

	public Color deadColor;

	public Color woundedColor;

	public RawImage memberIcon;

	public RawImage leaderIcon;

	public RawImage deadIcon;

	public RawImage woundedIcon;

	public int teamIndex;

	public CanvasGroup EditButton;
}


using System;
using Rust.UI;
using UnityEngine;

public class TeamUI : MonoBehaviour
{
	public static Phrase invitePhrase = new Phrase("team.invited", "{0} has invited you to join a team");

	public RectTransform MemberPanel;

	public GameObject memberEntryPrefab;

	public GameObjectRef InviteFriendDialog;

	public TeamMemberElement[] elements;

	public GameObject NoTeamPanel;

	public GameObject TeamPanel;

	public GameObject LeaveTeamButton;

	public GameObject InviteAcceptPanel;

	public GameObject InviteButton;

	public RustText inviteText;

	public static bool dirty = true;

	[NonSerialized]
	public static ulong pendingTeamID;

	[NonSerialized]
	public static string pendingTeamLeaderName;

	public GameObject teamMemberDetailsPanel;

	public RustText selectedTeamMemberNameText;
}


using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class TextEntryCookie : MonoBehaviour
{
	public InputField control => ((Component)this).GetComponent<InputField>();

	private void OnEnable()
	{
		string @string = PlayerPrefs.GetString("TextEntryCookie_" + ((Object)this).name);
		if (!string.IsNullOrEmpty(@string))
		{
			control.text = @string;
		}
		((UnityEvent<string>)(object)control.onValueChanged).Invoke(control.text);
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			PlayerPrefs.SetString("TextEntryCookie_" + ((Object)this).name, control.text);
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class TimeSlider : MonoBehaviour
{
	private Slider slider;

	private void Start()
	{
		slider = ((Component)this).GetComponent<Slider>();
	}

	private void Update()
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			slider.value = TOD_Sky.Instance.Cycle.Hour;
		}
	}

	public void OnValue(float f)
	{
		if (!((Object)(object)TOD_Sky.Instance == (Object)null))
		{
			TOD_Sky.Instance.Cycle.Hour = f;
			TOD_Sky.Instance.UpdateAmbient();
			TOD_Sky.Instance.UpdateReflection();
			TOD_Sky.Instance.UpdateFog();
		}
	}
}


using Rust;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;

public class ToggleCookie : MonoBehaviour
{
	public void OnEnable()
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Expected O, but got Unknown
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Expected O, but got Unknown
		RustButton val = default(RustButton);
		if (((Component)this).TryGetComponent<RustButton>(ref val))
		{
			bool result;
			bool flag = (bool.TryParse(PlayerPrefs.GetString("ToggleCookie_" + ((Object)this).name), out result) ? result : val.Value);
			val.Toggle(flag, true, true);
			val.OnPressed.AddListener(new UnityAction(OnPressed));
			val.OnReleased.AddListener(new UnityAction(OnReleased));
		}
	}

	public void OnDisable()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Expected O, but got Unknown
		RustButton val = default(RustButton);
		if (!Application.isQuitting && ((Component)this).TryGetComponent<RustButton>(ref val))
		{
			val.OnPressed.RemoveListener(new UnityAction(OnPressed));
			val.OnReleased.RemoveListener(new UnityAction(OnReleased));
		}
	}

	private void OnPressed()
	{
		OnChanged(v: true);
	}

	private void OnReleased()
	{
		OnChanged(v: false);
	}

	private void OnChanged(bool v)
	{
		PlayerPrefs.SetString("ToggleCookie_" + ((Object)this).name, v.ToString());
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Rust;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class ToggleGroupCookie : MonoBehaviour
{
	public ToggleGroup group => ((Component)this).GetComponent<ToggleGroup>();

	private void OnEnable()
	{
		string @string = PlayerPrefs.GetString("ToggleGroupCookie_" + ((Object)this).name);
		if (!string.IsNullOrEmpty(@string))
		{
			Transform val = FindChild(((Component)this).transform, @string);
			if (Object.op_Implicit((Object)(object)val))
			{
				Toggle component = ((Component)val).GetComponent<Toggle>();
				if (Object.op_Implicit((Object)(object)component))
				{
					Toggle[] componentsInChildren = ((Component)this).GetComponentsInChildren<Toggle>(true);
					for (int i = 0; i < componentsInChildren.Length; i++)
					{
						componentsInChildren[i].isOn = false;
					}
					component.isOn = false;
					component.isOn = true;
					SetupListeners();
					return;
				}
			}
		}
		Toggle val2 = group.ActiveToggles().FirstOrDefault((Func<Toggle, bool>)((Toggle x) => x.isOn));
		if (Object.op_Implicit((Object)(object)val2))
		{
			val2.isOn = false;
			val2.isOn = true;
		}
		SetupListeners();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Toggle[] componentsInChildren = ((Component)this).GetComponentsInChildren<Toggle>(true);
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				((UnityEvent<bool>)(object)componentsInChildren[i].onValueChanged).RemoveListener((UnityAction<bool>)OnToggleChanged);
			}
		}
	}

	private void SetupListeners()
	{
		Toggle[] componentsInChildren = ((Component)this).GetComponentsInChildren<Toggle>(true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			((UnityEvent<bool>)(object)componentsInChildren[i].onValueChanged).AddListener((UnityAction<bool>)OnToggleChanged);
		}
	}

	private void OnToggleChanged(bool b)
	{
		Toggle val = ((IEnumerable<Toggle>)((Component)this).GetComponentsInChildren<Toggle>()).FirstOrDefault((Func<Toggle, bool>)((Toggle x) => x.isOn));
		if (Object.op_Implicit((Object)(object)val))
		{
			PlayerPrefs.SetString("ToggleGroupCookie_" + ((Object)this).name, ((Object)((Component)val).gameObject).name);
		}
	}

	private static Transform FindChild(Transform parent, string name)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		foreach (Transform item in parent)
		{
			Transform val = item;
			if (((Object)val).name == name)
			{
				return val;
			}
		}
		return null;
	}
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class ToolsHUDUI : MonoBehaviour
{
	[SerializeField]
	private GameObject prefab;

	[SerializeField]
	private Transform parent;

	private bool initialised;

	protected void OnEnable()
	{
		Init();
	}

	private void Init()
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Expected O, but got Unknown
		if (initialised)
		{
			return;
		}
		UIHUD instance = SingletonComponent<UIHUD>.Instance;
		if ((Object)(object)instance == (Object)null)
		{
			return;
		}
		initialised = true;
		Transform[] componentsInChildren = ((Component)instance).GetComponentsInChildren<Transform>();
		foreach (Transform val in componentsInChildren)
		{
			string name = ((Object)val).name;
			if (!name.ToLower().StartsWith("gameui.hud."))
			{
				continue;
			}
			if (name.ToLower() == "gameui.hud.crosshair")
			{
				foreach (Transform item in val)
				{
					Transform val2 = item;
					AddToggleObj(((Object)val2).name, "<color=yellow>Crosshair sub:</color> " + ((Object)val2).name);
				}
			}
			AddToggleObj(name, name.Substring(11));
		}
	}

	private void AddToggleObj(string trName, string labelText)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = Object.Instantiate<GameObject>(prefab, Vector3.zero, Quaternion.identity, parent);
		((Object)obj).name = trName;
		ToggleHUDLayer component = obj.GetComponent<ToggleHUDLayer>();
		component.hudComponentName = trName;
		((TMP_Text)component.textControl).text = labelText;
	}

	public void SelectAll()
	{
		Toggle[] componentsInChildren = ((Component)parent).GetComponentsInChildren<Toggle>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isOn = true;
		}
	}

	public void SelectNone()
	{
		Toggle[] componentsInChildren = ((Component)parent).GetComponentsInChildren<Toggle>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].isOn = false;
		}
	}
}


using Rust.Localization;
using UnityEngine;

public class Tooltip : BaseMonoBehaviour, IClientComponent, ILocalize
{
	public enum DelayType
	{
		Short,
		Long
	}

	public static TooltipContainer Current;

	public GameObject TooltipObject;

	public Phrase phrase;

	[Tooltip("Delay timing before the tooltip appears. Short is 0.15 seconds, Long is 0.5 seconds.")]
	[Header("Additional Settings - Delay")]
	[Space(10f)]
	public DelayType delayBeforeAppearing;

	[Header("Advanced Settings - Position")]
	[Tooltip("What position relative to the object that the tooltip should be spawned on.")]
	[Space(10f)]
	public TooltipContainer.PositionMode positionMode;

	[Tooltip("Spawn the tooltip relative to the mouse position rather than the objects.")]
	public bool useMousePosition;

	[Tooltip("Anchor tooltip at the centre of the object rather than a specific side.")]
	public bool useCentre;

	[Tooltip("Use percentage of source width/Height for horizontal offset in Left/Right or Up/Down mode.")]
	public bool usePercentageOffset;

	[Tooltip("Percentage of the source rect width to offset (0.0 - 1.0).")]
	public float offsetPercent;

	[Tooltip("How far to spawn from the objects position")]
	public Vector2 offset = new Vector2(8f, 8f);

	private object[] localizationArguments;

	public string Text
	{
		get
		{
			return phrase.english;
		}
		set
		{
			phrase.english = value;
		}
	}

	public string LanguageToken => phrase.token;

	public string LanguageEnglish => phrase.english;
}


public enum DelayType
{
	Short,
	Long
}


using Rust.UI;
using UnityEngine;

public class TooltipContainer : MonoBehaviour
{
	public enum PositionMode
	{
		Auto,
		Top,
		Bottom,
		Left,
		Right,
		TopLeft
	}

	public Transform ScaleRoot;

	public RustText TooltipText;

	public RectTransform OverrideLayoutRoot;
}


public enum PositionMode
{
	Auto,
	Top,
	Bottom,
	Left,
	Right,
	TopLeft
}


public class TooltipContainer_Emoji : TooltipContainer
{
	public TmProEmojiRedirector EmojiRedirector;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Video;

public class TutorialHelpPopup : ListComponent<TutorialHelpPopup>
{
	public RustText HelpText;

	public Image HelpImage;

	public VideoPlayer HelpVideo;

	public RawImage HelpVideoTexture;

	public CanvasGroup Group;

	public Canvas Canvas;
}


public class TutorialStartModal : UIDialog
{
}


using System.Collections;
using Rust;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class TypeThroughButton : Button, IUpdateSelectedHandler, IEventSystemHandler
{
	public InputField typingTarget;

	private Event _processingEvent = new Event();

	public void OnUpdateSelected(BaseEventData eventData)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Invalid comparison between Unknown and I4
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected O, but got Unknown
		if ((Object)(object)typingTarget == (Object)null)
		{
			return;
		}
		while (Event.PopEvent(_processingEvent))
		{
			if ((int)_processingEvent.rawType == 4 && _processingEvent.character != 0)
			{
				Event e = new Event(_processingEvent);
				((MonoBehaviour)Global.Runner).StartCoroutine(DelayedActivateTextField(e));
				break;
			}
		}
		((AbstractEventData)eventData).Use();
	}

	private IEnumerator DelayedActivateTextField(Event e)
	{
		typingTarget.ActivateInputField();
		((Selectable)typingTarget).Select();
		if (e.character != ' ')
		{
			InputField obj = typingTarget;
			obj.text += " ";
		}
		typingTarget.MoveTextEnd(false);
		typingTarget.ProcessEvent(e);
		yield return null;
		typingTarget.caretPosition = typingTarget.text.Length;
		typingTarget.ForceLabelUpdate();
	}
}


using UnityEngine;

public class UIAutoPanelCloser : MonoBehaviour
{
	public UIDialog Dialog;
}


using UnityEngine;

public class UIBackgroundBlur : ListComponent<UIBackgroundBlur>, IClientComponent
{
	public float amount = 1f;

	public static float currentMax
	{
		get
		{
			if (ListComponent<UIBackgroundBlur>.InstanceList.Count == 0)
			{
				return 0f;
			}
			float num = 0f;
			for (int i = 0; i < ListComponent<UIBackgroundBlur>.InstanceList.Count; i++)
			{
				num = Mathf.Max(ListComponent<UIBackgroundBlur>.InstanceList[i].amount, num);
			}
			return num;
		}
	}
}


using Rust.UI;

public class UIBinocularOverlay : UIBlackoutOverlay
{
	public RustText RangeText;
}


public class UIBlackoutDeathOverlay : UIBlackoutOverlay
{
}


using System.Collections.Generic;
using UnityEngine;

public class UIBlackoutOverlay : MonoBehaviour
{
	public enum blackoutType
	{
		FULLBLACK = 0,
		BINOCULAR = 1,
		SCOPE = 2,
		HELMETSLIT = 3,
		SNORKELGOGGLE = 4,
		NVG = 5,
		FULLWHITE = 6,
		SUNGLASSES = 7,
		PRISONERHOOD = 8,
		DEATH = 9,
		OBSCUREVISION = 10,
		NONE = 64
	}

	public CanvasGroup group;

	public static Dictionary<blackoutType, UIBlackoutOverlay> instances;

	public blackoutType overlayType = blackoutType.NONE;

	public bool overrideCanvasScaling;

	public float referenceScale = 1f;
}


public enum blackoutType
{
	FULLBLACK = 0,
	BINOCULAR = 1,
	SCOPE = 2,
	HELMETSLIT = 3,
	SNORKELGOGGLE = 4,
	NVG = 5,
	FULLWHITE = 6,
	SUNGLASSES = 7,
	PRISONERHOOD = 8,
	DEATH = 9,
	OBSCUREVISION = 10,
	NONE = 64
}


using System;
using Rust.UI;
using UnityEngine;

public class UICameraOverlay : SingletonComponent<UICameraOverlay>
{
	public static readonly Phrase FocusOffText = new Phrase("camera.infinite_focus", "Infinite Focus");

	public static readonly Phrase FocusAutoText = new Phrase("camera.auto_focus", "Auto Focus");

	public static readonly Phrase FocusManualText = new Phrase("camera.manual_focus", "Manual Focus");

	public static readonly Phrase FlashOn = new Phrase("camera.flash_is_on", "Flash [ON]");

	public static readonly Phrase FlashOff = new Phrase("camera.flash_is_off", "Flash [OFF]");

	public CanvasGroup CanvasGroup;

	public RustText FocusModeLabel;

	public RustText FlashLabel;

	public void Show()
	{
		CanvasGroup.alpha = 1f;
	}

	public void Hide()
	{
		CanvasGroup.alpha = 0f;
	}

	public void SetFlash(bool flashEnabled)
	{
		FlashLabel.SetPhrase(flashEnabled ? FlashOn : FlashOff, Array.Empty<object>());
	}

	public void SetFocusMode(CameraFocusMode mode)
	{
		switch (mode)
		{
		case CameraFocusMode.Auto:
			FocusModeLabel.SetPhrase(FocusAutoText, Array.Empty<object>());
			break;
		case CameraFocusMode.Manual:
			FocusModeLabel.SetPhrase(FocusManualText, Array.Empty<object>());
			break;
		default:
			FocusModeLabel.SetPhrase(FocusOffText, Array.Empty<object>());
			break;
		}
	}
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIConversationScreen : SingletonComponent<UIConversationScreen>, IUIScreen
{
	public NeedsCursor needsCursor;

	public RectTransform conversationPanel;

	public RustText conversationSpeechBody;

	public RustText conversationProviderName;

	public Image conversationProviderImage;

	public RustButton[] responseButtons;

	public RectTransform letterBoxTop;

	public RectTransform letterBoxBottom;

	public CanvasGroup responseCanvasGroup;

	public GameObject cancelButton;

	protected CanvasGroup canvasGroup;

	public UIMissionInfoConversation missionInfo;

	public UIMissionInfoConversation missionInfoComplete;

	public CanvasGroup conversationCanvas;

	public UIEscapeCapture escapeCapture;
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class UIDeathScreen : SingletonComponent<UIDeathScreen>, IUIScreen
{
	[Serializable]
	public struct RespawnColourScheme
	{
		public Color BackgroundColour;

		public Color CircleRimColour;

		public Color CircleFillColour;
	}

	public LifeInfographic previousLifeInfographic;

	public Animator screenAnimator;

	public bool fadeIn;

	public Button ReportCheatButton;

	public MapView View;

	public List<SleepingBagButton> sleepingBagButtons = new List<SleepingBagButton>();

	public GameObject loadingIndicator;

	public RespawnColourScheme[] RespawnColourSchemes;

	public GameObject RespawnScrollGradient;

	public ScrollRect RespawnScrollRect;

	public ExpandedLifeStats ExpandedStats;

	public GameObject OpenStatsButton;

	public CanvasGroup StreamerModeContainer;

	public GameObject SafeZoneInfo;

	public Image FadeImage;
}


using System;
using UnityEngine;

[Serializable]
public struct RespawnColourScheme
{
	public Color BackgroundColour;

	public Color CircleRimColour;

	public Color CircleFillColour;
}


using System;
using UnityEngine;
using UnityEngine.Events;

public class UIEscapeCapture : ListComponent<UIEscapeCapture>
{
	public UnityEvent onEscape = new UnityEvent();

	[Tooltip("If true, pressing escape will call only this callback and not any others.")]
	public bool blockOtherCallbacks = true;

	[Tooltip("Set this to true if you want this EscapeCapture to take priority over any older EscapeCapture when enabled. Surely this should be default?")]
	public bool insertAtTop = true;

	[ClientVar(ClientAdmin = true)]
	public static bool debug;

	public override void Setup()
	{
		if (!ListComponent<UIEscapeCapture>.InstanceList.Contains(this))
		{
			if (insertAtTop && ListComponent<UIEscapeCapture>.InstanceList.Count > 0)
			{
				ListComponent<UIEscapeCapture>.InstanceList.Insert(0, this);
			}
			else
			{
				ListComponent<UIEscapeCapture>.InstanceList.Add(this);
			}
		}
	}

	public static bool EscapePressed()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<UIEscapeCapture> enumerator = ListComponent<UIEscapeCapture>.InstanceList.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				UIEscapeCapture current = enumerator.Current;
				if (debug)
				{
					Debug.Log((object)("Escape key pressed by: " + ((object)current).GetType().Name + " - " + ((Object)current).name));
				}
				current.onEscape.Invoke();
				if (current.blockOtherCallbacks)
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIFogOverlay : MonoBehaviour
{
	public static UIFogOverlay Instance;

	public CanvasGroup group;

	public Color baseColor;

	public Image overlayImage;
}


using UnityEngine;
using UnityEngine.UI;

public class UIGene : MonoBehaviour
{
	public GameObject Child;

	public Color PositiveColour;

	public Color NegativeColour;

	public Color PositiveTextColour;

	public Color NegativeTextColour;

	public Image ImageBG;

	public Text TextGene;

	public void Init(GrowableGene gene)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		bool flag = gene.IsPositive();
		((Graphic)ImageBG).color = (flag ? PositiveColour : NegativeColour);
		((Graphic)TextGene).color = (flag ? PositiveTextColour : NegativeTextColour);
		TextGene.text = gene.GetDisplayCharacter();
		Show();
	}

	public void InitPrevious(GrowableGene gene)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		((Graphic)ImageBG).color = Color.black;
		((Graphic)TextGene).color = Color.grey;
		TextGene.text = GrowableGene.GetDisplayCharacter(gene.PreviousType);
		Show();
	}

	public void Hide()
	{
		Child.gameObject.SetActive(false);
	}

	public void Show()
	{
		Child.gameObject.SetActive(true);
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIGenesDisplay : MonoBehaviour
{
	public UIGene[] GeneUI;

	public Text[] TextLinks;

	public Text[] TextDiagLinks;

	public void Init(GrowableGenes genes)
	{
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		GrowableGene[] genes2 = genes.Genes;
		foreach (GrowableGene gene in genes2)
		{
			GeneUI[num].Init(gene);
			num++;
			if (num < genes.Genes.Length)
			{
				((Graphic)TextLinks[num - 1]).color = (genes.Genes[num].IsPositive() ? GeneUI[num - 1].PositiveColour : GeneUI[num - 1].NegativeColour);
			}
		}
	}

	public void InitDualRow(GrowableGenes genes, bool firstRow)
	{
		if (firstRow)
		{
			InitFirstRow(genes);
		}
		else
		{
			InitSecondRow(genes);
		}
	}

	private void InitFirstRow(GrowableGenes genes)
	{
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		GrowableGene[] genes2 = genes.Genes;
		foreach (GrowableGene growableGene in genes2)
		{
			if (growableGene.Type != growableGene.PreviousType)
			{
				GeneUI[num].InitPrevious(growableGene);
			}
			else
			{
				GeneUI[num].Init(growableGene);
			}
			num++;
			if (num >= genes.Genes.Length)
			{
				break;
			}
			if (growableGene.Type != growableGene.PreviousType || genes.Genes[num].Type != genes.Genes[num].PreviousType)
			{
				((Behaviour)TextLinks[num - 1]).enabled = false;
				continue;
			}
			((Behaviour)TextLinks[num - 1]).enabled = true;
			((Graphic)TextLinks[num - 1]).color = (genes.Genes[num].IsPositive() ? GeneUI[num - 1].PositiveColour : GeneUI[num - 1].NegativeColour);
		}
	}

	private void InitSecondRow(GrowableGenes genes)
	{
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		GrowableGene[] genes2 = genes.Genes;
		foreach (GrowableGene growableGene in genes2)
		{
			if (growableGene.Type != growableGene.PreviousType)
			{
				GeneUI[num].Init(growableGene);
			}
			else
			{
				GeneUI[num].Hide();
			}
			num++;
			if (num >= genes.Genes.Length)
			{
				break;
			}
			((Behaviour)TextLinks[num - 1]).enabled = false;
			GrowableGene growableGene2 = genes.Genes[num];
			((Behaviour)TextDiagLinks[num - 1]).enabled = false;
			if (growableGene.Type != growableGene.PreviousType && growableGene2.Type != growableGene2.PreviousType)
			{
				((Behaviour)TextLinks[num - 1]).enabled = true;
				((Graphic)TextLinks[num - 1]).color = (growableGene2.IsPositive() ? GeneUI[num - 1].PositiveColour : GeneUI[num - 1].NegativeColour);
			}
			else if (growableGene.Type == growableGene.PreviousType && growableGene2.Type != growableGene2.PreviousType)
			{
				ShowDiagLink(num - 1, -43f, growableGene2);
			}
			else if (growableGene.Type != growableGene.PreviousType && growableGene2.Type == growableGene2.PreviousType)
			{
				ShowDiagLink(num - 1, 43f, growableGene2);
			}
		}
	}

	private void ShowDiagLink(int index, float rotation, GrowableGene nextGene)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		Vector3 localEulerAngles = ((Component)TextDiagLinks[index]).transform.localEulerAngles;
		localEulerAngles.z = rotation;
		((Component)TextDiagLinks[index]).transform.localEulerAngles = localEulerAngles;
		((Behaviour)TextDiagLinks[index]).enabled = true;
		((Graphic)TextDiagLinks[index]).color = (nextGene.IsPositive() ? GeneUI[index].PositiveColour : GeneUI[index].NegativeColour);
	}
}


using UnityEngine;

public class UIGodOverlay : SingletonComponent<UIGodOverlay>
{
	public CanvasGroup invisCanvas;
}


public class UIIngame : SingletonComponent<UIIngame>
{
}


using UnityEngine;

public class UIInvisOverlay : SingletonComponent<UIInvisOverlay>
{
	public CanvasGroup invisCanvas;
}


using Rust.UI;
using UnityEngine;

public class UIMissionInfoConversation : MonoBehaviour
{
	public RustText MissionName;

	public RustText[] MissionObjectives;

	public GameObject TimerRoot;

	public RustText TimerText;

	public VirtualItemIcon[] RewardIcons;

	public UIMissionNonItemReward[] NonItemRewards;
}


using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIMissionNonItemReward : MonoBehaviour
{
	public RustText TextField;

	public Image Icon;

	public void Populate(BaseMission.NonItemReward reward)
	{
		TextField.SetPhrase(reward.DisplayPhrase, Array.Empty<object>());
		Icon.sprite = reward.DisplaySprite;
	}
}


public class UIObscureVisionOverlay : UIBlackoutOverlay
{
	public float FadeSpeed = 10f;
}


using UnityEngine;
using UnityEngine.UI;

public class UIPixelDownscale : MonoBehaviour
{
	public CanvasScaler CanvasScaler;

	private void Awake()
	{
		if ((Object)(object)CanvasScaler == (Object)null)
		{
			CanvasScaler = ((Component)this).GetComponent<CanvasScaler>();
			if ((Object)(object)CanvasScaler == (Object)null)
			{
				Debug.LogError((object)(((object)this).GetType().Name + " is attached to a gameobject that is missing a canvas scaler"));
				Object.Destroy((Object)(object)((Component)this).gameObject);
			}
		}
	}

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if ((float)Screen.width < CanvasScaler.referenceResolution.x || (float)Screen.height < CanvasScaler.referenceResolution.y)
		{
			CanvasScaler.uiScaleMode = (ScaleMode)0;
		}
		else
		{
			CanvasScaler.uiScaleMode = (ScaleMode)1;
		}
	}
}


using Facepunch;
using UnityEngine;

public class UIPrefab : MonoBehaviour
{
	public GameObject prefabSource;

	internal GameObject createdGameObject;

	private void Awake()
	{
		if (!((Object)(object)prefabSource == (Object)null) && !((Object)(object)createdGameObject != (Object)null))
		{
			createdGameObject = Instantiate.GameObject(prefabSource, (Transform)null);
			((Object)createdGameObject).name = ((Object)prefabSource).name;
			createdGameObject.transform.SetParent(((Component)this).transform, false);
			createdGameObject.Identity();
		}
	}

	public void SetVisible(bool visible)
	{
		if (!((Object)(object)createdGameObject == (Object)null) && createdGameObject.activeSelf != visible)
		{
			createdGameObject.SetActive(visible);
		}
	}
}


public class UIPrisonerHoodOverlay : UIBlackoutOverlay
{
}


using UnityEngine;
using UnityEngine.UI;

public abstract class UIRoot : MonoBehaviour
{
	private GraphicRaycaster[] graphicRaycasters;

	public Canvas overlayCanvas;

	private void ToggleRaycasters(bool state)
	{
		for (int i = 0; i < graphicRaycasters.Length; i++)
		{
			GraphicRaycaster val = graphicRaycasters[i];
			if (((Behaviour)val).enabled != state)
			{
				((Behaviour)val).enabled = state;
			}
		}
	}

	protected virtual void Awake()
	{
	}

	protected virtual void Start()
	{
		graphicRaycasters = ((Component)this).GetComponentsInChildren<GraphicRaycaster>(true);
	}

	protected void Update()
	{
		Refresh();
	}

	protected abstract void Refresh();
}


public class UIRootPixel : UIRoot
{
	protected override void Refresh()
	{
	}
}


using ConVar;
using UnityEngine;
using UnityEngine.UI;

public class UIRootScaled : UIRoot
{
	private static UIRootScaled Instance;

	public bool OverrideReference;

	public Vector2 TargetReference = new Vector2(1280f, 720f);

	public CanvasScaler scaler;

	public static Canvas DragOverlayCanvas => Instance.overlayCanvas;

	protected override void Awake()
	{
		Instance = this;
		base.Awake();
	}

	protected override void Refresh()
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1280f / Graphics.uiscale, 720f / Graphics.uiscale);
		if (OverrideReference)
		{
			((Vector2)(ref val))..ctor(TargetReference.x / Graphics.uiscale, TargetReference.y / Graphics.uiscale);
		}
		if (scaler.referenceResolution != val)
		{
			scaler.referenceResolution = val;
		}
	}
}


using UnityEngine;
using UnityEngine.UI;

public class UIScale : MonoBehaviour, IClientComponent
{
	public CanvasScaler scaler;
}


using UnityEngine;

public class UIScalerOverride : MonoBehaviour
{
	public AnimationCurve scaleCurve = AnimationCurve.Linear(0f, 2f, 1f, 1f);
}


using UnityEngine;
using UnityEngine.UI;

public class UIScopeOverlay : MonoBehaviour
{
	public CanvasGroup group;

	public static UIScopeOverlay instance;

	public Image scopeImage;
}


public interface IUIScreen
{
}


using TMPro;
using UnityEngine;

public class UISleepingScreen : SingletonComponent<UISleepingScreen>, IUIScreen
{
	protected CanvasGroup canvasGroup;

	private bool visible;

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
		canvasGroup = ((Component)this).GetComponent<CanvasGroup>();
		visible = true;
	}

	public void SetVisible(bool b)
	{
		if (visible != b)
		{
			visible = b;
			canvasGroup.alpha = (visible ? 1f : 0f);
			((Component)SingletonComponent<UISleepingScreen>.Instance).gameObject.SetChildComponentsEnabled<TMP_Text>(visible);
		}
	}
}


using UnityEngine;

public class UISoundPlayer : MonoBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class UIVoiceIcon : MonoBehaviour
{
	public Text nameText;

	public RawImage avatar;
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class UIWounded : MonoBehaviour
{
	public CanvasGroup group;

	public Image chanceFill;

	public RustText chanceText;

	public Image timeRemainingFill;

	public RustText timeRemainingText;
}


using UnityEngine;

public class UI_LocalVoice : PriorityListComponent<UI_LocalVoice>
{
	public CanvasGroup voiceCanvas;

	public CanvasGroup levelImage;
}


using System;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class DragMe : MonoBehaviour, IBeginDragHandler, IEventSystemHandler, IDragHandler, IEndDragHandler
{
	public static DragMe dragging;

	public static GameObject dragIcon;

	public static Image dragImage;

	public static object data;

	[NonSerialized]
	public string dragType = "generic";

	protected virtual Canvas TopCanvas => UIRootScaled.DragOverlayCanvas;

	public virtual void OnBeginDrag(PointerEventData eventData)
	{
	}

	public virtual void OnDrag(PointerEventData eventData)
	{
	}

	public static void SetDropAppearance()
	{
	}

	public virtual void OnEndDrag(PointerEventData eventData)
	{
	}

	public void CancelDrag()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Expected O, but got Unknown
		OnEndDrag(new PointerEventData(EventSystem.current));
	}
}


public interface IDraggable
{
}


using UnityEngine;

public class DragMeCustomParent : DragMe
{
	public Canvas OverrideCanvas;

	public bool ShouldCancelOnDrop;
}


using UnityEngine;
using UnityEngine.EventSystems;

public class DropMe : MonoBehaviour, IDropHandler, IEventSystemHandler
{
	public string[] droppableTypes;

	public virtual void OnDrop(PointerEventData eventData)
	{
	}
}


using UnityEngine;
using UnityEngine.UI;

public class GridLayoutGroupNeat : GridLayoutGroup
{
	private float IdealCellWidth(float cellSize)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		Rect rect = ((LayoutGroup)this).rectTransform.rect;
		float num = ((Rect)(ref rect)).x + (float)(((LayoutGroup)this).padding.left + ((LayoutGroup)this).padding.right) * 0.5f;
		float num2 = Mathf.Floor(num / cellSize);
		return num / num2 - base.m_Spacing.x;
	}

	public override void SetLayoutHorizontal()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 cellSize = base.m_CellSize;
		base.m_CellSize.x = IdealCellWidth(cellSize.x);
		((GridLayoutGroup)this).SetLayoutHorizontal();
		base.m_CellSize = cellSize;
	}

	public override void SetLayoutVertical()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		Vector2 cellSize = base.m_CellSize;
		base.m_CellSize.x = IdealCellWidth(cellSize.x);
		((GridLayoutGroup)this).SetLayoutVertical();
		base.m_CellSize = cellSize;
	}
}


using Rust.Localization;
using UnityEngine;

public class LocalizeText : MonoBehaviour, IClientComponent, ILocalize
{
	public enum SpecialMode
	{
		None,
		AllUppercase,
		AllLowercase
	}

	[LocalizationToken]
	public string token;

	public string append;

	public SpecialMode specialMode;

	public string LanguageToken
	{
		get
		{
			return token;
		}
		set
		{
			token = value;
		}
	}

	public string LanguageEnglish => Translate.Get(token, (string)null, false);
}


public enum SpecialMode
{
	None,
	AllUppercase,
	AllLowercase
}


using UnityEngine.UI;

public class NonDrawingGraphic : Graphic
{
	public override void SetMaterialDirty()
	{
	}

	public override void SetVerticesDirty()
	{
	}

	protected override void OnPopulateMesh(VertexHelper vh)
	{
		vh.Clear();
	}
}


using UnityEngine.Events;
using UnityEngine.EventSystems;

public class RectChangeEvent : UIBehaviour
{
	public UnityEvent action;

	protected override void OnRectTransformDimensionsChange()
	{
		action.Invoke();
	}
}


using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

public class RightClickReceiver : MonoBehaviour, IPointerClickHandler, IEventSystemHandler
{
	public UnityEvent ClickReceiver;

	public void OnPointerClick(PointerEventData eventData)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Invalid comparison between Unknown and I4
		if ((int)eventData.button == 1)
		{
			UnityEvent clickReceiver = ClickReceiver;
			if (clickReceiver != null)
			{
				clickReceiver.Invoke();
			}
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class AlphaSinPulse : MonoBehaviour
{
	public CanvasGroup target;

	public float speed = 3f;

	public float amplitude = 2f;

	public bool preview;
}


using UnityEngine;

public static class EaseExtensions
{
	public static AnimationCurve FadeInFadeOutCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.5f, 1f),
		new Keyframe(1f, 0f)
	});
}


using UnityEngine;

public class ShowIfConvarEnabled : MonoBehaviour
{
	public string Convar = "";
}


using UnityEngine;

public class WorkshopSettingsSwitcher : MonoBehaviour
{
	public TextAsset SettingsFile;
}


public interface IVitalNotice
{
}


using Rust.UI;
using UnityEngine;
using UnityEngine.UI;

public class VitalInfo : MonoBehaviour, IClientComponent, IVitalNotice
{
	public enum Vital
	{
		BuildingBlocked,
		CanBuild,
		Crafting,
		CraftLevel1,
		CraftLevel2,
		CraftLevel3,
		DecayProtected,
		Decaying,
		SafeZone,
		Buffed,
		Pet,
		ModifyClan,
		DartEffects,
		NegativeEffects
	}

	public HudElement Element;

	public Image InfoImage;

	public Vital VitalType;

	public RustText text;

	public static readonly Phrase BoostActive = new Phrase("tea.boostactive", "{0} Boost active");

	public static readonly Phrase BoostsActive = new Phrase("tea.boostactive.plural", "{0} Boosts active");

	public static readonly Phrase DartEffectActive = new Phrase("dart.effectactive", "{0} dart effect");

	public static readonly Phrase DartEffectsActive = new Phrase("dart.effectactive.plural", "{0} dart effects");

	public static readonly Phrase NegativeEffectActive = new Phrase("negative.active", "{0} negative effect");

	public static readonly Phrase NegativeEffectsActive = new Phrase("negative.active.plural", "{0} negative effects");
}


public enum Vital
{
	BuildingBlocked,
	CanBuild,
	Crafting,
	CraftLevel1,
	CraftLevel2,
	CraftLevel3,
	DecayProtected,
	Decaying,
	SafeZone,
	Buffed,
	Pet,
	ModifyClan,
	DartEffects,
	NegativeEffects
}


using TMPro;
using UnityEngine;

public class VitalNote : MonoBehaviour, IClientComponent, IVitalNotice
{
	public enum Vital
	{
		Comfort,
		Radiation,
		Poison,
		Cold,
		Bleeding,
		Hot,
		Oxygen,
		Wet,
		Hygiene,
		Starving,
		Dehydration
	}

	public Vital VitalType;

	public FloatConditions showIf;

	public TextMeshProUGUI valueText;
}


public enum Vital
{
	Comfort,
	Radiation,
	Poison,
	Cold,
	Bleeding,
	Hot,
	Oxygen,
	Wet,
	Hygiene,
	Starving,
	Dehydration
}


using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class VitalNoteOxygen : MonoBehaviour, IClientComponent, IVitalNotice
{
	[SerializeField]
	private float refreshTime = 1f;

	[SerializeField]
	private TextMeshProUGUI valueText;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private Image airIcon;

	[SerializeField]
	private RectTransform airIconTr;

	[SerializeField]
	private Image backgroundImage;

	[SerializeField]
	private Color baseColour;

	[SerializeField]
	private Color badColour;

	[SerializeField]
	private Image iconImage;

	[SerializeField]
	private Color iconBaseColour;

	[SerializeField]
	private Color iconBadColour;

	protected bool show = true;
}


using UnityEngine;

public class VitalRadial : MonoBehaviour
{
	private void Awake()
	{
		Debug.LogWarning((object)("VitalRadial is obsolete " + ((Component)this).transform.GetRecursiveName()), (Object)(object)((Component)this).gameObject);
	}
}


using UnityEngine;

public class WorkshopWeather : MonoBehaviour
{
}


using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering;

public class BaseCommandBuffer : MonoBehaviour
{
	private Dictionary<Camera, Dictionary<int, CommandBuffer>> cameras = new Dictionary<Camera, Dictionary<int, CommandBuffer>>();

	protected CommandBuffer GetCommandBuffer(string name, Camera camera, CameraEvent cameraEvent)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Expected I4, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Expected O, but got Unknown
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Expected I4, but got Unknown
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		if (!cameras.TryGetValue(camera, out var value))
		{
			value = new Dictionary<int, CommandBuffer>();
			cameras.Add(camera, value);
		}
		if (value.TryGetValue((int)cameraEvent, out var value2))
		{
			value2.Clear();
		}
		else
		{
			value2 = new CommandBuffer();
			value2.name = name;
			value.Add((int)cameraEvent, value2);
			CleanupCamera(name, camera, cameraEvent);
			camera.AddCommandBuffer(cameraEvent, value2);
		}
		return value2;
	}

	protected void CleanupCamera(string name, Camera camera, CameraEvent cameraEvent)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer[] commandBuffers = camera.GetCommandBuffers(cameraEvent);
		foreach (CommandBuffer val in commandBuffers)
		{
			if (val.name == name)
			{
				camera.RemoveCommandBuffer(cameraEvent, val);
			}
		}
	}

	protected void CleanupCommandBuffer(Camera camera, CameraEvent cameraEvent)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Expected I4, but got Unknown
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (cameras.TryGetValue(camera, out var value) && value.TryGetValue((int)cameraEvent, out var value2))
		{
			camera.RemoveCommandBuffer(cameraEvent, value2);
		}
	}

	protected void Cleanup()
	{
		foreach (KeyValuePair<Camera, Dictionary<int, CommandBuffer>> camera in cameras)
		{
			Camera key = camera.Key;
			Dictionary<int, CommandBuffer> value = camera.Value;
			if (!Object.op_Implicit((Object)(object)key))
			{
				continue;
			}
			foreach (KeyValuePair<int, CommandBuffer> item in value)
			{
				int key2 = item.Key;
				CommandBuffer value2 = item.Value;
				key.RemoveCommandBuffer((CameraEvent)key2, value2);
			}
		}
	}
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public abstract class BaseMonoBehaviour : FacepunchBehaviour
{
	public virtual bool IsDebugging()
	{
		return false;
	}

	public virtual string GetLogColor()
	{
		return "yellow";
	}

	public void LogEntry(RustLog.EntryType log, int level, string fmtString)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			LogImpl(log, level, fmtString);
		}
	}

	public void LogEntry<T1>(RustLog.EntryType log, int level, string fmtString, T1 arg1)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			string message = string.Format(fmtString, arg1);
			LogImpl(log, level, message);
		}
	}

	public void LogEntry<T1, T2>(RustLog.EntryType log, int level, string fmtString, T1 arg1, T2 arg2)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			string message = string.Format(fmtString, arg1, arg2);
			LogImpl(log, level, message);
		}
	}

	public void LogEntry<T1, T2, T3>(RustLog.EntryType log, int level, string fmtString, T1 arg1, T2 arg2, T3 arg3)
	{
		if (IsDebugging() || RustLog.GetLevel(log) >= level)
		{
			string message = string.Format(fmtString, arg1, arg2, arg3);
			LogImpl(log, level, message);
		}
	}

	protected virtual string GetLogIdentity()
	{
		return $"{this} (InstID: {((Object)((Component)this).gameObject).GetInstanceID():x})";
	}

	private void LogImpl(RustLog.EntryType entryType, int level, string message)
	{
		string msgFormat = "<color={0}>{1}</color>: {2}";
		RustLog.Log(entryType, level, ((Component)this).gameObject, msgFormat, GetLogColor(), GetLogIdentity(), message);
	}
}


using UnityEngine;

public class BaseScriptableObject : ScriptableObject
{
	[HideInInspector]
	public uint FilenameStringId;

	public string LookupFileName()
	{
		return StringPool.Get(FilenameStringId);
	}

	public static bool operator ==(BaseScriptableObject a, BaseScriptableObject b)
	{
		if ((object)a == b)
		{
			return true;
		}
		if ((object)a == null || (object)b == null)
		{
			return false;
		}
		return a.FilenameStringId == b.FilenameStringId;
	}

	public static bool operator !=(BaseScriptableObject a, BaseScriptableObject b)
	{
		return !(a == b);
	}

	public override int GetHashCode()
	{
		return (int)FilenameStringId;
	}

	public override bool Equals(object o)
	{
		if (o != null && o is BaseScriptableObject)
		{
			return o as BaseScriptableObject == this;
		}
		return false;
	}
}


using UnityEngine;

public class ForceChildSingletonSetup : MonoBehaviour
{
	[ComponentHelp("Any child objects of this object that contain SingletonComponents will be registered - even if they're not enabled")]
	private void Awake()
	{
		SingletonComponent[] componentsInChildren = ((Component)this).GetComponentsInChildren<SingletonComponent>(true);
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			componentsInChildren[i].SingletonSetup();
		}
	}
}


public interface ICreateAssetCallback
{
	void OnAssetCreated(string assetName);
}


using UnityEngine;

public class InspectorNameAttribute : PropertyAttribute
{
	public string name;

	public InspectorNameAttribute(string name)
	{
		this.name = name;
	}
}


using System;
using UnityEngine;

[Serializable]
public class MinMax
{
	public float x;

	public float y = 1f;

	public MinMax(float x, float y)
	{
		this.x = x;
		this.y = y;
	}

	public float Random()
	{
		return Random.Range(x, y);
	}

	public float Lerp(float t)
	{
		return Mathf.Lerp(x, y, t);
	}

	public float Lerp(float a, float b, float t)
	{
		return Mathf.Lerp(x, y, Mathf.InverseLerp(a, b, t));
	}
}


using UnityEngine;

public class MinMaxAttribute : PropertyAttribute
{
	public float min;

	public float max;

	public MinMaxAttribute(float min, float max)
	{
		this.min = min;
		this.max = max;
	}
}


using UnityEngine;

public class AmbientLightLOD : FacepunchBehaviour, ILOD, IClientComponent
{
	public bool isDynamic;

	public float enabledRadius = 20f;

	public bool toggleFade;

	public float toggleFadeDuration = 0.5f;

	protected void OnValidate()
	{
		LightEx.CheckConflict(((Component)this).gameObject);
	}
}


using UnityEngine;

public class BasePrefab : BaseMonoBehaviour, IPrefabPreProcess
{
	[HideInInspector]
	public uint prefabID;

	[HideInInspector]
	public bool isClient;

	public bool isServer => !isClient;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		prefabID = StringPool.Get(name);
		isClient = clientside;
	}
}


using UnityEngine;

public struct CachedTransform<T> where T : Component
{
	public T component;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 localScale;

	public Matrix4x4 localToWorldMatrix => Matrix4x4.TRS(position, rotation, localScale);

	public Matrix4x4 worldToLocalMatrix
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Matrix4x4 val = localToWorldMatrix;
			return ((Matrix4x4)(ref val)).inverse;
		}
	}

	public Vector3 forward => rotation * Vector3.forward;

	public Vector3 up => rotation * Vector3.up;

	public Vector3 right => rotation * Vector3.right;

	public CachedTransform(T instance)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		component = instance;
		if (Object.op_Implicit((Object)(object)component))
		{
			position = ((Component)component).transform.position;
			rotation = ((Component)component).transform.rotation;
			localScale = ((Component)component).transform.localScale;
		}
		else
		{
			position = Vector3.zero;
			rotation = Quaternion.identity;
			localScale = Vector3.one;
		}
	}

	public void Apply()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)component))
		{
			((Component)component).transform.SetPositionAndRotation(position, rotation);
			((Component)component).transform.localScale = localScale;
		}
	}

	public void RotateAround(Vector3 center, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = val * (position - center);
		position = center + val2;
		rotation *= Quaternion.Inverse(rotation) * val * rotation;
	}

	public static implicit operator bool(CachedTransform<T> instance)
	{
		return (Object)(object)instance.component != (Object)null;
	}
}


using System;
using System.Runtime.CompilerServices;
using ConVar;
using UnityEngine;

[DisallowMultipleComponent]
public class CameraUpdateHook : MonoBehaviour
{
	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static CameraCallback <>9__5_0;

		public static CameraCallback <>9__5_1;

		public static CameraCallback <>9__5_2;

		internal void <Awake>b__5_0(Camera args)
		{
			Camera mainCamera = MainCamera.mainCamera;
			LastFrameFOV = ((mainCamera != null) ? mainCamera.fieldOfView : Graphics.fov);
			PreRender?.Invoke();
		}

		internal void <Awake>b__5_1(Camera args)
		{
			PostRender?.Invoke();
		}

		internal void <Awake>b__5_2(Camera args)
		{
			PreCull?.Invoke();
		}
	}

	public static Action PreCull;

	public static Action PreRender;

	public static Action PostRender;

	public static Action RustCamera_PreRender;

	public static float LastFrameFOV = Graphics.fov;

	private void Awake()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected O, but got Unknown
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected O, but got Unknown
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Expected O, but got Unknown
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Expected O, but got Unknown
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Expected O, but got Unknown
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Expected O, but got Unknown
		CameraUpdateHook[] components = ((Component)this).GetComponents<CameraUpdateHook>();
		foreach (CameraUpdateHook cameraUpdateHook in components)
		{
			if ((Object)(object)cameraUpdateHook != (Object)(object)this)
			{
				Object.DestroyImmediate((Object)(object)cameraUpdateHook);
			}
		}
		CameraCallback onPreRender = Camera.onPreRender;
		object obj = <>c.<>9__5_0;
		if (obj == null)
		{
			CameraCallback val = delegate
			{
				Camera mainCamera = MainCamera.mainCamera;
				LastFrameFOV = ((mainCamera != null) ? mainCamera.fieldOfView : Graphics.fov);
				PreRender?.Invoke();
			};
			<>c.<>9__5_0 = val;
			obj = (object)val;
		}
		Camera.onPreRender = (CameraCallback)Delegate.Combine((Delegate?)(object)onPreRender, (Delegate?)obj);
		CameraCallback onPostRender = Camera.onPostRender;
		object obj2 = <>c.<>9__5_1;
		if (obj2 == null)
		{
			CameraCallback val2 = delegate
			{
				PostRender?.Invoke();
			};
			<>c.<>9__5_1 = val2;
			obj2 = (object)val2;
		}
		Camera.onPostRender = (CameraCallback)Delegate.Combine((Delegate?)(object)onPostRender, (Delegate?)obj2);
		CameraCallback onPreCull = Camera.onPreCull;
		object obj3 = <>c.<>9__5_2;
		if (obj3 == null)
		{
			CameraCallback val3 = delegate
			{
				PreCull?.Invoke();
			};
			<>c.<>9__5_2 = val3;
			obj3 = (object)val3;
		}
		Camera.onPreCull = (CameraCallback)Delegate.Combine((Delegate?)(object)onPreCull, (Delegate?)obj3);
	}
}


using System;
using System.Collections;
using System.IO;
using System.Linq;
using UnityEngine;

public class ChildrenScreenshot : MonoBehaviour
{
	public Vector3 offsetAngle = new Vector3(0f, 0f, 1f);

	public int width = 512;

	public int height = 512;

	public float fieldOfView = 70f;

	[Tooltip("0 = full recursive name, 1 = object name")]
	public string folder = "screenshots/{0}.png";

	[ContextMenu("Create Screenshots")]
	public void CreateScreenshots()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Expected O, but got Unknown
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture val = new RenderTexture(width, height, 0);
		GameObject val2 = new GameObject();
		Camera val3 = val2.AddComponent<Camera>();
		val3.targetTexture = val;
		val3.orthographic = false;
		val3.fieldOfView = fieldOfView;
		val3.nearClipPlane = 0.1f;
		val3.farClipPlane = 2000f;
		val3.cullingMask = LayerMask.GetMask(new string[1] { "TransparentFX" });
		val3.clearFlags = (CameraClearFlags)2;
		val3.backgroundColor = new Color(0f, 0f, 0f, 0f);
		val3.renderingPath = (RenderingPath)3;
		Texture2D val4 = new Texture2D(((Texture)val).width, ((Texture)val).height, (TextureFormat)5, false);
		foreach (Transform item in ((IEnumerable)((Component)this).transform).Cast<Transform>())
		{
			PositionCamera(val3, ((Component)item).gameObject);
			int layer = ((Component)item).gameObject.layer;
			((Component)item).gameObject.SetLayerRecursive(1);
			val3.Render();
			((Component)item).gameObject.SetLayerRecursive(layer);
			string recursiveName = item.GetRecursiveName();
			recursiveName = recursiveName.Replace('/', '.');
			RenderTexture.active = val;
			val4.ReadPixels(new Rect(0f, 0f, (float)((Texture)val).width, (float)((Texture)val).height), 0, 0, false);
			RenderTexture.active = null;
			byte[] bytes = ImageConversion.EncodeToPNG(val4);
			string path = string.Format(folder, recursiveName, ((Object)item).name);
			string directoryName = Path.GetDirectoryName(path);
			if (!Directory.Exists(directoryName))
			{
				Directory.CreateDirectory(directoryName);
			}
			File.WriteAllBytes(path, bytes);
		}
		Object.DestroyImmediate((Object)(object)val4, true);
		Object.DestroyImmediate((Object)(object)val, true);
		Object.DestroyImmediate((Object)(object)val2, true);
	}

	public void PositionCamera(Camera cam, GameObject obj)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = default(Bounds);
		((Bounds)(ref bounds))..ctor(obj.transform.position, Vector3.zero * 0.1f);
		bool flag = true;
		Renderer[] componentsInChildren = obj.GetComponentsInChildren<Renderer>();
		foreach (Renderer val in componentsInChildren)
		{
			if (flag)
			{
				bounds = val.bounds;
				flag = false;
			}
			else
			{
				((Bounds)(ref bounds)).Encapsulate(val.bounds);
			}
		}
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = ((Vector3)(ref size)).magnitude * 0.5f / Mathf.Tan(cam.fieldOfView * 0.5f * (MathF.PI / 180f));
		((Component)cam).transform.position = ((Bounds)(ref bounds)).center + obj.transform.TransformVector(((Vector3)(ref offsetAngle)).normalized) * num;
		((Component)cam).transform.LookAt(((Bounds)(ref bounds)).center);
	}
}


using UnityEngine;

public class CommentComponent : MonoBehaviour, IEditorComponent
{
	[TextArea]
	public string comment;
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public class ConvarComponent : MonoBehaviour
{
	[Serializable]
	public class ConvarEvent
	{
		public string convar;

		public string on;

		public MonoBehaviour component;

		internal Command cmd;

		public void OnEnable()
		{
			cmd = Client.Find(convar);
			if (cmd == null)
			{
				cmd = Server.Find(convar);
			}
			if (cmd != null)
			{
				cmd.OnValueChanged += cmd_OnValueChanged;
				cmd_OnValueChanged(cmd);
			}
		}

		private void cmd_OnValueChanged(Command obj)
		{
			if (!((Object)(object)component == (Object)null))
			{
				bool flag = obj.String == on;
				if (((Behaviour)component).enabled != flag)
				{
					((Behaviour)component).enabled = flag;
				}
			}
		}

		public void OnDisable()
		{
			if (!Application.isQuitting && cmd != null)
			{
				cmd.OnValueChanged -= cmd_OnValueChanged;
			}
		}
	}

	public bool runOnServer = true;

	public bool runOnClient = true;

	public List<ConvarEvent> List = new List<ConvarEvent>();

	protected void OnEnable()
	{
		if (!ShouldRun())
		{
			return;
		}
		foreach (ConvarEvent item in List)
		{
			item.OnEnable();
		}
	}

	protected void OnDisable()
	{
		if (Application.isQuitting || !ShouldRun())
		{
			return;
		}
		foreach (ConvarEvent item in List)
		{
			item.OnDisable();
		}
	}

	private bool ShouldRun()
	{
		if (!runOnServer)
		{
			return false;
		}
		return true;
	}
}


using System;
using Rust;
using UnityEngine;

[Serializable]
public class ConvarEvent
{
	public string convar;

	public string on;

	public MonoBehaviour component;

	internal Command cmd;

	public void OnEnable()
	{
		cmd = Client.Find(convar);
		if (cmd == null)
		{
			cmd = Server.Find(convar);
		}
		if (cmd != null)
		{
			cmd.OnValueChanged += cmd_OnValueChanged;
			cmd_OnValueChanged(cmd);
		}
	}

	private void cmd_OnValueChanged(Command obj)
	{
		if (!((Object)(object)component == (Object)null))
		{
			bool flag = obj.String == on;
			if (((Behaviour)component).enabled != flag)
			{
				((Behaviour)component).enabled = flag;
			}
		}
	}

	public void OnDisable()
	{
		if (!Application.isQuitting && cmd != null)
		{
			cmd.OnValueChanged -= cmd_OnValueChanged;
		}
	}
}


using UnityEngine;
using UnityEngine.Serialization;

public class ConvarWater : MonoBehaviour
{
	[FormerlySerializedAs("waterEx")]
	public WaterSystem water;
}


public class DistanceFlareLOD : FacepunchBehaviour, ILOD, IClientComponent
{
	public bool isDynamic;

	public float minEnabledDistance = 100f;

	public float maxEnabledDistance = 600f;

	public bool toggleFade;

	public float toggleFadeDuration = 0.5f;
}


using System;
using UnityEngine;

public class ExecComponent : MonoBehaviour
{
	public string ExecToRun = string.Empty;

	public void Run()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		ConsoleSystem.Run(Option.Client, ExecToRun, Array.Empty<object>());
	}
}


using UnityEngine;

public class FoliageTrigger : MonoBehaviour
{
}


using UnityEngine;

public class IgnoreCollision : MonoBehaviour
{
	public Collider collider;

	protected void OnTriggerEnter(Collider other)
	{
		Physics.IgnoreCollision(other, collider, true);
	}
}


using UnityEngine;

public class LayerCullDistance : MonoBehaviour
{
	public string Layer = "Default";

	public float Distance = 1000f;

	protected void OnEnable()
	{
		Camera component = ((Component)this).GetComponent<Camera>();
		float[] layerCullDistances = component.layerCullDistances;
		layerCullDistances[LayerMask.NameToLayer(Layer)] = Distance;
		component.layerCullDistances = layerCullDistances;
	}
}


using UnityEngine;

public class LightLOD : MonoBehaviour, ILOD, IClientComponent
{
	public float DistanceBias;

	public bool ToggleLight;

	public bool ToggleShadows = true;

	protected void OnValidate()
	{
		LightEx.CheckConflict(((Component)this).gameObject);
	}
}


using UnityEngine;

public class LightOccludee : MonoBehaviour
{
	public float RadiusScale = 0.5f;

	public float MinTimeVisible = 0.1f;

	public bool IsDynamic;
}


using System.Collections.Generic;
using System.Diagnostics;
using Rust;
using UnityEngine;

public class LoadBalancer : SingletonComponent<LoadBalancer>
{
	public static bool Paused;

	private const float MinMilliseconds = 1f;

	private const float MaxMilliseconds = 100f;

	private const int MinBacklog = 1000;

	private const int MaxBacklog = 100000;

	private Queue<DeferredAction>[] queues = new Queue<DeferredAction>[5]
	{
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>(),
		new Queue<DeferredAction>()
	};

	private Stopwatch watch = Stopwatch.StartNew();

	protected void LateUpdate()
	{
		if (Application.isReceiving || Application.isLoading || Application.isUnloadingWorld || Paused)
		{
			return;
		}
		int num = Count();
		float num2 = Mathf.InverseLerp(1000f, 100000f, (float)num);
		float num3 = Mathf.SmoothStep(1f, 100f, num2);
		watch.Reset();
		watch.Start();
		for (int i = 0; i < queues.Length; i++)
		{
			Queue<DeferredAction> queue = queues[i];
			while (queue.Count > 0)
			{
				queue.Dequeue().Action();
				if (watch.Elapsed.TotalMilliseconds > (double)num3)
				{
					return;
				}
			}
		}
	}

	public static int Count()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<LoadBalancer>.Instance))
		{
			return 0;
		}
		Queue<DeferredAction>[] array = SingletonComponent<LoadBalancer>.Instance.queues;
		int num = 0;
		for (int i = 0; i < array.Length; i++)
		{
			num += array[i].Count;
		}
		return num;
	}

	public static void ProcessAll()
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<LoadBalancer>.Instance))
		{
			CreateInstance();
		}
		Queue<DeferredAction>[] array = SingletonComponent<LoadBalancer>.Instance.queues;
		foreach (Queue<DeferredAction> queue in array)
		{
			while (queue.Count > 0)
			{
				queue.Dequeue().Action();
			}
		}
	}

	public static void Enqueue(DeferredAction action)
	{
		if (!Object.op_Implicit((Object)(object)SingletonComponent<LoadBalancer>.Instance))
		{
			CreateInstance();
		}
		SingletonComponent<LoadBalancer>.Instance.queues[action.Index].Enqueue(action);
	}

	private static void CreateInstance()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Expected O, but got Unknown
		GameObject val = new GameObject
		{
			name = "LoadBalancer"
		};
		val.AddComponent<LoadBalancer>();
		Object.DontDestroyOnLoad((Object)val);
	}
}


public enum ActionPriority
{
	Highest,
	High,
	Medium,
	Low,
	Lowest
}


using System;
using UnityEngine;

public class DeferredAction
{
	private Object sender;

	private Action action;

	private ActionPriority priority = ActionPriority.Medium;

	public bool Idle { get; private set; }

	public int Index => (int)priority;

	public DeferredAction(Object sender, Action action, ActionPriority priority = ActionPriority.Medium)
	{
		this.sender = sender;
		this.action = action;
		this.priority = priority;
		Idle = true;
	}

	public void Action()
	{
		if (Idle)
		{
			throw new Exception("Double invocation of a deferred action.");
		}
		Idle = true;
		if (Object.op_Implicit(sender))
		{
			action();
		}
	}

	public void Invoke()
	{
		if (!Idle)
		{
			throw new Exception("Double invocation of a deferred action.");
		}
		LoadBalancer.Enqueue(this);
		Idle = false;
	}

	public static implicit operator bool(DeferredAction obj)
	{
		return obj != null;
	}

	public static void Invoke(Object sender, Action action, ActionPriority priority = ActionPriority.Medium)
	{
		new DeferredAction(sender, action, priority).Invoke();
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Material Config")]
public class MaterialConfig : ScriptableObject
{
	[Serializable]
	public class EnvironmentVolumeOverride
	{
		public EnvironmentType Environment;

		public Enum Biome;
	}

	public class ShaderParameters<T>
	{
		public string Name;

		public T Arid;

		public T Temperate;

		public T Tundra;

		public T Arctic;

		[FormerlySerializedAs("Temperate")]
		public T Jungle;

		private T[] climates;

		public float FindBlendParameters(Vector3 pos, int biomeOverride, out T src, out T dst)
		{
			//IL_0092: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				src = Temperate;
				dst = Tundra;
				return 0f;
			}
			if (climates == null || climates.Length == 0)
			{
				climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
			}
			int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
			int num2 = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~num));
			src = climates[TerrainBiome.TypeToIndex(num)];
			dst = climates[TerrainBiome.TypeToIndex(num2)];
			return TerrainMeta.BiomeMap.GetBiome(pos, num2);
		}

		public T FindBlendParameters(Vector3 pos, int biomeOverride)
		{
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
			{
				return Temperate;
			}
			if (climates == null || climates.Length == 0)
			{
				climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
			}
			int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
			return climates[TerrainBiome.TypeToIndex(num)];
		}
	}

	[Serializable]
	public class ShaderParametersFloat : ShaderParameters<float>
	{
	}

	[Serializable]
	public class ShaderParametersColor : ShaderParameters<Color>
	{
	}

	[Serializable]
	public class ShaderParametersTexture : ShaderParameters<Texture>
	{
	}

	[Serializable]
	public class ShaderParametersToggle : ShaderParameters<bool>
	{
	}

	[Horizontal(5, 0)]
	public ShaderParametersFloat[] Floats;

	[Horizontal(5, 0)]
	public ShaderParametersColor[] Colors;

	[Horizontal(5, 0)]
	public ShaderParametersTexture[] Textures;

	[Horizontal(5, 0)]
	public ShaderParametersToggle[] Toggles;

	public string[] ScaleUV;

	[Horizontal(2, -1)]
	public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;

	private MaterialPropertyBlock properties;

	public MaterialPropertyBlock GetMaterialPropertyBlock(Material mat, Vector3 pos, Vector3 scale)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Expected O, but got Unknown
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Expected I4, but got Unknown
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		if (properties == null)
		{
			properties = new MaterialPropertyBlock();
		}
		properties.Clear();
		int biomeOverride = 0;
		if (EnvironmentVolumeOverrides.Length != 0)
		{
			EnvironmentType environmentType = EnvironmentManager.Get(pos);
			if (TerrainMeta.IsPointWithinTutorialBounds(pos))
			{
				biomeOverride = 2;
			}
			else
			{
				EnvironmentVolumeOverride[] environmentVolumeOverrides = EnvironmentVolumeOverrides;
				foreach (EnvironmentVolumeOverride environmentVolumeOverride in environmentVolumeOverrides)
				{
					if ((environmentType & environmentVolumeOverride.Environment) != 0)
					{
						biomeOverride = (int)environmentVolumeOverride.Biome;
						break;
					}
				}
			}
		}
		for (int j = 0; j < Floats.Length; j++)
		{
			ShaderParametersFloat shaderParametersFloat = Floats[j];
			float src;
			float dst;
			float num = shaderParametersFloat.FindBlendParameters(pos, biomeOverride, out src, out dst);
			properties.SetFloat(shaderParametersFloat.Name, Mathf.Lerp(src, dst, num));
		}
		for (int k = 0; k < Colors.Length; k++)
		{
			ShaderParametersColor shaderParametersColor = Colors[k];
			Color src2;
			Color dst2;
			float num2 = shaderParametersColor.FindBlendParameters(pos, biomeOverride, out src2, out dst2);
			properties.SetColor(shaderParametersColor.Name, Color.Lerp(src2, dst2, num2));
		}
		for (int l = 0; l < Textures.Length; l++)
		{
			ShaderParametersTexture shaderParametersTexture = Textures[l];
			Texture val = shaderParametersTexture.FindBlendParameters(pos, biomeOverride);
			if (Object.op_Implicit((Object)(object)val))
			{
				properties.SetTexture(shaderParametersTexture.Name, val);
			}
		}
		for (int m = 0; m < Toggles.Length; m++)
		{
			ShaderParametersToggle shaderParametersToggle = Toggles[m];
			bool flag = shaderParametersToggle.FindBlendParameters(pos, biomeOverride);
			properties.SetFloat(shaderParametersToggle.Name, flag ? 1f : 0f);
		}
		for (int n = 0; n < ScaleUV.Length; n++)
		{
			Vector4 vector = mat.GetVector(ScaleUV[n]);
			((Vector4)(ref vector))..ctor(vector.x * scale.y, vector.y * scale.y, vector.z, vector.w);
			properties.SetVector(ScaleUV[n], vector);
		}
		return properties;
	}
}


using System;

[Serializable]
public class EnvironmentVolumeOverride
{
	public EnvironmentType Environment;

	public Enum Biome;
}


using UnityEngine;
using UnityEngine.Serialization;

public class ShaderParameters<T>
{
	public string Name;

	public T Arid;

	public T Temperate;

	public T Tundra;

	public T Arctic;

	[FormerlySerializedAs("Temperate")]
	public T Jungle;

	private T[] climates;

	public float FindBlendParameters(Vector3 pos, int biomeOverride, out T src, out T dst)
	{
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			src = Temperate;
			dst = Tundra;
			return 0f;
		}
		if (climates == null || climates.Length == 0)
		{
			climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
		int num2 = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos, ~num));
		src = climates[TerrainBiome.TypeToIndex(num)];
		dst = climates[TerrainBiome.TypeToIndex(num2)];
		return TerrainMeta.BiomeMap.GetBiome(pos, num2);
	}

	public T FindBlendParameters(Vector3 pos, int biomeOverride)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.BiomeMap == (Object)null)
		{
			return Temperate;
		}
		if (climates == null || climates.Length == 0)
		{
			climates = new T[5] { Arid, Temperate, Tundra, Arctic, Jungle };
		}
		int num = ((biomeOverride != 0) ? biomeOverride : TerrainMeta.BiomeMap.GetBiomeMaxType(pos));
		return climates[TerrainBiome.TypeToIndex(num)];
	}
}


using System;

[Serializable]
public class ShaderParametersFloat : ShaderParameters<float>
{
}


using System;
using UnityEngine;

[Serializable]
public class ShaderParametersColor : ShaderParameters<Color>
{
}


using System;
using UnityEngine;

[Serializable]
public class ShaderParametersTexture : ShaderParameters<Texture>
{
}


using System;

[Serializable]
public class ShaderParametersToggle : ShaderParameters<bool>
{
}


using Rust;

public class MaterialSetup : ProceduralObject, IClientComponent
{
	public MaterialConfig config;

	public bool IncludeChildren;

	protected void OnEnable()
	{
		if (!Application.isLoading)
		{
			Setup();
		}
	}

	public override void Process()
	{
		Setup();
	}

	private void Setup()
	{
	}
}


using UnityEngine;

public class MeshToggle : MonoBehaviour
{
	public Mesh[] RendererMeshes;

	public Mesh[] ColliderMeshes;

	public void SwitchRenderer(int index)
	{
		if (RendererMeshes.Length != 0)
		{
			MeshFilter component = ((Component)this).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.sharedMesh = RendererMeshes[Mathf.Clamp(index, 0, RendererMeshes.Length - 1)];
			}
		}
	}

	public void SwitchRenderer(float factor)
	{
		int index = Mathf.RoundToInt(factor * (float)RendererMeshes.Length);
		SwitchRenderer(index);
	}

	public void SwitchCollider(int index)
	{
		if (ColliderMeshes.Length != 0)
		{
			MeshCollider component = ((Component)this).GetComponent<MeshCollider>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.sharedMesh = ColliderMeshes[Mathf.Clamp(index, 0, ColliderMeshes.Length - 1)];
			}
		}
	}

	public void SwitchCollider(float factor)
	{
		int index = Mathf.RoundToInt(factor * (float)ColliderMeshes.Length);
		SwitchCollider(index);
	}

	public void SwitchAll(int index)
	{
		SwitchRenderer(index);
		SwitchCollider(index);
	}

	public void SwitchAll(float factor)
	{
		SwitchRenderer(factor);
		SwitchCollider(factor);
	}
}


using UnityEngine;

public class MoveForward : MonoBehaviour
{
	public float Speed = 2f;

	protected void Update()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).GetComponent<Rigidbody>().velocity = Speed * ((Component)this).transform.forward;
	}
}


using UnityEngine;

public class NetworkSleep : MonoBehaviour
{
	public static int totalBehavioursDisabled;

	public static int totalCollidersDisabled;

	public Behaviour[] behaviours;

	public Collider[] colliders;

	internal int BehavioursDisabled;

	internal int CollidersDisabled;
}


using UnityEngine;

public class ObjectFlasher : BaseMonoBehaviour
{
	public GameObject enabledObj;

	public GameObject disabledObj;

	public float toggleLength = 1f;

	public float timeOffset;

	public float randomOffset;
}


using UnityEngine;

[ExecuteAlways]
public class OneActiveSibling : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class ParticleSystemContainer : MonoBehaviour, IPrefabPreProcess
{
	[Serializable]
	public struct ParticleSystemGroup
	{
		public ParticleSystem system;

		public LODComponentParticleSystem[] lodComponents;
	}

	public bool precached;

	public bool includeLights;

	[HideInInspector]
	[SerializeField]
	private ParticleSystemGroup[] particleGroups;

	[SerializeField]
	[HideInInspector]
	private Light[] lights;

	[HideInInspector]
	[SerializeField]
	private LightEx[] lightExs;

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void Play()
	{
	}

	public void Pause()
	{
	}

	public void Stop()
	{
	}

	public void Clear()
	{
	}

	private void SetLights(bool on)
	{
		Light[] componentsInChildren;
		LightEx[] componentsInChildren2;
		if (precached)
		{
			componentsInChildren = lights;
			componentsInChildren2 = lightExs;
		}
		else
		{
			componentsInChildren = ((Component)this).GetComponentsInChildren<Light>();
			componentsInChildren2 = ((Component)this).GetComponentsInChildren<LightEx>();
		}
		LightEx[] array = componentsInChildren2;
		for (int i = 0; i < array.Length; i++)
		{
			((Behaviour)array[i]).enabled = on;
		}
		Light[] array2 = componentsInChildren;
		for (int i = 0; i < array2.Length; i++)
		{
			((Behaviour)array2[i]).enabled = on;
		}
	}

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (precached && clientside)
		{
			List<ParticleSystemGroup> list = new List<ParticleSystemGroup>();
			ParticleSystem[] componentsInChildren = ((Component)this).GetComponentsInChildren<ParticleSystem>();
			foreach (ParticleSystem val in componentsInChildren)
			{
				LODComponentParticleSystem[] components = ((Component)val).GetComponents<LODComponentParticleSystem>();
				ParticleSystemGroup particleSystemGroup = default(ParticleSystemGroup);
				particleSystemGroup.system = val;
				particleSystemGroup.lodComponents = components;
				ParticleSystemGroup item = particleSystemGroup;
				list.Add(item);
			}
			particleGroups = list.ToArray();
			if (includeLights)
			{
				lights = ((Component)this).GetComponentsInChildren<Light>();
				lightExs = ((Component)this).GetComponentsInChildren<LightEx>();
			}
		}
	}

	public bool IsPlaying()
	{
		ParticleSystemGroup[] array = particleGroups;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].system.isPlaying)
			{
				return true;
			}
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ParticleSystemGroup
{
	public ParticleSystem system;

	public LODComponentParticleSystem[] lodComponents;
}


using UnityEngine;

public class ParticleSystemIK : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class ParticleSystemPlayer : MonoBehaviour, IOnParentDestroying
{
	protected void OnEnable()
	{
		((Component)this).GetComponent<ParticleSystem>().enableEmission = true;
	}

	public void OnParentDestroying()
	{
		((Component)this).GetComponent<ParticleSystem>().enableEmission = false;
	}
}


using UnityEngine;

[DefaultExecutionOrder(16000)]
public class ParticleSystemPostIK : MonoBehaviour
{
}


using System;

public struct PerformanceSamplePoint
{
	public int UpdateCount;

	public int FixedUpdateCount;

	public int RenderCount;

	public TimeSpan PreCull;

	public TimeSpan Update;

	public TimeSpan LateUpdate;

	public TimeSpan PhysicsUpdate;

	public TimeSpan Render;

	public TimeSpan FixedUpdate;

	public TimeSpan TotalCPU;

	public int CpuUpdateCount;

	public PerformanceSamplePoint Add(PerformanceSamplePoint other)
	{
		PerformanceSamplePoint result = default(PerformanceSamplePoint);
		result.UpdateCount = UpdateCount + other.UpdateCount;
		result.FixedUpdateCount = FixedUpdateCount + other.FixedUpdateCount;
		result.RenderCount = RenderCount + other.RenderCount;
		result.PreCull = PreCull + other.PreCull;
		result.Update = Update + other.Update;
		result.LateUpdate = LateUpdate + other.LateUpdate;
		result.PhysicsUpdate = PhysicsUpdate + other.PhysicsUpdate;
		result.Render = Render + other.Render;
		result.FixedUpdate = FixedUpdate + other.FixedUpdate;
		result.TotalCPU = TotalCPU + other.TotalCPU;
		result.CpuUpdateCount = CpuUpdateCount + other.CpuUpdateCount;
		return result;
	}
}


using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using UnityEngine;
using UnityEngine.Events;

public static class PerformanceMetrics
{
	[Serializable]
	[CompilerGenerated]
	private sealed class <>c
	{
		public static readonly <>c <>9 = new <>c();

		public static UnityAction <>9__10_0;

		internal void <Setup>b__10_0()
		{
			OnBeforeRender?.Invoke();
		}
	}

	private static PerformanceSamplePoint current;

	private static Action OnBeforeRender;

	public static PerformanceSamplePoint LastFrame { get; private set; }

	public static PerformanceSamplePoint PerformancePerSecond { get; set; }

	public static void Setup()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Expected O, but got Unknown
		object obj = <>c.<>9__10_0;
		if (obj == null)
		{
			UnityAction val = delegate
			{
				OnBeforeRender?.Invoke();
			};
			<>c.<>9__10_0 = val;
			obj = (object)val;
		}
		Application.onBeforeRender += (UnityAction)obj;
		AddStopwatch(PerformanceSample.PreCull, ref OnBeforeRender, ref CameraUpdateHook.RustCamera_PreRender);
		AddStopwatch(PerformanceSample.Update, ref PreUpdateHook.OnUpdate, ref PostUpdateHook.OnUpdate);
		AddStopwatch(PerformanceSample.LateUpdate, ref PreUpdateHook.OnLateUpdate, ref PostUpdateHook.OnLateUpdate);
		AddStopwatch(PerformanceSample.Render, ref CameraUpdateHook.PreRender, ref CameraUpdateHook.PostRender);
		AddStopwatch(PerformanceSample.FixedUpdate, ref PreUpdateHook.OnFixedUpdate, ref PostUpdateHook.OnFixedUpdate);
		AddStopwatch(PerformanceSample.PhysicsUpdate, ref PostUpdateHook.OnFixedUpdate, ref PreUpdateHook.PostPhysicsUpdate);
		AddCPUTimeStopwatch();
	}

	private static void AddCPUTimeStopwatch()
	{
		Stopwatch watch = new Stopwatch();
		PreUpdateHook.StartOfFrame = (Action)Delegate.Combine(PreUpdateHook.StartOfFrame, (Action)delegate
		{
			PerformancePerSecond = PerformancePerSecond.Add(current);
			LastFrame = current;
			current = default(PerformanceSamplePoint);
			watch.Restart();
			current.CpuUpdateCount++;
		});
		PostUpdateHook.EndOfFrame = (Action)Delegate.Combine(PostUpdateHook.EndOfFrame, (Action)delegate
		{
			current.TotalCPU += watch.Elapsed;
		});
	}

	private static void AddStopwatch(PerformanceSample sample, ref Action pre, ref Action post)
	{
		Stopwatch watch = new Stopwatch();
		bool active = false;
		pre = (Action)Delegate.Combine(pre, (Action)delegate
		{
			if (!active)
			{
				active = true;
				watch.Restart();
			}
		});
		post = (Action)Delegate.Combine(post, (Action)delegate
		{
			if (active)
			{
				active = false;
				watch.Stop();
				switch (sample)
				{
				case PerformanceSample.Update:
					current.UpdateCount++;
					current.Update += watch.Elapsed;
					break;
				case PerformanceSample.LateUpdate:
					current.LateUpdate += watch.Elapsed;
					break;
				case PerformanceSample.FixedUpdate:
					current.FixedUpdate += watch.Elapsed;
					current.FixedUpdateCount++;
					break;
				case PerformanceSample.PreCull:
					current.PreCull += watch.Elapsed;
					break;
				case PerformanceSample.Render:
					current.Render += watch.Elapsed;
					current.RenderCount++;
					break;
				case PerformanceSample.PhysicsUpdate:
					current.PhysicsUpdate += watch.Elapsed;
					break;
				case PerformanceSample.NetworkMessage:
				case PerformanceSample.TotalCPU:
					break;
				}
			}
		});
	}
}


using System;
using System.Collections;
using Facepunch.Rust.Profiling;
using UnityEngine;

[DisallowMultipleComponent]
public class PostUpdateHook : MonoBehaviour
{
	public static Action OnUpdate;

	public static Action OnLateUpdate;

	public static Action OnFixedUpdate;

	public static Action EndOfFrame;

	private void Update()
	{
		OnUpdate?.Invoke();
		RuntimeProfiler.Update();
	}

	private void LateUpdate()
	{
		OnLateUpdate?.Invoke();
	}

	private void FixedUpdate()
	{
		OnFixedUpdate?.Invoke();
	}

	private void Start()
	{
		((MonoBehaviour)this).StartCoroutine(EndOfFrameRoutine());
	}

	private IEnumerator EndOfFrameRoutine()
	{
		while (Application.isPlaying)
		{
			yield return CoroutineEx.waitForEndOfFrame;
			EndOfFrame?.Invoke();
		}
	}
}


public enum PerformanceSample
{
	Update,
	LateUpdate,
	PreCull,
	Render,
	FixedUpdate,
	NetworkMessage,
	TotalCPU,
	PhysicsUpdate,
	Last
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;
using Development.Attributes;
using UnityEngine;
using UnityEngine.Assertions;

[ResetStaticFields]
public abstract class PrefabAttribute : MonoBehaviour, IPrefabPreProcess
{
	public class AttributeCollection
	{
		private Dictionary<Type, List<PrefabAttribute>> attributes = new Dictionary<Type, List<PrefabAttribute>>();

		private Dictionary<Type, object> cache = new Dictionary<Type, object>();

		internal List<PrefabAttribute> Find(Type t)
		{
			if (attributes.TryGetValue(t, out var value))
			{
				return value;
			}
			value = new List<PrefabAttribute>();
			attributes.Add(t, value);
			return value;
		}

		public T[] Find<T>()
		{
			if (cache == null)
			{
				cache = new Dictionary<Type, object>();
			}
			if (cache.TryGetValue(typeof(T), out var value))
			{
				return (T[])value;
			}
			value = Find(typeof(T)).Cast<T>().ToArray();
			cache.Add(typeof(T), value);
			return (T[])value;
		}

		public void Add(PrefabAttribute attribute)
		{
			List<PrefabAttribute> list = Find(attribute.GetIndexedType());
			Assert.IsTrue(!list.Contains(attribute), "AttributeCollection.Add: Adding twice to list");
			list.Add(attribute);
			cache = null;
		}
	}

	public class Library
	{
		public bool clientside;

		public bool serverside;

		public Dictionary<uint, AttributeCollection> prefabs = new Dictionary<uint, AttributeCollection>();

		public Library(bool clientside, bool serverside)
		{
			this.clientside = clientside;
			this.serverside = serverside;
		}

		public AttributeCollection Find(uint prefabID, bool warmup = true)
		{
			if (prefabs.TryGetValue(prefabID, out var value))
			{
				return value;
			}
			value = new AttributeCollection();
			prefabs.Add(prefabID, value);
			if (warmup && (!clientside || serverside))
			{
				if (!clientside && serverside)
				{
					GameManager.server.FindPrefab(prefabID);
				}
				else if (clientside)
				{
					_ = serverside;
				}
			}
			return value;
		}

		public T Find<T>(uint prefabID) where T : PrefabAttribute
		{
			T[] array = Find(prefabID).Find<T>();
			if (array.Length == 0)
			{
				return null;
			}
			return array[0];
		}

		public bool Find<T>(uint prefabID, out T result) where T : PrefabAttribute
		{
			result = null;
			T[] array = Find(prefabID).Find<T>();
			if (array.Length == 0)
			{
				return false;
			}
			result = array[0];
			return true;
		}

		public T[] FindAll<T>(uint prefabID) where T : PrefabAttribute
		{
			return Find(prefabID).Find<T>();
		}

		public void Add(uint prefabID, PrefabAttribute attribute)
		{
			Find(prefabID, warmup: false).Add(attribute);
		}

		public void Invalidate(uint prefabID)
		{
			prefabs.Remove(prefabID);
		}

		public void InvalidateAll()
		{
			prefabs.Clear();
		}
	}

	[NonSerialized]
	public Vector3 worldPosition;

	[NonSerialized]
	public Quaternion worldRotation;

	[NonSerialized]
	public Vector3 worldForward;

	[NonSerialized]
	public Vector3 localPosition;

	[NonSerialized]
	public Vector3 localScale;

	[NonSerialized]
	public Quaternion localRotation;

	[NonSerialized]
	public string fullName;

	[NonSerialized]
	public string hierachyName;

	[NonSerialized]
	public uint prefabID;

	[NonSerialized]
	public int instanceID;

	[NonSerialized]
	public Library prefabAttribute;

	[NonSerialized]
	public GameManager gameManager;

	[NonSerialized]
	public bool isServer;

	public static Library server = new Library(clientside: false, serverside: true);

	public bool isClient => !isServer;

	bool IPrefabPreProcess.CanRunDuringBundling => true;

	public virtual void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		fullName = name;
		hierachyName = ((Component)this).transform.GetRecursiveName();
		prefabID = StringPool.Get(name);
		instanceID = ((Object)this).GetInstanceID();
		worldPosition = ((Component)this).transform.position;
		worldRotation = ((Component)this).transform.rotation;
		worldForward = ((Component)this).transform.forward;
		localPosition = ((Component)this).transform.localPosition;
		localScale = ((Component)this).transform.localScale;
		localRotation = ((Component)this).transform.localRotation;
		if (serverside)
		{
			prefabAttribute = server;
			gameManager = GameManager.server;
			isServer = true;
		}
		AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!bundling)
		{
			if (serverside)
			{
				server.Add(prefabID, this);
			}
			preProcess.RemoveComponent((Component)(object)this);
			preProcess.NominateForDeletion(((Component)this).gameObject);
		}
	}

	protected virtual void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}

	protected abstract Type GetIndexedType();

	public static bool operator ==(PrefabAttribute x, PrefabAttribute y)
	{
		return ComparePrefabAttribute(x, y);
	}

	public static bool operator !=(PrefabAttribute x, PrefabAttribute y)
	{
		return !ComparePrefabAttribute(x, y);
	}

	public override bool Equals(object o)
	{
		if (o is PrefabAttribute y)
		{
			return ComparePrefabAttribute(this, y);
		}
		return false;
	}

	public override int GetHashCode()
	{
		if (hierachyName == null)
		{
			return ((Object)this).GetHashCode();
		}
		return hierachyName.GetHashCode();
	}

	public static implicit operator bool(PrefabAttribute exists)
	{
		return (object)exists != null;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	internal static bool ComparePrefabAttribute(PrefabAttribute x, PrefabAttribute y)
	{
		bool flag = (object)x == null;
		bool flag2 = (object)y == null;
		if (flag && flag2)
		{
			return true;
		}
		if (flag || flag2)
		{
			return false;
		}
		if (x.instanceID == y.instanceID)
		{
			return true;
		}
		return false;
	}

	public override string ToString()
	{
		if ((object)this == null)
		{
			return "null";
		}
		return hierachyName;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Assertions;

public class AttributeCollection
{
	private Dictionary<Type, List<PrefabAttribute>> attributes = new Dictionary<Type, List<PrefabAttribute>>();

	private Dictionary<Type, object> cache = new Dictionary<Type, object>();

	internal List<PrefabAttribute> Find(Type t)
	{
		if (attributes.TryGetValue(t, out var value))
		{
			return value;
		}
		value = new List<PrefabAttribute>();
		attributes.Add(t, value);
		return value;
	}

	public T[] Find<T>()
	{
		if (cache == null)
		{
			cache = new Dictionary<Type, object>();
		}
		if (cache.TryGetValue(typeof(T), out var value))
		{
			return (T[])value;
		}
		value = Find(typeof(T)).Cast<T>().ToArray();
		cache.Add(typeof(T), value);
		return (T[])value;
	}

	public void Add(PrefabAttribute attribute)
	{
		List<PrefabAttribute> list = Find(attribute.GetIndexedType());
		Assert.IsTrue(!list.Contains(attribute), "AttributeCollection.Add: Adding twice to list");
		list.Add(attribute);
		cache = null;
	}
}


using System.Collections.Generic;

public class Library
{
	public bool clientside;

	public bool serverside;

	public Dictionary<uint, AttributeCollection> prefabs = new Dictionary<uint, AttributeCollection>();

	public Library(bool clientside, bool serverside)
	{
		this.clientside = clientside;
		this.serverside = serverside;
	}

	public AttributeCollection Find(uint prefabID, bool warmup = true)
	{
		if (prefabs.TryGetValue(prefabID, out var value))
		{
			return value;
		}
		value = new AttributeCollection();
		prefabs.Add(prefabID, value);
		if (warmup && (!clientside || serverside))
		{
			if (!clientside && serverside)
			{
				GameManager.server.FindPrefab(prefabID);
			}
			else if (clientside)
			{
				_ = serverside;
			}
		}
		return value;
	}

	public T Find<T>(uint prefabID) where T : PrefabAttribute
	{
		T[] array = Find(prefabID).Find<T>();
		if (array.Length == 0)
		{
			return null;
		}
		return array[0];
	}

	public bool Find<T>(uint prefabID, out T result) where T : PrefabAttribute
	{
		result = null;
		T[] array = Find(prefabID).Find<T>();
		if (array.Length == 0)
		{
			return false;
		}
		result = array[0];
		return true;
	}

	public T[] FindAll<T>(uint prefabID) where T : PrefabAttribute
	{
		return Find(prefabID).Find<T>();
	}

	public void Add(uint prefabID, PrefabAttribute attribute)
	{
		Find(prefabID, warmup: false).Add(attribute);
	}

	public void Invalidate(uint prefabID)
	{
		prefabs.Remove(prefabID);
	}

	public void InvalidateAll()
	{
		prefabs.Clear();
	}
}


using System;
using UnityEngine;

public class RigidbodyInfo : PrefabAttribute, IClientComponent
{
	[ReadOnly]
	public float mass;

	[ReadOnly]
	public float drag;

	[ReadOnly]
	public float angularDrag;

	protected override Type GetIndexedType()
	{
		return typeof(RigidbodyInfo);
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		if (!FileSystem.IsBundled)
		{
			Rigidbody component = rootObj.GetComponent<Rigidbody>();
			if ((Object)(object)component == (Object)null)
			{
				Debug.LogError((object)(((object)this).GetType().Name + ": RigidbodyInfo couldn't find a rigidbody on " + name + "! If a RealmedRemove is removing it, make sure this script is above the RealmedRemove script so that this gets processed first."));
				return;
			}
			mass = component.mass;
			drag = component.drag;
			angularDrag = component.angularDrag;
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

[DisallowMultipleComponent]
public class PreUpdateHook : MonoBehaviour
{
	public static Action OnUpdate;

	public static Action OnLateUpdate;

	public static Action OnFixedUpdate;

	public static Action PostPhysicsUpdate;

	public static Action StartOfFrame;

	private static int lastStartOfFrame;

	private void Start()
	{
		((MonoBehaviour)this).StartCoroutine(AfterPhysicsUpdate());
	}

	private void Update()
	{
		TryRunStartOfFrame();
		OnUpdate?.Invoke();
	}

	private void LateUpdate()
	{
		OnLateUpdate?.Invoke();
	}

	private void FixedUpdate()
	{
		TryRunStartOfFrame();
		OnFixedUpdate?.Invoke();
	}

	private void TryRunStartOfFrame()
	{
		int frameCount = Time.frameCount;
		if (lastStartOfFrame != frameCount)
		{
			lastStartOfFrame = frameCount;
			StartOfFrame?.Invoke();
		}
	}

	private IEnumerator AfterPhysicsUpdate()
	{
		while (Application.isPlaying)
		{
			yield return CoroutineEx.waitForFixedUpdate;
			PostPhysicsUpdate?.Invoke();
		}
	}
}


using UnityEngine;

public class RotateCameraAroundObject : MonoBehaviour
{
	public GameObject m_goObjectToRotateAround;

	public float m_flRotateSpeed = 10f;

	private void FixedUpdate()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)m_goObjectToRotateAround != (Object)null)
		{
			((Component)this).transform.LookAt(m_goObjectToRotateAround.transform.position + Vector3.up * 0.75f);
			((Component)this).transform.Translate(Vector3.right * m_flRotateSpeed * Time.deltaTime);
		}
	}
}


using System;
using UnityEngine;

public class RunConsoleCommand : MonoBehaviour
{
	[SerializeField]
	private bool runQuiet;

	public void ClientRun(string command)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		Option val;
		if (!runQuiet)
		{
			val = Option.Client;
		}
		else
		{
			Option client = Option.Client;
			val = ((Option)(ref client)).Quiet();
		}
		ConsoleSystem.Run(val, command, Array.Empty<object>());
	}
}


public class Screenshot : SingletonComponent<Screenshot>
{
	public string screenshotPath;

	public int sizeMultiplier = 4;
}


using System;
using UnityEngine;

[DisallowMultipleComponent]
public class StripEmptyChildren : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(StripEmptyChildren);
	}
}


using UnityEngine;

public class TagComponent : MonoBehaviour
{
	public GameObjectTag Tag;

	public bool HasTag(GameObjectTag tag)
	{
		return (Tag & tag) == tag;
	}

	public void AddTag(GameObjectTag tag)
	{
		Tag |= tag;
	}

	public void RemoveTag(GameObjectTag tag)
	{
		Tag &= ~tag;
	}

	public void SetTag(GameObjectTag tag, bool state)
	{
		if (state)
		{
			AddTag(tag);
		}
		else
		{
			RemoveTag(tag);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using VLB;

public static class TagComponentEx
{
	private static Dictionary<GameObjectTag, string> strings;

	static TagComponentEx()
	{
		strings = new Dictionary<GameObjectTag, string>();
		foreach (object value in Enum.GetValues(typeof(GameObjectTag)))
		{
			strings[(GameObjectTag)value] = value.ToString();
		}
	}

	public static bool HasCustomTag(this GameObject gameObject, GameObjectTag tag)
	{
		string text = strings[tag];
		if (gameObject.CompareTag(text))
		{
			return true;
		}
		TagComponent component = gameObject.GetComponent<TagComponent>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		return component.HasTag(tag);
	}

	public static bool SetCustomTag(this GameObject gameObject, GameObjectTag tag, bool apply)
	{
		string text = strings[tag];
		if (apply)
		{
			if (gameObject.tag == text)
			{
				return false;
			}
			if (gameObject.CompareTag("Untagged"))
			{
				gameObject.tag = text;
				return true;
			}
			TagComponent orAddComponent = gameObject.GetOrAddComponent<TagComponent>();
			if (orAddComponent.HasTag(tag))
			{
				return false;
			}
			orAddComponent.AddTag(tag);
			return true;
		}
		if (gameObject.tag == text)
		{
			gameObject.CompareTag("Untagged");
			return true;
		}
		TagComponent component = gameObject.GetComponent<TagComponent>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		if (!component.HasTag(tag))
		{
			return false;
		}
		component.RemoveTag(tag);
		return true;
	}
}


using System;

[Flags]
public enum GameObjectTag
{
	AllowBarricadePlacement = 1,
	Road = 2,
	BlockBarricadePlacement = 4,
	BlockPlacement = 8
}


using UnityEngine;

public class TutorialOptionsPrompt : MonoBehaviour
{
	public CanvasGroup Group;

	public GameObject NotConnectedToValidServerRoot;

	public GameObject ServerValidRoot;

	public GameObject TutorialInProcessRoot;
}


using UnityEngine;

public class UnityHookHandler : SingletonComponent<UnityHookHandler>
{
	public static void EnsureCreated()
	{
		if ((Object)(object)SingletonComponent<UnityHookHandler>.Instance == (Object)null)
		{
			CreateInstance();
		}
	}

	private static void CreateInstance()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Expected O, but got Unknown
		GameObject val = new GameObject("UnityHookHandler");
		val.AddComponent<UnityHookHandler>();
		val.AddComponent<PreUpdateHook>();
		val.AddComponent<PostUpdateHook>();
		Object.DontDestroyOnLoad((Object)val);
		PerformanceMetrics.Setup();
		Debug.Log((object)"Setup unity update hooks");
	}
}


using UnityEngine;

public abstract class UpdateBehaviour : MonoBehaviour
{
}


public class UpdateHandler : SingletonComponent<UpdateHandler>
{
}


using UnityEngine;

public class VisualiseTrigger : MonoBehaviour, IEditorComponent
{
	[SerializeField]
	private Color colour;
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class ArrayEx
{
	public static T[] New<T>(int length)
	{
		if (length == 0)
		{
			return Array.Empty<T>();
		}
		return new T[length];
	}

	public static T GetRandom<T>(this T[] array)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		return array[Random.Range(0, array.Length)];
	}

	public static T GetRandom<T>(this T[] array, uint seed)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		return array[SeedRandom.Range(ref seed, 0, array.Length)];
	}

	public static T GetRandom<T>(this T[] array, ref uint seed)
	{
		if (array == null || array.Length == 0)
		{
			return default(T);
		}
		return array[SeedRandom.Range(ref seed, 0, array.Length)];
	}

	public static void Shuffle<T>(this T[] array, uint seed)
	{
		array.Shuffle(ref seed);
	}

	public static void Shuffle<T>(this T[] array, ref uint seed)
	{
		for (int i = 0; i < array.Length; i++)
		{
			int num = SeedRandom.Range(ref seed, 0, array.Length);
			int num2 = SeedRandom.Range(ref seed, 0, array.Length);
			T val = array[num];
			array[num] = array[num2];
			array[num2] = val;
		}
	}

	public static void BubbleSort<T>(this T[] array) where T : IComparable<T>
	{
		for (int i = 1; i < array.Length; i++)
		{
			T val = array[i];
			for (int num = i - 1; num >= 0; num--)
			{
				T val2 = array[num];
				if (val.CompareTo(val2) >= 0)
				{
					break;
				}
				array[num + 1] = val2;
				array[num] = val;
			}
		}
	}

	public static int BinarySearch<TElement, TNeedle>(this TElement[] array, Func<TElement, TNeedle> selector, TNeedle needle, IComparer<TNeedle> comparer = null)
	{
		if (comparer == null)
		{
			comparer = Comparer<TNeedle>.Default;
		}
		int num = 0;
		int num2 = array.Length - 1;
		while (num <= num2)
		{
			int num3 = num + (num2 - num) / 2;
			TNeedle x = selector(array[num3]);
			int num4 = comparer.Compare(x, needle);
			if (num4 == 0)
			{
				return num3;
			}
			if (num4 < 0)
			{
				num = num3 + 1;
			}
			else
			{
				num2 = num3 - 1;
			}
		}
		return ~num;
	}
}


using System;
using UnityEngine;

public static class BoundsEx
{
	private static Vector3[] pts = (Vector3[])(object)new Vector3[8];

	public static Bounds XZ3D(this Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		return new Bounds(Vector3Ex.XZ3D(((Bounds)(ref bounds)).center), Vector3Ex.XZ3D(((Bounds)(ref bounds)).size));
	}

	public static Bounds Transform(this Bounds bounds, Matrix4x4 matrix)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		Vector3 center = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(((Bounds)(ref bounds)).center);
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		Vector3 val = ((Matrix4x4)(ref matrix)).MultiplyVector(new Vector3(extents.x, 0f, 0f));
		Vector3 val2 = ((Matrix4x4)(ref matrix)).MultiplyVector(new Vector3(0f, extents.y, 0f));
		Vector3 val3 = ((Matrix4x4)(ref matrix)).MultiplyVector(new Vector3(0f, 0f, extents.z));
		extents.x = Mathf.Abs(val.x) + Mathf.Abs(val2.x) + Mathf.Abs(val3.x);
		extents.y = Mathf.Abs(val.y) + Mathf.Abs(val2.y) + Mathf.Abs(val3.y);
		extents.z = Mathf.Abs(val.z) + Mathf.Abs(val2.z) + Mathf.Abs(val3.z);
		Bounds result = default(Bounds);
		((Bounds)(ref result)).center = center;
		((Bounds)(ref result)).extents = extents;
		return result;
	}

	public static Rect ToScreenRect(this Bounds b, Camera cam)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0305: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_032b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("Bounds.ToScreenRect", 0);
		try
		{
			pts[0] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[1] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			pts[2] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[3] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x + ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			pts[4] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[5] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y + ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			pts[6] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z + ((Bounds)(ref b)).extents.z));
			pts[7] = cam.WorldToScreenPoint(new Vector3(((Bounds)(ref b)).center.x - ((Bounds)(ref b)).extents.x, ((Bounds)(ref b)).center.y - ((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).center.z - ((Bounds)(ref b)).extents.z));
			Vector3 val2 = pts[0];
			Vector3 val3 = pts[0];
			for (int i = 1; i < pts.Length; i++)
			{
				val2 = Vector3.Min(val2, pts[i]);
				val3 = Vector3.Max(val3, pts[i]);
			}
			return Rect.MinMaxRect(val2.x, val2.y, val3.x, val3.y);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Rect ToCanvasRect(this Bounds b, RectTransform target, Camera cam)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Rect result = b.ToScreenRect(cam);
		((Rect)(ref result)).min = Vector2Ex.ToCanvas(((Rect)(ref result)).min, target, (Camera)null);
		((Rect)(ref result)).max = Vector2Ex.ToCanvas(((Rect)(ref result)).max, target, (Camera)null);
		return result;
	}

	public static float InnerDistToEdge2D(this Bounds b, Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Abs(point.x - ((Bounds)(ref b)).min.x);
		float num2 = Mathf.Abs(point.x - ((Bounds)(ref b)).max.x);
		float num3 = Mathf.Abs(point.z - ((Bounds)(ref b)).min.z);
		float num4 = Mathf.Abs(point.z - ((Bounds)(ref b)).max.z);
		return Mathf.Min(num, Mathf.Min(num2, Mathf.Min(num3, num4)));
	}

	public static float MaxExtent(this Bounds b)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Max(((Bounds)(ref b)).extents.x, Mathf.Max(((Bounds)(ref b)).extents.y, ((Bounds)(ref b)).extents.z));
	}

	public static Vector3 Top(this Bounds b)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref b)).center + Vector3.up * ((Bounds)(ref b)).extents.y;
	}
}


using System.Collections.Generic;

public static class CollectionEx
{
	public static bool IsNullOrEmpty<T>(this ICollection<T> collection)
	{
		if (collection != null)
		{
			return collection.Count == 0;
		}
		return true;
	}

	public static bool IsEmpty<T>(this ICollection<T> collection)
	{
		return collection.Count == 0;
	}
}


using System;
using System.IO;
using System.Threading;

public static class DirectoryEx
{
	public static void Backup(DirectoryInfo parent, params string[] names)
	{
		for (int i = 0; i < names.Length; i++)
		{
			names[i] = Path.Combine(parent.FullName, names[i]);
		}
		Backup(names);
	}

	public static bool MoveToSafe(this DirectoryInfo parent, string target, int retries = 10)
	{
		for (int i = 0; i < retries; i++)
		{
			try
			{
				parent.MoveTo(target);
			}
			catch (Exception)
			{
				Thread.Sleep(5);
				continue;
			}
			return true;
		}
		return false;
	}

	public static void Backup(params string[] names)
	{
		for (int num = names.Length - 2; num >= 0; num--)
		{
			DirectoryInfo directoryInfo = new DirectoryInfo(names[num]);
			DirectoryInfo directoryInfo2 = new DirectoryInfo(names[num + 1]);
			if (directoryInfo.Exists)
			{
				if (directoryInfo2.Exists)
				{
					double totalHours = (DateTime.Now - directoryInfo2.LastWriteTime).TotalHours;
					int num2 = ((num != 0) ? (1 << num - 1) : 0);
					if (totalHours >= (double)num2)
					{
						directoryInfo2.Delete(recursive: true);
						directoryInfo.MoveToSafe(directoryInfo2.FullName);
					}
				}
				else
				{
					if (!directoryInfo2.Parent.Exists)
					{
						directoryInfo2.Parent.Create();
					}
					directoryInfo.MoveToSafe(directoryInfo2.FullName);
				}
			}
		}
	}

	public static void CopyAll(string sourceDirectory, string targetDirectory)
	{
		DirectoryInfo source = new DirectoryInfo(sourceDirectory);
		DirectoryInfo target = new DirectoryInfo(targetDirectory);
		CopyAll(source, target);
	}

	public static void CopyAll(DirectoryInfo source, DirectoryInfo target)
	{
		if (source.FullName.ToLower() == target.FullName.ToLower() || !source.Exists)
		{
			return;
		}
		if (!target.Exists)
		{
			target.Create();
		}
		FileInfo[] files = source.GetFiles();
		foreach (FileInfo fileInfo in files)
		{
			FileInfo fileInfo2 = new FileInfo(Path.Combine(target.FullName, fileInfo.Name));
			fileInfo.CopyTo(fileInfo2.FullName, overwrite: true);
			try
			{
				fileInfo2.CreationTime = fileInfo.CreationTime;
				fileInfo2.LastAccessTime = fileInfo.LastAccessTime;
				fileInfo2.LastWriteTime = fileInfo.LastWriteTime;
			}
			catch (IOException)
			{
			}
		}
		DirectoryInfo[] directories = source.GetDirectories();
		foreach (DirectoryInfo directoryInfo in directories)
		{
			DirectoryInfo directoryInfo2 = target.CreateSubdirectory(directoryInfo.Name);
			CopyAll(directoryInfo, directoryInfo2);
			try
			{
				directoryInfo2.CreationTime = directoryInfo.CreationTime;
				directoryInfo2.LastAccessTime = directoryInfo.LastAccessTime;
				directoryInfo2.LastWriteTime = directoryInfo.LastWriteTime;
			}
			catch (IOException)
			{
			}
		}
	}
}


using System;
using System.IO;
using System.Threading;

public static class FileEx
{
	public static void Backup(DirectoryInfo parent, params string[] names)
	{
		for (int i = 0; i < names.Length; i++)
		{
			names[i] = Path.Combine(parent.FullName, names[i]);
		}
		Backup(names);
	}

	public static bool MoveToSafe(this FileInfo parent, string target, int retries = 10)
	{
		for (int i = 0; i < retries; i++)
		{
			try
			{
				parent.MoveTo(target);
			}
			catch (Exception)
			{
				Thread.Sleep(5);
				continue;
			}
			return true;
		}
		return false;
	}

	public static void Backup(params string[] names)
	{
		for (int num = names.Length - 2; num >= 0; num--)
		{
			FileInfo fileInfo = new FileInfo(names[num]);
			FileInfo fileInfo2 = new FileInfo(names[num + 1]);
			if (fileInfo.Exists)
			{
				if (fileInfo2.Exists)
				{
					double totalHours = (DateTime.Now - fileInfo2.LastWriteTime).TotalHours;
					int num2 = ((num != 0) ? (1 << num - 1) : 0);
					if (totalHours >= (double)num2)
					{
						fileInfo2.Delete();
						fileInfo.MoveToSafe(fileInfo2.FullName);
					}
				}
				else
				{
					if (!fileInfo2.Directory.Exists)
					{
						fileInfo2.Directory.Create();
					}
					fileInfo.MoveToSafe(fileInfo2.FullName);
				}
			}
		}
	}
}


using System;
using System.Collections.Generic;

public static class LinqEx
{
	public static int MaxIndex<T>(this IEnumerable<T> sequence) where T : IComparable<T>
	{
		int num = -1;
		T other = default(T);
		int num2 = 0;
		foreach (T item in sequence)
		{
			if (item.CompareTo(other) > 0 || num == -1)
			{
				num = num2;
				other = item;
			}
			num2++;
		}
		return num;
	}
}


using Network;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;

public static class NetworkWriteEx
{
	public static void WriteObject<T>(this NetWrite write, T obj)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		if (typeof(T) == typeof(Vector3))
		{
			Vector3 val = GenericsUtil.Cast<T, Vector3>(obj);
			write.Vector3(ref val);
			return;
		}
		if (typeof(T) == typeof(Vector4))
		{
			Vector4 val2 = GenericsUtil.Cast<T, Vector4>(obj);
			write.Vector4(ref val2);
			return;
		}
		if (typeof(T) == typeof(Ray))
		{
			Ray val3 = GenericsUtil.Cast<T, Ray>(obj);
			write.Ray(ref val3);
			return;
		}
		if (typeof(T) == typeof(float))
		{
			write.Float(GenericsUtil.Cast<T, float>(obj));
			return;
		}
		if (typeof(T) == typeof(short))
		{
			write.Int16(GenericsUtil.Cast<T, short>(obj));
			return;
		}
		if (typeof(T) == typeof(ushort))
		{
			write.UInt16(GenericsUtil.Cast<T, ushort>(obj));
			return;
		}
		if (typeof(T) == typeof(int))
		{
			write.Int32(GenericsUtil.Cast<T, int>(obj));
			return;
		}
		if (typeof(T) == typeof(uint))
		{
			write.UInt32(GenericsUtil.Cast<T, uint>(obj));
			return;
		}
		if (typeof(T) == typeof(byte[]))
		{
			write.Bytes(GenericsUtil.Cast<T, byte[]>(obj));
			return;
		}
		if (typeof(T) == typeof(long))
		{
			write.Int64(GenericsUtil.Cast<T, long>(obj));
			return;
		}
		if (typeof(T) == typeof(ulong))
		{
			write.UInt64(GenericsUtil.Cast<T, ulong>(obj));
			return;
		}
		if (typeof(T) == typeof(string))
		{
			write.String(GenericsUtil.Cast<T, string>(obj), false);
			return;
		}
		if (typeof(T) == typeof(sbyte))
		{
			write.Int8(GenericsUtil.Cast<T, sbyte>(obj));
			return;
		}
		if (typeof(T) == typeof(byte))
		{
			write.UInt8(GenericsUtil.Cast<T, byte>(obj));
			return;
		}
		if (typeof(T) == typeof(bool))
		{
			write.Bool(GenericsUtil.Cast<T, bool>(obj));
			return;
		}
		if (typeof(T) == typeof(Color))
		{
			Color val4 = GenericsUtil.Cast<T, Color>(obj);
			write.Color(ref val4);
			return;
		}
		if (typeof(T) == typeof(Color32))
		{
			Color32 val5 = GenericsUtil.Cast<T, Color32>(obj);
			write.Color32(ref val5);
			return;
		}
		if (typeof(T) == typeof(NetworkableId))
		{
			write.EntityID(GenericsUtil.Cast<T, NetworkableId>(obj));
			return;
		}
		if (typeof(T) == typeof(ItemContainerId))
		{
			write.ItemContainerID(GenericsUtil.Cast<T, ItemContainerId>(obj));
			return;
		}
		if (typeof(T) == typeof(ItemId))
		{
			write.ItemID(GenericsUtil.Cast<T, ItemId>(obj));
			return;
		}
		object obj2 = obj;
		IProto val6 = (IProto)((obj2 is IProto) ? obj2 : null);
		if (val6 != null)
		{
			write.Proto<IProto>(val6);
			return;
		}
		T val7 = obj;
		Debug.LogError((object)("NetworkData.Write - no handler to write " + val7?.ToString() + " -> " + obj.GetType()));
	}
}


public static class ObjectEx
{
	public static bool IsUnityNull<T>(this T obj) where T : class
	{
		return obj?.Equals(null) ?? true;
	}
}


using UnityEngine;

public static class ParticleSystemEx
{
	public static void SetPlayingState(this ParticleSystem ps, bool play)
	{
		if (!((Object)(object)ps == (Object)null))
		{
			if (play && !ps.isPlaying)
			{
				ps.Play();
			}
			else if (!play && ps.isPlaying)
			{
				ps.Stop();
			}
		}
	}

	public static void SetEmitterState(this ParticleSystem ps, bool enable)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		EmissionModule emission = ps.emission;
		if (enable != ((EmissionModule)(ref emission)).enabled)
		{
			EmissionModule emission2 = ps.emission;
			((EmissionModule)(ref emission2)).enabled = enable;
		}
	}
}


using Rust;
using UnityEngine;

public static class RaycastHitEx
{
	public static Transform GetTransform(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).transform;
	}

	public static Rigidbody GetRigidbody(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).rigidbody;
	}

	public static Collider GetCollider(this RaycastHit hit)
	{
		return ((RaycastHit)(ref hit)).collider;
	}

	public static BaseEntity GetEntity(this RaycastHit hit)
	{
		if (!((Object)(object)((RaycastHit)(ref hit)).collider != (Object)null))
		{
			return null;
		}
		return ((RaycastHit)(ref hit)).collider.ToBaseEntity();
	}

	public static bool IsOnLayer(this RaycastHit hit, Layer rustLayer)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)((RaycastHit)(ref hit)).collider != (Object)null)
		{
			return ((Component)((RaycastHit)(ref hit)).collider).gameObject.IsOnLayer(rustLayer);
		}
		return false;
	}

	public static bool IsOnLayer(this RaycastHit hit, int layer)
	{
		if ((Object)(object)((RaycastHit)(ref hit)).collider != (Object)null)
		{
			return ((Component)((RaycastHit)(ref hit)).collider).gameObject.IsOnLayer(layer);
		}
		return false;
	}

	public static bool IsWaterHit(this RaycastHit hit)
	{
		if (!((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null))
		{
			return ((Component)((RaycastHit)(ref hit)).collider).gameObject.IsOnLayer((Layer)4);
		}
		return true;
	}

	public static WaterBody GetWaterBody(this RaycastHit hit)
	{
		if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
		{
			return WaterSystem.Ocean;
		}
		Transform transform = ((Component)((RaycastHit)(ref hit)).collider).transform;
		WaterBody result = default(WaterBody);
		if (((Component)transform).TryGetComponent<WaterBody>(ref result))
		{
			return result;
		}
		return ((Component)transform.parent).GetComponentInChildren<WaterBody>();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class RendererEx
{
	private static readonly Memoized<Material[], int> ArrayCache = new Memoized<Material[], int>((Func<int, Material[]>)((int n) => (Material[])(object)new Material[n]));

	private static MaterialPropertyBlock[] per_material_blocks;

	public static void SetSharedMaterials(this Renderer renderer, List<Material> materials)
	{
		if (materials.Count != 0)
		{
			if (materials.Count > 10)
			{
				throw new ArgumentOutOfRangeException("materials");
			}
			Material[] array = ArrayCache.Get(materials.Count);
			for (int i = 0; i < materials.Count; i++)
			{
				array[i] = materials[i];
			}
			renderer.sharedMaterials = array;
		}
	}

	public static MaterialPropertyBlock[] GetMaterialPropertyBlocksUnsafe(this Renderer renderer)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Expected O, but got Unknown
		if (!renderer.HasPropertyBlock())
		{
			return null;
		}
		if (per_material_blocks == null || renderer.sharedMaterials.Length > per_material_blocks.Length)
		{
			Array.Resize(ref per_material_blocks, Mathf.NextPowerOfTwo(renderer.sharedMaterials.Length));
			for (int i = 0; i < per_material_blocks.Length; i++)
			{
				ref MaterialPropertyBlock reference = ref per_material_blocks[i];
				if (reference == null)
				{
					reference = new MaterialPropertyBlock();
				}
			}
		}
		for (int j = 0; j < renderer.sharedMaterials.Length; j++)
		{
			renderer.GetPropertyBlock(per_material_blocks[j], j);
			if (per_material_blocks[j].isEmpty)
			{
				renderer.GetPropertyBlock(per_material_blocks[j]);
			}
		}
		return per_material_blocks;
	}
}


using System.IO;

public static class StreamEx
{
	private static readonly byte[] StaticBuffer = new byte[16384];

	public static void WriteToOtherStream(this Stream self, Stream target)
	{
		int count;
		while ((count = self.Read(StaticBuffer, 0, StaticBuffer.Length)) > 0)
		{
			target.Write(StaticBuffer, 0, count);
		}
	}
}


using System;

public static class TimeSpanEx
{
	public static string ToShortString(this TimeSpan timeSpan)
	{
		return $"{(int)timeSpan.TotalHours:00}:{timeSpan.Minutes:00}:{timeSpan.Seconds:00}";
	}

	public static string ToShortStringNoHours(this TimeSpan timeSpan)
	{
		return $"{timeSpan.Minutes:00}:{timeSpan.Seconds:00}";
	}
}


using UnityEngine;

public class FPSLogger : MonoBehaviour
{
}


using System;
using Facepunch;
using UnityEngine;

public static class FuzzySearch
{
	[ClientVar(Help = "How similar the server name must be to the search filter to be included in the results. (0 is exact match, 1 is no match at all)")]
	public static float search_similarity_modifier = 0.14f;

	private static ArrayPool<int> _levenshteinDistancePool;

	private static int DamerauLevenshteinDistance(string source, string target)
	{
		if (_levenshteinDistancePool == null)
		{
			_levenshteinDistancePool = new ArrayPool<int>(256);
		}
		if (string.IsNullOrEmpty(source))
		{
			if (!string.IsNullOrEmpty(target))
			{
				return target.Length;
			}
			return 0;
		}
		if (string.IsNullOrEmpty(target))
		{
			return source.Length;
		}
		if (source.Length > target.Length)
		{
			string text = target;
			string text2 = source;
			source = text;
			target = text2;
		}
		int length = source.Length;
		int length2 = target.Length;
		int[] array = _levenshteinDistancePool.Rent(length2 + 1);
		int[] array2 = _levenshteinDistancePool.Rent(length2 + 1);
		int[] array3 = _levenshteinDistancePool.Rent(length2 + 1);
		try
		{
			for (int i = 0; i <= length2; i++)
			{
				array[i] = i;
			}
			for (int j = 1; j <= length; j++)
			{
				array2[0] = j;
				for (int k = 1; k <= length2; k++)
				{
					int num = ((source[j - 1] != target[k - 1]) ? 1 : 0);
					int val = array[k] + 1;
					int val2 = array2[k - 1] + 1;
					int num2 = Math.Min(val2: array[k - 1] + num, val1: Math.Min(val, val2));
					if (j > 1 && k > 1 && source[j - 1] == target[k - 2] && source[j - 2] == target[k - 1])
					{
						num2 = Math.Min(num2, array3[k - 2] + num);
					}
					array2[k] = num2;
				}
				int[] array4 = array;
				int[] array5 = array2;
				int[] array6 = array3;
				array3 = array4;
				array = array5;
				array2 = array6;
			}
			return array[length2];
		}
		finally
		{
			_levenshteinDistancePool.Return(array);
			_levenshteinDistancePool.Return(array2);
			_levenshteinDistancePool.Return(array3);
		}
	}

	public static bool IsSimilarWithThreshold(string source, string target, float threshold)
	{
		bool flag = string.IsNullOrEmpty(source);
		bool flag2 = string.IsNullOrEmpty(target);
		if (flag && flag2)
		{
			return true;
		}
		if (flag || flag2)
		{
			return false;
		}
		string text = source.ToLower().Trim();
		string text2 = target.ToLower().Trim();
		int num = DamerauLevenshteinDistance(text, text2);
		if (num <= 3)
		{
			return true;
		}
		int num2 = Mathf.Max(text.Length, text2.Length);
		return 1f - (float)num / (float)num2 >= threshold;
	}

	public static bool IsSimilar(string source, string target)
	{
		return IsSimilarWithThreshold(source, target, search_similarity_modifier);
	}

	public static bool IsSimilarFuzzy(this string source, string target)
	{
		return IsSimilar(source, target);
	}

	public static bool IsSimilarFuzzy(this string source, string target, float threshold)
	{
		return IsSimilarWithThreshold(source, target, threshold);
	}
}


using UnityEngine;

public class BlendTexture : ProcessedTexture
{
	public BlendTexture(int width, int height, bool linear = true)
	{
		material = CreateMaterial("Hidden/BlitCopyAlpha");
		result = CreateRenderTexture("Blend Texture", width, height, linear);
	}

	public void Blend(Texture source, Texture target, float alpha)
	{
		material.SetTexture("_BlendTex", target);
		material.SetFloat("_Alpha", Mathf.Clamp01(alpha));
		Graphics.Blit(source, result, material);
	}

	public void CopyTo(BlendTexture target)
	{
		Graphics.Blit((Texture)(object)result, target.result);
	}
}


using UnityEngine;

public class BlurTexture : ProcessedTexture
{
	public BlurTexture(int width, int height, bool linear = true)
	{
		material = CreateMaterial("Hidden/Rust/SeparableBlur");
		result = CreateRenderTexture("Blur Texture", width, height, linear);
	}

	public void Blur(float radius)
	{
		Blur((Texture)(object)result, radius);
	}

	public void Blur(Texture source, float radius)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		RenderTexture val = CreateTemporary();
		material.SetVector("offsets", new Vector4(radius / (float)Screen.width, 0f, 0f, 0f));
		Graphics.Blit(source, val, material, 0);
		material.SetVector("offsets", new Vector4(0f, radius / (float)Screen.height, 0f, 0f));
		Graphics.Blit((Texture)(object)val, result, material, 0);
		ReleaseTemporary(val);
	}
}


using UnityEngine;

public static class CameraUtil
{
	public static void NormalizePlane(ref Plane plane)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = ((Plane)(ref plane)).normal;
		float num = 1f / ((Vector3)(ref normal)).magnitude;
		((Plane)(ref plane)).normal = ((Plane)(ref plane)).normal * num;
		((Plane)(ref plane)).distance = ((Plane)(ref plane)).distance * num;
	}

	public static void ExtractPlanes(Camera camera, ref Plane[] planes)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 worldToCameraMatrix = camera.worldToCameraMatrix;
		ExtractPlanes(GL.GetGPUProjectionMatrix(camera.projectionMatrix, false) * worldToCameraMatrix, ref planes);
	}

	public static void ExtractPlanes(Matrix4x4 viewProjMatrix, ref Plane[] planes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		((Plane)(ref planes[0])).normal = new Vector3(viewProjMatrix.m30 + viewProjMatrix.m00, viewProjMatrix.m31 + viewProjMatrix.m01, viewProjMatrix.m32 + viewProjMatrix.m02);
		((Plane)(ref planes[0])).distance = viewProjMatrix.m33 + viewProjMatrix.m03;
		NormalizePlane(ref planes[0]);
		((Plane)(ref planes[1])).normal = new Vector3(viewProjMatrix.m30 - viewProjMatrix.m00, viewProjMatrix.m31 - viewProjMatrix.m01, viewProjMatrix.m32 - viewProjMatrix.m02);
		((Plane)(ref planes[1])).distance = viewProjMatrix.m33 - viewProjMatrix.m03;
		NormalizePlane(ref planes[1]);
		((Plane)(ref planes[2])).normal = new Vector3(viewProjMatrix.m30 - viewProjMatrix.m10, viewProjMatrix.m31 - viewProjMatrix.m11, viewProjMatrix.m32 - viewProjMatrix.m12);
		((Plane)(ref planes[2])).distance = viewProjMatrix.m33 - viewProjMatrix.m13;
		NormalizePlane(ref planes[2]);
		((Plane)(ref planes[3])).normal = new Vector3(viewProjMatrix.m30 + viewProjMatrix.m10, viewProjMatrix.m31 + viewProjMatrix.m11, viewProjMatrix.m32 + viewProjMatrix.m12);
		((Plane)(ref planes[3])).distance = viewProjMatrix.m33 + viewProjMatrix.m13;
		NormalizePlane(ref planes[3]);
		((Plane)(ref planes[4])).normal = new Vector3(viewProjMatrix.m20, viewProjMatrix.m21, viewProjMatrix.m22);
		((Plane)(ref planes[4])).distance = viewProjMatrix.m23;
		NormalizePlane(ref planes[4]);
		((Plane)(ref planes[5])).normal = new Vector3(viewProjMatrix.m30 - viewProjMatrix.m20, viewProjMatrix.m31 - viewProjMatrix.m21, viewProjMatrix.m32 - viewProjMatrix.m22);
		((Plane)(ref planes[5])).distance = viewProjMatrix.m33 - viewProjMatrix.m23;
		NormalizePlane(ref planes[5]);
	}
}


using UnityEngine;

public class ClimateBlendTexture : ProcessedTexture
{
	public ClimateBlendTexture(int width, int height, bool linear = true)
	{
		material = CreateMaterial("Hidden/ClimateBlendLUTs");
		result = CreateRenderTexture("Climate Blend Texture", width, height, linear);
		((Texture)result).wrapMode = (TextureWrapMode)1;
	}

	public bool CheckLostData()
	{
		if (!result.IsCreated())
		{
			result.Create();
			return true;
		}
		return false;
	}

	public void Blend(Texture srcLut1, Texture dstLut1, float lerpLut1, Texture srcLut2, Texture dstLut2, float lerpLut2, float lerp, ClimateBlendTexture prevLut, float time)
	{
		material.SetTexture("_srcLut1", srcLut1);
		material.SetTexture("_dstLut1", dstLut1);
		material.SetTexture("_srcLut2", srcLut2);
		material.SetTexture("_dstLut2", dstLut2);
		material.SetTexture("_prevLut", (Texture)prevLut);
		material.SetFloat("_lerpLut1", lerpLut1);
		material.SetFloat("_lerpLut2", lerpLut2);
		material.SetFloat("_lerp", lerp);
		material.SetFloat("_time", time);
		Graphics.Blit((Texture)null, result, material);
	}

	public static void Swap(ref ClimateBlendTexture a, ref ClimateBlendTexture b)
	{
		ClimateBlendTexture climateBlendTexture = a;
		a = b;
		b = climateBlendTexture;
	}
}


using UnityEngine;

public class DistanceField
{
	private static readonly int[] GaussOffsets = new int[7] { -6, -4, -2, 0, 2, 4, 6 };

	private static readonly float[] GaussWeights = new float[7]
	{
		1f / 32f,
		7f / 64f,
		7f / 32f,
		9f / 32f,
		7f / 32f,
		7f / 64f,
		1f / 32f
	};

	public static void Generate(in int size, in byte threshold, in byte[] image, ref float[] distanceField)
	{
		int num = size + 2;
		int[] array = new int[num * num];
		int[] array2 = new int[num * num];
		float[] array3 = new float[num * num];
		int i = 0;
		int num2 = 0;
		for (; i < num; i++)
		{
			int num3 = 0;
			while (num3 < num)
			{
				array[num2] = -1;
				array2[num2] = -1;
				array3[num2] = float.PositiveInfinity;
				num3++;
				num2++;
			}
		}
		int num4 = 1;
		int num5 = num4 * size;
		int num6 = num4 * num;
		while (num4 < size - 2)
		{
			int num7 = 1;
			int num8 = num5 + num7;
			int num9 = num6 + num7;
			while (num7 < size - 2)
			{
				int num10 = num9 + num + 1;
				bool flag = image[num8] > threshold;
				if (flag && (image[num8 - 1] > threshold != flag || image[num8 + 1] > threshold != flag || image[num8 - size] > threshold != flag || image[num8 + size] > threshold != flag))
				{
					array[num10] = num7 + 1;
					array2[num10] = num4 + 1;
					array3[num10] = 0f;
				}
				num7++;
				num8++;
				num9++;
			}
			num4++;
			num5 += size;
			num6 += num;
		}
		int num11 = 1;
		int num12 = num11 * num;
		while (num11 < num - 1)
		{
			int num13 = 1;
			int num14 = num12 + num13;
			while (num13 < num - 1)
			{
				int num15 = num14 - 1;
				int num16 = num14 - num;
				int num17 = num16 - 1;
				int num18 = num16 + 1;
				float num19 = array3[num14];
				if (array3[num17] + 1.4142135f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num17])), (float)(num11 - (array2[num14] = array2[num17]))));
				}
				if (array3[num16] + 1f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num16])), (float)(num11 - (array2[num14] = array2[num16]))));
				}
				if (array3[num18] + 1.4142135f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num18])), (float)(num11 - (array2[num14] = array2[num18]))));
				}
				if (array3[num15] + 1f < num19)
				{
					num19 = (array3[num14] = Vector2Ex.Length((float)(num13 - (array[num14] = array[num15])), (float)(num11 - (array2[num14] = array2[num15]))));
				}
				num13++;
				num14++;
			}
			num11++;
			num12 += num;
		}
		int num20 = num - 2;
		int num21 = num20 * num;
		while (num20 >= 1)
		{
			int num22 = num - 2;
			int num23 = num21 + num22;
			while (num22 >= 1)
			{
				int num24 = num23 + 1;
				int num25 = num23 + num;
				int num26 = num25 - 1;
				int num27 = num25 + 1;
				float num28 = array3[num23];
				if (array3[num24] + 1f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num24])), (float)(num20 - (array2[num23] = array2[num24]))));
				}
				if (array3[num26] + 1.4142135f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num26])), (float)(num20 - (array2[num23] = array2[num26]))));
				}
				if (array3[num25] + 1f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num25])), (float)(num20 - (array2[num23] = array2[num25]))));
				}
				if (array3[num27] + 1f < num28)
				{
					num28 = (array3[num23] = Vector2Ex.Length((float)(num22 - (array[num23] = array[num27])), (float)(num20 - (array2[num23] = array2[num27]))));
				}
				num22--;
				num23--;
			}
			num20--;
			num21 -= num;
		}
		int num29 = 0;
		int num30 = 0;
		int num31 = num;
		while (num29 < size)
		{
			int num32 = 0;
			int num33 = num31 + 1;
			while (num32 < size)
			{
				distanceField[num30] = ((image[num30] > threshold) ? (0f - array3[num33]) : array3[num33]);
				num32++;
				num30++;
				num33++;
			}
			num29++;
			num31 += num;
		}
	}

	private static float SampleClamped(float[] data, int size, int x, int y)
	{
		x = ((x >= 0) ? x : 0);
		y = ((y >= 0) ? y : 0);
		x = ((x >= size) ? (size - 1) : x);
		y = ((y >= size) ? (size - 1) : y);
		return data[y * size + x];
	}

	private static Vector4 SampleClamped(Vector4[] data, int size, int x, int y)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		x = ((x >= 0) ? x : 0);
		y = ((y >= 0) ? y : 0);
		x = ((x >= size) ? (size - 1) : x);
		y = ((y >= size) ? (size - 1) : y);
		return data[y * size + x];
	}

	private static ushort SampleClamped(ushort[] data, int size, int x, int y)
	{
		x = ((x >= 0) ? x : 0);
		y = ((y >= 0) ? y : 0);
		x = ((x >= size) ? (size - 1) : x);
		y = ((y >= size) ? (size - 1) : y);
		return data[y * size + x];
	}

	public static void GenerateVectors(in int size, in float[] distanceField, ref Vector4[] vectorField)
	{
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0184: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 1; i < size - 1; i++)
		{
			for (int j = 1; j < size - 1; j++)
			{
				float num = SampleClamped(distanceField, size, i, j);
				float num2 = SampleClamped(distanceField, size, i - 1, j - 1);
				float num3 = SampleClamped(distanceField, size, i - 1, j);
				float num4 = SampleClamped(distanceField, size, i - 1, j + 1);
				float num5 = SampleClamped(distanceField, size, i, j - 1);
				float num6 = SampleClamped(distanceField, size, i, j + 1);
				float num7 = SampleClamped(distanceField, size, i + 1, j - 1);
				float num8 = SampleClamped(distanceField, size, i + 1, j);
				float num9 = SampleClamped(distanceField, size, i + 1, j + 1);
				float num10 = num7 + 2f * num8 + num9 - (num2 + 2f * num3 + num4);
				float num11 = num4 + 2f * num6 + num9 - (num2 + 2f * num5 + num7);
				Vector2 val = new Vector2(0f - num10, 0f - num11);
				Vector2 normalized = ((Vector2)(ref val)).normalized;
				vectorField[j * size + i] = new Vector4(normalized.x, normalized.y, num, 0f);
			}
		}
		for (int k = 1; k < size - 1; k++)
		{
			vectorField[k] = SampleClamped(vectorField, size, k, 1);
			vectorField[(size - 1) * size + k] = SampleClamped(vectorField, size, k, size - 2);
		}
		for (int l = 0; l < size; l++)
		{
			vectorField[l * size] = SampleClamped(vectorField, size, 1, l);
			vectorField[l * size + size - 1] = SampleClamped(vectorField, size, size - 2, l);
		}
	}

	public static void ApplyGaussianBlur(int size, float[] distanceField, int steps = 1)
	{
		if (steps <= 0)
		{
			return;
		}
		float[] array = new float[size * size];
		int num = size - 1;
		for (int i = 0; i < steps; i++)
		{
			int num2 = 0;
			int num3 = 0;
			int num4 = 0;
			while (num2 < size)
			{
				int num5 = 0;
				while (num5 < size)
				{
					float num6 = 0f;
					for (int j = 0; j < 7; j++)
					{
						int num7 = num5 + GaussOffsets[j];
						num7 = ((num7 >= 0) ? num7 : 0);
						num7 = ((num7 <= num) ? num7 : num);
						num6 += distanceField[num4 + num7] * GaussWeights[j];
					}
					array[num3] = num6;
					num5++;
					num3++;
				}
				num2++;
				num4 += size;
			}
			int k = 0;
			int num8 = 0;
			for (; k < size; k++)
			{
				int num9 = 0;
				while (num9 < size)
				{
					float num10 = 0f;
					for (int l = 0; l < 7; l++)
					{
						int num11 = k + GaussOffsets[l];
						num11 = ((num11 >= 0) ? num11 : 0);
						num11 = ((num11 <= num) ? num11 : num);
						num10 += array[num11 * size + num9] * GaussWeights[l];
					}
					distanceField[num8] = num10;
					num9++;
					num8++;
				}
			}
		}
	}
}


using UnityEngine;

public class ProcessedTexture
{
	protected RenderTexture result;

	protected Material material;

	public void Dispose()
	{
		DestroyRenderTexture(ref result);
		DestroyMaterial(ref material);
	}

	protected RenderTexture CreateRenderTexture(string name, int width, int height, bool linear)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected O, but got Unknown
		RenderTexture val = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)(linear ? 1 : 2))
		{
			hideFlags = (HideFlags)52,
			name = name,
			filterMode = (FilterMode)1,
			anisoLevel = 0
		};
		val.Create();
		return val;
	}

	protected void DestroyRenderTexture(ref RenderTexture rt)
	{
		if (!((Object)(object)rt == (Object)null))
		{
			Object.Destroy((Object)(object)rt);
			rt = null;
		}
	}

	protected RenderTexture CreateTemporary()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return RenderTexture.GetTemporary(((Texture)result).width, ((Texture)result).height, result.depth, result.format, (RenderTextureReadWrite)((!result.sRGB) ? 1 : 2));
	}

	protected void ReleaseTemporary(RenderTexture rt)
	{
		RenderTexture.ReleaseTemporary(rt);
	}

	protected Material CreateMaterial(string shader)
	{
		return CreateMaterial(Shader.Find(shader));
	}

	protected Material CreateMaterial(Shader shader)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Expected O, but got Unknown
		return new Material(shader)
		{
			hideFlags = (HideFlags)52
		};
	}

	protected void DestroyMaterial(ref Material mat)
	{
		if (!((Object)(object)mat == (Object)null))
		{
			Object.Destroy((Object)(object)mat);
			mat = null;
		}
	}

	public static implicit operator Texture(ProcessedTexture t)
	{
		return (Texture)(object)t.result;
	}
}


using UnityEngine;

public class sRGB
{
	public static byte[] to_linear;

	public static byte[] to_srgb;

	static sRGB()
	{
		to_linear = new byte[256];
		to_srgb = new byte[256];
		to_linear = new byte[256];
		to_srgb = new byte[256];
		for (int i = 0; i < 256; i++)
		{
			to_linear[i] = (byte)(srgb_to_linear((float)i * 0.003921569f) * 255f + 0.5f);
		}
		for (int j = 0; j < 256; j++)
		{
			to_srgb[j] = (byte)(linear_to_srgb((float)j * 0.003921569f) * 255f + 0.5f);
		}
	}

	public static float linear_to_srgb(float linear)
	{
		if (float.IsNaN(linear))
		{
			return 0f;
		}
		if (linear > 1f)
		{
			return 1f;
		}
		if (linear < 0f)
		{
			return 0f;
		}
		if (linear < 0.0031308f)
		{
			return 12.92f * linear;
		}
		return 1.055f * Mathf.Pow(linear, 0.41666f) - 0.055f;
	}

	public static float srgb_to_linear(float srgb)
	{
		if (srgb <= 0.04045f)
		{
			return srgb / 12.92f;
		}
		return Mathf.Pow((srgb + 0.055f) / 1.055f, 2.4f);
	}
}


using UnityEngine;

public static class AssetStorage
{
	public static void Save<T>(ref T asset, string path) where T : Object
	{
		Object.op_Implicit((Object)(object)asset);
	}

	public static void Save(ref Texture2D asset)
	{
	}

	public static void Save(ref Texture2D asset, string path, bool linear, bool compress)
	{
		Object.op_Implicit((Object)(object)asset);
	}

	public static void Load<T>(ref T asset, string path) where T : Object
	{
	}

	public static void Delete<T>(ref T asset) where T : Object
	{
		if (Object.op_Implicit((Object)(object)asset))
		{
			Object.Destroy((Object)(object)asset);
			asset = default(T);
		}
	}
}


using System;

public static class CollectionUtil
{
	public static void SortInplace<T>(Span<T> values, Span<int> indices)
	{
		for (int i = 0; i < indices.Length; i++)
		{
			int num = i;
			int num2 = indices[i];
			if (num2 != -1 && num != num2)
			{
				while (num2 != -1 && num != num2)
				{
					T val = values[num2];
					values[num2] = values[i];
					values[i] = val;
					indices[num] = -1;
					num = num2;
					num2 = indices[num2];
				}
			}
		}
	}

	public static void ScatterOutInplace<T>(Span<T> values, ReadOnlySpan<int> indices, T defValue = default(T))
	{
		int num = indices.Length;
		while (num > 0)
		{
			num--;
			int num2 = indices[num];
			if (num != num2)
			{
				values[num2] = values[num];
				values[num] = defValue;
			}
		}
	}

	public static void ScatterTo<T>(ReadOnlySpan<T> from, Span<T> to, ReadOnlySpan<int> indicesTo)
	{
		for (int i = 0; i < indicesTo.Length; i++)
		{
			to[indicesTo[i]] = from[i];
		}
	}
}


using System;

public static class Craptography
{
	private static readonly byte[] hash = new byte[256]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180
	};

	public static void XOR(uint seed, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		int num = hash.Length;
		int num2 = (int)(seed % num);
		for (int i = 0; i < src.Count; i++)
		{
			dst.Array[dst.Offset + i] = (byte)(src.Array[src.Offset + i] ^ hash[(num2 + i) % num]);
		}
		dst = new ArraySegment<byte>(dst.Array, dst.Offset, src.Count);
	}
}


using UnityEngine;

public class FixedRateStepped
{
	public float rate = 0.1f;

	public int maxSteps = 3;

	internal float nextCall;

	public bool ShouldStep()
	{
		if (nextCall > Time.time)
		{
			return false;
		}
		if (nextCall == 0f)
		{
			nextCall = Time.time;
		}
		if (nextCall + rate * (float)maxSteps < Time.time)
		{
			nextCall = Time.time - rate * (float)maxSteps;
		}
		nextCall += rate;
		return true;
	}
}


using System;

[Serializable]
public class FloatConditions
{
	[Serializable]
	public struct Condition
	{
		public enum Types
		{
			Equal,
			NotEqual,
			Higher,
			Lower
		}

		public Types type;

		public float value;

		public bool Test(float val)
		{
			return type switch
			{
				Types.Equal => val == value, 
				Types.NotEqual => val != value, 
				Types.Higher => val > value, 
				Types.Lower => val < value, 
				_ => false, 
			};
		}
	}

	public Condition[] conditions;

	public bool AllTrue(float val)
	{
		Condition[] array = conditions;
		foreach (Condition condition in array)
		{
			if (!condition.Test(val))
			{
				return false;
			}
		}
		return true;
	}
}


using System;

[Serializable]
public struct Condition
{
	public enum Types
	{
		Equal,
		NotEqual,
		Higher,
		Lower
	}

	public Types type;

	public float value;

	public bool Test(float val)
	{
		return type switch
		{
			Types.Equal => val == value, 
			Types.NotEqual => val != value, 
			Types.Higher => val > value, 
			Types.Lower => val < value, 
			_ => false, 
		};
	}
}


public enum Types
{
	Equal,
	NotEqual,
	Higher,
	Lower
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class FoliageGridMeshData
{
	public struct FoliageVertex
	{
		public Vector3 position;

		public Vector3 normal;

		public Vector4 tangent;

		public Color32 color;

		public Vector2 uv;

		public Vector4 uv2;

		public static readonly VertexAttributeDescriptor[] VertexLayout = (VertexAttributeDescriptor[])(object)new VertexAttributeDescriptor[6]
		{
			new VertexAttributeDescriptor((VertexAttribute)0, (VertexAttributeFormat)0, 3, 0),
			new VertexAttributeDescriptor((VertexAttribute)1, (VertexAttributeFormat)0, 3, 0),
			new VertexAttributeDescriptor((VertexAttribute)2, (VertexAttributeFormat)0, 4, 0),
			new VertexAttributeDescriptor((VertexAttribute)3, (VertexAttributeFormat)2, 4, 0),
			new VertexAttributeDescriptor((VertexAttribute)4, (VertexAttributeFormat)0, 2, 0),
			new VertexAttributeDescriptor((VertexAttribute)6, (VertexAttributeFormat)0, 4, 0)
		};
	}

	public List<FoliageVertex> vertices;

	public List<int> triangles;

	public Bounds bounds;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<FoliageVertex>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<FoliageVertex>(ref vertices);
		}
	}

	public void Clear()
	{
		triangles?.Clear();
		vertices?.Clear();
	}

	public void Combine(MeshGroup meshGroup)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		if (((List<MeshInstance>)(object)meshGroup).Count == 0)
		{
			return;
		}
		bounds = new Bounds(((List<MeshInstance>)(object)meshGroup)[0].position, Vector3.zero);
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshInstance>)(object)meshGroup).Count; i++)
		{
			MeshInstance meshInstance = ((List<MeshInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshInstance.position, meshInstance.rotation, meshInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshInstance.data.vertices.Length; k++)
			{
				Vector4 val2 = meshInstance.data.tangents[k];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				FoliageVertex item = default(FoliageVertex);
				item.position = ((Matrix4x4)(ref val)).MultiplyPoint3x4(meshInstance.data.vertices[k]);
				item.normal = ((Matrix4x4)(ref val)).MultiplyVector(meshInstance.data.normals[k]);
				item.uv = meshInstance.data.uv[k];
				item.uv2 = Vector4.op_Implicit(meshInstance.position);
				item.tangent = new Vector4(val4.x, val4.y, val4.z, val2.w);
				if (meshInstance.data.colors32.Length != 0)
				{
					item.color = meshInstance.data.colors32[k];
				}
				vertices.Add(item);
			}
			((Bounds)(ref bounds)).Encapsulate(new Bounds(meshInstance.position + ((Bounds)(ref meshInstance.data.bounds)).center, ((Bounds)(ref meshInstance.data.bounds)).size));
		}
		ref Bounds reference = ref bounds;
		((Bounds)(ref reference)).size = ((Bounds)(ref reference)).size + Vector3.one;
	}

	public void Apply(Mesh mesh)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		mesh.SetVertexBufferParams(vertices.Count, FoliageVertex.VertexLayout);
		mesh.SetVertexBufferData<FoliageVertex>(vertices, 0, 0, vertices.Count, 0, (MeshUpdateFlags)9);
		mesh.SetIndices(triangles, (MeshTopology)0, 0, false, 0);
		mesh.bounds = bounds;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public struct FoliageVertex
{
	public Vector3 position;

	public Vector3 normal;

	public Vector4 tangent;

	public Color32 color;

	public Vector2 uv;

	public Vector4 uv2;

	public static readonly VertexAttributeDescriptor[] VertexLayout = (VertexAttributeDescriptor[])(object)new VertexAttributeDescriptor[6]
	{
		new VertexAttributeDescriptor((VertexAttribute)0, (VertexAttributeFormat)0, 3, 0),
		new VertexAttributeDescriptor((VertexAttribute)1, (VertexAttributeFormat)0, 3, 0),
		new VertexAttributeDescriptor((VertexAttribute)2, (VertexAttributeFormat)0, 4, 0),
		new VertexAttributeDescriptor((VertexAttribute)3, (VertexAttributeFormat)2, 4, 0),
		new VertexAttributeDescriptor((VertexAttribute)4, (VertexAttributeFormat)0, 2, 0),
		new VertexAttributeDescriptor((VertexAttribute)6, (VertexAttributeFormat)0, 4, 0)
	};
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class FoliageGridBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private FoliageGridMeshData meshData;

	private MeshGroup meshGroup;

	private bool hasRunAwake;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		hasRunAwake = true;
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new FoliageGridMeshData();
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Invalid comparison between Unknown and I4
		if (!hasRunAwake)
		{
			Awake();
		}
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshData.Clear();
		meshData.Combine(meshGroup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshGroup>(ref meshGroup);
		}
	}
}


using UnityEngine;

public static class GameObjectUtil
{
	public static void GlobalBroadcast(string messageName, object param = null)
	{
		Transform[] rootObjects = TransformUtil.GetRootObjects();
		for (int i = 0; i < rootObjects.Length; i++)
		{
			((Component)rootObjects[i]).BroadcastMessage(messageName, param, (SendMessageOptions)1);
		}
	}
}


using System;
using UnityEngine;

public static class GizmosUtil
{
	public static void DrawWireCircleX(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(0f, 1f, 1f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCircleY(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 0f, 1f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCircleZ(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 1f, 0f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleX(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(0f, 1f, 1f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleY(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 0f, 1f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleZ(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 1f, 0f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCylinderX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleX(pos - new Vector3(0.5f * height, 0f, 0f), radius);
		DrawWireCircleX(pos + new Vector3(0.5f * height, 0f, 0f), radius);
	}

	public static void DrawWireCylinderY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleY(pos - new Vector3(0f, 0.5f * height, 0f), radius);
		DrawWireCircleY(pos + new Vector3(0f, 0.5f * height, 0f), radius);
	}

	public static void DrawWireCylinderZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleZ(pos - new Vector3(0f, 0f, 0.5f * height), radius);
		DrawWireCircleZ(pos + new Vector3(0f, 0f, 0.5f * height), radius);
	}

	public static void DrawCylinderX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleX(pos - new Vector3(0.5f * height, 0f, 0f), radius);
		DrawCircleX(pos + new Vector3(0.5f * height, 0f, 0f), radius);
	}

	public static void DrawCylinderY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleY(pos - new Vector3(0f, 0.5f * height, 0f), radius);
		DrawCircleY(pos + new Vector3(0f, 0.5f * height, 0f), radius);
	}

	public static void DrawCylinderZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleZ(pos - new Vector3(0f, 0f, 0.5f * height), radius);
		DrawCircleZ(pos + new Vector3(0f, 0f, 0.5f * height), radius);
	}

	public static void DrawWireCapsuleX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0.5f * height, 0f, 0f) + Vector3.right * radius;
		Vector3 val2 = pos + new Vector3(0.5f * height, 0f, 0f) - Vector3.right * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.forward * radius, val2 + Vector3.forward * radius);
		Gizmos.DrawLine(val + Vector3.up * radius, val2 + Vector3.up * radius);
		Gizmos.DrawLine(val + Vector3.back * radius, val2 + Vector3.back * radius);
		Gizmos.DrawLine(val + Vector3.down * radius, val2 + Vector3.down * radius);
	}

	public static void DrawWireCapsuleY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0.5f * height, 0f) + Vector3.up * radius;
		Vector3 val2 = pos + new Vector3(0f, 0.5f * height, 0f) - Vector3.up * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.forward * radius, val2 + Vector3.forward * radius);
		Gizmos.DrawLine(val + Vector3.right * radius, val2 + Vector3.right * radius);
		Gizmos.DrawLine(val + Vector3.back * radius, val2 + Vector3.back * radius);
		Gizmos.DrawLine(val + Vector3.left * radius, val2 + Vector3.left * radius);
	}

	public static void DrawWireCapsuleZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0f, 0.5f * height) + Vector3.forward * radius;
		Vector3 val2 = pos + new Vector3(0f, 0f, 0.5f * height) - Vector3.forward * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.up * radius, val2 + Vector3.up * radius);
		Gizmos.DrawLine(val + Vector3.right * radius, val2 + Vector3.right * radius);
		Gizmos.DrawLine(val + Vector3.down * radius, val2 + Vector3.down * radius);
		Gizmos.DrawLine(val + Vector3.left * radius, val2 + Vector3.left * radius);
	}

	public static void DrawCapsuleX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0.5f * height, 0f, 0f);
		Vector3 val2 = pos + new Vector3(0.5f * height, 0f, 0f);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawCapsuleY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0.5f * height, 0f);
		Vector3 val2 = pos + new Vector3(0f, 0.5f * height, 0f);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawCapsuleZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0f, 0.5f * height);
		Vector3 val2 = pos + new Vector3(0f, 0f, 0.5f * height);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix = Matrix4x4.TRS(pos, rot, size);
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
		Gizmos.matrix = matrix;
	}

	public static void DrawCube(Vector3 pos, Vector3 size, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix = Matrix4x4.TRS(pos, rot, size);
		Gizmos.DrawCube(Vector3.zero, Vector3.one);
		Gizmos.matrix = matrix;
	}

	public static void DrawWirePath(Vector3 a, Vector3 b, float thickness)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleY(a, thickness);
		DrawWireCircleY(b, thickness);
		Vector3 val = b - a;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Quaternion.Euler(0f, 90f, 0f) * normalized;
		Gizmos.DrawLine(b + val2 * thickness, a + val2 * thickness);
		Gizmos.DrawLine(b - val2 * thickness, a - val2 * thickness);
	}

	public static void DrawSemiCircle(float radius)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		float num = radius * (MathF.PI / 180f) * 0.5f;
		Vector3 val = Mathf.Cos(num) * Vector3.forward + Mathf.Sin(num) * Vector3.right;
		Gizmos.DrawLine(Vector3.zero, val);
		Vector3 val2 = Mathf.Cos(0f - num) * Vector3.forward + Mathf.Sin(0f - num) * Vector3.right;
		Gizmos.DrawLine(Vector3.zero, val2);
		float num2 = Mathf.Clamp(radius / 16f, 4f, 64f);
		float num3 = num / num2;
		for (float num4 = num; num4 > 0f; num4 -= num3)
		{
			Vector3 val3 = Mathf.Cos(num4) * Vector3.forward + Mathf.Sin(num4) * Vector3.right;
			Gizmos.DrawLine(Vector3.zero, val3);
			if (val != Vector3.zero)
			{
				Gizmos.DrawLine(val3, val);
			}
			val = val3;
			Vector3 val4 = Mathf.Cos(0f - num4) * Vector3.forward + Mathf.Sin(0f - num4) * Vector3.right;
			Gizmos.DrawLine(Vector3.zero, val4);
			if (val2 != Vector3.zero)
			{
				Gizmos.DrawLine(val4, val2);
			}
			val2 = val4;
		}
		Gizmos.DrawLine(val, val2);
	}

	public static void DrawArrowHead(Vector3 pos, Vector3 dir, float arrowHeadLength = 0.25f, float arrowHeadAngle = 20f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.LookRotation(dir) * Quaternion.Euler(arrowHeadAngle, 0f, 0f) * Vector3.back;
		Vector3 val2 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f - arrowHeadAngle, 0f, 0f) * Vector3.back;
		Vector3 val3 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f, arrowHeadAngle, 0f) * Vector3.back;
		Vector3 val4 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f, 0f - arrowHeadAngle, 0f) * Vector3.back;
		Gizmos.DrawRay(pos + dir, val * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val2 * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val3 * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val4 * arrowHeadLength);
	}

	public static void DrawMeshes(Transform transform)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderer[] componentsInChildren = ((Component)transform).GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer val in componentsInChildren)
		{
			if (!((Renderer)val).enabled)
			{
				continue;
			}
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				Transform transform2 = ((Component)val).transform;
				if ((Object)(object)transform2 != (Object)null && (Object)(object)component != (Object)null && (Object)(object)component.sharedMesh != (Object)null && component.sharedMesh.normals != null && component.sharedMesh.normals.Length != 0)
				{
					Gizmos.DrawMesh(component.sharedMesh, transform2.position, transform2.rotation, transform2.lossyScale);
				}
			}
		}
	}

	public static void DrawBounds(Transform transform)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = transform.GetBounds(includeRenderers: true, includeColliders: false);
		Vector3 lossyScale = transform.lossyScale;
		Quaternion rotation = transform.rotation;
		Vector3 pos = transform.position + rotation * Vector3.Scale(lossyScale, ((Bounds)(ref bounds)).center);
		Vector3 size = Vector3.Scale(lossyScale, ((Bounds)(ref bounds)).size);
		DrawCube(pos, size, rotation);
		DrawWireCube(pos, size, rotation);
	}
}


using Development.Attributes;

[ResetStaticFields]
public class GlobalMessages
{
}


public interface IInventoryChanged
{
}


public interface IPreInventoryChanged
{
}


public interface IViewModeChanged
{
}


public interface IClothingChanged
{
}


public interface IViewModelUpdated
{
}


public interface IBlueprintsChanged
{
}


public interface IItemAmountChanged
{
}


public interface IItemIconChanged
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class LocalClock
{
	public struct TimedEvent
	{
		public float time;

		public float delta;

		public float variance;

		public Action action;
	}

	public List<TimedEvent> events = new List<TimedEvent>();

	public void Add(float delta, float variance, Action action)
	{
		TimedEvent item = default(TimedEvent);
		item.time = Time.time + delta + Random.Range(0f - variance, variance);
		item.delta = delta;
		item.variance = variance;
		item.action = action;
		events.Add(item);
	}

	public void Tick()
	{
		for (int i = 0; i < events.Count; i++)
		{
			TimedEvent value = events[i];
			if (Time.time > value.time)
			{
				float delta = value.delta;
				float variance = value.variance;
				value.action();
				value.time = Time.time + delta + Random.Range(0f - variance, variance);
				events[i] = value;
			}
		}
	}
}


using System;

public struct TimedEvent
{
	public float time;

	public float delta;

	public float variance;

	public Action action;
}


using Rust;
using UnityEngine;

public abstract class MeshBatch : MonoBehaviour
{
	public bool NeedsRefresh { get; private set; }

	public int Count { get; private set; }

	public int BatchedCount { get; private set; }

	public int VertexCount { get; private set; }

	public abstract int VertexCapacity { get; }

	public abstract int VertexCutoff { get; }

	public int AvailableVertices => Mathf.Clamp(VertexCapacity, VertexCutoff, 65534) - VertexCount;

	protected abstract void AllocMemory();

	protected abstract void FreeMemory();

	protected abstract void RefreshMesh();

	protected abstract void ApplyMesh();

	protected abstract void ToggleMesh(bool state);

	protected abstract void OnPooled();

	public void Alloc()
	{
		AllocMemory();
	}

	public void Free()
	{
		FreeMemory();
	}

	public void Refresh()
	{
		RefreshMesh();
	}

	public void Apply()
	{
		NeedsRefresh = false;
		ApplyMesh();
	}

	public void Display()
	{
		ToggleMesh(state: true);
		BatchedCount = Count;
	}

	public void Invalidate()
	{
		ToggleMesh(state: false);
		BatchedCount = 0;
	}

	protected void AddVertices(int vertices)
	{
		NeedsRefresh = true;
		Count++;
		VertexCount += vertices;
	}

	protected void OnEnable()
	{
		NeedsRefresh = false;
		Count = 0;
		BatchedCount = 0;
		VertexCount = 0;
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			NeedsRefresh = false;
			Count = 0;
			BatchedCount = 0;
			VertexCount = 0;
			OnPooled();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class MeshDataBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private MeshData meshData;

	private MeshGroup meshGroup;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new MeshData();
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Invalid comparison between Unknown and I4
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshData.Clear();
		meshData.Combine(meshGroup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshGroup>(ref meshGroup);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class MeshRendererBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private MeshRendererData meshData;

	private MeshRendererGroup meshGroup;

	private MeshRendererLookup meshLookup;

	private static MaterialPropertyBlock propertyBlock;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new MeshRendererData();
		meshLookup = new MeshRendererLookup();
	}

	public void SetupColor(Color color)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		if (propertyBlock == null)
		{
			propertyBlock = new MaterialPropertyBlock();
		}
		((Renderer)meshRenderer).GetPropertyBlock(propertyBlock);
		((Renderer)meshRenderer).SetPropertyBlock(propertyBlock);
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer, Color color)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Invalid comparison between Unknown and I4
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		SetupColor(color);
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshRendererInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshRendererInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshRendererGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshRendererGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshLookup.dst.Clear();
		meshData.Clear();
		meshData.Combine(meshGroup, meshLookup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshLookup.Apply();
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		List<MeshRendererLookup.LookupEntry> data = meshLookup.src.data;
		for (int i = 0; i < data.Count; i++)
		{
			Renderer renderer = data[i].renderer;
			if (Object.op_Implicit((Object)(object)renderer))
			{
				renderer.enabled = !state;
			}
		}
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshRendererGroup>(ref meshGroup);
		}
		meshLookup.src.Clear();
		meshLookup.dst.Clear();
	}
}


using System.IO;
using System.Text;
using UnityEngine;

public static class ObjWriter
{
	public static string MeshToString(Mesh mesh)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("g ").Append(((Object)mesh).name).Append("\n");
		Vector3[] vertices = mesh.vertices;
		foreach (Vector3 val in vertices)
		{
			stringBuilder.Append($"v {0f - val.x} {val.y} {val.z}\n");
		}
		stringBuilder.Append("\n");
		vertices = mesh.normals;
		foreach (Vector3 val2 in vertices)
		{
			stringBuilder.Append($"vn {0f - val2.x} {val2.y} {val2.z}\n");
		}
		stringBuilder.Append("\n");
		Vector2[] uv = mesh.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			Vector3 val3 = Vector2.op_Implicit(uv[i]);
			stringBuilder.Append($"vt {val3.x} {val3.y}\n");
		}
		stringBuilder.Append("\n");
		int[] triangles = mesh.triangles;
		for (int j = 0; j < triangles.Length; j += 3)
		{
			int num = triangles[j] + 1;
			int num2 = triangles[j + 1] + 1;
			int num3 = triangles[j + 2] + 1;
			stringBuilder.Append(string.Format("f {1}/{1}/{1} {0}/{0}/{0} {2}/{2}/{2}\n", num, num2, num3));
		}
		return stringBuilder.ToString();
	}

	public static void Write(Mesh mesh, string path)
	{
		using StreamWriter streamWriter = new StreamWriter(path);
		streamWriter.Write(MeshToString(mesh));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathFinder
{
	public struct Point : IEquatable<Point>
	{
		public int x;

		public int y;

		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public static Point operator +(Point a, Point b)
		{
			return new Point(a.x + b.x, a.y + b.y);
		}

		public static Point operator -(Point a, Point b)
		{
			return new Point(a.x - b.x, a.y - b.y);
		}

		public static Point operator *(Point p, int i)
		{
			return new Point(p.x * i, p.y * i);
		}

		public static Point operator /(Point p, int i)
		{
			return new Point(p.x / i, p.y / i);
		}

		public static bool operator ==(Point a, Point b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(Point a, Point b)
		{
			return !a.Equals(b);
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Point))
			{
				return false;
			}
			return Equals((Point)other);
		}

		public bool Equals(Point other)
		{
			if (x == other.x)
			{
				return y == other.y;
			}
			return false;
		}
	}

	public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
	{
		public Point point;

		public int cost;

		public int heuristic;

		public Node next { get; set; }

		public Node child { get; set; }

		public int order => cost + heuristic;

		public Node(Point point, int cost, int heuristic, Node next = null)
		{
			this.point = point;
			this.cost = cost;
			this.heuristic = heuristic;
			this.next = next;
		}
	}

	private int[,] costmap;

	private int[,] visited;

	private Point[] neighbors;

	private bool diagonals;

	private bool directional;

	public Point PushPoint;

	public int PushRadius;

	public int PushDistance;

	public int PushMultiplier;

	public List<Point> PushPointsAdditional = new List<Point>();

	public HashSet<Point> BlockedPointsAdditional = new HashSet<Point>();

	private static Point[] mooreNeighbors = new Point[8]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1),
		new Point(-1, 1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(1, -1)
	};

	private static Point[] neumannNeighbors = new Point[4]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1)
	};

	public PathFinder(int[,] costmap, bool diagonals = true, bool directional = true)
	{
		this.costmap = costmap;
		neighbors = (diagonals ? mooreNeighbors : neumannNeighbors);
		this.diagonals = diagonals;
		this.directional = directional;
	}

	public int GetResolution(int index)
	{
		return costmap.GetLength(index);
	}

	public Node FindPath(Point start, Point end, int depth = int.MaxValue)
	{
		return FindPathReversed(end, start, depth);
	}

	private Node FindPathReversed(Point start, Point end, int depth = int.MaxValue)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		int num5 = Cost(start);
		if (num5 != int.MaxValue)
		{
			int heuristic = Heuristic(start, end);
			val.Add(new Node(start, num5, heuristic));
		}
		visited[start.x, start.y] = num5;
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x < num || point.x > num2 || point.y < num3 || point.y > num4)
				{
					continue;
				}
				int num6 = Cost(point, node);
				if (num6 != int.MaxValue)
				{
					int num7 = visited[point.x, point.y];
					if (num7 == 0 || num6 < num7)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point, end);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
				else
				{
					visited[point.x, point.y] = -1;
				}
			}
		}
		return null;
	}

	public Node FindPathDirected(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		if (startList.Count == 0 || endList.Count == 0)
		{
			return null;
		}
		return FindPathReversed(endList, startList, depth);
	}

	public Node FindPathUndirected(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		if (startList.Count == 0 || endList.Count == 0)
		{
			return null;
		}
		if (startList.Count > endList.Count)
		{
			return FindPathReversed(endList, startList, depth);
		}
		return FindPathReversed(startList, endList, depth);
	}

	private Node FindPathReversed(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		foreach (Point start in startList)
		{
			int num5 = Cost(start);
			if (num5 != int.MaxValue)
			{
				int heuristic = Heuristic(start, endList);
				val.Add(new Node(start, num5, heuristic));
			}
			visited[start.x, start.y] = num5;
		}
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x < num || point.x > num2 || point.y < num3 || point.y > num4)
				{
					continue;
				}
				int num6 = Cost(point, node);
				if (num6 != int.MaxValue)
				{
					int num7 = visited[point.x, point.y];
					if (num7 == 0 || num6 < num7)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point, endList);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
				else
				{
					visited[point.x, point.y] = -1;
				}
			}
		}
		return null;
	}

	public Node FindClosestWalkable(Point start, int depth = int.MaxValue)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		if (start.x < num)
		{
			return null;
		}
		if (start.x > num2)
		{
			return null;
		}
		if (start.y < num3)
		{
			return null;
		}
		if (start.y > num4)
		{
			return null;
		}
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		int num5 = 1;
		int heuristic = Heuristic(start);
		val.Add(new Node(start, num5, heuristic));
		visited[start.x, start.y] = num5;
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x >= num && point.x <= num2 && point.y >= num3 && point.y <= num4)
				{
					int num6 = 1;
					if (visited[point.x, point.y] == 0)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
			}
		}
		return null;
	}

	public bool IsWalkable(Point point)
	{
		return costmap[point.x, point.y] != int.MaxValue;
	}

	public bool IsWalkableWithNeighbours(Point point)
	{
		if (costmap[point.x, point.y] == int.MaxValue)
		{
			return false;
		}
		for (int i = 0; i < neighbors.Length; i++)
		{
			Point point2 = point + neighbors[i];
			if (costmap[point2.x, point2.y] == int.MaxValue)
			{
				return false;
			}
		}
		return true;
	}

	public Node Reverse(Node start)
	{
		Node node = null;
		Node next = null;
		for (Node node2 = start; node2 != null; node2 = node2.next)
		{
			if (node != null)
			{
				node.next = next;
			}
			next = node;
			node = node2;
		}
		if (node != null)
		{
			node.next = next;
		}
		return node;
	}

	public Node FindEnd(Node start)
	{
		for (Node node = start; node != null; node = node.next)
		{
			if (node.next == null)
			{
				return node;
			}
		}
		return start;
	}

	public int Cost(Point a)
	{
		int num = costmap[a.x, a.y];
		int num2 = 0;
		if (BlockedPointsAdditional.Contains(a))
		{
			num = int.MaxValue;
		}
		if (num == int.MaxValue)
		{
			return num;
		}
		if (PushMultiplier > 0)
		{
			int num3 = ((PushRadius > 0) ? Mathf.Max(0, Heuristic(a, PushPoint) - PushRadius) : (PushDistance * 2));
			for (int i = 0; i < PushPointsAdditional.Count; i++)
			{
				num3 = Mathf.Min(num3, Heuristic(a, PushPointsAdditional[i]));
			}
			float num4 = Mathf.Max(0f, (float)(PushDistance - num3)) / (float)PushDistance;
			num2 = ((PushMultiplier != int.MaxValue) ? Mathf.CeilToInt((float)PushMultiplier * num4) : ((num4 > 0f) ? int.MaxValue : 0));
		}
		if (num2 == int.MaxValue)
		{
			return num2;
		}
		return num + num2;
	}

	public int Cost(Point a, Node prev)
	{
		int num = Cost(a);
		int num2 = 0;
		if (num != int.MaxValue && directional && prev != null && prev.next != null && Heuristic(a, prev.next.point) <= 1)
		{
			num2 = 10000;
		}
		return num + num2;
	}

	public int Heuristic(Point a)
	{
		if (costmap[a.x, a.y] != int.MaxValue)
		{
			return 0;
		}
		return 1;
	}

	public int Heuristic(Point a, Point b)
	{
		int num = Mathf.Abs(a.x - b.x);
		int num2 = Mathf.Abs(a.y - b.y);
		if (diagonals)
		{
			return Mathf.Max(num, num2);
		}
		return num + num2;
	}

	public int Heuristic(Point a, List<Point> b)
	{
		int num = int.MaxValue;
		for (int i = 0; i < b.Count; i++)
		{
			num = Mathf.Min(num, Heuristic(a, b[i]));
		}
		return num;
	}

	public float Distance(Point a, Point b)
	{
		int num = a.x - b.x;
		int num2 = a.y - b.y;
		return Mathf.Sqrt((float)(num * num + num2 * num2));
	}

	public static Point GetPoint(Vector3 worldPos, int res)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.NormalizeX(worldPos.x);
		float num2 = TerrainMeta.NormalizeZ(worldPos.z);
		Point result = default(Point);
		result.x = Mathf.Clamp((int)(num * (float)res), 0, res - 1);
		result.y = Mathf.Clamp((int)(num2 * (float)res), 0, res - 1);
		return result;
	}
}


using System;

public struct Point : IEquatable<Point>
{
	public int x;

	public int y;

	public Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public static Point operator +(Point a, Point b)
	{
		return new Point(a.x + b.x, a.y + b.y);
	}

	public static Point operator -(Point a, Point b)
	{
		return new Point(a.x - b.x, a.y - b.y);
	}

	public static Point operator *(Point p, int i)
	{
		return new Point(p.x * i, p.y * i);
	}

	public static Point operator /(Point p, int i)
	{
		return new Point(p.x / i, p.y / i);
	}

	public static bool operator ==(Point a, Point b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Point a, Point b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Point))
		{
			return false;
		}
		return Equals((Point)other);
	}

	public bool Equals(Point other)
	{
		if (x == other.x)
		{
			return y == other.y;
		}
		return false;
	}
}


public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
{
	public Point point;

	public int cost;

	public int heuristic;

	public Node next { get; set; }

	public Node child { get; set; }

	public int order => cost + heuristic;

	public Node(Point point, int cost, int heuristic, Node next = null)
	{
		this.point = point;
		this.cost = cost;
		this.heuristic = heuristic;
		this.next = next;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathInterpolator
{
	public Vector3[] Points;

	public Vector3[] Tangents;

	protected bool initialized;

	public int MinIndex { get; set; }

	public int MaxIndex { get; set; }

	public virtual float Length { get; private set; }

	public virtual float StepSize { get; private set; }

	public bool Circular { get; private set; }

	public int DefaultMinIndex => 0;

	public int DefaultMaxIndex => Points.Length - 1;

	public float StartOffset => Length * (float)(MinIndex - DefaultMinIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public float EndOffset => Length * (float)(DefaultMaxIndex - MaxIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public PathInterpolator(Vector3[] points)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (points.Length < 2)
		{
			throw new ArgumentException("Point list too short.");
		}
		Points = points;
		MinIndex = DefaultMinIndex;
		MaxIndex = DefaultMaxIndex;
		Circular = Vector3.Distance(points[0], points[^1]) < 0.1f;
	}

	public PathInterpolator(Vector3[] points, Vector3[] tangents)
		: this(points)
	{
		if (tangents.Length != points.Length)
		{
			throw new ArgumentException("Points and tangents lengths must match. Points: " + points.Length + " Tangents: " + tangents.Length);
		}
		Tangents = tangents;
		RecalculateLength();
		initialized = true;
	}

	public void RecalculateTangents()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (Tangents == null || Tangents.Length != Points.Length)
		{
			Tangents = (Vector3[])(object)new Vector3[Points.Length];
		}
		for (int i = 0; i < Points.Length; i++)
		{
			int num = i - 1;
			int num2 = i + 1;
			if (num < 0)
			{
				num = (Circular ? (Points.Length - 2) : 0);
			}
			if (num2 > Points.Length - 1)
			{
				num2 = (Circular ? 1 : (Points.Length - 1));
			}
			Vector3 val = Points[num];
			Vector3 val2 = Points[num2];
			Vector3[] tangents = Tangents;
			int num3 = i;
			Vector3 val3 = val2 - val;
			tangents[num3] = ((Vector3)(ref val3)).normalized;
		}
		RecalculateLength();
		initialized = true;
	}

	public void RecalculateLength()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		for (int i = 0; i < Points.Length - 1; i++)
		{
			Vector3 val = Points[i];
			Vector3 val2 = Points[i + 1];
			float num2 = num;
			Vector3 val3 = val2 - val;
			num = num2 + ((Vector3)(ref val3)).magnitude;
		}
		Length = num;
		StepSize = num / (float)Points.Length;
	}

	public void Resample(float distance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		Vector3 val3;
		for (int i = 0; i < Points.Length - 1; i++)
		{
			Vector3 val = Points[i];
			Vector3 val2 = Points[i + 1];
			float num2 = num;
			val3 = val2 - val;
			num = num2 + ((Vector3)(ref val3)).magnitude;
		}
		int num3 = Mathf.RoundToInt(num / distance);
		if (num3 < 2)
		{
			return;
		}
		distance = num / (float)(num3 - 1);
		List<Vector3> list = new List<Vector3>(num3);
		float num4 = 0f;
		for (int j = 0; j < Points.Length - 1; j++)
		{
			int num5 = j;
			int num6 = j + 1;
			Vector3 val4 = Points[num5];
			Vector3 val5 = Points[num6];
			val3 = val5 - val4;
			float num7 = ((Vector3)(ref val3)).magnitude;
			if (num5 == 0)
			{
				list.Add(val4);
			}
			while (num4 + num7 > distance)
			{
				float num8 = distance - num4;
				float num9 = num8 / num7;
				Vector3 val6 = Vector3.Lerp(val4, val5, num9);
				list.Add(val6);
				val4 = val6;
				num4 = 0f;
				num7 -= num8;
			}
			num4 += num7;
			if (num6 == Points.Length - 1 && num4 > distance * 0.5f)
			{
				list.Add(val5);
			}
		}
		if (list.Count >= 2)
		{
			Points = list.ToArray();
			MinIndex = DefaultMinIndex;
			MaxIndex = DefaultMaxIndex;
			initialized = false;
		}
	}

	public void Smoothen(int iterations, Func<int, float> filter = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Smoothen(iterations, Vector3.one, filter);
	}

	public void Smoothen(int iterations, Vector3 multipliers, Func<int, float> filter = null)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < iterations; i++)
		{
			for (int j = MinIndex + ((!Circular) ? 1 : 0); j <= MaxIndex - 1; j += 2)
			{
				SmoothenIndex(j, multipliers, filter);
			}
			for (int k = MinIndex + (Circular ? 1 : 2); k <= MaxIndex - 1; k += 2)
			{
				SmoothenIndex(k, multipliers, filter);
			}
		}
		initialized = false;
	}

	private void SmoothenIndex(int i, Vector3 multipliers, Func<int, float> filter = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		int num = i - 1;
		int num2 = i + 1;
		if (i == 0)
		{
			num = Points.Length - 2;
		}
		Vector3 val = Points[num];
		Vector3 val2 = Points[i];
		Vector3 val3 = Points[num2];
		Vector3 val4 = (val + val2 + val2 + val3) * 0.25f;
		if (filter != null)
		{
			multipliers *= filter(i);
		}
		if (multipliers != Vector3.one)
		{
			val4.x = Mathf.LerpUnclamped(val2.x, val4.x, multipliers.x);
			val4.y = Mathf.LerpUnclamped(val2.y, val4.y, multipliers.y);
			val4.z = Mathf.LerpUnclamped(val2.z, val4.z, multipliers.z);
		}
		Points[i] = val4;
		if (i == 0)
		{
			Points[Points.Length - 1] = Points[0];
		}
	}

	public void Straighten(int diStart, int diEnd)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Points[diStart];
		Vector3 val2 = Points[diEnd];
		Vector3 val3 = Tangents[diStart];
		Vector3 val4 = Tangents[diEnd];
		float num = 1f / (float)(diEnd - diStart);
		for (int i = diStart + 1; i <= diEnd - 1; i++)
		{
			float num2 = (float)(i - diStart) * num;
			Points[i] = Vector3.Lerp(val, val2, num2);
			Tangents[i] = Vector3.Slerp(val3, val4, num2);
		}
	}

	public Vector3 GetStartPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Points[MinIndex];
	}

	public Vector3 GetEndPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Points[MaxIndex];
	}

	public Vector3 GetStartTangent()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MinIndex];
	}

	public Vector3 GetEndTangent()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MaxIndex];
	}

	public Vector3 GetPointByIndex(int i)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!Circular)
		{
			return Points[Mathf.Clamp(i, 0, Points.Length - 1)];
		}
		return Points[(i % Points.Length + Points.Length) % Points.Length];
	}

	public Vector3 GetTangentByIndex(int i)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = GetPoint(i + 1) - GetPoint(i - 1);
		return ((Vector3)(ref val)).normalized;
	}

	public int GetPrevIndex(float distance)
	{
		return Mathf.FloorToInt(distance / Length * (float)(Points.Length - 1));
	}

	public int GetNextIndex(float distance)
	{
		return Mathf.CeilToInt(distance / Length * (float)(Points.Length - 1));
	}

	public Vector3 GetPoint(int index)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		if (index <= MinIndex)
		{
			return GetStartPoint();
		}
		if (index >= MaxIndex)
		{
			return GetEndPoint();
		}
		return Points[index];
	}

	public Vector3 GetPoint(float distance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Points.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 val = Points[num2];
		Vector3 val2 = Points[num2 + 1];
		float num3 = num - (float)num2;
		return Vector3.Lerp(val, val2, num3);
	}

	public virtual Vector3 GetTangent(float distance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Tangents.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartTangent();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndTangent();
		}
		Vector3 val = Tangents[num2];
		Vector3 val2 = Tangents[num2 + 1];
		float num3 = num - (float)num2;
		return Vector3.Slerp(val, val2, num3);
	}

	public virtual Vector3 GetPointCubicHermite(float distance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Points.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 val = Points[num2];
		Vector3 val2 = Points[num2 + 1];
		Vector3 val3 = Tangents[num2] * StepSize;
		Vector3 val4 = Tangents[num2 + 1] * StepSize;
		float num3 = num - (float)num2;
		float num4 = num3 * num3;
		float num5 = num3 * num4;
		return (2f * num5 - 3f * num4 + 1f) * val + (num5 - 2f * num4 + num3) * val3 + (-2f * num5 + 3f * num4) * val2 + (num5 - num4) * val4;
	}
}


public class RadixSorter
{
	private uint[] histogram;

	private uint[] offset;

	public RadixSorter()
	{
		histogram = new uint[768];
		offset = new uint[768];
	}

	public void SortU8(uint[] values, uint[] remap, uint num)
	{
		for (int i = 0; i < 256; i++)
		{
			histogram[i] = 0u;
		}
		for (uint num2 = 0u; num2 < num; num2++)
		{
			histogram[values[num2] & 0xFF]++;
		}
		offset[0] = 0u;
		for (uint num3 = 0u; num3 < 255; num3++)
		{
			offset[num3 + 1] = offset[num3] + histogram[num3];
		}
		for (uint num4 = 0u; num4 < num; num4++)
		{
			remap[offset[values[num4] & 0xFF]++] = num4;
		}
	}

	public void SortU24(uint[] values, uint[] remap, uint[] remapTemp, uint num)
	{
		for (int i = 0; i < 768; i++)
		{
			histogram[i] = 0u;
		}
		for (uint num2 = 0u; num2 < num; num2++)
		{
			uint num3 = values[num2];
			histogram[num3 & 0xFF]++;
			histogram[256 + ((num3 >> 8) & 0xFF)]++;
			histogram[512 + ((num3 >> 16) & 0xFF)]++;
		}
		offset[0] = (offset[256] = (offset[512] = 0u));
		uint num4 = 0u;
		uint num5 = 256u;
		uint num6 = 512u;
		while (num4 < 255)
		{
			offset[num4 + 1] = offset[num4] + histogram[num4];
			offset[num5 + 1] = offset[num5] + histogram[num5];
			offset[num6 + 1] = offset[num6] + histogram[num6];
			num4++;
			num5++;
			num6++;
		}
		for (uint num7 = 0u; num7 < num; num7++)
		{
			remapTemp[offset[values[num7] & 0xFF]++] = num7;
		}
		for (uint num8 = 0u; num8 < num; num8++)
		{
			uint num9 = remapTemp[num8];
			remap[offset[256 + ((values[num9] >> 8) & 0xFF)]++] = num9;
		}
		for (uint num10 = 0u; num10 < num; num10++)
		{
			uint num9 = remap[num10];
			remapTemp[offset[512 + ((values[num9] >> 16) & 0xFF)]++] = num9;
		}
		for (uint num11 = 0u; num11 < num; num11++)
		{
			remap[num11] = remapTemp[num11];
		}
	}
}


using System.Collections.Generic;
using System.IO;

public static class RawWriter
{
	public static void Write(IEnumerable<byte> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (byte datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<int> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (int datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<short> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (short datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<ushort> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (ushort datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<float> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (float datum in data)
		{
			binaryWriter.Write(datum);
		}
	}
}


using Network;

public struct RealTimeSinceEx
{
	private double time;

	public static implicit operator double(RealTimeSinceEx ts)
	{
		return TimeEx.realtimeSinceStartup - ts.time;
	}

	public static implicit operator RealTimeSinceEx(double ts)
	{
		RealTimeSinceEx result = default(RealTimeSinceEx);
		result.time = TimeEx.realtimeSinceStartup - ts;
		return result;
	}

	public override string ToString()
	{
		return (TimeEx.realtimeSinceStartup - time).ToString();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SynchronizedClock
{
	public struct TimedEvent
	{
		public float time;

		public float delta;

		public float variance;

		public Action<uint> action;
	}

	public List<TimedEvent> events = new List<TimedEvent>();

	private static float CurrentTime => Time.realtimeSinceStartup;

	public void Add(float delta, float variance, Action<uint> action)
	{
		TimedEvent item = default(TimedEvent);
		item.time = CurrentTime;
		item.delta = delta;
		item.variance = variance;
		item.action = action;
		events.Add(item);
	}

	public void Tick()
	{
		for (int i = 0; i < events.Count; i++)
		{
			TimedEvent value = events[i];
			float time = value.time;
			float currentTime = CurrentTime;
			float delta = value.delta;
			float num = time - time % delta;
			uint obj = (uint)(time / delta);
			SeedRandom.Wanghash(ref obj);
			SeedRandom.Wanghash(ref obj);
			SeedRandom.Wanghash(ref obj);
			float num2 = SeedRandom.Range(ref obj, 0f - value.variance, value.variance);
			float num3 = num + delta + num2;
			if (time < num3 && currentTime >= num3)
			{
				value.action(obj);
				value.time = currentTime;
			}
			else if (currentTime > time || currentTime < num - 5f)
			{
				value.time = currentTime;
			}
			events[i] = value;
		}
	}
}


using System;

public struct TimedEvent
{
	public float time;

	public float delta;

	public float variance;

	public Action<uint> action;
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Threading.Tasks;
using Facepunch;
using UnityEngine;

public static class ThreadUtil
{
	public enum ErrorLogging
	{
		None,
		LogExceptionAndBreak
	}

	public static async Task IterateBudgetUnbuffered<T>(IReadOnlyList<T> collection, TimeSpan budget, ErrorLogging errorLogging, Action<T> callback)
	{
		Stopwatch timer = Stopwatch.StartNew();
		for (int i = 0; i < collection.Count; i++)
		{
			try
			{
				callback(collection[i]);
			}
			catch (Exception ex)
			{
				if (errorLogging == ErrorLogging.LogExceptionAndBreak)
				{
					Debug.LogException(ex);
					break;
				}
			}
			if (timer.Elapsed > budget)
			{
				await Task.Delay(1);
				timer.Restart();
			}
		}
	}

	public static async Task IterateBudget<T>(IReadOnlyList<T> collection, TimeSpan budget, ErrorLogging errorLogging, Action<T> callback)
	{
		List<T> list = Pool.Get<List<T>>();
		list.AddRange(collection);
		await IterateBudgetUnbuffered(list, budget, errorLogging, callback);
		Pool.FreeUnmanaged<T>(ref list);
		await Task.CompletedTask;
	}
}


public enum ErrorLogging
{
	None,
	LogExceptionAndBreak
}


using UnityEngine;

public class TickHistory
{
	private Deque<Vector3> points = new Deque<Vector3>(8);

	public int Count => points.Count;

	public void Reset()
	{
		points.Clear();
	}

	public void Reset(Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		AddPoint(point);
	}

	public float Distance(BasePlayer player, Vector3 point)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (points.Count == 0)
		{
			return player.Distance(point);
		}
		Vector3 position = ((Component)player).transform.position;
		Quaternion rotation = ((Component)player).transform.rotation;
		Bounds bounds = player.bounds;
		Matrix4x4 tickHistoryMatrix = player.tickHistoryMatrix;
		float num = float.MaxValue;
		Line val3 = default(Line);
		OBB val5 = default(OBB);
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 val = ((Matrix4x4)(ref tickHistoryMatrix)).MultiplyPoint3x4(points[i]);
			Vector3 val2 = ((i == points.Count - 1) ? position : ((Matrix4x4)(ref tickHistoryMatrix)).MultiplyPoint3x4(points[i + 1]));
			((Line)(ref val3))..ctor(val, val2);
			Vector3 val4 = ((Line)(ref val3)).ClosestPoint(point);
			((OBB)(ref val5))..ctor(val4, rotation, bounds);
			num = Mathf.Min(num, ((OBB)(ref val5)).Distance(point));
		}
		return num;
	}

	public void AddPoint(Vector3 point, int limit = -1)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		while (limit > 0 && points.Count >= limit)
		{
			points.PopFront();
		}
		points.PushBack(point);
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 val = points[i];
			val = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(val);
			points[i] = val;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TickInterpolator
{
	public struct Segment
	{
		public Vector3 point;

		public readonly float length;

		public Segment(Vector3 a, Vector3 b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			point = b;
			length = Vector3.Distance(a, b);
		}

		public Segment(Vector3 b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			point = b;
			length = 0f;
		}
	}

	private readonly List<Segment> points = new List<Segment>();

	private int index;

	public float Length;

	public Vector3 CurrentPoint;

	public Vector3 StartPoint;

	public Vector3 EndPoint;

	public int Count => points.Count;

	public void Reset()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		index = 0;
		CurrentPoint = StartPoint;
	}

	public void Reset(Vector3 point)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		points.Clear();
		index = 0;
		Length = 0f;
		CurrentPoint = (StartPoint = (EndPoint = point));
	}

	public void AddPoint(Vector3 point)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Segment item = new Segment(EndPoint, point);
		points.Add(item);
		Length += item.length;
		EndPoint = item.point;
	}

	public bool MoveNext(float distance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		while (num < distance && index < points.Count)
		{
			Segment segment = points[index];
			CurrentPoint = segment.point;
			num += segment.length;
			index++;
		}
		return num > 0f;
	}

	public bool HasNext()
	{
		return index < points.Count;
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < points.Count; i++)
		{
			Segment value = points[i];
			value.point = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(value.point);
			points[i] = value;
		}
		CurrentPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(CurrentPoint);
		StartPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(StartPoint);
		EndPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(EndPoint);
	}
}


using UnityEngine;

public struct Segment
{
	public Vector3 point;

	public readonly float length;

	public Segment(Vector3 a, Vector3 b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		point = b;
		length = Vector3.Distance(a, b);
	}

	public Segment(Vector3 b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		point = b;
		length = 0f;
	}
}


using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class TickInterpolatorCache
{
	public struct PlayerInfo
	{
		public int Count;

		public float Length;
	}

	public struct ReadOnlyState
	{
		public readonly ReadOnly<TickInterpolator.Segment> Segments;

		public readonly ReadOnly<PlayerInfo> Infos;

		public readonly int BufferSize;

		public ReadOnlyState(ReadOnly<TickInterpolator.Segment> playerSegments, ReadOnly<PlayerInfo> playerInfos, int bufferSize)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Segments = playerSegments;
			Infos = playerInfos;
			BufferSize = bufferSize;
		}
	}

	public struct PlayerTickIterator
	{
		private readonly ReadOnlyState state;

		private readonly int playerIndex;

		private Vector3 currPoint;

		private int segmentIndex;

		public Vector3 CurrentPoint => currPoint;

		public Vector3 StartPoint => GetStartPoint(state, playerIndex);

		public Vector3 EndPoint => GetEndPoint(state, playerIndex);

		public float Length => state.Infos[playerIndex].Length;

		public PlayerTickIterator(ReadOnlyState state, int playerIndex)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			this.state = state;
			this.playerIndex = playerIndex;
			segmentIndex = 0;
			currPoint = GetStartPoint(state, playerIndex);
		}

		public bool MoveNext(float distance)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			float num = 0f;
			int num2 = playerIndex * state.BufferSize + 1;
			while (num < distance && HasNext())
			{
				TickInterpolator.Segment segment = state.Segments[num2 + segmentIndex];
				currPoint = segment.point;
				num += segment.length;
				segmentIndex++;
			}
			return num > 0f;
		}

		public void Reset()
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			segmentIndex = 0;
			currPoint = StartPoint;
		}

		public bool HasNext()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return segmentIndex < state.Infos[playerIndex].Count;
		}
	}

	private NativeArray<TickInterpolator.Segment> playerSegments;

	private NativeArray<PlayerInfo> playerInfos;

	private int bufferSize = 9;

	public ReadOnlyState ReadOnly => new ReadOnlyState(playerSegments.AsReadOnly(), playerInfos.AsReadOnly(), bufferSize);

	public TickInterpolatorCache(int capacity = 32)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		playerSegments = new NativeArray<TickInterpolator.Segment>(bufferSize * capacity, (Allocator)4, (NativeArrayOptions)0);
		playerInfos = new NativeArray<PlayerInfo>(capacity, (Allocator)4, (NativeArrayOptions)1);
	}

	public void Dispose()
	{
		NativeArrayEx.SafeDispose(ref playerSegments);
		NativeArrayEx.SafeDispose(ref playerInfos);
	}

	public void ReplacePlayer(int index)
	{
		playerInfos[index] = default(PlayerInfo);
	}

	public unsafe void AddTick(BasePlayer player, Vector3 point)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		int stableIndex = player.StableIndex;
		int num = player.StableIndex * bufferSize;
		ref PlayerInfo reference = ref UnsafeUtility.ArrayElementAsRef<PlayerInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<PlayerInfo>(playerInfos), stableIndex);
		int num2 = ++reference.Count;
		Vector3 point2 = playerSegments[num + num2 - 1].point;
		TickInterpolator.Segment segment = new TickInterpolator.Segment(point2, point);
		reference.Length += segment.length;
		if (num2 >= bufferSize)
		{
			GrowSegments(playerInfos.Length);
		}
		playerSegments[num + num2] = segment;
	}

	public unsafe void Reset(BasePlayer player, Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		int stableIndex = player.StableIndex;
		ref PlayerInfo reference = ref UnsafeUtility.ArrayElementAsRef<PlayerInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<PlayerInfo>(playerInfos), stableIndex);
		reference.Count = 0;
		reference.Length = 0f;
		int num = player.StableIndex * bufferSize;
		playerSegments[num] = new TickInterpolator.Segment(point);
	}

	public void Expand(int newCap)
	{
		int length = playerInfos.Length;
		if (newCap > length)
		{
			NativeArrayEx.Expand(ref playerInfos, newCap, (NativeArrayOptions)1);
			GrowSegments(length);
		}
	}

	public static Vector3 GetStartPoint(ReadOnlyState state, int playerIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return state.Segments[playerIndex * state.BufferSize].point;
	}

	public static Vector3 GetEndPoint(ReadOnlyState state, int playerIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		PlayerInfo info = state.Infos[playerIndex];
		return GetEndPoint(state, playerIndex, info);
	}

	public static Vector3 GetEndPoint(ReadOnlyState state, int playerIndex, PlayerInfo info)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return state.Segments[playerIndex * state.BufferSize + info.Count].point;
	}

	public void TransformEntries(int playerIndex, in Matrix4x4 matrix)
	{
		PlayerInfo info = playerInfos[playerIndex];
		TransformEntries(playerIndex, info, in matrix);
	}

	public unsafe void TransformEntries(int playerIndex, PlayerInfo info, in Matrix4x4 matrix)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<TickInterpolator.Segment> subArray = playerSegments.GetSubArray(playerIndex * bufferSize, info.Count + 1);
		void* unsafePtr = NativeArrayUnsafeUtility.GetUnsafePtr<TickInterpolator.Segment>(subArray);
		for (int i = 0; i < subArray.Length; i++)
		{
			ref TickInterpolator.Segment reference = ref UnsafeUtility.ArrayElementAsRef<TickInterpolator.Segment>(unsafePtr, i);
			Matrix4x4 val = matrix;
			reference.point = ((Matrix4x4)(ref val)).MultiplyPoint3x4(reference.point);
		}
	}

	public static PlayerTickIterator GetPlayerTickIterator(ReadOnlyState state, int playerIndex)
	{
		return new PlayerTickIterator(state, playerIndex);
	}

	private void GrowSegments(int oldPlayerCap)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		int length = playerInfos.Length;
		int num = bufferSize;
		if (length == oldPlayerCap)
		{
			bufferSize += 4;
		}
		NativeArray<TickInterpolator.Segment> val = default(NativeArray<TickInterpolator.Segment>);
		val..ctor(length * bufferSize, (Allocator)4, (NativeArrayOptions)0);
		for (int i = 0; i < oldPlayerCap; i++)
		{
			int count = playerInfos[i].Count;
			if (count > 0)
			{
				NativeArray<TickInterpolator.Segment> subArray = playerSegments.GetSubArray(i * num, count + 1);
				NativeArray<TickInterpolator.Segment> subArray2 = val.GetSubArray(i * bufferSize, count + 1);
				subArray.CopyTo(subArray2);
			}
			else
			{
				val[i * bufferSize] = playerSegments[i * num];
			}
		}
		playerSegments.Dispose();
		playerSegments = val;
	}
}


public struct PlayerInfo
{
	public int Count;

	public float Length;
}


using Unity.Collections;

public struct ReadOnlyState
{
	public readonly ReadOnly<TickInterpolator.Segment> Segments;

	public readonly ReadOnly<PlayerInfo> Infos;

	public readonly int BufferSize;

	public ReadOnlyState(ReadOnly<TickInterpolator.Segment> playerSegments, ReadOnly<PlayerInfo> playerInfos, int bufferSize)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Segments = playerSegments;
		Infos = playerInfos;
		BufferSize = bufferSize;
	}
}


using UnityEngine;

public struct PlayerTickIterator
{
	private readonly ReadOnlyState state;

	private readonly int playerIndex;

	private Vector3 currPoint;

	private int segmentIndex;

	public Vector3 CurrentPoint => currPoint;

	public Vector3 StartPoint => GetStartPoint(state, playerIndex);

	public Vector3 EndPoint => GetEndPoint(state, playerIndex);

	public float Length => state.Infos[playerIndex].Length;

	public PlayerTickIterator(ReadOnlyState state, int playerIndex)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		this.state = state;
		this.playerIndex = playerIndex;
		segmentIndex = 0;
		currPoint = GetStartPoint(state, playerIndex);
	}

	public bool MoveNext(float distance)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = playerIndex * state.BufferSize + 1;
		while (num < distance && HasNext())
		{
			TickInterpolator.Segment segment = state.Segments[num2 + segmentIndex];
			currPoint = segment.point;
			num += segment.length;
			segmentIndex++;
		}
		return num > 0f;
	}

	public void Reset()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		segmentIndex = 0;
		currPoint = StartPoint;
	}

	public bool HasNext()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return segmentIndex < state.Infos[playerIndex].Count;
	}
}


using System;
using UnityEngine;

public class TimeCachedValue<T>
{
	public float refreshCooldown;

	public float refreshRandomRange;

	public Func<T> updateValue;

	private T cachedValue;

	private TimeSince cooldown;

	private bool hasRun;

	private bool forceNextRun;

	public T Get(bool force)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(cooldown) < refreshCooldown && !force && hasRun && !forceNextRun)
		{
			return cachedValue;
		}
		hasRun = true;
		forceNextRun = false;
		cooldown = TimeSince.op_Implicit(0f - Random.Range(0f, refreshRandomRange));
		if (updateValue != null)
		{
			cachedValue = updateValue();
		}
		else
		{
			cachedValue = default(T);
		}
		return cachedValue;
	}

	public void ForceNextRun()
	{
		forceNextRun = true;
	}

	public void UpdateImmediately()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		hasRun = true;
		forceNextRun = false;
		cooldown = TimeSince.op_Implicit(0f - Random.Range(0f, refreshRandomRange));
		if (updateValue != null)
		{
			cachedValue = updateValue();
		}
		else
		{
			cachedValue = default(T);
		}
	}
}


using System.Diagnostics;
using Facepunch.Rust;
using UnityEngine;

public struct Timing
{
	private Stopwatch sw;

	private string name;

	public static Timing Start(string name)
	{
		return new Timing(name);
	}

	public void End()
	{
		if (sw.Elapsed.TotalSeconds > 0.30000001192092896)
		{
			Debug.Log((object)("[" + sw.Elapsed.TotalSeconds.ToString("0.0") + "s] " + name));
			PerformanceLogging.server?.SetTiming(name, sw.Elapsed);
		}
	}

	public Timing(string name)
	{
		sw = Stopwatch.StartNew();
		this.name = name;
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public static class TransformUtil
{
	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hit, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out hit, 100f, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hit, float range, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out hit, range, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hitOut, float range, LayerMask mask, Transform ignoreTransform = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		hitOut = default(RaycastHit);
		if (GamePhysics.Trace(new Ray(startPos, Vector3.down), 0f, out var hitInfo, range, LayerMask.op_Implicit(mask), (QueryTriggerInteraction)0))
		{
			if ((Object)(object)ignoreTransform != (Object)null && (Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null && ((Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).transform == (Object)(object)ignoreTransform || ((Component)((RaycastHit)(ref hitInfo)).collider).transform.IsChildOf(ignoreTransform)))
			{
				return GetGroundInfo(startPos - new Vector3(0f, 0.01f, 0f), out hitOut, range, mask, ignoreTransform);
			}
			hitOut = hitInfo;
			return true;
		}
		return false;
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out pos, out normal, 100f, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out pos, out normal, range, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, LayerMask mask, Transform ignoreTransform = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(startPos, Vector3.down), 0f, list, range, LayerMask.op_Implicit(mask), (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			Collider collider = ((RaycastHit)(ref current)).collider;
			if ((Object)(object)collider == (Object)null)
			{
				continue;
			}
			if ((Object)(object)ignoreTransform != (Object)null)
			{
				Transform transform = ((Component)collider).transform;
				if ((Object)(object)transform == (Object)null || (Object)(object)transform == (Object)(object)ignoreTransform || transform.IsChildOf(ignoreTransform))
				{
					continue;
				}
			}
			pos = ((RaycastHit)(ref current)).point;
			normal = ((RaycastHit)(ref current)).normal;
			Pool.FreeUnmanaged<RaycastHit>(ref list);
			return true;
		}
		pos = startPos;
		normal = Vector3.up;
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfoTerrainOnly(startPos, out pos, out normal, 100f, LayerMask.op_Implicit(-1));
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfoTerrainOnly(startPos, out pos, out normal, range, LayerMask.op_Implicit(-1));
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, LayerMask mask)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(new Ray(startPos, Vector3.down), ref val, range, LayerMask.op_Implicit(mask)) && ((RaycastHit)(ref val)).collider is TerrainCollider)
		{
			pos = ((RaycastHit)(ref val)).point;
			normal = ((RaycastHit)(ref val)).normal;
			return true;
		}
		pos = startPos;
		normal = Vector3.up;
		return false;
	}

	public static Transform[] GetRootObjects()
	{
		return (from x in Object.FindObjectsOfType<Transform>()
			where (Object)(object)((Component)x).transform == (Object)(object)((Component)x).transform.root
			select x).ToArray();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class WorldSpline : MonoBehaviour
{
	public int dataIndex = -1;

	public Vector3[] points;

	public Vector3[] tangents;

	[Range(0.05f, 100f)]
	public float lutInterval = 0.25f;

	[SerializeField]
	private bool showGizmos = true;

	private static List<Vector3> visualSplineList = new List<Vector3>();

	private WorldSplineData privateData;

	public WorldSplineData GetData()
	{
		if (WorldSplineSharedData.TryGetDataFor(this, out var data))
		{
			return data;
		}
		if (Application.isPlaying && privateData == null)
		{
			privateData = new WorldSplineData(this);
		}
		return privateData;
	}

	public void SetAll(Vector3[] points, Vector3[] tangents, float lutInterval)
	{
		this.points = points;
		this.tangents = tangents;
		this.lutInterval = lutInterval;
	}

	public void CheckValidity()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		lutInterval = Mathf.Clamp(lutInterval, 0.05f, 100f);
		if (points == null || points.Length < 2)
		{
			points = (Vector3[])(object)new Vector3[2];
			points[0] = Vector3.zero;
			points[1] = Vector3.zero;
		}
		if (tangents != null && points.Length == tangents.Length)
		{
			return;
		}
		Vector3[] array = (Vector3[])(object)new Vector3[points.Length];
		for (int i = 0; i < array.Length; i++)
		{
			if (tangents != null && i < tangents.Length)
			{
				array[i] = tangents[i];
			}
			else
			{
				array[i] = Vector3.forward;
			}
		}
		tangents = array;
	}

	protected virtual void OnDrawGizmosSelected()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (showGizmos)
		{
			DrawSplineGizmo(this, Color.magenta);
		}
	}

	protected static void DrawSplineGizmo(WorldSpline ws, Color splineColour)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ws == (Object)null)
		{
			return;
		}
		WorldSplineData data = ws.GetData();
		if (data == null || ws.points.Length < 2 || ws.points.Length != ws.tangents.Length)
		{
			return;
		}
		Vector3[] pointsWorld = ws.GetPointsWorld();
		Vector3[] tangentsWorld = ws.GetTangentsWorld();
		for (int i = 0; i < pointsWorld.Length; i++)
		{
			Gizmos.color = Color.magenta;
			Gizmos.DrawSphere(pointsWorld[i], 0.25f);
			if (((Vector3)(ref tangentsWorld[i])).magnitude > 0f)
			{
				Gizmos.color = Color.cyan;
				Vector3 val = pointsWorld[i] + tangentsWorld[i] + Vector3.up * 0.1f;
				Gizmos.DrawLine(pointsWorld[i] + Vector3.up * 0.1f, val);
			}
		}
		Gizmos.color = splineColour;
		Vector3[] visualSpline = GetVisualSpline(ws, data, 1f);
		for (int j = 0; j < visualSpline.Length - 1; j++)
		{
			Gizmos.color = Color.Lerp(Color.white, splineColour, (float)j / (float)(visualSpline.Length - 1));
			Gizmos.DrawLine(visualSpline[j], visualSpline[j + 1]);
			Gizmos.DrawLine(visualSpline[j], visualSpline[j] + Vector3.up * 0.25f);
		}
	}

	private static Vector3[] GetVisualSpline(WorldSpline ws, WorldSplineData data, float distBetweenPoints)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		visualSplineList.Clear();
		if ((Object)(object)ws != (Object)null && ws.points.Length > 1)
		{
			Vector3 startPointWorld = ws.GetStartPointWorld();
			Vector3 endPointWorld = ws.GetEndPointWorld();
			visualSplineList.Add(startPointWorld);
			for (float num = distBetweenPoints; num <= data.Length - distBetweenPoints; num += distBetweenPoints)
			{
				visualSplineList.Add(ws.GetPointCubicHermiteWorld(num, data));
			}
			visualSplineList.Add(endPointWorld);
		}
		return visualSplineList.ToArray();
	}

	public Vector3 GetStartPointWorld()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(points[0]);
	}

	public Vector3 GetEndPointWorld()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(points[points.Length - 1]);
	}

	public Vector3 GetStartTangentWorld()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * tangents[0], ((Component)this).transform.localScale);
	}

	public Vector3 GetEndTangentWorld()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * tangents[tangents.Length - 1], ((Component)this).transform.localScale);
	}

	public Vector3 GetTangentCubicHermiteWorld(float distance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * GetData().GetTangentCubicHermite(distance), ((Component)this).transform.localScale);
	}

	public Vector3 GetTangentCubicHermiteWorld(float distance, WorldSplineData data)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * data.GetTangentCubicHermite(distance), ((Component)this).transform.localScale);
	}

	public Vector3 GetPointCubicHermiteWorld(float distance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(GetData().GetPointCubicHermite(distance));
	}

	public Vector3 GetPointCubicHermiteWorld(float distance, WorldSplineData data)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(data.GetPointCubicHermite(distance));
	}

	public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, out Vector3 tangent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermite = GetData().GetPointAndTangentCubicHermite(distance, out tangent);
		tangent = ((Component)this).transform.TransformVector(tangent);
		return ((Component)this).transform.TransformPoint(pointAndTangentCubicHermite);
	}

	public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, WorldSplineData data, out Vector3 tangent)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermite = data.GetPointAndTangentCubicHermite(distance, out tangent);
		tangent = ((Component)this).transform.TransformVector(tangent);
		return ((Component)this).transform.TransformPoint(pointAndTangentCubicHermite);
	}

	public Vector3[] GetPointsWorld()
	{
		return PointsToWorld(points, ((Component)this).transform);
	}

	public Vector3[] GetTangentsWorld()
	{
		return TangentsToWorld(tangents, ((Component)this).transform);
	}

	private static Vector3[] PointsToWorld(Vector3[] points, Transform tr)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[points.Length];
		for (int i = 0; i < points.Length; i++)
		{
			array[i] = tr.TransformPoint(points[i]);
		}
		return array;
	}

	private static Vector3[] TangentsToWorld(Vector3[] tangents, Transform tr)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[tangents.Length];
		for (int i = 0; i < tangents.Length; i++)
		{
			array[i] = Vector3.Scale(tr.rotation * tangents[i], tr.localScale);
		}
		return array;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class WorldSplineData
{
	[Serializable]
	public class LUTEntry
	{
		[Serializable]
		public struct LUTPoint
		{
			public float distance;

			public Vector3 pos;

			public LUTPoint(float distance, Vector3 pos)
			{
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				this.distance = distance;
				this.pos = pos;
			}
		}

		public List<LUTPoint> points = new List<LUTPoint>();
	}

	public Vector3[] inputPoints;

	public Vector3[] inputTangents;

	public float inputLUTInterval;

	public List<LUTEntry> LUTValues;

	public float Length;

	[SerializeField]
	private int maxPointsIndex;

	public WorldSplineData(WorldSpline worldSpline)
	{
		worldSpline.CheckValidity();
		LUTValues = new List<LUTEntry>();
		inputPoints = (Vector3[])(object)new Vector3[worldSpline.points.Length];
		worldSpline.points.CopyTo(inputPoints, 0);
		inputTangents = (Vector3[])(object)new Vector3[worldSpline.tangents.Length];
		worldSpline.tangents.CopyTo(inputTangents, 0);
		inputLUTInterval = worldSpline.lutInterval;
		maxPointsIndex = inputPoints.Length - 1;
		CreateLookupTable(worldSpline);
	}

	public bool IsSameAs(WorldSpline worldSpline)
	{
		if (inputPoints.SequenceEqual(worldSpline.points) && inputTangents.SequenceEqual(worldSpline.tangents))
		{
			return inputLUTInterval == worldSpline.lutInterval;
		}
		return false;
	}

	public bool IsDifferentTo(WorldSpline worldSpline)
	{
		return !IsSameAs(worldSpline);
	}

	public Vector3 GetStartPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return inputPoints[0];
	}

	public Vector3 GetEndPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return inputPoints[maxPointsIndex];
	}

	public Vector3 GetStartTangent()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return inputTangents[0];
	}

	public Vector3 GetEndTangent()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return inputTangents[maxPointsIndex];
	}

	public Vector3 GetPointCubicHermite(float distance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		Vector3 tangent;
		return GetPointAndTangentCubicHermite(distance, out tangent);
	}

	public Vector3 GetTangentCubicHermite(float distance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		GetPointAndTangentCubicHermite(distance, out var tangent);
		return tangent;
	}

	public Vector3 GetPointAndTangentCubicHermite(float distance, out Vector3 tangent)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		if (distance <= 0f)
		{
			tangent = GetStartTangent();
			return GetStartPoint();
		}
		if (distance >= Length)
		{
			tangent = GetEndTangent();
			return GetEndPoint();
		}
		int num = Mathf.FloorToInt(distance);
		if (LUTValues.Count > num)
		{
			int num2 = -1;
			while (num2 < 0 && (float)num > 0f)
			{
				LUTEntry lUTEntry = LUTValues[num];
				for (int i = 0; i < lUTEntry.points.Count && !(lUTEntry.points[i].distance > distance); i++)
				{
					num2 = i;
				}
				if (num2 < 0)
				{
					num--;
				}
			}
			float num3;
			Vector3 val;
			if (num2 < 0)
			{
				num3 = 0f;
				val = GetStartPoint();
			}
			else
			{
				LUTEntry.LUTPoint lUTPoint = LUTValues[num].points[num2];
				num3 = lUTPoint.distance;
				val = lUTPoint.pos;
			}
			num2 = -1;
			while (num2 < 0 && num < LUTValues.Count)
			{
				LUTEntry lUTEntry2 = LUTValues[num];
				for (int j = 0; j < lUTEntry2.points.Count; j++)
				{
					if (lUTEntry2.points[j].distance > distance)
					{
						num2 = j;
						break;
					}
				}
				if (num2 < 0)
				{
					num++;
				}
			}
			float num4;
			Vector3 val2;
			if (num2 < 0)
			{
				num4 = Length;
				val2 = GetEndPoint();
			}
			else
			{
				LUTEntry.LUTPoint lUTPoint2 = LUTValues[num].points[num2];
				num4 = lUTPoint2.distance;
				val2 = lUTPoint2.pos;
			}
			float num5 = Mathf.InverseLerp(num3, num4, distance);
			Vector3 val3 = val2 - val;
			tangent = ((Vector3)(ref val3)).normalized;
			return Vector3.Lerp(val, val2, num5);
		}
		tangent = GetEndTangent();
		return GetEndPoint();
	}

	public void SetDefaultTangents(WorldSpline worldSpline)
	{
		PathInterpolator pathInterpolator = new PathInterpolator(worldSpline.points, worldSpline.tangents);
		pathInterpolator.RecalculateTangents();
		worldSpline.tangents = pathInterpolator.Tangents;
	}

	public bool DetectSplineProblems(WorldSpline worldSpline)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		Vector3 val = GetTangentCubicHermite(0f);
		for (float num = 0.05f; num <= Length; num += 0.05f)
		{
			Vector3 tangentCubicHermite = GetTangentCubicHermite(num);
			float num2 = Vector3.Angle(tangentCubicHermite, val);
			if (num2 > 5f)
			{
				if ((Object)(object)worldSpline != (Object)null)
				{
					Vector3 tangent;
					Vector3 pointAndTangentCubicHermiteWorld = worldSpline.GetPointAndTangentCubicHermiteWorld(num, out tangent);
					Debug.DrawRay(pointAndTangentCubicHermiteWorld, tangent, Color.red, 30f);
					Debug.DrawRay(pointAndTangentCubicHermiteWorld, Vector3.up, Color.red, 30f);
				}
				Debug.Log((object)($"Spline may have a too-sharp bend at {num / Length:P0}. Angle change: " + num2));
				result = true;
			}
			val = tangentCubicHermite;
		}
		return result;
	}

	private void CreateLookupTable(WorldSpline worldSpline)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		PathInterpolator pathInterpolator = new PathInterpolator(worldSpline.points, worldSpline.tangents);
		Vector3 val = pathInterpolator.GetPointCubicHermite(0f);
		Length = 0f;
		AddEntry(0f, GetStartPoint());
		Vector3 pointCubicHermite;
		for (float num = worldSpline.lutInterval; num < pathInterpolator.Length; num += worldSpline.lutInterval)
		{
			pointCubicHermite = pathInterpolator.GetPointCubicHermite(num);
			Length += Vector3.Distance(pointCubicHermite, val);
			AddEntry(Length, pathInterpolator.GetPointCubicHermite(num));
			val = pointCubicHermite;
		}
		pointCubicHermite = GetEndPoint();
		Length += Vector3.Distance(pointCubicHermite, val);
		AddEntry(Length, pointCubicHermite);
	}

	private void AddEntry(float distance, Vector3 pos)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.FloorToInt(distance);
		if (LUTValues.Count < num + 1)
		{
			for (int i = LUTValues.Count; i < num + 1; i++)
			{
				LUTValues.Add(new LUTEntry());
			}
		}
		LUTValues[num].points.Add(new LUTEntry.LUTPoint(distance, pos));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class LUTEntry
{
	[Serializable]
	public struct LUTPoint
	{
		public float distance;

		public Vector3 pos;

		public LUTPoint(float distance, Vector3 pos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.distance = distance;
			this.pos = pos;
		}
	}

	public List<LUTPoint> points = new List<LUTPoint>();
}


using System;
using UnityEngine;

[Serializable]
public struct LUTPoint
{
	public float distance;

	public Vector3 pos;

	public LUTPoint(float distance, Vector3 pos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.distance = distance;
		this.pos = pos;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Vehicles/WorldSpline Shared Data", fileName = "WorldSpline Prefab Shared Data")]
public class WorldSplineSharedData : ScriptableObject
{
	[SerializeField]
	private List<WorldSplineData> dataList;

	public static WorldSplineSharedData _instance;

	private static readonly string[] worldSplineFolders = new string[2] { "Assets/Content/Structures", "Assets/bundled/Prefabs/autospawn" };

	public static WorldSplineSharedData instance
	{
		get
		{
			if ((Object)(object)_instance == (Object)null)
			{
				_instance = Resources.Load<WorldSplineSharedData>("WorldSpline Prefab Shared Data");
			}
			return _instance;
		}
	}

	public static bool TryGetDataFor(WorldSpline worldSpline, out WorldSplineData data)
	{
		if ((Object)(object)instance == (Object)null)
		{
			Debug.LogError((object)"No instance of WorldSplineSharedData found.");
			data = null;
			return false;
		}
		if (worldSpline.dataIndex < 0 || worldSpline.dataIndex >= instance.dataList.Count)
		{
			data = null;
			return false;
		}
		data = instance.dataList[worldSpline.dataIndex];
		return true;
	}
}


using System;
using UnityEngine;

public static class Ballistics
{
	private struct TheoreticalProjectile
	{
		public Vector3 pos;

		public Vector3 forward;

		public float gravity;

		public TheoreticalProjectile(Vector3 pos, Vector3 forward, float gravity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.pos = pos;
			this.forward = forward;
			this.gravity = gravity;
		}
	}

	public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, out float requiredGravity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetAimToTarget(origin, target, speed, maxAngle, idealGravity, 0f, out requiredGravity);
	}

	public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, float minRange, out float requiredGravity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		requiredGravity = idealGravity;
		Vector3 val = target - origin;
		float num = Vector3Ex.Magnitude2D(val);
		float y = val.y;
		float num2 = Mathf.Sqrt(speed * speed * speed * speed - requiredGravity * (requiredGravity * (num * num) + 2f * y * speed * speed));
		float num3 = Mathf.Atan((speed * speed + num2) / (requiredGravity * num)) * 57.29578f;
		float num4 = Mathf.Clamp(num3, 0f, 90f);
		if (float.IsNaN(num3))
		{
			num4 = 45f;
			requiredGravity = ProjectileDistToGravity(num, y, num4, speed);
		}
		else if (num3 > maxAngle)
		{
			num4 = maxAngle;
			requiredGravity = ProjectileDistToGravity(Mathf.Max(num, minRange), y, num4, speed);
		}
		((Vector3)(ref val)).Normalize();
		val.y = 0f;
		Vector3 val2 = Vector3.Cross(val, Vector3.up);
		val = Quaternion.AngleAxis(num4, val2) * val;
		return val;
	}

	public static bool TryGetPhysicsProjectileHitPos(Vector3 origin, Vector3 direction, float speed, float gravity, out Vector3 result, float flightTimePerUpwardCheck = 2f, float flightTimePerDownwardCheck = 0.66f, float maxRays = 128f, BaseNetworkable owner = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		TheoreticalProjectile projectile = new TheoreticalProjectile(origin, direction * speed, gravity);
		int num = 0;
		float dt = ((projectile.forward.y > 0f) ? flightTimePerUpwardCheck : flightTimePerDownwardCheck);
		while (!NextRayHitSomething(ref projectile, dt, owner) && (float)num < maxRays)
		{
			num++;
		}
		result = projectile.pos;
		return (float)num < maxRays;
	}

	public static Vector3 GetBulletHitPoint(Vector3 origin, Vector3 direction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return GetBulletHitPoint(new Ray(origin, direction));
	}

	public static Vector3 GetBulletHitPoint(Ray aimRay)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (GamePhysics.Trace(aimRay, 0f, out var hitInfo, 300f, 1220225809, (QueryTriggerInteraction)0))
		{
			return ((RaycastHit)(ref hitInfo)).point;
		}
		return ((Ray)(ref aimRay)).origin + ((Ray)(ref aimRay)).direction * 300f;
	}

	private static bool NextRayHitSomething(ref TheoreticalProjectile projectile, float dt, BaseNetworkable owner)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		float gravity = projectile.gravity;
		Vector3 pos = projectile.pos;
		float num = Vector3Ex.MagnitudeXZ(projectile.forward) * dt;
		float num2 = projectile.forward.y * dt + gravity * dt * dt * 0.5f;
		Vector2 val = Vector3Ex.XZ2D(projectile.forward);
		Vector2 val2 = ((Vector2)(ref val)).normalized * num;
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(val2.x, num2, val2.y);
		ref Vector3 pos2 = ref projectile.pos;
		pos2 += val3;
		float y = projectile.forward.y + gravity * dt;
		projectile.forward.y = y;
		RaycastHit hit = default(RaycastHit);
		if (Physics.Linecast(pos, projectile.pos, ref hit, 1084293393, (QueryTriggerInteraction)1))
		{
			projectile.pos = ((RaycastHit)(ref hit)).point;
			BaseEntity entity = hit.GetEntity();
			int num3;
			if ((Object)(object)entity != (Object)null)
			{
				num3 = (entity.EqualNetID(owner) ? 1 : 0);
				if (num3 != 0)
				{
					ref Vector3 pos3 = ref projectile.pos;
					pos3 += projectile.forward * 1f;
				}
			}
			else
			{
				num3 = 0;
			}
			return num3 == 0;
		}
		return false;
	}

	private static float ProjectileDistToGravity(float x, float y, float θ, float v)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		float num = θ * (MathF.PI / 180f);
		float num2 = (v * v * x * Mathf.Sin(2f * num) - 2f * v * v * y * Mathf.Cos(num) * Mathf.Cos(num)) / (x * x);
		if (float.IsNaN(num2) || num2 < 0.01f)
		{
			num2 = 0f - Physics.gravity.y;
		}
		return num2;
	}
}


using UnityEngine;

private struct TheoreticalProjectile
{
	public Vector3 pos;

	public Vector3 forward;

	public float gravity;

	public TheoreticalProjectile(Vector3 pos, Vector3 forward, float gravity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.pos = pos;
		this.forward = forward;
		this.gravity = gravity;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class Bezier
{
	public static void ApplyLineSlack(ref Vector3[] positions, float[] slackLevels, int tesselationLevel, Transform referenceTransform = null)
	{
		ApplyLineSlack(positions, slackLevels, ref positions, tesselationLevel, referenceTransform);
	}

	public static void ApplyLineSlack(Vector3[] positions, float[] slackLevels, ref Vector3[] result, int tesselationLevel, Transform referenceTransform = null)
	{
		List<Vector3> result2 = Pool.Get<List<Vector3>>();
		ApplyLineSlack(positions, slackLevels, ref result2, tesselationLevel, referenceTransform);
		if (result.Length >= 2 && result.Length != result2.Count)
		{
			result = (Vector3[])(object)new Vector3[result2.Count];
		}
		result2.CopyTo(result);
		Pool.FreeUnmanaged<Vector3>(ref result2);
	}

	public static int CalculateArraySize(int positionCount, int tesselationLevel)
	{
		return (positionCount - 1) * tesselationLevel + 2;
	}

	public static void ApplyLineSlack(Vector3[] positions, float[] slackLevels, ref List<Vector3> result, int tesselationLevel, Transform referenceTransform = null)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Length < 2 || slackLevels.Length == 0)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < slackLevels.Length; i++)
		{
			if (slackLevels[i] > 0f)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			result.AddRange(positions);
			return;
		}
		bool flag2 = (Object)(object)referenceTransform != (Object)null;
		float num = 1f / (float)tesselationLevel;
		for (int j = 0; j < positions.Length - 1; j++)
		{
			Vector3 val = positions[j];
			Vector3 val2 = positions[j + 1];
			if ((Object)(object)referenceTransform != (Object)null)
			{
				val = referenceTransform.TransformPoint(val);
				val2 = referenceTransform.TransformPoint(val2);
			}
			Vector3 val3 = Vector3.Lerp(val, val2, 0.5f);
			if (j < slackLevels.Length)
			{
				val3 += Vector3.down * slackLevels[j];
			}
			if (flag2)
			{
				result.Add(referenceTransform.InverseTransformPoint(val));
			}
			else
			{
				result.Add(val);
			}
			for (int k = 0; k < tesselationLevel; k++)
			{
				float num2 = (float)k * num;
				num2 = num2 * 0.8f + 0.1f;
				Vector3 val4 = Vector3.Lerp(val, val3, num2);
				Vector3 val5 = Vector3.Lerp(val3, val2, num2);
				Vector3 val6 = Vector3.Lerp(val4, val5, num2);
				if (flag2)
				{
					result.Add(referenceTransform.InverseTransformPoint(val6));
				}
				else
				{
					result.Add(val6);
				}
			}
		}
		Vector3 item = positions[^1];
		result.Add(item);
	}
}


using UnityEngine;

public struct FixedShort3
{
	private const int FracBits = 10;

	private const float MaxFrac = 1024f;

	private const float RcpMaxFrac = 0.0009765625f;

	public short x;

	public short y;

	public short z;

	public FixedShort3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		x = (short)(vec.x * 1024f);
		y = (short)(vec.y * 1024f);
		z = (short)(vec.z * 1024f);
	}

	public static explicit operator Vector3(FixedShort3 vec)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)vec.x * 0.0009765625f, (float)vec.y * 0.0009765625f, (float)vec.z * 0.0009765625f);
	}
}


using UnityEngine;

public struct FixedSByteNorm3
{
	private const int FracBits = 7;

	private const float MaxFrac = 128f;

	private const float RcpMaxFrac = 1f / 128f;

	public sbyte x;

	public sbyte y;

	public sbyte z;

	public FixedSByteNorm3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		x = (sbyte)(vec.x * 128f);
		y = (sbyte)(vec.y * 128f);
		z = (sbyte)(vec.z * 128f);
	}

	public static explicit operator Vector3(FixedSByteNorm3 vec)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)vec.x * (1f / 128f), (float)vec.y * (1f / 128f), (float)vec.z * (1f / 128f));
	}
}


using UnityEngine;

public struct FixedSByteNorm4
{
	private const int FracBits = 7;

	private const float MaxFrac = 128f;

	private const float RcpMaxFrac = 1f / 128f;

	public sbyte x;

	public sbyte y;

	public sbyte z;

	public sbyte w;

	public FixedSByteNorm4(Vector4 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		x = (sbyte)(vec.x * 128f);
		y = (sbyte)(vec.y * 128f);
		z = (sbyte)(vec.z * 128f);
		w = (sbyte)(vec.w * 128f);
	}

	public static explicit operator Vector4(FixedSByteNorm4 vec)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4((float)vec.x * (1f / 128f), (float)vec.y * (1f / 128f), (float)vec.z * (1f / 128f), (float)vec.w * (1f / 128f));
	}
}


using UnityEngine;

public struct Half3
{
	public ushort x;

	public ushort y;

	public ushort z;

	public Half3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		x = Mathf.FloatToHalf(vec.x);
		y = Mathf.FloatToHalf(vec.y);
		z = Mathf.FloatToHalf(vec.z);
	}

	public static explicit operator Vector3(Half3 vec)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Mathf.HalfToFloat(vec.x), Mathf.HalfToFloat(vec.y), Mathf.HalfToFloat(vec.z));
	}
}


using UnityEngine;

public struct Half4
{
	public ushort x;

	public ushort y;

	public ushort z;

	public ushort w;

	public Half4(Vector4 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		x = Mathf.FloatToHalf(vec.x);
		y = Mathf.FloatToHalf(vec.y);
		z = Mathf.FloatToHalf(vec.z);
		w = Mathf.FloatToHalf(vec.w);
	}

	public static explicit operator Vector4(Half4 vec)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4(Mathf.HalfToFloat(vec.x), Mathf.HalfToFloat(vec.y), Mathf.HalfToFloat(vec.z), Mathf.HalfToFloat(vec.w));
	}
}


using System.Collections.Concurrent;
using System.Collections.Generic;

public class ExactArrayPool<T>
{
	private readonly Dictionary<int, ConcurrentQueue<T[]>> _buffers = new Dictionary<int, ConcurrentQueue<T[]>>();

	public T[] Rent(int size)
	{
		if (!_buffers.TryGetValue(size, out var value))
		{
			value = new ConcurrentQueue<T[]>();
			_buffers[size] = value;
		}
		if (!value.TryDequeue(out var result))
		{
			return new T[size];
		}
		return result;
	}

	public void Return(T[] array)
	{
		if (!_buffers.TryGetValue(array.Length, out var value))
		{
			value = new ConcurrentQueue<T[]>();
			_buffers[array.Length] = value;
		}
		value.Enqueue(array);
	}
}


using System;
using System.Linq;
using ConVar;
using UnityEngine;

public class Poolable : MonoBehaviour, IClientComponent, IPrefabPostProcess
{
	[HideInInspector]
	public uint prefabID;

	[HideInInspector]
	public Behaviour[] behaviours;

	[HideInInspector]
	public Rigidbody[] rigidbodies;

	[HideInInspector]
	public Collider[] colliders;

	[HideInInspector]
	public LODGroup[] lodgroups;

	[HideInInspector]
	public Renderer[] renderers;

	[HideInInspector]
	public ParticleSystem[] particles;

	[HideInInspector]
	public bool[] behaviourStates;

	[HideInInspector]
	public bool[] rigidbodyStates;

	[HideInInspector]
	public bool[] colliderStates;

	[HideInInspector]
	public bool[] lodgroupStates;

	[HideInInspector]
	public bool[] rendererStates;

	public int ClientCount
	{
		get
		{
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<CodeLock>()))
			{
				return 200;
			}
			if ((Object)(object)((Component)this).GetComponent<LootPanel>() != (Object)null)
			{
				return 1;
			}
			if (((Component)this).GetComponent<DecorComponent>() != null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<BuildingBlock>() != (Object)null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<Door>() != (Object)null)
			{
				if ((bool)((Component)this).GetComponent<Construction>())
				{
					return 100;
				}
				return 1;
			}
			if ((Object)(object)((Component)this).GetComponent<Projectile>() != (Object)null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<Gib>() != (Object)null)
			{
				return 100;
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<UIMapVendingMachineMarker>()))
			{
				return 25;
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<UIMapVendingMachineMarkerCluster>()))
			{
				return 25;
			}
			if ((Object)(object)((Component)this).GetComponent<CollectableEasterEgg>() != (Object)null)
			{
				return 50;
			}
			return 1;
		}
	}

	public int ServerCount => 0;

	public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!bundling && !((Object)(object)((Component)this).gameObject != (Object)(object)rootObj))
		{
			Initialize(StringPool.Get(name));
		}
	}

	public void Initialize(uint id)
	{
		prefabID = id;
		behaviours = ((Component)this).gameObject.GetComponentsInChildren(typeof(Behaviour), true).OfType<Behaviour>().ToArray();
		rigidbodies = ((Component)this).gameObject.GetComponentsInChildren<Rigidbody>(true);
		colliders = ((Component)this).gameObject.GetComponentsInChildren<Collider>(true);
		lodgroups = ((Component)this).gameObject.GetComponentsInChildren<LODGroup>(true);
		renderers = ((Component)this).gameObject.GetComponentsInChildren<Renderer>(true);
		particles = ((Component)this).gameObject.GetComponentsInChildren<ParticleSystem>(true);
		if (behaviours.Length == 0)
		{
			behaviours = Array.Empty<Behaviour>();
		}
		if (rigidbodies.Length == 0)
		{
			rigidbodies = Array.Empty<Rigidbody>();
		}
		if (colliders.Length == 0)
		{
			colliders = Array.Empty<Collider>();
		}
		if (lodgroups.Length == 0)
		{
			lodgroups = Array.Empty<LODGroup>();
		}
		if (renderers.Length == 0)
		{
			renderers = Array.Empty<Renderer>();
		}
		if (particles.Length == 0)
		{
			particles = Array.Empty<ParticleSystem>();
		}
		behaviourStates = ArrayEx.New<bool>(behaviours.Length);
		rigidbodyStates = ArrayEx.New<bool>(rigidbodies.Length);
		colliderStates = ArrayEx.New<bool>(colliders.Length);
		lodgroupStates = ArrayEx.New<bool>(lodgroups.Length);
		rendererStates = ArrayEx.New<bool>(renderers.Length);
	}

	public void EnterPool()
	{
		if ((Object)(object)((Component)this).transform.parent != (Object)null)
		{
			((Component)this).transform.SetParent((Transform)null, false);
		}
		if (Pool.mode <= 1)
		{
			if (((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(false);
			}
			return;
		}
		SetBehaviourEnabled(state: false);
		SetComponentEnabled(state: false);
		if (!((Component)this).gameObject.activeSelf)
		{
			((Component)this).gameObject.SetActive(true);
		}
	}

	public void LeavePool()
	{
		if (Pool.mode > 1)
		{
			SetComponentEnabled(state: true);
		}
	}

	public void SetBehaviourEnabled(bool state)
	{
		try
		{
			if (!state)
			{
				for (int i = 0; i < behaviours.Length; i++)
				{
					Behaviour val = behaviours[i];
					behaviourStates[i] = val.enabled;
					val.enabled = false;
				}
				for (int j = 0; j < particles.Length; j++)
				{
					ParticleSystem obj = particles[j];
					obj.Stop();
					obj.Clear();
				}
				return;
			}
			for (int k = 0; k < particles.Length; k++)
			{
				ParticleSystem val2 = particles[k];
				if (val2.playOnAwake)
				{
					val2.Play();
				}
			}
			for (int l = 0; l < behaviours.Length; l++)
			{
				behaviours[l].enabled = behaviourStates[l];
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Pooling error: " + ((Object)this).name + " (" + ex.Message + ")"));
		}
	}

	public void SetComponentEnabled(bool state)
	{
		try
		{
			if (!state)
			{
				for (int i = 0; i < renderers.Length; i++)
				{
					Renderer val = renderers[i];
					rendererStates[i] = val.enabled;
					val.enabled = false;
				}
				for (int j = 0; j < lodgroups.Length; j++)
				{
					LODGroup val2 = lodgroups[j];
					lodgroupStates[j] = val2.enabled;
					val2.enabled = false;
				}
				for (int k = 0; k < colliders.Length; k++)
				{
					Collider val3 = colliders[k];
					colliderStates[k] = val3.enabled;
					val3.enabled = false;
				}
				for (int l = 0; l < rigidbodies.Length; l++)
				{
					Rigidbody val4 = rigidbodies[l];
					rigidbodyStates[l] = val4.isKinematic;
					val4.isKinematic = true;
					val4.detectCollisions = false;
				}
			}
			else
			{
				for (int m = 0; m < renderers.Length; m++)
				{
					renderers[m].enabled = rendererStates[m];
				}
				for (int n = 0; n < lodgroups.Length; n++)
				{
					lodgroups[n].enabled = lodgroupStates[n];
				}
				for (int num = 0; num < colliders.Length; num++)
				{
					colliders[num].enabled = colliderStates[num];
				}
				for (int num2 = 0; num2 < rigidbodies.Length; num2++)
				{
					Rigidbody obj = rigidbodies[num2];
					obj.isKinematic = rigidbodyStates[num2];
					obj.detectCollisions = true;
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Pooling error: " + ((Object)this).name + " (" + ex.Message + ")"));
		}
	}
}


using UnityEngine;

public static class PoolableEx
{
	public static bool SupportsPoolingInParent(this GameObject gameObject)
	{
		Poolable componentInParent = gameObject.GetComponentInParent<Poolable>();
		if ((Object)(object)componentInParent != (Object)null)
		{
			return componentInParent.prefabID != 0;
		}
		return false;
	}

	public static bool SupportsPooling(this GameObject gameObject)
	{
		Poolable component = gameObject.GetComponent<Poolable>();
		if ((Object)(object)component != (Object)null)
		{
			return component.prefabID != 0;
		}
		return false;
	}

	public static void AwakeFromInstantiate(this GameObject gameObject)
	{
		if (gameObject.activeSelf)
		{
			gameObject.GetComponent<Poolable>().SetBehaviourEnabled(state: true);
		}
		else
		{
			gameObject.SetActive(true);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class PrefabPool
{
	public Stack<Poolable> stack = new Stack<Poolable>();

	public string PrefabName { get; private set; }

	public int Missed { get; private set; }

	public int Pushed { get; private set; }

	public int Popped { get; private set; }

	public int Count => stack.Count;

	public int TargetCapacity { get; private set; }

	public PrefabPool(uint prefabId, int targetCapacity)
	{
		PrefabName = StringPool.Get(prefabId);
		TargetCapacity = targetCapacity;
	}

	public void Push(Poolable info)
	{
		Pushed++;
		stack.Push(info);
		info.EnterPool();
	}

	public void Push(GameObject instance)
	{
		Poolable component = instance.GetComponent<Poolable>();
		Push(component);
	}

	public GameObject Pop(Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		while (stack.Count > 0)
		{
			Poolable poolable = stack.Pop();
			Popped++;
			if (Object.op_Implicit((Object)(object)poolable))
			{
				((Component)poolable).transform.SetPositionAndRotation(pos, rot);
				poolable.LeavePool();
				return ((Component)poolable).gameObject;
			}
		}
		Missed++;
		return null;
	}

	public void Clear()
	{
		foreach (Poolable item in stack)
		{
			if (Object.op_Implicit((Object)(object)item))
			{
				Object.Destroy((Object)(object)((Component)item).gameObject);
			}
		}
		stack.Clear();
	}
}


using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

public class PrefabPoolCollection
{
	public Dictionary<uint, PrefabPool> storage = new Dictionary<uint, PrefabPool>();

	private bool isClient;

	public PrefabPoolCollection(bool client)
	{
		isClient = client;
	}

	public void Push(GameObject instance)
	{
		Poolable component = instance.GetComponent<Poolable>();
		if (!storage.TryGetValue(component.prefabID, out var value))
		{
			int targetCapacity = (isClient ? component.ClientCount : component.ServerCount);
			value = new PrefabPool(component.prefabID, targetCapacity);
			storage.Add(component.prefabID, value);
		}
		value.Push(component);
	}

	public GameObject Pop(uint id, Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (storage.TryGetValue(id, out var value))
		{
			return value.Pop(pos, rot);
		}
		return null;
	}

	public void Clear(string filter = null)
	{
		if (string.IsNullOrEmpty(filter))
		{
			foreach (KeyValuePair<uint, PrefabPool> item in storage)
			{
				item.Value.Clear();
			}
			return;
		}
		foreach (KeyValuePair<uint, PrefabPool> item2 in storage)
		{
			if (StringEx.Contains(StringPool.Get(item2.Key), filter, CompareOptions.IgnoreCase))
			{
				item2.Value.Clear();
			}
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using System.Threading;
using ConVar;
using Rust;
using UnityEngine;

public class PrefabPoolWarmup
{
	public static void Run(string filter = null, int countOverride = 0)
	{
		if (Application.isLoadingPrefabs)
		{
			return;
		}
		Application.isLoadingPrefabs = true;
		string[] assetList = GetAssetList();
		if (string.IsNullOrEmpty(filter))
		{
			for (int i = 0; i < assetList.Length; i++)
			{
				PrefabWarmup(assetList[i], countOverride);
			}
		}
		else
		{
			foreach (string text in assetList)
			{
				if (StringEx.Contains(text, filter, CompareOptions.IgnoreCase))
				{
					PrefabWarmup(text, countOverride);
				}
			}
		}
		Application.isLoadingPrefabs = false;
	}

	public static IEnumerator Run(float deltaTime, Action<string> statusFunction = null, string format = null, CancellationToken ct = default(CancellationToken))
	{
		if (Application.isEditor || Application.isLoadingPrefabs || !Pool.prewarm)
		{
			yield break;
		}
		Application.isLoadingPrefabs = true;
		string[] prewarmAssets = GetAssetList();
		Timing timer = new Timing("prefab_warmup");
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < prewarmAssets.Length; i++)
		{
			if (ct.IsCancellationRequested)
			{
				Application.isLoadingPrefabs = false;
				yield break;
			}
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == prewarmAssets.Length - 1)
			{
				statusFunction?.Invoke(string.Format((format != null) ? format : "{0}/{1}", i + 1, prewarmAssets.Length));
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			PrefabWarmup(prewarmAssets[i]);
		}
		timer.End();
		Application.isLoadingPrefabs = false;
	}

	public static string[] GetAssetList()
	{
		return (from x in GameManifest.Current.prefabProperties
			where x.pool && FileSystem.HasAsset(x.name)
			select x.name).ToArray();
	}

	private static void PrefabWarmup(string path, int countOverride = 0)
	{
		if (string.IsNullOrEmpty(path))
		{
			return;
		}
		GameObject val = GameManager.server.FindPrefab(path);
		if ((Object)(object)val != (Object)null && val.SupportsPooling())
		{
			int num = val.GetComponent<Poolable>().ServerCount;
			List<GameObject> list = new List<GameObject>();
			if (num > 0 && countOverride > 0)
			{
				num = countOverride;
			}
			for (int i = 0; i < num; i++)
			{
				list.Add(GameManager.server.CreatePrefab(path));
			}
			for (int j = 0; j < num; j++)
			{
				GameManager.server.Retire(list[j]);
			}
		}
	}
}


using UnityEngine;

public static class PorabolaUtils
{
	public static Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t, bool useLevelDirection = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		float num = t * 2f - 1f;
		if (Mathf.Abs(start.y - end.y) < 0.1f)
		{
			Vector3 val = end - start;
			Vector3 result = start + t * val;
			result.y += ((0f - num) * num + 1f) * height;
			return result;
		}
		Vector3 val2 = end - start;
		Vector3 val3 = end - new Vector3(start.x, end.y, start.z);
		Vector3 val4 = Vector3.Cross(val2, val3);
		Vector3 val5 = ((!useLevelDirection) ? Vector3.Cross(val4, val2) : Vector3.Cross(val4, val3));
		if (end.y > start.y)
		{
			val5 = -val5;
		}
		return start + t * val2 + ((0f - num) * num + 1f) * height * ((Vector3)(ref val5)).normalized;
	}

	public static float FindT(Vector3 start, Vector3 end, float height, Vector3 targetPosition, bool useLevelDirection = false)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 0.01f;
		for (num = 0f; num <= 1f; num += num2)
		{
			if (Vector3.Distance(SampleParabola(start, end, height, num, useLevelDirection), targetPosition) < 0.01f)
			{
				return num;
			}
		}
		return -1f;
	}

	public static Vector3 RotateAroundWorldAxis(Vector3 point, Vector3 pivot, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = point - pivot;
		Vector3 val3 = val * val2;
		return pivot + val3;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct LayerSelect
{
	[SerializeField]
	private int layer;

	public int Mask => 1 << layer;

	public string Name => LayerMask.LayerToName(layer);

	public LayerSelect(int layer)
	{
		this.layer = layer;
	}

	public static implicit operator int(LayerSelect layer)
	{
		return layer.layer;
	}

	public static implicit operator LayerSelect(int layer)
	{
		return new LayerSelect(layer);
	}
}


using System;

public class NetworkedProperty<T> where T : IEquatable<T>
{
	private T val;

	private BaseEntity entity;

	public T Value
	{
		get
		{
			return val;
		}
		set
		{
			if (!val.Equals(value))
			{
				val = value;
				if (entity.isServer)
				{
					entity.SendNetworkUpdate();
				}
			}
		}
	}

	public NetworkedProperty(BaseEntity entity)
	{
		this.entity = entity;
	}

	public static implicit operator T(NetworkedProperty<T> value)
	{
		return value.Value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResettableFloat : ISerializationCallbackReceiver
{
	[SerializeField]
	private float defaultValue;

	[NonSerialized]
	private float currentValue;

	public float Value
	{
		get
		{
			return currentValue;
		}
		set
		{
			currentValue = value;
		}
	}

	public float DefaultValue => defaultValue;

	public ResettableFloat(float value)
	{
		defaultValue = value;
		currentValue = value;
	}

	public void OnBeforeSerialize()
	{
	}

	public void OnAfterDeserialize()
	{
		currentValue = defaultValue;
	}

	public void Reset()
	{
		currentValue = defaultValue;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BaseEntityRef : ResourceRef<BaseEntity>
{
	public override BaseEntity Get()
	{
		if ((Object)(object)_cachedObject != (Object)null)
		{
			return _cachedObject;
		}
		Object obj = GameManifest.GUIDToObject(guid);
		GameObject val = (GameObject)(object)((obj is GameObject) ? obj : null);
		BaseEntity baseEntity = null;
		if ((Object)(object)val != (Object)null && val.TryGetComponent<BaseEntity>(ref baseEntity))
		{
			_cachedObject = baseEntity;
		}
		return baseEntity;
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class GameObjectRef : ResourceRef<GameObject>
{
	public GameObject Instantiate(Transform parent = null)
	{
		return Instantiate.GameObject(Get(), parent);
	}

	public BaseEntity GetEntity()
	{
		GameObject val = Get();
		if (!((Object)(object)val == (Object)null))
		{
			return val.GetComponent<BaseEntity>();
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceRef<T> where T : Object
{
	public string guid;

	protected T _cachedObject;

	public bool isValid => !string.IsNullOrEmpty(guid);

	public string resourcePath => GameManifest.GUIDToPath(guid);

	public uint resourceID => StringPool.Get(resourcePath);

	public virtual T Get()
	{
		if ((Object)(object)_cachedObject == (Object)null)
		{
			ref T cachedObject = ref _cachedObject;
			Object obj = GameManifest.GUIDToObject(guid);
			cachedObject = (T)(object)((obj is T) ? obj : null);
		}
		return _cachedObject;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ScriptableObjectRef : ResourceRef<ScriptableObject>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2DRef : ResourceRef<Texture2D>
{
}


using UnityEngine;

public class RandomGameObject : MonoBehaviour
{
	public GameObject[] gameObjects;

	private void Awake()
	{
		EnableRandomObject();
	}

	private void EnableRandomObject()
	{
		if (gameObjects.Length != 0)
		{
			GameObject[] array = gameObjects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(false);
			}
			gameObjects.GetRandom().SetActive(true);
		}
	}
}


using UnityEngine;

public class RandomScale : MonoBehaviour
{
	[SerializeField]
	private bool multiplyByExistingScale = true;

	[SerializeField]
	private Vector3 minScale = Vector3.one * 0.8f;

	[SerializeField]
	private Vector3 maxScale = Vector3.one * 1.2f;

	private void Awake()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (multiplyByExistingScale)
		{
			Transform transform = ((Component)this).transform;
			transform.localScale *= Random.Range(minScale.x, maxScale.x);
		}
		else
		{
			((Component)this).transform.localScale = Vector3.one * Random.Range(minScale.x, maxScale.x);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using UnityEngine;

[Factory("log")]
public class RustLog : ConsoleSystem
{
	public enum EntryType
	{
		General,
		Network,
		Hierarchy,
		Serialization,
		Combat,
		Item,
		Audio
	}

	private static readonly string[] names = Enum.GetNames(typeof(EntryType));

	public static readonly int[] Levels = new int[names.Length];

	[ServerVar]
	[ClientVar]
	public static void Level(Arg args)
	{
		if (args.Args.Length == 0 || args.Args.Length > 2)
		{
			return;
		}
		string @string = args.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			return;
		}
		for (int i = 0; i < names.Length; i++)
		{
			string text = names[i];
			if (!(@string != text))
			{
				if (args.Args.Length == 2)
				{
					Levels[i] = args.GetInt(1, Levels[i]);
				}
				else
				{
					Debug.Log((object)GetLevel((EntryType)i));
				}
				break;
			}
		}
	}

	public static int GetLevel(EntryType type)
	{
		return Levels[(int)type];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log(EntryType type, int level, GameObject gameObject, string msg)
	{
		if (GetLevel(type) >= level)
		{
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3, T4>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3, arg4);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3, T4, T5>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3, arg4, arg5);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void LogImpl(EntryType type, string msg, GameObject gameObject)
	{
		Debug.Log((object)$"<color=white>[{type}]</color> {msg}", (Object)(object)gameObject);
	}
}


public enum EntryType
{
	General,
	Network,
	Hierarchy,
	Serialization,
	Combat,
	Item,
	Audio
}


using UnityEngine;

public class AlternateAttack : StateMachineBehaviour
{
	public bool random;

	public bool dontIncrement;

	public string[] targetTransitions;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (random)
		{
			string text = targetTransitions[Random.Range(0, targetTransitions.Length)];
			animator.Play(text, layerIndex, 0f);
			return;
		}
		int integer = animator.GetInteger("lastAttack");
		string text2 = targetTransitions[integer % targetTransitions.Length];
		animator.Play(text2, layerIndex, 0f);
		if (!dontIncrement)
		{
			animator.SetInteger("lastAttack", integer + 1);
		}
	}
}


using System.Collections.Generic;
using Rust.Workshop;
using UnityEngine;

public class BaseViewModel : FacepunchBehaviour, IPrefabPreProcess, IViewmodelWorkshopPreview, IWorkshopPreview
{
	public enum ViewmodelType
	{
		Regular,
		Gesture,
		Shield
	}

	[Header("BaseViewModel")]
	public LazyAimProperties lazyaimRegular;

	public LazyAimProperties lazyaimIronsights;

	public Transform pivot;

	public bool useViewModelCamera = true;

	public bool wantsHeldItemFlags;

	public GameObject[] hideSightMeshes;

	public ViewmodelType viewmodelType;

	public Transform MuzzlePoint;

	[Header("Skin")]
	public SubsurfaceProfile subsurfaceProfile;

	[HideInInspector]
	public List<SkinnedMeshRenderer> baseSkinPieces = new List<SkinnedMeshRenderer>();

	[Header("Shield Overrides")]
	public AnimationCurve leftArmShieldHideCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	bool IPrefabPreProcess.CanRunDuringBundling => false;

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


public enum ViewmodelType
{
	Regular,
	Gesture,
	Shield
}


public interface IViewmodelComponent
{
}


using UnityEngine;

public class BinocularViewmodel : MonoBehaviour, IViewmodelComponent
{
}


using UnityEngine;

public class BlunderbussViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;

	public float ShotsLeftSpeed = 1f;

	public int HammerLayer = 1;
}


using UnityEngine;

public class CompassViewmodel : MonoBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	[SerializeField]
	private Transform needleBone;
}


using System;
using UnityEngine;

public class FishingRodViewmodel : MonoBehaviour
{
	[Serializable]
	public struct FishViewmodel
	{
		public ItemDefinition Item;

		public GameObject Root;
	}

	public Transform PitchTransform;

	public Transform YawTransform;

	public float YawLerpSpeed = 1f;

	public float PitchLerpSpeed = 1f;

	public Transform LineRendererStartPos;

	public ParticleSystem[] StrainParticles;

	public bool ApplyTransformRotation = true;

	public GameObject CatchRoot;

	public Transform CatchLinePoint;

	public FishViewmodel[] FishViewmodels;

	public float ShakeMaxScale = 0.1f;
}


using System;
using UnityEngine;

[Serializable]
public struct FishViewmodel
{
	public ItemDefinition Item;

	public GameObject Root;
}


public enum flamethrowerState
{
	OFF,
	PILOT_LIGHT,
	FLAME_ON
}


using UnityEngine;

public class flamethrowerFire : MonoBehaviour
{
	public ParticleSystem pilotLightFX;

	public ParticleSystem[] flameFX;

	public FlameJet jet;

	public AudioSource oneShotSound;

	public AudioSource loopSound;

	public AudioClip pilotlightIdle;

	public AudioClip flameLoop;

	public AudioClip flameStart;

	public flamethrowerState flameState;

	private flamethrowerState previousflameState;

	public void PilotLightOn()
	{
		pilotLightFX.enableEmission = true;
		SetFlameStatus(status: false);
	}

	public void SetFlameStatus(bool status)
	{
		ParticleSystem[] array = flameFX;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enableEmission = status;
		}
	}

	public void ShutOff()
	{
		pilotLightFX.enableEmission = false;
		SetFlameStatus(status: false);
	}

	public void FlameOn()
	{
		pilotLightFX.enableEmission = false;
		SetFlameStatus(status: true);
	}

	private void Start()
	{
		previousflameState = (flameState = flamethrowerState.OFF);
		ShutOff();
	}

	private void Update()
	{
		if (previousflameState != flameState)
		{
			switch (flameState)
			{
			case flamethrowerState.OFF:
				ShutOff();
				break;
			case flamethrowerState.PILOT_LIGHT:
				PilotLightOn();
				break;
			case flamethrowerState.FLAME_ON:
				FlameOn();
				break;
			}
			previousflameState = flameState;
			jet.SetOn(flameState == flamethrowerState.FLAME_ON);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class FoodViewModel : BaseViewModel
{
	[Serializable]
	public class FoodVisualConfig
	{
		public List<FoodVisualObject> VisualItems = new List<FoodVisualObject>();

		public string TintMaterialProperty;

		private MaterialPropertyBlock materialPB;

		private int detailAlbedo;

		public void InitForItem(Item item)
		{
			if (item != null && !((Object)(object)item.info == (Object)null))
			{
				InitForItemDef(item.info);
			}
		}

		public void InitForItemDef(ItemDefinition itemDef)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Expected O, but got Unknown
			if ((Object)(object)itemDef == (Object)null)
			{
				return;
			}
			if (materialPB == null)
			{
				materialPB = new MaterialPropertyBlock();
				detailAlbedo = Shader.PropertyToID(TintMaterialProperty);
			}
			FoodVisualObject foodVisualObject = null;
			foreach (FoodVisualObject visualItem in VisualItems)
			{
				if (visualItem != null)
				{
					visualItem.SetVisible(flag: false);
					if ((Object)(object)visualItem.ItemDef == (Object)(object)itemDef)
					{
						foodVisualObject = visualItem;
					}
				}
			}
			if (foodVisualObject != null)
			{
				foodVisualObject.SetVisible(flag: true);
				foodVisualObject.ApplyTint(materialPB, detailAlbedo);
			}
		}

		public void HideAll()
		{
			foreach (FoodVisualObject visualItem in VisualItems)
			{
				visualItem?.SetVisible(flag: false);
			}
		}
	}

	[Serializable]
	public class FoodVisualObject
	{
		public ItemDefinition ItemDef;

		public List<GameObject> GameObjects;

		public SkinnedMeshRenderer TintSkinnedRenderer;

		public List<MeshRenderer> TintRenderers;

		public Color ColorTint;

		public void SetVisible(bool flag)
		{
			if (GameObjects == null)
			{
				return;
			}
			foreach (GameObject gameObject in GameObjects)
			{
				gameObject.SetActive(flag);
			}
		}

		public void ApplyTint(MaterialPropertyBlock mpb, int matPropertyName)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (mpb == null || ((Object)(object)TintSkinnedRenderer == (Object)null && TintRenderers == null) || matPropertyName == 0)
			{
				return;
			}
			mpb.SetColor(matPropertyName, ColorTint);
			if ((Object)(object)TintSkinnedRenderer != (Object)null)
			{
				((Renderer)TintSkinnedRenderer).SetPropertyBlock(mpb, 0);
			}
			if (TintRenderers == null)
			{
				return;
			}
			foreach (MeshRenderer tintRenderer in TintRenderers)
			{
				if (!((Object)(object)tintRenderer == (Object)null))
				{
					((Renderer)tintRenderer).SetPropertyBlock(mpb, 0);
				}
			}
		}
	}

	public List<GameObject> VisualRoots;

	public FoodVisualConfig VisualConfig;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FoodVisualConfig
{
	public List<FoodVisualObject> VisualItems = new List<FoodVisualObject>();

	public string TintMaterialProperty;

	private MaterialPropertyBlock materialPB;

	private int detailAlbedo;

	public void InitForItem(Item item)
	{
		if (item != null && !((Object)(object)item.info == (Object)null))
		{
			InitForItemDef(item.info);
		}
	}

	public void InitForItemDef(ItemDefinition itemDef)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if ((Object)(object)itemDef == (Object)null)
		{
			return;
		}
		if (materialPB == null)
		{
			materialPB = new MaterialPropertyBlock();
			detailAlbedo = Shader.PropertyToID(TintMaterialProperty);
		}
		FoodVisualObject foodVisualObject = null;
		foreach (FoodVisualObject visualItem in VisualItems)
		{
			if (visualItem != null)
			{
				visualItem.SetVisible(flag: false);
				if ((Object)(object)visualItem.ItemDef == (Object)(object)itemDef)
				{
					foodVisualObject = visualItem;
				}
			}
		}
		if (foodVisualObject != null)
		{
			foodVisualObject.SetVisible(flag: true);
			foodVisualObject.ApplyTint(materialPB, detailAlbedo);
		}
	}

	public void HideAll()
	{
		foreach (FoodVisualObject visualItem in VisualItems)
		{
			visualItem?.SetVisible(flag: false);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FoodVisualObject
{
	public ItemDefinition ItemDef;

	public List<GameObject> GameObjects;

	public SkinnedMeshRenderer TintSkinnedRenderer;

	public List<MeshRenderer> TintRenderers;

	public Color ColorTint;

	public void SetVisible(bool flag)
	{
		if (GameObjects == null)
		{
			return;
		}
		foreach (GameObject gameObject in GameObjects)
		{
			gameObject.SetActive(flag);
		}
	}

	public void ApplyTint(MaterialPropertyBlock mpb, int matPropertyName)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (mpb == null || ((Object)(object)TintSkinnedRenderer == (Object)null && TintRenderers == null) || matPropertyName == 0)
		{
			return;
		}
		mpb.SetColor(matPropertyName, ColorTint);
		if ((Object)(object)TintSkinnedRenderer != (Object)null)
		{
			((Renderer)TintSkinnedRenderer).SetPropertyBlock(mpb, 0);
		}
		if (TintRenderers == null)
		{
			return;
		}
		foreach (MeshRenderer tintRenderer in TintRenderers)
		{
			if (!((Object)(object)tintRenderer == (Object)null))
			{
				((Renderer)tintRenderer).SetPropertyBlock(mpb, 0);
			}
		}
	}
}


using UnityEngine;

public class GrenadeViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;
}


using UnityEngine;

public class HandcuffsViewModel : BaseViewModel
{
	public SkinnedMeshRenderer handcuffsRenderer;
}


using UnityEngine;

public class IronsightAimPoint : MonoBehaviour
{
	public Transform targetPoint;

	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.cyan;
		Vector3 val = targetPoint.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Gizmos.color = Color.red;
		DrawArrow(((Component)this).transform.position, ((Component)this).transform.position + normalized * 0.1f, 0.1f);
		Gizmos.color = Color.cyan;
		DrawArrow(((Component)this).transform.position, targetPoint.position, 0.02f);
		Gizmos.color = Color.yellow;
		DrawArrow(targetPoint.position, targetPoint.position + normalized * 3f, 0.02f);
	}

	private void DrawArrow(Vector3 start, Vector3 end, float arrowLength)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = end - start;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 up = ((Component)Camera.current).transform.up;
		Gizmos.DrawLine(start, end);
		Gizmos.DrawLine(end, end + up * arrowLength - normalized * arrowLength);
		Gizmos.DrawLine(end, end - up * arrowLength - normalized * arrowLength);
		Gizmos.DrawLine(end + up * arrowLength - normalized * arrowLength, end - up * arrowLength - normalized * arrowLength);
	}
}


using UnityEngine;

public class IronSightOverride : MonoBehaviour
{
	public IronsightAimPoint aimPoint;

	public float fieldOfViewOffset = -20f;

	public float zoomFactor = -1f;

	[Tooltip("If set to 1, the FOV is set to what this override is set to. If set to 0.5 it's half way between the weapon iconsights default and this scope.")]
	public float fovBias = 0.5f;
}


using UnityEngine;

public class IronSights : MonoBehaviour
{
	[Header("View Setup")]
	public IronsightAimPoint aimPoint;

	public float fieldOfViewOffset = -20f;

	public float zoomFactor = 1f;

	[Header("Animation")]
	public float introSpeed = 1f;

	public AnimationCurve introCurve = new AnimationCurve();

	public float outroSpeed = 1f;

	public AnimationCurve outroCurve = new AnimationCurve();

	[Tooltip("Force the ironsight rotation every frame, don't lerp to the rotation. Can be useful if the ADS is animated and this component is conflicting")]
	public bool disableLerps;

	[Header("Sounds")]
	public SoundDefinition upSound;

	public SoundDefinition downSound;

	[Header("Info")]
	public IronSightOverride ironsightsOverride;

	public bool processUltrawideOffset;
}


using UnityEngine;

public class MagazineStateViewmodel : MonoBehaviour, IClientComponent, IViewmodelComponent, IAnimationEventReceiver
{
	public Animator TargetAnimator;

	[Tooltip("This gameobject will be toggled active if the gun has > 1 bullet")]
	public GameObject ShellRoot;

	[Tooltip("Will set layer 1 to full weight if the gun has no ammo")]
	public bool EmptyAmmoLayer;

	[Tooltip("Will update a parameter called 'hasAmmo' on the vm animator")]
	public bool SetHasAmmoParam;
}


using UnityEngine;

public class MetalDetectorViewmodel : BaseViewModel
{
	public GameObject[] LongRangeLights;

	public GameObject[] SweetspotLights;

	public GameObject LongRangeLight;

	public Transform YawTransform;

	public Transform DetectPos;

	public MetalDetectorViewmodelAnimEvents viewmodelAnimEvents;

	public SkinnedMeshRenderer MeshRenderer;

	[ColorUsage(false, true)]
	public Color BulbOffColor;

	[ColorUsage(false, true)]
	public Color BulbOnColor;
}


public class MetalDetectorViewmodelAnimEvents : BaseMonoBehaviour
{
	public float scanAmount = 1f;

	public SoundDefinition scanSwingSoundDef;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MultiSwapArrows : MonoBehaviour, IClientComponent
{
	public List<SwapArrows> arrowSlots;

	public void UpdateAmmoType(ItemDefinition ammoType, bool hidden = false, int? slotIndex = null)
	{
		if (slotIndex.HasValue)
		{
			int value = slotIndex.Value;
			if (value >= 0 && value < arrowSlots.Count)
			{
				if ((Object)(object)arrowSlots[value] != (Object)null)
				{
					arrowSlots[value].UpdateAmmoType(ammoType, hidden);
				}
			}
			else
			{
				Debug.Log((object)"Error in MultiSwapArrows: Slot index out of range");
			}
			return;
		}
		int num = 0;
		foreach (SwapArrows arrowSlot in arrowSlots)
		{
			if ((Object)(object)arrowSlot != (Object)null)
			{
				arrowSlot.UpdateAmmoType(ammoType, hidden);
			}
			num++;
		}
	}

	private void Cleanup()
	{
		foreach (SwapArrows arrowSlot in arrowSlots)
		{
			if ((Object)(object)arrowSlot != (Object)null)
			{
				arrowSlot.HideAllArrowHeads();
			}
		}
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}

	public void OnEnable()
	{
		Cleanup();
	}
}


using UnityEngine;

public class RagdollEditor : SingletonComponent<RagdollEditor>
{
	private Vector3 view;

	private Rigidbody grabbedRigid;

	private Vector3 grabPos;

	private Vector3 grabOffset;

	private void OnGUI()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		GUI.Box(new Rect((float)Screen.width * 0.5f - 2f, (float)Screen.height * 0.5f - 2f, 4f, 4f), "");
	}

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
	}

	private void Update()
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		Camera.main.fieldOfView = 75f;
		if (Input.GetKey((KeyCode)324))
		{
			view.y += Input.GetAxisRaw("Mouse X") * 3f;
			view.x -= Input.GetAxisRaw("Mouse Y") * 3f;
			Cursor.lockState = (CursorLockMode)1;
			Cursor.visible = false;
		}
		else
		{
			Cursor.lockState = (CursorLockMode)0;
			Cursor.visible = true;
		}
		((Component)Camera.main).transform.rotation = Quaternion.Euler(view);
		Vector3 val = Vector3.zero;
		if (Input.GetKey((KeyCode)119))
		{
			val += Vector3.forward;
		}
		if (Input.GetKey((KeyCode)115))
		{
			val += Vector3.back;
		}
		if (Input.GetKey((KeyCode)97))
		{
			val += Vector3.left;
		}
		if (Input.GetKey((KeyCode)100))
		{
			val += Vector3.right;
		}
		Transform transform = ((Component)Camera.main).transform;
		transform.position += ((Component)this).transform.rotation * val * 0.05f;
		if (Input.GetKeyDown((KeyCode)323))
		{
			StartGrab();
		}
		if (Input.GetKeyUp((KeyCode)323))
		{
			StopGrab();
		}
	}

	private void FixedUpdate()
	{
		if (Input.GetKey((KeyCode)323))
		{
			UpdateGrab();
		}
	}

	private void StartGrab()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position, ((Component)this).transform.forward, ref val, 100f))
		{
			grabbedRigid = ((Component)((RaycastHit)(ref val)).collider).GetComponent<Rigidbody>();
			if (!((Object)(object)grabbedRigid == (Object)null))
			{
				Matrix4x4 worldToLocalMatrix = ((Component)grabbedRigid).transform.worldToLocalMatrix;
				grabPos = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint(((RaycastHit)(ref val)).point);
				worldToLocalMatrix = ((Component)this).transform.worldToLocalMatrix;
				grabOffset = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint(((RaycastHit)(ref val)).point);
			}
		}
	}

	private void UpdateGrab()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)grabbedRigid == (Object)null))
		{
			Vector3 val = ((Component)this).transform.TransformPoint(grabOffset);
			Vector3 val2 = ((Component)grabbedRigid).transform.TransformPoint(grabPos);
			Vector3 val3 = val - val2;
			grabbedRigid.AddForceAtPosition(val3 * 100f, val2, (ForceMode)5);
		}
	}

	private void StopGrab()
	{
		grabbedRigid = null;
	}
}


using UnityEngine;

public class RandomParameterNumber : StateMachineBehaviour
{
	public string parameterName;

	public int min;

	public int max;

	public bool preventRepetition;

	public bool isFloat;

	private int last;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		int num = Random.Range(min, max);
		int num2 = 0;
		while (last == num && preventRepetition && num2 < 100)
		{
			num = Random.Range(min, max);
			num2++;
		}
		if (isFloat)
		{
			animator.SetFloat(parameterName, (float)num);
		}
		else
		{
			animator.SetInteger(parameterName, num);
		}
		last = num;
	}
}


using UnityEngine;

public class RandomParameterNumberFloat : StateMachineBehaviour
{
	public string parameterName;

	public int min;

	public int max;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!string.IsNullOrEmpty(parameterName))
		{
			animator.SetFloat(parameterName, Mathf.Floor(Random.Range((float)min, (float)max + 0.5f)));
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Animations;

public class SetParameterAnimatorBehaviour : StateMachineBehaviour
{
	public enum ParamType
	{
		Float,
		Bool,
		Int
	}

	public enum Timing
	{
		OnStateEnter,
		OnStateExit,
		PassThreshold
	}

	public string ParameterName;

	public ParamType ParameterType;

	public float FloatValue;

	public bool BoolValue;

	public int IntValue;

	public Timing SetParameterTiming;

	[Range(0f, 1f)]
	[Tooltip("Normalised time of animation")]
	public float ThresholdTiming;

	private float lastNormalisedTime;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		if (SetParameterTiming == Timing.OnStateEnter)
		{
			SetParameter(animator);
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex, controller);
		if (SetParameterTiming == Timing.OnStateExit)
		{
			SetParameter(animator);
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		if (SetParameterTiming == Timing.PassThreshold)
		{
			if (((AnimatorStateInfo)(ref stateInfo)).normalizedTime > ThresholdTiming && lastNormalisedTime < ThresholdTiming)
			{
				SetParameter(animator);
			}
			lastNormalisedTime = ((AnimatorStateInfo)(ref stateInfo)).normalizedTime;
		}
	}

	private void SetParameter(Animator animator)
	{
		switch (ParameterType)
		{
		case ParamType.Float:
			animator.SetFloat(ParameterName, FloatValue);
			break;
		case ParamType.Bool:
			animator.SetBool(ParameterName, BoolValue);
			break;
		case ParamType.Int:
			animator.SetInteger(ParameterName, IntValue);
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}
}


public enum ParamType
{
	Float,
	Bool,
	Int
}


public enum Timing
{
	OnStateEnter,
	OnStateExit,
	PassThreshold
}


using UnityEngine;

public class SetParameterCurveAnimatorBehaviour : StateMachineBehaviour
{
	public string FloatParameterName;

	public AnimationCurve ParameterCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		animator.SetFloat(FloatParameterName, ParameterCurve.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime));
	}
}


using System;
using UnityEngine;

public class SwapAmmo : MonoBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	[Serializable]
	public class AmmoSetup
	{
		public ItemDefinition TargetAmmo;

		public GameObject[] Roots;
	}

	public AmmoSetup[] Setups;

	public bool EventDriven;
}


using System;
using UnityEngine;

[Serializable]
public class AmmoSetup
{
	public ItemDefinition TargetAmmo;

	public GameObject[] Roots;
}


using System;
using Rust;
using UnityEngine;

public class SwapArrows : MonoBehaviour, IClientComponent
{
	public enum ArrowType
	{
		One,
		Two,
		Three,
		Four
	}

	public GameObject[] arrowModels;

	[NonSerialized]
	private ItemDefinition curAmmoType;

	private bool wasHidden;

	public ItemDefinition CurrentAmmoType
	{
		get
		{
			return curAmmoType;
		}
		set
		{
			curAmmoType = value;
		}
	}

	public bool WasHidden
	{
		get
		{
			return wasHidden;
		}
		set
		{
			wasHidden = value;
		}
	}

	public void SelectArrowType(int iType)
	{
		HideAllArrowHeads();
		if (iType < arrowModels.Length)
		{
			arrowModels[iType].SetActive(true);
		}
	}

	public void HideAllArrowHeads()
	{
		GameObject[] array = arrowModels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
	}

	public void UpdateAmmoType(ItemDefinition ammoType, bool hidden = false)
	{
		if (hidden)
		{
			wasHidden = hidden;
			HideAllArrowHeads();
		}
		else if (!((Object)(object)curAmmoType == (Object)(object)ammoType) || hidden != wasHidden)
		{
			curAmmoType = ammoType;
			wasHidden = hidden;
			if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.WoodenArrowItemDef)
			{
				HideAllArrowHeads();
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.BoneArrowItemDef)
			{
				SelectArrowType(0);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.FireArrowItemDef)
			{
				SelectArrowType(1);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.HvArrowItemDef)
			{
				SelectArrowType(2);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.PoisonArrowItemDef)
			{
				SelectArrowType(3);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.StoneArrowItemDef)
			{
				SelectArrowType(4);
			}
			else
			{
				HideAllArrowHeads();
			}
		}
	}

	private void Cleanup()
	{
		HideAllArrowHeads();
		curAmmoType = null;
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}

	public void OnEnable()
	{
		Cleanup();
	}
}


public enum ArrowType
{
	One,
	Two,
	Three,
	Four
}


using UnityEngine;

public class SwapKeycard : MonoBehaviour
{
	public GameObject[] accessLevels;

	public void UpdateAccessLevel(int level)
	{
		GameObject[] array = accessLevels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
		if (level > 0 && accessLevels.Length >= level)
		{
			accessLevels[level - 1].SetActive(true);
		}
	}

	public void SetRootActive(int index)
	{
		for (int i = 0; i < accessLevels.Length; i++)
		{
			accessLevels[i].SetActive(i == index);
		}
	}
}


using System;
using UnityEngine;

public class SwapRPG : MonoBehaviour
{
	public enum RPGType
	{
		One,
		Two,
		Three,
		Four
	}

	public GameObject[] rpgModels;

	[NonSerialized]
	private string curAmmoType = "";

	public void SelectRPGType(int iType)
	{
		GameObject[] array = rpgModels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
		rpgModels[iType].SetActive(true);
	}

	public void UpdateAmmoType(ItemDefinition ammoType)
	{
		if (!(curAmmoType == ammoType.shortname))
		{
			curAmmoType = ammoType.shortname;
			switch (curAmmoType)
			{
			default:
				SelectRPGType(0);
				break;
			case "ammo.rocket.fire":
				SelectRPGType(1);
				break;
			case "ammo.rocket.hv":
				SelectRPGType(2);
				break;
			case "ammo.rocket.smoke":
				SelectRPGType(3);
				break;
			}
		}
	}

	private void Start()
	{
	}
}


public enum RPGType
{
	One,
	Two,
	Three,
	Four
}


using UnityEngine;

public class ViewmodelAspectOffset : MonoBehaviour
{
	public Vector3 OffsetAmount = Vector3.zero;

	[Tooltip("What aspect ratio should we start moving the viewmodel? 16:9 = 1.7, 21:9 = 2.3")]
	public float aspectCutoff = 2f;
}


public class ViewmodelAttachment : EntityComponent<BaseEntity>, IClientComponent, IViewModeChanged, IViewModelUpdated
{
	public enum AttachmentType
	{
		None,
		Scope8x,
		SmallScope,
		BurstModule,
		ExtendedMags,
		Flashlight,
		Holosight,
		LaserSight,
		MuzzleBoost,
		MuzzleBrake,
		RedDotSight,
		Silencer
	}

	public GameObjectRef modelObject;

	public string targetBone;

	public bool hideViewModelIronSights;

	public AttachmentType attachmentType;
}


public enum AttachmentType
{
	None,
	Scope8x,
	SmallScope,
	BurstModule,
	ExtendedMags,
	Flashlight,
	Holosight,
	LaserSight,
	MuzzleBoost,
	MuzzleBrake,
	RedDotSight,
	Silencer
}


using System;
using UnityEngine;

public class ViewmodelAttachmentOverride : MonoBehaviour
{
	[Serializable]
	public struct Override
	{
		public Transform TargetRoot;

		public ViewmodelAttachment.AttachmentType ForAttachment;

		public GameObjectRef ForAttachmentObject;
	}

	public Override[] Overrides;
}


using System;
using UnityEngine;

[Serializable]
public struct Override
{
	public Transform TargetRoot;

	public ViewmodelAttachment.AttachmentType ForAttachment;

	public GameObjectRef ForAttachmentObject;
}


using UnityEngine;

public class ViewmodelBob : MonoBehaviour
{
	public float bobSpeedWalk = 9f;

	public float bobSpeedRun = 13f;

	public float bobAmountWalk = 0.005f;

	public float bobAmountRun = 0.02f;

	public float leftOffsetRun = 0.04f;
}


using UnityEngine;

public class ViewModelCamera : MonoBehaviour
{
}


public enum RenderType
{
	OPAQUE_DEFERRED,
	OPAQUE_FORWARDBASE,
	TRANSPARENT_FORWARDBASE,
	TRANSPARENT,
	UNDEFINED
}


using System;
using UnityEngine;

[Serializable]
public struct ViewModelDrawEvent : IEquatable<ViewModelDrawEvent>
{
	public ViewModelRenderer viewModelRenderer;

	public Renderer renderer;

	public bool skipDepthPrePass;

	public Material material;

	public int subMesh;

	public int pass;

	public bool Equals(ViewModelDrawEvent other)
	{
		if (object.Equals(viewModelRenderer, other.viewModelRenderer) && object.Equals(renderer, other.renderer) && skipDepthPrePass == other.skipDepthPrePass && object.Equals(material, other.material) && subMesh == other.subMesh)
		{
			return pass == other.pass;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ViewModelDrawEvent other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((((((((((((Object)(object)viewModelRenderer != (Object)null) ? ((object)viewModelRenderer).GetHashCode() : 0) * 397) ^ (((Object)(object)renderer != (Object)null) ? ((object)renderer).GetHashCode() : 0)) * 397) ^ skipDepthPrePass.GetHashCode()) * 397) ^ (((Object)(object)material != (Object)null) ? ((object)material).GetHashCode() : 0)) * 397) ^ subMesh) * 397) ^ pass;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ViewModelRenderer : MonoBehaviour
{
	public List<Texture2D> cachedTextureRefs = new List<Texture2D>();

	public List<ViewModelDrawEvent> opaqueEvents = new List<ViewModelDrawEvent>();

	public List<ViewModelDrawEvent> transparentEvents = new List<ViewModelDrawEvent>();

	public Matrix4x4 prevModelMatrix;

	private Renderer viewModelRenderer;
}


using UnityEngine;

public class ViewmodelCameraAnimation : MonoBehaviour
{
	public Transform CameraModifyBone;

	public bool ShouldSuppressLeftHandScreenShake;

	public float FadeInTime;

	public Vector3 PositionOffset;

	public Vector3 RotationOffset;

	public Animator CameraAnimator;
}


using UnityEngine;

public class ViewmodelCameraAnimationSync : StateMachineBehaviour
{
}


public class ViewmodelEditor : SingletonComponent<ViewmodelEditor>
{
}


using UnityEngine;

public class ViewmodelIk : MonoBehaviour
{
}


using UnityEngine;

public class ViewmodelLower : MonoBehaviour
{
	public bool lowerOnSprint = true;

	public bool lowerWhenCantAttack = true;

	public bool forceLower;

	public float lowerScale = 1f;

	public void SetShouldLower(bool shouldLower)
	{
	}
}


using UnityEngine;

public class ViewmodelMountedAnchor : MonoBehaviour
{
	public ViewmodelIk IkController;
}


using UnityEngine;

public class ViewmodelPunch : MonoBehaviour
{
	public AnimationCurve punchScale;

	public Vector3 punchDirection;

	public float punchDuration = 0.1f;

	public float punchMagnitude = 1f;
}


using UnityEngine;

public class ViewmodelSway : MonoBehaviour
{
	public float positionalSwaySpeed = 1f;

	public float positionalSwayAmount = 1f;

	public float rotationSwaySpeed = 1f;

	public float rotationSwayAmount = 1f;

	public float rotateAmountTest = 20f;
}


using System;
using UnityEngine;

[AddComponentMenu("")]
public class AmplifyOcclusionBase : MonoBehaviour
{
	public enum ApplicationMethod
	{
		PostEffect,
		Deferred,
		Debug
	}

	public enum PerPixelNormalSource
	{
		None,
		Camera,
		GBuffer,
		GBufferOctaEncoded
	}

	public enum SampleCountLevel
	{
		Low,
		Medium,
		High,
		VeryHigh
	}

	[Header("Ambient Occlusion")]
	public ApplicationMethod ApplyMethod;

	[Tooltip("Number of samples per pass.")]
	public SampleCountLevel SampleCount = SampleCountLevel.Medium;

	public PerPixelNormalSource PerPixelNormals = PerPixelNormalSource.Camera;

	[Tooltip("Final applied intensity of the occlusion effect.")]
	[Range(0f, 1f)]
	public float Intensity = 1f;

	public Color Tint = Color.black;

	[Tooltip("Radius spread of the occlusion.")]
	[Range(0f, 32f)]
	public float Radius = 2f;

	[NonSerialized]
	[Tooltip("Max sampling range in pixels.")]
	[Range(32f, 1024f)]
	public int PixelRadiusLimit = 512;

	[NonSerialized]
	[Tooltip("Occlusion contribution amount on relation to radius.")]
	[Range(0f, 2f)]
	public float RadiusIntensity = 1f;

	[Tooltip("Power exponent attenuation of the occlusion.")]
	[Range(0f, 16f)]
	public float PowerExponent = 1.8f;

	[Range(0f, 0.99f)]
	[Tooltip("Controls the initial occlusion contribution offset.")]
	public float Bias = 0.05f;

	[Tooltip("Controls the thickness occlusion contribution.")]
	[Range(0f, 1f)]
	public float Thickness = 1f;

	[Tooltip("Compute the Occlusion and Blur at half of the resolution.")]
	public bool Downsample = true;

	[Header("Distance Fade")]
	[Tooltip("Control parameters at faraway.")]
	public bool FadeEnabled;

	[Tooltip("Distance in Unity unities that start to fade.")]
	public float FadeStart = 100f;

	[Tooltip("Length distance to performe the transition.")]
	public float FadeLength = 50f;

	[Tooltip("Final Intensity parameter.")]
	[Range(0f, 1f)]
	public float FadeToIntensity;

	public Color FadeToTint = Color.black;

	[Range(0f, 32f)]
	[Tooltip("Final Radius parameter.")]
	public float FadeToRadius = 2f;

	[Tooltip("Final PowerExponent parameter.")]
	[Range(0f, 16f)]
	public float FadeToPowerExponent = 1.8f;

	[Range(0f, 1f)]
	[Tooltip("Final Thickness parameter.")]
	public float FadeToThickness = 1f;

	[Header("Bilateral Blur")]
	public bool BlurEnabled = true;

	[Tooltip("Radius in screen pixels.")]
	[Range(1f, 4f)]
	public int BlurRadius = 3;

	[Range(1f, 4f)]
	[Tooltip("Number of times that the Blur will repeat.")]
	public int BlurPasses = 1;

	[Range(0f, 20f)]
	[Tooltip("0 - Blured, 1 - Sharpened.")]
	public float BlurSharpness = 10f;

	[Header("Temporal Filter")]
	[Tooltip("Accumulates the effect over the time.")]
	public bool FilterEnabled = true;

	[Tooltip("Controls the accumulation decayment. 0 - Faster update, more flicker. 1 - Slow update (ghosting on moving objects), less flicker.")]
	[Range(0f, 1f)]
	public float FilterBlending = 0.5f;

	[Tooltip("Controls the discard sensibility based on the motion of the scene and objects. 0 - Discard less, reuse more (more ghost effect). 1 - Discard more, reuse less (less ghost effect).")]
	[Range(0f, 1f)]
	public float FilterResponse = 0.5f;

	[NonSerialized]
	[Tooltip("Enables directional variations.")]
	public bool TemporalDirections = true;

	[NonSerialized]
	[Tooltip("Enables offset variations.")]
	public bool TemporalOffsets = true;

	[NonSerialized]
	[Tooltip("Reduces ghosting effect near the objects's edges while moving.")]
	public bool TemporalDilation;

	[NonSerialized]
	[Tooltip("Uses the object movement information for calc new areas of occlusion.")]
	public bool UseMotionVectors = true;
}


public enum ApplicationMethod
{
	PostEffect,
	Deferred,
	Debug
}


public enum PerPixelNormalSource
{
	None,
	Camera,
	GBuffer,
	GBufferOctaEncoded
}


public enum SampleCountLevel
{
	Low,
	Medium,
	High,
	VeryHigh
}


using UnityEngine;

[ExecuteInEditMode]
[AddComponentMenu("Image Effects/Amplify Occlusion")]
[RequireComponent(typeof(Camera))]
public class AmplifyOcclusionEffect : AmplifyOcclusionBase
{
}


using System;
using System.Collections;
using UnityEngine;

internal class UVTextureAnimator : MonoBehaviour
{
	public int Rows = 4;

	public int Columns = 4;

	public float Fps = 20f;

	public int OffsetMat;

	public bool IsLoop = true;

	public float StartDelay;

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		deltaFps = 1f / Fps;
		count = Rows * Columns;
		index = Columns - 1;
		Vector3 zero = Vector3.zero;
		OffsetMat -= OffsetMat / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)Columns, 1f / (float)Rows);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		while (isVisible && (IsLoop || allCount != count))
		{
			UpdateCorutineFrame();
			if (!IsLoop && allCount == count)
			{
				break;
			}
			yield return (object)new WaitForSeconds(deltaFps);
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateCorutineFrame()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(CathodeRenderer), PostProcessEvent.AfterStack, "Custom/Cathode - Analogue Video", true)]
public class Cathode : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Range(1f, 16f)]
	public IntParameter downscale = new IntParameter
	{
		value = 1
	};

	[Range(1f, 16f)]
	public IntParameter downscaleTemporal = new IntParameter
	{
		value = 1
	};

	[Range(0f, 3f)]
	public FloatParameter horizontalBlur = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 3f)]
	public FloatParameter verticalBlur = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 5f)]
	public FloatParameter chromaSubsampling = new FloatParameter
	{
		value = 1.7f
	};

	[Range(0f, 5f)]
	public FloatParameter sharpen = new FloatParameter
	{
		value = 1.2f
	};

	[Range(0f, 5f)]
	public FloatParameter sharpenRadius = new FloatParameter
	{
		value = 1.2f
	};

	[Range(0f, 0.5f)]
	public FloatParameter colorNoise = new FloatParameter
	{
		value = 0.05f
	};

	[Range(0f, 5f)]
	public FloatParameter restlessFoot = new FloatParameter
	{
		value = 0.2f
	};

	[Range(0f, 0.1f)]
	public FloatParameter footAmplitude = new FloatParameter
	{
		value = 0.02f
	};

	[Range(0f, 3f)]
	public FloatParameter chromaIntensity = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter chromaInstability = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 0.1f)]
	public FloatParameter chromaOffset = new FloatParameter
	{
		value = 0.02f
	};

	[Range(-2f, 2f)]
	public FloatParameter responseCurve = new FloatParameter
	{
		value = 0f
	};

	[Range(-1f, 1f)]
	public FloatParameter saturation = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter cometTrailing = new FloatParameter
	{
		value = 0.3f
	};

	[Range(0f, 1f)]
	public FloatParameter burnIn = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter tapeDust = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 2f)]
	public FloatParameter wobble = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public Vector2Parameter blackWhiteLevels = new Vector2Parameter
	{
		value = new Vector2(0f, 1f)
	};

	[Range(0f, 1f)]
	public Vector2Parameter dynamicRange = new Vector2Parameter
	{
		value = new Vector2(0f, 1f)
	};

	[Range(-1f, 1f)]
	public FloatParameter whiteBallance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class CathodeRenderer : PostProcessEffectRenderer<Cathode>
{
	private Texture2D noiseTex;

	private RenderTexture temporalRT;

	private Shader grayShader = Shader.Find("Hidden/Shader/Gray");

	private Shader primaryShader = Shader.Find("Hidden/Shader/PrimaryTransform");

	private Shader tvShader = Shader.Find("Hidden/Shader/TV");

	private Shader postTVShader = Shader.Find("Hidden/Shader/PostTV");

	private Shader trailShader = Shader.Find("Hidden/Shader/Trail");

	private readonly int _CathodeRT1 = Shader.PropertyToID("CathodeRT1");

	private readonly int _CathodeRT2 = Shader.PropertyToID("CathodeRT2");

	private readonly int _Intensity = Shader.PropertyToID("_Intensity");

	private readonly int _SizeX = Shader.PropertyToID("_SizeX");

	private readonly int _SizeY = Shader.PropertyToID("_SizeY");

	private readonly int _ChromaSubsampling = Shader.PropertyToID("_ChromaSubsampling");

	private readonly int _Sharpen = Shader.PropertyToID("_Sharpen");

	private readonly int _SharpenRadius = Shader.PropertyToID("_SharpenRadius");

	private readonly int _ColorNoise = Shader.PropertyToID("_ColorNoise");

	private readonly int _RestlessFoot = Shader.PropertyToID("_RestlessFoot");

	private readonly int _FootAmplitude = Shader.PropertyToID("_FootAmplitude");

	private readonly int _ChromaOffset = Shader.PropertyToID("_ChromaOffset");

	private readonly int _ChromaIntensity = Shader.PropertyToID("_ChromaIntensity");

	private readonly int _ChromaInstability = Shader.PropertyToID("_ChromaInstability");

	private readonly int _BurnIn = Shader.PropertyToID("_BurnIn");

	private readonly int _TapeDust = Shader.PropertyToID("_TapeDust");

	private readonly int _TrailTex = Shader.PropertyToID("_TrailTex");

	private readonly int _NoiseTex = Shader.PropertyToID("_NoiseTex");

	private readonly int _Gamma = Shader.PropertyToID("_Gamma");

	private readonly int _ResponseCurve = Shader.PropertyToID("_ResponseCurve");

	private readonly int _Saturation = Shader.PropertyToID("_Saturation");

	private readonly int _Wobble = Shader.PropertyToID("_Wobble");

	private readonly int _Black = Shader.PropertyToID("_Black");

	private readonly int _White = Shader.PropertyToID("_White");

	private readonly int _DynamicRangeMin = Shader.PropertyToID("_DynamicRangeMin");

	private readonly int _DynamicRangeMax = Shader.PropertyToID("_DynamicRangeMax");

	private readonly int _ScreenWhiteBal = Shader.PropertyToID("_ScreenWhiteBal");

	private readonly int _Trailing = Shader.PropertyToID("_Trailing");

	public override void Init()
	{
		base.Init();
		grayShader = Shader.Find("Hidden/Shader/Gray");
		primaryShader = Shader.Find("Hidden/Shader/PrimaryTransform");
		tvShader = Shader.Find("Hidden/Shader/TV");
		postTVShader = Shader.Find("Hidden/Shader/PostTV");
		trailShader = Shader.Find("Hidden/Shader/Trail");
		noiseTex = Resources.Load<Texture2D>("Noise");
	}

	public override void Release()
	{
		if ((Object)(object)noiseTex != (Object)null)
		{
			Resources.UnloadAsset((Object)(object)noiseTex);
			noiseTex = null;
		}
		if ((Object)(object)temporalRT != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)temporalRT);
			temporalRT = null;
		}
		base.Release();
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Expected O, but got Unknown
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_081e: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0713: Unknown result type (might be due to invalid IL or missing references)
		//IL_0715: Unknown result type (might be due to invalid IL or missing references)
		//IL_071e: Unknown result type (might be due to invalid IL or missing references)
		//IL_072d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_0742: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_076b: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0795: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e4: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("CathodeAnalogueVideo");
		int num = context.width / (int)base.settings.downscaleTemporal;
		int num2 = context.height / (int)base.settings.downscaleTemporal;
		if ((Object)(object)temporalRT == (Object)null || ((Texture)temporalRT).width != num || ((Texture)temporalRT).height != num2)
		{
			if ((Object)(object)temporalRT != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)temporalRT);
			}
			temporalRT = new RenderTexture(num, num2, 0, (RenderTextureFormat)9);
		}
		if ((float)base.settings.intensity > 0f)
		{
			PropertySheet propertySheet = context.propertySheets.Get(grayShader);
			PropertySheet propertySheet2 = context.propertySheets.Get(primaryShader);
			PropertySheet propertySheet3 = context.propertySheets.Get(tvShader);
			PropertySheet propertySheet4 = context.propertySheets.Get(postTVShader);
			PropertySheet propertySheet5 = context.propertySheets.Get(trailShader);
			propertySheet.properties.Clear();
			propertySheet2.properties.Clear();
			propertySheet3.properties.Clear();
			propertySheet4.properties.Clear();
			propertySheet5.properties.Clear();
			propertySheet.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet.properties.SetFloat(_SizeX, (float)base.settings.horizontalBlur);
			propertySheet.properties.SetFloat(_SizeY, (float)base.settings.verticalBlur);
			propertySheet2.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaSubsampling, (float)base.settings.chromaSubsampling * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_Sharpen, (float)base.settings.sharpen * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_SharpenRadius, (float)base.settings.sharpenRadius * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ColorNoise, (float)base.settings.colorNoise * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_RestlessFoot, (float)base.settings.restlessFoot * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_FootAmplitude, (float)base.settings.footAmplitude * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaOffset, (float)base.settings.chromaOffset * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaIntensity, Mathf.Lerp(1f, (float)base.settings.chromaIntensity, (float)base.settings.intensity));
			propertySheet2.properties.SetFloat(_ChromaInstability, (float)base.settings.chromaInstability * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_BurnIn, (float)base.settings.burnIn * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_TapeDust, 1f - (float)base.settings.tapeDust * (float)base.settings.intensity);
			propertySheet2.properties.SetTexture(_TrailTex, (Texture)(object)temporalRT);
			propertySheet2.properties.SetTexture(_NoiseTex, (Texture)(object)noiseTex);
			propertySheet3.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet3.properties.SetFloat(_Gamma, 1f);
			propertySheet4.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_ResponseCurve, (float)base.settings.responseCurve * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_Saturation, Mathf.Lerp(1f, (float)base.settings.saturation, (float)base.settings.intensity));
			propertySheet4.properties.SetFloat(_Wobble, (float)base.settings.wobble * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_Black, base.settings.blackWhiteLevels.value.x * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_White, 1f - (1f - base.settings.blackWhiteLevels.value.y) * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_DynamicRangeMin, base.settings.dynamicRange.value.x * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_DynamicRangeMax, 1f - (1f - base.settings.dynamicRange.value.y) * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_ScreenWhiteBal, (float)base.settings.whiteBallance * (float)base.settings.intensity);
			propertySheet5.properties.SetFloat(_Trailing, 1f - (float)base.settings.cometTrailing * (float)base.settings.intensity);
			RenderTextureDescriptor val = default(RenderTextureDescriptor);
			((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)2;
			((RenderTextureDescriptor)(ref val)).width = context.width / (int)base.settings.downscale;
			((RenderTextureDescriptor)(ref val)).height = context.height / (int)base.settings.downscale;
			((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
			((RenderTextureDescriptor)(ref val)).colorFormat = (RenderTextureFormat)9;
			((RenderTextureDescriptor)(ref val)).useMipMap = true;
			((RenderTextureDescriptor)(ref val)).autoGenerateMips = true;
			((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
			RenderTextureDescriptor val2 = val;
			command.GetTemporaryRT(_CathodeRT1, val2, (FilterMode)2);
			command.GetTemporaryRT(_CathodeRT2, val2, (FilterMode)2);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(_CathodeRT1), propertySheet, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), RenderTargetIdentifier.op_Implicit(_CathodeRT2), propertySheet2, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), RenderTargetIdentifier.op_Implicit((Texture)(object)temporalRT), propertySheet5, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT2), RenderTargetIdentifier.op_Implicit(_CathodeRT1), propertySheet4, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), context.destination, propertySheet3, 0, clear: false, null);
			command.ReleaseTemporaryRT(_CathodeRT1);
			command.ReleaseTemporaryRT(_CathodeRT2);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		command.EndSample("CathodeAnalogueVideo");
	}
}


public class cui
{
	[ServerUserVar]
	public static void cui_test(Arg args)
	{
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", args.Connection), "[\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"parent\": \"Overlay\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Tiled\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"url\": \"http://files.facepunch.com/garry/2015/June/03/2015-06-03_12-19-17.jpg\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0 0\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"1 1\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"NeedsCursor\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"name\": \"buttonText\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"Do you want to press a button?\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":32,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleCenter\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0 0.5\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"1 0.9\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"Button88\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Button\",\r\n\t\t\t\t\t\t\t\t\t\"close\":\"TestPanel7766\",\r\n\t\t\t\t\t\t\t\t\t\"command\":\"cui.endtest\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"0.9 0.8 0.3 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Tiled\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0.3 0.15\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"0.7 0.2\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"parent\": \"Button88\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"YES\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":20,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleCenter\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIcon\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Simple\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -151838493,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.4 0.4\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.4 0.4\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIconSkinTest\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Simple\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -733625651,\r\n\t\t\t\t\t\t\t\t\t\"skinid\": 13035\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.6 0.6\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.6 0.6\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"UpdateLabelTest\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"This should go away once you update!\",\r\n\t\t\t\t\t\t\t\t\t\"font\":\"DroidSansMono.ttf\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":32,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleRight\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"SteamAvatar\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"steamid\": \"76561197960279927\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.8 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.8 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t]\r\n\t\t\t\t\t");
	}

	[ServerUserVar]
	public static void cui_test_update(Arg args)
	{
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", args.Connection), "[\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"url\": \"https://files.facepunch.com/paddy/20220405/zipline_01.jpg\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"buttonText\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"This text just got updated!\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIcon\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -2067472972,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"Button88\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Button\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"0.9 0.3 0.3 0.8\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"UpdateLabelTest\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"enabled\": false,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t]\r\n\t\t\t\t\t");
	}

	[ServerUserVar]
	public static void endtest(Arg args)
	{
		args.ReplyWith("Ending Test!");
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("DestroyUI", args.Connection), "TestPanel7766");
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
public class CoverageQueries : MonoBehaviour
{
	public class BufferSet
	{
		public int width;

		public int height;

		public Texture2D inputTexture;

		public RenderTexture resultTexture;

		public Color[] inputData = (Color[])(object)new Color[0];

		public Color32[] resultData = (Color32[])(object)new Color32[0];

		private Material coverageMat;

		private const int MaxAsyncGPUReadbackRequests = 10;

		private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

		public void Attach(Material coverageMat)
		{
			this.coverageMat = coverageMat;
		}

		public void Dispose(bool data = true)
		{
			if ((Object)(object)inputTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)inputTexture);
				inputTexture = null;
			}
			if ((Object)(object)resultTexture != (Object)null)
			{
				RenderTexture.active = null;
				resultTexture.Release();
				Object.DestroyImmediate((Object)(object)resultTexture);
				resultTexture = null;
			}
			if (data)
			{
				inputData = (Color[])(object)new Color[0];
				resultData = (Color32[])(object)new Color32[0];
			}
		}

		public bool CheckResize(int count)
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Expected O, but got Unknown
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
			{
				Dispose(data: false);
				width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
				height = Mathf.CeilToInt((float)count / (float)width);
				inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
				((Object)inputTexture).name = "_Input";
				((Texture)inputTexture).filterMode = (FilterMode)0;
				((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
				resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
				((Object)resultTexture).name = "_Result";
				((Texture)resultTexture).filterMode = (FilterMode)0;
				((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				int num = resultData.Length;
				int num2 = width * height;
				Array.Resize(ref inputData, num2);
				Array.Resize(ref resultData, num2);
				Color32 val = default(Color32);
				((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
				for (int i = num; i < num2; i++)
				{
					resultData[i] = val;
				}
				return true;
			}
			return false;
		}

		public void UploadData()
		{
			if (inputData.Length != 0)
			{
				inputTexture.SetPixels(inputData);
				inputTexture.Apply();
			}
		}

		public void Dispatch(int count)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			if (inputData.Length != 0)
			{
				RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
				RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
				coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
				Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
				Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
			}
		}

		public void IssueRead()
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (asyncRequests.Count < 10)
			{
				asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
			}
		}

		public void GetResults()
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (resultData.Length == 0)
			{
				return;
			}
			while (asyncRequests.Count > 0)
			{
				AsyncGPUReadbackRequest val = asyncRequests.Peek();
				if (((AsyncGPUReadbackRequest)(ref val)).hasError)
				{
					asyncRequests.Dequeue();
					continue;
				}
				if (((AsyncGPUReadbackRequest)(ref val)).done)
				{
					NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
					for (int i = 0; i < data.Length; i++)
					{
						resultData[i] = data[i];
					}
					asyncRequests.Dequeue();
					continue;
				}
				break;
			}
		}
	}

	public enum RadiusSpace
	{
		ScreenNormalized,
		World
	}

	public class Query
	{
		public struct Input
		{
			public Vector3 position;

			public RadiusSpace radiusSpace;

			public float radius;

			public int sampleCount;

			public float smoothingSpeed;
		}

		public struct Internal
		{
			public int id;

			public void Reset()
			{
				id = -1;
			}
		}

		public struct Result
		{
			public int passed;

			public float coverage;

			public float smoothCoverage;

			public float weightedCoverage;

			public float weightedSmoothCoverage;

			public bool originOccluded;

			public int frame;

			public float originVisibility;

			public float originSmoothVisibility;

			public void Reset()
			{
				passed = 0;
				coverage = 0f;
				smoothCoverage = 0f;
				weightedCoverage = 0f;
				weightedSmoothCoverage = 0f;
				originOccluded = true;
				frame = -1;
				originVisibility = 0f;
				originSmoothVisibility = 0f;
			}
		}

		public Input input;

		public Internal intern;

		public Result result;

		public bool IsRegistered => intern.id >= 0;
	}

	public float depthBias = -0.1f;

	public bool debug;
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public int width;

	public int height;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private Material coverageMat;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public void Attach(Material coverageMat)
	{
		this.coverageMat = coverageMat;
	}

	public void Dispose(bool data = true)
	{
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
		}
	}

	public bool CheckResize(int count)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Expected O, but got Unknown
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
			height = Mathf.CeilToInt((float)count / (float)width);
			inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
			((Object)inputTexture).name = "_Input";
			((Texture)inputTexture).filterMode = (FilterMode)0;
			((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
			resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
			((Object)resultTexture).name = "_Result";
			((Texture)resultTexture).filterMode = (FilterMode)0;
			((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
			resultTexture.useMipMap = false;
			resultTexture.Create();
			int num = resultData.Length;
			int num2 = width * height;
			Array.Resize(ref inputData, num2);
			Array.Resize(ref resultData, num2);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
			for (int i = num; i < num2; i++)
			{
				resultData[i] = val;
			}
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (inputData.Length != 0)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
	}

	public void Dispatch(int count)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (inputData.Length != 0)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
	}

	public void IssueRead()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (asyncRequests.Count < 10)
		{
			asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
		}
	}

	public void GetResults()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (resultData.Length == 0)
		{
			return;
		}
		while (asyncRequests.Count > 0)
		{
			AsyncGPUReadbackRequest val = asyncRequests.Peek();
			if (((AsyncGPUReadbackRequest)(ref val)).hasError)
			{
				asyncRequests.Dequeue();
				continue;
			}
			if (((AsyncGPUReadbackRequest)(ref val)).done)
			{
				NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
				for (int i = 0; i < data.Length; i++)
				{
					resultData[i] = data[i];
				}
				asyncRequests.Dequeue();
				continue;
			}
			break;
		}
	}
}


public enum RadiusSpace
{
	ScreenNormalized,
	World
}


using UnityEngine;

public class Query
{
	public struct Input
	{
		public Vector3 position;

		public RadiusSpace radiusSpace;

		public float radius;

		public int sampleCount;

		public float smoothingSpeed;
	}

	public struct Internal
	{
		public int id;

		public void Reset()
		{
			id = -1;
		}
	}

	public struct Result
	{
		public int passed;

		public float coverage;

		public float smoothCoverage;

		public float weightedCoverage;

		public float weightedSmoothCoverage;

		public bool originOccluded;

		public int frame;

		public float originVisibility;

		public float originSmoothVisibility;

		public void Reset()
		{
			passed = 0;
			coverage = 0f;
			smoothCoverage = 0f;
			weightedCoverage = 0f;
			weightedSmoothCoverage = 0f;
			originOccluded = true;
			frame = -1;
			originVisibility = 0f;
			originSmoothVisibility = 0f;
		}
	}

	public Input input;

	public Internal intern;

	public Result result;

	public bool IsRegistered => intern.id >= 0;
}


using UnityEngine;

public struct Input
{
	public Vector3 position;

	public RadiusSpace radiusSpace;

	public float radius;

	public int sampleCount;

	public float smoothingSpeed;
}


public struct Internal
{
	public int id;

	public void Reset()
	{
		id = -1;
	}
}


public struct Result
{
	public int passed;

	public float coverage;

	public float smoothCoverage;

	public float weightedCoverage;

	public float weightedSmoothCoverage;

	public bool originOccluded;

	public int frame;

	public float originVisibility;

	public float originSmoothVisibility;

	public void Reset()
	{
		passed = 0;
		coverage = 0f;
		smoothCoverage = 0f;
		weightedCoverage = 0f;
		weightedSmoothCoverage = 0f;
		originOccluded = true;
		frame = -1;
		originVisibility = 0f;
		originSmoothVisibility = 0f;
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class ERVegetationStudio : ScriptableObject
{
	public static bool VegetationStudio()
	{
		return false;
	}

	public static bool VegetationStudioPro()
	{
		return false;
	}

	public static void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateHeightmap(Bounds bounds)
	{
	}

	public static void RemoveVegetationMaskLine(GameObject go)
	{
	}

	public static void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise)
	{
	}

	public static void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise)
	{
	}

	public static void RemoveBiomeArea(GameObject go)
	{
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class runtimeScript : MonoBehaviour
{
	public ERRoadNetwork roadNetwork;

	public ERRoad road;

	public GameObject go;

	public int currentElement;

	public float distance;

	public float speed = 5f;

	private void Start()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Please read the comments at the top of the runtime script (/Assets/EasyRoads3D/Scripts/runtimeScript) before using the runtime API!");
		roadNetwork = new ERRoadNetwork();
		ERRoadType val = new ERRoadType();
		val.roadWidth = 6f;
		ref Material roadMaterial = ref val.roadMaterial;
		Object obj = Resources.Load("Materials/roads/road material");
		roadMaterial = (Material)(object)((obj is Material) ? obj : null);
		val.layer = 1;
		val.tag = "Untagged";
		Vector3[] array = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(200f, 5f, 200f),
			new Vector3(250f, 5f, 200f),
			new Vector3(250f, 5f, 250f),
			new Vector3(300f, 5f, 250f)
		};
		road = roadNetwork.CreateRoad("road 1", val, array);
		road.AddMarker(new Vector3(300f, 5f, 300f));
		road.InsertMarker(new Vector3(275f, 5f, 235f));
		road.DeleteMarker(2);
		roadNetwork.BuildRoadNetwork();
		go = GameObject.CreatePrimitive((PrimitiveType)3);
	}

	private void Update()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (roadNetwork != null)
		{
			float num = Time.deltaTime * speed;
			distance += num;
			Vector3 position = road.GetPosition(distance, ref currentElement);
			position.y += 1f;
			go.transform.position = position;
			go.transform.forward = road.GetLookatSmooth(distance, currentElement);
		}
	}

	private void OnDestroy()
	{
		if (roadNetwork != null && roadNetwork.isInBuildMode)
		{
			roadNetwork.RestoreRoadNetwork();
			Debug.Log((object)"Restore Road Network");
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_RMCharacterController : FSimpleFitter
{
	protected FAnimationClips clips;

	protected Animator animator;

	private float gravity;

	protected override void Start()
	{
		base.Start();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Walk");
		clips.AddClip("RotateL");
		clips.AddClip("RotateR");
	}

	public void Update()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)optionalCharContr))
		{
			if (optionalCharContr.isGrounded)
			{
				gravity = 0f;
			}
			else
			{
				gravity += Time.deltaTime * 10f;
				optionalCharContr.Move(Vector3.down * gravity * Time.deltaTime);
			}
		}
		if (Input.GetKey((KeyCode)97))
		{
			clips.CrossFade("RotateL");
		}
		else if (Input.GetKey((KeyCode)100))
		{
			clips.CrossFade("RotateR");
		}
		else if (Input.GetKey((KeyCode)119))
		{
			clips.CrossFade("Walk");
		}
		else
		{
			clips.CrossFade("Idle");
		}
	}
}


using System;
using UnityEngine;

public static class FEasing
{
	public enum EFease
	{
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInOutElastic,
		EaseInElastic,
		EaseOutElastic,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		Linear
	}

	public delegate float Function(float s, float e, float v, float extraParameter = 1f);

	public static float EaseInCubic(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * value * value * value + start;
	}

	public static float EaseOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	public static float EaseInOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	public static float EaseOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 * 0.25f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return num3 * Mathf.Pow(2f, -10f * value * rangeMul) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + end + start;
	}

	public static float EaseInElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return 0f - num3 * Mathf.Pow(2f, 10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + start;
	}

	public static float EaseInOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		if (value < 1f)
		{
			return -0.5f * (num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2)) + start;
		}
		return num3 * Mathf.Pow(2f, -10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) * 0.5f + end + start;
	}

	public static float EaseInExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	public static float EaseOutExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	public static float EaseInOutExpo(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	public static float Linear(float start, float end, float value, float ignore = 1f)
	{
		return Mathf.Lerp(start, end, value);
	}

	public static Function GetEasingFunction(EFease easingFunction)
	{
		return easingFunction switch
		{
			EFease.EaseInCubic => EaseInCubic, 
			EFease.EaseOutCubic => EaseOutCubic, 
			EFease.EaseInOutCubic => EaseInOutCubic, 
			EFease.EaseInElastic => EaseInElastic, 
			EFease.EaseOutElastic => EaseOutElastic, 
			EFease.EaseInOutElastic => EaseInOutElastic, 
			EFease.EaseInExpo => EaseInExpo, 
			EFease.EaseOutExpo => EaseOutExpo, 
			EFease.EaseInOutExpo => EaseInOutExpo, 
			EFease.Linear => Linear, 
			_ => null, 
		};
	}
}


public enum EFease
{
	EaseInCubic,
	EaseOutCubic,
	EaseInOutCubic,
	EaseInOutElastic,
	EaseInElastic,
	EaseOutElastic,
	EaseInExpo,
	EaseOutExpo,
	EaseInOutExpo,
	Linear
}


public delegate float Function(float s, float e, float v, float extraParameter = 1f);


using UnityEngine;

public class FHierarchyIcons
{
	static FHierarchyIcons()
	{
	}

	private static void EvaluateIcons(int instanceId, Rect selectionRect)
	{
	}

	private static void DrawIcon(string texName, Rect rect)
	{
	}

	private static Texture2D GetTex(string name)
	{
		return null;
	}
}


public interface IFHierarchyIcon
{
	string EditorIconPath { get; }
}


using System;
using UnityEngine;

public static class FSceneIcons
{
	public static void SetGizmoIconEnabled(MonoBehaviour beh, bool on)
	{
		if (!((Object)(object)beh == (Object)null))
		{
			SetGizmoIconEnabled(((object)beh).GetType(), on);
		}
	}

	public static void SetGizmoIconEnabled(Type type, bool on)
	{
	}
}


using UnityEngine;

public class FPD_FixedCurveWindowAttribute : PropertyAttribute
{
	public float StartTime;

	public float EndTime;

	public float StartValue;

	public float EndValue;

	public Color Color;

	public FPD_FixedCurveWindowAttribute(float startTime = 0f, float startValue = 0f, float endTime = 1f, float endValue = 1f, float r = 0f, float g = 1f, float b = 1f, float a = 1f)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		StartTime = startTime;
		StartValue = startValue;
		EndTime = endTime;
		EndValue = endValue;
		Color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_FoldableAttribute : PropertyAttribute
{
	public string FoldVariable;

	public FPD_FoldableAttribute(string boolFoldVariable)
	{
		FoldVariable = boolFoldVariable;
	}
}


using UnityEngine;

public class FPD_HeaderAttribute : PropertyAttribute
{
	public string HeaderText;

	public float UpperPadding;

	public float BottomPadding;

	public float Height;

	public FPD_HeaderAttribute(string headerText, float upperPadding = 6f, float bottomPadding = 4f, int addHeight = 2)
	{
		HeaderText = headerText;
		UpperPadding = upperPadding;
		BottomPadding = bottomPadding;
		Height = addHeight;
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, Inherited = true)]
public class FPD_HideOnBoolAttribute : PropertyAttribute
{
	public string BoolVarName = "";

	public bool HideInInspector;

	public FPD_HideOnBoolAttribute(string boolVariableName)
	{
		BoolVarName = boolVariableName;
		HideInInspector = false;
	}

	public FPD_HideOnBoolAttribute(string conditionalSourceField, bool hideInInspector)
	{
		BoolVarName = conditionalSourceField;
		HideInInspector = hideInInspector;
	}
}


using UnityEngine;

public class FPD_LayersAttribute : PropertyAttribute
{
}


using UnityEngine;

public class FPD_MinMaxSliderAttribute : PropertyAttribute
{
	public float MinValue = -60f;

	public float MaxValue = 60f;

	public FPD_MinMaxSliderAttribute(int min, int max)
	{
		MinValue = min;
		MaxValue = max;
	}
}


using UnityEngine;

public class FPD_OverridableFloatAttribute : PropertyAttribute
{
	public string BoolVarName;

	public string TargetVarName;

	public int LabelWidth;

	public FPD_OverridableFloatAttribute(string boolVariableName, string targetVariableName, int labelWidth = 90)
	{
		BoolVarName = boolVariableName;
		TargetVarName = targetVariableName;
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class BackgroundColorAttribute : PropertyAttribute
{
	public float r;

	public float g;

	public float b;

	public float a;

	public Color Color => new Color(r, g, b, a);

	public BackgroundColorAttribute()
	{
		r = (g = (b = (a = 1f)));
	}

	public BackgroundColorAttribute(float aR, float aG, float aB, float aA)
	{
		r = aR;
		g = aG;
		b = aB;
		a = aA;
	}
}


using UnityEngine;

public class FPD_WidthAttribute : PropertyAttribute
{
	public float LabelWidth;

	public FPD_WidthAttribute(int labelWidth)
	{
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class FPD_IndentAttribute : PropertyAttribute
{
	public int IndentCount = 1;

	public int LabelsWidth;

	public int SpaceAfter;

	public FPD_IndentAttribute(int indent = 1, int labelsWidth = 0, int spaceAfter = 0)
	{
		IndentCount = indent;
		LabelsWidth = labelsWidth;
		SpaceAfter = spaceAfter;
	}
}


using UnityEngine;

public class FPD_HorizontalLineAttribute : PropertyAttribute
{
	public Color color;

	public FPD_HorizontalLineAttribute(float r = 0.55f, float g = 0.55f, float b = 0.55f, float a = 0.7f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_PercentageAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly string Suffix;

	public readonly bool from0to100;

	public readonly bool editableValue;

	public readonly bool basic;

	public FPD_PercentageAttribute(float min, float max, bool goOver100Perc = false, bool editable = true, string suffix = "%", bool basicFromTo = false)
	{
		Min = min;
		Max = max;
		from0to100 = !goOver100Perc;
		editableValue = editable;
		Suffix = suffix;
		basic = basicFromTo;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_SuffixAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly SuffixMode Mode;

	public readonly string Suffix;

	public readonly bool editableValue;

	public readonly int widerField;

	public FPD_SuffixAttribute(float min, float max, SuffixMode mode = SuffixMode.From0to100, string suffix = "%", bool editable = true, int wider = 0)
	{
		Min = min;
		Max = max;
		Mode = mode;
		Suffix = suffix;
		editableValue = editable;
		widerField = wider;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_TabAttribute : PropertyAttribute
{
	public string HeaderText;

	public float R;

	public float G;

	public float B;

	public string IconContent;

	public string ResourcesIconPath;

	public int IconSize;

	public string FoldVariable;

	public FPD_TabAttribute(string headerText, float r = 0.5f, float g = 0.5f, float b = 1f, string iconContent = "", string resourcesIconPath = "", int iconSize = 24, string foldVariable = "")
	{
		HeaderText = headerText;
		R = r;
		G = g;
		B = b;
		IconContent = iconContent;
		ResourcesIconPath = resourcesIconPath;
		IconSize = iconSize;
		FoldVariable = foldVariable;
	}
}


using UnityEngine;

[AddComponentMenu("Image Effects/FXAA")]
public class FXAA : FXAAPostEffectsBase, IImageEffect
{
	public Shader shader;

	private Material mat;

	private void CreateMaterials()
	{
		if ((Object)(object)mat == (Object)null)
		{
			mat = CheckShaderAndCreateMaterial(shader, mat);
		}
	}

	private void Start()
	{
		CreateMaterials();
		CheckSupport(needDepth: false);
	}

	public bool IsActive()
	{
		return ((Behaviour)this).enabled;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		CreateMaterials();
		float num = 1f / (float)Screen.width;
		float num2 = 1f / (float)Screen.height;
		mat.SetVector("_rcpFrame", new Vector4(num, num2, 0f, 0f));
		mat.SetVector("_rcpFrameOpt", new Vector4(num * 2f, num2 * 2f, num * 0.5f, num2 * 0.5f));
		Graphics.Blit((Texture)(object)source, destination, mat);
	}
}


using UnityEngine;

public class FXAAPostEffectsBase : MonoBehaviour
{
	protected bool supportHDRTextures = true;

	protected bool isSupported = true;

	public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			((Behaviour)this).enabled = false;
			return null;
		}
		if (s.isSupported && Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			NotSupported();
			Debug.LogError((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not supported on this platform!"));
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private Material CreateMaterial(Shader s, Material m2Create)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			return null;
		}
		if (Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s && s.isSupported)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private void OnEnable()
	{
		isSupported = true;
	}

	private bool CheckSupport()
	{
		return CheckSupport(needDepth: false);
	}

	private bool CheckResources()
	{
		Debug.LogWarning((object)("CheckResources () for " + ((object)this).ToString() + " should be overwritten."));
		return isSupported;
	}

	private void Start()
	{
		CheckResources();
	}

	public bool CheckSupport(bool needDepth)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		isSupported = true;
		supportHDRTextures = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2);
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			NotSupported();
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			NotSupported();
			return false;
		}
		if (needDepth)
		{
			Camera component = ((Component)this).GetComponent<Camera>();
			component.depthTextureMode = (DepthTextureMode)(component.depthTextureMode | 1);
		}
		return true;
	}

	private bool CheckSupport(bool needDepth, bool needHdr)
	{
		if (!CheckSupport(needDepth))
		{
			return false;
		}
		if (needHdr && !supportHDRTextures)
		{
			NotSupported();
			return false;
		}
		return true;
	}

	private void ReportAutoDisable()
	{
		Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it's not supported on the current platform."));
	}

	private bool CheckShader(Shader s)
	{
		Debug.Log((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package."));
		if (!s.isSupported)
		{
			NotSupported();
			return false;
		}
		return false;
	}

	private void NotSupported()
	{
		((Behaviour)this).enabled = false;
		isSupported = false;
	}

	private void DrawBorder(RenderTexture dest, Material material)
	{
		RenderTexture.active = dest;
		bool flag = true;
		GL.PushMatrix();
		GL.LoadOrtho();
		for (int i = 0; i < material.passCount; i++)
		{
			material.SetPass(i);
			float num;
			float num2;
			if (flag)
			{
				num = 1f;
				num2 = 0f;
			}
			else
			{
				num = 0f;
				num2 = 1f;
			}
			float num3 = 0f + 1f / ((float)((Texture)dest).width * 1f);
			float num4 = 0f;
			float num5 = 1f;
			GL.Begin(7);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			float num6 = 1f - 1f / ((float)((Texture)dest).width * 1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(num6, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(num6, num5, 0.1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 0f + 1f / ((float)((Texture)dest).height * 1f);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			num3 = 1f;
			num4 = 1f - 1f / ((float)((Texture)dest).height * 1f);
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			GL.End();
		}
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/Explosion_Bloom")]
[ImageEffectAllowedInSceneView]
[ExecuteInEditMode]
public class Explosion_Bloom : MonoBehaviour
{
	[Serializable]
	public struct Settings
	{
		[SerializeField]
		[Tooltip("Filters out pixels under this level of brightness.")]
		public float threshold;

		[SerializeField]
		[Range(0f, 1f)]
		[Tooltip("Makes transition between under/over-threshold gradual.")]
		public float softKnee;

		[SerializeField]
		[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
		[Range(1f, 7f)]
		public float radius;

		[Tooltip("Blend factor of the result image.")]
		[SerializeField]
		public float intensity;

		[SerializeField]
		[Tooltip("Controls filter quality and buffer resolution.")]
		public bool highQuality;

		[SerializeField]
		[Tooltip("Reduces flashing noise with an additional filter.")]
		public bool antiFlicker;

		public float thresholdGamma
		{
			get
			{
				return Mathf.Max(0f, threshold);
			}
			set
			{
				threshold = value;
			}
		}

		public float thresholdLinear
		{
			get
			{
				return Mathf.GammaToLinearSpace(thresholdGamma);
			}
			set
			{
				threshold = Mathf.LinearToGammaSpace(value);
			}
		}

		public static Settings defaultSettings
		{
			get
			{
				Settings result = default(Settings);
				result.threshold = 2f;
				result.softKnee = 0f;
				result.radius = 7f;
				result.intensity = 0.7f;
				result.highQuality = true;
				result.antiFlicker = true;
				return result;
			}
		}
	}

	[SerializeField]
	public Settings settings = Settings.defaultSettings;

	[SerializeField]
	[HideInInspector]
	private Shader m_Shader;

	private Material m_Material;

	private const int kMaxIterations = 16;

	private RenderTexture[] m_blurBuffer1 = (RenderTexture[])(object)new RenderTexture[16];

	private RenderTexture[] m_blurBuffer2 = (RenderTexture[])(object)new RenderTexture[16];

	private int m_Threshold;

	private int m_Curve;

	private int m_PrefilterOffs;

	private int m_SampleScale;

	private int m_Intensity;

	private int m_BaseTex;

	public Shader shader
	{
		get
		{
			if ((Object)(object)m_Shader == (Object)null)
			{
				m_Shader = Shader.Find("Hidden/KriptoFX/PostEffects/Explosion_Bloom");
			}
			return m_Shader;
		}
	}

	public Material material
	{
		get
		{
			if ((Object)(object)m_Material == (Object)null)
			{
				m_Material = CheckShaderAndCreateMaterial(shader);
			}
			return m_Material;
		}
	}

	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			Debug.LogWarningFormat("Missing shader for image effect {0}", new object[1] { effect });
			return false;
		}
		if (!SystemInfo.supportsImageEffects)
		{
			Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2))
		{
			Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = (HideFlags)52
		};
	}

	private void Awake()
	{
		m_Threshold = Shader.PropertyToID("_Threshold");
		m_Curve = Shader.PropertyToID("_Curve");
		m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
		m_SampleScale = Shader.PropertyToID("_SampleScale");
		m_Intensity = Shader.PropertyToID("_Intensity");
		m_BaseTex = Shader.PropertyToID("_BaseTex");
	}

	private void OnEnable()
	{
		if (!IsSupported(shader, needDepth: true, needHdr: false, (MonoBehaviour)(object)this))
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void OnDisable()
	{
		if ((Object)(object)m_Material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)m_Material);
		}
		m_Material = null;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		bool isMobilePlatform = Application.isMobilePlatform;
		int num = ((Texture)source).width;
		int num2 = ((Texture)source).height;
		if (!settings.highQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat val = (RenderTextureFormat)(isMobilePlatform ? 7 : 9);
		float num3 = Mathf.Log((float)num2, 2f) + settings.radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float thresholdLinear = settings.thresholdLinear;
		material.SetFloat(m_Threshold, thresholdLinear);
		float num6 = thresholdLinear * settings.softKnee + 1E-05f;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
		material.SetVector(m_Curve, Vector4.op_Implicit(val2));
		bool flag = !settings.highQuality && settings.antiFlicker;
		material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
		material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
		material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, val);
		Graphics.Blit((Texture)(object)source, temporary, material, settings.antiFlicker ? 1 : 0);
		RenderTexture val3 = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(((Texture)val3).width / 2, ((Texture)val3).height / 2, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
			val3 = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture val4 = m_blurBuffer1[num7];
			material.SetTexture(m_BaseTex, (Texture)(object)val4);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(((Texture)val4).width, ((Texture)val4).height, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
			val3 = m_blurBuffer2[num7];
		}
		int num8 = 7;
		num8 += (settings.highQuality ? 1 : 0);
		material.SetTexture(m_BaseTex, (Texture)(object)source);
		Graphics.Blit((Texture)(object)val3, destination, material, num8);
		for (int j = 0; j < 16; j++)
		{
			if ((Object)(object)m_blurBuffer1[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if ((Object)(object)m_blurBuffer2[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Settings
{
	[SerializeField]
	[Tooltip("Filters out pixels under this level of brightness.")]
	public float threshold;

	[SerializeField]
	[Range(0f, 1f)]
	[Tooltip("Makes transition between under/over-threshold gradual.")]
	public float softKnee;

	[SerializeField]
	[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
	[Range(1f, 7f)]
	public float radius;

	[Tooltip("Blend factor of the result image.")]
	[SerializeField]
	public float intensity;

	[SerializeField]
	[Tooltip("Controls filter quality and buffer resolution.")]
	public bool highQuality;

	[SerializeField]
	[Tooltip("Reduces flashing noise with an additional filter.")]
	public bool antiFlicker;

	public float thresholdGamma
	{
		get
		{
			return Mathf.Max(0f, threshold);
		}
		set
		{
			threshold = value;
		}
	}

	public float thresholdLinear
	{
		get
		{
			return Mathf.GammaToLinearSpace(thresholdGamma);
		}
		set
		{
			threshold = Mathf.LinearToGammaSpace(value);
		}
	}

	public static Settings defaultSettings
	{
		get
		{
			Settings result = default(Settings);
			result.threshold = 2f;
			result.softKnee = 0f;
			result.radius = 7f;
			result.intensity = 0.7f;
			result.highQuality = true;
			result.antiFlicker = true;
			return result;
		}
	}
}


using UnityEngine;

public class ExplosionDemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float reactivateTime = 4f;

	public Light Sun;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float sunIntensity;

	private float dpiScale;

	private void Start()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
		sunIntensity = Sun.intensity;
	}

	private void OnGUI()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT"))
		{
			ChangeCurrent(1);
		}
		sunIntensity = GUI.HorizontalSlider(new Rect(10f * dpiScale, 70f * dpiScale, 285f * dpiScale, 15f * dpiScale), sunIntensity, 0f, 0.6f);
		Sun.intensity = sunIntensity;
		GUI.Label(new Rect(300f * dpiScale, 70f * dpiScale, 30f * dpiScale, 30f * dpiScale), "SUN INTENSITY", guiStyleHeader);
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + ((Object)Prefabs[currentNomber]).name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
	}

	private void ChangeCurrent(int delta)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if ((Object)(object)currentInstance != (Object)null)
		{
			Object.Destroy((Object)(object)currentInstance);
		}
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
	}
}


using UnityEngine;

public class ExplosionDemoReactivator : MonoBehaviour
{
	public float TimeDelayToReactivate = 3f;

	private void Start()
	{
		((MonoBehaviour)this).InvokeRepeating("Reactivate", 0f, TimeDelayToReactivate);
	}

	private void Reactivate()
	{
		Transform[] componentsInChildren = ((Component)this).GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			((Component)obj).gameObject.SetActive(false);
			((Component)obj).gameObject.SetActive(true);
		}
	}
}


using UnityEngine;

public class ExplosionPlatformActivator : MonoBehaviour
{
	public GameObject Effect;

	public float TimeDelay;

	public float DefaultRepeatTime = 5f;

	public float NearRepeatTime = 3f;

	private float currentTime;

	private float currentRepeatTime;

	private bool canUpdate;

	private void Start()
	{
		currentRepeatTime = DefaultRepeatTime;
		((MonoBehaviour)this).Invoke("Init", TimeDelay);
	}

	private void Init()
	{
		canUpdate = true;
		Effect.SetActive(true);
	}

	private void Update()
	{
		if (canUpdate && !((Object)(object)Effect == (Object)null))
		{
			currentTime += Time.deltaTime;
			if (currentTime > currentRepeatTime)
			{
				currentTime = 0f;
				Effect.SetActive(false);
				Effect.SetActive(true);
			}
		}
	}

	private void OnTriggerEnter(Collider coll)
	{
		currentRepeatTime = NearRepeatTime;
	}

	private void OnTriggerExit(Collider other)
	{
		currentRepeatTime = DefaultRepeatTime;
	}
}


using UnityEngine;

public class ExplosionsFPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}


using UnityEngine;

public class ExplosionsBillboard : MonoBehaviour
{
	public Camera Camera;

	public bool Active = true;

	public bool AutoInitCamera = true;

	private GameObject myContainer;

	private Transform t;

	private Transform camT;

	private Transform contT;

	private void Awake()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (AutoInitCamera)
		{
			Camera = Camera.main;
			Active = true;
		}
		t = ((Component)this).transform;
		Vector3 localScale = ((Component)t.parent).transform.localScale;
		localScale.z = localScale.x;
		((Component)t.parent).transform.localScale = localScale;
		camT = ((Component)Camera).transform;
		Transform parent = t.parent;
		myContainer = new GameObject
		{
			name = "Billboard_" + ((Object)((Component)t).gameObject).name
		};
		contT = myContainer.transform;
		contT.position = t.position;
		t.parent = myContainer.transform;
		contT.parent = parent;
	}

	private void Update()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Active)
		{
			contT.LookAt(contT.position + camT.rotation * Vector3.back, camT.rotation * Vector3.up);
		}
	}
}


using UnityEngine;

public class ExplosionsDeactivateRendererByTime : MonoBehaviour
{
	public float TimeDelay = 1f;

	private Renderer rend;

	private void Awake()
	{
		rend = ((Component)this).GetComponent<Renderer>();
	}

	private void DeactivateRenderer()
	{
		rend.enabled = false;
	}

	private void OnEnable()
	{
		rend.enabled = true;
		((MonoBehaviour)this).Invoke("DeactivateRenderer", TimeDelay);
	}
}


using UnityEngine;

public class ExplosionsLightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = ((Component)this).GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class ExplosionsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class ExplosionsScaleCurves : MonoBehaviour
{
	public AnimationCurve ScaleCurveX = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveY = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveZ = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public Vector3 GraphTimeMultiplier = Vector3.one;

	public Vector3 GraphScaleMultiplier = Vector3.one;

	private float startTime;

	private Transform t;

	private float evalX;

	private float evalY;

	private float evalZ;

	private void Awake()
	{
		t = ((Component)this).transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		evalX = 0f;
		evalY = 0f;
		evalZ = 0f;
	}

	private void Update()
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (num <= GraphTimeMultiplier.x)
		{
			evalX = ScaleCurveX.Evaluate(num / GraphTimeMultiplier.x) * GraphScaleMultiplier.x;
		}
		if (num <= GraphTimeMultiplier.y)
		{
			evalY = ScaleCurveY.Evaluate(num / GraphTimeMultiplier.y) * GraphScaleMultiplier.y;
		}
		if (num <= GraphTimeMultiplier.z)
		{
			evalZ = ScaleCurveZ.Evaluate(num / GraphTimeMultiplier.z) * GraphScaleMultiplier.z;
		}
		t.localScale = new Vector3(evalX, evalY, evalZ);
	}
}


using UnityEngine;

public class ExplosionsShaderColorGradient : MonoBehaviour
{
	public string ShaderProperty = "_TintColor";

	public int MaterialID;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private Color oldColor;

	private void Start()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
		oldColor = matInstance.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color val = Color.Evaluate(num / TimeMultiplier);
			matInstance.SetColor(propertyID, val * oldColor);
		}
		if (num >= TimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderFloatCurves : MonoBehaviour
{
	public string ShaderProperty = "_BumpAmt";

	public int MaterialID;

	public AnimationCurve FloatPropertyCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphScaleMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private void Start()
	{
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatPropertyCurve.Evaluate(num / GraphTimeMultiplier) * GraphScaleMultiplier;
			matInstance.SetFloat(propertyID, num2);
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderQueue : MonoBehaviour
{
	public int AddQueue = 1;

	private Renderer rend;

	private void Start()
	{
		rend = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)rend != (Object)null)
		{
			Material sharedMaterial = rend.sharedMaterial;
			sharedMaterial.renderQueue += AddQueue;
		}
		else
		{
			((MonoBehaviour)this).Invoke("SetProjectorQueue", 0.1f);
		}
	}

	private void SetProjectorQueue()
	{
		Material material = ((Component)this).GetComponent<Projector>().material;
		material.renderQueue += AddQueue;
	}

	private void OnDisable()
	{
		if ((Object)(object)rend != (Object)null)
		{
			rend.sharedMaterial.renderQueue = -1;
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

internal class ExplosionsSpriteSheetAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public float AnimationFPS = 30f;

	public bool IsInterpolateFrames;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float animationLifeTime;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private float currentInterpolatedTime;

	private float animationStartTime;

	private bool animationStoped;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		animationStoped = false;
		animationLifeTime = (float)(TilesX * TilesY) / AnimationFPS;
		count = TilesY * TilesX;
		index = TilesX - 1;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		animationStartTime = Time.time;
		while (isVisible && (IsLoop || !animationStoped))
		{
			UpdateFrame();
			if (!IsLoop && animationStoped)
			{
				break;
			}
			float num = (Time.time - animationStartTime) / animationLifeTime;
			float num2 = FrameOverTime.Evaluate(Mathf.Clamp01(num));
			yield return (object)new WaitForSeconds(1f / (AnimationFPS * num2));
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateFrame()
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		if (count == allCount)
		{
			animationStartTime = Time.time;
			allCount = 0;
			animationStoped = true;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)TilesX - (float)(index / TilesX), 1f - (float)(index / TilesX) / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime = 0f;
		}
	}

	private void Update()
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime += Time.deltaTime;
			int num = index + 1;
			if (allCount == 0)
			{
				num = index;
			}
			Vector4 val = default(Vector4);
			((Vector4)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY, (float)num / (float)TilesX - (float)(num / TilesX), 1f - (float)(num / TilesX) / (float)TilesY);
			if ((Object)(object)currentRenderer != (Object)null)
			{
				instanceMaterial.SetVector("_MainTex_NextFrame", val);
				float num2 = (Time.time - animationStartTime) / animationLifeTime;
				float num3 = FrameOverTime.Evaluate(Mathf.Clamp01(num2));
				instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * AnimationFPS * num3));
			}
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using ConVar;
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Light))]
public class NGSS_Directional : MonoBehaviour
{
	public enum SAMPLER_COUNT
	{
		SAMPLERS_16,
		SAMPLERS_25,
		SAMPLERS_32,
		SAMPLERS_64
	}

	[Tooltip("Overall softness for both PCF and PCSS shadows.\nRecommended value: 0.01.")]
	[Range(0f, 0.02f)]
	public float PCSS_GLOBAL_SOFTNESS = 0.01f;

	[Tooltip("PCSS softness when shadows is close to caster.\nRecommended value: 0.05.")]
	[Range(0f, 1f)]
	public float PCSS_FILTER_DIR_MIN = 0.05f;

	[Tooltip("PCSS softness when shadows is far from caster.\nRecommended value: 0.25.\nIf too high can lead to visible artifacts when early bailout is enabled.")]
	[Range(0f, 0.5f)]
	public float PCSS_FILTER_DIR_MAX = 0.25f;

	[Tooltip("Amount of banding or noise. Example: 0.0 gives 100 % Banding and 10.0 gives 100 % Noise.")]
	[Range(0f, 10f)]
	public float BANDING_NOISE_AMOUNT = 1f;

	[Tooltip("Recommended values: Mobile = 16, Consoles = 25, Desktop Low = 32, Desktop High = 64")]
	public SAMPLER_COUNT SAMPLERS_COUNT;

	private void Update()
	{
		bool globalSettings = Graphics.shadowquality >= 2;
		SetGlobalSettings(globalSettings);
	}

	private void SetGlobalSettings(bool enabled)
	{
		if (enabled)
		{
			Shader.SetGlobalFloat("NGSS_PCSS_GLOBAL_SOFTNESS", PCSS_GLOBAL_SOFTNESS);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MIN", (PCSS_FILTER_DIR_MIN > PCSS_FILTER_DIR_MAX) ? PCSS_FILTER_DIR_MAX : PCSS_FILTER_DIR_MIN);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MAX", (PCSS_FILTER_DIR_MAX < PCSS_FILTER_DIR_MIN) ? PCSS_FILTER_DIR_MIN : PCSS_FILTER_DIR_MAX);
			Shader.SetGlobalFloat("NGSS_POISSON_SAMPLING_NOISE_DIR", BANDING_NOISE_AMOUNT);
		}
	}
}


public enum SAMPLER_COUNT
{
	SAMPLERS_16,
	SAMPLERS_25,
	SAMPLERS_32,
	SAMPLERS_64
}


using UnityEngine;

public struct OccludeeSphere
{
	public int id;

	public OccludeeState state;

	public OcclusionCulling.Sphere sphere;

	public bool IsRegistered => id >= 0;

	public void Invalidate()
	{
		id = -1;
		state = null;
		sphere = default(OcclusionCulling.Sphere);
	}

	public OccludeeSphere(int id)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		sphere = new OcclusionCulling.Sphere(Vector3.zero, 0f);
	}

	public OccludeeSphere(int id, OcclusionCulling.Sphere sphere)
	{
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		this.sphere = sphere;
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

public class OccludeeState : OcclusionCulling.SmartListValue
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
	public struct State
	{
		[FieldOffset(0)]
		public Vector4 sphereBounds;

		[FieldOffset(16)]
		public float minTimeVisible;

		[FieldOffset(20)]
		public float waitTime;

		[FieldOffset(24)]
		public uint waitFrame;

		[FieldOffset(28)]
		public byte isVisible;

		[FieldOffset(29)]
		public byte active;

		[FieldOffset(30)]
		public byte callback;

		[FieldOffset(31)]
		public byte pad1;

		public static State Unused = new State
		{
			active = 0
		};
	}

	public int slot;

	public bool isStatic;

	public int layer;

	public OcclusionCulling.OnVisibilityChanged onVisibilityChanged;

	public OcclusionCulling.Cell cell;

	public OcclusionCulling.SimpleList<State> states;

	public bool isVisible => states[slot].isVisible != 0;

	public OccludeeState Initialize(OcclusionCulling.SimpleList<State> states, OcclusionCulling.BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OcclusionCulling.OnVisibilityChanged onVisibilityChanged)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		states[slot] = new State
		{
			sphereBounds = sphereBounds,
			minTimeVisible = minTimeVisible,
			waitTime = (isVisible ? (Time.time + minTimeVisible) : 0f),
			waitFrame = (uint)(Time.frameCount + 1),
			isVisible = (byte)(isVisible ? 1 : 0),
			active = 1,
			callback = ((onVisibilityChanged != null) ? ((byte)1) : ((byte)0))
		};
		this.slot = slot;
		this.isStatic = isStatic;
		this.layer = layer;
		this.onVisibilityChanged = onVisibilityChanged;
		cell = null;
		this.states = states;
		return this;
	}

	public void Invalidate()
	{
		states[slot] = State.Unused;
		slot = -1;
		onVisibilityChanged = null;
		cell = null;
	}

	public void MakeVisible()
	{
		states.array[slot].waitTime = Time.time + states[slot].minTimeVisible;
		states.array[slot].isVisible = 1;
		if (onVisibilityChanged != null)
		{
			onVisibilityChanged(visible: true);
		}
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
public struct State
{
	[FieldOffset(0)]
	public Vector4 sphereBounds;

	[FieldOffset(16)]
	public float minTimeVisible;

	[FieldOffset(20)]
	public float waitTime;

	[FieldOffset(24)]
	public uint waitFrame;

	[FieldOffset(28)]
	public byte isVisible;

	[FieldOffset(29)]
	public byte active;

	[FieldOffset(30)]
	public byte callback;

	[FieldOffset(31)]
	public byte pad1;

	public static State Unused = new State
	{
		active = 0
	};
}


using UnityEngine;

public class Occludee : MonoBehaviour
{
	public float minTimeVisible = 0.1f;

	public bool isStatic = true;

	public bool autoRegister;

	public bool stickyGizmos;

	public OccludeeState state;

	protected int occludeeId = -1;

	protected Vector3 center;

	protected float radius;

	protected Renderer renderer;

	protected Collider collider;

	protected virtual void Awake()
	{
		renderer = ((Component)this).GetComponent<Renderer>();
		collider = ((Component)this).GetComponent<Collider>();
	}

	public void OnEnable()
	{
		if (autoRegister && (Object)(object)collider != (Object)null)
		{
			Register();
		}
	}

	public void OnDisable()
	{
		if (autoRegister && occludeeId >= 0)
		{
			Unregister();
		}
	}

	public void Register()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = collider.bounds;
		center = ((Bounds)(ref bounds)).center;
		bounds = collider.bounds;
		float x = ((Bounds)(ref bounds)).extents.x;
		bounds = collider.bounds;
		float num = Mathf.Max(x, ((Bounds)(ref bounds)).extents.y);
		bounds = collider.bounds;
		radius = Mathf.Max(num, ((Bounds)(ref bounds)).extents.z);
		occludeeId = OcclusionCulling.RegisterOccludee(center, radius, renderer.enabled, minTimeVisible, isStatic, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (occludeeId < 0)
		{
			Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
		}
		state = OcclusionCulling.GetStateById(occludeeId);
	}

	public void Unregister()
	{
		OcclusionCulling.UnregisterOccludee(occludeeId);
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		if ((Object)(object)renderer != (Object)null)
		{
			renderer.enabled = visible;
		}
	}
}


public class OcclusionCPUTest
{
}


