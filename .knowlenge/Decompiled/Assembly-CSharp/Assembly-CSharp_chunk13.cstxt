using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PathList
{
	public enum Side
	{
		Both,
		Left,
		Right,
		Any
	}

	public enum Placement
	{
		Center,
		Side
	}

	public enum Alignment
	{
		None,
		Neighbor,
		Forward,
		Inward
	}

	[Serializable]
	public class BasicObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Placement Placement;

		public bool AlignToNormal = true;

		public bool HeightToTerrain = true;

		public float Offset;
	}

	[Serializable]
	public class SideObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Side Side;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 25f;

		public float Offset = 2f;
	}

	[Serializable]
	public class PathObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 5f;

		public float Dithering = 5f;
	}

	[Serializable]
	public class BridgeObject
	{
		public string Folder;

		public float Distance = 10f;
	}

	public class MeshObject
	{
		public Vector3 Position;

		public Mesh[] Meshes;

		public MeshObject(Vector3 meshPivot, MeshData[] meshData)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0031: Expected O, but got Unknown
			Position = meshPivot;
			Meshes = (Mesh[])(object)new Mesh[meshData.Length];
			for (int i = 0; i < Meshes.Length; i++)
			{
				MeshData obj = meshData[i];
				Mesh[] meshes = Meshes;
				int num = i;
				Mesh val = new Mesh();
				Mesh val2 = val;
				meshes[num] = val;
				Mesh mesh = val2;
				obj.Apply(mesh);
			}
		}
	}

	private struct WeldVertex : IEquatable<WeldVertex>
	{
		private const float EPSILON = 0.001f;

		private const float INV_EPSILON = 999.99994f;

		public float x;

		public float y;

		public float z;

		public float alwaysUnderwater;

		public float topSurface;

		public override bool Equals(object other)
		{
			if (other is WeldVertex)
			{
				return Equals((WeldVertex)other);
			}
			return false;
		}

		public bool Equals(WeldVertex other)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
			{
				return topSurface == other.topSurface;
			}
			return false;
		}

		public override int GetHashCode()
		{
			int value = Mathf.RoundToInt(x * 999.99994f);
			int value2 = Mathf.RoundToInt(y * 999.99994f);
			int value3 = Mathf.RoundToInt(z * 999.99994f);
			return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
		}
	}

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rot180 = Quaternion.Euler(0f, 180f, 0f);

	private static Quaternion rot270 = Quaternion.Euler(0f, 270f, 0f);

	public const float EndWidthScale = 3f;

	public const float EndScaleDistance = 100f;

	public const float LengthWidthScale = 8f;

	public const float LengthDepthScale = 3f;

	public const float LengthScaleDistance = 1000f;

	public string Name;

	public PathInterpolator Path;

	public bool Spline;

	public bool Start;

	public bool End;

	public float Width;

	public float InnerPadding;

	public float OuterPadding;

	public float InnerFade;

	public float OuterFade;

	public float RandomScale;

	public float MeshOffset;

	public float TerrainOffset;

	public int Topology;

	public int Splat;

	public int Hierarchy;

	public PathFinder.Node ProcgenStartNode;

	public PathFinder.Node ProcgenEndNode;

	public const float StepSize = 1f;

	private static float[] placements = new float[3] { 0f, -1f, 1f };

	public PathList(string name, Vector3[] points)
	{
		Name = name;
		Path = new PathInterpolator(points);
	}

	private void SpawnObjectsNeighborAligned(ref uint seed, Prefab[] prefabs, List<Vector3> positions, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Count < 2)
		{
			return;
		}
		List<Prefab> list = Pool.Get<List<Prefab>>();
		for (int i = 0; i < positions.Count; i++)
		{
			int index = Mathf.Max(i - 1, 0);
			int index2 = Mathf.Min(i + 1, positions.Count - 1);
			Vector3 position = positions[i];
			Quaternion rotation = Quaternion.LookRotation(Vector3Ex.XZ3D(positions[index2] - positions[index]));
			SpawnObject(ref seed, prefabs, position, rotation, list, out var spawned, positions.Count, i, filter);
			if (spawned != null)
			{
				list.Add(spawned);
			}
		}
		Pool.FreeUnmanaged<Prefab>(ref list);
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Prefab random = prefabs.GetRandom(ref seed);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = random.Object.transform.localScale;
		random.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!random.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, random, pos, rot, scale);
		return true;
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, List<Prefab> previousSpawns, out Prefab spawned, int pathLength, int index, SpawnFilter filter = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		spawned = null;
		Prefab replacement = prefabs.GetRandom(ref seed);
		replacement.ApplySequenceReplacement(previousSpawns, ref replacement, prefabs, pathLength, index, position);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = replacement.Object.transform.localScale;
		replacement.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!replacement.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, replacement, pos, rot, scale);
		spawned = replacement;
		return true;
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		foreach (Prefab obj in prefabs)
		{
			Vector3 pos = position;
			Vector3 localScale = obj.Object.transform.localScale;
			if (!obj.ApplyTerrainAnchors(ref pos, rotation, localScale, filter))
			{
				return false;
			}
		}
		return true;
	}

	private void SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (SpawnObject(ref seed, prefabs, val3, rotation, filter))
				{
					break;
				}
			}
		}
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (CheckObjects(prefabs, val3, rotation, filter))
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SpawnSide(ref uint seed, SideObject obj)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Side side = obj.Side;
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float num = Width * 0.5f + obj.Offset;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		float[] array2 = new float[2]
		{
			0f - num,
			num
		};
		int num2 = 0;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num3 = distance * 0.25f;
		float num4 = distance * 0.5f;
		float num5 = Path.StartOffset + num4;
		float num6 = Path.Length - Path.EndOffset - num4;
		for (float num7 = num5; num7 <= num6; num7 += num3)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num7) : Path.GetPoint(num7));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num7);
			Vector3 val4 = rot90 * tangent;
			for (int i = 0; i < array2.Length; i++)
			{
				int num8 = (num2 + i) % array2.Length;
				if ((side == Side.Left && num8 != 0) || (side == Side.Right && num8 != 1))
				{
					continue;
				}
				float num9 = array2[num8];
				Vector3 val5 = val2;
				val5.x += val4.x * num9;
				val5.z += val4.z * num9;
				float normX = TerrainMeta.NormalizeX(val5.x);
				float normZ = TerrainMeta.NormalizeZ(val5.z);
				if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
				{
					continue;
				}
				if (density >= SeedRandom.Value(ref seed))
				{
					val5.y = heightMap.GetHeight(normX, normZ);
					if (obj.Alignment == Alignment.None)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(Vector3.zero), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Forward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Inward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9) * rot270, filter))
						{
							continue;
						}
					}
					else
					{
						list.Add(val5);
					}
				}
				num2 = num8;
				val = val2;
				if (side == Side.Any)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnAlong(ref uint seed, PathObject obj)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float dithering = obj.Dithering;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num = distance * 0.25f;
		float num2 = distance * 0.5f;
		float num3 = Path.StartOffset + num2;
		float num4 = Path.Length - Path.EndOffset - num2;
		for (float num5 = num3; num5 <= num4; num5 += num)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num5) : Path.GetPoint(num5));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num5);
			Vector3 val4 = rot90 * tangent;
			Vector3 val5 = val2;
			val5.x += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			val5.z += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			float normX = TerrainMeta.NormalizeX(val5.x);
			float normZ = TerrainMeta.NormalizeZ(val5.z);
			if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
			{
				continue;
			}
			if (density >= SeedRandom.Value(ref seed))
			{
				val5.y = heightMap.GetHeight(normX, normZ);
				if (obj.Alignment == Alignment.None)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.identity, filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Forward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent), filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Inward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(val4), filter))
					{
						continue;
					}
				}
				else
				{
					list.Add(val5);
				}
			}
			val = val2;
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnBridge(ref uint seed, BridgeObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 val = Path.GetEndPoint() - startPoint;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = val / magnitude;
		float num = magnitude / obj.Distance;
		int num2 = Mathf.RoundToInt(num);
		float num3 = 0.5f * (num - (float)num2);
		Vector3 val3 = obj.Distance * val2;
		Vector3 val4 = startPoint + (0.5f + num3) * val3;
		Quaternion rotation = Quaternion.LookRotation(val2);
		for (int i = 0; i < num2; i++)
		{
			float num4 = WaterLevel.GetWaterOrTerrainSurface(val4, waves: false, volumes: false) - 1f;
			if (val4.y > num4)
			{
				SpawnObject(ref seed, array, val4, rotation);
			}
			val4 += val3;
		}
	}

	public void SpawnStart(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (Start && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 startPoint = Path.GetStartPoint();
			Vector3 startTangent = Path.GetStartTangent();
			SpawnObject(ref seed, array, startPoint, startTangent, obj);
		}
	}

	public void SpawnEnd(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (End && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 endPoint = Path.GetEndPoint();
			Vector3 dir = -Path.GetEndTangent();
			SpawnObject(ref seed, array, endPoint, dir, obj);
		}
	}

	public void TrimStart(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!Start || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MinIndex + i];
			Vector3 dir = tangents[Path.MinIndex + i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MinIndex += i;
				break;
			}
		}
	}

	public void TrimEnd(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!End || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MaxIndex - i];
			Vector3 dir = -tangents[Path.MaxIndex - i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MaxIndex -= i;
				break;
			}
		}
	}

	public void TrimTopology(int topology)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] points = Path.Points;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 worldPos = points[Path.MinIndex + i];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos, topology))
			{
				Path.MinIndex += i;
				break;
			}
		}
		for (int j = 0; j < num; j++)
		{
			Vector3 worldPos2 = points[Path.MaxIndex - j];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos2, topology))
			{
				Path.MaxIndex -= j;
				break;
			}
		}
	}

	public void ResetTrims()
	{
		Path.MinIndex = Path.DefaultMinIndex;
		Path.MaxIndex = Path.DefaultMaxIndex;
	}

	public void AdjustTerrainHeight(float intensity = 1f, float fade = 1f, bool scaleWidthWithLength = false)
	{
		AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => fade, scaleWidthWithLength);
	}

	public void AdjustTerrainHeight(Func<float, float, float> intensity, Func<float, float, float> fade, bool scaleWidthWithLength = false)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		_ = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float outerFade = OuterFade;
		float innerFade = InnerFade;
		float terrainOffset = TerrainOffset;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 val3 = startPoint;
		Line prev_line = new Line(startPoint, startPoint + startTangent * num);
		Vector3 val4 = startPoint - val2 * (num2 + outerPadding + outerFade);
		Vector3 val5 = startPoint + val2 * (num2 + outerPadding + outerFade);
		Vector3 val6 = val3;
		Vector3 val7 = startTangent;
		Line cur_line = prev_line;
		Vector3 val8 = val4;
		Vector3 val9 = val5;
		float num3 = Path.Length + num;
		for (float d = 0f; d < num3; d += num)
		{
			Vector3 val10 = (Spline ? Path.GetPointCubicHermite(d + num) : Path.GetPoint(d + num));
			Vector3 tangent = Path.GetTangent(d + num);
			Line next_line = new Line(val10, val10 + tangent * num);
			float opacity = 1f;
			float radius = GetRadius(d, Path.Length, num2, randomScale, scaleWidthWithLength);
			float depth = GetDepth(d, Path.Length, terrainOffset, randomScale, scaleWidthWithLength);
			float offset01 = depth * TerrainMeta.OneOverSize.y;
			if (!Path.Circular)
			{
				float num4 = Vector3Ex.Magnitude2D(startPoint - val6);
				float num5 = Vector3Ex.Magnitude2D(endPoint - val6);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num4, num5));
			}
			val = Vector3Ex.XZ3D(val7);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			val8 = val6 - val2 * (radius + outerPadding + outerFade);
			val9 = val6 + val2 * (radius + outerPadding + outerFade);
			float yn = TerrainMeta.NormalizeY((val6.y + val3.y) * 0.5f);
			heightmap.ForEach(val4, val5, val8, val9, delegate(int x, int z)
			{
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0031: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_0054: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_0079: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_0088: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_01af: Unknown result type (might be due to invalid IL or missing references)
				float num6 = heightmap.Coordinate(x);
				float num7 = heightmap.Coordinate(z);
				Vector3 val11 = TerrainMeta.Denormalize(new Vector3(num6, yn, num7));
				Vector3 val12 = ((Line)(ref prev_line)).ClosestPoint2D(val11);
				Vector3 val13 = ((Line)(ref cur_line)).ClosestPoint2D(val11);
				Vector3 val14 = ((Line)(ref next_line)).ClosestPoint2D(val11);
				float num8 = Vector3Ex.Magnitude2D(val11 - val12);
				float num9 = Vector3Ex.Magnitude2D(val11 - val13);
				float num10 = Vector3Ex.Magnitude2D(val11 - val14);
				float num11 = num9;
				Vector3 val15 = val13;
				if (!(num9 <= num8) || !(num9 <= num10))
				{
					if (num8 <= num10)
					{
						num11 = num8;
						val15 = val12;
					}
					else
					{
						num11 = num10;
						val15 = val14;
					}
				}
				float num12 = Mathf.InverseLerp(radius + outerPadding + outerFade * fade(num6, num7), radius + outerPadding, num11);
				float num13 = intensity(num6, num7) * opacity * num12;
				if (num13 > 0f)
				{
					float num14 = (scaleWidthWithLength ? Mathf.Lerp(0.3f, 1f, d / 1000f) : 1f);
					float num15 = Mathf.InverseLerp(radius - innerPadding * num14, radius - innerPadding * num14 - innerFade * num14, num11);
					float num16 = TerrainMeta.NormalizeY(val15.y);
					float num17 = Mathf.SmoothStep(0f, offset01, num15);
					heightmap.SetHeight(x, z, num16 + num17, num13);
				}
			});
			val3 = val6;
			val4 = val8;
			val5 = val9;
			prev_line = cur_line;
			val6 = val10;
			val7 = tangent;
			cur_line = next_line;
		}
	}

	public void AdjustTerrainTexture(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Splat == 0)
		{
			return;
		}
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			splatmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = splatmap.Coordinate(x);
				float num8 = splatmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				float num10 = Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9);
				splatmap.SetSplat(x, z, Splat, num10 * opacity);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainWaterFlow(bool scaleWidthWithLength = false)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		TerrainWaterFlowMap flowMap = TerrainMeta.WaterFlowMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 dir = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(dir);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			dir = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(dir);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			flowMap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				float normX = flowMap.Coordinate(x);
				float normZ = flowMap.Coordinate(z);
				flowMap.SetFlowDirection(normX, normZ, dir);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainTopology(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Topology == 0)
		{
			return;
		}
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			topomap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = topomap.Coordinate(x);
				float num8 = topomap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				if (Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9) * opacity > 0.3f)
				{
					topomap.AddTopology(x, z, Topology);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustPlacementMap(float width)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		TerrainPlacementMap placementmap = TerrainMeta.PlacementMap;
		float num = 1f;
		float radius = width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * radius;
		Vector3 v2 = startPoint + val2 * radius;
		float num2 = Path.Length + num;
		for (float num3 = 0f; num3 < num2; num3 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num3) : Path.GetPoint(num3));
			startTangent = Path.GetTangent(num3);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * radius;
			Vector3 val5 = val3 + val2 * radius;
			float yn = TerrainMeta.NormalizeY(val3.y);
			placementmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num4 = placementmap.Coordinate(x);
				float num5 = placementmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num4, yn, num5));
				Vector3 val7 = ray.ClosestPoint(val6);
				if (Vector3Ex.Magnitude2D(val6 - val7) <= radius)
				{
					placementmap.SetBlocked(x, z);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public List<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, bool scaleWidthWithLength = false, bool topAligned = false, int roundVertices = 0)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		MeshData[] array2 = new MeshData[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
			array2[i] = new MeshData();
		}
		MeshData[] array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].AllocMinimal();
		}
		Bounds bounds = meshes[^1].bounds;
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		List<MeshObject> list = new List<MeshObject>();
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		_ = array[0].vertices.Length;
		_ = array[0].triangles.Length;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val12 = default(Vector3);
		for (int k = 0; k < num2; k += num3)
		{
			float distance = (float)k * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int l = 0; l < num3 && k + l < num2; l++)
			{
				float num5 = (float)(k + l) * num4;
				for (int m = 0; m < meshes.Length; m++)
				{
					MeshCache.Data data = array[m];
					MeshData meshData = array2[m];
					int count = meshData.vertices.Count;
					for (int n = 0; n < data.vertices.Length; n++)
					{
						Vector2 item = data.uv[n];
						Vector3 val2 = data.vertices[n];
						Vector3 val3 = data.normals[n];
						Vector4 val4 = data.tangents[n];
						float num6 = (val2.x - min.x) / size.x;
						float num7 = val2.y - min.y;
						if (topAligned)
						{
							num7 -= size.y;
						}
						float num8 = (val2.z - min.z) / size.z;
						float num9 = num5 + num8 * num4;
						Vector3 val5 = (Spline ? Path.GetPointCubicHermite(num9) : Path.GetPoint(num9));
						Vector3 tangent = Path.GetTangent(num9);
						Vector3 val6 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val6)).normalized;
						Vector3 val7 = rot90 * normalized;
						Vector3 val8 = Vector3.Cross(tangent, val7);
						Quaternion val9 = Quaternion.LookRotation(normalized, val8);
						float radius = GetRadius(num9, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val10 = val5 - val7 * radius;
						Vector3 val11 = val5 + val7 * radius;
						if (snapToTerrain)
						{
							val10.y = heightMap.GetHeight(val10);
							val11.y = heightMap.GetHeight(val11);
						}
						val10 += val8 * meshOffset;
						val11 += val8 * meshOffset;
						val2 = Vector3.Lerp(val10, val11, num6);
						if ((snapStartToTerrain && num9 < 0.1f) || (snapEndToTerrain && num9 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num7;
						}
						val2 -= val;
						val3 = val9 * val3;
						((Vector3)(ref val12))..ctor(val4.x, val4.y, val4.z);
						val12 = val9 * val12;
						((Vector4)(ref val4)).Set(val12.x, val12.y, val12.z, val4.w);
						if (normalSmoothing > 0f)
						{
							val3 = Vector3.Slerp(val3, Vector3.up, normalSmoothing);
						}
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData.vertices.Add(val2);
						meshData.normals.Add(val3);
						meshData.tangents.Add(val4);
						meshData.uv.Add(item);
					}
					for (int num10 = 0; num10 < data.triangles.Length; num10++)
					{
						int num11 = data.triangles[num10];
						meshData.triangles.Add(count + num11);
					}
				}
			}
			list.Add(new MeshObject(val, array2));
			array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				array3[j].Clear();
			}
		}
		array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].Free();
		}
		return list;
	}

	public List<MeshObject> CreateMeshRiverInterior(Mesh[] meshes, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, Bounds bounds, bool scaleWidthWithLength = false, int roundVertices = 0)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0571: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
		}
		MeshData meshData = new MeshData();
		meshData.vertices = Pool.Get<List<Vector3>>();
		meshData.triangles = Pool.Get<List<int>>();
		meshData.uv = Pool.Get<List<Vector2>>();
		MeshData meshData2 = new MeshData();
		meshData2.vertices = Pool.Get<List<Vector3>>();
		meshData2.triangles = Pool.Get<List<int>>();
		meshData2.uv = Pool.Get<List<Vector2>>();
		Dictionary<WeldVertex, int> dictionary = new Dictionary<WeldVertex, int>();
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		List<MeshObject> list = new List<MeshObject>();
		for (int j = 0; j < num2; j += num3)
		{
			float distance = (float)j * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int k = 0; k < num3 && j + k < num2; k++)
			{
				float num5 = (float)(j + k) * num4;
				bool flag = j == 0;
				bool flag2 = k == 0;
				bool flag3 = j == num2 - 1;
				bool flag4 = k == num3 - 1 || j + k == num2 - 1;
				int num6 = (flag2 ? 4 : 3);
				for (int l = 0; l < num6; l++)
				{
					int num7 = l;
					MeshCache.Data data = array[num7];
					MeshData meshData3 = meshData;
					int count = meshData3.vertices.Count;
					float num8 = ((num7 == 2 && !(flag4 && flag3)) ? 1f : ((!(num7 == 3 && flag2) || flag) ? 0f : 1f));
					float num9 = ((num7 == 0) ? 1f : 0f);
					for (int m = 0; m < data.vertices.Length; m++)
					{
						Vector3 val2 = data.vertices[m];
						float num10 = (val2.x - min.x) / size.x;
						float num11 = val2.y - min.y;
						float num12 = (val2.z - min.z) / size.z;
						float num13 = num5 + num12 * num4;
						Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num13) : Path.GetPoint(num13));
						Vector3 tangent = Path.GetTangent(num13);
						Vector3 val4 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val4)).normalized;
						Vector3 val5 = rot90 * normalized;
						Vector3 val6 = Vector3.Cross(tangent, val5);
						float radius = GetRadius(num13, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val7 = val3 - val5 * radius;
						Vector3 val8 = val3 + val5 * radius;
						if (snapToTerrain)
						{
							val7.y = heightMap.GetHeight(val7);
							val8.y = heightMap.GetHeight(val8);
						}
						val7 += val6 * meshOffset;
						val8 += val6 * meshOffset;
						val2 = Vector3.Lerp(val7, val8, num10);
						if ((snapStartToTerrain && num13 < 0.1f) || (snapEndToTerrain && num13 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num11;
						}
						val2 -= val;
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData3.vertices.Add(val2);
						meshData3.uv.Add(new Vector2(num8, num9));
					}
					for (int n = 0; n < data.triangles.Length; n++)
					{
						int num14 = data.triangles[n];
						meshData3.triangles.Add(count + num14);
					}
				}
			}
			for (int num15 = 0; num15 < meshData.triangles.Count; num15++)
			{
				int index = meshData.triangles[num15];
				Vector3 val9 = meshData.vertices[index];
				Vector2 item = meshData.uv[index];
				WeldVertex key = default(WeldVertex);
				key.x = val9.x;
				key.y = val9.y;
				key.z = val9.z;
				key.alwaysUnderwater = meshData.uv[index].x;
				key.topSurface = meshData.uv[index].y;
				if (!dictionary.TryGetValue(key, out var value))
				{
					value = meshData2.vertices.Count;
					dictionary.Add(key, value);
					meshData2.vertices.Add(val9);
					meshData2.uv.Add(item);
				}
				meshData2.triangles.Add(value);
			}
			list.Add(new MeshObject(val, new MeshData[1] { meshData2 }));
			meshData.Clear();
			meshData2.Clear();
			dictionary.Clear();
		}
		meshData.Free();
		meshData2.Free();
		return list;
	}

	public static float GetRadius(float distance, float length, float baseRadius, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = Mathf.Sqrt(Mathf.Max(0f, length - distance) / 100f);
			float num2 = ((length > 0f) ? Mathf.Lerp(3f, 1f, num) : 1f);
			float num3 = distance / 1000f;
			float num4 = Mathf.Lerp(1f, 8f, num3);
			baseRadius = baseRadius * num4 * num2;
		}
		return Mathf.Lerp(baseRadius, baseRadius * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}

	public static float GetDepth(float distance, float length, float baseDepth, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = distance / 1000f;
			float num2 = Mathf.Lerp(1f, 3f, num);
			baseDepth *= num2;
		}
		return Mathf.Lerp(baseDepth, baseDepth * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}
}


public enum Side
{
	Both,
	Left,
	Right,
	Any
}


public enum Placement
{
	Center,
	Side
}


public enum Alignment
{
	None,
	Neighbor,
	Forward,
	Inward
}


using System;

[Serializable]
public class BasicObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Placement Placement;

	public bool AlignToNormal = true;

	public bool HeightToTerrain = true;

	public float Offset;
}


using System;

[Serializable]
public class SideObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Side Side;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 25f;

	public float Offset = 2f;
}


using System;

[Serializable]
public class PathObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 5f;

	public float Dithering = 5f;
}


using System;

[Serializable]
public class BridgeObject
{
	public string Folder;

	public float Distance = 10f;
}


using UnityEngine;

public class MeshObject
{
	public Vector3 Position;

	public Mesh[] Meshes;

	public MeshObject(Vector3 meshPivot, MeshData[] meshData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Expected O, but got Unknown
		//IL_0031: Expected O, but got Unknown
		Position = meshPivot;
		Meshes = (Mesh[])(object)new Mesh[meshData.Length];
		for (int i = 0; i < Meshes.Length; i++)
		{
			MeshData obj = meshData[i];
			Mesh[] meshes = Meshes;
			int num = i;
			Mesh val = new Mesh();
			Mesh val2 = val;
			meshes[num] = val;
			Mesh mesh = val2;
			obj.Apply(mesh);
		}
	}
}


using System;
using UnityEngine;

private struct WeldVertex : IEquatable<WeldVertex>
{
	private const float EPSILON = 0.001f;

	private const float INV_EPSILON = 999.99994f;

	public float x;

	public float y;

	public float z;

	public float alwaysUnderwater;

	public float topSurface;

	public override bool Equals(object other)
	{
		if (other is WeldVertex)
		{
			return Equals((WeldVertex)other);
		}
		return false;
	}

	public bool Equals(WeldVertex other)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
		{
			return topSurface == other.topSurface;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int value = Mathf.RoundToInt(x * 999.99994f);
		int value2 = Mathf.RoundToInt(y * 999.99994f);
		int value3 = Mathf.RoundToInt(z * 999.99994f);
		return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
	}
}


using System;
using UnityEngine;

[Serializable]
public class SpawnFilter
{
	[InspectorFlags]
	public Enum SplatType = (Enum)(-1);

	[InspectorFlags]
	public Enum BiomeType = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAny = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAll;

	[InspectorFlags]
	public Enum TopologyNot;

	public bool Test(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetFactor(worldPos) > 0.5f;
	}

	public bool Test(float normX, float normZ)
	{
		return GetFactor(normX, normZ) > 0.5f;
	}

	public float GetFactor(Vector3 worldPos, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFactor(normX, normZ, checkPlacementMap, checkTopologyRadius);
	}

	public float GetFactor(float normX, float normZ, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected I4, but got Unknown
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected I4, but got Unknown
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected I4, but got Unknown
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected I4, but got Unknown
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected I4, but got Unknown
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return 0f;
		}
		if (checkPlacementMap && (Object)(object)TerrainMeta.PlacementMap != (Object)null && TerrainMeta.PlacementMap.GetBlocked(normX, normZ))
		{
			return 0f;
		}
		int num = (int)SplatType;
		int num2 = (int)BiomeType;
		int num3 = (int)TopologyAny;
		int num4 = (int)TopologyAll;
		int num5 = (int)TopologyNot;
		if (num3 == 0)
		{
			Debug.LogError((object)"Empty topology filter is invalid.");
		}
		else if (num3 != -1 || num4 != 0 || num5 != 0)
		{
			int num6 = ((checkTopologyRadius > 0f) ? TerrainMeta.TopologyMap.GetTopology(normX, normZ, checkTopologyRadius) : TerrainMeta.TopologyMap.GetTopology(normX, normZ));
			if (num3 != -1 && (num6 & num3) == 0)
			{
				return 0f;
			}
			if (num5 != 0 && (num6 & num5) != 0)
			{
				return 0f;
			}
			if (num4 != 0 && (num6 & num4) != num4)
			{
				return 0f;
			}
		}
		switch (num2)
		{
		case 0:
			Debug.LogError((object)"Empty biome filter is invalid.");
			break;
		default:
			if ((TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ) & num2) == 0)
			{
				return 0f;
			}
			break;
		case -1:
			break;
		}
		switch (num)
		{
		case 0:
			Debug.LogError((object)"Empty splat filter is invalid.");
			break;
		default:
			return TerrainMeta.SplatMap.GetSplat(normX, normZ, num);
		case -1:
			break;
		}
		return 1f;
	}
}


public enum SpawnFilterMode
{
	PivotPoint = 1,
	TerrainAnchorPoints = 2,
	TerrainCheckPoints = 4
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Terrain Config")]
public class TerrainConfig : ScriptableObject
{
	[Serializable]
	public class SplatOverlay
	{
		public Color Color = new Color(1f, 1f, 1f, 0f);

		[Range(0f, 1f)]
		public float Smoothness;

		[Range(0f, 1f)]
		public float NormalIntensity = 1f;

		[Range(0f, 8f)]
		public float BlendFactor = 0.5f;

		[Range(0.01f, 32f)]
		public float BlendFalloff = 0.5f;
	}

	[Serializable]
	public class SplatType
	{
		public string Name = "";

		[FormerlySerializedAs("WarmColor")]
		public Color AridColor = Color.white;

		public SplatOverlay AridOverlay = new SplatOverlay();

		[FormerlySerializedAs("Color")]
		public Color TemperateColor = Color.white;

		public SplatOverlay TemperateOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color TundraColor = Color.white;

		public SplatOverlay TundraOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color ArcticColor = Color.white;

		public SplatOverlay ArcticOverlay = new SplatOverlay();

		public Color JungleColor = Color.white;

		public SplatOverlay JungleOverlay = new SplatOverlay();

		public PhysicMaterial Material;

		public float SplatTiling = 5f;

		[Range(0f, 1f)]
		public float UVMIXMult = 0.15f;

		public float UVMIXStart;

		public float UVMIXDist = 100f;
	}

	public enum GroundType
	{
		None,
		HardSurface,
		Grass,
		Sand,
		Snow,
		Dirt,
		Gravel
	}

	public bool CastShadows = true;

	public LayerMask GroundMask = LayerMask.op_Implicit(0);

	public LayerMask WaterMask = LayerMask.op_Implicit(0);

	public PhysicMaterial GenericMaterial;

	public PhysicMaterial WaterMaterial;

	public Material Material;

	public Material MarginMaterial;

	public Texture[] AlbedoArrays = (Texture[])(object)new Texture[3];

	public Texture[] NormalArrays = (Texture[])(object)new Texture[3];

	public float HeightMapErrorMin = 5f;

	public float HeightMapErrorMax = 100f;

	public float BaseMapDistanceMin = 100f;

	public float BaseMapDistanceMax = 500f;

	public float ShaderLodMin = 100f;

	public float ShaderLodMax = 600f;

	public SplatType[] Splats = new SplatType[8];

	private string snowMatName;

	private string grassMatName;

	private string sandMatName;

	private List<string> dirtMatNames;

	private List<string> stoneyMatNames;

	private int snowMatID;

	private int grassMatID;

	private int sandMatID;

	private List<int> dirtMatIds;

	private List<int> stoneyMatIds;

	public Texture AlbedoArray => AlbedoArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public Texture NormalArray => NormalArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public PhysicMaterial[] GetPhysicMaterials()
	{
		PhysicMaterial[] array = (PhysicMaterial[])(object)new PhysicMaterial[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].Material;
		}
		return array;
	}

	public Color[] GetAridColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].AridColor;
		}
		return array;
	}

	public void GetAridOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay aridOverlay = Splats[i].AridOverlay;
			color[i] = ((Color)(ref aridOverlay.Color)).linear;
			param[i] = new Vector4(aridOverlay.Smoothness, aridOverlay.NormalIntensity, aridOverlay.BlendFactor, aridOverlay.BlendFalloff);
		}
	}

	public Color[] GetTemperateColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TemperateColor;
		}
		return array;
	}

	public void GetTemperateOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay temperateOverlay = Splats[i].TemperateOverlay;
			color[i] = ((Color)(ref temperateOverlay.Color)).linear;
			param[i] = new Vector4(temperateOverlay.Smoothness, temperateOverlay.NormalIntensity, temperateOverlay.BlendFactor, temperateOverlay.BlendFalloff);
		}
	}

	public Color[] GetTundraColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TundraColor;
		}
		return array;
	}

	public void GetTundraOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay tundraOverlay = Splats[i].TundraOverlay;
			color[i] = ((Color)(ref tundraOverlay.Color)).linear;
			param[i] = new Vector4(tundraOverlay.Smoothness, tundraOverlay.NormalIntensity, tundraOverlay.BlendFactor, tundraOverlay.BlendFalloff);
		}
	}

	public Color[] GetArcticColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].ArcticColor;
		}
		return array;
	}

	public void GetArcticOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay arcticOverlay = Splats[i].ArcticOverlay;
			color[i] = ((Color)(ref arcticOverlay.Color)).linear;
			param[i] = new Vector4(arcticOverlay.Smoothness, arcticOverlay.NormalIntensity, arcticOverlay.BlendFactor, arcticOverlay.BlendFalloff);
		}
	}

	public Color[] GetJungleColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].JungleColor;
		}
		return array;
	}

	public void GetJungleOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay jungleOverlay = Splats[i].JungleOverlay;
			color[i] = ((Color)(ref jungleOverlay.Color)).linear;
			param[i] = new Vector4(jungleOverlay.Smoothness, jungleOverlay.NormalIntensity, jungleOverlay.BlendFactor, jungleOverlay.BlendFalloff);
		}
	}

	public float[] GetSplatTiling()
	{
		float[] array = new float[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].SplatTiling;
		}
		return array;
	}

	public float GetMaxSplatTiling()
	{
		float num = float.MinValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling > num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public float GetMinSplatTiling()
	{
		float num = float.MaxValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling < num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public Vector3[] GetPackedUVMIX()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = new Vector3(Splats[i].UVMIXMult, Splats[i].UVMIXStart, Splats[i].UVMIXDist);
		}
		return array;
	}

	[Obsolete("Use GetCurrentGroundTypeNoAlloc instead")]
	public GroundType GetCurrentGroundType(bool isGrounded, RaycastHit hit)
	{
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundType", 0);
		try
		{
			if (string.IsNullOrEmpty(grassMatName))
			{
				dirtMatNames = new List<string>();
				stoneyMatNames = new List<string>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					string text = obj.Name.ToLower();
					string name = ((Object)obj.Material).name;
					switch (text)
					{
					case "grass":
						grassMatName = name;
						break;
					case "snow":
						snowMatName = name;
						break;
					case "sand":
						sandMatName = name;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatNames.Add(name);
						break;
					case "stones":
					case "gravel":
						stoneyMatNames.Add(name);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			string name2 = ((Object)materialAt).name;
			if (name2 == grassMatName)
			{
				return GroundType.Grass;
			}
			if (name2 == sandMatName)
			{
				return GroundType.Sand;
			}
			if (name2 == snowMatName)
			{
				return GroundType.Snow;
			}
			for (int j = 0; j < dirtMatNames.Count; j++)
			{
				if (dirtMatNames[j] == name2)
				{
					return GroundType.Dirt;
				}
			}
			for (int k = 0; k < stoneyMatNames.Count; k++)
			{
				if (stoneyMatNames[k] == name2)
				{
					return GroundType.Gravel;
				}
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public GroundType GetCurrentGroundTypeNoAlloc(bool isGrounded, RaycastHit hit)
	{
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundTypeNoAlloc", 0);
		try
		{
			if (grassMatID == 0)
			{
				dirtMatIds = new List<int>();
				stoneyMatIds = new List<int>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					int instanceID = ((Object)obj.Material).GetInstanceID();
					switch (obj.Name.ToLower())
					{
					case "grass":
						grassMatID = instanceID;
						break;
					case "snow":
						snowMatID = instanceID;
						break;
					case "sand":
						sandMatID = instanceID;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatIds.Add(instanceID);
						break;
					case "stones":
					case "gravel":
						stoneyMatIds.Add(instanceID);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			int instanceID2 = ((Object)materialAt).GetInstanceID();
			if (instanceID2 == grassMatID)
			{
				return GroundType.Grass;
			}
			if (instanceID2 == sandMatID)
			{
				return GroundType.Sand;
			}
			if (instanceID2 == snowMatID)
			{
				return GroundType.Snow;
			}
			if (dirtMatIds.Contains(instanceID2))
			{
				return GroundType.Dirt;
			}
			if (stoneyMatIds.Contains(instanceID2))
			{
				return GroundType.Gravel;
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SplatOverlay
{
	public Color Color = new Color(1f, 1f, 1f, 0f);

	[Range(0f, 1f)]
	public float Smoothness;

	[Range(0f, 1f)]
	public float NormalIntensity = 1f;

	[Range(0f, 8f)]
	public float BlendFactor = 0.5f;

	[Range(0.01f, 32f)]
	public float BlendFalloff = 0.5f;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class SplatType
{
	public string Name = "";

	[FormerlySerializedAs("WarmColor")]
	public Color AridColor = Color.white;

	public SplatOverlay AridOverlay = new SplatOverlay();

	[FormerlySerializedAs("Color")]
	public Color TemperateColor = Color.white;

	public SplatOverlay TemperateOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color TundraColor = Color.white;

	public SplatOverlay TundraOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color ArcticColor = Color.white;

	public SplatOverlay ArcticOverlay = new SplatOverlay();

	public Color JungleColor = Color.white;

	public SplatOverlay JungleOverlay = new SplatOverlay();

	public PhysicMaterial Material;

	public float SplatTiling = 5f;

	[Range(0f, 1f)]
	public float UVMIXMult = 0.15f;

	public float UVMIXStart;

	public float UVMIXDist = 100f;
}


public enum GroundType
{
	None,
	HardSurface,
	Grass,
	Sand,
	Snow,
	Dirt,
	Gravel
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.AI;

public class AsyncTerrainNavMeshBake : CustomYieldInstruction
{
	private List<int> indices;

	private List<Vector3> vertices;

	private List<Vector3> normals;

	private List<int> triangles;

	private Vector3 pivot;

	private int width;

	private int height;

	private bool normal;

	private bool alpha;

	private Action worker;

	public override bool keepWaiting => worker != null;

	public bool isDone => worker == null;

	public Mesh mesh
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Mesh val = new Mesh();
			if (vertices != null)
			{
				val.SetVertices(vertices);
				Pool.FreeUnmanaged<Vector3>(ref vertices);
			}
			if (normals != null)
			{
				val.SetNormals(normals);
				Pool.FreeUnmanaged<Vector3>(ref normals);
			}
			if (triangles != null)
			{
				val.SetTriangles(triangles, 0);
				Pool.FreeUnmanaged<int>(ref triangles);
			}
			if (indices != null)
			{
				Pool.FreeUnmanaged<int>(ref indices);
			}
			return val;
		}
	}

	public NavMeshBuildSource CreateNavMeshBuildSource()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = default(NavMeshBuildSource);
		((NavMeshBuildSource)(ref result)).transform = Matrix4x4.TRS(pivot, Quaternion.identity, Vector3.one);
		((NavMeshBuildSource)(ref result)).shape = (NavMeshBuildSourceShape)0;
		((NavMeshBuildSource)(ref result)).sourceObject = (Object)(object)mesh;
		return result;
	}

	public NavMeshBuildSource CreateNavMeshBuildSource(int area)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = CreateNavMeshBuildSource();
		((NavMeshBuildSource)(ref result)).area = area;
		return result;
	}

	public AsyncTerrainNavMeshBake(Vector3 pivot, int width, int height, bool normal, bool alpha)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		this.pivot = pivot;
		this.width = width;
		this.height = height;
		this.normal = normal;
		this.alpha = alpha;
		indices = Pool.Get<List<int>>();
		vertices = Pool.Get<List<Vector3>>();
		normals = (normal ? Pool.Get<List<Vector3>>() : null);
		triangles = Pool.Get<List<int>>();
		Invoke();
	}

	private void DoWork()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)(width / 2), 0f, (float)(height / 2));
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(pivot.x - val.x, 0f, pivot.z - val.z);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainAlphaMap alphaMap = TerrainMeta.AlphaMap;
		int num = 0;
		for (int i = 0; i <= height; i++)
		{
			int num2 = 0;
			while (num2 <= width)
			{
				Vector3 worldPos = new Vector3((float)num2, 0f, (float)i) + val2;
				Vector3 item = new Vector3((float)num2, 0f, (float)i) - val;
				float num3 = heightMap.GetHeight(worldPos);
				if (num3 < -1f)
				{
					indices.Add(-1);
				}
				else if (alpha && alphaMap.GetAlpha(worldPos) < 0.1f)
				{
					indices.Add(-1);
				}
				else
				{
					if (normal)
					{
						Vector3 item2 = heightMap.GetNormal(worldPos);
						normals.Add(item2);
					}
					worldPos.y = (item.y = num3 - pivot.y);
					indices.Add(vertices.Count);
					vertices.Add(item);
				}
				num2++;
				num++;
			}
		}
		int num4 = 0;
		int num5 = 0;
		while (num5 < height)
		{
			int num6 = 0;
			while (num6 < width)
			{
				int num7 = indices[num4];
				int num8 = indices[num4 + width + 1];
				int num9 = indices[num4 + 1];
				int num10 = indices[num4 + 1];
				int num11 = indices[num4 + width + 1];
				int num12 = indices[num4 + width + 2];
				if (num7 != -1 && num8 != -1 && num9 != -1)
				{
					triangles.Add(num7);
					triangles.Add(num8);
					triangles.Add(num9);
				}
				if (num10 != -1 && num11 != -1 && num12 != -1)
				{
					triangles.Add(num10);
					triangles.Add(num11);
					triangles.Add(num12);
				}
				num6++;
				num4++;
			}
			num5++;
			num4++;
		}
	}

	private void Invoke()
	{
		worker = DoWork;
		worker.BeginInvoke(Callback, null);
	}

	private void Callback(IAsyncResult result)
	{
		worker.EndInvoke(result);
		worker = null;
	}
}


using UnityEngine;

public struct TextureData
{
	public int width;

	public int height;

	public Color32[] colors;

	public TextureData(Texture2D tex)
	{
		if ((Object)(object)tex != (Object)null)
		{
			width = ((Texture)tex).width;
			height = ((Texture)tex).height;
			colors = tex.GetPixels32();
		}
		else
		{
			width = 0;
			height = 0;
			colors = null;
		}
	}

	public Color32 GetColor(int x, int y)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return colors[y * width + x];
	}

	public int GetShort(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeShort(GetColor(x, y));
	}

	public int GetInt(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeInt(GetColor(x, y));
	}

	public float GetFloat(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeFloat(GetColor(x, y));
	}

	public float GetHalf(int x, int y)
	{
		return BitUtility.Short2Float(GetShort(x, y));
	}

	public Vector4 GetVector(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeVector(GetColor(x, y));
	}

	public Vector3 GetNormal(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeNormal(Color32.op_Implicit(GetColor(x, y)));
	}

	public Color32 GetInterpolatedColor(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Color val = Color32.op_Implicit(GetColor(num3, num4));
		Color val2 = Color32.op_Implicit(GetColor(x2, num4));
		Color val3 = Color32.op_Implicit(GetColor(num3, y2));
		Color val4 = Color32.op_Implicit(GetColor(x2, y2));
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Color val5 = Color.Lerp(val, val2, num5);
		Color val6 = Color.Lerp(val3, val4, num5);
		return Color32.op_Implicit(Color.Lerp(val5, val6, num6));
	}

	public int GetInterpolatedInt(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetInt(x2, y2);
	}

	public int GetInterpolatedShort(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetShort(x2, y2);
	}

	public float GetInterpolatedFloat(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float @float = GetFloat(num3, num4);
		float float2 = GetFloat(x2, num4);
		float float3 = GetFloat(num3, y2);
		float float4 = GetFloat(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(@float, float2, num5);
		float num8 = Mathf.Lerp(float3, float4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public float GetInterpolatedHalf(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float half = GetHalf(num3, num4);
		float half2 = GetHalf(x2, num4);
		float half3 = GetHalf(num3, y2);
		float half4 = GetHalf(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(half, half2, num5);
		float num8 = Mathf.Lerp(half3, half4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public Vector4 GetInterpolatedVector(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector4 vector = GetVector(num3, num4);
		Vector4 vector2 = GetVector(x2, num4);
		Vector4 vector3 = GetVector(num3, y2);
		Vector4 vector4 = GetVector(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector4 val = Vector4.Lerp(vector, vector2, num5);
		Vector4 val2 = Vector4.Lerp(vector3, vector4, num5);
		return Vector4.Lerp(val, val2, num6);
	}

	public Vector3 GetInterpolatedNormal(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector3 normal = GetNormal(num3, num4);
		Vector3 normal2 = GetNormal(x2, num4);
		Vector3 normal3 = GetNormal(num3, y2);
		Vector3 normal4 = GetNormal(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector3 val = Vector3.Lerp(normal, normal2, num5);
		Vector3 val2 = Vector3.Lerp(normal3, normal4, num5);
		return Vector3.Lerp(val, val2, num6);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using ConVar;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public static class World
{
	public struct SpawnTiming
	{
		public string category;

		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public TimeSpan time;
	}

	private static uint _size;

	private static Stopwatch spawnTimer = new Stopwatch();

	private static List<SpawnTiming> spawnTimings = new List<SpawnTiming>();

	public static uint Seed { get; set; }

	public static uint Salt { get; set; }

	public static uint Size
	{
		get
		{
			return _size;
		}
		set
		{
			_size = value;
		}
	}

	public static string Checksum { get; set; }

	public static long Timestamp { get; set; }

	public static string Url { get; set; }

	public static bool Procedural { get; set; }

	public static bool Cached { get; set; }

	public static bool Networked { get; set; }

	public static bool Receiving { get; set; }

	public static bool Transfer { get; set; }

	public static bool Nexus => NexusServer.Started;

	public static bool LoadedFromSave { get; set; }

	public static int SpawnIndex { get; set; }

	public static WorldSerialization Serialization { get; set; }

	public static WorldConfig Config { get; set; }

	public static string Name
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalName;
			}
			if (CanLoadFromUrl())
			{
				return Path.GetFileNameWithoutExtension(WWW.UnEscapeURL(Url));
			}
			return Application.loadedLevelName;
		}
	}

	public static string MapFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalMapFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + ".map";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 270 + ".map";
		}
	}

	public static string MapFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	public static string SaveFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalSaveFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + "." + 270 + ".sav";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 270 + ".sav";
		}
	}

	public static string SaveFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static string GetServerBrowserMapName()
	{
		if (MapUploader.IsUploaded)
		{
			return Name;
		}
		if (!CanLoadFromUrl())
		{
			return Name;
		}
		if (Name.StartsWith("proceduralmap."))
		{
			return "Procedural Map";
		}
		return "Custom Map";
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromUrl()
	{
		return !string.IsNullOrEmpty(Url);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromDisk()
	{
		return File.Exists(MapFolderName + "/" + MapFileName);
	}

	public static void CleanupOldFiles()
	{
		if (!Directory.Exists(MapFolderName))
		{
			return;
		}
		Regex regex1 = new Regex("proceduralmap\\.[0-9]+\\.[0-9]+\\.[0-9]+(_occlusion)*\\.(map|dat)");
		Regex regex2 = new Regex("\\.[0-9]+\\.[0-9]+\\." + 270 + "+(_occlusion)*\\.(map|dat)");
		foreach (string item in new string[2] { "*.map", "*.dat" }.SelectMany((string ext) => from path in Directory.GetFiles(MapFolderName, ext)
			where regex1.IsMatch(path) && !regex2.IsMatch(path)
			select path))
		{
			try
			{
				File.Delete(item);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex.Message);
			}
		}
	}

	public static void InitSeed(int seed)
	{
		InitSeed((uint)seed);
	}

	public static void InitSeed(uint seed)
	{
		if (seed == 0)
		{
			seed = MurmurHashEx.MurmurHashUnsigned(SeedIdentifier()) % int.MaxValue;
		}
		if (seed == 0)
		{
			seed = 123456u;
		}
		Seed = seed;
		Server.seed = (int)seed;
	}

	private static string SeedIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_" + 270 + "_" + Server.identity;
	}

	public static void InitSalt(int salt)
	{
		InitSalt((uint)salt);
	}

	public static void InitSalt(uint salt)
	{
		if (salt == 0)
		{
			salt = MurmurHashEx.MurmurHashUnsigned(SaltIdentifier()) % int.MaxValue;
		}
		if (salt == 0)
		{
			salt = 654321u;
		}
		Salt = salt;
		Server.salt = (int)salt;
	}

	private static string SaltIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_salt";
	}

	public static void InitSize(int size)
	{
		InitSize((uint)size);
	}

	public static void InitSize(uint size)
	{
		if (size == 0)
		{
			size = 4500u;
		}
		if (size < 1000)
		{
			size = 1000u;
		}
		if (size > 6000)
		{
			size = 6000u;
		}
		Size = size;
		Server.worldsize = (int)size;
	}

	public static byte[] GetMap(string name)
	{
		return Serialization.GetMap(name)?.data;
	}

	public static int GetCachedHeightMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("height").Length / 2)));
	}

	public static int GetCachedSplatMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("splat").Length / 8)));
	}

	public static void AddMap(string name, byte[] data)
	{
		Serialization.AddMap(name, data);
	}

	public static void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Serialization.AddPrefab(category, prefab.ID, position, rotation, scale);
		if (!Cached)
		{
			rotation = Quaternion.Euler(((Quaternion)(ref rotation)).eulerAngles);
			SpawnPrefab(category, prefab, position, rotation, scale);
		}
	}

	public static PathData PathListToPathData(PathList src)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Expected O, but got Unknown
		return new PathData
		{
			name = src.Name,
			spline = src.Spline,
			start = src.Start,
			end = src.End,
			width = src.Width,
			innerPadding = src.InnerPadding,
			outerPadding = src.OuterPadding,
			innerFade = src.InnerFade,
			outerFade = src.OuterFade,
			randomScale = src.RandomScale,
			meshOffset = src.MeshOffset,
			terrainOffset = src.TerrainOffset,
			splat = src.Splat,
			topology = src.Topology,
			hierarchy = src.Hierarchy,
			nodes = VectorArrayToList(src.Path.Points)
		};
	}

	public static PathList PathDataToPathList(PathData src)
	{
		PathList pathList = new PathList(src.name, VectorListToArray(src.nodes));
		pathList.Spline = src.spline;
		pathList.Start = src.start;
		pathList.End = src.end;
		pathList.Width = src.width;
		pathList.InnerPadding = src.innerPadding;
		pathList.OuterPadding = src.outerPadding;
		pathList.InnerFade = src.innerFade;
		pathList.OuterFade = src.outerFade;
		pathList.RandomScale = src.randomScale;
		pathList.MeshOffset = src.meshOffset;
		pathList.TerrainOffset = src.terrainOffset;
		pathList.Splat = src.splat;
		pathList.Topology = src.topology;
		pathList.Hierarchy = src.hierarchy;
		pathList.Path.RecalculateTangents();
		return pathList;
	}

	public static Vector3[] VectorListToArray(List<VectorData> src)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[src.Count];
		for (int i = 0; i < array.Length; i++)
		{
			VectorData val = src[i];
			Vector3 val2 = default(Vector3);
			val2.x = val.x;
			val2.y = val.y;
			val2.z = val.z;
			array[i] = val2;
		}
		return array;
	}

	public static List<VectorData> VectorArrayToList(Vector3[] src)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		List<VectorData> list = new List<VectorData>(src.Length);
		foreach (Vector3 val in src)
		{
			VectorData item = default(VectorData);
			item.x = val.x;
			item.y = val.y;
			item.z = val.z;
			list.Add(item);
		}
		return list;
	}

	public static IEnumerable<PathList> GetPaths(string name)
	{
		return from p in Serialization.GetPaths(name)
			select PathDataToPathList(p);
	}

	public static void AddPaths(IEnumerable<PathList> paths)
	{
		foreach (PathList path in paths)
		{
			AddPath(path);
		}
	}

	public static void AddPath(PathList path)
	{
		Serialization.AddPath(PathListToPathData(path));
	}

	public static IEnumerator Spawn(float deltaTime, Action<string> statusFunction = null, CancellationToken ct = default(CancellationToken))
	{
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (assetBundleBackend != null)
		{
			HashSet<string> hashSet = Serialization.world.prefabs.Select((PrefabData p) => StringPool.Get(p.id)).ToHashSet<string>(StringComparer.OrdinalIgnoreCase);
			List<string> requiredAssetScenes = assetBundleBackend.GetRequiredAssetScenesForPrefabs((IEnumerable<string>)hashSet);
			IEnumerator loading = assetBundleBackend.LoadAssetScenes(requiredAssetScenes);
			bool wantsCancel = false;
			float lastProgress = 0f;
			while (loading.MoveNext())
			{
				if (!wantsCancel && ct.IsCancellationRequested)
				{
					wantsCancel = true;
					Debug.LogWarning((object)"Cancel was requested but must wait for asset scenes to finish loading");
				}
				float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress(requiredAssetScenes);
				if (!Mathf.Approximately(assetSceneProgress, lastProgress))
				{
					lastProgress = assetSceneProgress;
					Status(statusFunction, $"Loading World Prefabs {assetSceneProgress * 100f:0.0}%");
				}
				yield return loading.Current;
			}
		}
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			if (ct.IsCancellationRequested)
			{
				break;
			}
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == Serialization.world.prefabs.Count - 1)
			{
				Status(statusFunction, "Spawning World ({0}/{1})", i + 1, Serialization.world.prefabs.Count);
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn()
	{
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn(string category, string folder = null)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (string.IsNullOrEmpty(folder) || text.StartsWith(folder))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	public static void Spawn(string category, string[] folders)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (folders == null || StringEx.StartsWithAny(text, folders))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	private static void SpawnPrefabData(PrefabData prefab)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		StringPool.Get(prefab.id);
		uint id = prefab.id;
		SpawnPrefab(prefab.category, Prefab.Load(id), VectorData.op_Implicit(prefab.position), VectorData.op_Implicit(prefab.rotation), VectorData.op_Implicit(prefab.scale));
	}

	private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		if (prefab != null && Object.op_Implicit((Object)(object)prefab.Object))
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject val = prefab.Spawn(position, rotation, scale);
			if (Object.op_Implicit((Object)(object)val))
			{
				Interface.CallHook("OnWorldPrefabSpawned", (object)val, (object)category);
				val.SetHierarchyGroup(category);
			}
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

	private static void Status(Action<string> statusFunction, string status, object obj1)
	{
		statusFunction?.Invoke(string.Format(status, obj1));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2, object obj3)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2, obj3));
	}

	private static void Status(Action<string> statusFunction, string status, params object[] objs)
	{
		statusFunction?.Invoke(string.Format(status, objs));
	}

	public static IEnumerable<SpawnTiming> GetSpawnTimings()
	{
		return spawnTimings;
	}

	public static void ResetTiming()
	{
		spawnTimings.Clear();
	}
}


using System;
using UnityEngine;

public struct SpawnTiming
{
	public string category;

	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public TimeSpan time;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using UnityEngine;

[JsonModel]
public class WorldConfig
{
	public string JsonString = string.Empty;

	public float PercentageTier0 = 0.3f;

	public float PercentageTier1 = 0.3f;

	public float PercentageTier2 = 0.4f;

	public float PercentageBiomeArid = 0.4f;

	public float PercentageBiomeTemperate = 0.15f;

	public float PercentageBiomeTundra = 0.15f;

	public float PercentageBiomeArctic = 0.3f;

	public float PercentageBiomeJungle = 0.5f;

	public bool MainRoads = true;

	public bool SideRoads = true;

	public bool Trails = true;

	public bool Rivers = true;

	public bool Powerlines = true;

	public bool AboveGroundRails = true;

	public bool BelowGroundRails = true;

	public bool UnderwaterLabs = true;

	public List<string> PrefabBlacklist = new List<string>();

	public List<string> PrefabWhitelist = new List<string>();

	public bool IsPrefabAllowed(string name)
	{
		if (PrefabBlacklist.Count > 0)
		{
			foreach (string item in PrefabBlacklist)
			{
				if (name.Contains(item))
				{
					return false;
				}
			}
		}
		if (PrefabWhitelist.Count > 0)
		{
			foreach (string item2 in PrefabWhitelist)
			{
				if (name.Contains(item2))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void LoadFromJsonFile(string fileName)
	{
		try
		{
			LoadFromJsonString(File.ReadAllText(fileName));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromJsonString(string data)
	{
		try
		{
			LoadFromWorldConfig(JsonConvert.DeserializeObject<WorldConfig>(JsonString = data));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromWorldConfig(WorldConfig data)
	{
		float num = data.PercentageTier0 + data.PercentageTier1 + data.PercentageTier2;
		if (num > 0f)
		{
			PercentageTier0 = data.PercentageTier0 / num;
			PercentageTier1 = data.PercentageTier1 / num;
			PercentageTier2 = data.PercentageTier2 / num;
		}
		else
		{
			PercentageTier0 = 0f;
			PercentageTier1 = 1f;
			PercentageTier2 = 0f;
		}
		float num2 = data.PercentageBiomeArid + data.PercentageBiomeTemperate + data.PercentageBiomeTundra + data.PercentageBiomeArctic;
		if (num2 > 0f)
		{
			PercentageBiomeArid = data.PercentageBiomeArid / num2;
			PercentageBiomeTemperate = data.PercentageBiomeTemperate / num2;
			PercentageBiomeTundra = data.PercentageBiomeTundra / num2;
			PercentageBiomeArctic = data.PercentageBiomeArctic / num2;
		}
		else
		{
			PercentageBiomeArid = 0f;
			PercentageBiomeTemperate = 1f;
			PercentageBiomeTundra = 0f;
			PercentageBiomeArctic = 0f;
		}
		MainRoads = data.MainRoads;
		SideRoads = data.SideRoads;
		Trails = data.Trails;
		Rivers = data.Rivers;
		Powerlines = data.Powerlines;
		AboveGroundRails = data.AboveGroundRails;
		BelowGroundRails = data.BelowGroundRails;
		UnderwaterLabs = data.UnderwaterLabs;
		PrefabBlacklist.Clear();
		if (data.PrefabBlacklist != null && data.PrefabBlacklist.Count > 0)
		{
			PrefabBlacklist.AddRange(data.PrefabBlacklist);
		}
		PrefabWhitelist.Clear();
		if (data.PrefabWhitelist != null && data.PrefabWhitelist.Count > 0)
		{
			PrefabWhitelist.AddRange(data.PrefabWhitelist);
		}
	}

	public void LoadScriptableConfigs()
	{
		ScriptableWorldConfig[] array = Resources.LoadAll<ScriptableWorldConfig>("");
		bool flag = false;
		ScriptableWorldConfig[] array2 = array;
		foreach (ScriptableWorldConfig scriptableWorldConfig in array2)
		{
			if (scriptableWorldConfig.GameModes != null && scriptableWorldConfig.GameModes.Contains(Server.gamemode))
			{
				MergeScriptableConfig(scriptableWorldConfig);
				flag = true;
			}
		}
		if (flag)
		{
			JsonString = JsonConvert.SerializeObject((object)this);
		}
	}

	private void MergeScriptableConfig(ScriptableWorldConfig config)
	{
		UnderwaterLabs &= config.UnderwaterLabs;
		BelowGroundRails &= config.UndergroundTrains;
		if (PrefabBlacklist == null)
		{
			PrefabBlacklist = new List<string>();
		}
		if (config.BlacklistedPrefabs != null)
		{
			PrefabBlacklist.AddRange(config.BlacklistedPrefabs);
		}
	}
}


using System;
using UnityEngine;

public abstract class DecorComponent : PrefabAttribute
{
	internal bool isRoot;

	public abstract void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isRoot = (Object)(object)rootObj == (Object)(object)((Component)this).gameObject;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecorComponent);
	}
}


using UnityEngine;

public static class DecorComponentEx
{
	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components, ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		foreach (DecorComponent decorComponent in components)
		{
			if (!decorComponent.isRoot)
			{
				break;
			}
			decorComponent.Apply(ref pos, ref rot, ref scale);
		}
	}

	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.position = pos;
		transform.rotation = rot;
		transform.localScale = scale;
	}

	public static void ApplyDecorComponentsScaleOnly(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.localScale = scale;
	}
}


using UnityEngine;

public class DecorAlign : DecorComponent
{
	public float NormalAlignment = 1f;

	public float GradientAlignment = 1f;

	public Vector3 SlopeOffset = Vector3.zero;

	public Vector3 SlopeScale = Vector3.one;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = TerrainMeta.HeightMap.GetNormal(pos);
		Vector3 val = ((normal == Vector3.up) ? Vector3.forward : Vector3.Cross(normal, Vector3.up));
		Vector3 val2 = Vector3.Cross(normal, val);
		if (SlopeOffset != Vector3.zero || SlopeScale != Vector3.one)
		{
			float slope = TerrainMeta.HeightMap.GetSlope01(pos);
			if (SlopeOffset != Vector3.zero)
			{
				Vector3 val3 = SlopeOffset * slope;
				pos += val3.x * val;
				pos += val3.y * normal;
				pos -= val3.z * val2;
			}
			if (SlopeScale != Vector3.one)
			{
				Vector3 val4 = Vector3.Lerp(Vector3.one, Vector3.one + Quaternion.Inverse(rot) * (SlopeScale - Vector3.one), slope);
				scale.x *= val4.x;
				scale.y *= val4.y;
				scale.z *= val4.z;
			}
		}
		Vector3 up = Vector3.Lerp(rot * Vector3.up, normal, NormalAlignment);
		Vector3 forward = Vector3.Lerp(rot * Vector3.forward, val2, GradientAlignment);
		rot = QuaternionEx.LookRotationForcedUp(forward, up);
	}
}


using UnityEngine;

public class DecorFlip : DecorComponent
{
	public enum AxisType
	{
		X,
		Y,
		Z
	}

	public AxisType FlipAxis = AxisType.Y;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 4;
		if (!(SeedRandom.Value(ref num) > 0.5f))
		{
			switch (FlipAxis)
			{
			case AxisType.X:
			case AxisType.Z:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.up) * rot;
				break;
			case AxisType.Y:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.forward) * rot;
				break;
			}
		}
	}
}


public enum AxisType
{
	X,
	Y,
	Z
}


using UnityEngine;

public class DecorOffset : DecorComponent
{
	public Vector3 MinOffset = new Vector3(0f, 0f, 0f);

	public Vector3 MaxOffset = new Vector3(0f, 0f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 1;
		pos.x += scale.x * SeedRandom.Range(ref num, MinOffset.x, MaxOffset.x);
		pos.y += scale.y * SeedRandom.Range(ref num, MinOffset.y, MaxOffset.y);
		pos.z += scale.z * SeedRandom.Range(ref num, MinOffset.z, MaxOffset.z);
	}
}


using UnityEngine;

public class DecorRotate : DecorComponent
{
	public Vector3 MinRotation = new Vector3(0f, -180f, 0f);

	public Vector3 MaxRotation = new Vector3(0f, 180f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 2;
		float num2 = SeedRandom.Range(ref num, MinRotation.x, MaxRotation.x);
		float num3 = SeedRandom.Range(ref num, MinRotation.y, MaxRotation.y);
		float num4 = SeedRandom.Range(ref num, MinRotation.z, MaxRotation.z);
		rot = Quaternion.Euler(num2, num3, num4) * rot;
	}
}


using UnityEngine;

public class DecorScale : DecorComponent
{
	public Vector3 MinScale = new Vector3(1f, 1f, 1f);

	public Vector3 MaxScale = new Vector3(2f, 2f, 2f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 3;
		float num2 = SeedRandom.Value(ref num);
		scale.x *= Mathf.Lerp(MinScale.x, MaxScale.x, num2);
		scale.y *= Mathf.Lerp(MinScale.y, MaxScale.y, num2);
		scale.z *= Mathf.Lerp(MinScale.z, MaxScale.z, num2);
	}
}


using System;
using UnityEngine;

public class DecorSocketFemale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketFemale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(1f, 0.5f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using System;
using UnityEngine;

public class DecorSocketMale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketMale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 1f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using UnityEngine;

public class DecorSwim : DecorComponent
{
	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		pos.y = WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
		if (pos.y <= TerrainMeta.Position.y + 1f)
		{
			pos.y = 0f;
		}
	}
}


using UnityEngine;

public class DecorTransform : DecorComponent
{
	public Vector3 Position = new Vector3(0f, 0f, 0f);

	public Vector3 Rotation = new Vector3(0f, 0f, 0f);

	public Vector3 Scale = new Vector3(1f, 1f, 1f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		pos += rot * Vector3.Scale(scale, Position);
		rot = Quaternion.Euler(Rotation) * rot;
		scale = Vector3.Scale(scale, Scale);
	}
}


public class DecorPatch
{
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class DecorSpawn : MonoBehaviour, IClientComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public uint Seed;

	public float ObjectCutoff = 0.2f;

	public float ObjectTapering = 0.2f;

	public int ObjectsPerPatch = 10;

	public float ClusterRadius = 2f;

	public int ClusterSizeMin = 1;

	public int ClusterSizeMax = 10;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public bool LOD = true;
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseInfo : LandmarkInfo
{
	public List<GameObject> Links = new List<GameObject>();

	public List<DungeonBaseFloor> Floors = new List<DungeonBaseFloor>();

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public void Add(DungeonBaseLink link)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Links.Add(((Component)link).gameObject);
		if (link.Type == DungeonBaseLinkType.End)
		{
			return;
		}
		DungeonBaseFloor dungeonBaseFloor = null;
		float num = float.MaxValue;
		for (int i = 0; i < Floors.Count; i++)
		{
			DungeonBaseFloor dungeonBaseFloor2 = Floors[i];
			float num2 = dungeonBaseFloor2.Distance(((Component)link).transform.position);
			if (!(num2 >= 1f) && !(num2 >= num))
			{
				dungeonBaseFloor = dungeonBaseFloor2;
				num = num2;
			}
		}
		if (dungeonBaseFloor == null)
		{
			dungeonBaseFloor = new DungeonBaseFloor();
			dungeonBaseFloor.Links.Add(link);
			Floors.Add(dungeonBaseFloor);
			Floors.Sort((DungeonBaseFloor l, DungeonBaseFloor r) => l.SignedDistance(((Component)this).transform.position).CompareTo(r.SignedDistance(((Component)this).transform.position)));
		}
		else
		{
			dungeonBaseFloor.Links.Add(link);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseEntrances.Add(this);
		}
	}

	protected void Start()
	{
		((Component)this).transform.SetHierarchyGroup("DungeonBase");
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class DungeonBaseFloor
{
	public List<DungeonBaseLink> Links = new List<DungeonBaseLink>();

	public float Distance(Vector3 position)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Abs(((Component)Links[0]).transform.position.y - position.y);
	}

	public float SignedDistance(Vector3 position)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)Links[0]).transform.position.y - position.y;
	}
}


using UnityEngine;

[RequireComponent(typeof(DungeonBaseLink))]
public class DungeonBaseLandmarkInfo : LandmarkInfo
{
	private DungeonBaseLink baseLink;

	private MapLayer? layer;

	public override MapLayer MapLayer
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (layer.HasValue)
			{
				return layer.Value;
			}
			DungeonBaseInfo dungeonBaseInfo = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonBaseEntrances, ((Component)baseLink).transform.position);
			if ((Object)(object)dungeonBaseInfo == (Object)null)
			{
				Debug.LogWarning((object)"Couldn't determine which underwater lab a DungeonBaseLandmarkInfo belongs to", (Object)(object)this);
				shouldDisplayOnMap = false;
				layer = MapLayer.Overworld;
				return layer.Value;
			}
			int num = -1;
			for (int i = 0; i < dungeonBaseInfo.Floors.Count; i++)
			{
				if (dungeonBaseInfo.Floors[i].Links.Contains(baseLink))
				{
					num = i;
				}
			}
			if (num >= 0)
			{
				layer = (MapLayer)(1 + num);
			}
			else
			{
				Debug.LogWarning((object)"Couldn't determine the floor of a DungeonBaseLandmarkInfo", (Object)(object)this);
				shouldDisplayOnMap = false;
				layer = MapLayer.Overworld;
			}
			return layer.Value;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		baseLink = ((Component)this).GetComponent<DungeonBaseLink>();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseLink : MonoBehaviour
{
	public DungeonBaseLinkType Type;

	public int Cost = 1;

	public int MaxFloor = -1;

	public int MaxCountLocal = -1;

	public int MaxCountGlobal = -1;

	[Tooltip("If set to a positive number, all segments with the same MaxCountIdentifier are counted towards MaxCountLocal and MaxCountGlobal")]
	public int MaxCountIdentifier = -1;

	public DungeonBaseInfo Dungeon;

	public RendererLOD[] MapRendererLods = new RendererLOD[0];

	private List<DungeonBaseSocket> sockets;

	private List<DungeonVolume> volumes;

	internal List<DungeonBaseSocket> Sockets
	{
		get
		{
			if (sockets == null)
			{
				sockets = new List<DungeonBaseSocket>();
				((Component)this).GetComponentsInChildren<DungeonBaseSocket>(true, sockets);
			}
			return sockets;
		}
	}

	internal List<DungeonVolume> Volumes
	{
		get
		{
			if (volumes == null)
			{
				volumes = new List<DungeonVolume>();
				((Component)this).GetComponentsInChildren<DungeonVolume>(true, volumes);
			}
			return volumes;
		}
	}

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseLinks.Add(this);
		}
	}

	internal void Initialize()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)TerrainMeta.Path == (Object)null))
		{
			Dungeon = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonBaseEntrances, ((Component)this).transform.position);
			if (!((Object)(object)Dungeon == (Object)null))
			{
				Dungeon.Add(this);
			}
		}
	}
}


public enum DungeonBaseLinkType
{
	Room,
	Corridor,
	End
}


using UnityEngine;

public class DungeonBaseSocket : MonoBehaviour
{
	public DungeonBaseSocketType Type;

	public bool Male = true;

	public bool Female = true;
}


public enum DungeonBaseSocketType
{
	Horizontal,
	Vertical,
	Pillar
}


using UnityEngine;

public class DungeonBaseTransition : MonoBehaviour
{
	public DungeonBaseSocketType Type;

	public DungeonBaseLinkType Neighbour1;

	public DungeonBaseLinkType Neighbour2;
}


using UnityEngine;

public class DungeonConditionalModel : MonoBehaviour
{
	public MapLayer Layer;

	private void Start()
	{
		foreach (Transform child in ((Component)this).transform.GetChildren())
		{
			((Component)child).gameObject.SetActive(!World.Config.BelowGroundRails);
		}
	}
}


using UnityEngine;

public class DungeonGridCell : MonoBehaviour
{
	public DungeonGridConnectionType North;

	public DungeonGridConnectionType South;

	public DungeonGridConnectionType West;

	public DungeonGridConnectionType East;

	public DungeonGridConnectionVariant NorthVariant;

	public DungeonGridConnectionVariant SouthVariant;

	public DungeonGridConnectionVariant WestVariant;

	public DungeonGridConnectionVariant EastVariant;

	public GameObjectRef[] AvoidNeighbours;

	public RendererLOD[] MapRendererLods;

	public bool Replaceable;

	public bool ShouldAvoid(uint id)
	{
		GameObjectRef[] avoidNeighbours = AvoidNeighbours;
		for (int i = 0; i < avoidNeighbours.Length; i++)
		{
			if (avoidNeighbours[i].resourceID == id)
			{
				return true;
			}
		}
		return false;
	}

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonGridCells.Add(this);
		}
	}
}


public enum DungeonGridConnectionType
{
	None,
	TrainTunnel
}


public enum DungeonGridConnectionVariant
{
	A,
	B
}


public struct DungeonGridConnectionHash
{
	public bool North;

	public bool South;

	public bool West;

	public bool East;

	public int Value => (North ? 1 : 0) | (South ? 2 : 0) | (West ? 4 : 0) | (East ? 8 : 0);
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonGridInfo : LandmarkInfo
{
	[Header("DungeonGridInfo")]
	public int CellSize = 216;

	public float LinkHeight = 1.5f;

	public float LinkRadius = 3f;

	internal List<GameObject> Links = new List<GameObject>();

	public float MinDistance => (float)CellSize * 2.5f;

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public bool IsValidSpawnPosition(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		OBB bounds = ((Component)this).GetComponentInChildren<DungeonVolume>().GetBounds(position, Quaternion.identity);
		Vector3 val = WorldSpaceGrid.ClosestGridCell(bounds.position, TerrainMeta.Size.x, (float)CellSize, (RoundingMode)1);
		Vector3 val2 = bounds.position - val;
		if (!(Mathf.Abs(val2.x) > 3f))
		{
			return Mathf.Abs(val2.z) > 3f;
		}
		return true;
	}

	public Vector3 SnapPosition(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		pos.x = (float)Mathf.RoundToInt(pos.x / LinkRadius) * LinkRadius;
		pos.y = (float)Mathf.CeilToInt(pos.y / LinkHeight) * LinkHeight;
		pos.z = (float)Mathf.RoundToInt(pos.z / LinkRadius) * LinkRadius;
		return pos;
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonGridEntrances.Add(this);
		}
	}

	protected void Start()
	{
		((Component)this).transform.SetHierarchyGroup("Dungeon");
	}
}


using UnityEngine;

public class DungeonGridLink : MonoBehaviour
{
	public Transform UpSocket;

	public Transform DownSocket;

	public DungeonGridLinkType UpType;

	public DungeonGridLinkType DownType;

	public int Priority;

	public int Rotation;

	protected void Start()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)TerrainMeta.Path == (Object)null))
		{
			DungeonGridInfo dungeonGridInfo = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonGridEntrances, ((Component)this).transform.position);
			if (!((Object)(object)dungeonGridInfo == (Object)null))
			{
				dungeonGridInfo.Links.Add(((Component)this).gameObject);
			}
		}
	}
}


public enum DungeonGridLinkType
{
	Default,
	Elevator,
	Transition
}


using UnityEngine;

public class DungeonVolume : MonoBehaviour
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public OBB GetBounds(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (((Component)this).transform.localRotation * ((Bounds)(ref bounds)).center + ((Component)this).transform.localPosition);
		return new OBB(position, ((Bounds)(ref bounds)).size, rotation * ((Component)this).transform.localRotation);
	}

	public OBB GetBounds(Vector3 position, Quaternion rotation, Vector3 extrude)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (((Component)this).transform.localRotation * ((Bounds)(ref bounds)).center + ((Component)this).transform.localPosition);
		return new OBB(position, ((Bounds)(ref bounds)).size + extrude, rotation * ((Component)this).transform.localRotation);
	}
}


using System;
using UnityEngine;

public class EnvironmentVolumeCheck : PrefabAttribute
{
	[InspectorFlags]
	public EnvironmentType Type = EnvironmentType.Underground | EnvironmentType.TrainTunnels;

	public Vector3 Center = Vector3.zero;

	public Vector3 Size = Vector3.one;

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(0f, 0f, 0.5f, 1f);
		Gizmos.DrawWireCube(Center, Size);
	}

	public bool Check(OBB obb)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return !EnvironmentManager.Check(obb, Type);
	}

	protected override Type GetIndexedType()
	{
		return typeof(EnvironmentVolumeCheck);
	}
}


using UnityEngine;

public static class EnvironmentVolumeCheckEx
{
	public static bool ApplyEnvironmentVolumeChecks(this Transform transform, EnvironmentVolumeCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		OBB obb = default(OBB);
		foreach (EnvironmentVolumeCheck environmentVolumeCheck in anchors)
		{
			Vector3 val = environmentVolumeCheck.worldPosition + environmentVolumeCheck.worldRotation * environmentVolumeCheck.Center;
			Vector3 val2 = rot * Vector3.Scale(val, scale);
			((OBB)(ref obb))..ctor(pos + val2, Vector3.Scale(environmentVolumeCheck.Size, scale), rot);
			if (!environmentVolumeCheck.Check(obb))
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using UnityEngine;

public class BiomeVisuals : MonoBehaviour
{
	[Serializable]
	public class EnvironmentVolumeOverride
	{
		public EnvironmentType Environment;

		public Enum Biome;
	}

	public GameObject Arid;

	public GameObject Temperate;

	public GameObject Tundra;

	public GameObject Arctic;

	public bool OverrideBiome;

	public Enum ToOverride;

	[Horizontal(2, -1)]
	public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;

	private bool _supportsPooling;

	private GameObject _defaultSelection;

	protected void Awake()
	{
		_supportsPooling = ((Component)this).gameObject.SupportsPoolingInParent();
		if (Object.op_Implicit((Object)(object)Arid) && Arid.activeSelf)
		{
			_defaultSelection = Arid;
		}
		else if (Object.op_Implicit((Object)(object)Temperate) && Temperate.activeSelf)
		{
			_defaultSelection = Temperate;
		}
		else if (Object.op_Implicit((Object)(object)Tundra) && Tundra.activeSelf)
		{
			_defaultSelection = Tundra;
		}
		else if (Object.op_Implicit((Object)(object)Arctic) && Arctic.activeSelf)
		{
			_defaultSelection = Arctic;
		}
	}

	protected void OnEnable()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected I4, but got Unknown
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Expected I4, but got Unknown
		int num = (((Object)(object)TerrainMeta.BiomeMap != (Object)null) ? TerrainMeta.BiomeMap.GetBiomeMaxType(((Component)this).transform.position) : 2);
		if (OverrideBiome)
		{
			num = (int)ToOverride;
		}
		else if (EnvironmentVolumeOverrides.Length != 0)
		{
			EnvironmentType environmentType = EnvironmentManager.Get(((Component)this).transform.position);
			EnvironmentVolumeOverride[] environmentVolumeOverrides = EnvironmentVolumeOverrides;
			foreach (EnvironmentVolumeOverride environmentVolumeOverride in environmentVolumeOverrides)
			{
				if ((environmentType & environmentVolumeOverride.Environment) != 0)
				{
					num = (int)environmentVolumeOverride.Biome;
					break;
				}
			}
		}
		switch (num)
		{
		case 1:
			SetChoice(Arid);
			break;
		case 2:
			SetChoice(Temperate);
			break;
		case 4:
			SetChoice(Tundra);
			break;
		case 8:
			SetChoice(Arctic);
			break;
		default:
			SetChoice(_defaultSelection);
			break;
		}
	}

	private void SetChoice(GameObject selection)
	{
		bool flag = !_supportsPooling;
		ApplyChoice(selection, Arid, flag);
		ApplyChoice(selection, Temperate, flag);
		ApplyChoice(selection, Tundra, flag);
		ApplyChoice(selection, Arctic, flag);
		if ((Object)(object)selection != (Object)null)
		{
			selection.SetActive(true);
		}
		if (flag)
		{
			GameManager.Destroy((Component)(object)this);
		}
	}

	private void ApplyChoice(GameObject selection, GameObject target, bool shouldDestroy)
	{
		if ((Object)(object)target != (Object)null && (Object)(object)target != (Object)(object)selection)
		{
			if (shouldDestroy)
			{
				GameManager.Destroy(target);
			}
			else
			{
				target.SetActive(false);
			}
		}
	}
}


using System;

[Serializable]
public class EnvironmentVolumeOverride
{
	public EnvironmentType Environment;

	public Enum Biome;
}


using UnityEngine;

public class RandomDestroy : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref num) > Probability)
		{
			GameManager.Destroy((Component)(object)this);
		}
		else
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
	}
}


using UnityEngine;

public class RandomDynamicObject : MonoBehaviour, IClientComponent, ILOD
{
	public uint Seed;

	public float Distance = 100f;

	public float Probability = 0.5f;

	public GameObject[] Candidates;
}


using UnityEngine;

public class RandomDynamicPrefab : MonoBehaviour, IClientComponent, ILOD
{
	public uint Seed;

	public float Distance = 100f;

	public float Probability = 0.5f;

	public string ResourceFolder = string.Empty;
}


using UnityEngine;

public class RandomStaticObject : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	public GameObject[] Candidates;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref num) > Probability)
		{
			for (int i = 0; i < Candidates.Length; i++)
			{
				GameManager.Destroy(Candidates[i]);
			}
			GameManager.Destroy((Component)(object)this);
			return;
		}
		int num2 = SeedRandom.Range(num, 0, ((Component)this).transform.childCount);
		for (int j = 0; j < Candidates.Length; j++)
		{
			GameObject val = Candidates[j];
			if (j == num2)
			{
				val.SetActive(true);
			}
			else
			{
				GameManager.Destroy(val);
			}
		}
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class RandomStaticPrefab : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	public string ResourceFolder = string.Empty;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint seed = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref seed) > Probability)
		{
			GameManager.Destroy((Component)(object)this);
			return;
		}
		Prefab.LoadRandom("assets/bundled/prefabs/autospawn/" + ResourceFolder, ref seed).Spawn(((Component)this).transform);
		GameManager.Destroy((Component)(object)this);
	}
}


public class ParticlePatch
{
}


using UnityEngine;

public class ParticleSpawn : SingletonComponent<ParticleSpawn>, IClientComponent
{
	public GameObjectRef[] Prefabs;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public Vector3 Origin { get; private set; }
}


using UnityEngine;

public class PowerlineNode : MonoBehaviour
{
	public GameObjectRef WirePrefab;

	public float MaxDistance = 50f;

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.AddWire(this);
		}
	}
}


using UnityEngine;

public class RemoveChildObjectsAlongPath : MonoBehaviour, IEditorComponent
{
	public Transform Node1;

	public Transform Node2;

	public float Distance;
}


using System.Collections.Generic;
using UnityEngine;

public class TerrainPathChildObjects : MonoBehaviour
{
	public bool Spline = true;

	public float Width;

	public float Offset;

	public float Fade;

	[InspectorFlags]
	public Enum Splat = (Enum)1;

	[InspectorFlags]
	public Enum Topology = (Enum)2048;

	public InfrastructureType Type;

	protected void Awake()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Expected I4, but got Unknown
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Expected I4, but got Unknown
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Expected I4, but got Unknown
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Expected I4, but got Unknown
		if (!World.Cached && !World.Networked)
		{
			List<Vector3> list = new List<Vector3>();
			foreach (Transform item in ((Component)this).transform)
			{
				Transform val = item;
				list.Add(val.position);
			}
			if (list.Count >= 2)
			{
				switch (Type)
				{
				case InfrastructureType.Road:
				{
					PathList pathList2 = new PathList("Road " + TerrainMeta.Path.Roads.Count, list.ToArray());
					pathList2.Width = Width;
					pathList2.InnerFade = Fade * 0.5f;
					pathList2.OuterFade = Fade * 0.5f;
					pathList2.MeshOffset = Offset * 0.3f;
					pathList2.TerrainOffset = Offset;
					pathList2.Topology = (int)Topology;
					pathList2.Splat = (int)Splat;
					pathList2.Spline = Spline;
					pathList2.Path.RecalculateTangents();
					TerrainMeta.Path.Roads.Add(pathList2);
					break;
				}
				case InfrastructureType.Power:
				{
					PathList pathList = new PathList("Powerline " + TerrainMeta.Path.Powerlines.Count, list.ToArray());
					pathList.Width = Width;
					pathList.InnerFade = Fade * 0.5f;
					pathList.OuterFade = Fade * 0.5f;
					pathList.MeshOffset = Offset * 0.3f;
					pathList.TerrainOffset = Offset;
					pathList.Topology = (int)Topology;
					pathList.Splat = (int)Splat;
					pathList.Spline = Spline;
					pathList.Path.RecalculateTangents();
					TerrainMeta.Path.Powerlines.Add(pathList);
					break;
				}
				}
			}
		}
		GameManager.Destroy(((Component)this).gameObject);
	}

	protected void OnDrawGizmos()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		Vector3 a = Vector3.zero;
		foreach (Transform item in ((Component)this).transform)
		{
			Vector3 position = item.position;
			if (flag)
			{
				Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
				GizmosUtil.DrawWirePath(a, position, 0.5f * Width);
			}
			a = position;
			flag = true;
		}
	}
}


using UnityEngine;

public class TerrainPathConnect : MonoBehaviour
{
	public InfrastructureType Type;

	public PathFinder.Point GetPathFinderPoint(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return PathFinder.GetPoint(((Component)this).transform.position, res);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathSequence : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(PathSequence);
	}

	public virtual void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
	}
}


using System.Collections.Generic;
using UnityEngine;

public class PathSequencePowerline : PathSequence
{
	public enum SequenceRule
	{
		PowerlinePlatform,
		Powerline
	}

	public SequenceRule Rule;

	private const int RegularPowerlineSpacing = 2;

	public override void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
		bool flag = false;
		if (Rule == SequenceRule.Powerline)
		{
			if (pathLength >= 3)
			{
				flag = sequence.Count == 0 || pathIndex == pathLength - 1;
				if (!flag)
				{
					flag = GetIndexCountToRule(sequence, SequenceRule.PowerlinePlatform) >= 2;
				}
			}
		}
		else if (Rule == SequenceRule.PowerlinePlatform)
		{
			flag = pathLength < 3;
			if (!flag)
			{
				int indexCountToRule = GetIndexCountToRule(sequence, SequenceRule.PowerlinePlatform);
				flag = indexCountToRule < 2 && indexCountToRule != sequence.Count && pathIndex < pathLength - 1;
			}
		}
		if (flag)
		{
			Prefab prefabOfType = GetPrefabOfType(possibleReplacements, (Rule == SequenceRule.PowerlinePlatform) ? SequenceRule.Powerline : SequenceRule.PowerlinePlatform);
			if (prefabOfType != null)
			{
				replacement = prefabOfType;
			}
		}
	}

	private Prefab GetPrefabOfType(Prefab[] options, SequenceRule ruleToFind)
	{
		for (int i = 0; i < options.Length; i++)
		{
			PathSequencePowerline pathSequencePowerline = options[i].Attribute.Find<PathSequence>(options[i].ID) as PathSequencePowerline;
			if (pathSequencePowerline == null || pathSequencePowerline.Rule == ruleToFind)
			{
				return options[i];
			}
		}
		return null;
	}

	private int GetIndexCountToRule(List<Prefab> sequence, SequenceRule rule)
	{
		int num = 0;
		for (int num2 = sequence.Count - 1; num2 >= 0; num2--)
		{
			PathSequencePowerline pathSequencePowerline = sequence[num2].Attribute.Find<PathSequence>(sequence[num2].ID) as PathSequencePowerline;
			if (pathSequencePowerline != null)
			{
				if (pathSequencePowerline.Rule == rule)
				{
					break;
				}
				num++;
			}
		}
		return num;
	}
}


public enum SequenceRule
{
	PowerlinePlatform,
	Powerline
}


using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Procedural/Mega Wire")]
public class PowerLineWire : MonoBehaviour
{
	public List<Transform> poles = new List<Transform>();

	public List<PowerLineWireConnectionDef> connections = new List<PowerLineWireConnectionDef>();

	public List<PowerLineWireSpan> spans = new List<PowerLineWireSpan>();

	public void Copy(PowerLineWire from, PowerLineWireConnectionHelper helper)
	{
		connections.Clear();
		if (Object.op_Implicit((Object)(object)helper))
		{
			for (int i = 0; i < helper.connections.Count; i++)
			{
				connections.Add(new PowerLineWireConnectionDef(helper.connections[i]));
			}
		}
		else
		{
			for (int j = 0; j < from.connections.Count; j++)
			{
				connections.Add(new PowerLineWireConnectionDef(from.connections[j]));
			}
		}
	}

	public static PowerLineWire Create(PowerLineWire wire, List<GameObject> objs, GameObjectRef wirePrefab, string name, PowerLineWire copyfrom, float wiresize, float str)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Expected O, but got Unknown
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (objs != null && objs.Count > 1)
		{
			GameObject val = null;
			if ((Object)(object)wire == (Object)null)
			{
				val = new GameObject();
				((Object)val).name = name;
				wire = val.AddComponent<PowerLineWire>();
			}
			else
			{
				val = ((Component)wire).gameObject;
			}
			wire.poles.Clear();
			wire.spans.Clear();
			wire.connections.Clear();
			wire.poles.Add(objs[0].transform);
			for (int i = 0; i < objs.Count - 1; i++)
			{
				GameObject val2 = new GameObject
				{
					name = name + " Span Mesh " + i
				};
				val2.transform.parent = val.transform;
				PowerLineWireSpan powerLineWireSpan = val2.AddComponent<PowerLineWireSpan>();
				powerLineWireSpan.wirePrefab = wirePrefab;
				powerLineWireSpan.start = objs[i].transform;
				powerLineWireSpan.end = objs[i + 1].transform;
				wire.spans.Add(powerLineWireSpan);
				wire.poles.Add(objs[i + 1].transform);
			}
			PowerLineWireConnectionHelper component = objs[0].GetComponent<PowerLineWireConnectionHelper>();
			if (Object.op_Implicit((Object)(object)copyfrom))
			{
				wire.Copy(copyfrom, component);
			}
			else if (Object.op_Implicit((Object)(object)component))
			{
				wire.Copy(wire, component);
			}
			else
			{
				PowerLineWireConnectionDef item = new PowerLineWireConnectionDef();
				wire.connections.Add(item);
			}
			if (wiresize != 1f)
			{
				for (int j = 0; j < wire.connections.Count; j++)
				{
					wire.connections[j].radius *= wiresize;
				}
			}
			wire.Init();
		}
		return wire;
	}

	public void Init()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < spans.Count; i++)
		{
			PowerLineWireSpan powerLineWireSpan = spans[i];
			powerLineWireSpan.connections.Clear();
			for (int j = 0; j < connections.Count; j++)
			{
				PowerLineWireConnection powerLineWireConnection = new PowerLineWireConnection
				{
					start = powerLineWireSpan.start,
					end = powerLineWireSpan.end,
					inOffset = connections[j].inOffset,
					outOffset = connections[j].outOffset,
					radius = connections[j].radius
				};
				PowerLineWireConnectionHelper component = ((Component)powerLineWireSpan.start).GetComponent<PowerLineWireConnectionHelper>();
				PowerLineWireConnectionHelper component2 = ((Component)powerLineWireSpan.end).GetComponent<PowerLineWireConnectionHelper>();
				powerLineWireConnection.inOffset = component2.connections[j].inOffset;
				powerLineWireConnection.outOffset = component.connections[j].outOffset;
				if (!component.connections[j].hidden && !component2.connections[j].hidden)
				{
					powerLineWireSpan.connections.Add(powerLineWireConnection);
				}
			}
			powerLineWireSpan.Init(this);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class PowerLineWireConnectionDef
{
	public Vector3 inOffset = Vector3.zero;

	public Vector3 outOffset = Vector3.zero;

	public float radius = 0.01f;

	public bool hidden;

	public PowerLineWireConnectionDef()
	{
	}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
	//IL_0006: Unknown result type (might be due to invalid IL or missing references)
	//IL_000c: Unknown result type (might be due to invalid IL or missing references)
	//IL_0011: Unknown result type (might be due to invalid IL or missing references)


	public PowerLineWireConnectionDef(PowerLineWireConnectionDef src)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		inOffset = src.inOffset;
		outOffset = src.outOffset;
		radius = src.radius;
	}
}


using System;
using UnityEngine;

[Serializable]
public class PowerLineWireConnection
{
	public Vector3 inOffset = Vector3.zero;

	public Vector3 outOffset = Vector3.zero;

	public float radius = 0.01f;

	public Transform start;

	public Transform end;
}


using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Mega Wire/Connection Helper")]
public class PowerLineWireConnectionHelper : MonoBehaviour
{
	public List<PowerLineWireConnectionDef> connections = new List<PowerLineWireConnectionDef>();

	public bool showgizmo;
}


using System.Collections.Generic;
using UnityEngine;

public class PowerLineWireSpan : MonoBehaviour
{
	public GameObjectRef wirePrefab;

	public Transform start;

	public Transform end;

	public float WireLength;

	public List<PowerLineWireConnection> connections = new List<PowerLineWireConnection>();

	public void Init(PowerLineWire wire)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)start) && Object.op_Implicit((Object)(object)end))
		{
			WireLength = Vector3.Distance(start.position, end.position);
			for (int i = 0; i < connections.Count; i++)
			{
				Vector3 val = start.TransformPoint(connections[i].outOffset);
				Vector3 val2 = end.TransformPoint(connections[i].inOffset);
				Vector3 val3 = val - val2;
				WireLength = ((Vector3)(ref val3)).magnitude;
				GameObject obj = wirePrefab.Instantiate(((Component)this).transform);
				((Object)obj).name = "WIRE";
				obj.transform.position = Vector3.Lerp(val, val2, 0.5f);
				obj.transform.LookAt(val2);
				obj.transform.localScale = new Vector3(1f, 1f, Vector3.Distance(val, val2));
				obj.SetActive(true);
			}
		}
	}
}


using UnityEngine;

public class ApplyTerrainAnchors : MonoBehaviour
{
	protected void Awake()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		TerrainAnchor[] anchors = null;
		if (component.isServer)
		{
			anchors = PrefabAttribute.server.FindAll<TerrainAnchor>(component.prefabID);
		}
		((Component)this).transform.ApplyTerrainAnchors(anchors);
		GameManager.Destroy((Component)(object)this);
	}
}


using System;
using UnityEngine;

public class TerrainAnchor : PrefabAttribute
{
	public float Extents = 1f;

	public float Offset;

	public float Radius;

	public float SlopeScale;

	public void Apply(out float height, out float min, out float max, Vector3 pos, Vector3 scale, Quaternion rotation)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f + SlopeScale * Mathf.InverseLerp(0f, 90f, Vector3.Angle(Vector3.up, rotation * Vector3.up));
		float num2 = Extents * scale.y * num;
		float num3 = Offset * scale.y * num;
		height = TerrainMeta.HeightMap.GetHeight(pos);
		min = height - num3 - num2;
		max = height - num3 + num2;
		if (!(Radius > 0f))
		{
			return;
		}
		int num4 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(pos.x - Radius));
		int num5 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(pos.x + Radius));
		int num6 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(pos.z - Radius));
		int num7 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(pos.z + Radius));
		for (int i = num6; i <= num7; i++)
		{
			if (max < min)
			{
				break;
			}
			for (int j = num4; j <= num5; j++)
			{
				if (max < min)
				{
					break;
				}
				float height2 = TerrainMeta.HeightMap.GetHeight(j, i);
				min = Mathf.Max(min, height2 - num3 - num2);
				max = Mathf.Min(max, height2 - num3 + num2);
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainAnchor);
	}
}


public enum TerrainAnchorMode
{
	MinimizeError,
	MinimizeMovement,
	MaximizeHeight
}


using UnityEngine;

public static class TerrainAnchorEx
{
	public static bool ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors, ref Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return transform.ApplyTerrainAnchors(anchors, ref pos, rot, scale, TerrainAnchorMode.MinimizeError, filter);
	}

	public static bool ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors, ref Vector3 pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter = null)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		float num = 0f;
		float num2 = float.MinValue;
		float num3 = float.MaxValue;
		foreach (TerrainAnchor terrainAnchor in anchors)
		{
			Vector3 val = Vector3.Scale(terrainAnchor.worldPosition, scale);
			val = rot * val;
			Vector3 val2 = pos + val;
			if (filter != null && filter.GetFactor(val2) == 0f)
			{
				return false;
			}
			terrainAnchor.Apply(out var height, out var min, out var max, val2, scale, rot);
			num += height - val.y;
			num2 = Mathf.Max(num2, min - val.y);
			num3 = Mathf.Min(num3, max - val.y);
			if (num3 < num2)
			{
				return false;
			}
		}
		if (num3 > 1f && num2 < 1f)
		{
			num2 = 1f;
		}
		switch (mode)
		{
		case TerrainAnchorMode.MinimizeError:
			pos.y = Mathf.Clamp(num / (float)anchors.Length, num2, num3);
			break;
		case TerrainAnchorMode.MinimizeMovement:
			pos.y = Mathf.Clamp(pos.y, num2, num3);
			break;
		default:
			pos.y = num3;
			break;
		}
		return true;
	}

	public static void ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		transform.ApplyTerrainAnchors(anchors, ref pos, transform.rotation, transform.lossyScale);
		transform.position = pos;
	}
}


using UnityEngine;

public class TerrainAnchorGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementPadding;

	public float PlacementFade = 16f;

	public float PlacementDistance = 8f;

	public float AnchorExtentsMin = 8f;

	public float AnchorExtentsMax = 16f;

	public float AnchorOffsetMin;

	public float AnchorOffsetMax;
}


using System;
using UnityEngine;

public class TerrainCheck : PrefabAttribute
{
	public bool Rotate = true;

	public float Extents = 1f;

	public bool Check(Vector3 pos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float extents = Extents;
		float height = TerrainMeta.HeightMap.GetHeight(pos);
		float num = pos.y - extents;
		float num2 = pos.y + extents;
		if (num > height)
		{
			return false;
		}
		if (num2 < height)
		{
			return false;
		}
		return true;
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainCheck);
	}
}


using UnityEngine;

public static class TerrainCheckEx
{
	public static bool ApplyTerrainChecks(this Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		foreach (TerrainCheck terrainCheck in anchors)
		{
			Vector3 val = Vector3.Scale(terrainCheck.worldPosition, scale);
			if (terrainCheck.Rotate)
			{
				val = rot * val;
			}
			Vector3 val2 = pos + val;
			if (filter != null && filter.GetFactor(val2) == 0f)
			{
				return false;
			}
			if (!terrainCheck.Check(val2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class TerrainCheckGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementPadding;

	public float PlacementFade = 16f;

	public float PlacementDistance = 8f;

	public float CheckExtentsMin = 8f;

	public float CheckExtentsMax = 16f;

	public bool CheckRotate = true;
}


using UnityEngine;

public class TerrainCheckGeneratorVolumes : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius;

	public float PlacementOffset;

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, PlacementRadius);
	}
}


using System;

public interface ICoarseQueryGridProvider : IDisposable
{
	CoarseQueryGrid GetQueryGrid();
}


using System;
using CoarseQueryGridJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[GenerateTestsForBurstCompatibility]
public struct CoarseQueryGrid : IDisposable
{
	public struct RefCountedSpatialArray : IDisposable
	{
		private NativeArray<byte> _array;

		public NativeArray<byte> RawArray => _array;

		public int Length => _array.Length;

		public static RefCountedSpatialArray Init(int length)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			RefCountedSpatialArray result = default(RefCountedSpatialArray);
			result._array = new NativeArray<byte>(length, (Allocator)4, (NativeArrayOptions)1);
			return result;
		}

		public void Add(int index)
		{
			Debug.Assert(_array[index] != byte.MaxValue);
			ref NativeArray<byte> array = ref _array;
			byte b = array[index];
			array[index] = (byte)(b + 1);
		}

		public void Remove(int index)
		{
			Debug.Assert(_array[index] != 0);
			ref NativeArray<byte> array = ref _array;
			byte b = array[index];
			array[index] = (byte)(b - 1);
		}

		public bool Get(int index)
		{
			return _array[index] > 0;
		}

		public void Dispose()
		{
			_array.Dispose();
		}
	}

	private const float StaticBoundsInflation = 0.1f;

	private readonly int _cellXZDimensionCount;

	private readonly Vector2 _gridCentre;

	private readonly float _yCutoff;

	private readonly int _cellSize;

	private readonly int _cellClampLimit;

	private NativeReference<bool> _result;

	private bool _hasDisposed;

	private NativeList<Bounds> _dynamicBounds;

	private RefCountedSpatialArray _upperStaticSpatialArray;

	private RefCountedSpatialArray _lowerStaticSpatialArray;

	public CoarseQueryGrid(int cellSize, int maxWorldSizeXZ, float yCutoff)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		_cellSize = cellSize;
		_cellXZDimensionCount = (int)((float)(maxWorldSizeXZ / cellSize) + 0.5f);
		_gridCentre = new Vector2((float)maxWorldSizeXZ * 0.5f, (float)maxWorldSizeXZ * 0.5f);
		_yCutoff = yCutoff;
		_hasDisposed = false;
		_result = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
		_upperStaticSpatialArray = RefCountedSpatialArray.Init(_cellXZDimensionCount * _cellXZDimensionCount);
		_lowerStaticSpatialArray = RefCountedSpatialArray.Init(_cellXZDimensionCount * _cellXZDimensionCount);
		_dynamicBounds = new NativeList<Bounds>(AllocatorHandle.op_Implicit((Allocator)4));
		_cellClampLimit = _upperStaticSpatialArray.Length - 1;
	}

	private bool TouchesUpperSpatial(Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref bounds)).max.y >= _yCutoff;
	}

	private bool TouchesUpperSpatial(Vector3 pos, float r)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return pos.y + r >= _yCutoff;
	}

	private bool TouchesLowerSpatial(Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref bounds)).min.y <= _yCutoff;
	}

	private bool TouchesLowerSpatial(Vector3 pos, float r)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return pos.y - r <= _yCutoff;
	}

	public void PrepareForDynamicPopulate(int dynamicCount)
	{
		if (!_hasDisposed)
		{
			_dynamicBounds.Clear();
			if (_dynamicBounds.Capacity < dynamicCount)
			{
				_dynamicBounds.SetCapacity(dynamicCount);
			}
		}
	}

	private bool CheckStateAdd()
	{
		if (_hasDisposed)
		{
			Debug.LogError((object)"Adding bounds to disposed CoarseQueryGrid");
		}
		return _hasDisposed;
	}

	public void AddDynamic(Bounds bounds)
	{
		if (!CheckStateAdd())
		{
			_dynamicBounds.Add(ref bounds);
		}
	}

	public void AddStatic(Bounds bounds)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckStateAdd())
		{
			((Bounds)(ref bounds)).Expand(0.1f);
			Vector2i min = WorldPosToStaticGrid(((Bounds)(ref bounds)).min);
			Vector2i max = WorldPosToStaticGrid(((Bounds)(ref bounds)).max);
			if (TouchesUpperSpatial(bounds))
			{
				AddStatic(min, max, _upperStaticSpatialArray);
			}
			if (TouchesLowerSpatial(bounds))
			{
				AddStatic(min, max, _lowerStaticSpatialArray);
			}
		}
	}

	private void AddStatic(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				spatial.Add(index);
			}
		}
	}

	public void RemoveStatic(Bounds bounds)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!_hasDisposed)
		{
			((Bounds)(ref bounds)).Expand(0.1f);
			Vector2i min = WorldPosToStaticGrid(((Bounds)(ref bounds)).min);
			Vector2i max = WorldPosToStaticGrid(((Bounds)(ref bounds)).max);
			if (TouchesUpperSpatial(bounds))
			{
				RemoveStatic(min, max, _upperStaticSpatialArray);
			}
			if (TouchesLowerSpatial(bounds))
			{
				RemoveStatic(min, max, _lowerStaticSpatialArray);
			}
		}
	}

	private void RemoveStatic(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				spatial.Remove(index);
			}
		}
	}

	public bool CheckJob(Bounds checkBounds)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		CheckBoundsJob checkBoundsJob = default(CheckBoundsJob);
		checkBoundsJob.Grid = this;
		checkBoundsJob.CheckBounds = checkBounds;
		checkBoundsJob.Result = _result;
		CheckBoundsJob checkBoundsJob2 = checkBoundsJob;
		IJobExtensions.RunByRef<CheckBoundsJob>(ref checkBoundsJob2);
		return _result.Value;
	}

	public bool Check(Bounds checkBounds)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector2i min = WorldPosToStaticGrid(((Bounds)(ref checkBounds)).min);
		Vector2i max = WorldPosToStaticGrid(((Bounds)(ref checkBounds)).max);
		if (TouchesUpperSpatial(checkBounds) && Check(min, max, _upperStaticSpatialArray))
		{
			return true;
		}
		if (TouchesLowerSpatial(checkBounds) && Check(min, max, _lowerStaticSpatialArray))
		{
			return true;
		}
		Enumerator<Bounds> enumerator = _dynamicBounds.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Bounds current = enumerator.Current;
				if (((Bounds)(ref current)).Intersects(checkBounds))
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	private bool Check(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				if (spatial.Get(index))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool CheckJob(Vector3 worldPosition, float radius)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		CheckPosRadJob checkPosRadJob = default(CheckPosRadJob);
		checkPosRadJob.Grid = this;
		checkPosRadJob.CheckPos = worldPosition;
		checkPosRadJob.CheckRad = radius;
		checkPosRadJob.Result = _result;
		CheckPosRadJob checkPosRadJob2 = checkPosRadJob;
		IJobExtensions.RunByRef<CheckPosRadJob>(ref checkPosRadJob2);
		return _result.Value;
	}

	public JobHandle CheckJob(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckPosRadBatchJob checkPosRadBatchJob = default(CheckPosRadBatchJob);
		checkPosRadBatchJob.Grid = this;
		checkPosRadBatchJob.Pos = worldPositions;
		checkPosRadBatchJob.Radii = radii;
		checkPosRadBatchJob.OverlapIndices = overlapIndices;
		CheckPosRadBatchJob checkPosRadBatchJob2 = checkPosRadBatchJob;
		return IJobExtensions.ScheduleByRef<CheckPosRadBatchJob>(ref checkPosRadBatchJob2, default(JobHandle));
	}

	public JobHandle CheckJobIndirect(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckPosRadBatchJobIndirect checkPosRadBatchJobIndirect = default(CheckPosRadBatchJobIndirect);
		checkPosRadBatchJobIndirect.Grid = this;
		checkPosRadBatchJobIndirect.Pos = worldPositions;
		checkPosRadBatchJobIndirect.Radii = radii;
		checkPosRadBatchJobIndirect.OverlapIndices = overlapIndices;
		checkPosRadBatchJobIndirect.Indices = indices;
		CheckPosRadBatchJobIndirect checkPosRadBatchJobIndirect2 = checkPosRadBatchJobIndirect;
		return IJobExtensions.ScheduleByRef<CheckPosRadBatchJobIndirect>(ref checkPosRadBatchJobIndirect2, default(JobHandle));
	}

	public bool Check(Vector3 worldPosition, float radius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector2i min = WorldPosToStaticGrid(worldPosition - Vector3.one * radius);
		Vector2i max = WorldPosToStaticGrid(worldPosition + Vector3.one * radius);
		if (TouchesUpperSpatial(worldPosition, radius) && Check(min, max, _upperStaticSpatialArray))
		{
			return true;
		}
		if (TouchesLowerSpatial(worldPosition, radius) && Check(min, max, _lowerStaticSpatialArray))
		{
			return true;
		}
		float num = radius * radius;
		Enumerator<Bounds> enumerator = _dynamicBounds.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Bounds current = enumerator.Current;
				if (Vector3.SqrMagnitude(((Bounds)(ref current)).ClosestPoint(worldPosition) - worldPosition) <= num)
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	public bool CheckJob(Vector3 start, Vector3 end, float radius)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector3 val = Vector3.one * radius;
		Vector3 val2 = Vector3.Min(start, end) - val;
		Vector3 val3 = Vector3.Max(start, end) + val;
		Bounds checkBounds = default(Bounds);
		((Bounds)(ref checkBounds))..ctor((val3 + val2) * 0.5f, val3 - val2);
		return CheckJob(checkBounds);
	}

	public JobHandle CheckJobIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckBoundsJobIndirect checkBoundsJobIndirect = default(CheckBoundsJobIndirect);
		checkBoundsJobIndirect.Grid = this;
		checkBoundsJobIndirect.Starts = starts;
		checkBoundsJobIndirect.Ends = ends;
		checkBoundsJobIndirect.Radii = radii;
		checkBoundsJobIndirect.OverlapIndices = overlapIndices;
		checkBoundsJobIndirect.Indices = indices;
		CheckBoundsJobIndirect checkBoundsJobIndirect2 = checkBoundsJobIndirect;
		return IJobExtensions.ScheduleByRef<CheckBoundsJobIndirect>(ref checkBoundsJobIndirect2, default(JobHandle));
	}

	public bool Check(Vector3 start, Vector3 end, float radius)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector3 val = Vector3.one * radius;
		Vector3 val2 = Vector3.Min(start, end) - val;
		Vector3 val3 = Vector3.Max(start, end) + val;
		Bounds checkBounds = default(Bounds);
		((Bounds)(ref checkBounds))..ctor((val3 + val2) * 0.5f, val3 - val2);
		return Check(checkBounds);
	}

	private Vector2i WorldPosToStaticGrid(Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)((worldPosition.x + _gridCentre.x) / (float)_cellSize), (int)((worldPosition.z + _gridCentre.y) / (float)_cellSize));
	}

	private int GridToStaticIndex(Vector2i gridPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return math.clamp(gridPosition.x + gridPosition.y * _cellXZDimensionCount, 0, _cellClampLimit);
	}

	public void Dispose()
	{
		_hasDisposed = true;
		_result.Dispose();
		_dynamicBounds.Dispose();
		_upperStaticSpatialArray.Dispose();
		_lowerStaticSpatialArray.Dispose();
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public struct RefCountedSpatialArray : IDisposable
{
	private NativeArray<byte> _array;

	public NativeArray<byte> RawArray => _array;

	public int Length => _array.Length;

	public static RefCountedSpatialArray Init(int length)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		RefCountedSpatialArray result = default(RefCountedSpatialArray);
		result._array = new NativeArray<byte>(length, (Allocator)4, (NativeArrayOptions)1);
		return result;
	}

	public void Add(int index)
	{
		Debug.Assert(_array[index] != byte.MaxValue);
		ref NativeArray<byte> array = ref _array;
		byte b = array[index];
		array[index] = (byte)(b + 1);
	}

	public void Remove(int index)
	{
		Debug.Assert(_array[index] != 0);
		ref NativeArray<byte> array = ref _array;
		byte b = array[index];
		array[index] = (byte)(b - 1);
	}

	public bool Get(int index)
	{
		return _array[index] > 0;
	}

	public void Dispose()
	{
		_array.Dispose();
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Terrain Atlas Set")]
public class TerrainAtlasSet : ScriptableObject
{
	public enum SourceType
	{
		ALBEDO,
		NORMAL,
		PACKED,
		COUNT
	}

	[Serializable]
	public class SourceMapSet
	{
		public Texture2D[] maps;

		internal void CheckReset()
		{
			if (maps == null)
			{
				maps = (Texture2D[])(object)new Texture2D[8];
			}
			else if (maps.Length != 8)
			{
				Array.Resize(ref maps, 8);
			}
		}
	}

	public const int SplatCount = 8;

	public const int SplatSize = 2048;

	public const int MaxSplatSize = 2047;

	public const int SplatPadding = 256;

	public const int AtlasSize = 8192;

	public const int RegionSize = 2560;

	public const int SplatsPerLine = 3;

	public const int SourceTypeCount = 3;

	public const int AtlasMipCount = 10;

	public static string[] sourceTypeNames = new string[3] { "Albedo", "Normal", "Packed" };

	public static string[] sourceTypeNamesExt = new string[3] { "Albedo (rgb)", "Normal (rgb)", "Metal[ignored]_Height_AO_Gloss (rgba)" };

	public static string[] sourceTypePostfix = new string[3] { "_albedo", "_normal", "_metal_hm_ao_gloss" };

	public string[] splatNames;

	public bool[] albedoHighpass;

	public string[] albedoPaths;

	public Color[] defaultValues;

	public SourceMapSet[] sourceMaps;

	public bool highQualityCompression = true;

	public bool generateTextureAtlases = true;

	public bool generateTextureArrays;

	public string splatSearchPrefix = "terrain_";

	public string splatSearchFolder = "Assets/Content/Nature/Terrain";

	public string albedoAtlasSavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_albedo_atlas";

	public string normalAtlasSavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_normal_atlas";

	public string albedoArraySavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_albedo_array";

	public string normalArraySavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_normal_array";

	public void CheckReset()
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (splatNames == null)
		{
			splatNames = new string[8] { "Dirt", "Snow", "Sand", "Rock", "Grass", "Forest", "Stones", "Gravel" };
		}
		else if (splatNames.Length != 8)
		{
			Array.Resize(ref splatNames, 8);
		}
		if (albedoHighpass == null)
		{
			albedoHighpass = new bool[8];
		}
		else if (albedoHighpass.Length != 8)
		{
			Array.Resize(ref albedoHighpass, 8);
		}
		if (albedoPaths == null)
		{
			albedoPaths = new string[8];
		}
		else if (albedoPaths.Length != 8)
		{
			Array.Resize(ref albedoPaths, 8);
		}
		if (defaultValues == null)
		{
			defaultValues = (Color[])(object)new Color[3]
			{
				new Color(1f, 1f, 1f, 0.5f),
				new Color(0.5f, 0.5f, 1f, 0f),
				new Color(0f, 0f, 1f, 0.5f)
			};
		}
		else if (defaultValues.Length != 3)
		{
			Array.Resize(ref defaultValues, 3);
		}
		if (sourceMaps == null)
		{
			sourceMaps = new SourceMapSet[3];
		}
		else if (sourceMaps.Length != 3)
		{
			Array.Resize(ref sourceMaps, 3);
		}
		for (int i = 0; i < 3; i++)
		{
			sourceMaps[i] = ((sourceMaps[i] != null) ? sourceMaps[i] : new SourceMapSet());
			sourceMaps[i].CheckReset();
		}
	}
}


public enum SourceType
{
	ALBEDO,
	NORMAL,
	PACKED,
	COUNT
}


using System;
using UnityEngine;

[Serializable]
public class SourceMapSet
{
	public Texture2D[] maps;

	internal void CheckReset()
	{
		if (maps == null)
		{
			maps = (Texture2D[])(object)new Texture2D[8];
		}
		else if (maps.Length != 8)
		{
			Array.Resize(ref maps, 8);
		}
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public class TerrainCollision : TerrainExtension
{
	public TerrainIgnoreGrid TerrainIgnoreGrid;

	public ListDictionary<Collider, List<Collider>> ignoredColliders;

	public TerrainCollider terrainCollider;

	public const float IgnoreRadius = 0.01f;

	public override void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		terrainCollider = ((Component)terrain).GetComponent<TerrainCollider>();
		TerrainIgnoreGrid = new TerrainIgnoreGrid();
	}

	private void OnDestroy()
	{
		TerrainIgnoreGrid.Dispose();
	}

	public void Clear()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)terrainCollider))
		{
			return;
		}
		Enumerator<Collider> enumerator = ignoredColliders.Keys.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Physics.IgnoreCollision(enumerator.Current, (Collider)(object)terrainCollider, false);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if (Object.op_Implicit((Object)(object)terrainCollider) && Object.op_Implicit((Object)(object)collider))
		{
			Physics.IgnoreCollision(collider, (Collider)(object)terrainCollider, false);
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			if (TerrainIgnoreGrid != null && !TerrainIgnoreGrid.Check(pos, radius))
			{
				return false;
			}
			return GamePhysics.CheckSphere<TerrainCollisionTrigger>(pos, radius, 262144, (QueryTriggerInteraction)2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetIgnore(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> val2 = new NativeList<int>(positions.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val3;
			if (TerrainIgnoreGrid != null)
			{
				val3 = TerrainIgnoreGrid.Check(positions, radii, val2);
			}
			else
			{
				GenerateAscSeqListJob generateAscSeqListJob = default(GenerateAscSeqListJob);
				generateAscSeqListJob.Values = val2;
				generateAscSeqListJob.Start = 0;
				generateAscSeqListJob.Step = 1;
				generateAscSeqListJob.Count = positions.Length;
				val3 = IJobExtensions.Schedule<GenerateAscSeqListJob>(generateAscSeqListJob, default(JobHandle));
			}
			((JobHandle)(ref val3)).Complete();
			if (!val2.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = positions;
				gatherJob.Indices = val2.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = val2.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				new QueryParameters(262144, false, (QueryTriggerInteraction)2, false);
				GamePhysics.CheckSpheres<TerrainCollisionTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref results), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				Span<bool> values2 = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = val2.AsReadOnly();
				CollectionUtil.ScatterOutInplace(values2, ReadOnly<int>.op_Implicit(ref val4), defValue: false);
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(RaycastHit hit)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			if (!(((RaycastHit)(ref hit)).collider is TerrainCollider))
			{
				return false;
			}
			if (!TerrainIgnoreGrid.Check(((RaycastHit)(ref hit)).point))
			{
				return false;
			}
			return ((RaycastHit)(ref hit)).collider is TerrainCollider && GetIgnore(((RaycastHit)(ref hit)).point);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(Collider collider)
	{
		if (!Object.op_Implicit((Object)(object)terrainCollider) || !Object.op_Implicit((Object)(object)collider))
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (!Object.op_Implicit((Object)(object)terrainCollider) || !Object.op_Implicit((Object)(object)collider))
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> list = new List<Collider> { trigger };
				Physics.IgnoreCollision(collider, (Collider)(object)terrainCollider, true);
				ignoredColliders.Add(collider, list);
			}
			return;
		}
		List<Collider> list2 = ignoredColliders[collider];
		if (ignore)
		{
			if (!list2.Contains(trigger))
			{
				list2.Add(trigger);
			}
		}
		else if (list2.Contains(trigger))
		{
			list2.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if ((Object)(object)key == (Object)null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				Physics.IgnoreCollision(key, (Collider)(object)terrainCollider, false);
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}


using UnityEngine;

public class TerrainCollisionProxy : MonoBehaviour, IServerComponent
{
	public WheelCollider[] colliders;
}


using Rust;
using UnityEngine;

public class TerrainCollisionTrigger : EnvironmentVolumeTrigger
{
	protected override void OnVolumeTriggerUpdate()
	{
		TerrainMeta.Collision.TerrainIgnoreGrid.AddTrigger(this);
	}

	private void OnDisable()
	{
		if (!Application.isUnloadingWorld)
		{
			TerrainMeta.Collision.TerrainIgnoreGrid.RemoveTrigger(this);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !other.isTrigger)
		{
			UpdateCollider(other, state: true);
		}
	}

	protected void OnTriggerExit(Collider other)
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !other.isTrigger)
		{
			UpdateCollider(other, state: false);
		}
	}

	private void UpdateCollider(Collider other, bool state)
	{
		TerrainMeta.Collision.SetIgnore(other, base.volume.trigger, state);
		TerrainCollisionProxy component = ((Component)other).GetComponent<TerrainCollisionProxy>();
		if (Object.op_Implicit((Object)(object)component))
		{
			for (int i = 0; i < component.colliders.Length; i++)
			{
				TerrainMeta.Collision.SetIgnore((Collider)(object)component.colliders[i], base.volume.trigger, state);
			}
		}
	}
}


using UnityEngine;

public class TerrainColors : TerrainExtension
{
	private TerrainSplatMap splatMap;

	private TerrainBiomeMap biomeMap;

	public override void Setup()
	{
		splatMap = ((Component)terrain).GetComponent<TerrainSplatMap>();
		biomeMap = ((Component)terrain).GetComponent<TerrainBiomeMap>();
	}

	public Color GetColor(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetColor(normX, normZ, mask);
	}

	public Color GetColor(float normX, float normZ, int mask = -1)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		float biome = biomeMap.GetBiome(normX, normZ, 1);
		float biome2 = biomeMap.GetBiome(normX, normZ, 2);
		float biome3 = biomeMap.GetBiome(normX, normZ, 4);
		float biome4 = biomeMap.GetBiome(normX, normZ, 8);
		int num = TerrainSplat.TypeToIndex(splatMap.GetSplatMaxType(normX, normZ, mask));
		TerrainConfig.SplatType splatType = config.Splats[num];
		return biome * splatType.AridColor + biome2 * splatType.TemperateColor + biome3 * splatType.TundraColor + biome4 * splatType.ArcticColor;
	}
}


using System;
using Facepunch.Extend;
using UnityEngine;

[RequireComponent(typeof(TerrainMeta))]
public abstract class TerrainExtension : MonoBehaviour
{
	[NonSerialized]
	public bool isInitialized;

	internal Terrain terrain;

	internal TerrainConfig config;

	public void Init(Terrain terrain, TerrainConfig config)
	{
		this.terrain = terrain;
		this.config = config;
	}

	public virtual void Setup()
	{
	}

	public virtual void PostSetup()
	{
	}

	public void LogSize(object obj, ulong size)
	{
		Debug.Log((object)(obj.GetType()?.ToString() + " allocated: " + NumberExtensions.FormatBytes<ulong>(size, false)));
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainIgnoreGrid : ICoarseQueryGridProvider, IDisposable
{
	private CoarseQueryGrid _queryGrid;

	private const int CellSize = 8;

	public TerrainIgnoreGrid()
	{
		_queryGrid = new CoarseQueryGrid(8, (int)(World.Size + 1000), -5f);
	}

	public CoarseQueryGrid GetQueryGrid()
	{
		return _queryGrid;
	}

	public void AddTrigger(TerrainCollisionTrigger trigger)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.AddStatic(trigger.volume.trigger.bounds);
	}

	public void RemoveTrigger(TerrainCollisionTrigger trigger)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.RemoveStatic(trigger.volume.trigger.bounds);
	}

	public bool Check(Vector3 pos, float radius)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainIgnoreGrid.Check(pos,rad)", 0);
		try
		{
			return _queryGrid.CheckJob(pos, radius);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public JobHandle Check(ReadOnly<Vector3> starts, ReadOnly<float> radii, NativeList<int> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return _queryGrid.CheckJob(starts, radii, results);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return _queryGrid.CheckJobIndirect(pos, radii, indices, results);
	}

	public bool Check(Vector3 pos)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerraingIgnoreGrid.Check(pos)", 0);
		try
		{
			return _queryGrid.CheckJob(pos, 0f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Dispose()
	{
		_queryGrid.Dispose();
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

public class TerrainAlphaMap : TerrainMap<byte>
{
	[FormerlySerializedAs("ColorTexture")]
	public Texture2D AlphaTexture;

	private bool _generatedAlphaTexture;

	public override void Setup()
	{
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				dst[i * res + j] = byte.MaxValue;
			}
		}
		if (!((Object)(object)AlphaTexture != (Object)null))
		{
			return;
		}
		if (((Texture)AlphaTexture).width == ((Texture)AlphaTexture).height && ((Texture)AlphaTexture).width == res)
		{
			Color32[] pixels = AlphaTexture.GetPixels32();
			int k = 0;
			int num = 0;
			for (; k < res; k++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					dst[k * res + num2] = pixels[num].a;
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid alpha texture: " + ((Object)AlphaTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedAlphaTexture && (Object)(object)AlphaTexture != (Object)null)
		{
			Object.Destroy((Object)(object)AlphaTexture);
			AlphaTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		AlphaTexture = new Texture2D(res, res, (TextureFormat)1, false, true);
		((Object)AlphaTexture).name = "AlphaTexture";
		((Texture)AlphaTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				byte b = src[z * res + i];
				col[z * res + i] = new Color32(b, b, b, b);
			}
		});
		AlphaTexture.SetPixels32(col);
		_generatedAlphaTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		AlphaTexture.Apply(true, false);
		AlphaTexture.Compress(false);
		AlphaTexture.Apply(false, true);
	}

	public float GetAlpha(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetAlpha(normX, normZ);
	}

	public float GetAlpha(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetAlpha(num4, num5), GetAlpha(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetAlpha(num4, z), GetAlpha(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetAlpha(int x, int z)
	{
		return BitUtility.Byte2Float((int)src[z * res + x]);
	}

	public void SetAlpha(Vector3 worldPos, float a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a);
	}

	public void SetAlpha(float normX, float normZ, float a)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetAlpha(x, z, a);
	}

	public void SetAlpha(int x, int z, float a)
	{
		dst[z * res + x] = BitUtility.Float2Byte(a);
	}

	public void SetAlpha(int x, int z, float a, float opacity)
	{
		SetAlpha(x, z, Mathf.Lerp(GetAlpha(x, z), a, opacity));
	}

	public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a, opacity, radius, fade);
	}

	public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			lerp *= opacity;
			if (lerp > 0f)
			{
				SetAlpha(x, z, a, lerp);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainBiomeMap : TerrainMap<byte>
{
	public Texture2D BiomeTexture;

	private bool _generatedBiomeTexture;

	internal int num;

	public override void Setup()
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		this.num = 5;
		InitArrays(this.num * res * res);
		if (!((Object)(object)BiomeTexture != (Object)null))
		{
			return;
		}
		if (((Texture)BiomeTexture).width == ((Texture)BiomeTexture).height && ((Texture)BiomeTexture).width == res)
		{
			Color32[] pixels = BiomeTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					ref NativeArray<byte> reference = ref dst;
					_ = res;
					reference[(0 + i) * res + num2] = val.r;
					dst[(res + i) * res + num2] = val.g;
					dst[(2 * res + i) * res + num2] = val.b;
					dst[(3 * res + i) * res + num2] = val.a;
					dst[(4 * res + i) * res + num2] = (byte)(255 - val.r - val.g - val.b - val.a);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid biome texture: " + ((Object)BiomeTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedBiomeTexture && (Object)(object)BiomeTexture != (Object)null)
		{
			Object.Destroy((Object)(object)BiomeTexture);
			BiomeTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		BiomeTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)BiomeTexture).name = "BiomeTexture";
		((Texture)BiomeTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				ref NativeArray<byte> reference = ref src;
				_ = res;
				byte b = reference[(0 + z) * res + i];
				byte b2 = src[(res + z) * res + i];
				byte b3 = src[(2 * res + z) * res + i];
				byte b4 = src[(3 * res + z) * res + i];
				col[z * res + i] = new Color32(b, b2, b3, b4);
			}
		});
		BiomeTexture.SetPixels32(col);
		_generatedBiomeTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		BiomeTexture.Apply(true, false);
		BiomeTexture.Compress(false);
		BiomeTexture.Apply(false, true);
	}

	public float GetBiomeMax(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMax(normX, normZ, mask);
	}

	public float GetBiomeMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMax(x, z, mask);
	}

	public float GetBiomeMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return (int)b;
	}

	public int GetBiomeMaxIndex(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMaxIndex(normX, normZ, mask);
	}

	public int GetBiomeMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMaxIndex(x, z, mask);
	}

	public int GetBiomeMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetBiomeMaxType(Vector3 worldPos, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(worldPos, mask));
	}

	public int GetBiomeMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(normX, normZ, mask));
	}

	public int GetBiomeMaxType(int x, int z, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(x, z, mask));
	}

	public float GetBiome(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiome(normX, normZ, mask);
	}

	public float GetBiome(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiome(x, z, mask);
	}

	public float GetBiome(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(TerrainBiome.TypeToIndex(mask) * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	public void SetBiome(Vector3 worldPos, int id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id);
	}

	public void SetBiome(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id);
	}

	public void SetBiome(int x, int z, int id)
	{
		int num = TerrainBiome.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = byte.MaxValue;
			}
			else
			{
				dst[(i * res + z) * res + x] = 0;
			}
		}
	}

	public void SetBiome(Vector3 worldPos, int id, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id, v);
	}

	public void SetBiome(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id, v);
	}

	public void SetBiome(int x, int z, int id, float v)
	{
		SetBiome(x, z, id, GetBiome(x, z, id), v);
	}

	public void SetBiomeRaw(int x, int z, float biome0, float biome1, float biome2, float biome3, float biome4, float opacity)
	{
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(biome0 + biome1 + biome2 + biome3 + biome4);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				ref NativeArray<byte> reference = ref dst;
				_ = res;
				reference[(0 + z) * res + x] = BitUtility.Float2Byte(biome0);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(biome1);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(biome2);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(biome3);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(biome4);
			}
			else
			{
				ref NativeArray<byte> reference2 = ref dst;
				_ = res;
				int num3 = (0 + z) * res + x;
				ref NativeArray<byte> reference3 = ref src;
				_ = res;
				reference2[num3] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)reference3[(0 + z) * res + x]) * num2 + biome0 * opacity);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(res + z) * res + x]) * num2 + biome1 * opacity);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(2 * res + z) * res + x]) * num2 + biome2 * opacity);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(3 * res + z) * res + x]) * num2 + biome3 * opacity);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(4 * res + z) * res + x]) * num2 + biome4 * opacity);
			}
		}
	}

	private void SetBiome(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainBiome.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(new_val);
			}
			else
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(num2 * BitUtility.Byte2Float((int)dst[(i * res + z) * res + x]));
			}
		}
	}
}


using System;
using UnityEngine;

public class TerrainBlendMap : TerrainMap<byte>
{
	public Texture2D BlendTexture;

	public override void Setup()
	{
		if ((Object)(object)BlendTexture != (Object)null)
		{
			if (((Texture)BlendTexture).width == ((Texture)BlendTexture).height)
			{
				res = ((Texture)BlendTexture).width;
				InitArrays(res * res);
				Color32[] pixels = BlendTexture.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						dst[i * res + num2] = pixels[num].a;
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError((object)("Invalid alpha texture: " + ((Object)BlendTexture).name));
			}
			return;
		}
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		for (int j = 0; j < res; j++)
		{
			for (int k = 0; k < res; k++)
			{
				dst[j * res + k] = 0;
			}
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		BlendTexture = new Texture2D(res, res, (TextureFormat)1, true, true);
		((Object)BlendTexture).name = "BlendTexture";
		((Texture)BlendTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				byte b = src[z * res + i];
				col[z * res + i] = new Color32(b, b, b, b);
			}
		});
		BlendTexture.SetPixels32(col);
	}

	public void ApplyTextures()
	{
		BlendTexture.Apply(true, false);
		BlendTexture.Compress(false);
		BlendTexture.Apply(false, true);
	}

	public float GetAlpha(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetAlpha(normX, normZ);
	}

	public float GetAlpha(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetAlpha(num4, num5), GetAlpha(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetAlpha(num4, z), GetAlpha(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetAlpha(int x, int z)
	{
		return BitUtility.Byte2Float((int)src[z * res + x]);
	}

	public void SetAlpha(Vector3 worldPos, float a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a);
	}

	public void SetAlpha(float normX, float normZ, float a)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetAlpha(x, z, a);
	}

	public void SetAlpha(int x, int z, float a)
	{
		dst[z * res + x] = BitUtility.Float2Byte(a);
	}

	public void SetAlpha(int x, int z, float a, float opacity)
	{
		SetAlpha(x, z, Mathf.Lerp(GetAlpha(x, z), a, opacity));
	}

	public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a, opacity, radius, fade);
	}

	public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			lerp *= opacity;
			if (lerp > 0f)
			{
				SetAlpha(x, z, a, lerp);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainDistanceMap : TerrainMap<byte>
{
	public Texture2D DistanceTexture;

	public override void Setup()
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(4 * res * res);
		if (!((Object)(object)DistanceTexture != (Object)null))
		{
			return;
		}
		if (((Texture)DistanceTexture).width == ((Texture)DistanceTexture).height && ((Texture)DistanceTexture).width == res)
		{
			Color32[] pixels = DistanceTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					SetDistance(num2, i, BitUtility.DecodeVector2i(pixels[num]));
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid distance texture: " + ((Object)DistanceTexture).name), (Object)(object)DistanceTexture);
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		DistanceTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)DistanceTexture).name = "DistanceTexture";
		((Texture)DistanceTexture).wrapMode = (TextureWrapMode)1;
		Color32[] cols = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				cols[z * res + i] = BitUtility.EncodeVector2i(GetDistance(i, z));
			}
		});
		DistanceTexture.SetPixels32(cols);
	}

	public void ApplyTextures()
	{
		DistanceTexture.Apply(true, true);
	}

	public Vector2i GetDistance(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetDistance(normX, normZ);
	}

	public Vector2i GetDistance(float normX, float normZ)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x = Mathf.Clamp(Mathf.RoundToInt(normX * (float)num), 0, num);
		int z = Mathf.Clamp(Mathf.RoundToInt(normZ * (float)num), 0, num);
		return GetDistance(x, z);
	}

	public Vector2i GetDistance(int x, int z)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<byte> reference = ref src;
		_ = res;
		byte b = reference[(0 + z) * res + x];
		byte b2 = src[(res + z) * res + x];
		byte b3 = src[(2 * res + z) * res + x];
		byte b4 = src[(3 * res + z) * res + x];
		if (b == byte.MaxValue && b2 == byte.MaxValue && b3 == byte.MaxValue && b4 == byte.MaxValue)
		{
			return new Vector2i(256, 256);
		}
		return new Vector2i(b - b2, b3 - b4);
	}

	public void SetDistance(int x, int z, Vector2i v)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<byte> reference = ref dst;
		_ = res;
		reference[(0 + z) * res + x] = (byte)Mathf.Clamp(v.x, 0, 255);
		dst[(res + z) * res + x] = (byte)Mathf.Clamp(-v.x, 0, 255);
		dst[(2 * res + z) * res + x] = (byte)Mathf.Clamp(v.y, 0, 255);
		dst[(3 * res + z) * res + x] = (byte)Mathf.Clamp(-v.y, 0, 255);
	}
}


using System;
using TerrainHeightMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainHeightMap : TerrainMap<short>
{
	public struct HeightMapQueryStructure
	{
		public ReadOnly<short> Data;

		public int Res;

		public Vector3 TerrainPosition;

		public Vector3 TerrainSize;

		public Vector3 TerrainOneOverSize;

		public float GetHeightFast(Vector2 uv)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			int num = Res - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? Res : 0);
			int num10 = num5 * Res + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = (float)Data[num10] * 3.051944E-05f;
			float num15 = (float)Data[num11] * 3.051944E-05f;
			float num16 = (float)Data[num12] * 3.051944E-05f;
			float num17 = (float)Data[num13] * 3.051944E-05f;
			float num18 = (num15 - num14) * num6 + num14;
			float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
			return TerrainPosition.y + num19 * TerrainSize.y;
		}
	}

	public Texture2D HeightTexture;

	public Texture2D NormalTexture;

	public float normY;

	private bool _generatedHeightTexture;

	private bool _generatedNormalTexture;

	public override void Setup()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
		if (!((Object)(object)HeightTexture != (Object)null))
		{
			return;
		}
		if (((Texture)HeightTexture).width == ((Texture)HeightTexture).height && ((Texture)HeightTexture).width == res)
		{
			Color32[] pixels = HeightTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					dst[i * res + num2] = BitUtility.DecodeShort(val);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid height texture: " + ((Object)HeightTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedHeightTexture && (Object)(object)HeightTexture != (Object)null)
		{
			Object.Destroy((Object)(object)HeightTexture);
			HeightTexture = null;
		}
		if (_generatedNormalTexture && (Object)(object)NormalTexture != (Object)null)
		{
			Object.Destroy((Object)(object)NormalTexture);
			NormalTexture = null;
		}
	}

	public void ApplyToTerrain()
	{
		float[,] heights = terrain.terrainData.GetHeights(0, 0, res, res);
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				heights[z, i] = GetHeight01(i, z);
			}
		});
		terrain.terrainData.SetHeights(0, 0, heights);
		TerrainCollider component = ((Component)terrain).GetComponent<TerrainCollider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Collider)component).enabled = false;
			((Collider)component).enabled = true;
		}
	}

	public void GenerateTextures(bool heightTexture = true, bool normalTexture = true)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Expected O, but got Unknown
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Expected O, but got Unknown
		if (heightTexture)
		{
			Color32[] heights = (Color32[])(object)new Color32[res * res];
			Parallel.For(0, res, (Action<int>)delegate(int z)
			{
				//IL_0038: Unknown result type (might be due to invalid IL or missing references)
				//IL_003d: Unknown result type (might be due to invalid IL or missing references)
				for (int i = 0; i < res; i++)
				{
					heights[z * res + i] = BitUtility.EncodeShort(src[z * res + i]);
				}
			});
			HeightTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
			((Object)HeightTexture).name = "HeightTexture";
			((Texture)HeightTexture).wrapMode = (TextureWrapMode)1;
			HeightTexture.SetPixels32(heights);
			HeightTexture.ignoreMipmapLimit = true;
			_generatedHeightTexture = Application.isPlaying;
		}
		if (!normalTexture)
		{
			return;
		}
		int normalres = (res - 1) / 2;
		Color32[] normals = (Color32[])(object)new Color32[normalres * normalres];
		Parallel.For(0, normalres, (Action<int>)delegate(int z)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			float normZ = ((float)z + 0.5f) / (float)normalres;
			for (int j = 0; j < normalres; j++)
			{
				float normX = ((float)j + 0.5f) / (float)normalres;
				Vector3 normal = GetNormal(normX, normZ);
				float num = Vector3.Angle(Vector3.up, normal);
				float num2 = Mathf.InverseLerp(50f, 70f, num);
				normal = Vector3.Slerp(normal, Vector3.up, num2);
				normals[z * normalres + j] = Color32.op_Implicit(BitUtility.EncodeNormal(normal));
			}
		});
		NormalTexture = new Texture2D(normalres, normalres, (TextureFormat)4, false, true);
		((Object)NormalTexture).name = "NormalTexture";
		((Texture)NormalTexture).wrapMode = (TextureWrapMode)1;
		NormalTexture.SetPixels32(normals);
		_generatedNormalTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		HeightTexture.Apply(true, false);
		NormalTexture.Apply(true, false);
		NormalTexture.Compress(false);
		HeightTexture.Apply(false, true);
		NormalTexture.Apply(false, true);
	}

	public float GetHeight(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(worldPos) * TerrainMeta.Size.y;
	}

	public void GetHeights(NativeArray<Vector3> worldPos, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsJob getHeightsJob = default(GetHeightsJob);
		getHeightsJob.Heights = results;
		getHeightsJob.Pos = worldPos;
		getHeightsJob.Data = src;
		getHeightsJob.Res = res;
		getHeightsJob.TerrainPos = TerrainMeta.Position;
		getHeightsJob.TerrainScale = TerrainMeta.Size.y;
		getHeightsJob.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
		GetHeightsJob getHeightsJob2 = getHeightsJob;
		IJobExtensions.RunByRef<GetHeightsJob>(ref getHeightsJob2);
	}

	public void GetHeightsIndirect(ReadOnly<Vector3> worldPos, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsJobIndirect getHeightsJobIndirect = default(GetHeightsJobIndirect);
		getHeightsJobIndirect.Heights = results;
		getHeightsJobIndirect.Pos = worldPos;
		getHeightsJobIndirect.Data = src.AsReadOnly();
		getHeightsJobIndirect.Res = res;
		getHeightsJobIndirect.TerrainPos = TerrainMeta.Position;
		getHeightsJobIndirect.TerrainScale = TerrainMeta.Size.y;
		getHeightsJobIndirect.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
		getHeightsJobIndirect.Indices = indices;
		GetHeightsJobIndirect getHeightsJobIndirect2 = getHeightsJobIndirect;
		IJobExtensions.RunByRef<GetHeightsJobIndirect>(ref getHeightsJobIndirect2);
	}

	public float GetHeight(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public HeightMapQueryStructure GetQueryStructure()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		HeightMapQueryStructure result = default(HeightMapQueryStructure);
		result.Data = src.AsReadOnly();
		result.Res = res;
		result.TerrainPosition = TerrainMeta.Position;
		result.TerrainSize = TerrainMeta.Size;
		result.TerrainOneOverSize = TerrainMeta.OneOverSize;
		return result;
	}

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainMeta.Position.y + num19 * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public void GetHeightsFastIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsFastJobIndirect getHeightsFastJobIndirect = default(GetHeightsFastJobIndirect);
		getHeightsFastJobIndirect.Heights = results;
		getHeightsFastJobIndirect.UVs = uvs;
		getHeightsFastJobIndirect.Indices = indices;
		getHeightsFastJobIndirect.Data = src.AsReadOnly();
		getHeightsFastJobIndirect.Res = res;
		getHeightsFastJobIndirect.TerrainPos = TerrainMeta.Position.y;
		getHeightsFastJobIndirect.TerrainScale = TerrainMeta.Size.y;
		GetHeightsFastJobIndirect getHeightsFastJobIndirect2 = getHeightsFastJobIndirect;
		IJobExtensions.RunByRef<GetHeightsFastJobIndirect>(ref getHeightsFastJobIndirect2);
	}

	public float GetHeight01(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetHeight01(normX, normZ);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float height = GetHeight01(num4, num5);
		float height2 = GetHeight01(x, num5);
		float height3 = GetHeight01(num4, z);
		float height4 = GetHeight01(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		float num8 = Mathf.Lerp(height, height2, num6);
		float num9 = Mathf.Lerp(height3, height4, num6);
		return Mathf.Lerp(num8, num9, num7);
	}

	public float GetTriangulatedHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		float height = GetHeight01(num4, num5);
		float height2 = GetHeight01(x, z);
		if (num6 > num7)
		{
			float height3 = GetHeight01(x, num5);
			return height + (height3 - height) * num6 + (height2 - height3) * num7;
		}
		float height4 = GetHeight01(num4, z);
		return height + (height2 - height4) * num6 + (height4 - height) * num7;
	}

	public float GetHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	private float GetSrcHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	private float GetDstHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)dst[z * res + x]);
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		Vector3 normal = GetNormal(num4, num5);
		Vector3 normal2 = GetNormal(x, num5);
		Vector3 normal3 = GetNormal(num4, z);
		Vector3 normal4 = GetNormal(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		Vector3 val = Vector3.Slerp(normal, normal2, num6);
		Vector3 val2 = Vector3.Slerp(normal3, normal4, num6);
		Vector3 val3 = Vector3.Slerp(val, val2, num7);
		return ((Vector3)(ref val3)).normalized;
	}

	public Vector3 GetNormal(int x, int z)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = (GetHeight01(x3, z2) - GetHeight01(x2, z2)) * 0.5f;
		float num3 = (GetHeight01(x2, z3) - GetHeight01(x2, z2)) * 0.5f;
		Vector3 val = new Vector3(0f - num2, normY, 0f - num3);
		return ((Vector3)(ref val)).normalized;
	}

	private Vector3 GetNormalSobel(int x, int z)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(TerrainMeta.Size.x / (float)num, TerrainMeta.Size.y, TerrainMeta.Size.z / (float)num);
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = GetHeight01(x2, z2) * -1f;
		num2 += GetHeight01(x2, z) * -2f;
		num2 += GetHeight01(x2, z3) * -1f;
		num2 += GetHeight01(x3, z2) * 1f;
		num2 += GetHeight01(x3, z) * 2f;
		num2 += GetHeight01(x3, z3) * 1f;
		num2 *= val.y;
		num2 /= val.x;
		float num3 = GetHeight01(x2, z2) * -1f;
		num3 += GetHeight01(x, z2) * -2f;
		num3 += GetHeight01(x3, z2) * -1f;
		num3 += GetHeight01(x2, z3) * 1f;
		num3 += GetHeight01(x, z3) * 2f;
		num3 += GetHeight01(x3, z3) * 1f;
		num3 *= val.y;
		num3 /= val.z;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(0f - num2, 8f, 0f - num3);
		return ((Vector3)(ref val2)).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z * res + x] = BitUtility.Float2Short(height);
	}

	public void SetHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height, opacity);
	}

	public void SetHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height, opacity);
	}

	public void SetHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity);
		SetHeight(x, z, height2);
	}

	public void AddHeight(Vector3 worldPos, float delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddHeight(normX, normZ, delta);
	}

	public void AddHeight(float normX, float normZ, float delta)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddHeight(x, z, delta);
	}

	public void AddHeight(int x, int z, float delta)
	{
		float height = Mathf.Clamp01(GetDstHeight01(x, z) + delta);
		SetHeight(x, z, height);
	}

	public void LowerHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		LowerHeight(normX, normZ, height, opacity);
	}

	public void LowerHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		LowerHeight(x, z, height, opacity);
	}

	public void LowerHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.Min(GetDstHeight01(x, z), Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity));
		SetHeight(x, z, height2);
	}

	public void RaiseHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RaiseHeight(normX, normZ, height, opacity);
	}

	public void RaiseHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		RaiseHeight(x, z, height, opacity);
	}

	public void RaiseHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.Max(GetDstHeight01(x, z), Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity));
		SetHeight(x, z, height2);
	}

	public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		SetHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				SetHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		LowerHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				LowerHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		RaiseHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				RaiseHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddHeight(Vector3 worldPos, float delta, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddHeight(normX, normZ, delta, radius, fade);
	}

	public void AddHeight(float normX, float normZ, float delta, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				AddHeight(x, z, lerp * delta);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using Unity.Collections;
using UnityEngine;

public struct HeightMapQueryStructure
{
	public ReadOnly<short> Data;

	public int Res;

	public Vector3 TerrainPosition;

	public Vector3 TerrainSize;

	public Vector3 TerrainOneOverSize;

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? Res : 0);
		int num10 = num5 * Res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)Data[num10] * 3.051944E-05f;
		float num15 = (float)Data[num11] * 3.051944E-05f;
		float num16 = (float)Data[num12] * 3.051944E-05f;
		float num17 = (float)Data[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainPosition.y + num19 * TerrainSize.y;
	}
}


using System;
using UnityEngine;

public abstract class TerrainMap : TerrainExtension
{
	internal int res;

	public void ApplyFilter(float normX, float normZ, float radius, float fade, Action<int, int, float> action)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		float num2 = TerrainMeta.OneOverSize.x * fade;
		float num3 = (float)res * (num - num2);
		float num4 = (float)res * num;
		float num5 = normX * (float)res;
		float num6 = normZ * (float)res;
		int num7 = Index(normX - num);
		int num8 = Index(normX + num);
		int num9 = Index(normZ - num);
		int num10 = Index(normZ + num);
		Vector2 val;
		if (num3 != num4)
		{
			for (int i = num9; i <= num10; i++)
			{
				for (int j = num7; j <= num8; j++)
				{
					val = new Vector2((float)j + 0.5f - num5, (float)i + 0.5f - num6);
					float magnitude = ((Vector2)(ref val)).magnitude;
					float arg = Mathf.InverseLerp(num4, num3, magnitude);
					action(j, i, arg);
				}
			}
			return;
		}
		for (int k = num9; k <= num10; k++)
		{
			for (int l = num7; l <= num8; l++)
			{
				val = new Vector2((float)l + 0.5f - num5, (float)k + 0.5f - num6);
				float arg2 = ((((Vector2)(ref val)).magnitude < num4) ? 1 : 0);
				action(l, k, arg2);
			}
		}
	}

	public void ForEach(Vector3 worldPos, float radius, Action<int, int> action)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(TerrainMeta.NormalizeX(worldPos.x - radius));
		int num2 = Index(TerrainMeta.NormalizeX(worldPos.x + radius));
		int num3 = Index(TerrainMeta.NormalizeZ(worldPos.z - radius));
		int num4 = Index(TerrainMeta.NormalizeZ(worldPos.z + radius));
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num; j <= num2; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEach(float normX, float normZ, float normRadius, Action<int, int> action)
	{
		int num = Index(normX - normRadius);
		int num2 = Index(normX + normRadius);
		int num3 = Index(normZ - normRadius);
		int num4 = Index(normZ + normRadius);
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num; j <= num2; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v3 = default(Vector2i);
		((Vector2i)(ref v3))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		ForEachParallel(v3, v4, v5, action);
	}

	public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathx.Min(v0.x, v1.x, v2.x);
		int num2 = Mathx.Max(v0.x, v1.x, v2.x);
		int num3 = Mathx.Min(v0.y, v1.y, v2.y);
		int num4 = Mathx.Max(v0.y, v1.y, v2.y);
		Vector2i base_min = new Vector2i(num, num3);
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num2, num4);
		Vector2i base_count = val - base_min + Vector2i.one;
		Parallel.Call((Action<int, int>)delegate(int thread_id, int thread_count)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			Vector2i min = base_min + base_count * thread_id / thread_count;
			Vector2i max = base_min + base_count * (thread_id + 1) / thread_count - Vector2i.one;
			ForEachInternal(v0, v1, v2, action, min, max);
		});
	}

	public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v3 = default(Vector2i);
		((Vector2i)(ref v3))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		ForEach(v3, v4, v5, action);
	}

	public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector2i min = default(Vector2i);
		((Vector2i)(ref min))..ctor(int.MinValue, int.MinValue);
		Vector2i max = default(Vector2i);
		((Vector2i)(ref max))..ctor(int.MaxValue, int.MaxValue);
		ForEachInternal(v0, v1, v2, action, min, max);
	}

	private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action, Vector2i min, Vector2i max)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.Max(min.x, Mathx.Min(v0.x, v1.x, v2.x));
		int num2 = Mathf.Min(max.x, Mathx.Max(v0.x, v1.x, v2.x));
		int num3 = Mathf.Max(min.y, Mathx.Min(v0.y, v1.y, v2.y));
		int num4 = Mathf.Min(max.y, Mathx.Max(v0.y, v1.y, v2.y));
		int num5 = v0.y - v1.y;
		int num6 = v1.x - v0.x;
		int num7 = v1.y - v2.y;
		int num8 = v2.x - v1.x;
		int num9 = v2.y - v0.y;
		int num10 = v0.x - v2.x;
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num, num3);
		int num11 = (v2.x - v1.x) * (val.y - v1.y) - (v2.y - v1.y) * (val.x - v1.x);
		int num12 = (v0.x - v2.x) * (val.y - v2.y) - (v0.y - v2.y) * (val.x - v2.x);
		int num13 = (v1.x - v0.x) * (val.y - v0.y) - (v1.y - v0.y) * (val.x - v0.x);
		val.y = num3;
		while (val.y <= num4)
		{
			int num14 = num11;
			int num15 = num12;
			int num16 = num13;
			val.x = num;
			while (val.x <= num2)
			{
				if ((num14 | num15 | num16) >= 0)
				{
					action(val.x, val.y);
				}
				num14 += num7;
				num15 += num9;
				num16 += num5;
				val.x++;
			}
			num11 += num8;
			num12 += num10;
			num13 += num6;
			val.y++;
		}
	}

	public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v6 = default(Vector2i);
		((Vector2i)(ref v6))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		Vector2i v7 = default(Vector2i);
		((Vector2i)(ref v7))..ctor(Index(TerrainMeta.NormalizeX(v3.x)), Index(TerrainMeta.NormalizeZ(v3.z)));
		ForEachParallel(v4, v5, v6, v7, action);
	}

	public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathx.Min(v0.x, v1.x, v2.x, v3.x);
		int num2 = Mathx.Max(v0.x, v1.x, v2.x, v3.x);
		int num3 = Mathx.Min(v0.y, v1.y, v2.y, v3.y);
		int num4 = Mathx.Max(v0.y, v1.y, v2.y, v3.y);
		Vector2i base_min = new Vector2i(num, num3);
		Vector2i val = new Vector2i(num2, num4) - base_min + Vector2i.one;
		Vector2i size_x = new Vector2i(val.x, 0);
		Vector2i size_y = new Vector2i(0, val.y);
		Parallel.Call((Action<int, int>)delegate(int thread_id, int thread_count)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			Vector2i min = base_min + size_y * thread_id / thread_count;
			Vector2i max = base_min + size_y * (thread_id + 1) / thread_count + size_x - Vector2i.one;
			ForEachInternal(v0, v1, v2, v3, action, min, max);
		});
	}

	public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v6 = default(Vector2i);
		((Vector2i)(ref v6))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		Vector2i v7 = default(Vector2i);
		((Vector2i)(ref v7))..ctor(Index(TerrainMeta.NormalizeX(v3.x)), Index(TerrainMeta.NormalizeZ(v3.z)));
		ForEach(v4, v5, v6, v7, action);
	}

	public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Vector2i min = default(Vector2i);
		((Vector2i)(ref min))..ctor(int.MinValue, int.MinValue);
		Vector2i max = default(Vector2i);
		((Vector2i)(ref max))..ctor(int.MaxValue, int.MaxValue);
		ForEachInternal(v0, v1, v2, v3, action, min, max);
	}

	private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action, Vector2i min, Vector2i max)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.Max(min.x, Mathx.Min(v0.x, v1.x, v2.x, v3.x));
		int num2 = Mathf.Min(max.x, Mathx.Max(v0.x, v1.x, v2.x, v3.x));
		int num3 = Mathf.Max(min.y, Mathx.Min(v0.y, v1.y, v2.y, v3.y));
		int num4 = Mathf.Min(max.y, Mathx.Max(v0.y, v1.y, v2.y, v3.y));
		int num5 = v0.y - v1.y;
		int num6 = v1.x - v0.x;
		int num7 = v1.y - v2.y;
		int num8 = v2.x - v1.x;
		int num9 = v2.y - v0.y;
		int num10 = v0.x - v2.x;
		int num11 = v3.y - v2.y;
		int num12 = v2.x - v3.x;
		int num13 = v2.y - v1.y;
		int num14 = v1.x - v2.x;
		int num15 = v1.y - v3.y;
		int num16 = v3.x - v1.x;
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num, num3);
		int num17 = (v2.x - v1.x) * (val.y - v1.y) - (v2.y - v1.y) * (val.x - v1.x);
		int num18 = (v0.x - v2.x) * (val.y - v2.y) - (v0.y - v2.y) * (val.x - v2.x);
		int num19 = (v1.x - v0.x) * (val.y - v0.y) - (v1.y - v0.y) * (val.x - v0.x);
		int num20 = (v1.x - v2.x) * (val.y - v2.y) - (v1.y - v2.y) * (val.x - v2.x);
		int num21 = (v3.x - v1.x) * (val.y - v1.y) - (v3.y - v1.y) * (val.x - v1.x);
		int num22 = (v2.x - v3.x) * (val.y - v3.y) - (v2.y - v3.y) * (val.x - v3.x);
		val.y = num3;
		while (val.y <= num4)
		{
			int num23 = num17;
			int num24 = num18;
			int num25 = num19;
			int num26 = num20;
			int num27 = num21;
			int num28 = num22;
			val.x = num;
			while (val.x <= num2)
			{
				if ((num23 | num24 | num25) >= 0 || (num26 | num27 | num28) >= 0)
				{
					action(val.x, val.y);
				}
				num23 += num7;
				num24 += num9;
				num25 += num5;
				num26 += num13;
				num27 += num15;
				num28 += num11;
				val.x++;
			}
			num17 += num8;
			num18 += num10;
			num19 += num6;
			num20 += num14;
			num21 += num16;
			num22 += num12;
			val.y++;
		}
	}

	public void ForEach(int x_min, int x_max, int z_min, int z_max, Action<int, int> action)
	{
		for (int i = z_min; i <= z_max; i++)
		{
			for (int j = x_min; j <= x_max; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEach(Action<int, int> action)
	{
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				action(j, i);
			}
		}
	}

	public int Index(float normalized)
	{
		int num = (int)(normalized * (float)res);
		if (num >= 0)
		{
			if (num <= res - 1)
			{
				return num;
			}
			return res - 1;
		}
		return 0;
	}

	public float Coordinate(int index)
	{
		return ((float)index + 0.5f) / (float)res;
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public abstract class TerrainMap<T> : TerrainMap, IDisposable where T : unmanaged
{
	internal NativeArray<T> src;

	internal NativeArray<T> dst;

	public void InitArrays(int size)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		src = (dst = new NativeArray<T>(size, (Allocator)4, (NativeArrayOptions)1));
	}

	public void Push()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!(src != dst))
		{
			Debug.Assert(src == dst);
			dst = new NativeArray<T>(src, (Allocator)4);
		}
	}

	public void Pop()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!(src == dst))
		{
			Debug.Assert(src.IsCreated);
			Debug.Assert(dst.IsCreated);
			src.CopyFrom(dst);
			Debug.Assert(src != dst);
			dst.Dispose();
			dst = src;
		}
	}

	public IEnumerable<T> ToEnumerable()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerable<T>)(object)src;
	}

	public int BytesPerElement()
	{
		return UnsafeUtility.SizeOf<T>();
	}

	public long GetMemoryUsage()
	{
		return (long)BytesPerElement() * (long)src.Length;
	}

	public byte[] ToByteArray()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return src.Reinterpret<byte>(UnsafeUtility.SizeOf<T>()).ToArray();
	}

	public void FromByteArray(byte[] dat)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (dat == null)
		{
			throw new ArgumentNullException("dat");
		}
		if (!dst.IsCreated)
		{
			throw new InvalidOperationException("Destination NativeArray is not created");
		}
		int num = UnsafeUtility.SizeOf<T>();
		NativeSlice<byte> val = default(NativeSlice<byte>);
		val..ctor(dst.Reinterpret<byte>(num), 0, dat.Length);
		val.CopyFrom(dat);
	}

	public void OnDestroy()
	{
		Dispose();
	}

	public virtual void Dispose()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (src != dst)
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
			if (dst.IsCreated)
			{
				dst.Dispose();
			}
		}
		else if (src.IsCreated)
		{
			src.Dispose();
		}
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainPlacementMap : TerrainMap<bool>
{
	private bool isEnabled;

	public override void Setup()
	{
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		Enable();
	}

	public override void PostSetup()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		res = 0;
		if (src == dst)
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
		}
		else
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
			if (dst.IsCreated)
			{
				dst.Dispose();
			}
		}
		src = default(NativeArray<bool>);
		dst = default(NativeArray<bool>);
		Disable();
	}

	public void Enable()
	{
		isEnabled = true;
	}

	public void Disable()
	{
		isEnabled = false;
	}

	public void Reset()
	{
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				dst[i * res + j] = false;
			}
		}
	}

	public bool GetBlocked(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBlocked(normX, normZ);
	}

	public bool GetBlocked(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBlocked(x, z);
	}

	public bool GetBlocked(int x, int z)
	{
		if (!isEnabled || res <= 0)
		{
			return false;
		}
		return src[z * res + x];
	}

	public void SetBlocked(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBlocked(normX, normZ);
	}

	public void SetBlocked(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBlocked(x, z);
	}

	public void SetBlocked(int x, int z)
	{
		dst[z * res + x] = true;
	}

	public bool GetBlocked(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBlocked(normX, normZ, radius);
	}

	public bool GetBlocked(float normX, float normZ, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		int num2 = Index(normX - num);
		int num3 = Index(normX + num);
		int num4 = Index(normZ - num);
		int num5 = Index(normZ + num);
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				if (src[i * res + j])
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SetBlocked(Vector3 worldPos, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBlocked(normX, normZ, radius, fade);
	}

	public void SetBlocked(float normX, float normZ, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				dst[z * res + x] = true;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainSplatMap : TerrainMap<byte>
{
	public Texture2D SplatTexture0;

	public Texture2D SplatTexture1;

	private bool _generatedSplatTexture0;

	private bool _generatedSplatTexture1;

	internal int num;

	public override void Setup()
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		this.num = config.Splats.Length;
		InitArrays(this.num * res * res);
		if ((Object)(object)SplatTexture0 != (Object)null)
		{
			if (((Texture)SplatTexture0).width == ((Texture)SplatTexture0).height && ((Texture)SplatTexture0).width == res)
			{
				Color32[] pixels = SplatTexture0.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						Color32 val = pixels[num];
						if (this.num > 0)
						{
							ref NativeArray<byte> reference = ref dst;
							_ = res;
							reference[(0 + i) * res + num2] = val.r;
						}
						if (this.num > 1)
						{
							dst[(res + i) * res + num2] = val.g;
						}
						if (this.num > 2)
						{
							dst[(2 * res + i) * res + num2] = val.b;
						}
						if (this.num > 3)
						{
							dst[(3 * res + i) * res + num2] = val.a;
						}
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError((object)("Invalid splat texture: " + ((Object)SplatTexture0).name), (Object)(object)SplatTexture0);
			}
		}
		if (!((Object)(object)SplatTexture1 != (Object)null))
		{
			return;
		}
		if (((Texture)SplatTexture1).width == ((Texture)SplatTexture1).height && ((Texture)SplatTexture1).width == res && this.num > 5)
		{
			Color32[] pixels2 = SplatTexture1.GetPixels32();
			int j = 0;
			int num3 = 0;
			for (; j < res; j++)
			{
				int num4 = 0;
				while (num4 < res)
				{
					Color32 val2 = pixels2[num3];
					if (this.num > 4)
					{
						dst[(4 * res + j) * res + num4] = val2.r;
					}
					if (this.num > 5)
					{
						dst[(5 * res + j) * res + num4] = val2.g;
					}
					if (this.num > 6)
					{
						dst[(6 * res + j) * res + num4] = val2.b;
					}
					if (this.num > 7)
					{
						dst[(7 * res + j) * res + num4] = val2.a;
					}
					num4++;
					num3++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid splat texture: " + ((Object)SplatTexture1).name), (Object)(object)SplatTexture1);
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedSplatTexture0 && (Object)(object)SplatTexture0 != (Object)null)
		{
			Object.Destroy((Object)(object)SplatTexture0);
			SplatTexture0 = null;
		}
		if (_generatedSplatTexture1 && (Object)(object)SplatTexture1 != (Object)null)
		{
			Object.Destroy((Object)(object)SplatTexture1);
			SplatTexture1 = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Expected O, but got Unknown
		SplatTexture0 = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)SplatTexture0).name = "SplatTexture0";
		((Texture)SplatTexture0).wrapMode = (TextureWrapMode)1;
		Color32[] cols = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				int num;
				if (this.num <= 0)
				{
					num = 0;
				}
				else
				{
					ref NativeArray<byte> reference = ref src;
					_ = res;
					num = reference[(0 + z) * res + i];
				}
				byte b = (byte)num;
				byte b2 = (byte)((this.num > 1) ? src[(res + z) * res + i] : 0);
				byte b3 = (byte)((this.num > 2) ? src[(2 * res + z) * res + i] : 0);
				byte b4 = (byte)((this.num > 3) ? src[(3 * res + z) * res + i] : 0);
				cols[z * res + i] = new Color32(b, b2, b3, b4);
			}
		});
		SplatTexture0.SetPixels32(cols);
		_generatedSplatTexture0 = Application.isPlaying;
		SplatTexture1 = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)SplatTexture1).name = "SplatTexture1";
		((Texture)SplatTexture1).wrapMode = (TextureWrapMode)1;
		Color32[] cols2 = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			for (int j = 0; j < res; j++)
			{
				byte b5 = (byte)((num > 4) ? src[(4 * res + z) * res + j] : 0);
				byte b6 = (byte)((num > 5) ? src[(5 * res + z) * res + j] : 0);
				byte b7 = (byte)((num > 6) ? src[(6 * res + z) * res + j] : 0);
				byte b8 = (byte)((num > 7) ? src[(7 * res + z) * res + j] : 0);
				cols2[z * res + j] = new Color32(b5, b6, b7, b8);
			}
		});
		SplatTexture1.SetPixels32(cols2);
		_generatedSplatTexture1 = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		SplatTexture0.Apply(true, true);
		SplatTexture1.Apply(true, true);
	}

	public float GetSplatMax(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplatMax(normX, normZ, mask);
	}

	public float GetSplatMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetSplatMax(x, z, mask);
	}

	public float GetSplatMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return BitUtility.Byte2Float((int)b);
	}

	public int GetSplatMaxIndex(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplatMaxIndex(normX, normZ, mask);
	}

	public int GetSplatMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetSplatMaxIndex(x, z, mask);
	}

	public int GetSplatMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetSplatMaxType(Vector3 worldPos, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TerrainSplat.IndexToType(GetSplatMaxIndex(worldPos, mask));
	}

	public int GetSplatMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainSplat.IndexToType(GetSplatMaxIndex(normX, normZ, mask));
	}

	public int GetSplatMaxType(int x, int z, int mask = -1)
	{
		return TerrainSplat.IndexToType(GetSplatMaxIndex(x, z, mask));
	}

	public float GetSplat(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplat(normX, normZ, mask);
	}

	public float GetSplat(float normX, float normZ, int mask)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetSplat(num4, num5, mask), GetSplat(x, num5, mask), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetSplat(num4, z, mask), GetSplat(x, z, mask), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetSplat(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(TerrainSplat.TypeToIndex(mask) * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	public void SetSplat(Vector3 worldPos, int id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id);
	}

	public void SetSplat(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetSplat(x, z, id);
	}

	public void SetSplat(int x, int z, int id)
	{
		int num = TerrainSplat.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = byte.MaxValue;
			}
			else
			{
				dst[(i * res + z) * res + x] = 0;
			}
		}
	}

	public void SetSplat(Vector3 worldPos, int id, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id, v);
	}

	public void SetSplat(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetSplat(x, z, id, v);
	}

	public void SetSplat(int x, int z, int id, float v)
	{
		SetSplat(x, z, id, GetSplat(x, z, id), v);
	}

	public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				ref NativeArray<byte> reference = ref dst;
				_ = res;
				reference[(0 + z) * res + x] = BitUtility.Float2Byte(v1.x);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(v1.y);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(v1.z);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(v1.w);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(v2.x);
				dst[(5 * res + z) * res + x] = BitUtility.Float2Byte(v2.y);
				dst[(6 * res + z) * res + x] = BitUtility.Float2Byte(v2.z);
				dst[(7 * res + z) * res + x] = BitUtility.Float2Byte(v2.w);
			}
			else
			{
				ref NativeArray<byte> reference2 = ref dst;
				_ = res;
				int num3 = (0 + z) * res + x;
				ref NativeArray<byte> reference3 = ref src;
				_ = res;
				reference2[num3] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)reference3[(0 + z) * res + x]) * num2 + v1.x * opacity);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(res + z) * res + x]) * num2 + v1.y * opacity);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(2 * res + z) * res + x]) * num2 + v1.z * opacity);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(3 * res + z) * res + x]) * num2 + v1.w * opacity);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(4 * res + z) * res + x]) * num2 + v2.x * opacity);
				dst[(5 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(5 * res + z) * res + x]) * num2 + v2.y * opacity);
				dst[(6 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(6 * res + z) * res + x]) * num2 + v2.z * opacity);
				dst[(7 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(7 * res + z) * res + x]) * num2 + v2.w * opacity);
			}
		}
	}

	public void AddSplat(Vector3 worldPos, int id, float d)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddSplat(normX, normZ, id, d);
	}

	public void AddSplat(float normX, float normZ, int id, float d)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddSplat(x, z, id, d);
	}

	public void AddSplat(int x, int z, int id, float d)
	{
		float splat = GetSplat(x, z, id);
		SetSplat(x, z, id, splat, Mathf.Clamp01(splat + d));
	}

	public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id, opacity, radius, fade);
	}

	public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade = 0f)
	{
		int idx = TerrainSplat.TypeToIndex(id);
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				float num = BitUtility.Byte2Float((int)dst[(idx * res + z) * res + x]);
				float new_val = Mathf.Lerp(num, 1f, lerp * opacity);
				SetSplat(x, z, id, num, new_val);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddSplat(normX, normZ, id, delta, radius, fade);
	}

	public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade = 0f)
	{
		int idx = TerrainSplat.TypeToIndex(id);
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				float num = BitUtility.Byte2Float((int)dst[(idx * res + z) * res + x]);
				float new_val = Mathf.Clamp01(num + lerp * delta);
				SetSplat(x, z, id, num, new_val);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void RemoveSplat(Vector3 worldPos, int id, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RemoveSplat(normX, normZ, id, opacity, radius, fade);
	}

	public void RemoveSplat(float normX, float normZ, int id, float opacity, float radius, float fade = 0f)
	{
		int a_idx = TerrainSplat.TypeToIndex(id);
		int b_idx = 0;
		switch (TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ))
		{
		case 1:
			b_idx = TerrainSplat.TypeToIndex(4);
			break;
		case 2:
			b_idx = TerrainSplat.TypeToIndex(16);
			break;
		case 4:
			b_idx = TerrainSplat.TypeToIndex(16);
			break;
		case 8:
			b_idx = TerrainSplat.TypeToIndex(2);
			break;
		}
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				int num = (a_idx * res + z) * res + x;
				int num2 = (b_idx * res + z) * res + x;
				float num3 = BitUtility.Byte2Float((int)dst[num]);
				float num4 = BitUtility.Byte2Float((int)dst[num2]);
				float num5 = lerp * opacity * num3;
				float num6 = Mathf.Clamp01(num3 - num5);
				float num7 = Mathf.Clamp01(num4 + num5);
				dst[num] = BitUtility.Float2Byte(num6);
				dst[num2] = BitUtility.Float2Byte(num7);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	private void SetSplat(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainSplat.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(new_val);
			}
			else
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(num2 * BitUtility.Byte2Float((int)dst[(i * res + z) * res + x]));
			}
		}
	}
}


using System;
using System.Threading;
using TerrainTopologyMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainTopologyMap : TerrainMap<int>
{
	public Texture2D TopologyTexture;

	private bool _generatedTopologyTexture;

	private ThreadLocal<NativeReference<int>> topoNative = new ThreadLocal<NativeReference<int>>(() => new NativeReference<int>(0, AllocatorHandle.op_Implicit((Allocator)4)), trackAllValues: true);

	public override void Setup()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		if (!((Object)(object)TopologyTexture != (Object)null))
		{
			return;
		}
		if (((Texture)TopologyTexture).width == ((Texture)TopologyTexture).height && ((Texture)TopologyTexture).width == res)
		{
			Color32[] pixels = TopologyTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					dst[i * res + num2] = BitUtility.DecodeInt(pixels[num]);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid topology texture: " + ((Object)TopologyTexture).name));
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		TopologyTexture = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)TopologyTexture).name = "TopologyTexture";
		((Texture)TopologyTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				col[z * res + i] = BitUtility.EncodeInt(src[z * res + i]);
			}
		});
		TopologyTexture.SetPixels32(col);
		_generatedTopologyTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		TopologyTexture.Apply(false, true);
	}

	public bool GetTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ, mask);
	}

	public bool GetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z, mask);
	}

	public bool GetTopology(int x, int z, int mask)
	{
		return (src[z * res + x] & mask) != 0;
	}

	public int GetTopology(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ);
	}

	public int GetTopology(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z);
	}

	public int GetTopologyFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int num2 = (int)(uv.x * (float)res);
		int num3 = (int)(uv.y * (float)res);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		return src[num3 * res + num2];
	}

	public int GetTopology(int x, int z)
	{
		return src[z * res + x];
	}

	public void GetTopologies(NativeArray<Vector3> worldPos, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByPosJob getTopologyByPosJob = default(GetTopologyByPosJob);
		getTopologyByPosJob.Topologies = results;
		getTopologyByPosJob.Pos = worldPos;
		getTopologyByPosJob.Data = src;
		getTopologyByPosJob.Res = res;
		getTopologyByPosJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		getTopologyByPosJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		GetTopologyByPosJob getTopologyByPosJob2 = getTopologyByPosJob;
		IJobExtensions.RunByRef<GetTopologyByPosJob>(ref getTopologyByPosJob2);
	}

	public void GetTopologies(NativeArray<Vector2> uvs, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByUVJob getTopologyByUVJob = default(GetTopologyByUVJob);
		getTopologyByUVJob.Topologies = results;
		getTopologyByUVJob.UV = uvs;
		getTopologyByUVJob.Data = src;
		getTopologyByUVJob.Res = res;
		GetTopologyByUVJob getTopologyByUVJob2 = getTopologyByUVJob;
		IJobExtensions.RunByRef<GetTopologyByUVJob>(ref getTopologyByUVJob2);
	}

	public void GetTopologies(NativeArray<Vector2i> indices, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByIndexJob getTopologyByIndexJob = default(GetTopologyByIndexJob);
		getTopologyByIndexJob.Topologies = results;
		getTopologyByIndexJob.Indices = indices;
		getTopologyByIndexJob.Data = src;
		getTopologyByIndexJob.Res = res;
		GetTopologyByIndexJob getTopologyByIndexJob2 = getTopologyByIndexJob;
		IJobExtensions.RunByRef<GetTopologyByIndexJob>(ref getTopologyByIndexJob2);
	}

	public void GetTopologiesIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByUVJobIndirect getTopologyByUVJobIndirect = default(GetTopologyByUVJobIndirect);
		getTopologyByUVJobIndirect.Topologies = results;
		getTopologyByUVJobIndirect.UV = uvs;
		getTopologyByUVJobIndirect.Indices = indices;
		getTopologyByUVJobIndirect.Data = src.AsReadOnly();
		getTopologyByUVJobIndirect.Res = res;
		GetTopologyByUVJobIndirect getTopologyByUVJobIndirect2 = getTopologyByUVJobIndirect;
		IJobExtensions.RunByRef<GetTopologyByUVJobIndirect>(ref getTopologyByUVJobIndirect2);
	}

	public void SetTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetTopology(normX, normZ, mask);
	}

	public void SetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetTopology(x, z, mask);
	}

	public void SetTopology(int x, int z, int mask)
	{
		dst[z * res + x] = mask;
	}

	public void AddTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddTopology(normX, normZ, mask);
	}

	public void AddTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddTopology(x, z, mask);
	}

	public void AddTopology(int x, int z, int mask)
	{
		ref NativeArray<int> reference = ref dst;
		int num = z * res + x;
		reference[num] |= mask;
	}

	public void RemoveTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RemoveTopology(normX, normZ, mask);
	}

	public void RemoveTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		RemoveTopology(x, z, mask);
	}

	public void RemoveTopology(int x, int z, int mask)
	{
		ref NativeArray<int> reference = ref dst;
		int num = z * res + x;
		reference[num] &= ~mask;
	}

	public int GetTopology(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ, radius);
	}

	public int GetTopologyJob(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopologyJob(normX, normZ, radius);
	}

	public int GetTopologyJob(float normX, float normZ, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		int x_mid = Index(normX);
		int z_mid = Index(normZ);
		int x_min = Index(normX - num);
		int x_max = Index(normX + num);
		int z_min = Index(normZ - num);
		int z_max = Index(normZ + num);
		NativeReference<int> value = topoNative.Value;
		GetTopologyRadiusJob getTopologyRadiusJob = default(GetTopologyRadiusJob);
		getTopologyRadiusJob.Res = res;
		getTopologyRadiusJob.Src = src.AsReadOnly();
		getTopologyRadiusJob.Topo = value;
		getTopologyRadiusJob.radius = radius;
		getTopologyRadiusJob.x_mid = x_mid;
		getTopologyRadiusJob.z_mid = z_mid;
		getTopologyRadiusJob.x_min = x_min;
		getTopologyRadiusJob.x_max = x_max;
		getTopologyRadiusJob.z_min = z_min;
		getTopologyRadiusJob.z_max = z_max;
		GetTopologyRadiusJob getTopologyRadiusJob2 = getTopologyRadiusJob;
		IJobExtensions.RunByRef<GetTopologyRadiusJob>(ref getTopologyRadiusJob2);
		return value.Value;
	}

	public int GetTopology(float normX, float normZ, float radius)
	{
		return GetTopologyJob(normX, normZ, radius);
	}

	public void SetTopology(Vector3 worldPos, int mask, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetTopology(normX, normZ, mask, radius, fade);
	}

	public void SetTopology(float normX, float normZ, int mask, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				dst[z * res + x] = mask;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddTopology(Vector3 worldPos, int mask, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddTopology(normX, normZ, mask, radius, fade);
	}

	public void AddTopology(float normX, float normZ, int mask, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				ref NativeArray<int> reference = ref dst;
				int num = z * res + x;
				reference[num] |= mask;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public override void Dispose()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.Dispose();
		if (_generatedTopologyTexture && (Object)(object)TopologyTexture != (Object)null)
		{
			Object.Destroy((Object)(object)TopologyTexture);
			TopologyTexture = null;
		}
		foreach (NativeReference<int> value in topoNative.Values)
		{
			if (value.IsCreated)
			{
				value.Dispose();
			}
		}
	}
}


using System;
using Facepunch;
using UnityEngine;

public class TerrainWaterFlowMap : TerrainMap<byte>
{
	private const float TwoPi = MathF.PI * 2f;

	public override void Setup()
	{
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
	}

	public override void PostSetup()
	{
		TimeWarning val = TimeWarning.New("TerrainWaterFlowMap.PostSetup", 0);
		try
		{
			WriteWaterFlowFromShoreVectors();
			WriteWaterFlowFromRivers();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void WriteWaterFlowFromShoreVectors()
	{
		Parallel.For(0, res * res, (Action<int>)delegate(int i)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			int index = i % res;
			int index2 = i / res;
			float num = Coordinate(index);
			float num2 = Coordinate(index2);
			int topology = TerrainMeta.TopologyMap.GetTopology(num, num2, 16f);
			Vector4 rawShoreVector = TerrainTexturing.Instance.GetRawShoreVector(new Vector2(num, num2));
			Vector3 flow = default(Vector3);
			((Vector3)(ref flow))..ctor(rawShoreVector.x, 0f, rawShoreVector.y);
			if ((topology & 0x14080) != 0)
			{
				SetFlowDirection(num, num2, flow);
			}
		});
	}

	private void WriteWaterFlowFromRivers()
	{
		foreach (PathList river in TerrainMeta.Path.Rivers)
		{
			river.AdjustTerrainWaterFlow(scaleWidthWithLength: true);
		}
	}

	public Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFlowDirection(normX, normZ);
	}

	public Vector3 GetFlowDirection(Vector2 worldPos2D)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos2D.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos2D.y);
		return GetFlowDirection(normX, normZ);
	}

	public Vector3 GetFlowDirection(float normX, float normZ)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(normX);
		int num2 = Index(normZ);
		float num3 = ByteToAngle(src[num2 * res + num]);
		return new Vector3(Mathf.Sin(num3), 0f, Mathf.Cos(num3));
	}

	public void SetFlowDirection(Vector3 worldPos, Vector3 flow)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetFlowDirection(normX, normZ, flow);
	}

	public void SetFlowDirection(float normX, float normZ, Vector3 flow)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(normX);
		int num2 = Index(normZ);
		Vector3 val = Vector3Extensions.XZ(flow, 0f);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		byte b = AngleToByte(Mathf.Atan2(normalized.x, normalized.z));
		src[num2 * res + num] = b;
	}

	private static float ByteToAngle(byte b)
	{
		return (float)(int)b / 255f * (MathF.PI * 2f) - MathF.PI;
	}

	private static byte AngleToByte(float a)
	{
		a = Mathf.Clamp(a, -MathF.PI, MathF.PI);
		return (byte)Mathf.RoundToInt((a + MathF.PI) / (MathF.PI * 2f) * 255f);
	}
}


using System;
using TerrainWaterMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainWaterMap : TerrainMap<short>
{
	public Texture2D WaterTexture;

	private bool _generatedWaterTexture;

	private float normY;

	public override void Setup()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
		if (!((Object)(object)WaterTexture != (Object)null))
		{
			return;
		}
		if (((Texture)WaterTexture).width == ((Texture)WaterTexture).height && ((Texture)WaterTexture).width == res)
		{
			Color32[] pixels = WaterTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					dst[i * res + num2] = BitUtility.DecodeShort(val);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid water texture: " + ((Object)WaterTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedWaterTexture && (Object)(object)WaterTexture != (Object)null)
		{
			Object.Destroy((Object)(object)WaterTexture);
			WaterTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Expected O, but got Unknown
		Color32[] heights = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				heights[z * res + i] = BitUtility.EncodeShort(src[z * res + i]);
			}
		});
		WaterTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)WaterTexture).name = "WaterTexture";
		((Texture)WaterTexture).wrapMode = (TextureWrapMode)1;
		WaterTexture.SetPixels32(heights);
		_generatedWaterTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		WaterTexture.Apply(true, true);
	}

	public float GetHeight(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(worldPos) * TerrainMeta.Size.y;
	}

	public float GetHeight(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainMeta.Position.y + num19 * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public void GetHeights(NativeArray<Vector3> worldPos, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByPosJob getHeightByPosJob = default(GetHeightByPosJob);
		getHeightByPosJob.Heights = results;
		getHeightByPosJob.Pos = worldPos;
		getHeightByPosJob.Data = src;
		getHeightByPosJob.Res = res;
		getHeightByPosJob.Offset = TerrainMeta.Position.y;
		getHeightByPosJob.Scale = TerrainMeta.Size.y;
		getHeightByPosJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		getHeightByPosJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		GetHeightByPosJob getHeightByPosJob2 = getHeightByPosJob;
		IJobExtensions.RunByRef<GetHeightByPosJob>(ref getHeightByPosJob2);
	}

	public void GetHeights(NativeArray<Vector2> uvs, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJob getHeightByUVJob = default(GetHeightByUVJob);
		getHeightByUVJob.Heights = results;
		getHeightByUVJob.UV = uvs;
		getHeightByUVJob.Data = src;
		getHeightByUVJob.Res = res;
		getHeightByUVJob.Offset = TerrainMeta.Position.y;
		getHeightByUVJob.Scale = TerrainMeta.Size.y;
		GetHeightByUVJob getHeightByUVJob2 = getHeightByUVJob;
		IJobExtensions.RunByRef<GetHeightByUVJob>(ref getHeightByUVJob2);
	}

	public void GetHeightsIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJobIndirect getHeightByUVJobIndirect = default(GetHeightByUVJobIndirect);
		getHeightByUVJobIndirect.Heights = results;
		getHeightByUVJobIndirect.UV = uvs;
		getHeightByUVJobIndirect.Indices = indices;
		getHeightByUVJobIndirect.Data = src.AsReadOnly();
		getHeightByUVJobIndirect.Res = res;
		getHeightByUVJobIndirect.Offset = TerrainMeta.Position.y;
		getHeightByUVJobIndirect.Scale = TerrainMeta.Size.y;
		GetHeightByUVJobIndirect getHeightByUVJobIndirect2 = getHeightByUVJobIndirect;
		IJobExtensions.RunByRef<GetHeightByUVJobIndirect>(ref getHeightByUVJobIndirect2);
	}

	public void GetHeights(NativeArray<Vector2i> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByIndexJob getHeightByIndexJob = default(GetHeightByIndexJob);
		getHeightByIndexJob.Heights = results;
		getHeightByIndexJob.Indices = indices;
		getHeightByIndexJob.Data = src;
		getHeightByIndexJob.Res = res;
		getHeightByIndexJob.Offset = TerrainMeta.Position.y;
		getHeightByIndexJob.Scale = TerrainMeta.Size.y;
		GetHeightByIndexJob getHeightByIndexJob2 = getHeightByIndexJob;
		IJobExtensions.RunByRef<GetHeightByIndexJob>(ref getHeightByIndexJob2);
	}

	public float GetHeight01(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetHeight01(normX, normZ);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetHeight01(num4, num5), GetHeight01(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetHeight01(num4, z), GetHeight01(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = GetHeight01(x, num5) - GetHeight01(num4, num5);
		float num7 = GetHeight01(num4, z) - GetHeight01(num4, num5);
		Vector3 val = new Vector3(0f - num6, normY, 0f - num7);
		return ((Vector3)(ref val)).normalized;
	}

	public Vector3 GetNormalFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int num2 = (int)(uv.x * (float)num);
		int num3 = (int)(uv.y * (float)num);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		int num4 = ((num2 < num) ? 1 : 0);
		int num5 = ((num3 < num) ? res : 0);
		int num6 = num3 * res + num2;
		int num7 = num6 + num4;
		int num8 = num6 + num5;
		short num9 = src[num6];
		short num10 = src[num7];
		short num11 = src[num8];
		float num12 = (float)(num10 - num9) * 3.051944E-05f;
		float num13 = (float)(num11 - num9) * 3.051944E-05f;
		return new Vector3(0f - num12, normY, 0f - num13);
	}

	public Vector3 GetNormal(int x, int z)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = (GetHeight01(x3, z2) - GetHeight01(x2, z2)) * 0.5f;
		float num3 = (GetHeight01(x2, z3) - GetHeight01(x2, z2)) * 0.5f;
		Vector3 val = new Vector3(0f - num2, normY, 0f - num3);
		return ((Vector3)(ref val)).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public float GetDepth(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetHeight(worldPos) - TerrainMeta.HeightMap.GetHeight(worldPos);
	}

	public float GetDepth(float normX, float normZ)
	{
		return GetHeight(normX, normZ) - TerrainMeta.HeightMap.GetHeight(normX, normZ);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z * res + x] = BitUtility.Float2Short(height);
	}
}


using UnityEngine;

public class TerrainMargin
{
	private static MaterialPropertyBlock materialPropertyBlock;

	public static void Create()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		Material marginMaterial = TerrainMeta.Config.MarginMaterial;
		Vector3 center = TerrainMeta.Center;
		Vector3 size = TerrainMeta.Size;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(size.x, 0f, 0f);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(0f, 0f, size.z);
		center.y = TerrainMeta.HeightMap.GetHeight(0, 0);
		Create(center - val2, size, marginMaterial);
		Create(center - val2 - val, size, marginMaterial);
		Create(center - val2 + val, size, marginMaterial);
		Create(center - val, size, marginMaterial);
		Create(center + val, size, marginMaterial);
		Create(center + val2, size, marginMaterial);
		Create(center + val2 - val, size, marginMaterial);
		Create(center + val2 + val, size, marginMaterial);
	}

	private static void Create(Vector3 position, Vector3 size, Material material)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = GameObject.CreatePrimitive((PrimitiveType)4);
		((Object)obj).name = "TerrainMargin";
		obj.layer = 16;
		obj.transform.position = position;
		obj.transform.localScale = size * 0.1f;
		Object.Destroy((Object)(object)obj.GetComponent<MeshRenderer>());
		Object.Destroy((Object)(object)obj.GetComponent<MeshFilter>());
	}
}


using Oxide.Core;
using UnityEngine;

[ExecuteInEditMode]
public class TerrainMeta : MonoBehaviour
{
	public enum PaintMode
	{
		None,
		Splats,
		Biomes,
		Alpha,
		Blend,
		Field,
		Cliff,
		Summit,
		Beachside,
		Beach,
		Forest,
		Forestside,
		Ocean,
		Oceanside,
		Decor,
		Monument,
		Road,
		Roadside,
		Swamp,
		River,
		Riverside,
		Lake,
		Lakeside,
		Offshore,
		Rail,
		Railside,
		Building,
		Cliffside,
		Mountain,
		Clutter,
		Alt,
		Tier0,
		Tier1,
		Tier2,
		Mainland,
		Hilltop
	}

	public Terrain terrain;

	public TerrainConfig config;

	public PaintMode paint;

	[HideInInspector]
	public PaintMode currentPaintMode;

	public static TerrainConfig Config { get; private set; }

	public static Terrain Terrain { get; private set; }

	public static Transform Transform { get; private set; }

	public static Vector3 Position { get; private set; }

	public static Vector3 Size { get; private set; }

	public static Vector3 Center => Position + Size * 0.5f;

	public static Vector3 Max => Position + Size;

	public static Vector3 OneOverSize { get; private set; }

	public static Vector3 HighestPoint { get; set; }

	public static Vector3 LowestPoint { get; set; }

	public static float LootAxisAngle { get; private set; }

	public static float BiomeAxisAngle { get; private set; }

	public static TerrainData Data { get; private set; }

	public static TerrainCollider Collider { get; private set; }

	public static TerrainCollision Collision { get; private set; }

	public static TerrainPhysics Physics { get; private set; }

	public static TerrainColors Colors { get; private set; }

	public static TerrainQuality Quality { get; private set; }

	public static TerrainPath Path { get; private set; }

	public static TerrainBiomeMap BiomeMap { get; private set; }

	public static TerrainAlphaMap AlphaMap { get; private set; }

	public static TerrainBlendMap BlendMap { get; private set; }

	public static TerrainHeightMap HeightMap { get; private set; }

	public static TerrainSplatMap SplatMap { get; private set; }

	public static TerrainTopologyMap TopologyMap { get; private set; }

	public static TerrainWaterMap WaterMap { get; private set; }

	public static TerrainWaterFlowMap WaterFlowMap { get; private set; }

	public static TerrainDistanceMap DistanceMap { get; private set; }

	public static TerrainPlacementMap PlacementMap { get; private set; }

	public static TerrainTexturing Texturing { get; private set; }

	public static bool OutOfBounds(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x)
		{
			return true;
		}
		if (worldPos.z < Position.z)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfMargin(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x - Size.x)
		{
			return true;
		}
		if (worldPos.z < Position.z - Size.z)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x + Size.x)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z + Size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfMarginPlusTutorialBounds(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x - Size.x - TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.z < Position.z - Size.z - TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x + Size.x + TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z + Size.z + TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		return false;
	}

	public static float InnerDistToEdge2D(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		float num = Position.x - Size.x;
		float num2 = Position.x + Size.x + Size.x;
		float num3 = Position.z - Size.z;
		float num4 = Position.z + Size.z + Size.z;
		float num5 = Mathf.Abs(worldPos.x - num);
		float num6 = Mathf.Abs(worldPos.x - num2);
		float num7 = Mathf.Abs(worldPos.z - num3);
		float num8 = Mathf.Abs(worldPos.z - num4);
		return Mathf.Min(num5, Mathf.Min(num6, Mathf.Min(num7, num8)));
	}

	public static bool IsPointWithinTutorialBounds(Vector3 worldPos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		float tutorialBoundsSize = TutorialIsland.TutorialBoundsSize;
		float maximumPointTutorial = ValidBounds.GetMaximumPointTutorial();
		float num = 0f - maximumPointTutorial + tutorialBoundsSize;
		float num2 = maximumPointTutorial - tutorialBoundsSize;
		float num3 = 0f - maximumPointTutorial + tutorialBoundsSize;
		float num4 = maximumPointTutorial - tutorialBoundsSize;
		if (!(worldPos.x < num) && !(worldPos.x > num2) && !(worldPos.z < num3))
		{
			return worldPos.z > num4;
		}
		return true;
	}

	public static bool RandomWaterPointInAnnulus(Vector3 centre, float minRadius, float maxRadius, out Vector3 randomPoint)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 100; i++)
		{
			Vector3 val = Vector2.op_Implicit(Random.insideUnitCircle);
			float num = Random.Range(minRadius, maxRadius);
			Vector3 val2 = centre + new Vector3(val.x, 0f, val.y) * num;
			float height = HeightMap.GetHeight(val2);
			float height2 = WaterMap.GetHeight(val2);
			if (height <= height2)
			{
				randomPoint = val2;
				return true;
			}
		}
		randomPoint = Vector3.zero;
		return false;
	}

	public static Vector3 RandomPointOffshore()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		float num = Random.Range(-1f, 1f);
		float num2 = Random.Range(0f, 100f);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Min(Size.x, 4000f) - 100f, 0f, Mathf.Min(Size.z, 4000f) - 100f);
		if (num2 < 25f)
		{
			return Center + new Vector3(0f - val.x, 0f, num * val.z);
		}
		if (num2 < 50f)
		{
			return Center + new Vector3(val.x, 0f, num * val.z);
		}
		if (num2 < 75f)
		{
			return Center + new Vector3(num * val.x, 0f, 0f - val.z);
		}
		return Center + new Vector3(num * val.x, 0f, val.z);
	}

	public static Vector3 RandomPoint(bool excludeWater = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		while (((Vector3)(ref val)).Equals(default(Vector3)) || (excludeWater && WaterLevel.Test(val, waves: true, volumes: true)))
		{
			float num = Random.Range(0f, Terrain.terrainData.size.x);
			float num2 = Random.Range(0f, Terrain.terrainData.size.z);
			float height = HeightMap.GetHeight(new Vector3(num, 0f, num2));
			((Vector3)(ref val))..ctor(num, height, num2);
		}
		return val;
	}

	public static Vector3 Normalize(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = (worldPos.x - Position.x) * OneOverSize.x;
		float num2 = (worldPos.y - Position.y) * OneOverSize.y;
		float num3 = (worldPos.z - Position.z) * OneOverSize.z;
		return new Vector3(num, num2, num3);
	}

	public static float NormalizeX(float x)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (x - Position.x) * OneOverSize.x;
	}

	public static float NormalizeY(float y)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (y - Position.y) * OneOverSize.y;
	}

	public static float NormalizeZ(float z)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (z - Position.z) * OneOverSize.z;
	}

	public static Vector3 Denormalize(Vector3 normPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = Position.x + normPos.x * Size.x;
		float num2 = Position.y + normPos.y * Size.y;
		float num3 = Position.z + normPos.z * Size.z;
		return new Vector3(num, num2, num3);
	}

	public static float DenormalizeX(float normX)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.x + normX * Size.x;
	}

	public static float DenormalizeY(float normY)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.y + normY * Size.y;
	}

	public static float DenormalizeZ(float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.z + normZ * Size.z;
	}

	protected void Awake()
	{
		if (Application.isPlaying)
		{
			Shader.DisableKeyword("TERRAIN_PAINTING");
		}
	}

	public void Init(Terrain terrainOverride = null, TerrainConfig configOverride = null)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)terrainOverride != (Object)null)
		{
			terrain = terrainOverride;
		}
		if ((Object)(object)configOverride != (Object)null)
		{
			config = configOverride;
		}
		Terrain = terrain;
		Config = config;
		Transform = ((Component)terrain).transform;
		Data = terrain.terrainData;
		Size = terrain.terrainData.size;
		OneOverSize = Vector3Ex.Inverse(Size);
		Position = terrain.GetPosition();
		Collider = ((Component)terrain).GetComponent<TerrainCollider>();
		Collision = ((Component)terrain).GetComponent<TerrainCollision>();
		Physics = ((Component)terrain).GetComponent<TerrainPhysics>();
		Colors = ((Component)terrain).GetComponent<TerrainColors>();
		Quality = ((Component)terrain).GetComponent<TerrainQuality>();
		Path = ((Component)terrain).GetComponent<TerrainPath>();
		BiomeMap = ((Component)terrain).GetComponent<TerrainBiomeMap>();
		AlphaMap = ((Component)terrain).GetComponent<TerrainAlphaMap>();
		BlendMap = ((Component)terrain).GetComponent<TerrainBlendMap>();
		HeightMap = ((Component)terrain).GetComponent<TerrainHeightMap>();
		SplatMap = ((Component)terrain).GetComponent<TerrainSplatMap>();
		TopologyMap = ((Component)terrain).GetComponent<TerrainTopologyMap>();
		WaterMap = ((Component)terrain).GetComponent<TerrainWaterMap>();
		WaterFlowMap = ((Component)terrain).GetComponent<TerrainWaterFlowMap>();
		DistanceMap = ((Component)terrain).GetComponent<TerrainDistanceMap>();
		PlacementMap = ((Component)terrain).GetComponent<TerrainPlacementMap>();
		Texturing = ((Component)terrain).GetComponent<TerrainTexturing>();
		terrain.drawInstanced = false;
		HighestPoint = new Vector3(Position.x, Position.y + Size.y, Position.z);
		LowestPoint = new Vector3(Position.x, Position.y, Position.z);
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].Init(terrain, config);
		}
		uint seed = World.Seed;
		int num = SeedRandom.Range(ref seed, 0, 4) * 90;
		int num2 = SeedRandom.Range(ref seed, -45, 46);
		int num3 = SeedRandom.Sign(ref seed);
		LootAxisAngle = num;
		BiomeAxisAngle = num + num2 + num3 * 90;
	}

	public static void InitNoTerrain(bool createPath = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Size = new Vector3(4096f, 4096f, 4096f);
		OneOverSize = Vector3Ex.Inverse(Size);
		Position = -0.5f * Size;
	}

	public void SetupComponents()
	{
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		foreach (TerrainExtension obj in components)
		{
			obj.Setup();
			obj.isInitialized = true;
		}
	}

	public void PostSetupComponents()
	{
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

	public void BindShaderProperties()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)config))
		{
			Shader.SetGlobalTexture("Terrain_AlbedoArray", config.AlbedoArray);
			Shader.SetGlobalTexture("Terrain_NormalArray", config.NormalArray);
			Shader.SetGlobalVector("Terrain_TexelSize", Vector4.op_Implicit(new Vector2(1f / config.GetMinSplatTiling(), 1f / config.GetMinSplatTiling())));
			Shader.SetGlobalVector("Terrain_TexelSize0", new Vector4(1f / config.Splats[0].SplatTiling, 1f / config.Splats[1].SplatTiling, 1f / config.Splats[2].SplatTiling, 1f / config.Splats[3].SplatTiling));
			Shader.SetGlobalVector("Terrain_TexelSize1", new Vector4(1f / config.Splats[4].SplatTiling, 1f / config.Splats[5].SplatTiling, 1f / config.Splats[6].SplatTiling, 1f / config.Splats[7].SplatTiling));
			Shader.SetGlobalVector("Splat0_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[0].UVMIXMult, config.Splats[0].UVMIXStart, 1f / config.Splats[0].UVMIXDist)));
			Shader.SetGlobalVector("Splat1_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[1].UVMIXMult, config.Splats[1].UVMIXStart, 1f / config.Splats[1].UVMIXDist)));
			Shader.SetGlobalVector("Splat2_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[2].UVMIXMult, config.Splats[2].UVMIXStart, 1f / config.Splats[2].UVMIXDist)));
			Shader.SetGlobalVector("Splat3_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[3].UVMIXMult, config.Splats[3].UVMIXStart, 1f / config.Splats[3].UVMIXDist)));
			Shader.SetGlobalVector("Splat4_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[4].UVMIXMult, config.Splats[4].UVMIXStart, 1f / config.Splats[4].UVMIXDist)));
			Shader.SetGlobalVector("Splat5_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[5].UVMIXMult, config.Splats[5].UVMIXStart, 1f / config.Splats[5].UVMIXDist)));
			Shader.SetGlobalVector("Splat6_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[6].UVMIXMult, config.Splats[6].UVMIXStart, 1f / config.Splats[6].UVMIXDist)));
			Shader.SetGlobalVector("Splat7_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[7].UVMIXMult, config.Splats[7].UVMIXStart, 1f / config.Splats[7].UVMIXDist)));
		}
		if (Object.op_Implicit((Object)(object)HeightMap))
		{
			Shader.SetGlobalTexture("Terrain_Normal", (Texture)(object)HeightMap.NormalTexture);
		}
		if (Object.op_Implicit((Object)(object)AlphaMap))
		{
			Shader.SetGlobalTexture("Terrain_Alpha", (Texture)(object)AlphaMap.AlphaTexture);
		}
		if (Object.op_Implicit((Object)(object)BiomeMap))
		{
			Shader.SetGlobalTexture("Terrain_Biome", (Texture)(object)BiomeMap.BiomeTexture);
		}
		if (Object.op_Implicit((Object)(object)SplatMap))
		{
			Shader.SetGlobalTexture("Terrain_Control0", (Texture)(object)SplatMap.SplatTexture0);
			Shader.SetGlobalTexture("Terrain_Control1", (Texture)(object)SplatMap.SplatTexture1);
		}
		Object.op_Implicit((Object)(object)WaterMap);
		Object.op_Implicit((Object)(object)DistanceMap);
		if (!Object.op_Implicit((Object)(object)terrain))
		{
			return;
		}
		Shader.SetGlobalVector("Terrain_Position", Vector4.op_Implicit(Position));
		Shader.SetGlobalVector("Terrain_Size", Vector4.op_Implicit(Size));
		Shader.SetGlobalVector("Terrain_RcpSize", Vector4.op_Implicit(OneOverSize));
		if (Object.op_Implicit((Object)(object)terrain.materialTemplate))
		{
			if (terrain.materialTemplate.IsKeywordEnabled("_TERRAIN_BLEND_LINEAR"))
			{
				terrain.materialTemplate.DisableKeyword("_TERRAIN_BLEND_LINEAR");
			}
			if (terrain.materialTemplate.IsKeywordEnabled("_TERRAIN_VERTEX_NORMALS"))
			{
				terrain.materialTemplate.DisableKeyword("_TERRAIN_VERTEX_NORMALS");
			}
		}
	}
}


public enum PaintMode
{
	None,
	Splats,
	Biomes,
	Alpha,
	Blend,
	Field,
	Cliff,
	Summit,
	Beachside,
	Beach,
	Forest,
	Forestside,
	Ocean,
	Oceanside,
	Decor,
	Monument,
	Road,
	Roadside,
	Swamp,
	River,
	Riverside,
	Lake,
	Lakeside,
	Offshore,
	Rail,
	Railside,
	Building,
	Cliffside,
	Mountain,
	Clutter,
	Alt,
	Tier0,
	Tier1,
	Tier2,
	Mainland,
	Hilltop
}


using UnityEngine;

[ExecuteInEditMode]
public class TerrainPaint : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TerrainPath : TerrainExtension
{
	public List<PathList> Roads = new List<PathList>();

	public List<PathList> MainRoads = new List<PathList>();

	public List<PathList> SideRoads = new List<PathList>();

	public List<PathList> TrailRoads = new List<PathList>();

	public List<PathList> Rails = new List<PathList>();

	public List<PathList> Rivers = new List<PathList>();

	public List<PathList> Powerlines = new List<PathList>();

	public List<LandmarkInfo> Landmarks = new List<LandmarkInfo>();

	public List<MonumentInfo> Monuments = new List<MonumentInfo>();

	public List<RiverInfo> RiverObjs = new List<RiverInfo>();

	public List<LakeInfo> LakeObjs = new List<LakeInfo>();

	public GameObject DungeonGridRoot;

	public List<DungeonGridInfo> DungeonGridEntrances = new List<DungeonGridInfo>();

	public List<DungeonGridCell> DungeonGridCells = new List<DungeonGridCell>();

	public GameObject DungeonBaseRoot;

	public List<DungeonBaseInfo> DungeonBaseEntrances = new List<DungeonBaseInfo>();

	public List<DungeonBaseLink> DungeonBaseLinks = new List<DungeonBaseLink>();

	public List<Vector3> OceanPatrolClose = new List<Vector3>();

	public List<Vector3> OceanPatrolFar = new List<Vector3>();

	public Dictionary<string, List<PowerlineNode>> wires = new Dictionary<string, List<PowerlineNode>>();

	public override void PostSetup()
	{
		foreach (PathList road in Roads)
		{
			road.ProcgenStartNode = null;
			road.ProcgenEndNode = null;
		}
		foreach (PathList rail in Rails)
		{
			rail.ProcgenStartNode = null;
			rail.ProcgenEndNode = null;
		}
		foreach (PathList river in Rivers)
		{
			river.ProcgenStartNode = null;
			river.ProcgenEndNode = null;
		}
		foreach (PathList powerline in Powerlines)
		{
			powerline.ProcgenStartNode = null;
			powerline.ProcgenEndNode = null;
		}
	}

	public void Clear()
	{
		Roads.Clear();
		Rails.Clear();
		Rivers.Clear();
		Powerlines.Clear();
	}

	public T FindClosest<T>(List<T> list, Vector3 pos) where T : MonoBehaviour
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		T result = default(T);
		float num = float.MaxValue;
		foreach (T item in list)
		{
			float num2 = Vector3Ex.Distance2D(((Component)(object)item).transform.position, pos);
			if (!(num2 >= num))
			{
				result = item;
				num = num2;
			}
		}
		return result;
	}

	public static int[,] CreatePowerlineCostmap(ref uint seed)
	{
		float radius = 5f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int num2 = 10683780;
				int num3 = 1628160;
				int num4 = 514;
				if ((topology & num2) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num3) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 2500;
				}
				else if ((topology & num4) != 0)
				{
					array[j, i] = 1000;
				}
				else
				{
					array[j, i] = 1 + (int)(slope * slope * 10f);
				}
			}
		}
		return array;
	}

	public static int[,] CreateRoadCostmap(ref uint seed, bool trail = false)
	{
		float radius = 5f;
		float radius2 = 15f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				int num2 = SeedRandom.Range(ref seed, 100, 200);
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int topology2 = topologyMap.GetTopology(normX, normZ, radius2);
				int num3 = 196996;
				int num4 = 10487296;
				int num5 = 2;
				int num6 = 49152;
				if (slope > 20f || (topology & num3) != 0 || (topology2 & num4) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num6) != 0)
				{
					array[j, i] = (trail ? int.MaxValue : 5000);
				}
				else if ((topology & num5) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 5000;
				}
				else
				{
					array[j, i] = 1 + (int)(slope * slope * 10f) + num2;
				}
			}
		}
		return array;
	}

	public static int[,] CreateRailCostmap(ref uint seed)
	{
		float radius = 5f;
		float radius2 = 25f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int topology2 = topologyMap.GetTopology(normX, normZ, radius2);
				int num2 = 196996;
				int num3 = 10487296;
				int num4 = 2;
				int num5 = 49152;
				if (slope > 30f || (topology & num2) != 0 || (topology2 & num3) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num5) != 0)
				{
					array[j, i] = 5000;
				}
				else if (slope > 20f || (topology & num4) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 5000;
				}
				else if (slope > 10f)
				{
					array[j, i] = 1500;
				}
				else
				{
					array[j, i] = 1000;
				}
			}
		}
		return array;
	}

	public static int[,] CreateBoatCostmap(float depth)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)((float)World.Size / 7.5f);
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				if (WaterLevel.GetOverallWaterDepth(new Vector3(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ)), waves: false, volumes: false) < depth)
				{
					array[j, i] = int.MaxValue;
				}
				else
				{
					array[j, i] = 1;
				}
			}
		}
		return array;
	}

	public void AddWire(PowerlineNode node)
	{
		string name = ((Object)((Component)node).transform.root).name;
		if (!wires.ContainsKey(name))
		{
			wires.Add(name, new List<PowerlineNode>());
		}
		wires[name].Add(node);
	}

	public void CreateWires()
	{
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		List<GameObject> list = new List<GameObject>();
		int num = 0;
		GameObjectRef gameObjectRef = null;
		foreach (KeyValuePair<string, List<PowerlineNode>> wire in wires)
		{
			foreach (PowerlineNode item in wire.Value)
			{
				PowerLineWireConnectionHelper component = ((Component)item).GetComponent<PowerLineWireConnectionHelper>();
				if (!Object.op_Implicit((Object)(object)component))
				{
					continue;
				}
				if (list.Count == 0)
				{
					gameObjectRef = item.WirePrefab;
					num = component.connections.Count;
				}
				else
				{
					GameObject val = list[list.Count - 1];
					if (!(item.WirePrefab.guid != gameObjectRef?.guid) && component.connections.Count == num)
					{
						Vector3 val2 = val.transform.position - ((Component)item).transform.position;
						if (!(((Vector3)(ref val2)).sqrMagnitude > item.MaxDistance * item.MaxDistance))
						{
							goto IL_0101;
						}
					}
					CreateWire(wire.Key, list, gameObjectRef);
					list.Clear();
				}
				goto IL_0101;
				IL_0101:
				list.Add(((Component)item).gameObject);
			}
			CreateWire(wire.Key, list, gameObjectRef);
			list.Clear();
		}
	}

	private void CreateWire(string name, List<GameObject> objects, GameObjectRef wirePrefab)
	{
		if (objects.Count >= 3 && wirePrefab != null && wirePrefab.isValid)
		{
			PowerLineWire powerLineWire = PowerLineWire.Create(null, objects, wirePrefab, "Powerline Wires", null, 1f, 0.1f);
			if (Object.op_Implicit((Object)(object)powerLineWire))
			{
				((Behaviour)powerLineWire).enabled = false;
				((Component)powerLineWire).gameObject.SetHierarchyGroup(name);
			}
		}
	}

	public MonumentInfo FindMonumentWithBoundsOverlap(Vector3 position, MonumentType[] types = null)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in Monuments)
		{
			if ((Object)(object)monument != (Object)null && (types == null || Array.IndexOf(types, monument.Type) != -1) && monument.IsInBounds(position))
			{
				return monument;
			}
		}
		return null;
	}

	public void AddRoad(List<PathList> newRoadList, bool addToMaster = true)
	{
		foreach (PathList newRoad in newRoadList)
		{
			AddRoad(newRoad, addToMaster);
		}
	}

	public void AddRoad(PathList newRoad, bool addToMaster = true)
	{
		switch (newRoad?.Hierarchy)
		{
		case 0:
			MainRoads.Add(newRoad);
			break;
		case 1:
			SideRoads.Add(newRoad);
			break;
		case 2:
			TrailRoads.Add(newRoad);
			break;
		default:
			MainRoads.Add(newRoad);
			break;
		}
		if (addToMaster && newRoad != null)
		{
			Roads.Add(newRoad);
		}
	}
}


public enum InfrastructureType
{
	Road,
	Power,
	Trail,
	Tunnel,
	UnderwaterLab,
	Boat,
	Rail
}


using UnityEngine;

public class TerrainPhysics : TerrainExtension
{
	private TerrainSplatMap splat;

	private PhysicMaterial[] materials;

	public override void Setup()
	{
		splat = ((Component)terrain).GetComponent<TerrainSplatMap>();
		materials = config.GetPhysicMaterials();
	}

	public PhysicMaterial GetMaterial(Vector3 worldPos)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)splat == (Object)null || materials.Length == 0)
		{
			return null;
		}
		return materials[splat.GetSplatMaxIndex(worldPos)];
	}
}


public class TerrainQuality : TerrainExtension
{
}


using System;
using Rust;
using TerrainTexturingJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[ExecuteInEditMode]
public class TerrainTexturing : TerrainExtension
{
	public struct ShoreVectorQueryStructure
	{
		public ReadOnly<float> ShoreDistances;

		public float ShoreDistanceScale;

		public int ShoreMapSize;

		public float GetCoarseDistanceToShore(Vector2 uv)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			int shoreMapSize = ShoreMapSize;
			int num = shoreMapSize - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
			int num10 = num5 * shoreMapSize + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = ShoreDistances[num10];
			float num15 = ShoreDistances[num11];
			float num16 = ShoreDistances[num12];
			float num17 = ShoreDistances[num13];
			float num18 = (num15 - num14) * num6 + num14;
			return (((num17 - num16) * num6 + num16 - num18) * num7 + num18) * ShoreDistanceScale;
		}
	}

	public bool debugFoliageDisplacement;

	private bool initialized;

	private static TerrainTexturing instance;

	private int afCached;

	private int globalTextureMipmapLimitCached;

	private int anisotropicFilteringCached;

	private bool streamingMipmapsActiveCached;

	private bool billboardsFaceCameraPositionCached;

	private const int ShoreVectorDownscale = 1;

	private const int ShoreVectorBlurPasses = 1;

	private float terrainSize;

	private int shoreMapSize;

	private float shoreDistanceScale;

	private NativeArray<float> shoreDistances;

	private NativeArray<float4> shoreVectors;

	public static TerrainTexturing Instance => instance;

	public bool TexturesInitialized => initialized;

	public int ShoreMapSize => shoreMapSize;

	public ReadOnlySpan<float4> ShoreMap => NativeArray<float4>.op_Implicit(ref shoreVectors);

	private void ReleaseBasePyramid()
	{
	}

	private void UpdateBasePyramid()
	{
	}

	private void InitializeCoarseHeightSlope()
	{
	}

	private void ReleaseCoarseHeightSlope()
	{
	}

	private void UpdateCoarseHeightSlope()
	{
	}

	private void CheckInstance()
	{
		instance = (((Object)(object)instance != (Object)null) ? instance : this);
	}

	private void Awake()
	{
		CheckInstance();
	}

	public override void Setup()
	{
		CheckInstance();
		InitializeShoreVector();
	}

	public override void PostSetup()
	{
		TerrainMeta component = ((Component)this).GetComponent<TerrainMeta>();
		if ((Object)(object)component == (Object)null || (Object)(object)component.config == (Object)null)
		{
			Debug.LogError((object)"[TerrainTexturing] Missing TerrainMeta or TerrainConfig not assigned.");
			return;
		}
		Shutdown();
		InitializeCoarseHeightSlope();
		GenerateShoreVector();
		InitializeWaterHeight();
		initialized = true;
	}

	private void Shutdown()
	{
		ReleaseBasePyramid();
		ReleaseCoarseHeightSlope();
		ReleaseShoreVector();
		ReleaseWaterHeight();
		initialized = false;
	}

	public void OnEnable()
	{
		CheckInstance();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Shutdown();
		}
	}

	private void Update()
	{
		if (initialized)
		{
			UpdateBasePyramid();
			UpdateCoarseHeightSlope();
			UpdateWaterHeight();
		}
	}

	private void InitializeShoreVector()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.ClosestPowerOfTwo(terrain.terrainData.heightmapResolution) >> 1;
		int num2 = num * num;
		terrainSize = Mathf.Max(terrain.terrainData.size.x, terrain.terrainData.size.z);
		shoreMapSize = num;
		shoreDistanceScale = terrainSize / (float)shoreMapSize;
		shoreDistances = new NativeArray<float>(num * num, (Allocator)4, (NativeArrayOptions)0);
		shoreVectors = new NativeArray<float4>(num * num, (Allocator)4, (NativeArrayOptions)0);
		for (int i = 0; i < num2; i++)
		{
			shoreDistances[i] = 10000f;
			shoreVectors[i] = new float4(1f, 1f, 1f, 0f);
		}
	}

	private void GenerateShoreVector()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GenerateShoreVector", 500);
		try
		{
			GenerateShoreVector(out var distances, out var vectors);
			if (!shoreDistances.IsCreated)
			{
				shoreDistances = new NativeArray<float>(distances, (Allocator)4);
			}
			else
			{
				shoreDistances.CopyFrom(distances);
			}
			if (!shoreVectors.IsCreated)
			{
				shoreVectors = new NativeArray<float4>(vectors.Length, (Allocator)4, (NativeArrayOptions)0);
			}
			for (int i = 0; i < vectors.Length; i++)
			{
				shoreVectors[i] = float4.op_Implicit(vectors[i]);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void OnDestroy()
	{
		ReleaseShoreVector();
	}

	private void ReleaseShoreVector()
	{
		NativeArrayEx.SafeDispose(ref shoreDistances);
		shoreVectors.SafeDispose<float4>();
	}

	private void GenerateShoreVector(out float[] distances, out Vector4[] vectors)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		float num = terrainSize / (float)shoreMapSize;
		Vector3 position = terrain.GetPosition();
		byte[] image = new byte[shoreMapSize * shoreMapSize];
		distances = new float[shoreMapSize * shoreMapSize];
		vectors = (Vector4[])(object)new Vector4[shoreMapSize * shoreMapSize];
		int i = 0;
		int num2 = 0;
		for (; i < shoreMapSize; i++)
		{
			int num3 = 0;
			while (num3 < shoreMapSize)
			{
				float num4 = ((float)num3 + 0.5f) * num;
				float num5 = ((float)i + 0.5f) * num;
				bool flag = WaterLevel.GetOverallWaterDepth(new Vector3(position.x, 0f, position.z) + new Vector3(num4, 0f, num5), waves: false, volumes: false) <= 0f;
				image[num2] = (byte)(flag ? 255u : 0u);
				distances[num2] = (flag ? 256 : 0);
				num3++;
				num2++;
			}
		}
		DistanceField.Generate(in shoreMapSize, (byte)127, in image, ref distances);
		DistanceField.ApplyGaussianBlur(shoreMapSize, distances);
		DistanceField.GenerateVectors(in shoreMapSize, in distances, ref vectors);
		int j = 0;
		int num6 = 0;
		for (; j < shoreMapSize; j++)
		{
			int num7 = 0;
			while (num7 < shoreMapSize)
			{
				float num8 = ((float)num7 + 0.5f) * num;
				float num9 = ((float)j + 0.5f) * num;
				Vector3 worldPos = new Vector3(position.x, 0f, position.z) + new Vector3(num8, 0f, num9);
				Vector4 val = vectors[j * shoreMapSize + num7];
				if ((Object)(object)TerrainMeta.TopologyMap != (Object)null && TerrainMeta.TopologyMap.isInitialized && (Object)(object)TerrainMeta.HeightMap != (Object)null && TerrainMeta.HeightMap.isInitialized)
				{
					float height = TerrainMeta.HeightMap.GetHeight(worldPos);
					float num10 = Mathf.InverseLerp(4f, 0f, height);
					float radius = Mathf.Lerp(16f, 64f, num10);
					int topology = TerrainMeta.TopologyMap.GetTopology(worldPos, radius);
					if ((topology & 0x180) != 0)
					{
						val.w = 1f;
					}
					else if ((topology & 0x32000) != 0)
					{
						val.w = 2f;
					}
					else if ((topology & 0xC000) != 0)
					{
						val.w = 3f;
					}
				}
				else
				{
					val.w = -1f;
				}
				vectors[j * shoreMapSize + num7] = val;
				num7++;
				num6++;
			}
		}
	}

	public float GetCoarseDistanceToShore(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - TerrainMeta.Position.x) * TerrainMeta.OneOverSize.x;
		uv.y = (pos.z - TerrainMeta.Position.z) * TerrainMeta.OneOverSize.z;
		return GetCoarseDistanceToShore(uv);
	}

	public ShoreVectorQueryStructure GetShoreVectorQueryStructure()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		ShoreVectorQueryStructure result = default(ShoreVectorQueryStructure);
		result.ShoreDistances = shoreDistances.AsReadOnly();
		result.ShoreDistanceScale = shoreDistanceScale;
		result.ShoreMapSize = shoreMapSize;
		return result;
	}

	public float GetCoarseDistanceToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		int num = shoreMapSize;
		int num2 = num - 1;
		float num3 = uv.x * (float)num2;
		float num4 = uv.y * (float)num2;
		int num5 = (int)num3;
		int num6 = (int)num4;
		float num7 = num3 - (float)num5;
		float num8 = num4 - (float)num6;
		num5 = ((num5 >= 0) ? num5 : 0);
		num6 = ((num6 >= 0) ? num6 : 0);
		num5 = ((num5 <= num2) ? num5 : num2);
		num6 = ((num6 <= num2) ? num6 : num2);
		int num9 = ((num3 < (float)num2) ? 1 : 0);
		int num10 = ((num4 < (float)num2) ? num : 0);
		int num11 = num6 * num + num5;
		int num12 = num11 + num9;
		int num13 = num11 + num10;
		int num14 = num13 + num9;
		float num15 = shoreDistances[num11];
		float num16 = shoreDistances[num12];
		float num17 = shoreDistances[num13];
		float num18 = shoreDistances[num14];
		float num19 = (num16 - num15) * num7 + num15;
		return (((num18 - num17) * num7 + num17 - num19) * num8 + num19) * shoreDistanceScale;
	}

	public void GetCoarseDistancesToShoreIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		GetCoarseDistsToShoreJobIndirect getCoarseDistsToShoreJobIndirect = default(GetCoarseDistsToShoreJobIndirect);
		getCoarseDistsToShoreJobIndirect.Dists = results;
		getCoarseDistsToShoreJobIndirect.UVs = uvs;
		getCoarseDistsToShoreJobIndirect.Indices = indices;
		getCoarseDistsToShoreJobIndirect.Data = shoreDistances.AsReadOnly();
		getCoarseDistsToShoreJobIndirect.ShoreMapSize = shoreMapSize;
		getCoarseDistsToShoreJobIndirect.ShoreDistanceScale = shoreDistanceScale;
		GetCoarseDistsToShoreJobIndirect getCoarseDistsToShoreJobIndirect2 = getCoarseDistsToShoreJobIndirect;
		IJobExtensions.RunByRef<GetCoarseDistsToShoreJobIndirect>(ref getCoarseDistsToShoreJobIndirect2);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - TerrainMeta.Position.x) * TerrainMeta.OneOverSize.x;
		uv.y = (pos.z - TerrainMeta.Position.z) * TerrainMeta.OneOverSize.z;
		return GetCoarseVectorToShore(uv);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		int num = shoreMapSize;
		int num2 = num - 1;
		float num3 = uv.x * (float)num2;
		float num4 = uv.y * (float)num2;
		int num5 = (int)num3;
		int num6 = (int)num4;
		float num7 = num3 - (float)num5;
		float num8 = num4 - (float)num6;
		num5 = ((num5 >= 0) ? num5 : 0);
		num6 = ((num6 >= 0) ? num6 : 0);
		num5 = ((num5 <= num2) ? num5 : num2);
		num6 = ((num6 <= num2) ? num6 : num2);
		int num9 = ((num3 < (float)num2) ? 1 : 0);
		int num10 = ((num4 < (float)num2) ? num : 0);
		int num11 = num6 * num + num5;
		int num12 = num11 + num9;
		int num13 = num11 + num10;
		int num14 = num13 + num9;
		float4 val = shoreVectors[num11];
		float3 xyz = ((float4)(ref val)).xyz;
		val = shoreVectors[num12];
		float3 xyz2 = ((float4)(ref val)).xyz;
		val = shoreVectors[num13];
		float3 xyz3 = ((float4)(ref val)).xyz;
		val = shoreVectors[num14];
		float3 xyz4 = ((float4)(ref val)).xyz;
		Vector3 val2 = default(Vector3);
		val2.x = (xyz2.x - xyz.x) * num7 + xyz.x;
		val2.y = (xyz2.y - xyz.y) * num7 + xyz.y;
		val2.z = (xyz2.z - xyz.z) * num7 + xyz.z;
		Vector3 val3 = default(Vector3);
		val3.x = (xyz4.x - xyz3.x) * num7 + xyz3.x;
		val3.y = (xyz4.y - xyz3.y) * num7 + xyz3.y;
		val3.z = (xyz4.z - xyz3.z) * num7 + xyz3.z;
		float num15 = (val3.x - val2.x) * num8 + val2.x;
		float num16 = (val3.y - val2.y) * num8 + val2.y;
		return new ValueTuple<Vector3, float>(item2: ((val3.z - val2.z) * num8 + val2.z) * shoreDistanceScale, item1: new Vector3(num15, 0f, num16));
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(float normX, float normY)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return this.GetCoarseVectorToShore(new Vector2(normX, normY));
	}

	public Vector4 GetRawShoreVector(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - TerrainMeta.Position.x) * TerrainMeta.OneOverSize.x;
		uv.y = (pos.z - TerrainMeta.Position.z) * TerrainMeta.OneOverSize.z;
		return GetRawShoreVector(uv);
	}

	public Vector4 GetRawShoreVector(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		int num = shoreMapSize;
		int num2 = num - 1;
		float num3 = uv.x * (float)num2;
		float num4 = uv.y * (float)num2;
		int num5 = (int)num3;
		int num6 = (int)num4;
		num5 = ((num5 >= 0) ? num5 : 0);
		num6 = ((num6 >= 0) ? num6 : 0);
		num5 = ((num5 <= num2) ? num5 : num2);
		num6 = ((num6 <= num2) ? num6 : num2);
		return float4.op_Implicit(shoreVectors[num6 * num + num5]);
	}

	private void InitializeWaterHeight()
	{
	}

	private void ReleaseWaterHeight()
	{
	}

	private void UpdateWaterHeight()
	{
	}
}


using Unity.Collections;
using UnityEngine;

public struct ShoreVectorQueryStructure
{
	public ReadOnly<float> ShoreDistances;

	public float ShoreDistanceScale;

	public int ShoreMapSize;

	public float GetCoarseDistanceToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		int shoreMapSize = ShoreMapSize;
		int num = shoreMapSize - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
		int num10 = num5 * shoreMapSize + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = ShoreDistances[num10];
		float num15 = ShoreDistances[num11];
		float num16 = ShoreDistances[num12];
		float num17 = ShoreDistances[num13];
		float num18 = (num15 - num14) * num6 + num14;
		return (((num17 - num16) * num6 + num16 - num18) * num7 + num18) * ShoreDistanceScale;
	}
}


internal enum TextureCacheState
{
	Initializing,
	Uncached,
	CachedRaw,
	CachedCompressed
}


using UnityEngine;

public class TerrainTreeBatch : MonoBehaviour
{
}


using UnityEngine;

public class TreeMesh : MonoBehaviour
{
}


using System;
using UnityEngine;

public class TerrainFilter : PrefabAttribute
{
	public SpawnFilter Filter;

	public bool CheckPlacementMap = true;

	public bool CheckTerrainBounds;

	public float CheckTopologyRadius;

	public bool Check(Vector3 pos)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (CheckTerrainBounds && TerrainMeta.OutOfBounds(pos))
		{
			return false;
		}
		return Filter.GetFactor(pos, CheckPlacementMap, CheckTopologyRadius) > 0f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainFilter);
	}
}


using UnityEngine;

public static class TerrainFilterEx
{
	public static bool ApplyTerrainFilters(this Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (filters.Length == 0)
		{
			return true;
		}
		foreach (TerrainFilter terrainFilter in filters)
		{
			Vector3 val = Vector3.Scale(terrainFilter.worldPosition, scale);
			val = rot * val;
			Vector3 val2 = pos + val;
			if (globalFilter != null && globalFilter.GetFactor(val2) == 0f)
			{
				return false;
			}
			if (!terrainFilter.Check(val2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class TerrainFilterGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementDistance = 8f;

	public SpawnFilter Filter;

	public bool CheckPlacementMap = true;
}


using UnityEngine;

public class CollateTrainTracks : ProceduralComponent
{
	private const float MAX_NODE_DIST = 0.1f;

	private const float MAX_NODE_DIST_SQR = 0.010000001f;

	private const float MAX_NODE_ANGLE = 10f;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline[] array = Object.FindObjectsOfType<TrainTrackSpline>();
		TrainTrackSpline[] array2;
		for (int num = array.Length - 1; num >= 0; num--)
		{
			TrainTrackSpline ourSpline = array[num];
			if (ourSpline.dataIndex < 0 && ourSpline.points.Length > 3)
			{
				int nodeIndex;
				for (nodeIndex = ourSpline.points.Length - 2; nodeIndex >= 1; nodeIndex--)
				{
					Vector3 ourPos2 = ourSpline.points[nodeIndex];
					Vector3 ourTangent2 = ourSpline.tangents[nodeIndex];
					array2 = array;
					foreach (TrainTrackSpline trainTrackSpline in array2)
					{
						if (!((Object)(object)ourSpline == (Object)(object)trainTrackSpline))
						{
							Vector3 startPointWorld = trainTrackSpline.GetStartPointWorld();
							Vector3 endPointWorld = trainTrackSpline.GetEndPointWorld();
							Vector3 startTangentWorld = trainTrackSpline.GetStartTangentWorld();
							Vector3 endTangentWorld = trainTrackSpline.GetEndTangentWorld();
							if (!CompareNodes(startPointWorld, startTangentWorld) && !CompareNodes(endPointWorld, endTangentWorld) && !CompareNodes(startPointWorld, -startTangentWorld))
							{
								CompareNodes(endPointWorld, -endTangentWorld);
							}
						}
					}
					bool CompareNodes(Vector3 theirPos, Vector3 theirTangent)
					{
						//IL_0002: Unknown result type (might be due to invalid IL or missing references)
						//IL_0007: Unknown result type (might be due to invalid IL or missing references)
						//IL_000a: Unknown result type (might be due to invalid IL or missing references)
						//IL_000f: Unknown result type (might be due to invalid IL or missing references)
						//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
						//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
						//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
						//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
						//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
						//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
						//IL_0113: Unknown result type (might be due to invalid IL or missing references)
						//IL_0118: Unknown result type (might be due to invalid IL or missing references)
						if (NodesConnect(ourPos2, theirPos, ourTangent2, theirTangent))
						{
							TrainTrackSpline trainTrackSpline2 = ((Component)ourSpline).gameObject.AddComponent<TrainTrackSpline>();
							Vector3[] array4 = (Vector3[])(object)new Vector3[ourSpline.points.Length - nodeIndex];
							Vector3[] array5 = (Vector3[])(object)new Vector3[ourSpline.points.Length - nodeIndex];
							Vector3[] array6 = (Vector3[])(object)new Vector3[nodeIndex + 1];
							Vector3[] array7 = (Vector3[])(object)new Vector3[nodeIndex + 1];
							for (int num2 = ourSpline.points.Length - 1; num2 >= 0; num2--)
							{
								if (num2 >= nodeIndex)
								{
									array4[num2 - nodeIndex] = ourSpline.points[num2];
									array5[num2 - nodeIndex] = ourSpline.tangents[num2];
								}
								if (num2 <= nodeIndex)
								{
									array6[num2] = ourSpline.points[num2];
									array7[num2] = ourSpline.tangents[num2];
								}
							}
							ourSpline.SetAll(array6, array7, ourSpline);
							trainTrackSpline2.SetAll(array4, array5, ourSpline);
							nodeIndex--;
							return true;
						}
						return false;
					}
				}
			}
		}
		array = Object.FindObjectsOfType<TrainTrackSpline>();
		array2 = array;
		foreach (TrainTrackSpline ourSpline2 in array2)
		{
			Vector3 ourStartPos = ourSpline2.GetStartPointWorld();
			Vector3 ourEndPos = ourSpline2.GetEndPointWorld();
			Vector3 ourStartTangent = ourSpline2.GetStartTangentWorld();
			Vector3 ourEndTangent = ourSpline2.GetEndTangentWorld();
			if (NodesConnect(ourStartPos, ourEndPos, ourStartTangent, ourEndTangent))
			{
				ourSpline2.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Next, TrainTrackSpline.TrackOrientation.Same);
				ourSpline2.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Prev, TrainTrackSpline.TrackOrientation.Same);
				continue;
			}
			TrainTrackSpline[] array3 = array;
			foreach (TrainTrackSpline otherSpline in array3)
			{
				Vector3 theirStartPos;
				Vector3 theirEndPos;
				Vector3 theirStartTangent;
				Vector3 theirEndTangent;
				if (!((Object)(object)ourSpline2 == (Object)(object)otherSpline))
				{
					theirStartPos = otherSpline.GetStartPointWorld();
					theirEndPos = otherSpline.GetEndPointWorld();
					theirStartTangent = otherSpline.GetStartTangentWorld();
					theirEndTangent = otherSpline.GetEndTangentWorld();
					if (!CompareNodes(ourStart: false, theirStart: true) && !CompareNodes(ourStart: false, theirStart: false) && !CompareNodes(ourStart: true, theirStart: true))
					{
						CompareNodes(ourStart: true, theirStart: false);
					}
				}
				bool CompareNodes(bool ourStart, bool theirStart)
				{
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0004: Unknown result type (might be due to invalid IL or missing references)
					//IL_001d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0015: Unknown result type (might be due to invalid IL or missing references)
					//IL_0022: Unknown result type (might be due to invalid IL or missing references)
					//IL_0031: Unknown result type (might be due to invalid IL or missing references)
					//IL_0028: Unknown result type (might be due to invalid IL or missing references)
					//IL_0036: Unknown result type (might be due to invalid IL or missing references)
					//IL_0045: Unknown result type (might be due to invalid IL or missing references)
					//IL_003c: Unknown result type (might be due to invalid IL or missing references)
					//IL_004a: Unknown result type (might be due to invalid IL or missing references)
					//IL_005b: Unknown result type (might be due to invalid IL or missing references)
					//IL_005c: Unknown result type (might be due to invalid IL or missing references)
					//IL_005d: Unknown result type (might be due to invalid IL or missing references)
					//IL_004f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0055: Unknown result type (might be due to invalid IL or missing references)
					//IL_005a: Unknown result type (might be due to invalid IL or missing references)
					Vector3 ourPos3 = (ourStart ? ourStartPos : ourEndPos);
					Vector3 ourTangent3 = (ourStart ? ourStartTangent : ourEndTangent);
					Vector3 theirPos2 = (theirStart ? theirStartPos : theirEndPos);
					Vector3 val = (theirStart ? theirStartTangent : theirEndTangent);
					if (ourStart == theirStart)
					{
						val *= -1f;
					}
					if (NodesConnect(ourPos3, theirPos2, ourTangent3, val))
					{
						if (ourStart)
						{
							ourSpline2.AddTrackConnection(otherSpline, TrainTrackSpline.TrackPosition.Prev, theirStart ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						else
						{
							ourSpline2.AddTrackConnection(otherSpline, TrainTrackSpline.TrackPosition.Next, (!theirStart) ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						if (theirStart)
						{
							otherSpline.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Prev, ourStart ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						else
						{
							otherSpline.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Next, (!ourStart) ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						return true;
					}
					return false;
				}
			}
		}
		static bool NodesConnect(Vector3 ourPos, Vector3 theirPos, Vector3 ourTangent, Vector3 theirTangent)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.SqrMagnitude(ourPos - theirPos) < 0.010000001f)
			{
				return Vector3.Angle(ourTangent, theirTangent) < 10f;
			}
			return false;
		}
	}
}


using UnityEngine;

public class MonumentNode : MonoBehaviour
{
	public string ResourceFolder = string.Empty;

	protected void Awake()
	{
		if (!((Object)(object)SingletonComponent<WorldSetup>.Instance == (Object)null))
		{
			if (SingletonComponent<WorldSetup>.Instance.MonumentNodes == null)
			{
				Debug.LogError((object)"WorldSetup.Instance.MonumentNodes is null.", (Object)(object)this);
			}
			else
			{
				SingletonComponent<WorldSetup>.Instance.MonumentNodes.Add(this);
			}
		}
	}

	public void Process(ref uint seed)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Monument", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		Prefab<MonumentInfo>[] array = Prefab.Load<MonumentInfo>("assets/bundled/prefabs/autospawn/" + ResourceFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
		if (array != null && array.Length != 0)
		{
			Prefab<MonumentInfo> random = array.GetRandom(ref seed);
			float height = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
			Vector3 pos = default(Vector3);
			((Vector3)(ref pos))..ctor(((Component)this).transform.position.x, height, ((Component)this).transform.position.z);
			Quaternion rot = random.Object.transform.localRotation;
			Vector3 scale = random.Object.transform.localScale;
			random.ApplyDecorComponents(ref pos, ref rot, ref scale);
			World.AddPrefab("Monument", random, pos, rot, scale);
		}
	}
}


using UnityEngine;

public abstract class ProceduralComponent : MonoBehaviour
{
	public enum Realm
	{
		Client = 1,
		Server
	}

	[InspectorFlags]
	public Realm Mode = (Realm)(-1);

	public string Description = "Procedural Component";

	public virtual bool RunOnCache => false;

	public bool ShouldRun()
	{
		if (World.Cached && !RunOnCache)
		{
			return false;
		}
		if ((Mode & Realm.Server) != 0)
		{
			return true;
		}
		return false;
	}

	public abstract void Process(uint seed);
}


public enum Realm
{
	Client = 1,
	Server
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateBiome : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_biome")]
	public unsafe static extern void Native_GenerateBiome(byte* nativeArrayPtr, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, float biomeJungle, short* heightmap, int heightres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		byte* unsafePtr = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.dst);
		int res = TerrainMeta.BiomeMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		Native_GenerateBiome(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic, World.Config.PercentageBiomeJungle, unsafePtr2, res2);
	}
}


using System;
using UnityEngine;

public class GenerateCliffSplat : ProceduralComponent
{
	private const int filter = 8389632;

	public static void Process(int x, int z)
	{
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		float normZ = splatMap.Coordinate(z);
		float normX = splatMap.Coordinate(x);
		if ((TerrainMeta.TopologyMap.GetTopology(normX, normZ) & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			if (slope > 30f)
			{
				splatMap.SetSplat(x, z, 8, Mathf.InverseLerp(30f, 50f, slope));
			}
		}
	}

	public override void Process(uint seed)
	{
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		int splatres = splatMap.res;
		Parallel.For(0, splatres, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < splatres; i++)
			{
				Process(i, z);
			}
		});
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class GenerateCliffTopology : ProceduralComponent
{
	public bool KeepExisting = true;

	private const float slopeCutoff = 30f;

	private const float splatCutoff = 0.4f;

	private const int filter = 8389632;

	public static void Process(int x, int z)
	{
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		float normZ = topologyMap.Coordinate(z);
		float normX = topologyMap.Coordinate(x);
		if ((topologyMap.GetTopology(x, z) & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			float splat = TerrainMeta.SplatMap.GetSplat(normX, normZ, 8);
			if (slope > 30f || splat > 0.4f)
			{
				topologyMap.AddTopology(x, z, 2);
			}
			else
			{
				topologyMap.RemoveTopology(x, z, 2);
			}
		}
	}

	private static void Process(int x, int z, bool keepExisting)
	{
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		float normZ = topologyMap.Coordinate(z);
		float normX = topologyMap.Coordinate(x);
		int topology = topologyMap.GetTopology(x, z);
		if (!World.Procedural || (topology & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			float splat = TerrainMeta.SplatMap.GetSplat(normX, normZ, 8);
			if (slope > 30f || splat > 0.4f)
			{
				topologyMap.AddTopology(x, z, 2);
			}
			else if (!keepExisting)
			{
				topologyMap.RemoveTopology(x, z, 2);
			}
		}
	}

	public override void Process(uint seed)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<int> map = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				Process(i, z, KeepExisting);
			}
		});
		ImageProcessing.Dilate2D(map, res, res, 4194306, 1, delegate(int x, int y)
		{
			if ((map[x * res + y] & 2) == 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x400000;
			}
		});
	}
}


using Unity.Collections;

public class GenerateClutterTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<int> map = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		ImageProcessing.Dilate2D(map, res, res, 16777728, 3, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x200) == 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x1000000;
			}
		});
	}
}


using System;
using UnityEngine;

public class GenerateDecorTopology : ProceduralComponent
{
	public bool KeepExisting = true;

	public override void Process(uint seed)
	{
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		int topores = topomap.res;
		Parallel.For(0, topores, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < topores; i++)
			{
				if (topomap.GetTopology(i, z, 4194306))
				{
					topomap.AddTopology(i, z, 512);
				}
				else if (!KeepExisting)
				{
					topomap.RemoveTopology(i, z, 512);
				}
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateDungeonBase : ProceduralComponent
{
	private class DungeonSegment
	{
		public Vector3 position;

		public Quaternion rotation;

		public Prefab prefab;

		public DungeonBaseLink link;

		public int score;

		public int cost;

		public int floor;
	}

	public string EntranceFolder = string.Empty;

	public string LinkFolder = string.Empty;

	public string EndFolder = string.Empty;

	public string TransitionFolder = string.Empty;

	public InfrastructureType ConnectionType = InfrastructureType.UnderwaterLab;

	private static Vector3 VolumeExtrudePositive = Vector3.one * 0.01f;

	private static Vector3 VolumeExtrudeNegative = Vector3.one * -0.01f;

	private const int MaxCount = int.MaxValue;

	private const int MaxDepth = 3;

	private const int MaxFloor = 2;

	private List<DungeonSegment> segmentsTotal = new List<DungeonSegment>();

	private Quaternion[] horizontalRotations = (Quaternion[])(object)new Quaternion[1] { Quaternion.Euler(0f, 0f, 0f) };

	private Quaternion[] pillarRotations = (Quaternion[])(object)new Quaternion[4]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 270f, 0f)
	};

	private Quaternion[] verticalRotations = (Quaternion[])(object)new Quaternion[8]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 45f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 135f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 225f, 0f),
		Quaternion.Euler(0f, 270f, 0f),
		Quaternion.Euler(0f, 315f, 0f)
	};

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b8: Unknown result type (might be due to invalid IL or missing references)
		if (World.Cached)
		{
			TerrainMeta.Path.DungeonBaseRoot = HierarchyUtil.GetRoot("DungeonBase");
		}
		else if (World.Networked)
		{
			World.Spawn("DungeonBase");
			TerrainMeta.Path.DungeonBaseRoot = HierarchyUtil.GetRoot("DungeonBase");
		}
		else
		{
			if (ConnectionType == InfrastructureType.UnderwaterLab && !World.Config.UnderwaterLabs)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + EntranceFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array == null)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array2 = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + LinkFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array2 == null)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array3 = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + EndFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array3 == null)
			{
				return;
			}
			Prefab<DungeonBaseTransition>[] array4 = Prefab.Load<DungeonBaseTransition>("assets/bundled/prefabs/autospawn/" + TransitionFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array4 == null)
			{
				return;
			}
			foreach (DungeonBaseInfo item in Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.DungeonBaseEntrances : null)
			{
				TerrainPathConnect[] componentsInChildren = ((Component)item).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect obj in componentsInChildren)
				{
					if (obj.Type != ConnectionType)
					{
						continue;
					}
					uint seed2 = seed++;
					List<DungeonSegment> list = new List<DungeonSegment>();
					DungeonSegment segmentStart = new DungeonSegment();
					int num = 0;
					segmentStart.position = ((Component)item).transform.position;
					segmentStart.rotation = ((Component)item).transform.rotation;
					segmentStart.link = ((Component)item).GetComponentInChildren<DungeonBaseLink>();
					segmentStart.cost = 0;
					segmentStart.floor = 0;
					for (int j = 0; j < 25; j++)
					{
						List<DungeonSegment> list2 = new List<DungeonSegment>();
						list2.Add(segmentStart);
						PlaceSegments(ref seed2, int.MaxValue, 3, 2, attachToFemale: true, attachToMale: false, list2, array2);
						int num2 = list2.Count((DungeonSegment x) => x.link.MaxCountLocal != -1);
						if (num2 > num || (num2 == num && list2.Count > list.Count))
						{
							list = list2;
							num = num2;
						}
					}
					if (list.Count > 5)
					{
						list = list.OrderByDescending((DungeonSegment x) => Vector3Ex.SqrMagnitude2D(x.position - segmentStart.position)).ToList();
						PlaceSegments(ref seed2, 1, 4, 2, attachToFemale: true, attachToMale: false, list, array);
					}
					if (list.Count > 25)
					{
						DungeonSegment segmentEnd = list[list.Count - 1];
						list = list.OrderByDescending((DungeonSegment x) => Mathf.Min(Vector3Ex.SqrMagnitude2D(x.position - segmentStart.position), Vector3Ex.SqrMagnitude2D(x.position - segmentEnd.position))).ToList();
						PlaceSegments(ref seed2, 1, 5, 2, attachToFemale: true, attachToMale: false, list, array);
					}
					bool flag = true;
					while (flag)
					{
						flag = false;
						for (int k = 0; k < list.Count; k++)
						{
							DungeonSegment dungeonSegment = list[k];
							if (dungeonSegment.link.Cost <= 0 && !IsFullyOccupied(list, dungeonSegment))
							{
								list.RemoveAt(k--);
								flag = true;
							}
						}
					}
					PlaceSegments(ref seed2, int.MaxValue, int.MaxValue, 3, attachToFemale: true, attachToMale: true, list, array3);
					PlaceTransitions(ref seed2, list, array4);
					segmentsTotal.AddRange(list);
				}
			}
			foreach (DungeonSegment item2 in segmentsTotal)
			{
				if (item2.prefab != null)
				{
					World.AddPrefab("DungeonBase", item2.prefab, item2.position, item2.rotation, Vector3.one);
				}
			}
			if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
			{
				TerrainMeta.Path.DungeonBaseRoot = HierarchyUtil.GetRoot("DungeonBase");
			}
		}
	}

	private Quaternion[] GetRotationList(DungeonBaseSocketType type)
	{
		return type switch
		{
			DungeonBaseSocketType.Horizontal => horizontalRotations, 
			DungeonBaseSocketType.Vertical => verticalRotations, 
			DungeonBaseSocketType.Pillar => pillarRotations, 
			_ => null, 
		};
	}

	private int GetSocketFloor(DungeonBaseSocketType type)
	{
		if (type != DungeonBaseSocketType.Vertical)
		{
			return 0;
		}
		return 1;
	}

	private bool IsFullyOccupied(List<DungeonSegment> segments, DungeonSegment segment)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return SocketMatches(segments, segment.link, segment.position, segment.rotation) == segment.link.Sockets.Count;
	}

	private bool NeighbourMatches(List<DungeonSegment> segments, DungeonBaseTransition transition, Vector3 transitionPos, Quaternion transitionRot)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		bool flag2 = false;
		foreach (DungeonSegment segment in segments)
		{
			Vector3 val;
			if ((Object)(object)segment.link == (Object)null)
			{
				val = segment.position - transitionPos;
				if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
				{
					flag = false;
					flag2 = false;
				}
				continue;
			}
			foreach (DungeonBaseSocket socket in segment.link.Sockets)
			{
				val = segment.position + segment.rotation * ((Component)socket).transform.localPosition - transitionPos;
				if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
				{
					if (!flag && segment.link.Type == transition.Neighbour1)
					{
						flag = true;
					}
					else if (!flag2 && segment.link.Type == transition.Neighbour2)
					{
						flag2 = true;
					}
				}
			}
		}
		return flag && flag2;
	}

	private int SocketMatches(List<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (DungeonSegment segment in segments)
		{
			foreach (DungeonBaseSocket socket in segment.link.Sockets)
			{
				Vector3 val = segment.position + segment.rotation * ((Component)socket).transform.localPosition;
				foreach (DungeonBaseSocket socket2 in link.Sockets)
				{
					if (!((Object)(object)socket == (Object)(object)socket2))
					{
						Vector3 val2 = linkPos + linkRot * ((Component)socket2).transform.localPosition;
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							num++;
						}
					}
				}
			}
		}
		return num;
	}

	private bool IsOccupied(List<DungeonSegment> segments, DungeonBaseSocket socket, Vector3 socketPos, Quaternion socketRot)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		foreach (DungeonSegment segment in segments)
		{
			foreach (DungeonBaseSocket socket2 in segment.link.Sockets)
			{
				if (!((Object)(object)socket2 == (Object)(object)socket))
				{
					Vector3 val = segment.position + segment.rotation * ((Component)socket2).transform.localPosition - socketPos;
					if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private int CountLocal(List<DungeonSegment> segments, DungeonBaseLink link)
	{
		int num = 0;
		if ((Object)(object)link == (Object)null)
		{
			return num;
		}
		foreach (DungeonSegment segment in segments)
		{
			if (!((Object)(object)segment.link == (Object)null))
			{
				if ((Object)(object)segment.link == (Object)(object)link)
				{
					num++;
				}
				else if (segment.link.MaxCountIdentifier >= 0 && segment.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		return num;
	}

	private int CountGlobal(List<DungeonSegment> segments, DungeonBaseLink link)
	{
		int num = 0;
		if ((Object)(object)link == (Object)null)
		{
			return num;
		}
		foreach (DungeonSegment segment in segments)
		{
			if (!((Object)(object)segment.link == (Object)null))
			{
				if ((Object)(object)segment.link == (Object)(object)link)
				{
					num++;
				}
				else if (segment.link.MaxCountIdentifier >= 0 && segment.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		foreach (DungeonSegment item in segmentsTotal)
		{
			if (!((Object)(object)item.link == (Object)null))
			{
				if ((Object)(object)item.link == (Object)(object)link)
				{
					num++;
				}
				else if (item.link.MaxCountIdentifier >= 0 && item.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		return num;
	}

	private bool IsBlocked(List<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3;
		foreach (DungeonVolume volume in link.Volumes)
		{
			OBB bounds = volume.GetBounds(linkPos, linkRot, VolumeExtrudeNegative);
			OBB bounds2 = volume.GetBounds(linkPos, linkRot, VolumeExtrudePositive);
			foreach (DungeonSegment segment in segments)
			{
				foreach (DungeonVolume volume2 in segment.link.Volumes)
				{
					OBB bounds3 = volume2.GetBounds(segment.position, segment.rotation, VolumeExtrudeNegative);
					if (((OBB)(ref bounds)).Intersects(bounds3))
					{
						return true;
					}
				}
				foreach (DungeonBaseSocket socket in segment.link.Sockets)
				{
					Vector3 val = segment.position + segment.rotation * ((Component)socket).transform.localPosition;
					if (!((OBB)(ref bounds2)).Contains(val))
					{
						continue;
					}
					bool flag = false;
					foreach (DungeonBaseSocket socket2 in link.Sockets)
					{
						Vector3 val2 = linkPos + linkRot * ((Component)socket2).transform.localPosition;
						val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return true;
					}
				}
			}
		}
		foreach (DungeonSegment segment2 in segments)
		{
			foreach (DungeonVolume volume3 in segment2.link.Volumes)
			{
				OBB bounds4 = volume3.GetBounds(segment2.position, segment2.rotation, VolumeExtrudePositive);
				foreach (DungeonBaseSocket socket3 in link.Sockets)
				{
					Vector3 val4 = linkPos + linkRot * ((Component)socket3).transform.localPosition;
					if (!((OBB)(ref bounds4)).Contains(val4))
					{
						continue;
					}
					bool flag2 = false;
					foreach (DungeonBaseSocket socket4 in segment2.link.Sockets)
					{
						val3 = segment2.position + segment2.rotation * ((Component)socket4).transform.localPosition - val4;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							flag2 = true;
							break;
						}
					}
					if (!flag2)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private void PlaceSegments(ref uint seed, int count, int budget, int floors, bool attachToFemale, bool attachToMale, List<DungeonSegment> segments, Prefab<DungeonBaseLink>[] prefabs)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < segments.Count; i++)
		{
			DungeonSegment dungeonSegment = segments[i];
			if (dungeonSegment.cost >= budget)
			{
				continue;
			}
			int num2 = SeedRandom.Range(ref seed, 0, dungeonSegment.link.Sockets.Count);
			for (int j = 0; j < dungeonSegment.link.Sockets.Count; j++)
			{
				DungeonBaseSocket dungeonBaseSocket = dungeonSegment.link.Sockets[(j + num2) % dungeonSegment.link.Sockets.Count];
				if (!(dungeonBaseSocket.Female && attachToFemale) && !(dungeonBaseSocket.Male && attachToMale))
				{
					continue;
				}
				Vector3 val = dungeonSegment.position + dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localPosition;
				Quaternion val2 = dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localRotation;
				if (IsOccupied(segments, dungeonBaseSocket, val, val2))
				{
					continue;
				}
				prefabs.Shuffle(ref seed);
				DungeonSegment dungeonSegment2 = null;
				Quaternion[] rotationList = GetRotationList(dungeonBaseSocket.Type);
				foreach (Prefab<DungeonBaseLink> prefab in prefabs)
				{
					DungeonBaseLink component = prefab.Component;
					if (component.MaxCountLocal == 0 || component.MaxCountGlobal == 0 || (component.MaxFloor >= 0 && dungeonSegment.floor > component.MaxFloor))
					{
						continue;
					}
					int num3 = dungeonSegment.cost + component.Cost;
					if (num3 > budget)
					{
						continue;
					}
					int num4 = dungeonSegment.floor + GetSocketFloor(dungeonBaseSocket.Type);
					if (num4 > floors)
					{
						continue;
					}
					DungeonBaseSocket linkSocket = null;
					Vector3 linkPos = Vector3.zero;
					Quaternion linkRot = Quaternion.identity;
					int linkScore = 0;
					if (Place(ref seed, segments, dungeonBaseSocket, val, val2, prefab, rotationList, out linkSocket, out linkPos, out linkRot, out linkScore) && (component.MaxCountLocal <= 0 || CountLocal(segments, component) < component.MaxCountLocal) && (component.MaxCountGlobal <= 0 || CountGlobal(segments, component) < component.MaxCountGlobal))
					{
						DungeonSegment dungeonSegment3 = new DungeonSegment();
						dungeonSegment3.position = linkPos;
						dungeonSegment3.rotation = linkRot;
						dungeonSegment3.prefab = prefab;
						dungeonSegment3.link = component;
						dungeonSegment3.score = linkScore;
						dungeonSegment3.cost = num3;
						dungeonSegment3.floor = num4;
						if (dungeonSegment2 == null || dungeonSegment2.score < dungeonSegment3.score)
						{
							dungeonSegment2 = dungeonSegment3;
						}
					}
				}
				if (dungeonSegment2 != null)
				{
					segments.Add(dungeonSegment2);
					num++;
					if (num >= count)
					{
						return;
					}
				}
			}
		}
	}

	private void PlaceTransitions(ref uint seed, List<DungeonSegment> segments, Prefab<DungeonBaseTransition>[] prefabs)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		int count = segments.Count;
		for (int i = 0; i < count; i++)
		{
			DungeonSegment dungeonSegment = segments[i];
			int num = SeedRandom.Range(ref seed, 0, dungeonSegment.link.Sockets.Count);
			for (int j = 0; j < dungeonSegment.link.Sockets.Count; j++)
			{
				DungeonBaseSocket dungeonBaseSocket = dungeonSegment.link.Sockets[(j + num) % dungeonSegment.link.Sockets.Count];
				Vector3 val = dungeonSegment.position + dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localPosition;
				Quaternion val2 = dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localRotation;
				prefabs.Shuffle(ref seed);
				foreach (Prefab<DungeonBaseTransition> prefab in prefabs)
				{
					if (dungeonBaseSocket.Type == prefab.Component.Type && NeighbourMatches(segments, prefab.Component, val, val2))
					{
						DungeonSegment dungeonSegment2 = new DungeonSegment();
						dungeonSegment2.position = val;
						dungeonSegment2.rotation = val2;
						dungeonSegment2.prefab = prefab;
						dungeonSegment2.link = null;
						dungeonSegment2.score = 0;
						dungeonSegment2.cost = 0;
						dungeonSegment2.floor = 0;
						segments.Add(dungeonSegment2);
						break;
					}
				}
			}
		}
	}

	private bool Place(ref uint seed, List<DungeonSegment> segments, DungeonBaseSocket targetSocket, Vector3 targetPos, Quaternion targetRot, Prefab<DungeonBaseLink> prefab, Quaternion[] rotations, out DungeonBaseSocket linkSocket, out Vector3 linkPos, out Quaternion linkRot, out int linkScore)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		linkSocket = null;
		linkPos = Vector3.one;
		linkRot = Quaternion.identity;
		linkScore = 0;
		DungeonBaseLink component = prefab.Component;
		int num = SeedRandom.Range(ref seed, 0, component.Sockets.Count);
		for (int i = 0; i < component.Sockets.Count; i++)
		{
			DungeonBaseSocket dungeonBaseSocket = component.Sockets[(i + num) % component.Sockets.Count];
			if (dungeonBaseSocket.Type != targetSocket.Type || ((!dungeonBaseSocket.Male || !targetSocket.Female) && (!dungeonBaseSocket.Female || !targetSocket.Male)))
			{
				continue;
			}
			rotations.Shuffle(ref seed);
			foreach (Quaternion val in rotations)
			{
				Quaternion val2 = Quaternion.FromToRotation(-((Component)dungeonBaseSocket).transform.forward, targetRot * Vector3.forward);
				if (dungeonBaseSocket.Type != DungeonBaseSocketType.Vertical)
				{
					val2 = QuaternionEx.LookRotationForcedUp(val2 * Vector3.forward, Vector3.up);
				}
				Quaternion val3 = val * val2;
				Vector3 val4 = targetPos - val3 * ((Component)dungeonBaseSocket).transform.localPosition;
				if (!IsBlocked(segments, component, val4, val3))
				{
					int num2 = SocketMatches(segments, component, val4, val3);
					if (num2 > linkScore && prefab.CheckEnvironmentVolumesOutsideTerrain(val4, val3, Vector3.one, EnvironmentType.UnderwaterLab, (EnvironmentType)0, 1f))
					{
						linkSocket = dungeonBaseSocket;
						linkPos = val4;
						linkRot = val3;
						linkScore = num2;
					}
				}
			}
		}
		return linkScore > 0;
	}

	public static void SetupAI()
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Expected O, but got Unknown
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.DungeonBaseEntrances == null)
		{
			return;
		}
		foreach (DungeonBaseInfo dungeonBaseEntrance in TerrainMeta.Path.DungeonBaseEntrances)
		{
			if ((Object)(object)dungeonBaseEntrance == (Object)null)
			{
				continue;
			}
			List<AIInformationZone> list = new List<AIInformationZone>();
			int num = 0;
			AIInformationZone componentInChildren = ((Component)dungeonBaseEntrance).GetComponentInChildren<AIInformationZone>();
			if ((Object)(object)componentInChildren != (Object)null)
			{
				list.Add(componentInChildren);
				num++;
			}
			foreach (GameObject link in ((Component)dungeonBaseEntrance).GetComponent<DungeonBaseInfo>().Links)
			{
				AIInformationZone componentInChildren2 = link.GetComponentInChildren<AIInformationZone>();
				if (!((Object)(object)componentInChildren2 == (Object)null))
				{
					list.Add(componentInChildren2);
					num++;
				}
			}
			GameObject val = new GameObject("AIZ");
			val.transform.position = ((Component)dungeonBaseEntrance).gameObject.transform.position;
			AIInformationZone aIInformationZone = AIInformationZone.Merge(list, val);
			aIInformationZone.ShouldSleepAI = true;
			val.transform.SetParent(((Component)dungeonBaseEntrance).gameObject.transform);
			GameObject val2 = new GameObject("WakeTrigger");
			val2.transform.position = val.transform.position + ((Bounds)(ref aIInformationZone.bounds)).center;
			val2.transform.localScale = ((Bounds)(ref aIInformationZone.bounds)).extents + new Vector3(100f, 100f, 100f);
			((Collider)val2.AddComponent<BoxCollider>()).isTrigger = true;
			val2.layer = LayerMask.NameToLayer("Trigger");
			val2.transform.SetParent(((Component)dungeonBaseEntrance).gameObject.transform);
			TriggerWakeAIZ triggerWakeAIZ = val2.AddComponent<TriggerWakeAIZ>();
			triggerWakeAIZ.InterestLayers = LayerMask.op_Implicit(LayerMask.GetMask(new string[1] { "Player (Server)" }));
			triggerWakeAIZ.Init(aIInformationZone);
		}
	}
}


using UnityEngine;

private class DungeonSegment
{
	public Vector3 position;

	public Quaternion rotation;

	public Prefab prefab;

	public DungeonBaseLink link;

	public int score;

	public int cost;

	public int floor;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateDungeonGrid : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;
	}

	private class PathLink
	{
		public PathLinkSide downwards;

		public PathLinkSide upwards;
	}

	private class PathLinkSide
	{
		public PathLinkSegment origin;

		public List<PathLinkSegment> segments;

		public PathLinkSegment prevSegment
		{
			get
			{
				if (segments.Count <= 0)
				{
					return origin;
				}
				return segments[segments.Count - 1];
			}
		}
	}

	private class PathLinkSegment
	{
		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public Prefab<DungeonGridLink> prefab;

		public DungeonGridLink link;

		public Transform downSocket => link.DownSocket;

		public Transform upSocket => link.UpSocket;

		public DungeonGridLinkType downType => link.DownType;

		public DungeonGridLinkType upType => link.UpType;
	}

	private struct PrefabReplacement
	{
		public Vector2i gridPosition;

		public Vector3 worldPosition;

		public int distance;

		public Prefab<DungeonGridCell> prefab;
	}

	public string TunnelFolder = string.Empty;

	public string StationFolder = string.Empty;

	public string UpwardsFolder = string.Empty;

	public string TransitionFolder = string.Empty;

	public string LinkFolder = string.Empty;

	public InfrastructureType ConnectionType = InfrastructureType.Tunnel;

	public int CellSize = 216;

	public float LinkHeight = 1.5f;

	public float LinkRadius = 3f;

	public float LinkTransition = 9f;

	private const int MaxDepth = 100000;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_08f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0335: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0345: Unknown result type (might be due to invalid IL or missing references)
		//IL_034c: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_1142: Unknown result type (might be due to invalid IL or missing references)
		//IL_1144: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_1103: Unknown result type (might be due to invalid IL or missing references)
		//IL_1105: Unknown result type (might be due to invalid IL or missing references)
		//IL_1107: Unknown result type (might be due to invalid IL or missing references)
		//IL_110c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1111: Unknown result type (might be due to invalid IL or missing references)
		//IL_116d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1172: Unknown result type (might be due to invalid IL or missing references)
		//IL_1174: Unknown result type (might be due to invalid IL or missing references)
		//IL_1179: Unknown result type (might be due to invalid IL or missing references)
		//IL_11ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_11cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_11e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_11f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_11f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_11fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1201: Unknown result type (might be due to invalid IL or missing references)
		//IL_1206: Unknown result type (might be due to invalid IL or missing references)
		//IL_1214: Unknown result type (might be due to invalid IL or missing references)
		//IL_1225: Unknown result type (might be due to invalid IL or missing references)
		//IL_123b: Unknown result type (might be due to invalid IL or missing references)
		//IL_124c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1251: Unknown result type (might be due to invalid IL or missing references)
		//IL_1256: Unknown result type (might be due to invalid IL or missing references)
		//IL_125b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1260: Unknown result type (might be due to invalid IL or missing references)
		//IL_1262: Unknown result type (might be due to invalid IL or missing references)
		//IL_1267: Unknown result type (might be due to invalid IL or missing references)
		//IL_1280: Unknown result type (might be due to invalid IL or missing references)
		//IL_1285: Unknown result type (might be due to invalid IL or missing references)
		//IL_129b: Unknown result type (might be due to invalid IL or missing references)
		//IL_12a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_12b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f4a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f51: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f58: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_12eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_12fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1300: Unknown result type (might be due to invalid IL or missing references)
		//IL_1312: Unknown result type (might be due to invalid IL or missing references)
		//IL_1319: Unknown result type (might be due to invalid IL or missing references)
		//IL_1320: Unknown result type (might be due to invalid IL or missing references)
		//IL_132c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1331: Unknown result type (might be due to invalid IL or missing references)
		//IL_1336: Unknown result type (might be due to invalid IL or missing references)
		//IL_133b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1340: Unknown result type (might be due to invalid IL or missing references)
		//IL_1344: Unknown result type (might be due to invalid IL or missing references)
		//IL_1350: Unknown result type (might be due to invalid IL or missing references)
		//IL_1355: Unknown result type (might be due to invalid IL or missing references)
		//IL_135a: Unknown result type (might be due to invalid IL or missing references)
		//IL_184c: Unknown result type (might be due to invalid IL or missing references)
		//IL_184e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fa7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fae: Unknown result type (might be due to invalid IL or missing references)
		//IL_1fb5: Unknown result type (might be due to invalid IL or missing references)
		//IL_22cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_22cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_22d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_22db: Unknown result type (might be due to invalid IL or missing references)
		//IL_22dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_22df: Unknown result type (might be due to invalid IL or missing references)
		//IL_22e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_22e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_059b: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1863: Unknown result type (might be due to invalid IL or missing references)
		//IL_1865: Unknown result type (might be due to invalid IL or missing references)
		//IL_186c: Unknown result type (might be due to invalid IL or missing references)
		//IL_186e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1875: Unknown result type (might be due to invalid IL or missing references)
		//IL_187a: Unknown result type (might be due to invalid IL or missing references)
		//IL_18a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_2052: Unknown result type (might be due to invalid IL or missing references)
		//IL_2054: Unknown result type (might be due to invalid IL or missing references)
		//IL_2059: Unknown result type (might be due to invalid IL or missing references)
		//IL_205b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2060: Unknown result type (might be due to invalid IL or missing references)
		//IL_060a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0613: Unknown result type (might be due to invalid IL or missing references)
		//IL_13dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_18bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_063e: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_18de: Unknown result type (might be due to invalid IL or missing references)
		//IL_18e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_18f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_18f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_18f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_190a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1911: Unknown result type (might be due to invalid IL or missing references)
		//IL_1918: Unknown result type (might be due to invalid IL or missing references)
		//IL_1924: Unknown result type (might be due to invalid IL or missing references)
		//IL_1929: Unknown result type (might be due to invalid IL or missing references)
		//IL_192e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1933: Unknown result type (might be due to invalid IL or missing references)
		//IL_1938: Unknown result type (might be due to invalid IL or missing references)
		//IL_193c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1948: Unknown result type (might be due to invalid IL or missing references)
		//IL_194d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1952: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04db: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0660: Unknown result type (might be due to invalid IL or missing references)
		//IL_0667: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0517: Unknown result type (might be due to invalid IL or missing references)
		//IL_051e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0525: Unknown result type (might be due to invalid IL or missing references)
		//IL_052a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_053b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0540: Unknown result type (might be due to invalid IL or missing references)
		//IL_0549: Unknown result type (might be due to invalid IL or missing references)
		//IL_054e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0550: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06df: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0706: Unknown result type (might be due to invalid IL or missing references)
		//IL_070d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0712: Unknown result type (might be due to invalid IL or missing references)
		//IL_0717: Unknown result type (might be due to invalid IL or missing references)
		//IL_0719: Unknown result type (might be due to invalid IL or missing references)
		//IL_071e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0749: Unknown result type (might be due to invalid IL or missing references)
		//IL_074b: Unknown result type (might be due to invalid IL or missing references)
		//IL_075c: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0763: Unknown result type (might be due to invalid IL or missing references)
		//IL_0774: Unknown result type (might be due to invalid IL or missing references)
		//IL_0779: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_068b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0692: Unknown result type (might be due to invalid IL or missing references)
		//IL_1418: Unknown result type (might be due to invalid IL or missing references)
		//IL_1421: Unknown result type (might be due to invalid IL or missing references)
		//IL_1426: Unknown result type (might be due to invalid IL or missing references)
		//IL_142b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1430: Unknown result type (might be due to invalid IL or missing references)
		//IL_1432: Unknown result type (might be due to invalid IL or missing references)
		//IL_143b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1440: Unknown result type (might be due to invalid IL or missing references)
		//IL_1445: Unknown result type (might be due to invalid IL or missing references)
		//IL_1457: Unknown result type (might be due to invalid IL or missing references)
		//IL_1463: Unknown result type (might be due to invalid IL or missing references)
		//IL_1468: Unknown result type (might be due to invalid IL or missing references)
		//IL_146d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e44: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14da: Unknown result type (might be due to invalid IL or missing references)
		//IL_14e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1500: Unknown result type (might be due to invalid IL or missing references)
		//IL_1502: Unknown result type (might be due to invalid IL or missing references)
		//IL_1504: Unknown result type (might be due to invalid IL or missing references)
		//IL_1506: Unknown result type (might be due to invalid IL or missing references)
		//IL_150b: Unknown result type (might be due to invalid IL or missing references)
		//IL_151f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1521: Unknown result type (might be due to invalid IL or missing references)
		//IL_1523: Unknown result type (might be due to invalid IL or missing references)
		//IL_1528: Unknown result type (might be due to invalid IL or missing references)
		//IL_152a: Unknown result type (might be due to invalid IL or missing references)
		//IL_152c: Unknown result type (might be due to invalid IL or missing references)
		//IL_152e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1533: Unknown result type (might be due to invalid IL or missing references)
		//IL_1547: Unknown result type (might be due to invalid IL or missing references)
		//IL_1549: Unknown result type (might be due to invalid IL or missing references)
		//IL_1479: Unknown result type (might be due to invalid IL or missing references)
		//IL_147b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e64: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e66: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e72: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ea1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ea3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ea5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1eaa: Unknown result type (might be due to invalid IL or missing references)
		//IL_148f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1491: Unknown result type (might be due to invalid IL or missing references)
		//IL_1493: Unknown result type (might be due to invalid IL or missing references)
		//IL_1498: Unknown result type (might be due to invalid IL or missing references)
		//IL_149d: Unknown result type (might be due to invalid IL or missing references)
		//IL_149f: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_14b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_19d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_20eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_20ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1590: Unknown result type (might be due to invalid IL or missing references)
		//IL_159c: Unknown result type (might be due to invalid IL or missing references)
		//IL_19b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_2106: Unknown result type (might be due to invalid IL or missing references)
		//IL_2108: Unknown result type (might be due to invalid IL or missing references)
		//IL_210d: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_19c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_211f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2121: Unknown result type (might be due to invalid IL or missing references)
		//IL_2126: Unknown result type (might be due to invalid IL or missing references)
		//IL_15df: Unknown result type (might be due to invalid IL or missing references)
		//IL_15eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_15c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_15cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a10: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a19: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a23: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a28: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a2a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a33: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a38: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a3d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a4f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a60: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a65: Unknown result type (might be due to invalid IL or missing references)
		//IL_2412: Unknown result type (might be due to invalid IL or missing references)
		//IL_2414: Unknown result type (might be due to invalid IL or missing references)
		//IL_242a: Unknown result type (might be due to invalid IL or missing references)
		//IL_242f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2434: Unknown result type (might be due to invalid IL or missing references)
		//IL_243d: Unknown result type (might be due to invalid IL or missing references)
		//IL_243f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2441: Unknown result type (might be due to invalid IL or missing references)
		//IL_2446: Unknown result type (might be due to invalid IL or missing references)
		//IL_244b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2144: Unknown result type (might be due to invalid IL or missing references)
		//IL_2146: Unknown result type (might be due to invalid IL or missing references)
		//IL_1602: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aad: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aaf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1abd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ade: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ae3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ae8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aed: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aef: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1afa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1afc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1afe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b03: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b17: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b19: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b1b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b20: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b22: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b24: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b26: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b2b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b3f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b41: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a71: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a73: Unknown result type (might be due to invalid IL or missing references)
		//IL_252a: Unknown result type (might be due to invalid IL or missing references)
		//IL_252c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2542: Unknown result type (might be due to invalid IL or missing references)
		//IL_2547: Unknown result type (might be due to invalid IL or missing references)
		//IL_254c: Unknown result type (might be due to invalid IL or missing references)
		//IL_2555: Unknown result type (might be due to invalid IL or missing references)
		//IL_2557: Unknown result type (might be due to invalid IL or missing references)
		//IL_2559: Unknown result type (might be due to invalid IL or missing references)
		//IL_255e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2563: Unknown result type (might be due to invalid IL or missing references)
		//IL_2166: Unknown result type (might be due to invalid IL or missing references)
		//IL_2151: Unknown result type (might be due to invalid IL or missing references)
		//IL_215a: Unknown result type (might be due to invalid IL or missing references)
		//IL_215f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2164: Unknown result type (might be due to invalid IL or missing references)
		//IL_162e: Unknown result type (might be due to invalid IL or missing references)
		//IL_163a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1615: Unknown result type (might be due to invalid IL or missing references)
		//IL_161c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a87: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a89: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a90: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a95: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a97: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a99: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aa0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aa2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aa4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aa6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aab: Unknown result type (might be due to invalid IL or missing references)
		//IL_2175: Unknown result type (might be due to invalid IL or missing references)
		//IL_1651: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b88: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b94: Unknown result type (might be due to invalid IL or missing references)
		//IL_2191: Unknown result type (might be due to invalid IL or missing references)
		//IL_2193: Unknown result type (might be due to invalid IL or missing references)
		//IL_219a: Unknown result type (might be due to invalid IL or missing references)
		//IL_219c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1664: Unknown result type (might be due to invalid IL or missing references)
		//IL_166b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bab: Unknown result type (might be due to invalid IL or missing references)
		//IL_171c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1684: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bd7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bbe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bc5: Unknown result type (might be due to invalid IL or missing references)
		//IL_172a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1695: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c26: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c32: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c0d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c14: Unknown result type (might be due to invalid IL or missing references)
		//IL_176e: Unknown result type (might be due to invalid IL or missing references)
		//IL_173f: Unknown result type (might be due to invalid IL or missing references)
		//IL_16ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c49: Unknown result type (might be due to invalid IL or missing references)
		//IL_182b: Unknown result type (might be due to invalid IL or missing references)
		//IL_182d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1833: Unknown result type (might be due to invalid IL or missing references)
		//IL_1835: Unknown result type (might be due to invalid IL or missing references)
		//IL_1837: Unknown result type (might be due to invalid IL or missing references)
		//IL_1839: Unknown result type (might be due to invalid IL or missing references)
		//IL_17c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1791: Unknown result type (might be due to invalid IL or missing references)
		//IL_16e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_16bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c63: Unknown result type (might be due to invalid IL or missing references)
		//IL_17e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_16f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d14: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c7c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1817: Unknown result type (might be due to invalid IL or missing references)
		//IL_1819: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d22: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d66: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d37: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ca4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e23: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e25: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e2b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e2d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e31: Unknown result type (might be due to invalid IL or missing references)
		//IL_1db9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d89: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cda: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dd9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ced: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e0f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e11: Unknown result type (might be due to invalid IL or missing references)
		if (World.Cached)
		{
			TerrainMeta.Path.DungeonGridRoot = HierarchyUtil.GetRoot("Dungeon");
		}
		else if (World.Networked)
		{
			World.Spawn("Dungeon");
			TerrainMeta.Path.DungeonGridRoot = HierarchyUtil.GetRoot("Dungeon");
		}
		else
		{
			if (ConnectionType == InfrastructureType.Tunnel && !World.Config.BelowGroundRails)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + TunnelFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array == null || array.Length == 0)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array2 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + StationFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array2 == null || array2.Length == 0)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array3 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + UpwardsFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array3 == null)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array4 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + TransitionFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array4 == null)
			{
				return;
			}
			Prefab<DungeonGridLink>[] array5 = Prefab.Load<DungeonGridLink>("assets/bundled/prefabs/autospawn/" + LinkFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array5 == null)
			{
				return;
			}
			array5 = array5.OrderByDescending((Prefab<DungeonGridLink> x) => x.Component.Priority).ToArray();
			List<DungeonGridInfo> list = (Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.DungeonGridEntrances : null);
			WorldSpaceGrid<Prefab<DungeonGridCell>> val = new WorldSpaceGrid<Prefab<DungeonGridCell>>(TerrainMeta.Size.x, (float)CellSize, (RoundingMode)1);
			int[,] array6 = new int[val.CellCount, val.CellCount];
			DungeonGridConnectionHash[,] hashmap = new DungeonGridConnectionHash[val.CellCount, val.CellCount];
			PathFinder pathFinder = new PathFinder(array6, diagonals: false);
			int cellCount = val.CellCount;
			int num = 0;
			int num2 = val.CellCount - 1;
			for (int i = 0; i < cellCount; i++)
			{
				for (int j = 0; j < cellCount; j++)
				{
					array6[j, i] = 1;
				}
			}
			List<PathSegment> list2 = new List<PathSegment>();
			List<PathLink> list3 = new List<PathLink>();
			List<PathNode> list4 = new List<PathNode>();
			List<PathNode> unconnectedNodeList = new List<PathNode>();
			List<PathNode> secondaryNodeList = new List<PathNode>();
			List<PathFinder.Point> list5 = new List<PathFinder.Point>();
			List<PathFinder.Point> list6 = new List<PathFinder.Point>();
			List<PathFinder.Point> list7 = new List<PathFinder.Point>();
			foreach (DungeonGridInfo item3 in list)
			{
				DungeonGridInfo entrance = item3;
				TerrainPathConnect[] componentsInChildren = ((Component)entrance).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type != ConnectionType)
					{
						continue;
					}
					Vector2i val2 = val.WorldToGridCoords(((Component)terrainPathConnect).transform.position);
					if (array6[val2.x, val2.y] == int.MaxValue)
					{
						continue;
					}
					PathFinder.Node stationNode = pathFinder.FindClosestWalkable(new PathFinder.Point(val2.x, val2.y), 1);
					if (stationNode == null)
					{
						continue;
					}
					Prefab<DungeonGridCell> prefab2 = ((val2.x > num) ? val[val2.x - 1, val2.y] : null);
					Prefab<DungeonGridCell> prefab3 = ((val2.x < num2) ? val[val2.x + 1, val2.y] : null);
					Prefab<DungeonGridCell> prefab4 = ((val2.y > num) ? val[val2.x, val2.y - 1] : null);
					Prefab<DungeonGridCell> obj = ((val2.y < num2) ? val[val2.x, val2.y + 1] : null);
					DungeonGridConnectionType dungeonGridConnectionType = prefab2?.Component.East ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType2 = prefab3?.Component.West ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType3 = prefab4?.Component.North ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType4 = obj?.Component.South ?? DungeonGridConnectionType.None;
					bool flag = prefab2 != null || val2.x <= num;
					bool flag2 = prefab3 != null || val2.x >= num2;
					bool flag3 = prefab4 != null || val2.y <= num;
					bool flag4 = obj != null || val2.y >= num2;
					Prefab<DungeonGridCell> prefab5 = null;
					float num3 = float.MaxValue;
					array2.Shuffle(ref seed);
					Prefab<DungeonGridCell>[] array7 = array2;
					foreach (Prefab<DungeonGridCell> prefab6 in array7)
					{
						if ((flag && prefab6.Component.West != dungeonGridConnectionType) || (flag2 && prefab6.Component.East != dungeonGridConnectionType2) || (flag3 && prefab6.Component.South != dungeonGridConnectionType3) || (flag4 && prefab6.Component.North != dungeonGridConnectionType4))
						{
							continue;
						}
						DungeonVolume componentInChildren = prefab6.Object.GetComponentInChildren<DungeonVolume>();
						DungeonVolume componentInChildren2 = ((Component)entrance).GetComponentInChildren<DungeonVolume>();
						OBB bounds = componentInChildren.GetBounds(val.GridToWorldCoords(val2), Quaternion.identity);
						OBB bounds2 = componentInChildren2.GetBounds(((Component)entrance).transform.position, Quaternion.identity);
						if (!((OBB)(ref bounds)).Intersects2D(bounds2))
						{
							DungeonGridLink componentInChildren3 = prefab6.Object.GetComponentInChildren<DungeonGridLink>();
							Vector3 val3 = val.GridToWorldCoords(new Vector2i(val2.x, val2.y)) + componentInChildren3.UpSocket.localPosition;
							float num4 = Vector3Ex.Magnitude2D(((Component)terrainPathConnect).transform.position - val3);
							if (!(num3 < num4))
							{
								prefab5 = prefab6;
								num3 = num4;
							}
						}
					}
					bool isStartPoint;
					if (prefab5 != null)
					{
						val[val2.x, val2.y] = prefab5;
						array6[val2.x, val2.y] = int.MaxValue;
						isStartPoint = secondaryNodeList.Count == 0;
						secondaryNodeList.RemoveAll((PathNode x) => x.node.point == stationNode.point);
						unconnectedNodeList.RemoveAll((PathNode x) => x.node.point == stationNode.point);
						if (prefab5.Component.West != 0)
						{
							AddNode(val2.x - 1, val2.y);
						}
						if (prefab5.Component.East != 0)
						{
							AddNode(val2.x + 1, val2.y);
						}
						if (prefab5.Component.South != 0)
						{
							AddNode(val2.x, val2.y - 1);
						}
						if (prefab5.Component.North != 0)
						{
							AddNode(val2.x, val2.y + 1);
						}
						PathLink pathLink = new PathLink();
						DungeonGridLink componentInChildren4 = ((Component)entrance).gameObject.GetComponentInChildren<DungeonGridLink>();
						Vector3 position = ((Component)entrance).transform.position;
						Quaternion rotation = ((Component)entrance).transform.rotation;
						Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
						DungeonGridLink componentInChildren5 = prefab5.Object.GetComponentInChildren<DungeonGridLink>();
						Vector3 position2 = val.GridToWorldCoords(new Vector2i(val2.x, val2.y));
						Vector3 zero = Vector3.zero;
						pathLink.downwards = new PathLinkSide();
						pathLink.downwards.origin = new PathLinkSegment();
						pathLink.downwards.origin.position = position;
						pathLink.downwards.origin.rotation = Quaternion.Euler(eulerAngles);
						pathLink.downwards.origin.scale = Vector3.one;
						pathLink.downwards.origin.link = componentInChildren4;
						pathLink.downwards.segments = new List<PathLinkSegment>();
						pathLink.upwards = new PathLinkSide();
						pathLink.upwards.origin = new PathLinkSegment();
						pathLink.upwards.origin.position = position2;
						pathLink.upwards.origin.rotation = Quaternion.Euler(zero);
						pathLink.upwards.origin.scale = Vector3.one;
						pathLink.upwards.origin.link = componentInChildren5;
						pathLink.upwards.segments = new List<PathLinkSegment>();
						list3.Add(pathLink);
					}
					void AddNode(int x, int y)
					{
						//IL_0059: Unknown result type (might be due to invalid IL or missing references)
						PathFinder.Node node8 = pathFinder.FindClosestWalkable(new PathFinder.Point(x, y), 1);
						if (node8 != null)
						{
							PathNode item2 = new PathNode
							{
								monument = (Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.FindClosest(TerrainMeta.Path.Monuments, ((Component)entrance).transform.position) : ((Component)((Component)entrance).transform).GetComponentInParent<MonumentInfo>()),
								node = node8
							};
							if (isStartPoint)
							{
								secondaryNodeList.Add(item2);
							}
							else
							{
								unconnectedNodeList.Add(item2);
							}
							DungeonGridConnectionHash dungeonGridConnectionHash4 = hashmap[node8.point.x, node8.point.y];
							DungeonGridConnectionHash dungeonGridConnectionHash5 = hashmap[stationNode.point.x, stationNode.point.y];
							if (node8.point.x > stationNode.point.x)
							{
								dungeonGridConnectionHash4.West = true;
								dungeonGridConnectionHash5.East = true;
							}
							if (node8.point.x < stationNode.point.x)
							{
								dungeonGridConnectionHash4.East = true;
								dungeonGridConnectionHash5.West = true;
							}
							if (node8.point.y > stationNode.point.y)
							{
								dungeonGridConnectionHash4.South = true;
								dungeonGridConnectionHash5.North = true;
							}
							if (node8.point.y < stationNode.point.y)
							{
								dungeonGridConnectionHash4.North = true;
								dungeonGridConnectionHash5.South = true;
							}
							hashmap[node8.point.x, node8.point.y] = dungeonGridConnectionHash4;
							hashmap[stationNode.point.x, stationNode.point.y] = dungeonGridConnectionHash5;
						}
					}
				}
			}
			while (unconnectedNodeList.Count != 0 || secondaryNodeList.Count != 0)
			{
				if (unconnectedNodeList.Count == 0)
				{
					PathNode node = secondaryNodeList[0];
					unconnectedNodeList.AddRange(secondaryNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node.monument));
					secondaryNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node.monument);
					Vector2i val4 = val.WorldToGridCoords(((Component)node.monument).transform.position);
					pathFinder.PushPoint = new PathFinder.Point(val4.x, val4.y);
					pathFinder.PushRadius = (pathFinder.PushDistance = 2);
					pathFinder.PushMultiplier = 16;
				}
				list7.Clear();
				list7.AddRange(unconnectedNodeList.Select((PathNode x) => x.node.point));
				list6.Clear();
				list6.AddRange(list4.Select((PathNode x) => x.node.point));
				list6.AddRange(secondaryNodeList.Select((PathNode x) => x.node.point));
				list6.AddRange(list5);
				PathFinder.Node node2 = pathFinder.FindPathUndirected(list6, list7, 100000);
				if (node2 == null)
				{
					PathNode node3 = unconnectedNodeList[0];
					secondaryNodeList.AddRange(unconnectedNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument));
					unconnectedNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument);
					secondaryNodeList.Remove(node3);
					list4.Add(node3);
					continue;
				}
				PathSegment segment = new PathSegment();
				for (PathFinder.Node node4 = node2; node4 != null; node4 = node4.next)
				{
					if (node4 == node2)
					{
						segment.start = node4;
					}
					if (node4.next == null)
					{
						segment.end = node4;
					}
				}
				list2.Add(segment);
				PathNode node5 = unconnectedNodeList.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				secondaryNodeList.AddRange(unconnectedNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument));
				unconnectedNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument);
				secondaryNodeList.Remove(node5);
				list4.Add(node5);
				PathNode pathNode = secondaryNodeList.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				if (pathNode != null)
				{
					secondaryNodeList.Remove(pathNode);
					list4.Add(pathNode);
				}
				for (PathFinder.Node node6 = node2; node6 != null; node6 = node6.next)
				{
					if (node6 != node2 && node6.next != null)
					{
						list5.Add(node6.point);
					}
				}
			}
			foreach (PathSegment item4 in list2)
			{
				PathFinder.Node node7 = item4.start;
				while (node7 != null && node7.next != null)
				{
					DungeonGridConnectionHash dungeonGridConnectionHash = hashmap[node7.point.x, node7.point.y];
					DungeonGridConnectionHash dungeonGridConnectionHash2 = hashmap[node7.next.point.x, node7.next.point.y];
					if (node7.point.x > node7.next.point.x)
					{
						dungeonGridConnectionHash.West = true;
						dungeonGridConnectionHash2.East = true;
					}
					if (node7.point.x < node7.next.point.x)
					{
						dungeonGridConnectionHash.East = true;
						dungeonGridConnectionHash2.West = true;
					}
					if (node7.point.y > node7.next.point.y)
					{
						dungeonGridConnectionHash.South = true;
						dungeonGridConnectionHash2.North = true;
					}
					if (node7.point.y < node7.next.point.y)
					{
						dungeonGridConnectionHash.North = true;
						dungeonGridConnectionHash2.South = true;
					}
					hashmap[node7.point.x, node7.point.y] = dungeonGridConnectionHash;
					hashmap[node7.next.point.x, node7.next.point.y] = dungeonGridConnectionHash2;
					node7 = node7.next;
				}
			}
			for (int m = 0; m < val.CellCount; m++)
			{
				for (int n = 0; n < val.CellCount; n++)
				{
					if (array6[m, n] == int.MaxValue)
					{
						continue;
					}
					DungeonGridConnectionHash dungeonGridConnectionHash3 = hashmap[m, n];
					if (dungeonGridConnectionHash3.Value == 0)
					{
						continue;
					}
					array.Shuffle(ref seed);
					Prefab<DungeonGridCell>[] array7 = array;
					foreach (Prefab<DungeonGridCell> prefab7 in array7)
					{
						Prefab<DungeonGridCell> prefab8 = ((m > num) ? val[m - 1, n] : null);
						if (((prefab8 != null) ? ((prefab7.Component.West == prefab8.Component.East) ? 1 : 0) : (dungeonGridConnectionHash3.West ? ((int)prefab7.Component.West) : ((prefab7.Component.West == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab9 = ((m < num2) ? val[m + 1, n] : null);
						if (((prefab9 != null) ? ((prefab7.Component.East == prefab9.Component.West) ? 1 : 0) : (dungeonGridConnectionHash3.East ? ((int)prefab7.Component.East) : ((prefab7.Component.East == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab10 = ((n > num) ? val[m, n - 1] : null);
						if (((prefab10 != null) ? ((prefab7.Component.South == prefab10.Component.North) ? 1 : 0) : (dungeonGridConnectionHash3.South ? ((int)prefab7.Component.South) : ((prefab7.Component.South == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab11 = ((n < num2) ? val[m, n + 1] : null);
						if (((prefab11 != null) ? (prefab7.Component.North == prefab11.Component.South) : (dungeonGridConnectionHash3.North ? ((byte)prefab7.Component.North != 0) : (prefab7.Component.North == DungeonGridConnectionType.None))) && (prefab7.Component.West == DungeonGridConnectionType.None || prefab8 == null || !prefab7.Component.ShouldAvoid(prefab8.ID)) && (prefab7.Component.East == DungeonGridConnectionType.None || prefab9 == null || !prefab7.Component.ShouldAvoid(prefab9.ID)) && (prefab7.Component.South == DungeonGridConnectionType.None || prefab10 == null || !prefab7.Component.ShouldAvoid(prefab10.ID)) && (prefab7.Component.North == DungeonGridConnectionType.None || prefab11 == null || !prefab7.Component.ShouldAvoid(prefab11.ID)))
						{
							val[m, n] = prefab7;
							bool num5 = prefab8 == null || prefab7.Component.WestVariant == prefab8.Component.EastVariant;
							bool flag5 = prefab10 == null || prefab7.Component.SouthVariant == prefab10.Component.NorthVariant;
							if (num5 && flag5)
							{
								break;
							}
						}
					}
				}
			}
			Vector3 zero2 = Vector3.zero;
			Vector3 zero3 = Vector3.zero;
			Vector2i val5 = default(Vector2i);
			do
			{
				zero3 = zero2;
				for (int num6 = 0; num6 < val.CellCount; num6++)
				{
					for (int num7 = 0; num7 < val.CellCount; num7++)
					{
						Prefab<DungeonGridCell> prefab12 = val[num6, num7];
						if (prefab12 != null)
						{
							((Vector2i)(ref val5))..ctor(num6, num7);
							Vector3 val6 = val.GridToWorldCoords(val5);
							while (!IsValidPrefabPlacement(prefab12, zero2 + val6, Quaternion.identity, Vector3.one, EnvironmentType.Underground | EnvironmentType.Building))
							{
								zero2.y -= 3f;
							}
						}
					}
				}
			}
			while (zero2 != zero3);
			foreach (PathLink item5 in list3)
			{
				PathLinkSegment origin = item5.upwards.origin;
				origin.position += zero2;
			}
			foreach (PathLink item6 in list3)
			{
				Vector3 val7 = item6.upwards.origin.position + item6.upwards.origin.rotation * Vector3.Scale(item6.upwards.origin.upSocket.localPosition, item6.upwards.origin.scale);
				Vector3 val8 = item6.downwards.origin.position + item6.downwards.origin.rotation * Vector3.Scale(item6.downwards.origin.downSocket.localPosition, item6.downwards.origin.scale) - val7;
				Vector3[] array8 = (Vector3[])(object)new Vector3[2]
				{
					new Vector3(0f, 1f, 0f),
					new Vector3(1f, 1f, 1f)
				};
				foreach (Vector3 val9 in array8)
				{
					int num8 = 0;
					int num9 = 0;
					while (((Vector3)(ref val8)).magnitude > 1f && (num8 < 8 || num9 < 8))
					{
						bool flag6 = num8 > 2 && num9 > 2;
						bool flag7 = num8 > 4 && num9 > 4;
						Prefab<DungeonGridLink> prefab13 = null;
						Vector3 val10 = Vector3.zero;
						int num10 = int.MinValue;
						Vector3 position3 = Vector3.zero;
						Quaternion rotation2 = Quaternion.identity;
						PathLinkSegment prevSegment = item6.downwards.prevSegment;
						Vector3 val11 = prevSegment.position + prevSegment.rotation * Vector3.Scale(prevSegment.scale, prevSegment.downSocket.localPosition);
						Quaternion val12 = prevSegment.rotation * prevSegment.downSocket.localRotation;
						Prefab<DungeonGridLink>[] array9 = array5;
						foreach (Prefab<DungeonGridLink> prefab14 in array9)
						{
							float num11 = SeedRandom.Value(ref seed);
							DungeonGridLink component = prefab14.Component;
							if (prevSegment.downType != component.UpType)
							{
								continue;
							}
							switch (component.DownType)
							{
							case DungeonGridLinkType.Elevator:
								if (flag6 || val9.x != 0f || val9.z != 0f)
								{
									continue;
								}
								break;
							case DungeonGridLinkType.Transition:
								if (val9.x != 0f || val9.z != 0f)
								{
									continue;
								}
								break;
							}
							int num12 = ((!flag6) ? component.Priority : 0);
							if (num10 > num12)
							{
								continue;
							}
							Quaternion val13 = val12 * Quaternion.Inverse(component.UpSocket.localRotation);
							Quaternion val14 = val13 * component.DownSocket.localRotation;
							PathLinkSegment prevSegment2 = item6.upwards.prevSegment;
							Quaternion val15 = prevSegment2.rotation * prevSegment2.upSocket.localRotation;
							if (component.Rotation > 0)
							{
								if (Quaternion.Angle(val15, val14) > (float)component.Rotation)
								{
									continue;
								}
								Quaternion val16 = val15 * Quaternion.Inverse(val14);
								val13 *= val16;
								val14 *= val16;
							}
							Vector3 val17 = val11 - val13 * component.UpSocket.localPosition;
							Vector3 val18 = val13 * (component.DownSocket.localPosition - component.UpSocket.localPosition);
							Vector3 val19 = val8 + val10;
							Vector3 val20 = val8 + val18;
							float magnitude = ((Vector3)(ref val19)).magnitude;
							float magnitude2 = ((Vector3)(ref val20)).magnitude;
							Vector3 val21 = Vector3.Scale(val19, val9);
							Vector3 val22 = Vector3.Scale(val20, val9);
							float magnitude3 = ((Vector3)(ref val21)).magnitude;
							float magnitude4 = ((Vector3)(ref val22)).magnitude;
							if (val10 != Vector3.zero)
							{
								if (magnitude3 < magnitude4 || (magnitude3 == magnitude4 && magnitude < magnitude2) || (magnitude3 == magnitude4 && magnitude == magnitude2 && num11 < 0.5f))
								{
									continue;
								}
							}
							else if (magnitude3 <= magnitude4)
							{
								continue;
							}
							if (Mathf.Abs(val22.x) - Mathf.Abs(val21.x) > 0.01f || (Mathf.Abs(val22.x) > 0.01f && val19.x * val20.x < 0f) || Mathf.Abs(val22.y) - Mathf.Abs(val21.y) > 0.01f || (Mathf.Abs(val22.y) > 0.01f && val19.y * val20.y < 0f) || Mathf.Abs(val22.z) - Mathf.Abs(val21.z) > 0.01f || (Mathf.Abs(val22.z) > 0.01f && val19.z * val20.z < 0f) || (flag6 && val9.x == 0f && val9.z == 0f && component.DownType == DungeonGridLinkType.Default && ((Mathf.Abs(val20.x) > 0.01f && Mathf.Abs(val20.x) < LinkRadius * 2f - 0.1f) || (Mathf.Abs(val20.z) > 0.01f && Mathf.Abs(val20.z) < LinkRadius * 2f - 0.1f))))
							{
								continue;
							}
							num10 = num12;
							if (val9.x == 0f && val9.z == 0f)
							{
								if (!flag6 && Mathf.Abs(val20.y) < LinkTransition - 0.1f)
								{
									continue;
								}
							}
							else if ((!flag6 && magnitude4 > 0.01f && (Mathf.Abs(val20.x) < LinkRadius * 2f - 0.1f || Mathf.Abs(val20.z) < LinkRadius * 2f - 0.1f)) || (!flag7 && magnitude4 > 0.01f && (Mathf.Abs(val20.x) < LinkRadius * 1f - 0.1f || Mathf.Abs(val20.z) < LinkRadius * 1f - 0.1f)))
							{
								continue;
							}
							if (!flag6 || !(magnitude4 < 0.01f) || !(magnitude2 < 0.01f) || !(Quaternion.Angle(val15, val14) > 10f))
							{
								prefab13 = prefab14;
								val10 = val18;
								num10 = num12;
								position3 = val17;
								rotation2 = val13;
							}
						}
						if (val10 != Vector3.zero)
						{
							PathLinkSegment pathLinkSegment = new PathLinkSegment();
							pathLinkSegment.position = position3;
							pathLinkSegment.rotation = rotation2;
							pathLinkSegment.scale = Vector3.one;
							pathLinkSegment.prefab = prefab13;
							pathLinkSegment.link = prefab13.Component;
							item6.downwards.segments.Add(pathLinkSegment);
							val8 += val10;
						}
						else
						{
							num9++;
						}
						if (val9.x > 0f || val9.z > 0f)
						{
							Prefab<DungeonGridLink> prefab15 = null;
							Vector3 val23 = Vector3.zero;
							int num13 = int.MinValue;
							Vector3 position4 = Vector3.zero;
							Quaternion rotation3 = Quaternion.identity;
							PathLinkSegment prevSegment3 = item6.upwards.prevSegment;
							Vector3 val24 = prevSegment3.position + prevSegment3.rotation * Vector3.Scale(prevSegment3.scale, prevSegment3.upSocket.localPosition);
							Quaternion val25 = prevSegment3.rotation * prevSegment3.upSocket.localRotation;
							array9 = array5;
							foreach (Prefab<DungeonGridLink> prefab16 in array9)
							{
								float num14 = SeedRandom.Value(ref seed);
								DungeonGridLink component2 = prefab16.Component;
								if (prevSegment3.upType != component2.DownType)
								{
									continue;
								}
								switch (component2.DownType)
								{
								case DungeonGridLinkType.Elevator:
									if (flag6 || val9.x != 0f || val9.z != 0f)
									{
										continue;
									}
									break;
								case DungeonGridLinkType.Transition:
									if (val9.x != 0f || val9.z != 0f)
									{
										continue;
									}
									break;
								}
								int num15 = ((!flag6) ? component2.Priority : 0);
								if (num13 > num15)
								{
									continue;
								}
								Quaternion val26 = val25 * Quaternion.Inverse(component2.DownSocket.localRotation);
								Quaternion val27 = val26 * component2.UpSocket.localRotation;
								PathLinkSegment prevSegment4 = item6.downwards.prevSegment;
								Quaternion val28 = prevSegment4.rotation * prevSegment4.downSocket.localRotation;
								if (component2.Rotation > 0)
								{
									if (Quaternion.Angle(val28, val27) > (float)component2.Rotation)
									{
										continue;
									}
									Quaternion val29 = val28 * Quaternion.Inverse(val27);
									val26 *= val29;
									val27 *= val29;
								}
								Vector3 val30 = val24 - val26 * component2.DownSocket.localPosition;
								Vector3 val31 = val26 * (component2.UpSocket.localPosition - component2.DownSocket.localPosition);
								Vector3 val32 = val8 - val23;
								Vector3 val33 = val8 - val31;
								float magnitude5 = ((Vector3)(ref val32)).magnitude;
								float magnitude6 = ((Vector3)(ref val33)).magnitude;
								Vector3 val34 = Vector3.Scale(val32, val9);
								Vector3 val35 = Vector3.Scale(val33, val9);
								float magnitude7 = ((Vector3)(ref val34)).magnitude;
								float magnitude8 = ((Vector3)(ref val35)).magnitude;
								if (val23 != Vector3.zero)
								{
									if (magnitude7 < magnitude8 || (magnitude7 == magnitude8 && magnitude5 < magnitude6) || (magnitude7 == magnitude8 && magnitude5 == magnitude6 && num14 < 0.5f))
									{
										continue;
									}
								}
								else if (magnitude7 <= magnitude8)
								{
									continue;
								}
								if (Mathf.Abs(val35.x) - Mathf.Abs(val34.x) > 0.01f || (Mathf.Abs(val35.x) > 0.01f && val32.x * val33.x < 0f) || Mathf.Abs(val35.y) - Mathf.Abs(val34.y) > 0.01f || (Mathf.Abs(val35.y) > 0.01f && val32.y * val33.y < 0f) || Mathf.Abs(val35.z) - Mathf.Abs(val34.z) > 0.01f || (Mathf.Abs(val35.z) > 0.01f && val32.z * val33.z < 0f) || (flag6 && val9.x == 0f && val9.z == 0f && component2.UpType == DungeonGridLinkType.Default && ((Mathf.Abs(val33.x) > 0.01f && Mathf.Abs(val33.x) < LinkRadius * 2f - 0.1f) || (Mathf.Abs(val33.z) > 0.01f && Mathf.Abs(val33.z) < LinkRadius * 2f - 0.1f))))
								{
									continue;
								}
								num13 = num15;
								if (val9.x == 0f && val9.z == 0f)
								{
									if (!flag6 && Mathf.Abs(val33.y) < LinkTransition - 0.1f)
									{
										continue;
									}
								}
								else if ((!flag6 && magnitude8 > 0.01f && (Mathf.Abs(val33.x) < LinkRadius * 2f - 0.1f || Mathf.Abs(val33.z) < LinkRadius * 2f - 0.1f)) || (!flag7 && magnitude8 > 0.01f && (Mathf.Abs(val33.x) < LinkRadius * 1f - 0.1f || Mathf.Abs(val33.z) < LinkRadius * 1f - 0.1f)))
								{
									continue;
								}
								if (!flag6 || !(magnitude8 < 0.01f) || !(magnitude6 < 0.01f) || !(Quaternion.Angle(val28, val27) > 10f))
								{
									prefab15 = prefab16;
									val23 = val31;
									num13 = num15;
									position4 = val30;
									rotation3 = val26;
								}
							}
							if (val23 != Vector3.zero)
							{
								PathLinkSegment pathLinkSegment2 = new PathLinkSegment();
								pathLinkSegment2.position = position4;
								pathLinkSegment2.rotation = rotation3;
								pathLinkSegment2.scale = Vector3.one;
								pathLinkSegment2.prefab = prefab15;
								pathLinkSegment2.link = prefab15.Component;
								item6.upwards.segments.Add(pathLinkSegment2);
								val8 -= val23;
							}
							else
							{
								num8++;
							}
						}
						else
						{
							num8++;
						}
					}
				}
			}
			foreach (PathLink item7 in list3)
			{
				foreach (PathLinkSegment segment2 in item7.downwards.segments)
				{
					World.AddPrefab("Dungeon", segment2.prefab, segment2.position, segment2.rotation, segment2.scale);
				}
				foreach (PathLinkSegment segment3 in item7.upwards.segments)
				{
					World.AddPrefab("Dungeon", segment3.prefab, segment3.position, segment3.rotation, segment3.scale);
				}
			}
			if (TerrainMeta.Path.Rails.Count > 0)
			{
				List<PrefabReplacement> list8 = new List<PrefabReplacement>();
				Vector2i val36 = default(Vector2i);
				for (int num16 = 0; num16 < val.CellCount; num16++)
				{
					for (int num17 = 0; num17 < val.CellCount; num17++)
					{
						Prefab<DungeonGridCell> prefab17 = val[num16, num17];
						if (prefab17 == null || !prefab17.Component.Replaceable)
						{
							continue;
						}
						((Vector2i)(ref val36))..ctor(num16, num17);
						Vector3 val37 = val.GridToWorldCoords(val36) + zero2;
						Prefab<DungeonGridCell>[] array7 = array3;
						foreach (Prefab<DungeonGridCell> prefab18 in array7)
						{
							if (prefab17.Component.North != prefab18.Component.North || prefab17.Component.South != prefab18.Component.South || prefab17.Component.West != prefab18.Component.West || prefab17.Component.East != prefab18.Component.East || !IsValidPrefabPlacement(prefab18, val37, Quaternion.identity, Vector3.one, EnvironmentType.Underground) || !prefab18.ApplyTerrainChecks(val37, Quaternion.identity, Vector3.one) || !prefab18.ApplyTerrainFilters(val37, Quaternion.identity, Vector3.one))
							{
								continue;
							}
							MonumentInfo componentInChildren6 = prefab18.Object.GetComponentInChildren<MonumentInfo>();
							Vector3 val38 = val37;
							if (Object.op_Implicit((Object)(object)componentInChildren6))
							{
								val38 += ((Component)componentInChildren6).transform.position;
							}
							if (!(val38.y < 1f))
							{
								float distanceToAboveGroundRail = GetDistanceToAboveGroundRail(val38);
								if (!(distanceToAboveGroundRail < 200f))
								{
									PrefabReplacement item = default(PrefabReplacement);
									item.gridPosition = val36;
									item.worldPosition = val38;
									item.distance = Mathf.RoundToInt(distanceToAboveGroundRail);
									item.prefab = prefab18;
									list8.Add(item);
								}
							}
						}
					}
				}
				ListEx.Shuffle<PrefabReplacement>(list8, ref seed);
				list8.Sort((PrefabReplacement a, PrefabReplacement b) => a.distance.CompareTo(b.distance));
				int num18 = 2;
				while (num18 > 0 && list8.Count > 0)
				{
					num18--;
					PrefabReplacement replacement = list8[0];
					val[replacement.gridPosition.x, replacement.gridPosition.y] = replacement.prefab;
					list8.RemoveAll(delegate(PrefabReplacement a)
					{
						//IL_0001: Unknown result type (might be due to invalid IL or missing references)
						//IL_000c: Unknown result type (might be due to invalid IL or missing references)
						//IL_0011: Unknown result type (might be due to invalid IL or missing references)
						//IL_0016: Unknown result type (might be due to invalid IL or missing references)
						Vector3 val39 = a.worldPosition - replacement.worldPosition;
						return ((Vector3)(ref val39)).magnitude < 1500f;
					});
				}
			}
			Vector2i val40 = default(Vector2i);
			for (int num19 = 0; num19 < val.CellCount; num19++)
			{
				for (int num20 = 0; num20 < val.CellCount; num20++)
				{
					Prefab<DungeonGridCell> prefab19 = val[num19, num20];
					if (prefab19 != null)
					{
						((Vector2i)(ref val40))..ctor(num19, num20);
						Vector3 val41 = val.GridToWorldCoords(val40);
						World.AddPrefab("Dungeon", prefab19, zero2 + val41, Quaternion.identity, Vector3.one);
					}
				}
			}
			Vector2i val42 = default(Vector2i);
			Vector2i val44 = default(Vector2i);
			for (int num21 = 0; num21 < val.CellCount - 1; num21++)
			{
				for (int num22 = 0; num22 < val.CellCount - 1; num22++)
				{
					Prefab<DungeonGridCell> prefab20 = val[num21, num22];
					Prefab<DungeonGridCell> prefab21 = val[num21 + 1, num22];
					Prefab<DungeonGridCell> prefab22 = val[num21, num22 + 1];
					Prefab<DungeonGridCell>[] array7;
					if (prefab20 != null && prefab21 != null && prefab20.Component.EastVariant != prefab21.Component.WestVariant)
					{
						array4.Shuffle(ref seed);
						array7 = array4;
						foreach (Prefab<DungeonGridCell> prefab23 in array7)
						{
							if (prefab23.Component.West == prefab20.Component.East && prefab23.Component.East == prefab21.Component.West && prefab23.Component.WestVariant == prefab20.Component.EastVariant && prefab23.Component.EastVariant == prefab21.Component.WestVariant)
							{
								((Vector2i)(ref val42))..ctor(num21, num22);
								Vector3 val43 = val.GridToWorldCoords(val42) + new Vector3(val.CellSizeHalf, 0f, 0f);
								World.AddPrefab("Dungeon", prefab23, zero2 + val43, Quaternion.identity, Vector3.one);
								break;
							}
						}
					}
					if (prefab20 == null || prefab22 == null || prefab20.Component.NorthVariant == prefab22.Component.SouthVariant)
					{
						continue;
					}
					array4.Shuffle(ref seed);
					array7 = array4;
					foreach (Prefab<DungeonGridCell> prefab24 in array7)
					{
						if (prefab24.Component.South == prefab20.Component.North && prefab24.Component.North == prefab22.Component.South && prefab24.Component.SouthVariant == prefab20.Component.NorthVariant && prefab24.Component.NorthVariant == prefab22.Component.SouthVariant)
						{
							((Vector2i)(ref val44))..ctor(num21, num22);
							Vector3 val45 = val.GridToWorldCoords(val44) + new Vector3(0f, 0f, val.CellSizeHalf);
							World.AddPrefab("Dungeon", prefab24, zero2 + val45, Quaternion.identity, Vector3.one);
							break;
						}
					}
				}
			}
			if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
			{
				TerrainMeta.Path.DungeonGridRoot = HierarchyUtil.GetRoot("Dungeon");
			}
		}
		bool IsValidPrefabPlacement(Prefab<DungeonGridCell> prefab, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val46 = Vector3.up * 9f;
			Vector3 val47 = Vector3.up * (LinkTransition + 1f);
			if (!prefab.CheckEnvironmentVolumesBelowAltitude(pos + val46, rot, scale, EnvironmentType.Underground, EnvironmentType.Entrance) && !prefab.CheckEnvironmentVolumesInsideTerrain(pos + val46, rot, scale, EnvironmentType.TrainTunnels, EnvironmentType.Entrance))
			{
				return false;
			}
			if (prefab.CheckEnvironmentVolumes(pos + val47, rot, scale, type))
			{
				return false;
			}
			if (prefab.CheckEnvironmentVolumes(pos, rot, scale, type))
			{
				return false;
			}
			return true;
		}
	}

	private float GetDistanceToAboveGroundRail(Vector3 pos)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			foreach (PathList rail in TerrainMeta.Path.Rails)
			{
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					num = Mathf.Min(num, Vector3Ex.Distance2D(val, pos));
				}
			}
		}
		return num;
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;
}


private class PathLink
{
	public PathLinkSide downwards;

	public PathLinkSide upwards;
}


using System.Collections.Generic;

private class PathLinkSide
{
	public PathLinkSegment origin;

	public List<PathLinkSegment> segments;

	public PathLinkSegment prevSegment
	{
		get
		{
			if (segments.Count <= 0)
			{
				return origin;
			}
			return segments[segments.Count - 1];
		}
	}
}


using UnityEngine;

private class PathLinkSegment
{
	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public Prefab<DungeonGridLink> prefab;

	public DungeonGridLink link;

	public Transform downSocket => link.DownSocket;

	public Transform upSocket => link.UpSocket;

	public DungeonGridLinkType downType => link.DownType;

	public DungeonGridLinkType upType => link.UpType;
}


using UnityEngine;

private struct PrefabReplacement
{
	public Vector2i gridPosition;

	public Vector3 worldPosition;

	public int distance;

	public Prefab<DungeonGridCell> prefab;
}


using System;
using GenerateErosionJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using Unity.Mathematics;
using UnityEngine;

public class GenerateErosion : ProceduralComponent
{
	public struct SplatPaintingData : IDisposable
	{
		public bool IsValid;

		public readonly NativeArray<float> HeightMapDelta;

		public readonly NativeArray<float> AngleMap;

		public SplatPaintingData(NativeArray<float> heightMapDelta, NativeArray<float> angleMap)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			HeightMapDelta = heightMapDelta;
			AngleMap = angleMap;
			IsValid = true;
		}

		public void Dispose()
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			IsValid = false;
			if (HeightMapDelta.IsCreated)
			{
				HeightMapDelta.Dispose();
			}
			if (AngleMap.IsCreated)
			{
				AngleMap.Dispose();
			}
		}

		public void Dispose(JobHandle inputDeps)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			IsValid = false;
			if (HeightMapDelta.IsCreated)
			{
				HeightMapDelta.Dispose(inputDeps);
			}
			if (AngleMap.IsCreated)
			{
				AngleMap.Dispose(inputDeps);
			}
		}
	}

	public static SplatPaintingData splatPaintingData;

	public override void Process(uint seed)
	{
		if (!World.Networked)
		{
			GridErosion(seed);
		}
	}

	private static int GetBatchSize(int length)
	{
		int num = length / JobsUtility.JobWorkerCount;
		if (num < 64)
		{
			return 64;
		}
		return num;
	}

	private void GridErosion(uint seed)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0395: Unknown result type (might be due to invalid IL or missing references)
		//IL_039a: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040d: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0461: Unknown result type (might be due to invalid IL or missing references)
		//IL_0463: Unknown result type (might be due to invalid IL or missing references)
		//IL_0468: Unknown result type (might be due to invalid IL or missing references)
		//IL_0474: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0488: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_053a: Unknown result type (might be due to invalid IL or missing references)
		//IL_053c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0541: Unknown result type (might be due to invalid IL or missing references)
		//IL_054d: Unknown result type (might be due to invalid IL or missing references)
		//IL_054f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0566: Unknown result type (might be due to invalid IL or missing references)
		//IL_056b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0572: Unknown result type (might be due to invalid IL or missing references)
		//IL_0574: Unknown result type (might be due to invalid IL or missing references)
		//IL_057b: Unknown result type (might be due to invalid IL or missing references)
		//IL_057d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_058b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0601: Unknown result type (might be due to invalid IL or missing references)
		//IL_0608: Unknown result type (might be due to invalid IL or missing references)
		//IL_060a: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0628: Unknown result type (might be due to invalid IL or missing references)
		//IL_062d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0636: Unknown result type (might be due to invalid IL or missing references)
		//IL_063b: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0661: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		//IL_067d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0682: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_0693: Unknown result type (might be due to invalid IL or missing references)
		//IL_0695: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0706: Unknown result type (might be due to invalid IL or missing references)
		//IL_0717: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0741: Unknown result type (might be due to invalid IL or missing references)
		//IL_0746: Unknown result type (might be due to invalid IL or missing references)
		//IL_0751: Unknown result type (might be due to invalid IL or missing references)
		//IL_0756: Unknown result type (might be due to invalid IL or missing references)
		//IL_0764: Unknown result type (might be due to invalid IL or missing references)
		//IL_0769: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_0777: Unknown result type (might be due to invalid IL or missing references)
		//IL_077e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0780: Unknown result type (might be due to invalid IL or missing references)
		//IL_079e: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07db: Unknown result type (might be due to invalid IL or missing references)
		//IL_07dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0803: Unknown result type (might be due to invalid IL or missing references)
		//IL_0805: Unknown result type (might be due to invalid IL or missing references)
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_081a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GridErosion", 0);
		try
		{
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			heightMap.Push();
			NativeArray<short> src = heightMap.src;
			NativeArray<short> dst = heightMap.dst;
			NativeArray<float> minTerrainHeightMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)0);
			NativeArray<float> waterMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeList<int> val2 = new NativeList<int>(heightMap.src.Length, AllocatorHandle.op_Implicit((Allocator)4));
			NativeArray<float4> fluxMap = new NativeArray<float4>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float2> velocityMap = new NativeArray<float2>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> val3 = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> copyTarget = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> angleMap = new NativeArray<float>(heightMap.src.Length, (Allocator)4, (NativeArrayOptions)0);
			Debug.Assert(waterMap.Length == heightMap.src.Length);
			Debug.Assert(fluxMap.Length == heightMap.src.Length);
			Debug.Assert(velocityMap.Length == heightMap.src.Length);
			Debug.Assert(val3.Length == heightMap.src.Length);
			float num = TerrainMeta.Size.x / (float)heightMap.res * TerrainMeta.Size.z / (float)heightMap.res;
			float invGridCellSquareSize = 1f / num;
			float pipeLength = 1f;
			float pipeArea = 1f;
			JobHandle val4 = default(JobHandle);
			NativeArray<float> val5 = new NativeArray<float>(src.Length, (Allocator)4, (NativeArrayOptions)1);
			NativeArray<float> val6 = new NativeArray<float>(val5, (Allocator)4);
			PrepareMapJob prepareMapJob = default(PrepareMapJob);
			prepareMapJob.HeightMapAsShort = src.AsReadOnly();
			prepareMapJob.HeightMapAsFloat = val5;
			prepareMapJob.OceanIndicesWriter = val2.AsParallelWriter();
			prepareMapJob.OceanLevel = WaterSystem.OceanLevel;
			prepareMapJob.TerrainPositionY = TerrainMeta.Position.y;
			prepareMapJob.TerrainSizeY = TerrainMeta.Size.y;
			val4 = IJobParallelForBatchExtensions.Schedule<PrepareMapJob>(prepareMapJob, src.Length, GetBatchSize(src.Length), val4);
			CalcMinHeightMapJob calcMinHeightMapJob = default(CalcMinHeightMapJob);
			calcMinHeightMapJob.TerrainHeightMap = val5.AsReadOnly();
			calcMinHeightMapJob.MinTerrainHeightMap = minTerrainHeightMap;
			calcMinHeightMapJob.HeightMapRes = TerrainMeta.HeightMap.res;
			calcMinHeightMapJob.TopologyMap = TerrainMeta.TopologyMap.src.AsReadOnly();
			calcMinHeightMapJob.TopologyMapRes = TerrainMeta.TopologyMap.res;
			calcMinHeightMapJob.OceanHeight = WaterSystem.OceanLevel;
			calcMinHeightMapJob.TerrainOneOverSizeX = TerrainMeta.OneOverSize.x;
			val4 = IJobParallelForExtensions.Schedule<CalcMinHeightMapJob>(calcMinHeightMapJob, val5.Length, GetBatchSize(val5.Length), val4);
			((JobHandle)(ref val4)).Complete();
			val4 = default(JobHandle);
			NativeArray<float> copyTarget2 = new NativeArray<float>(src.Length, (Allocator)4, (NativeArrayOptions)1);
			CopyArrayJob<float> copyArrayJob = default(CopyArrayJob<float>);
			copyArrayJob.CopyTarget = copyTarget2;
			copyArrayJob.CopySource = val5;
			CopyArrayJob<float> copyArrayJob2 = copyArrayJob;
			CopyArrayJob<float> copyArrayJob3 = new CopyArrayJob<float>
			{
				CopyTarget = val6,
				CopySource = val5
			};
			val4 = JobHandle.CombineDependencies(IJobExtensions.Schedule<CopyArrayJob<float>>(copyArrayJob2, val4), IJobExtensions.Schedule<CopyArrayJob<float>>(copyArrayJob3, val4));
			int num2 = 32;
			int num3 = 32;
			int num4 = (heightMap.res + num2 - 1) / num2;
			int num5 = (heightMap.res + num3 - 1) / num3;
			int num6 = num4 * num5;
			for (int i = 0; i < 512; i++)
			{
				RefillOceanJob refillOceanJob = default(RefillOceanJob);
				refillOceanJob.OceanIndices = val2.AsReadOnly();
				refillOceanJob.HeightMap = val5.AsReadOnly();
				refillOceanJob.OceanLevel = WaterSystem.OceanLevel;
				refillOceanJob.WaterMap = waterMap;
				RefillOceanJob refillOceanJob2 = refillOceanJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<RefillOceanJob>(ref refillOceanJob2, val2.Length, GetBatchSize(val2.Length), val4);
				WaterIncrementationJob waterIncrementationJob = default(WaterIncrementationJob);
				waterIncrementationJob.WaterMap = waterMap;
				waterIncrementationJob.WaterFillRate = 0.04f;
				waterIncrementationJob.DT = 0.06f;
				WaterIncrementationJob waterIncrementationJob2 = waterIncrementationJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<WaterIncrementationJob>(ref waterIncrementationJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
				CalculateOutputFluxJob calculateOutputFluxJob = default(CalculateOutputFluxJob);
				calculateOutputFluxJob.TerrainHeightMapFloatVal = val5.AsReadOnly();
				calculateOutputFluxJob.WaterMap = waterMap.AsReadOnly();
				calculateOutputFluxJob.FluxMap = fluxMap;
				calculateOutputFluxJob.Res = heightMap.res;
				calculateOutputFluxJob.DT = 0.06f;
				calculateOutputFluxJob.GridCellSquareSize = num;
				calculateOutputFluxJob.PipeLength = pipeLength;
				calculateOutputFluxJob.PipeArea = pipeArea;
				CalculateOutputFluxJob calculateOutputFluxJob2 = calculateOutputFluxJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<CalculateOutputFluxJob>(ref calculateOutputFluxJob2, fluxMap.Length, GetBatchSize(fluxMap.Length), val4);
				AdjustWaterHeightByFluxJob adjustWaterHeightByFluxJob = default(AdjustWaterHeightByFluxJob);
				adjustWaterHeightByFluxJob.WaterMap = waterMap;
				adjustWaterHeightByFluxJob.VelocityMap = velocityMap;
				adjustWaterHeightByFluxJob.FluxMap = fluxMap.AsReadOnly();
				adjustWaterHeightByFluxJob.Res = heightMap.res;
				adjustWaterHeightByFluxJob.DT = 0.06f;
				adjustWaterHeightByFluxJob.InvGridCellSquareSize = invGridCellSquareSize;
				AdjustWaterHeightByFluxJob adjustWaterHeightByFluxJob2 = adjustWaterHeightByFluxJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<AdjustWaterHeightByFluxJob>(ref adjustWaterHeightByFluxJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
				TileCalculateAngleMap tileCalculateAngleMap = default(TileCalculateAngleMap);
				tileCalculateAngleMap.AngleMap = angleMap;
				tileCalculateAngleMap.TerrainHeightMapSrcFloat = val5.AsReadOnly();
				tileCalculateAngleMap.NormY = heightMap.normY;
				tileCalculateAngleMap.Res = heightMap.res;
				tileCalculateAngleMap.TileSizeX = num2;
				tileCalculateAngleMap.TileSizeZ = num3;
				tileCalculateAngleMap.NumXTiles = num4;
				TileCalculateAngleMap tileCalculateAngleMap2 = tileCalculateAngleMap;
				val4 = IJobParallelForExtensions.ScheduleByRef<TileCalculateAngleMap>(ref tileCalculateAngleMap2, num6, num6 / JobsUtility.JobWorkerCount, val4);
				ErosionAndDepositionJob erosionAndDepositionJob = default(ErosionAndDepositionJob);
				erosionAndDepositionJob.SedimentMap = val3;
				erosionAndDepositionJob.MinTerrainHeightMap = minTerrainHeightMap.AsReadOnly();
				erosionAndDepositionJob.TerrainHeightMapSrcFloat = val5.AsReadOnly();
				erosionAndDepositionJob.TerrainHeightMapDstFloat = val6;
				erosionAndDepositionJob.WaterMap = waterMap;
				erosionAndDepositionJob.VelocityMap = velocityMap.AsReadOnly();
				erosionAndDepositionJob.AngleMap = angleMap.AsReadOnly();
				erosionAndDepositionJob.DT = 0.06f;
				ErosionAndDepositionJob erosionAndDepositionJob2 = erosionAndDepositionJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<ErosionAndDepositionJob>(ref erosionAndDepositionJob2, val3.Length, GetBatchSize(val3.Length), val4);
				copyArrayJob = default(CopyArrayJob<float>);
				copyArrayJob.CopyTarget = copyTarget;
				copyArrayJob.CopySource = val3;
				CopyArrayJob<float> copyArrayJob4 = copyArrayJob;
				val4 = IJobExtensions.ScheduleByRef<CopyArrayJob<float>>(ref copyArrayJob4, val4);
				copyArrayJob = default(CopyArrayJob<float>);
				copyArrayJob.CopyTarget = val5;
				copyArrayJob.CopySource = val6;
				CopyArrayJob<float> copyArrayJob5 = copyArrayJob;
				TransportSedimentJob transportSedimentJob = default(TransportSedimentJob);
				transportSedimentJob.SedimentMap = val3;
				transportSedimentJob.SedimentReadOnlyMap = copyTarget.AsReadOnly();
				transportSedimentJob.VelocityMap = velocityMap.AsReadOnly();
				transportSedimentJob.Res = heightMap.res;
				transportSedimentJob.DT = 0.06f;
				TransportSedimentJob transportSedimentJob2 = transportSedimentJob;
				val4 = JobHandle.CombineDependencies(IJobExtensions.ScheduleByRef<CopyArrayJob<float>>(ref copyArrayJob5, val4), IJobParallelForExtensions.ScheduleByRef<TransportSedimentJob>(ref transportSedimentJob2, val3.Length, GetBatchSize(val3.Length), val4));
				EvaporationJob evaporationJob = default(EvaporationJob);
				evaporationJob.WaterMap = waterMap;
				evaporationJob.DT = 0.06f;
				evaporationJob.EvaporationRate = 0.015f;
				EvaporationJob evaporationJob2 = evaporationJob;
				val4 = IJobParallelForExtensions.ScheduleByRef<EvaporationJob>(ref evaporationJob2, waterMap.Length, GetBatchSize(waterMap.Length), val4);
			}
			CopyBackFloatHeightToShortHeightJob copyBackFloatHeightToShortHeightJob = default(CopyBackFloatHeightToShortHeightJob);
			copyBackFloatHeightToShortHeightJob.HeightMapAsFloat = val5.AsReadOnly();
			copyBackFloatHeightToShortHeightJob.HeightMapAsShort = dst;
			copyBackFloatHeightToShortHeightJob.TerrainOneOverSizeY = TerrainMeta.OneOverSize.y;
			copyBackFloatHeightToShortHeightJob.TerrainPositionY = TerrainMeta.Position.y;
			CopyBackFloatHeightToShortHeightJob copyBackFloatHeightToShortHeightJob2 = copyBackFloatHeightToShortHeightJob;
			val4 = IJobParallelForExtensions.ScheduleByRef<CopyBackFloatHeightToShortHeightJob>(ref copyBackFloatHeightToShortHeightJob2, val5.Length, GetBatchSize(val5.Length), val4);
			NativeArray<float> val7 = new NativeArray<float>(val5.Length, (Allocator)4, (NativeArrayOptions)1);
			PopulateDeltaHeightJob populateDeltaHeightJob = default(PopulateDeltaHeightJob);
			populateDeltaHeightJob.HeightMapOriginal = copyTarget2.AsReadOnly();
			populateDeltaHeightJob.HeightMap = val5.AsReadOnly();
			populateDeltaHeightJob.DeltaHeightMap = val7;
			PopulateDeltaHeightJob populateDeltaHeightJob2 = populateDeltaHeightJob;
			val4 = IJobParallelForExtensions.ScheduleByRef<PopulateDeltaHeightJob>(ref populateDeltaHeightJob2, val7.Length, GetBatchSize(val7.Length), val4);
			minTerrainHeightMap.Dispose(val4);
			waterMap.Dispose(val4);
			fluxMap.Dispose(val4);
			velocityMap.Dispose(val4);
			val3.Dispose(val4);
			copyTarget.Dispose(val4);
			val5.Dispose(val4);
			val6.Dispose(val4);
			val2.Dispose(val4);
			copyTarget2.Dispose(val4);
			((JobHandle)(ref val4)).Complete();
			heightMap.Pop();
			splatPaintingData = new SplatPaintingData(val7, angleMap);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void OnDestroy()
	{
		if (splatPaintingData.IsValid)
		{
			splatPaintingData.Dispose();
		}
	}

	private void OldErosion(uint seed)
	{
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		int erosion_res = heightmap.res;
		float[] erosion = new float[erosion_res * erosion_res];
		int deposit_res = splatmap.res;
		float[] deposit = new float[deposit_res * deposit_res];
		Vector3 val = default(Vector3);
		for (float num = TerrainMeta.Position.z; num < TerrainMeta.Position.z + TerrainMeta.Size.z; num += 10f)
		{
			for (float num2 = TerrainMeta.Position.x; num2 < TerrainMeta.Position.x + TerrainMeta.Size.x; num2 += 10f)
			{
				((Vector3)(ref val))..ctor(num2, 0f, num);
				float num3 = (val.y = heightmap.GetHeight(val));
				if (val.y <= 15f)
				{
					continue;
				}
				Vector3 normal = heightmap.GetNormal(val);
				if (normal.y <= 0.01f || normal.y >= 0.99f)
				{
					continue;
				}
				Vector2 val2 = Vector3Ex.XZ2D(normal);
				Vector2 normalized = ((Vector2)(ref val2)).normalized;
				Vector2 val3 = normalized;
				float num4 = 0f;
				float num5 = 0f;
				for (int i = 0; i < 300; i++)
				{
					val.x += normalized.x;
					val.z += normalized.y;
					if (Vector3.Angle(Vector2.op_Implicit(normalized), Vector2.op_Implicit(val3)) > 90f)
					{
						break;
					}
					float num6 = TerrainMeta.NormalizeX(val.x);
					float num7 = TerrainMeta.NormalizeZ(val.z);
					int topology = topologyMap.GetTopology(num6, num7);
					if ((topology & 0xB4990) != 0)
					{
						break;
					}
					float height = heightmap.GetHeight(num6, num7);
					if (height > num3 + 8f)
					{
						break;
					}
					float num8 = Mathf.Min(height, num3);
					val.y = Mathf.Lerp(val.y, num8, 0.5f);
					normal = heightmap.GetNormal(val);
					Vector2 val4 = normalized;
					val2 = Vector3Ex.XZ2D(normal);
					val2 = Vector2.Lerp(val4, ((Vector2)(ref val2)).normalized, 0.5f);
					normalized = ((Vector2)(ref val2)).normalized;
					num3 = num8;
					float num9 = 0f;
					float num10 = 0f;
					if ((topology & 0x800400) == 0)
					{
						float num11 = Vector3.Angle(Vector3.up, normal);
						num9 = Mathf.InverseLerp(5f, 15f, num11);
						num10 = 1f;
						if ((topology & 0x8000) == 0)
						{
							num10 = num9;
						}
					}
					num4 = Mathf.MoveTowards(num4, num9, 0.05f);
					num5 = Mathf.MoveTowards(num5, num10, 0.05f);
					if ((topologyMap.GetTopology(num6, num7, 10f) & 2) == 0)
					{
						int num12 = Mathf.Clamp((int)(num6 * (float)erosion_res), 0, erosion_res - 1);
						int num13 = Mathf.Clamp((int)(num7 * (float)erosion_res), 0, erosion_res - 1);
						int num14 = Mathf.Clamp((int)(num6 * (float)deposit_res), 0, deposit_res - 1);
						int num15 = Mathf.Clamp((int)(num7 * (float)deposit_res), 0, deposit_res - 1);
						erosion[num13 * erosion_res + num12] += num4;
						deposit[num15 * deposit_res + num14] += num5;
					}
				}
			}
		}
		Parallel.For(1, erosion_res - 1, (Action<int>)delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			for (int j = 1; j < erosion_res - 1; j++)
			{
				float num16 = CalculateDelta(erosion, erosion_res, j, z, 1f, 0.8f, 0.6f);
				float delta = (0f - Mathf.Lerp(0f, 0.25f, num16)) * TerrainMeta.OneOverSize.y;
				heightmap.AddHeight(j, z, delta);
			}
		});
		Parallel.For(1, deposit_res - 1, (Action<int>)delegate(int z)
		{
			for (int k = 1; k < deposit_res - 1; k++)
			{
				float splat = splatmap.GetSplat(k, z, 2);
				float splat2 = splatmap.GetSplat(k, z, 4);
				if (splat > 0.1f || splat2 > 0.1f)
				{
					float num17 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.4f, 0.2f);
					num17 = Mathf.InverseLerp(1f, 3f, num17);
					num17 = Mathf.Lerp(0f, 0.5f, num17);
					splatmap.AddSplat(k, z, 128, num17);
				}
				else
				{
					float num18 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.2f, 0.1f);
					float num19 = CalculateDelta(deposit, deposit_res, k, z, 1f, 0.8f, 0.4f);
					num18 = Mathf.InverseLerp(1f, 3f, num18);
					num19 = Mathf.InverseLerp(1f, 3f, num19);
					num18 = Mathf.Lerp(0f, 1f, num18);
					num19 = Mathf.Lerp(0f, 1f, num19);
					splatmap.AddSplat(k, z, 1, num19 * 0.5f);
					splatmap.AddSplat(k, z, 64, num18 * 0.7f);
					splatmap.AddSplat(k, z, 128, num18 * 0.5f);
				}
			}
		});
		static float CalculateDelta(float[] data, int res, int x, int z, float cntr, float side, float diag)
		{
			int num20 = x - 1;
			int num21 = x + 1;
			int num22 = z - 1;
			int num23 = z + 1;
			side /= 4f;
			diag /= 4f;
			float num24 = data[z * res + x];
			float num25 = data[z * res + num20] + data[z * res + num21] + data[num23 * res + x] + data[num23 * res + x];
			float num26 = data[num22 * res + num20] + data[num22 * res + num21] + data[num23 * res + num20] + data[num23 * res + num21];
			return cntr * num24 + side * num25 + diag * num26;
		}
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;

public struct SplatPaintingData : IDisposable
{
	public bool IsValid;

	public readonly NativeArray<float> HeightMapDelta;

	public readonly NativeArray<float> AngleMap;

	public SplatPaintingData(NativeArray<float> heightMapDelta, NativeArray<float> angleMap)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		HeightMapDelta = heightMapDelta;
		AngleMap = angleMap;
		IsValid = true;
	}

	public void Dispose()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		IsValid = false;
		if (HeightMapDelta.IsCreated)
		{
			HeightMapDelta.Dispose();
		}
		if (AngleMap.IsCreated)
		{
			AngleMap.Dispose();
		}
	}

	public void Dispose(JobHandle inputDeps)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		IsValid = false;
		if (HeightMapDelta.IsCreated)
		{
			HeightMapDelta.Dispose(inputDeps);
		}
		if (AngleMap.IsCreated)
		{
			AngleMap.Dispose(inputDeps);
		}
	}
}


using System;
using System.Collections.Generic;
using GenerateErosionJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class GenerateErosionSplat : ProceduralComponent
{
	public override void Process(uint seed)
	{
		if (!World.Networked)
		{
			Debug.Assert(GenerateErosion.splatPaintingData.IsValid, "GenerateErosion.splatPaintingData is not populated, GenerateErosion likely missing from WorldSetup");
			if (GenerateErosion.splatPaintingData.IsValid)
			{
				PaintSplat();
			}
		}
	}

	private void PaintSplat()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		Debug.Assert(GenerateErosion.splatPaintingData.HeightMapDelta.IsCreated);
		Debug.Assert(GenerateErosion.splatPaintingData.AngleMap.IsCreated);
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		NativeArray<float> heightMapDelta = GenerateErosion.splatPaintingData.HeightMapDelta;
		NativeArray<float> angleMap = GenerateErosion.splatPaintingData.AngleMap;
		int res = TerrainMeta.HeightMap.res;
		Parallel.For(1, res - 1, (Action<int>)delegate(int z)
		{
			for (int i = 1; i < res - 1; i++)
			{
				angleMap[z * res + i] = TerrainMeta.HeightMap.GetSlope(i, z);
			}
		});
		splatMap.Push();
		NativeHashMap<int, int> val = default(NativeHashMap<int, int>);
		val..ctor(splatMap.num, AllocatorHandle.op_Implicit((Allocator)3));
		foreach (var (num3, num4) in TerrainSplat.GetType2IndexDic())
		{
			val.Add(num3, num4);
		}
		JobHandle val2 = default(JobHandle);
		PaintSplatJob paintSplatJob = default(PaintSplatJob);
		paintSplatJob.HeightMapDelta = heightMapDelta.AsReadOnly();
		paintSplatJob.HeightMapRes = TerrainMeta.HeightMap.res;
		paintSplatJob.AngleMapDeg = angleMap.AsReadOnly();
		paintSplatJob.TopologyMap = TerrainMeta.TopologyMap.src.AsReadOnly();
		paintSplatJob.TopologyMapRes = TerrainMeta.TopologyMap.res;
		paintSplatJob.SplatMap = splatMap.dst;
		paintSplatJob.SplatMapRes = splatMap.res;
		paintSplatJob.SplatNum = splatMap.num;
		paintSplatJob.SplatType2Index = val.AsReadOnly();
		paintSplatJob.TerrainOneOverSizeX = TerrainMeta.OneOverSize.x;
		PaintSplatJob paintSplatJob2 = paintSplatJob;
		val2 = IJobForExtensions.ScheduleByRef<PaintSplatJob>(ref paintSplatJob2, heightMapDelta.Length, val2);
		val.Dispose(val2);
		GenerateErosion.splatPaintingData.Dispose(val2);
		((JobHandle)(ref val2)).Complete();
		splatMap.Pop();
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateHeight : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_height")]
	public unsafe static extern void Native_GenerateHeight(short* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		short* unsafePtr = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.dst);
		int res = TerrainMeta.HeightMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		Native_GenerateHeight(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class GenerateOceanTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		TerrainTopologyMap topologymap = TerrainMeta.TopologyMap;
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		NativeArray<int> dst = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = topologymap.Coordinate(i);
				float normZ = topologymap.Coordinate(z);
				int num = dst[z * res + i];
				if (heightmap.GetHeight01(normX, normZ) <= 0.5f)
				{
					if ((num & 0x810000) == 0)
					{
						dst[z * res + i] = num | 0x80;
					}
				}
				else
				{
					dst[z * res + i] = num & -129;
				}
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GeneratePowerlineLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;
	}

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		//IL_03df: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Powerlines.Clear();
			TerrainMeta.Path.Powerlines.AddRange(World.GetPaths("Powerline"));
		}
		else
		{
			if (!World.Config.Powerlines)
			{
				return;
			}
			List<PathList> list = new List<PathList>();
			List<MonumentInfo> monuments = TerrainMeta.Path.Monuments;
			int[,] array = TerrainPath.CreatePowerlineCostmap(ref seed);
			PathFinder pathFinder = new PathFinder(array);
			int length = array.GetLength(0);
			List<PathSegment> list2 = new List<PathSegment>();
			List<PathNode> list3 = new List<PathNode>();
			List<PathNode> list4 = new List<PathNode>();
			List<PathFinder.Point> list5 = new List<PathFinder.Point>();
			List<PathFinder.Point> list6 = new List<PathFinder.Point>();
			List<PathFinder.Point> list7 = new List<PathFinder.Point>();
			foreach (PathList road in TerrainMeta.Path.Roads)
			{
				if (road.ProcgenStartNode == null || road.ProcgenEndNode == null || road.Hierarchy != 0)
				{
					continue;
				}
				int num = 1;
				for (PathFinder.Node node = road.ProcgenStartNode; node != null; node = node.next)
				{
					if (num % 8 == 0)
					{
						list5.Add(node.point);
					}
					num++;
				}
			}
			foreach (MonumentInfo item in monuments)
			{
				TerrainPathConnect[] componentsInChildren = ((Component)item).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Power)
					{
						PathFinder.Point pathFinderPoint = terrainPathConnect.GetPathFinderPoint(length);
						PathFinder.Node node2 = pathFinder.FindClosestWalkable(pathFinderPoint, 100000);
						if (node2 != null)
						{
							PathNode pathNode = new PathNode();
							pathNode.monument = item;
							pathNode.node = node2;
							list4.Add(pathNode);
						}
					}
				}
			}
			while (list4.Count != 0)
			{
				list7.Clear();
				list7.AddRange(list4.Select((PathNode x) => x.node.point));
				list6.Clear();
				list6.AddRange(list3.Select((PathNode x) => x.node.point));
				list6.AddRange(list5);
				PathFinder.Node node3 = pathFinder.FindPathUndirected(list6, list7, 100000);
				if (node3 == null)
				{
					PathNode copy = list4[0];
					list3.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)copy.monument));
					list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)copy.monument);
					continue;
				}
				PathSegment segment = new PathSegment();
				for (PathFinder.Node node4 = node3; node4 != null; node4 = node4.next)
				{
					if (node4 == node3)
					{
						segment.start = node4;
					}
					if (node4.next == null)
					{
						segment.end = node4;
					}
				}
				list2.Add(segment);
				PathNode copy2 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				list3.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)copy2.monument));
				list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)copy2.monument);
				int num2 = 1;
				for (PathFinder.Node node5 = node3; node5 != null; node5 = node5.next)
				{
					if (num2 % 8 == 0)
					{
						list5.Add(node5.point);
					}
					num2++;
				}
			}
			List<Vector3> list8 = new List<Vector3>();
			foreach (PathSegment item2 in list2)
			{
				for (PathFinder.Node node6 = item2.start; node6 != null; node6 = node6.next)
				{
					float num3 = ((float)node6.point.x + 0.5f) / (float)length;
					float num4 = ((float)node6.point.y + 0.5f) / (float)length;
					float height = TerrainMeta.HeightMap.GetHeight01(num3, num4);
					list8.Add(TerrainMeta.Denormalize(new Vector3(num3, height, num4)));
				}
				if (list8.Count != 0)
				{
					if (list8.Count >= 8)
					{
						PathList pathList = new PathList("Powerline " + (TerrainMeta.Path.Powerlines.Count + list.Count), list8.ToArray());
						pathList.Start = true;
						pathList.End = true;
						pathList.ProcgenStartNode = item2.start;
						pathList.ProcgenEndNode = item2.end;
						list.Add(pathList);
					}
					list8.Clear();
				}
			}
			foreach (PathList item3 in list)
			{
				item3.Path.RecalculateTangents();
			}
			TerrainMeta.Path.Powerlines.AddRange(list);
		}
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;
}


public class GeneratePowerlineTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailBranching : ProceduralComponent
{
	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 1
		};
	}

	public override void Process(uint seed)
	{
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0466: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04df: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0513: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_0528: Unknown result type (might be due to invalid IL or missing references)
		//IL_0534: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0538: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0581: Unknown result type (might be due to invalid IL or missing references)
		//IL_0586: Unknown result type (might be due to invalid IL or missing references)
		//IL_0588: Unknown result type (might be due to invalid IL or missing references)
		//IL_058d: Unknown result type (might be due to invalid IL or missing references)
		//IL_058f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_059f: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_060d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0635: Unknown result type (might be due to invalid IL or missing references)
		//IL_063a: Unknown result type (might be due to invalid IL or missing references)
		//IL_063e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0643: Unknown result type (might be due to invalid IL or missing references)
		//IL_066f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0674: Unknown result type (might be due to invalid IL or missing references)
		//IL_067b: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			return;
		}
		int num = Mathf.RoundToInt(40f);
		int num2 = Mathf.RoundToInt(53.333332f);
		int num3 = Mathf.RoundToInt(40f);
		int num4 = Mathf.RoundToInt(120f);
		float num5 = 120f * 120f;
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				select target).ToArray();
			foreach (TerrainPathConnect terrainPathConnect in array2)
			{
				pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(((Component)terrainPathConnect).transform.position, length));
			}
		}
		if (pathFinder.PushPointsAdditional.Count > 0)
		{
			pathFinder.PushDistance = 10;
			pathFinder.PushMultiplier = int.MaxValue;
		}
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		List<Vector3> list4 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		foreach (PathList rail2 in TerrainMeta.Path.Rails)
		{
			foreach (PathList rail3 in TerrainMeta.Path.Rails)
			{
				if (rail2 == rail3)
				{
					continue;
				}
				Vector3[] points = rail2.Path.Points;
				foreach (Vector3 val in points)
				{
					Vector3[] points2 = rail3.Path.Points;
					foreach (Vector3 val2 in points2)
					{
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < num5)
						{
							hashSet.Add(val);
							break;
						}
					}
				}
			}
		}
		foreach (PathList rail4 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path = rail4.Path;
			Vector3[] points3 = path.Points;
			Vector3[] tangents = path.Tangents;
			int num6 = path.MinIndex + 1 + 8;
			int num7 = path.MaxIndex - 1 - 8;
			for (int l = num6; l <= num7; l++)
			{
				list2.Clear();
				list3.Clear();
				list4.Clear();
				int num8 = SeedRandom.Range(ref seed, num3, num4);
				int num9 = SeedRandom.Range(ref seed, num, num2);
				int num10 = l;
				int num11 = l + num8;
				if (num11 >= num7)
				{
					continue;
				}
				Vector3 val4 = tangents[num10];
				Vector3 val5 = tangents[num11];
				if (Vector3.Angle(val4, val5) > 30f)
				{
					continue;
				}
				Vector3 val6 = points3[num10];
				Vector3 val7 = points3[num11];
				if (hashSet.Contains(val6) || hashSet.Contains(val7))
				{
					continue;
				}
				PathFinder.Point point = PathFinder.GetPoint(val6, length);
				PathFinder.Point point2 = PathFinder.GetPoint(val7, length);
				l += num9;
				PathFinder.Node node = pathFinder.FindPath(point, point2, 250000);
				if (node == null)
				{
					continue;
				}
				PathFinder.Node node2 = null;
				PathFinder.Node node3 = null;
				PathFinder.Node node4 = node;
				while (node4 != null && node4.next != null)
				{
					if (node4 == node.next)
					{
						node2 = node4;
					}
					if (node4.next.next == null)
					{
						node3 = node4;
					}
					node4 = node4.next;
				}
				if (node2 == null || node3 == null)
				{
					continue;
				}
				node = node2;
				node3.next = null;
				for (int m = 0; m < 8; m++)
				{
					int num12 = num10 + (m + 1 - 8);
					int num13 = num11 + m;
					list2.Add(points3[num12]);
					list3.Add(points3[num13]);
				}
				list4.AddRange(list2);
				for (PathFinder.Node node5 = node2; node5 != null; node5 = node5.next)
				{
					float normX = ((float)node5.point.x + 0.5f) / (float)length;
					float normZ = ((float)node5.point.y + 0.5f) / (float)length;
					float num14 = TerrainMeta.DenormalizeX(normX);
					float num15 = TerrainMeta.DenormalizeZ(normZ);
					float num16 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
					list4.Add(new Vector3(num14, num16, num15));
				}
				list4.AddRange(list3);
				int num17 = 8;
				int num18 = list4.Count - 1 - 8;
				Vector3 val8 = Vector3.Normalize(list4[num17 + 16] - list4[num17]);
				Vector3 val9 = Vector3.Normalize(list4[num18] - list4[num18 - 16]);
				Vector3 val10 = Vector3.Normalize(points3[num10 + 16] - points3[num10]);
				Vector3 val11 = Vector3.Normalize(points3[num11] - points3[(num11 - 16 + points3.Length) % points3.Length]);
				float num19 = Vector3.SignedAngle(val10, val8, Vector3.up);
				float num20 = 0f - Vector3.SignedAngle(val11, val9, Vector3.up);
				if (Mathf.Sign(num19) != Mathf.Sign(num20) || Mathf.Abs(num19) > 60f || Mathf.Abs(num20) > 60f)
				{
					continue;
				}
				Vector3 val12 = rot90 * val10;
				Vector3 val13 = rot90 * val11;
				if (num19 < 0f)
				{
					val12 = -val12;
				}
				if (num20 < 0f)
				{
					val13 = -val13;
				}
				for (int n = 0; n < 16; n++)
				{
					int num21 = n;
					int num22 = list4.Count - n - 1;
					float num23 = Mathf.InverseLerp(0f, 8f, (float)n);
					float num24 = Mathf.SmoothStep(0f, 2f, num23) * 4f;
					List<Vector3> list5 = list4;
					int j = num21;
					list5[j] += val12 * num24;
					list5 = list4;
					j = num22;
					list5[j] += val13 * num24;
				}
				bool flag = false;
				bool flag2 = false;
				foreach (Vector3 item in list4)
				{
					bool blocked = TerrainMeta.PlacementMap.GetBlocked(item);
					if (!flag2 && !flag && !blocked)
					{
						flag = true;
					}
					if (flag && !flag2 && blocked)
					{
						flag2 = true;
					}
					if (flag && flag2 && !blocked)
					{
						list4.Clear();
						break;
					}
				}
				if (list4.Count != 0)
				{
					if (list4.Count >= 2)
					{
						int number = TerrainMeta.Path.Rails.Count + list.Count;
						PathList pathList = CreateSegment(number, list4.ToArray());
						pathList.Start = false;
						pathList.End = false;
						pathList.ProcgenStartNode = node2;
						pathList.ProcgenEndNode = node3;
						list.Add(pathList);
					}
					l += num8;
				}
			}
		}
		foreach (PathList rail in list)
		{
			Func<int, float> filter = delegate(int i)
			{
				float num25 = Mathf.InverseLerp(0f, 8f, (float)i);
				float num26 = Mathf.InverseLerp((float)rail.Path.DefaultMaxIndex, (float)(rail.Path.DefaultMaxIndex - 8), (float)i);
				return Mathf.SmoothStep(0f, 1f, Mathf.Min(num25, num26));
			};
			rail.Path.Smoothen(32, new Vector3(1f, 0f, 1f), filter);
			rail.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter);
			rail.Path.Resample(7.5f);
			rail.Path.RecalculateTangents();
			rail.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 1
		};
	}

	public override void Process(uint seed)
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_0313: Unknown result type (might be due to invalid IL or missing references)
		//IL_031a: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0506: Unknown result type (might be due to invalid IL or missing references)
		//IL_0508: Unknown result type (might be due to invalid IL or missing references)
		//IL_050a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0511: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06be: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_079c: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_084a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0858: Unknown result type (might be due to invalid IL or missing references)
		//IL_085d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0862: Unknown result type (might be due to invalid IL or missing references)
		//IL_0867: Unknown result type (might be due to invalid IL or missing references)
		//IL_0869: Unknown result type (might be due to invalid IL or missing references)
		//IL_086e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0870: Unknown result type (might be due to invalid IL or missing references)
		//IL_0875: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0800: Unknown result type (might be due to invalid IL or missing references)
		//IL_0807: Unknown result type (might be due to invalid IL or missing references)
		//IL_0809: Unknown result type (might be due to invalid IL or missing references)
		//IL_080e: Unknown result type (might be due to invalid IL or missing references)
		//IL_072b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0731: Unknown result type (might be due to invalid IL or missing references)
		//IL_0886: Unknown result type (might be due to invalid IL or missing references)
		//IL_089f: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_08cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0912: Unknown result type (might be due to invalid IL or missing references)
		//IL_0917: Unknown result type (might be due to invalid IL or missing references)
		//IL_091b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0920: Unknown result type (might be due to invalid IL or missing references)
		//IL_09d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0a02: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Rails.Clear();
			TerrainMeta.Path.Rails.AddRange(World.GetPaths("Rail"));
			{
				foreach (PathList rail in TerrainMeta.Path.Rails)
				{
					Func<int, float> filter = delegate(int i)
					{
						float num = Mathf.InverseLerp(0f, 8f, (float)i);
						float num2 = Mathf.InverseLerp((float)rail.Path.DefaultMaxIndex, (float)(rail.Path.DefaultMaxIndex - 8), (float)i);
						return Mathf.SmoothStep(0f, 1f, Mathf.Min(num, num2));
					};
					Vector3[] points = rail.Path.Points;
					for (int j = 1; j < points.Length - 1; j++)
					{
						Vector3 val = points[j];
						val.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(val), 1f);
						points[j] = val;
					}
					rail.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter);
					rail.Path.RecalculateTangents();
				}
				return;
			}
		}
		if (!World.Config.AboveGroundRails)
		{
			return;
		}
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		PathFinder pathFinder2 = new PathFinder(array);
		int length = array.GetLength(0);
		new List<PathSegment>();
		List<PathFinder.Point> list2 = new List<PathFinder.Point>();
		List<PathFinder.Point> list3 = new List<PathFinder.Point>();
		List<PathFinder.Point> list4 = new List<PathFinder.Point>();
		List<Vector3> list5 = new List<Vector3>();
		foreach (PathList rail3 in TerrainMeta.Path.Rails)
		{
			for (PathFinder.Node node = rail3.ProcgenStartNode; node != null; node = node.next)
			{
				list2.Add(node.point);
			}
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			pathFinder.PushPoint = monument.GetPathFinderPoint(length);
			pathFinder.PushRadius = (pathFinder.PushDistance = monument.GetPathFinderRadius(length));
			pathFinder.PushMultiplier = 50000;
			int num3 = int.MaxValue;
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				orderby DistanceToRail(((Component)target).transform.position)
				select target).ToArray();
			TerrainPathConnect[] array3 = array2;
			foreach (TerrainPathConnect terrainPathConnect in array3)
			{
				pathFinder.PushPointsAdditional.Clear();
				pathFinder.BlockedPointsAdditional.Clear();
				Vector3 val2 = ((Component)terrainPathConnect).transform.position;
				TerrainPathConnect[] array4 = array2;
				foreach (TerrainPathConnect terrainPathConnect2 in array4)
				{
					if (!((Object)(object)terrainPathConnect == (Object)(object)terrainPathConnect2))
					{
						Vector3 position = ((Component)terrainPathConnect2).transform.position;
						PathFinder.Point point = PathFinder.GetPoint(((Component)terrainPathConnect2).transform.position, length);
						pathFinder.PushPointsAdditional.Add(point);
						val2 += position;
					}
				}
				val2 /= (float)array2.Length;
				Vector3 val3;
				if (array2.Length <= 1)
				{
					val3 = ((Component)terrainPathConnect).transform.forward;
				}
				else
				{
					Vector3 val4 = ((Component)terrainPathConnect).transform.position - val2;
					val3 = ((Vector3)(ref val4)).normalized;
				}
				Vector3 val5 = val3;
				foreach (PathList item in list)
				{
					pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(item.Path.GetEndPoint(), length));
					PathFinder.Point point2 = PathFinder.GetPoint(item.Path.GetStartPoint(), length);
					Vector3[] points2 = item.Path.Points;
					for (int l = 0; l < points2.Length; l++)
					{
						PathFinder.Point point3 = PathFinder.GetPoint(points2[l], length);
						pathFinder.BlockedPointsAdditional.Add(point3);
						pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point3.x, point2.y));
						pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point2.x, point3.y));
						point2 = point3;
					}
					if (item.ProcgenStartNode != null)
					{
						PathFinder.Point point4 = item.ProcgenStartNode.point;
						for (PathFinder.Node node2 = item.ProcgenStartNode; node2 != null; node2 = node2.next)
						{
							PathFinder.Point point5 = node2.point;
							pathFinder.BlockedPointsAdditional.Add(point5);
							pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point5.x, point4.y));
							pathFinder.BlockedPointsAdditional.Add(new PathFinder.Point(point4.x, point5.y));
							point4 = point5;
						}
					}
				}
				list5.Clear();
				Vector3 val6 = ((Component)terrainPathConnect).transform.position;
				Vector3 val7 = ((Component)terrainPathConnect).transform.forward * 7.5f;
				PathFinder.Point point6 = PathFinder.GetPoint(val6, length);
				for (int m = 0; (m < 8 && pathFinder.Heuristic(point6, list2) > 1) || (m < 16 && !pathFinder.IsWalkable(point6)); m++)
				{
					list5.Add(val6);
					val6 += val7;
					point6 = PathFinder.GetPoint(val6, length);
				}
				if (!pathFinder.IsWalkable(point6))
				{
					continue;
				}
				list3.Clear();
				list3.Add(point6);
				list4.Clear();
				list4.AddRange(list2);
				PathFinder.Node node3 = pathFinder.FindPathDirected(list3, list4, 250000);
				bool flag = false;
				if (node3 == null && list.Count > 0 && num3 != int.MaxValue)
				{
					PathList pathList = list[list.Count - 1];
					list4.Clear();
					for (int n = 0; n < pathList.Path.Points.Length; n++)
					{
						list4.Add(PathFinder.GetPoint(pathList.Path.Points[n], length));
					}
					node3 = pathFinder2.FindPathDirected(list3, list4, 250000);
					flag = true;
				}
				if (node3 == null)
				{
					continue;
				}
				PathFinder.Node node4 = null;
				PathFinder.Node node5 = null;
				PathFinder.Node node6 = node3;
				while (node6 != null && node6.next != null)
				{
					if (node6 == node3.next)
					{
						node4 = node6;
					}
					if (node6.next.next == null)
					{
						node5 = node6;
						node5.next = null;
					}
					node6 = node6.next;
				}
				for (PathFinder.Node node7 = node4; node7 != null; node7 = node7.next)
				{
					float normX = ((float)node7.point.x + 0.5f) / (float)length;
					float normZ = ((float)node7.point.y + 0.5f) / (float)length;
					float num4 = TerrainMeta.DenormalizeX(normX);
					float num5 = TerrainMeta.DenormalizeZ(normZ);
					float num6 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
					list5.Add(new Vector3(num4, num6, num5));
				}
				Vector3 val8 = list5[list5.Count - 1];
				Vector3 val9 = val5;
				PathList pathList2 = null;
				float num7 = float.MaxValue;
				int num8 = -1;
				if (!flag)
				{
					foreach (PathList rail4 in TerrainMeta.Path.Rails)
					{
						Vector3[] points3 = rail4.Path.Points;
						for (int num9 = 0; num9 < points3.Length; num9++)
						{
							float num10 = Vector3.Distance(val8, points3[num9]);
							if (num10 < num7)
							{
								num7 = num10;
								pathList2 = rail4;
								num8 = num9;
							}
						}
					}
				}
				else
				{
					foreach (PathList item2 in list)
					{
						Vector3[] points4 = item2.Path.Points;
						for (int num11 = 0; num11 < points4.Length; num11++)
						{
							float num12 = Vector3.Distance(val8, points4[num11]);
							if (num12 < num7)
							{
								num7 = num12;
								pathList2 = item2;
								num8 = num11;
							}
						}
					}
				}
				int num13 = 1;
				if (!flag)
				{
					Vector3 tangentByIndex = pathList2.Path.GetTangentByIndex(num8);
					num13 = ((Vector3.Angle(tangentByIndex, val9) < Vector3.Angle(-tangentByIndex, val9)) ? 1 : (-1));
					if (num3 != int.MaxValue)
					{
						GenericsUtil.Swap<int>(ref num3, ref num13);
						num13 = -num13;
					}
					else
					{
						num3 = num13;
					}
				}
				Vector3 val10 = Vector3.Normalize(pathList2.Path.GetPointByIndex(num8 + num13 * 8 * 2) - pathList2.Path.GetPointByIndex(num8));
				Vector3 val11 = rot90 * val10;
				if (!flag)
				{
					Vector3 val12 = Vector3.Normalize(list5[list5.Count - 1] - list5[Mathf.Max(0, list5.Count - 1 - 16)]);
					if (0f - Vector3.SignedAngle(val10, val12, Vector3.up) < 0f)
					{
						val11 = -val11;
					}
				}
				for (int num14 = 0; num14 < 8; num14++)
				{
					float num15 = Mathf.InverseLerp(7f, 0f, (float)num14);
					float num16 = Mathf.SmoothStep(0f, 2f, num15) * 4f;
					list5.Add(pathList2.Path.GetPointByIndex(num8 + num13 * num14) + val11 * num16);
				}
				if (list5.Count >= 2)
				{
					int number = TerrainMeta.Path.Rails.Count + list.Count;
					PathList rail2 = CreateSegment(number, list5.ToArray());
					rail2.Start = true;
					rail2.End = false;
					rail2.ProcgenStartNode = node4;
					rail2.ProcgenEndNode = node5;
					Func<int, float> filter2 = delegate(int i)
					{
						float num17 = Mathf.InverseLerp(0f, 8f, (float)i);
						float num18 = Mathf.InverseLerp((float)rail2.Path.DefaultMaxIndex, (float)(rail2.Path.DefaultMaxIndex - 8), (float)i);
						return Mathf.SmoothStep(0f, 1f, Mathf.Min(num17, num18));
					};
					rail2.Path.Smoothen(32, new Vector3(1f, 0f, 1f), filter2);
					rail2.Path.Smoothen(64, new Vector3(0f, 1f, 0f), filter2);
					rail2.Path.Resample(7.5f);
					rail2.Path.RecalculateTangents();
					list.Add(rail2);
				}
			}
		}
		foreach (PathList item3 in list)
		{
			item3.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
		static float DistanceToRail(Vector3 vec)
		{
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			float num19 = float.MaxValue;
			foreach (PathList rail5 in TerrainMeta.Path.Rails)
			{
				Vector3[] points5 = rail5.Path.Points;
				foreach (Vector3 val13 in points5)
				{
					num19 = Mathf.Min(num19, Vector3Ex.Magnitude2D(vec - val13));
				}
			}
			return num19;
		}
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public TerrainPathConnect target;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;

	public TerrainPathConnect origin;

	public TerrainPathConnect target;
}


using UnityEngine;

public class GenerateRailMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0f;

	public const bool SnapToTerrain = false;

	public Mesh RailMesh;

	public Mesh[] RailMeshes;

	public Material RailMaterial;

	public PhysicMaterial RailPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Expected O, but got Unknown
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		if (RailMeshes == null || RailMeshes.Length == 0)
		{
			RailMeshes = (Mesh[])(object)new Mesh[1] { RailMesh };
		}
		foreach (PathList rail in TerrainMeta.Path.Rails)
		{
			foreach (PathList.MeshObject item in rail.CreateMesh(RailMeshes, 0f, snapToTerrain: false, !rail.Path.Circular && !rail.Start, !rail.Path.Circular && !rail.End))
			{
				GameObject val = new GameObject("Rail Mesh");
				val.transform.position = item.Position;
				val.tag = "Railway";
				val.layer = 16;
				GameObjectEx.SetHierarchyGroup(val, rail.Name);
				val.SetActive(false);
				MeshCollider obj = val.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RailPhysicMaterial;
				obj.sharedMesh = item.Meshes[0];
				val.AddComponent<AddToHeightMap>();
				val.SetActive(true);
			}
			AddTrackSpline(rail);
		}
	}

	private void AddTrackSpline(PathList rail)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline trainTrackSpline = HierarchyUtil.GetRoot(rail.Name).AddComponent<TrainTrackSpline>();
		trainTrackSpline.aboveGroundSpawn = rail.Hierarchy == 2;
		trainTrackSpline.hierarchy = rail.Hierarchy;
		if (trainTrackSpline.aboveGroundSpawn)
		{
			TrainTrackSpline.SidingSplines.Add(trainTrackSpline);
		}
		Vector3[] array = (Vector3[])(object)new Vector3[rail.Path.Points.Length];
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = rail.Path.Points[i];
			array[i].y += 0.41f;
		}
		Vector3[] array2 = (Vector3[])(object)new Vector3[rail.Path.Tangents.Length];
		for (int j = 0; j < array.Length; j++)
		{
			array2[j] = rail.Path.Tangents[j];
		}
		trainTrackSpline.SetAll(array, array2, 0.25f);
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRailRing : ProceduralComponent
{
	private class RingNode
	{
		public int attempts;

		public PathFinder.Point position;

		public PathFinder.Point direction;

		public RingNode next;

		public RingNode prev;

		public PathFinder.Node path;

		public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
		{
			position = new PathFinder.Point(pos_x, pos_y);
			direction = new PathFinder.Point(dir_x, dir_y);
			attempts = stepcount;
		}
	}

	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 250000;

	public int MinWorldSize;

	public override void Process(uint seed)
	{
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_082c: Unknown result type (might be due to invalid IL or missing references)
		//IL_093a: Unknown result type (might be due to invalid IL or missing references)
		//IL_095d: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked || World.Size < MinWorldSize || !World.Config.AboveGroundRails)
		{
			return;
		}
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		int num = length / 4;
		int num2 = 1;
		int stepcount = num / num2;
		int num3 = length / 2;
		int pos_x = num;
		int pos_x2 = length - num;
		int pos_y = num;
		int pos_y2 = length - num;
		int num4 = 0;
		int dir_x = -num2;
		int dir_x2 = num2;
		int dir_y = -num2;
		int dir_y2 = num2;
		List<RingNode> list = ((World.Size >= 5000) ? new List<RingNode>
		{
			new RingNode(num3, pos_y2, num4, dir_y, stepcount),
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, num3, dir_x, num4, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(num3, pos_y, num4, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, num3, dir_x2, num4, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		} : new List<RingNode>
		{
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		});
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			TerrainPathConnect[] array2 = (from target in ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true)
				where target.Type == InfrastructureType.Rail
				select target).ToArray();
			foreach (TerrainPathConnect terrainPathConnect in array2)
			{
				pathFinder.PushPointsAdditional.Add(PathFinder.GetPoint(((Component)terrainPathConnect).transform.position, length));
			}
		}
		if (pathFinder.PushPointsAdditional.Count > 0)
		{
			pathFinder.PushDistance = 10;
			pathFinder.PushMultiplier = int.MaxValue;
		}
		for (int j = 0; j < list.Count; j++)
		{
			RingNode ringNode = list[j];
			RingNode next = list[(j + 1) % list.Count];
			RingNode prev = list[(j - 1 + list.Count) % list.Count];
			ringNode.next = next;
			ringNode.prev = prev;
			while (!pathFinder.IsWalkableWithNeighbours(ringNode.position))
			{
				if (ringNode.attempts <= 0)
				{
					return;
				}
				ringNode.position += ringNode.direction;
				ringNode.attempts--;
			}
		}
		foreach (RingNode item in list)
		{
			item.path = pathFinder.FindPath(item.position, item.next.position, 250000);
		}
		bool flag = false;
		while (!flag)
		{
			flag = true;
			PathFinder.Point point = new PathFinder.Point(0, 0);
			foreach (RingNode item2 in list)
			{
				point += item2.position;
			}
			point /= list.Count;
			float num5 = float.MinValue;
			RingNode ringNode2 = null;
			foreach (RingNode item3 in list)
			{
				if (item3.path == null)
				{
					Vector2 val = new Vector2((float)(item3.position.x - point.x), (float)(item3.position.y - point.y));
					float num6 = ((Vector2)(ref val)).magnitude;
					if (item3.prev.path == null)
					{
						num6 *= 1.5f;
					}
					if (num6 > num5)
					{
						num5 = num6;
						ringNode2 = item3;
					}
				}
			}
			if (ringNode2 == null)
			{
				continue;
			}
			do
			{
				if (ringNode2.attempts <= 0)
				{
					return;
				}
				ringNode2.position += ringNode2.direction;
				ringNode2.attempts--;
			}
			while (!pathFinder.IsWalkableWithNeighbours(ringNode2.position));
			ringNode2.path = pathFinder.FindPath(ringNode2.position, ringNode2.next.position, 250000);
			ringNode2.prev.path = pathFinder.FindPath(ringNode2.prev.position, ringNode2.position, 250000);
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		for (int k = 0; k < list.Count; k++)
		{
			RingNode ringNode3 = list[k];
			RingNode ringNode4 = list[(k + 1) % list.Count];
			PathFinder.Node node = null;
			PathFinder.Node node2 = null;
			for (PathFinder.Node node3 = ringNode3.path; node3 != null; node3 = node3.next)
			{
				for (PathFinder.Node node4 = ringNode4.path; node4 != null; node4 = node4.next)
				{
					int num7 = Mathf.Abs(node3.point.x - node4.point.x);
					int num8 = Mathf.Abs(node3.point.y - node4.point.y);
					if (num7 <= 15 && num8 <= 15)
					{
						if (node == null || node3.cost > node.cost)
						{
							node = node3;
						}
						if (node2 == null || node4.cost < node2.cost)
						{
							node2 = node4;
						}
					}
				}
			}
			if (node != null && node2 != null)
			{
				PathFinder.Node node5 = pathFinder.FindPath(node.point, node2.point, 250000);
				if (node5 != null && node5.next != null)
				{
					node.next = node5.next;
					ringNode4.path = node2;
				}
			}
		}
		for (int l = 0; l < list.Count; l++)
		{
			RingNode ringNode5 = list[l];
			RingNode ringNode6 = list[(l + 1) % list.Count];
			PathFinder.Node node6 = null;
			PathFinder.Node node7 = null;
			for (PathFinder.Node node8 = ringNode5.path; node8 != null; node8 = node8.next)
			{
				for (PathFinder.Node node9 = ringNode6.path; node9 != null; node9 = node9.next)
				{
					int num9 = Mathf.Abs(node8.point.x - node9.point.x);
					int num10 = Mathf.Abs(node8.point.y - node9.point.y);
					if (num9 <= 1 && num10 <= 1)
					{
						if (node6 == null || node8.cost > node6.cost)
						{
							node6 = node8;
						}
						if (node7 == null || node9.cost < node7.cost)
						{
							node7 = node9;
						}
					}
				}
			}
			if (node6 != null && node7 != null)
			{
				node6.next = null;
				ringNode6.path = node7;
			}
		}
		PathFinder.Node node10 = null;
		PathFinder.Node node11 = null;
		foreach (RingNode item4 in list)
		{
			if (node10 == null)
			{
				node10 = item4.path;
				node11 = item4.path;
			}
			else
			{
				node11.next = item4.path;
			}
			while (node11.next != null)
			{
				node11 = node11.next;
			}
		}
		node11.next = new PathFinder.Node(node10.point, node10.cost, node10.heuristic);
		List<Vector3> list2 = new List<Vector3>();
		for (PathFinder.Node node12 = node10; node12 != null; node12 = node12.next)
		{
			float normX = ((float)node12.point.x + 0.5f) / (float)length;
			float normZ = ((float)node12.point.y + 0.5f) / (float)length;
			float num11 = TerrainMeta.DenormalizeX(normX);
			float num12 = TerrainMeta.DenormalizeZ(normZ);
			float num13 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
			list2.Add(new Vector3(num11, num13, num12));
		}
		if (list2.Count >= 2)
		{
			PathList pathList = new PathList("Rail " + TerrainMeta.Path.Rails.Count, list2.ToArray());
			pathList.Spline = true;
			pathList.Width = 4f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 32f;
			pathList.RandomScale = 1f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 524288;
			pathList.Splat = 128;
			pathList.Start = false;
			pathList.End = false;
			pathList.ProcgenStartNode = node10;
			pathList.ProcgenEndNode = node11;
			pathList.Path.Smoothen(32, new Vector3(1f, 0f, 1f));
			pathList.Path.Smoothen(64, new Vector3(0f, 1f, 0f));
			pathList.Path.Resample(7.5f);
			pathList.Path.RecalculateTangents();
			pathList.AdjustPlacementMap(20f);
			TerrainMeta.Path.Rails.Add(pathList);
		}
	}
}


private class RingNode
{
	public int attempts;

	public PathFinder.Point position;

	public PathFinder.Point direction;

	public RingNode next;

	public RingNode prev;

	public PathFinder.Node path;

	public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
	{
		position = new PathFinder.Point(pos_x, pos_y);
		direction = new PathFinder.Point(dir_x, dir_y);
		attempts = stepcount;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRailSiding : ProceduralComponent
{
	public const float Width = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 32f;

	public const float RandomScale = 1f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private static Quaternion rotRight = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rotLeft = Quaternion.Euler(0f, -90f, 0f);

	private const int MaxDepth = 250000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		return new PathList("Rail " + number, points)
		{
			Spline = true,
			Width = 4f,
			InnerPadding = 1f,
			OuterPadding = 1f,
			InnerFade = 1f,
			OuterFade = 32f,
			RandomScale = 1f,
			MeshOffset = 0f,
			TerrainOffset = -0.125f,
			Topology = 524288,
			Splat = 128,
			Hierarchy = 2
		};
	}

	public override void Process(uint seed)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_026a: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0271: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_031e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03be: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			return;
		}
		int num = Mathf.RoundToInt(40f);
		int num2 = Mathf.RoundToInt(53.333332f);
		int num3 = Mathf.RoundToInt(13.333333f);
		int num4 = Mathf.RoundToInt(20f);
		float num5 = 16f * 16f;
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRailCostmap(ref seed);
		new PathFinder(array);
		array.GetLength(0);
		List<Vector3> list2 = new List<Vector3>();
		List<Vector3> list3 = new List<Vector3>();
		HashSet<Vector3> hashSet = new HashSet<Vector3>();
		foreach (PathList rail in TerrainMeta.Path.Rails)
		{
			foreach (PathList rail2 in TerrainMeta.Path.Rails)
			{
				if (rail == rail2)
				{
					continue;
				}
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					Vector3[] points2 = rail2.Path.Points;
					foreach (Vector3 val2 in points2)
					{
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < num5)
						{
							hashSet.Add(val);
							break;
						}
					}
				}
			}
		}
		foreach (PathList rail3 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path = rail3.Path;
			Vector3[] points3 = path.Points;
			Vector3[] tangents = path.Tangents;
			int num6 = path.MinIndex + 1 + 16;
			int num7 = path.MaxIndex - 1 - 16;
			for (int k = num6; k <= num7; k++)
			{
				list2.Clear();
				list3.Clear();
				int num8 = SeedRandom.Range(ref seed, num3, num4);
				int num9 = SeedRandom.Range(ref seed, num, num2);
				int num10 = k;
				int num11 = k + num8;
				if (num11 >= num7)
				{
					continue;
				}
				Vector3 val4 = tangents[num10];
				Vector3 val5 = tangents[num11];
				if (Vector3.Angle(val4, val5) > 30f)
				{
					continue;
				}
				Vector3 val6 = tangents[num10];
				Vector3 val7 = tangents[num11];
				Vector3 val8 = Vector3.Normalize(points3[num10 + 8] - points3[num10]);
				Vector3 val9 = Vector3.Normalize(points3[num11] - points3[num11 - 8]);
				float num12 = Vector3.SignedAngle(val8, val6, Vector3.up);
				float num13 = 0f - Vector3.SignedAngle(val9, val7, Vector3.up);
				if (Mathf.Sign(num12) != Mathf.Sign(num13) || Mathf.Abs(num12) > 60f || Mathf.Abs(num13) > 60f)
				{
					continue;
				}
				float num14 = 5f;
				Quaternion val10 = ((num12 > 0f) ? rotRight : rotLeft);
				for (int l = num10 - 8; l <= num11 + 8; l++)
				{
					Vector3 val11 = points3[l];
					if (hashSet.Contains(val11))
					{
						list2.Clear();
						list3.Clear();
						break;
					}
					Vector3 val12 = tangents[l];
					Vector3 val13 = val10 * val12;
					if (l < num10 + 8)
					{
						float num15 = Mathf.InverseLerp((float)(num10 - 8), (float)num10, (float)l);
						float num16 = Mathf.SmoothStep(0f, 1f, num15) * num14;
						val11 += val13 * num16;
					}
					else if (l > num11 - 8)
					{
						float num17 = Mathf.InverseLerp((float)(num11 + 8), (float)num11, (float)l);
						float num18 = Mathf.SmoothStep(0f, 1f, num17) * num14;
						val11 += val13 * num18;
					}
					else
					{
						val11 += val13 * num14;
					}
					list2.Add(val11);
					list3.Add(val12);
				}
				if (list2.Count >= 2)
				{
					int number = TerrainMeta.Path.Rails.Count + list.Count;
					PathList pathList = CreateSegment(number, list2.ToArray());
					pathList.Start = false;
					pathList.End = false;
					list.Add(pathList);
					k += num8;
				}
				k += num9;
			}
		}
		foreach (PathList item in list)
		{
			item.Path.Resample(7.5f);
			item.Path.RecalculateTangents();
			item.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.Rails.AddRange(list);
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRailTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 8;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 64;

	public const int SmoothenXZ = 32;

	public const int TransitionSteps = 8;

	private float AdjustTerrainFade(float xn, float zn)
	{
		int topology = TerrainMeta.TopologyMap.GetTopology(xn, zn);
		if ((topology & 0x4000) != 0)
		{
			return 0f;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.5f;
		}
		return 1f;
	}

	private float SmoothenFilter(PathList path, int index)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		float num = (path.Start ? Mathf.SmoothStep(0f, 1f, Mathf.InverseLerp(0f, 8f, (float)index)) : 1f);
		int topology = TerrainMeta.TopologyMap.GetTopology(path.Path.Points[index]);
		if ((topology & 0x4000) != 0)
		{
			return 0.1f * num;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.3f * num;
		}
		return num;
	}

	public override void Process(uint seed)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		for (int j = 0; j < 8; j++)
		{
			foreach (PathList rail in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				PathInterpolator path = rail.Path;
				Vector3[] points = path.Points;
				for (int k = 0; k < points.Length; k++)
				{
					Vector3 val = points[k];
					float num = heightMap.GetHeight(val);
					if ((topologyMap.GetTopology(val) & 0xC000) != 0)
					{
						num = Mathf.Max(num, WaterLevel.RaycastWaterColliders(val) + 2f);
					}
					if (rail.Start)
					{
						val.y = Mathf.SmoothStep(val.y, num, SmoothenFilter(rail, k));
					}
					else
					{
						val.y = num;
					}
					points[k] = val;
				}
				path.Smoothen(8, Vector3.up, (int i) => SmoothenFilter(rail, i));
				path.RecalculateTangents();
			}
			foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fademin = 0.125f;
				float fademax = Mathf.InverseLerp(8f, 0f, (float)j);
				item.AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => Mathf.Lerp(fademin, fademax, AdjustTerrainFade(xn, zn)));
				heightMap.Pop();
			}
		}
		foreach (PathList rail2 in TerrainMeta.Path.Rails)
		{
			PathInterpolator path2 = rail2.Path;
			Vector3[] points2 = path2.Points;
			for (int l = 0; l < points2.Length; l++)
			{
				Vector3 val2 = points2[l];
				float height = heightMap.GetHeight(val2);
				if (rail2.Start)
				{
					val2.y = Mathf.SmoothStep(val2.y, height, SmoothenFilter(rail2, l));
				}
				else
				{
					val2.y = height;
				}
				points2[l] = val2;
			}
			path2.RecalculateTangents();
		}
	}
}


using System.Linq;

public class GenerateRailTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture();
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRailTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology();
		}
		MarkRailside();
		TerrainMeta.PlacementMap.Reset();
	}

	private void MarkRailside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 1572864, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x100000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverLayout : ProceduralComponent
{
	public const float Width = 8f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 16f;

	public const float OuterFade = 64f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = -0.5f;

	public const float TerrainOffset = -1.5f;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0687: Unknown result type (might be due to invalid IL or missing references)
		//IL_0714: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_076d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0772: Unknown result type (might be due to invalid IL or missing references)
		//IL_09bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_09de: Unknown result type (might be due to invalid IL or missing references)
		//IL_080c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0811: Unknown result type (might be due to invalid IL or missing references)
		//IL_078b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0790: Unknown result type (might be due to invalid IL or missing references)
		//IL_0792: Unknown result type (might be due to invalid IL or missing references)
		//IL_0794: Unknown result type (might be due to invalid IL or missing references)
		//IL_0796: Unknown result type (might be due to invalid IL or missing references)
		//IL_079b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_08aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_028c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_02af: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0415: Unknown result type (might be due to invalid IL or missing references)
		//IL_0425: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0443: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044f: Unknown result type (might be due to invalid IL or missing references)
		//IL_045b: Unknown result type (might be due to invalid IL or missing references)
		//IL_045d: Unknown result type (might be due to invalid IL or missing references)
		//IL_045f: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_046f: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048b: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_049b: Unknown result type (might be due to invalid IL or missing references)
		//IL_049d: Unknown result type (might be due to invalid IL or missing references)
		//IL_049f: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05df: Unknown result type (might be due to invalid IL or missing references)
		//IL_060f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0611: Unknown result type (might be due to invalid IL or missing references)
		//IL_0616: Unknown result type (might be due to invalid IL or missing references)
		//IL_0618: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0626: Unknown result type (might be due to invalid IL or missing references)
		//IL_0628: Unknown result type (might be due to invalid IL or missing references)
		//IL_062a: Unknown result type (might be due to invalid IL or missing references)
		//IL_062f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0633: Unknown result type (might be due to invalid IL or missing references)
		//IL_063d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0642: Unknown result type (might be due to invalid IL or missing references)
		//IL_0646: Unknown result type (might be due to invalid IL or missing references)
		//IL_064b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0607: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Rivers.Clear();
			TerrainMeta.Path.Rivers.AddRange(World.GetPaths("River"));
		}
		else
		{
			if (!World.Config.Rivers)
			{
				return;
			}
			List<PathList> list = new List<PathList>();
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
			TerrainBiomeMap biomeMap = TerrainMeta.BiomeMap;
			List<Vector3> list2 = new List<Vector3>();
			int num = 3;
			if (World.Size <= 4000)
			{
				num = 2;
			}
			Vector3[] array = (Vector3[])(object)new Vector3[4]
			{
				new Vector3(-1f, 0f, -1f),
				new Vector3(-1f, 0f, 1f),
				new Vector3(1f, 0f, -1f),
				new Vector3(1f, 0f, 1f)
			};
			Vector3 val2 = default(Vector3);
			Line val6 = default(Line);
			Vector3 val8 = default(Vector3);
			for (float num2 = TerrainMeta.Center.z + 250f; num2 < TerrainMeta.Max.z - 750f; num2 += 5f)
			{
				for (float num3 = TerrainMeta.Center.x + 250f; num3 < TerrainMeta.Max.x - 750f; num3 += 5f)
				{
					Vector3[] array2 = array;
					foreach (Vector3 val in array2)
					{
						((Vector3)(ref val2))..ctor(val.x * num3, 0f, val.z * num2);
						float num4 = (val2.y = heightMap.GetHeight(val2));
						if (val2.y <= 15f)
						{
							continue;
						}
						Vector3 normal = heightMap.GetNormal(val2);
						if (normal.y <= 0.01f || normal.y >= 0.99f)
						{
							continue;
						}
						bool flag = false;
						foreach (PathList item in list)
						{
							Vector3[] points = item.Path.Points;
							foreach (Vector3 val3 in points)
							{
								if (Vector3Ex.SqrMagnitude2D(val2 - val3) < 67600f)
								{
									flag = true;
									break;
								}
							}
							if (flag)
							{
								break;
							}
						}
						if (flag)
						{
							continue;
						}
						Vector2 val4 = Vector3Ex.XZ2D(normal);
						Vector2 normalized = ((Vector2)(ref val4)).normalized;
						float num5 = Vector3.Angle(Vector3.up, normal);
						list2.Add(val2);
						float baseRadius = 4f;
						int num6 = 0;
						for (int k = 0; k < 5000; k++)
						{
							int num7 = k * 4;
							Vector2 val5 = Vector2Ex.Rotate(normalized, Mathf.Sin((float)num7 * (MathF.PI / 180f) * 0.5f) * Mathf.InverseLerp(30f, 10f, num5) * 60f);
							val2.x += val5.x * 4f;
							val2.z += val5.y * 4f;
							bool flag2 = false;
							for (int l = 0; l < list2.Count - 10; l++)
							{
								((Line)(ref val6))..ctor(list2[l], list2[l + 1]);
								Vector3 val7 = ((Line)(ref val6)).ClosestPoint(val2);
								if (Vector3Ex.SqrMagnitude2D(val2 - val7) < 16900f)
								{
									flag2 = true;
									break;
								}
							}
							if (flag2)
							{
								break;
							}
							float height = heightMap.GetHeight(val2);
							if (height > num4 + 32f)
							{
								break;
							}
							float num8 = Mathf.Min(height, num4);
							float num9 = Mathf.Lerp(0.15f, 0.95f, Mathf.InverseLerp(10f, 0f, num8));
							val2.y = Mathf.Lerp(val2.y, num8, num9);
							float radius = PathList.GetRadius(num7, 0f, baseRadius, 0.75f, scaleWidthWithLength: true);
							float radius2 = PathList.GetRadius(num7, num7, baseRadius, 0.75f, scaleWidthWithLength: true);
							int num10 = Mathf.RoundToInt(radius2 / 4f);
							((Vector3)(ref val8))..ctor(val5.x, 0f, val5.y);
							Vector3 val9 = val8 * (radius * 1.5f);
							Vector3 val10 = val8 * (radius2 + 1f + 64f);
							Vector3 val11 = rot90 * val8;
							Vector3 val12 = val11 * (radius * 1.5f);
							Vector3 val13 = val11 * (radius2 + 1f + 64f);
							int topology = topologyMap.GetTopology(val2, radius + 1f + 64f);
							int num11 = topologyMap.GetTopology(val2) & topologyMap.GetTopology(val2 - val9) & topologyMap.GetTopology(val2 + val9) & topologyMap.GetTopology(val2 + val10) & topologyMap.GetTopology(val2 - val12) & topologyMap.GetTopology(val2 - val13) & topologyMap.GetTopology(val2 + val12) & topologyMap.GetTopology(val2 + val13);
							int topology2 = topologyMap.GetTopology(val2);
							int num12 = 3742724;
							int num13 = 128;
							int num14 = 128;
							if ((topology & num12) != 0)
							{
								break;
							}
							if ((num11 & num13) != 0)
							{
								list2.Add(val2);
								if (list2.Count >= 62)
								{
									PathList pathList = new PathList("River " + (TerrainMeta.Path.Rivers.Count + list.Count), list2.ToArray());
									pathList.Spline = true;
									pathList.Width = 8f;
									pathList.InnerPadding = 1f;
									pathList.OuterPadding = 1f;
									pathList.InnerFade = 16f;
									pathList.OuterFade = 64f;
									pathList.RandomScale = 0.75f;
									pathList.MeshOffset = -0.5f;
									pathList.TerrainOffset = -1.5f;
									pathList.Topology = 16384;
									pathList.Splat = 128;
									pathList.Start = true;
									pathList.End = true;
									list.Add(pathList);
								}
								break;
							}
							if ((topology2 & num14) != 0 || val2.y < 0f)
							{
								if (num6++ >= num10)
								{
									break;
								}
							}
							else if (num6 > 0)
							{
								break;
							}
							if (k % 4 == 0)
							{
								list2.Add(val2);
							}
							normal = heightMap.GetNormal(val2);
							num5 = Vector3.Angle(Vector3.up, normal);
							Vector2 val14 = normalized;
							val4 = Vector3Ex.XZ2D(normal);
							val4 = Vector2.Lerp(val14, ((Vector2)(ref val4)).normalized, 0.025f);
							normalized = ((Vector2)(ref val4)).normalized;
							num4 = num8;
						}
						list2.Clear();
					}
				}
			}
			list.Sort((PathList a, PathList b) => b.Path.Points.Length.CompareTo(a.Path.Points.Length));
			int num15 = (int)(World.Size / 16);
			bool[,] array3 = new bool[num15, num15];
			int num16 = 0;
			for (int m = 0; m < list.Count; m++)
			{
				PathList pathList2 = list[m];
				bool flag3 = biomeMap.GetBiomeMaxType(pathList2.Path.GetEndPoint()) == 16;
				if (num16 >= num && !flag3)
				{
					list.RemoveAt(m--);
					continue;
				}
				bool flag4 = false;
				for (int n = 0; n < m; n++)
				{
					PathList pathList3 = list[n];
					Vector3[] array2 = pathList2.Path.Points;
					foreach (Vector3 val15 in array2)
					{
						Vector3[] points = pathList3.Path.Points;
						foreach (Vector3 val16 in points)
						{
							Vector3 val17 = val15 - val16;
							if (((Vector3)(ref val17)).sqrMagnitude < 67600f)
							{
								list.RemoveAt(m--);
								flag4 = true;
							}
							if (flag4)
							{
								break;
							}
						}
						if (flag4)
						{
							break;
						}
					}
					if (flag4)
					{
						break;
					}
				}
				if (flag4)
				{
					continue;
				}
				for (int num17 = 0; num17 < pathList2.Path.Points.Length; num17++)
				{
					Vector3 val18 = pathList2.Path.Points[num17];
					int num18 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(val18.x) * (float)num15), 0, num15 - 1);
					int num19 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(val18.z) * (float)num15), 0, num15 - 1);
					if (array3[num19, num18])
					{
						list.RemoveAt(m--);
						flag4 = true;
						break;
					}
				}
				if (flag4)
				{
					continue;
				}
				int num20 = -1;
				int num21 = -1;
				for (int num22 = 0; num22 < pathList2.Path.Points.Length; num22++)
				{
					Vector3 val19 = pathList2.Path.Points[num22];
					int num23 = Mathf.Clamp((int)(TerrainMeta.NormalizeX(val19.x) * (float)num15), 0, num15 - 1);
					int num24 = Mathf.Clamp((int)(TerrainMeta.NormalizeZ(val19.z) * (float)num15), 0, num15 - 1);
					if (num20 != -1)
					{
						array3[num24, num20] = true;
					}
					if (num21 != -1)
					{
						array3[num21, num23] = true;
					}
					array3[num24, num23] = true;
					num20 = num23;
					num21 = num24;
				}
				if (!flag3)
				{
					num16++;
				}
			}
			for (int num25 = 0; num25 < list.Count; num25++)
			{
				list[num25].Name = "River " + (TerrainMeta.Path.Rivers.Count + num25);
			}
			foreach (PathList item2 in list)
			{
				item2.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
				item2.Path.Smoothen(8, new Vector3(0f, 1f, 0f));
				item2.Path.Resample(7.5f);
				item2.Path.RecalculateTangents();
			}
			TerrainMeta.Path.Rivers.AddRange(list);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRiverMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0.1f;

	public const bool SnapToTerrain = false;

	public Mesh RiverMesh;

	public Mesh RiverInteriorMesh;

	public Mesh RiverInteriorFrontCapMesh;

	public Mesh RiverInteriorBackCapMesh;

	public Mesh[] RiverMeshes;

	public Material RiverMaterial;

	public PhysicMaterial RiverPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Expected O, but got Unknown
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		RiverMeshes = (Mesh[])(object)new Mesh[1] { RiverMesh };
		foreach (PathList river in TerrainMeta.Path.Rivers)
		{
			List<PathList.MeshObject> list = river.CreateMesh(RiverMeshes, 0.1f, snapToTerrain: false, !river.Path.Circular, !river.Path.Circular, scaleWidthWithLength: true, topAligned: false, 4);
			for (int i = 0; i < list.Count; i++)
			{
				PathList.MeshObject meshObject = list[i];
				GameObject val = new GameObject("River Mesh");
				val.transform.position = meshObject.Position;
				val.tag = "River";
				val.layer = 4;
				GameObjectEx.SetHierarchyGroup(val, river.Name);
				val.SetActive(false);
				MeshCollider obj = val.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RiverPhysicMaterial;
				obj.sharedMesh = meshObject.Meshes[0];
				val.AddComponent<RiverInfo>();
				WaterBody waterBody = val.AddComponent<WaterBody>();
				waterBody.Type = WaterBodyType.River;
				waterBody.FishingType = WaterBody.FishingTag.River;
				val.AddComponent<AddToWaterMap>();
				val.SetActive(true);
			}
		}
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRiverTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 1;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 8;

	public const int SmoothenXZ = 4;

	public override void Process(uint seed)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		for (int i = 0; i < 1; i++)
		{
			foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
			{
				if (!World.Networked)
				{
					PathInterpolator path = item.Path;
					path.Smoothen(8, Vector3.up);
					path.RecalculateTangents();
				}
			}
			foreach (PathList item2 in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fade = Mathf.InverseLerp(1f, 0f, (float)i);
				item2.AdjustTerrainHeight(intensity, fade, scaleWidthWithLength: true);
				heightMap.Pop();
			}
		}
	}
}


using System.Linq;

public class GenerateRiverTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture(scaleWidthWithLength: true);
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRiverTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Rivers.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology(scaleWidthWithLength: true);
		}
		MarkRiverside();
	}

	public void MarkRiverside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 49152, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x8000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateRoadLayout : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public TerrainPathConnect target;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;

		public TerrainPathConnect origin;

		public TerrainPathConnect target;
	}

	public InfrastructureType RoadType;

	public const float RoadWidth = 10f;

	public const float TrailWidth = 4f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 100000;

	private PathList CreateSegment(int number, Vector3[] points)
	{
		PathList pathList = new PathList("Road " + number, points);
		if (RoadType == InfrastructureType.Road)
		{
			pathList.Spline = true;
			pathList.Width = 10f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 128;
			pathList.Hierarchy = 1;
		}
		else
		{
			float num = 0.4f;
			pathList.Spline = true;
			pathList.Width = 4f;
			pathList.InnerPadding = 1f * num;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 1;
			pathList.Hierarchy = 2;
		}
		return pathList;
	}

	public override void Process(uint seed)
	{
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0833: Unknown result type (might be due to invalid IL or missing references)
		//IL_0778: Unknown result type (might be due to invalid IL or missing references)
		//IL_0795: Unknown result type (might be due to invalid IL or missing references)
		//IL_0909: Unknown result type (might be due to invalid IL or missing references)
		//IL_092b: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ee: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			TerrainMeta.Path.Roads.Clear();
			TerrainMeta.Path.Roads.AddRange(World.GetPaths("Road"));
			TerrainMeta.Path.AddRoad(TerrainMeta.Path.Roads, addToMaster: false);
			{
				foreach (PathList road in TerrainMeta.Path.Roads)
				{
					Vector3[] points = road.Path.Points;
					for (int i = 1; i < points.Length - 1; i++)
					{
						Vector3 val = points[i];
						val.y = Mathf.Max(TerrainMeta.HeightMap.GetHeight(val), 1f);
						points[i] = val;
					}
					road.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
					road.Path.RecalculateTangents();
				}
				return;
			}
		}
		if ((RoadType == InfrastructureType.Road && !World.Config.SideRoads) || (RoadType == InfrastructureType.Trail && !World.Config.Trails))
		{
			return;
		}
		List<PathList> list = new List<PathList>();
		int[,] array = TerrainPath.CreateRoadCostmap(ref seed, RoadType == InfrastructureType.Trail);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		List<PathSegment> list2 = new List<PathSegment>();
		List<PathNode> list3 = new List<PathNode>();
		List<PathNode> list4 = new List<PathNode>();
		List<PathNode> list5 = new List<PathNode>();
		List<PathFinder.Point> list6 = new List<PathFinder.Point>();
		List<PathFinder.Point> list7 = new List<PathFinder.Point>();
		List<PathFinder.Point> list8 = new List<PathFinder.Point>();
		foreach (PathList road2 in TerrainMeta.Path.Roads)
		{
			if (road2.ProcgenStartNode == null || road2.ProcgenEndNode == null)
			{
				continue;
			}
			int num = 1;
			for (PathFinder.Node node = road2.ProcgenStartNode; node != null; node = node.next)
			{
				if (num % 8 == 0)
				{
					list6.Add(node.point);
				}
				num++;
			}
		}
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.Type == MonumentType.Roadside)
			{
				continue;
			}
			TerrainPathConnect[] componentsInChildren = ((Component)monument).GetComponentsInChildren<TerrainPathConnect>(true);
			foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
			{
				if (terrainPathConnect.Type == RoadType)
				{
					PathFinder.Point pathFinderPoint = terrainPathConnect.GetPathFinderPoint(length);
					PathFinder.Node node2 = pathFinder.FindClosestWalkable(pathFinderPoint, 100000);
					if (node2 != null)
					{
						PathNode pathNode = new PathNode();
						pathNode.monument = monument;
						pathNode.target = terrainPathConnect;
						pathNode.node = node2;
						list4.Add(pathNode);
					}
				}
			}
		}
		while (list4.Count != 0 || list5.Count != 0)
		{
			if (list4.Count == 0)
			{
				PathNode node3 = list5[0];
				list4.AddRange(list5.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument));
				list5.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument);
				pathFinder.PushPoint = node3.monument.GetPathFinderPoint(length);
				pathFinder.PushRadius = (pathFinder.PushDistance = node3.monument.GetPathFinderRadius(length));
				pathFinder.PushMultiplier = 50000;
			}
			list8.Clear();
			list8.AddRange(list4.Select((PathNode x) => x.node.point));
			list7.Clear();
			list7.AddRange(list3.Select((PathNode x) => x.node.point));
			list7.AddRange(list5.Select((PathNode x) => x.node.point));
			list7.AddRange(list6);
			PathFinder.Node node4 = pathFinder.FindPathUndirected(list7, list8, 100000);
			if (node4 == null)
			{
				PathNode node5 = list4[0];
				list5.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument));
				list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument);
				list5.Remove(node5);
				list3.Add(node5);
				continue;
			}
			PathSegment segment = new PathSegment();
			for (PathFinder.Node node6 = node4; node6 != null; node6 = node6.next)
			{
				if (node6 == node4)
				{
					segment.start = node6;
				}
				if (node6.next == null)
				{
					segment.end = node6;
				}
			}
			list2.Add(segment);
			PathNode node7 = list4.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			list5.AddRange(list4.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node7.monument));
			list4.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node7.monument);
			list5.Remove(node7);
			list3.Add(node7);
			PathNode pathNode2 = list5.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
			if (pathNode2 != null)
			{
				list5.Remove(pathNode2);
				list3.Add(pathNode2);
			}
			int num2 = 1;
			for (PathFinder.Node node8 = node4; node8 != null; node8 = node8.next)
			{
				if (num2 % 8 == 0)
				{
					list6.Add(node8.point);
				}
				num2++;
			}
		}
		foreach (PathNode target in list3)
		{
			PathSegment pathSegment = list2.Find((PathSegment x) => x.start.point == target.node.point || x.end.point == target.node.point);
			if (pathSegment != null)
			{
				if (pathSegment.start.point == target.node.point)
				{
					PathFinder.Node node9 = target.node;
					PathFinder.Node start = pathFinder.Reverse(target.node);
					node9.next = pathSegment.start;
					pathSegment.start = start;
					pathSegment.origin = target.target;
				}
				else if (pathSegment.end.point == target.node.point)
				{
					pathSegment.end.next = target.node;
					pathSegment.end = pathFinder.FindEnd(target.node);
					pathSegment.target = target.target;
				}
			}
		}
		List<Vector3> list9 = new List<Vector3>();
		foreach (PathSegment item in list2)
		{
			bool start2 = false;
			bool end = false;
			for (PathFinder.Node node10 = item.start; node10 != null; node10 = node10.next)
			{
				float normX = ((float)node10.point.x + 0.5f) / (float)length;
				float normZ = ((float)node10.point.y + 0.5f) / (float)length;
				if (item.start == node10 && (Object)(object)item.origin != (Object)null)
				{
					start2 = true;
					normX = TerrainMeta.NormalizeX(((Component)item.origin).transform.position.x);
					normZ = TerrainMeta.NormalizeZ(((Component)item.origin).transform.position.z);
				}
				else if (item.end == node10 && (Object)(object)item.target != (Object)null)
				{
					end = true;
					normX = TerrainMeta.NormalizeX(((Component)item.target).transform.position.x);
					normZ = TerrainMeta.NormalizeZ(((Component)item.target).transform.position.z);
				}
				float num3 = TerrainMeta.DenormalizeX(normX);
				float num4 = TerrainMeta.DenormalizeZ(normZ);
				float num5 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
				list9.Add(new Vector3(num3, num5, num4));
			}
			if (list9.Count != 0)
			{
				if (list9.Count >= 2)
				{
					int number = TerrainMeta.Path.Roads.Count + list.Count;
					PathList pathList = CreateSegment(number, list9.ToArray());
					pathList.Start = start2;
					pathList.End = end;
					pathList.ProcgenStartNode = item.start;
					pathList.ProcgenEndNode = item.end;
					list.Add(pathList);
				}
				list9.Clear();
			}
		}
		foreach (PathList item2 in list)
		{
			item2.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
			item2.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
			item2.Path.Resample(7.5f);
			item2.Path.RecalculateTangents();
			item2.AdjustPlacementMap(20f);
		}
		TerrainMeta.Path.AddRoad(list);
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public TerrainPathConnect target;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;

	public TerrainPathConnect origin;

	public TerrainPathConnect target;
}


using UnityEngine;

public class GenerateRoadMeshes : ProceduralComponent
{
	public const float NormalSmoothing = 0f;

	public const bool SnapToTerrain = true;

	public Mesh RoadMesh;

	public Mesh[] RoadMeshes;

	public Material RoadMaterial;

	public Material RoadRingMaterial;

	public PhysicMaterial RoadPhysicMaterial;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Expected O, but got Unknown
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Expected O, but got Unknown
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		if (RoadMeshes == null || RoadMeshes.Length == 0)
		{
			RoadMeshes = (Mesh[])(object)new Mesh[1] { RoadMesh };
		}
		foreach (PathList road in TerrainMeta.Path.Roads)
		{
			if (road.Hierarchy >= 2)
			{
				continue;
			}
			foreach (PathList.MeshObject item in road.CreateMesh(RoadMeshes, 0f, snapToTerrain: true, !road.Path.Circular, !road.Path.Circular))
			{
				GameObject val = new GameObject("Road Mesh");
				val.transform.position = item.Position;
				val.layer = 16;
				val.tag = "IgnoreCollider";
				GameObjectEx.SetHierarchyGroup(val, road.Name);
				val.SetActive(false);
				MeshCollider obj = val.AddComponent<MeshCollider>();
				((Collider)obj).sharedMaterial = RoadPhysicMaterial;
				obj.sharedMesh = item.Meshes[0];
				TagComponentEx.SetCustomTag(val, GameObjectTag.Road, apply: true);
				val.AddComponent<AddToHeightMap>();
				val.SetActive(true);
			}
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class GenerateRoadRing : ProceduralComponent
{
	private class RingNode
	{
		public int attempts;

		public PathFinder.Point position;

		public PathFinder.Point direction;

		public RingNode next;

		public RingNode prev;

		public PathFinder.Node path;

		public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
		{
			position = new PathFinder.Point(pos_x, pos_y);
			direction = new PathFinder.Point(dir_x, dir_y);
			attempts = stepcount;
		}
	}

	public const float Width = 12f;

	public const float InnerPadding = 1f;

	public const float OuterPadding = 1f;

	public const float InnerFade = 1f;

	public const float OuterFade = 8f;

	public const float RandomScale = 0.75f;

	public const float MeshOffset = 0f;

	public const float TerrainOffset = -0.125f;

	private const int MaxDepth = 250000;

	public int MinWorldSize;

	public override void Process(uint seed)
	{
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0771: Unknown result type (might be due to invalid IL or missing references)
		//IL_087e: Unknown result type (might be due to invalid IL or missing references)
		//IL_08a1: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked || World.Size < MinWorldSize || !World.Config.MainRoads)
		{
			return;
		}
		int[,] array = TerrainPath.CreateRoadCostmap(ref seed);
		PathFinder pathFinder = new PathFinder(array);
		int length = array.GetLength(0);
		int num = length / 4;
		int num2 = 1;
		int stepcount = num / num2;
		int num3 = length / 2;
		int pos_x = num;
		int pos_x2 = length - num;
		int pos_y = num;
		int pos_y2 = length - num;
		int num4 = 0;
		int dir_x = -num2;
		int dir_x2 = num2;
		int dir_y = -num2;
		int dir_y2 = num2;
		List<RingNode> list = ((World.Size >= 5000) ? new List<RingNode>
		{
			new RingNode(num3, pos_y2, num4, dir_y, stepcount),
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, num3, dir_x, num4, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(num3, pos_y, num4, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, num3, dir_x2, num4, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		} : new List<RingNode>
		{
			new RingNode(pos_x2, pos_y2, dir_x, dir_y, stepcount),
			new RingNode(pos_x2, pos_y, dir_x, dir_y2, stepcount),
			new RingNode(pos_x, pos_y, dir_x2, dir_y2, stepcount),
			new RingNode(pos_x, pos_y2, dir_x2, dir_y, stepcount)
		});
		for (int i = 0; i < list.Count; i++)
		{
			RingNode ringNode = list[i];
			RingNode next = list[(i + 1) % list.Count];
			RingNode prev = list[(i - 1 + list.Count) % list.Count];
			ringNode.next = next;
			ringNode.prev = prev;
			while (!pathFinder.IsWalkable(ringNode.position))
			{
				if (ringNode.attempts <= 0)
				{
					return;
				}
				ringNode.position += ringNode.direction;
				ringNode.attempts--;
			}
		}
		foreach (RingNode item in list)
		{
			item.path = pathFinder.FindPath(item.position, item.next.position, 250000);
		}
		bool flag = false;
		while (!flag)
		{
			flag = true;
			PathFinder.Point point = new PathFinder.Point(0, 0);
			foreach (RingNode item2 in list)
			{
				point += item2.position;
			}
			point /= list.Count;
			float num5 = float.MinValue;
			RingNode ringNode2 = null;
			foreach (RingNode item3 in list)
			{
				if (item3.path == null)
				{
					Vector2 val = new Vector2((float)(item3.position.x - point.x), (float)(item3.position.y - point.y));
					float num6 = ((Vector2)(ref val)).magnitude;
					if (item3.prev.path == null)
					{
						num6 *= 1.5f;
					}
					if (num6 > num5)
					{
						num5 = num6;
						ringNode2 = item3;
					}
				}
			}
			if (ringNode2 == null)
			{
				continue;
			}
			do
			{
				if (ringNode2.attempts <= 0)
				{
					return;
				}
				ringNode2.position += ringNode2.direction;
				ringNode2.attempts--;
			}
			while (!pathFinder.IsWalkable(ringNode2.position));
			ringNode2.path = pathFinder.FindPath(ringNode2.position, ringNode2.next.position, 250000);
			ringNode2.prev.path = pathFinder.FindPath(ringNode2.prev.position, ringNode2.position, 250000);
			flag = false;
		}
		if (!flag)
		{
			return;
		}
		for (int j = 0; j < list.Count; j++)
		{
			RingNode ringNode3 = list[j];
			RingNode ringNode4 = list[(j + 1) % list.Count];
			PathFinder.Node node = null;
			PathFinder.Node node2 = null;
			for (PathFinder.Node node3 = ringNode3.path; node3 != null; node3 = node3.next)
			{
				for (PathFinder.Node node4 = ringNode4.path; node4 != null; node4 = node4.next)
				{
					int num7 = Mathf.Abs(node3.point.x - node4.point.x);
					int num8 = Mathf.Abs(node3.point.y - node4.point.y);
					if (num7 <= 15 && num8 <= 15)
					{
						if (node == null || node3.cost > node.cost)
						{
							node = node3;
						}
						if (node2 == null || node4.cost < node2.cost)
						{
							node2 = node4;
						}
					}
				}
			}
			if (node != null && node2 != null)
			{
				PathFinder.Node node5 = pathFinder.FindPath(node.point, node2.point, 250000);
				if (node5 != null && node5.next != null)
				{
					node.next = node5.next;
					ringNode4.path = node2;
				}
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			RingNode ringNode5 = list[k];
			RingNode ringNode6 = list[(k + 1) % list.Count];
			PathFinder.Node node6 = null;
			PathFinder.Node node7 = null;
			for (PathFinder.Node node8 = ringNode5.path; node8 != null; node8 = node8.next)
			{
				for (PathFinder.Node node9 = ringNode6.path; node9 != null; node9 = node9.next)
				{
					int num9 = Mathf.Abs(node8.point.x - node9.point.x);
					int num10 = Mathf.Abs(node8.point.y - node9.point.y);
					if (num9 <= 1 && num10 <= 1)
					{
						if (node6 == null || node8.cost > node6.cost)
						{
							node6 = node8;
						}
						if (node7 == null || node9.cost < node7.cost)
						{
							node7 = node9;
						}
					}
				}
			}
			if (node6 != null && node7 != null)
			{
				node6.next = null;
				ringNode6.path = node7;
			}
		}
		PathFinder.Node node10 = null;
		PathFinder.Node node11 = null;
		foreach (RingNode item4 in list)
		{
			if (node10 == null)
			{
				node10 = item4.path;
				node11 = item4.path;
			}
			else
			{
				node11.next = item4.path;
			}
			while (node11.next != null)
			{
				node11 = node11.next;
			}
		}
		node11.next = new PathFinder.Node(node10.point, node10.cost, node10.heuristic);
		List<Vector3> list2 = new List<Vector3>();
		for (PathFinder.Node node12 = node10; node12 != null; node12 = node12.next)
		{
			float normX = ((float)node12.point.x + 0.5f) / (float)length;
			float normZ = ((float)node12.point.y + 0.5f) / (float)length;
			float num11 = TerrainMeta.DenormalizeX(normX);
			float num12 = TerrainMeta.DenormalizeZ(normZ);
			float num13 = Mathf.Max(TerrainMeta.HeightMap.GetHeight(normX, normZ), 1f);
			list2.Add(new Vector3(num11, num13, num12));
		}
		if (list2.Count >= 2)
		{
			PathList pathList = new PathList("Road " + TerrainMeta.Path.Roads.Count, list2.ToArray());
			pathList.Spline = true;
			pathList.Width = 12f;
			pathList.InnerPadding = 1f;
			pathList.OuterPadding = 1f;
			pathList.InnerFade = 1f;
			pathList.OuterFade = 8f;
			pathList.RandomScale = 0.75f;
			pathList.MeshOffset = 0f;
			pathList.TerrainOffset = -0.125f;
			pathList.Topology = 2048;
			pathList.Splat = 128;
			pathList.Start = false;
			pathList.End = false;
			pathList.ProcgenStartNode = node10;
			pathList.ProcgenEndNode = node11;
			pathList.Path.Smoothen(4, new Vector3(1f, 0f, 1f));
			pathList.Path.Smoothen(16, new Vector3(0f, 1f, 0f));
			pathList.Path.Resample(7.5f);
			pathList.Path.RecalculateTangents();
			pathList.AdjustPlacementMap(24f);
			TerrainMeta.Path.AddRoad(pathList);
		}
	}
}


private class RingNode
{
	public int attempts;

	public PathFinder.Point position;

	public PathFinder.Point direction;

	public RingNode next;

	public RingNode prev;

	public PathFinder.Node path;

	public RingNode(int pos_x, int pos_y, int dir_x, int dir_y, int stepcount)
	{
		position = new PathFinder.Point(pos_x, pos_y);
		direction = new PathFinder.Point(dir_x, dir_y);
		attempts = stepcount;
	}
}


using System.Linq;
using UnityEngine;

public class GenerateRoadTerrain : ProceduralComponent
{
	public const int SmoothenLoops = 2;

	public const int SmoothenIterations = 8;

	public const int SmoothenY = 16;

	public const int SmoothenXZ = 4;

	private float SmoothenFilter(PathList path, int index)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		int topology = TerrainMeta.TopologyMap.GetTopology(path.Path.Points[index]);
		if ((topology & 0x80400) != 0)
		{
			return 0f;
		}
		if ((topology & 0x100000) != 0)
		{
			return 0.5f;
		}
		if ((topology & 0x4000) != 0)
		{
			return 0.1f;
		}
		if ((topology & 0x8000) != 0)
		{
			return 0.3f;
		}
		return 1f;
	}

	public override void Process(uint seed)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_0229: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		for (int j = 0; j < 2; j++)
		{
			foreach (PathList road in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
			{
				PathInterpolator path = road.Path;
				Vector3[] points = path.Points;
				for (int k = 0; k < points.Length; k++)
				{
					Vector3 val = points[k];
					float num = heightMap.GetHeight(val);
					if ((topologyMap.GetTopology(val) & 0xC000) != 0)
					{
						num = Mathf.Max(num, WaterLevel.RaycastWaterColliders(val) + 2f);
					}
					val.y = num;
					points[k] = val;
				}
				path.Smoothen(8, Vector3.up, (int i) => SmoothenFilter(road, i));
				path.RecalculateTangents();
			}
			foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity = 1f;
				float fade = Mathf.InverseLerp(2f, 0f, (float)j);
				item.AdjustTerrainHeight(intensity, fade);
				heightMap.Pop();
			}
			foreach (PathList item2 in TerrainMeta.Path.Rails.AsEnumerable().Reverse())
			{
				heightMap.Push();
				float intensity2 = 1f;
				float num2 = Mathf.InverseLerp(2f, 0f, (float)j);
				item2.AdjustTerrainHeight(intensity2, num2 / 4f);
				heightMap.Pop();
			}
		}
		foreach (PathList road2 in TerrainMeta.Path.Roads)
		{
			PathInterpolator path2 = road2.Path;
			Vector3[] points2 = path2.Points;
			for (int l = 0; l < points2.Length; l++)
			{
				Vector3 val2 = points2[l];
				val2.y = heightMap.GetHeight(val2);
				points2[l] = val2;
			}
			path2.RecalculateTangents();
		}
	}
}


using System.Linq;

public class GenerateRoadTexture : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTexture();
		}
	}
}


using System.Linq;
using Unity.Collections;

public class GenerateRoadTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		foreach (PathList item in TerrainMeta.Path.Roads.AsEnumerable().Reverse())
		{
			item.AdjustTerrainTopology();
		}
		MarkRoadside();
		TerrainMeta.PlacementMap.Reset();
	}

	private void MarkRoadside()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		NativeArray<int> map = topomap.dst;
		int res = topomap.res;
		ImageProcessing.Dilate2D(map, res, res, 6144, 6, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x31) != 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x1000;
			}
			float normX = topomap.Coordinate(x);
			float normZ = topomap.Coordinate(y);
			if (heightmap.GetSlope(normX, normZ) > 40f)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 2;
			}
		});
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateSplat : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_splat")]
	public unsafe static extern void Native_GenerateSplat(byte* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float biomeAngle, short* heightmap, int heightres, byte* biomemap, int biomeres, int* topologymap, int topologyres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		byte* unsafePtr = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.SplatMap.dst);
		int res = TerrainMeta.SplatMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		byte* unsafePtr3 = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.src);
		int res3 = TerrainMeta.BiomeMap.res;
		int* unsafePtr4 = (int*)NativeArrayUnsafeUtility.GetUnsafePtr<int>(TerrainMeta.TopologyMap.src);
		int res4 = TerrainMeta.TopologyMap.res;
		Native_GenerateSplat(unsafePtr, res, position, size, seed, lootAxisAngle, biomeAxisAngle, unsafePtr2, res2, unsafePtr3, res3, unsafePtr4, res4);
	}
}


public class GenerateTerrainMesh : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		if (!World.Cached)
		{
			World.AddMap("terrain", TerrainMeta.HeightMap.ToByteArray());
		}
		TerrainMeta.HeightMap.ApplyToTerrain();
	}
}


public class GenerateTextures : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		if (!World.Cached)
		{
			World.AddMap("height", TerrainMeta.HeightMap.ToByteArray());
			World.AddMap("splat", TerrainMeta.SplatMap.ToByteArray());
			World.AddMap("biome", TerrainMeta.BiomeMap.ToByteArray());
			World.AddMap("topology", TerrainMeta.TopologyMap.ToByteArray());
			World.AddMap("alpha", TerrainMeta.AlphaMap.ToByteArray());
			World.AddMap("water", TerrainMeta.WaterMap.ToByteArray());
		}
		else
		{
			TerrainMeta.HeightMap.FromByteArray(World.GetMap("height"));
		}
	}
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateTopology : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_topology")]
	public unsafe static extern void Native_GenerateTopology(int* map, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, short* heightmap, int heightres, byte* biomemap, int biomeres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		int* unsafePtr = (int*)NativeArrayUnsafeUtility.GetUnsafePtr<int>(TerrainMeta.TopologyMap.dst);
		int res = TerrainMeta.TopologyMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		byte* unsafePtr3 = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.src);
		int res3 = TerrainMeta.BiomeMap.res;
		Native_GenerateTopology(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic, unsafePtr2, res2, unsafePtr3, res3);
	}
}


public class GenerateWireMeshes : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		TerrainMeta.Path.CreateWires();
	}
}


using System;

public class PlaceCliffParameters : PrefabAttribute
{
	public int CutoffSlopeInitial = 10;

	public int CutoffSlopeRepeat = 10;

	public int MinTerrainHeight;

	public int MaxTerrainHeight = 500;

	public int MinCliffHeight;

	public int MaxCliffHeight = 500;

	public float MinCliffScale = 1f;

	public float MaxCliffScale = 2f;

	protected override Type GetIndexedType()
	{
		return typeof(PlaceCliffParameters);
	}
}


using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceCliffs : ProceduralComponent
{
	private class CliffPlacement
	{
		public int count;

		public int score;

		public Prefab prefab;

		public Vector3 pos = Vector3.zero;

		public Quaternion rot = Quaternion.identity;

		public Vector3 scale = Vector3.one;

		public CliffPlacement next;
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int RetryMultiplier = 1;

	[FormerlySerializedAs("CutoffSlope")]
	public int CutoffSlopeInitial = 10;

	public int CutoffSlopeRepeat = 10;

	[FormerlySerializedAs("MinHeight")]
	public int MinTerrainHeight;

	[FormerlySerializedAs("MaxHeight")]
	public int MaxTerrainHeight = 500;

	public int MinCliffHeight;

	public int MaxCliffHeight = 500;

	[FormerlySerializedAs("MinScale")]
	public float MinCliffScale = 1f;

	[FormerlySerializedAs("MaxScale")]
	public float MaxCliffScale = 2f;

	public int TargetCount = 8;

	public int TargetLength;

	public TerrainAnchorMode AnchorModeInitial = TerrainAnchorMode.MaximizeHeight;

	public TerrainAnchorMode AnchorModeRepeat = TerrainAnchorMode.MinimizeMovement;

	[InspectorFlags]
	public SpawnFilterMode FilterModeInitial = SpawnFilterMode.PivotPoint;

	[InspectorFlags]
	public SpawnFilterMode FilterModeRepeat = SpawnFilterMode.PivotPoint;

	private static float min_scale_delta = 0.1f;

	private static int max_scale_attempts = 10;

	private static int min_rotation = rotation_delta;

	private static int max_rotation = 60;

	private static int rotation_delta = 10;

	private static float offset_c = 0f;

	private static float offset_l = -0.75f;

	private static float offset_r = 0.75f;

	private static Vector3[] offsets = (Vector3[])(object)new Vector3[5]
	{
		new Vector3(offset_c, offset_c, offset_c),
		new Vector3(offset_l, offset_c, offset_c),
		new Vector3(offset_r, offset_c, offset_c),
		new Vector3(offset_c, offset_c, offset_l),
		new Vector3(offset_c, offset_c, offset_r)
	};

	public override void Process(uint seed)
	{
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_0304: Unknown result type (might be due to invalid IL or missing references)
		//IL_0312: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0336: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_03dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03de: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0404: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_041c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_043a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		//IL_0477: Unknown result type (might be due to invalid IL or missing references)
		//IL_047e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0485: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Prefab[] array2 = array.Where((Prefab prefab) => (bool)prefab.Attribute.Find<DecorSocketMale>(prefab.ID) && (bool)prefab.Attribute.Find<DecorSocketFemale>(prefab.ID)).ToArray();
		if (array2 == null || array2.Length == 0)
		{
			return;
		}
		Prefab[] array3 = array.Where((Prefab prefab) => prefab.Attribute.Find<DecorSocketMale>(prefab.ID)).ToArray();
		if (array3 == null || array3.Length == 0)
		{
			return;
		}
		Prefab[] array4 = array.Where((Prefab prefab) => prefab.Attribute.Find<DecorSocketFemale>(prefab.ID)).ToArray();
		if (array4 == null || array4.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		int num3 = Mathf.RoundToInt(size.x * size.z * 0.001f * (float)RetryMultiplier);
		Vector3 val = default(Vector3);
		for (int i = 0; i < num3; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num);
			float num5 = SeedRandom.Range(ref seed, z, num2);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			Prefab random = array2.GetRandom(ref seed);
			PlaceCliffParameters placeCliffParameters = random.Attribute.Find<PlaceCliffParameters>(random.ID);
			int num7 = (placeCliffParameters ? placeCliffParameters.CutoffSlopeInitial : CutoffSlopeInitial);
			int num8 = (placeCliffParameters ? placeCliffParameters.MinTerrainHeight : MinTerrainHeight);
			int num9 = (placeCliffParameters ? placeCliffParameters.MaxTerrainHeight : MaxTerrainHeight);
			int num10 = (placeCliffParameters ? placeCliffParameters.MinCliffHeight : MinCliffHeight);
			int num11 = (placeCliffParameters ? placeCliffParameters.MaxCliffHeight : MaxCliffHeight);
			float num12 = (placeCliffParameters ? placeCliffParameters.MinCliffScale : MinCliffScale);
			float num13 = (placeCliffParameters ? placeCliffParameters.MaxCliffScale : MaxCliffScale);
			if ((FilterModeInitial & SpawnFilterMode.PivotPoint) != 0)
			{
				float factor = Filter.GetFactor(normX, normZ);
				if (factor * factor < num6)
				{
					continue;
				}
			}
			float height = heightMap.GetHeight(normX, normZ);
			if (height < (float)num8 || height > (float)num9)
			{
				continue;
			}
			Vector3 normal = heightMap.GetNormal(normX, normZ);
			if (Vector3.Angle(Vector3.up, normal) < (float)num7)
			{
				continue;
			}
			((Vector3)(ref val))..ctor(num4, height, num5);
			Quaternion val2 = QuaternionEx.LookRotationForcedUp(normal, Vector3.up);
			float num14 = Mathf.Max((num13 - num12) / (float)max_scale_attempts, min_scale_delta);
			for (float num15 = num13; num15 >= num12; num15 -= num14)
			{
				Vector3 pos = val;
				Quaternion rot = val2 * random.Object.transform.localRotation;
				Vector3 scale = num15 * random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorModeInitial, ((FilterModeInitial & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && !(pos.y < (float)num10) && !(pos.y > (float)num11) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterModeInitial & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					CliffPlacement cliffPlacement = PlaceMale(array3, ref seed, random, pos, rot, scale);
					CliffPlacement cliffPlacement2 = PlaceFemale(array4, ref seed, random, pos, rot, scale);
					World.AddPrefab("Decor", random, pos, rot, scale);
					while (cliffPlacement != null && cliffPlacement.prefab != null)
					{
						World.AddPrefab("Decor", cliffPlacement.prefab, cliffPlacement.pos, cliffPlacement.rot, cliffPlacement.scale);
						cliffPlacement = cliffPlacement.next;
						i++;
					}
					while (cliffPlacement2 != null && cliffPlacement2.prefab != null)
					{
						World.AddPrefab("Decor", cliffPlacement2.prefab, cliffPlacement2.pos, cliffPlacement2.rot, cliffPlacement2.scale);
						cliffPlacement2 = cliffPlacement2.next;
						i++;
					}
					break;
				}
			}
		}
	}

	private CliffPlacement PlaceMale(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Place<DecorSocketFemale, DecorSocketMale>(prefabs, ref seed, parentPrefab, parentPos, parentRot, parentScale);
	}

	private CliffPlacement PlaceFemale(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Place<DecorSocketMale, DecorSocketFemale>(prefabs, ref seed, parentPrefab, parentPos, parentRot, parentScale);
	}

	private CliffPlacement Place<ParentSocketType, ChildSocketType>(Prefab[] prefabs, ref uint seed, Prefab parentPrefab, Vector3 parentPos, Quaternion parentRot, Vector3 parentScale, int parentAngle = 0, int parentCount = 0, int parentScore = 0) where ParentSocketType : PrefabAttribute where ChildSocketType : PrefabAttribute
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0239: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0354: Unknown result type (might be due to invalid IL or missing references)
		//IL_0356: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0418: Unknown result type (might be due to invalid IL or missing references)
		//IL_041a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0420: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0428: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		CliffPlacement cliffPlacement = null;
		if (parentAngle > 160 || parentAngle < -160)
		{
			return cliffPlacement;
		}
		int num = SeedRandom.Range(ref seed, 0, prefabs.Length);
		ParentSocketType val = parentPrefab.Attribute.Find<ParentSocketType>(parentPrefab.ID);
		Vector3 val2 = parentPos + parentRot * Vector3.Scale(val.worldPosition, parentScale);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		for (int i = 0; i < prefabs.Length; i++)
		{
			Prefab prefab = prefabs[(num + i) % prefabs.Length];
			if (prefab == parentPrefab)
			{
				continue;
			}
			ParentSocketType val3 = prefab.Attribute.Find<ParentSocketType>(prefab.ID);
			ChildSocketType val4 = prefab.Attribute.Find<ChildSocketType>(prefab.ID);
			bool flag = val3 != null;
			if (cliffPlacement != null && cliffPlacement.count > TargetCount && cliffPlacement.score > TargetLength && flag)
			{
				continue;
			}
			PlaceCliffParameters placeCliffParameters = prefab.Attribute.Find<PlaceCliffParameters>(prefab.ID);
			int num2 = (placeCliffParameters ? placeCliffParameters.CutoffSlopeRepeat : CutoffSlopeRepeat);
			int num3 = (placeCliffParameters ? placeCliffParameters.MinTerrainHeight : MinTerrainHeight);
			int num4 = (placeCliffParameters ? placeCliffParameters.MaxTerrainHeight : MaxTerrainHeight);
			int num5 = (placeCliffParameters ? placeCliffParameters.MinCliffHeight : MinCliffHeight);
			int num6 = (placeCliffParameters ? placeCliffParameters.MaxCliffHeight : MaxCliffHeight);
			float num7 = (placeCliffParameters ? placeCliffParameters.MinCliffScale : MinCliffScale);
			float num8 = (placeCliffParameters ? placeCliffParameters.MaxCliffScale : MaxCliffScale);
			float num9 = Mathf.Max((num8 - num7) / (float)max_scale_attempts, min_scale_delta);
			float num10 = num8;
			while (num10 >= num7)
			{
				int j;
				Vector3 scale;
				Quaternion rot;
				Vector3 pos;
				for (j = min_rotation; j <= max_rotation; j += rotation_delta)
				{
					for (int k = -1; k <= 1; k += 2)
					{
						Vector3[] array = offsets;
						foreach (Vector3 val5 in array)
						{
							scale = prefab.Object.transform.localScale * num10;
							rot = Quaternion.Euler(0f, (float)(k * j), 0f) * parentRot;
							pos = val2 - rot * (Vector3.Scale(val4.worldPosition, scale) + val5);
							float normX = TerrainMeta.NormalizeX(pos.x);
							float normZ = TerrainMeta.NormalizeZ(pos.z);
							if ((FilterModeRepeat & SpawnFilterMode.PivotPoint) != 0)
							{
								float factor = Filter.GetFactor(normX, normZ);
								if (factor * factor < 0.5f)
								{
									continue;
								}
							}
							float height = heightMap.GetHeight(normX, normZ);
							if (height < (float)num3 || height > (float)num4)
							{
								continue;
							}
							Vector3 normal = heightMap.GetNormal(normX, normZ);
							if (Vector3.Angle(Vector3.up, normal) < (float)num2)
							{
								continue;
							}
							prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
							if (!prefab.ApplyTerrainAnchors(ref pos, rot, scale, AnchorModeRepeat, ((FilterModeRepeat & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) || pos.y < (float)num5 || pos.y > (float)num6 || !prefab.ApplyTerrainChecks(pos, rot, scale, ((FilterModeRepeat & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) || !prefab.ApplyTerrainFilters(pos, rot, scale) || !prefab.ApplyWaterChecks(pos, rot, scale) || !prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale))
							{
								continue;
							}
							goto IL_0387;
						}
					}
				}
				num10 -= num9;
				continue;
				IL_0387:
				int parentAngle2 = parentAngle + j;
				int num11 = parentCount + 1;
				int num12 = parentScore + Mathf.CeilToInt(Vector3Ex.Distance2D(parentPos, pos));
				CliffPlacement cliffPlacement2 = null;
				if (flag)
				{
					cliffPlacement2 = Place<ParentSocketType, ChildSocketType>(prefabs, ref seed, prefab, pos, rot, scale, parentAngle2, num11, num12);
					if (cliffPlacement2 != null)
					{
						num11 = cliffPlacement2.count;
						num12 = cliffPlacement2.score;
					}
				}
				else
				{
					num12 *= 2;
				}
				if (cliffPlacement == null)
				{
					cliffPlacement = new CliffPlacement();
				}
				if (cliffPlacement.score < num12)
				{
					cliffPlacement.next = cliffPlacement2;
					cliffPlacement.count = num11;
					cliffPlacement.score = num12;
					cliffPlacement.prefab = prefab;
					cliffPlacement.pos = pos;
					cliffPlacement.rot = rot;
					cliffPlacement.scale = scale;
				}
				break;
			}
		}
		return cliffPlacement;
	}
}


using UnityEngine;

private class CliffPlacement
{
	public int count;

	public int score;

	public Prefab prefab;

	public Vector3 pos = Vector3.zero;

	public Quaternion rot = Quaternion.identity;

	public Vector3 scale = Vector3.one;

	public CliffPlacement next;
}


using UnityEngine;

public class PlaceCliffsUniform : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDistance = 10f;

	public float ObjectDithering = 5f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	private static int min_rotation_z = 0;

	private static int max_rotation_z = 12;

	private static int rotation_delta_z = 4;

	private static int min_rotation_x = 0;

	private static int max_rotation_x = 12;

	private static int rotation_delta_x = 2;

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (int num3 = 128; num3 > 0; num3 /= 2)
		{
			float num4 = ObjectDistance * (float)num3;
			for (float num5 = z; num5 < num2; num5 += num4)
			{
				for (float num6 = x; num6 < num; num6 += num4)
				{
					float num7 = num6 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
					float num8 = num5 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
					float normX = TerrainMeta.NormalizeX(num7);
					float normZ = TerrainMeta.NormalizeZ(num8);
					float num9 = SeedRandom.Value(ref seed);
					array.BubbleSort();
					if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
					{
						float factor = Filter.GetFactor(normX, normZ);
						if (factor * factor < num9)
						{
							continue;
						}
					}
					float height = heightMap.GetHeight(normX, normZ);
					Prefab[] array2 = array;
					foreach (Prefab prefab in array2)
					{
						((Vector3)(ref pos))..ctor(num7, height, num8);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						bool flag = false;
						Vector3 val = Vector3.zero;
						Quaternion rotation = Quaternion.identity;
						Vector3 scale2 = Vector3.zero;
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						for (int j = min_rotation_z; j <= max_rotation_z; j += rotation_delta_z)
						{
							for (int k = min_rotation_x; k <= max_rotation_x; k += rotation_delta_x)
							{
								for (int l = -1; l <= 1; l += 2)
								{
									for (int m = -1; m <= 1; m += 2)
									{
										Vector3 pos2 = pos;
										Quaternion val2 = rot * Quaternion.Euler((float)(m * k), 0f, (float)(l * j));
										Vector3 val3 = scale;
										if (prefab.ApplyTerrainFilters(pos2, val2, val3) && prefab.ApplyTerrainAnchors(ref pos2, val2, val3, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && prefab.ApplyTerrainChecks(pos2, val2, val3, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && prefab.ApplyWaterChecks(pos2, val2, val3) && prefab.ApplyEnvironmentVolumeChecks(pos2, val2, val3) && (!flag || val.y < pos2.y))
										{
											flag = true;
											val = pos2;
											rotation = val2;
											scale2 = val3;
										}
									}
								}
							}
						}
						if (flag)
						{
							prefab.SpawnedCount++;
							World.AddPrefab("Decor", prefab, val, rotation, scale2);
							break;
						}
					}
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorUniform : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDistance = 10f;

	public float ObjectDithering = 5f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (float num3 = z; num3 < num2; num3 += ObjectDistance)
		{
			for (float num4 = x; num4 < num; num4 += ObjectDistance)
			{
				float num5 = num4 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
				float num6 = num3 + SeedRandom.Range(ref seed, 0f - ObjectDithering, ObjectDithering);
				float normX = TerrainMeta.NormalizeX(num5);
				float normZ = TerrainMeta.NormalizeZ(num6);
				float num7 = SeedRandom.Value(ref seed);
				Prefab random = array.GetRandom(ref seed);
				if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
				{
					float factor = Filter.GetFactor(normX, normZ);
					if (factor * factor < num7)
					{
						continue;
					}
				}
				float height = heightMap.GetHeight(normX, normZ);
				((Vector3)(ref pos))..ctor(num5, height, num6);
				Quaternion rot = random.Object.transform.localRotation;
				Vector3 scale = random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					World.AddPrefab("Decor", random, pos, rot, scale);
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorValueNoise : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public NoiseParameters Cluster = new NoiseParameters(2, 0.5f, 1f, 0f);

	public float ObjectDensity = 100f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0265: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0279: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		int num = Mathf.RoundToInt(ObjectDensity * size.x * size.z * 1E-06f);
		float x = position.x;
		float z = position.z;
		float num2 = position.x + size.x;
		float num3 = position.z + size.z;
		float num4 = SeedRandom.Range(ref seed, -1000000f, 1000000f);
		float num5 = SeedRandom.Range(ref seed, -1000000f, 1000000f);
		int octaves = Cluster.Octaves;
		float offset = Cluster.Offset;
		float frequency = Cluster.Frequency * 0.01f;
		float amplitude = Cluster.Amplitude;
		Vector3 pos = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num6 = SeedRandom.Range(ref seed, x, num2);
			float num7 = SeedRandom.Range(ref seed, z, num3);
			float normX = TerrainMeta.NormalizeX(num6);
			float normZ = TerrainMeta.NormalizeZ(num7);
			float num8 = SeedRandom.Value(ref seed);
			float factor = Filter.GetFactor(normX, normZ);
			Prefab random = array.GetRandom(ref seed);
			if (((FilterMode & SpawnFilterMode.PivotPoint) == 0 || !(factor <= 0f)) && !((offset + Noise.Turbulence(num4 + num6, num5 + num7, octaves, frequency, amplitude)) * factor * factor < num8))
			{
				float height = heightMap.GetHeight(normX, normZ);
				((Vector3)(ref pos))..ctor(num6, height, num7);
				Quaternion rot = random.Object.transform.localRotation;
				Vector3 scale = random.Object.transform.localScale;
				random.ApplyDecorComponents(ref pos, ref rot, ref scale);
				if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
				{
					World.AddPrefab("Decor", random, pos, rot, scale);
				}
			}
		}
	}
}


using UnityEngine;

public class PlaceDecorWhiteNoise : ProceduralComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public float ObjectDensity = 100f;

	public TerrainAnchorMode AnchorMode;

	[InspectorFlags]
	public SpawnFilterMode FilterMode = (SpawnFilterMode)(-1);

	public override void Process(uint seed)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Decor", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + ResourceFolder);
		if (array == null || array.Length == 0)
		{
			return;
		}
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		int num = Mathf.RoundToInt(ObjectDensity * size.x * size.z * 1E-06f);
		float x = position.x;
		float z = position.z;
		float num2 = position.x + size.x;
		float num3 = position.z + size.z;
		Vector3 pos = default(Vector3);
		for (int i = 0; i < num; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num2);
			float num5 = SeedRandom.Range(ref seed, z, num3);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			Prefab random = array.GetRandom(ref seed);
			if ((FilterMode & SpawnFilterMode.PivotPoint) != 0)
			{
				float factor = Filter.GetFactor(normX, normZ);
				if (factor * factor < num6)
				{
					continue;
				}
			}
			float height = heightMap.GetHeight(normX, normZ);
			((Vector3)(ref pos))..ctor(num4, height, num5);
			Quaternion rot = random.Object.transform.localRotation;
			Vector3 scale = random.Object.transform.localScale;
			random.ApplyDecorComponents(ref pos, ref rot, ref scale);
			if (random.ApplyTerrainFilters(pos, rot, scale) && random.ApplyTerrainAnchors(ref pos, rot, scale, AnchorMode, ((FilterMode & SpawnFilterMode.TerrainAnchorPoints) != 0) ? Filter : null) && random.ApplyTerrainChecks(pos, rot, scale, ((FilterMode & SpawnFilterMode.TerrainCheckPoints) != 0) ? Filter : null) && random.ApplyWaterChecks(pos, rot, scale) && random.ApplyEnvironmentVolumeChecks(pos, rot, scale))
			{
				World.AddPrefab("Decor", random, pos, rot, scale);
			}
		}
	}
}


using ConVar;
using UnityEngine;

public class PlaceJungleVines : PlaceDecorUniform
{
	public override void Process(uint seed)
	{
		if (!Server.spawnVineTrees)
		{
			Debug.LogWarning((object)"server.spawnVineTrees is disabled, skipping vine spawn...");
		}
		else
		{
			base.Process(seed);
		}
	}
}


using UnityEngine;

public class PlaceMonument : ProceduralComponent
{
	public struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public SpawnFilter Filter;

	public GameObjectRef Monument;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		if (!Monument.isValid)
		{
			return;
		}
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float x = position.x;
		float z = position.z;
		float num = position.x + size.x;
		float num2 = position.z + size.z;
		SpawnInfo spawnInfo = default(SpawnInfo);
		int num3 = int.MinValue;
		Prefab<MonumentInfo> prefab = Prefab.Load<MonumentInfo>(Monument.resourceID, (GameManager)null, (PrefabAttribute.Library)null);
		Vector3 pos = default(Vector3);
		for (int i = 0; i < 10000; i++)
		{
			float num4 = SeedRandom.Range(ref seed, x, num);
			float num5 = SeedRandom.Range(ref seed, z, num2);
			float normX = TerrainMeta.NormalizeX(num4);
			float normZ = TerrainMeta.NormalizeZ(num5);
			float num6 = SeedRandom.Value(ref seed);
			float factor = Filter.GetFactor(normX, normZ);
			if (factor * factor < num6)
			{
				continue;
			}
			float height = heightMap.GetHeight(normX, normZ);
			((Vector3)(ref pos))..ctor(num4, height, num5);
			Quaternion rot = prefab.Object.transform.localRotation;
			Vector3 scale = prefab.Object.transform.localScale;
			prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
			if ((!Object.op_Implicit((Object)(object)prefab.Component) || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyTerrainFilters(pos, rot, scale) && prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) && prefab.ApplyTerrainChecks(pos, rot, scale, Filter) && prefab.ApplyWaterChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
			{
				SpawnInfo spawnInfo2 = default(SpawnInfo);
				spawnInfo2.prefab = prefab;
				spawnInfo2.position = pos;
				spawnInfo2.rotation = rot;
				spawnInfo2.scale = scale;
				int num7 = -Mathf.RoundToInt(Vector3Ex.Magnitude2D(pos));
				if (num7 > num3)
				{
					num3 = num7;
					spawnInfo = spawnInfo2;
				}
			}
		}
		if (num3 != int.MinValue)
		{
			World.AddPrefab("Monument", spawnInfo.prefab, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
		}
	}
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonuments : ProceduralComponent
{
	public struct WorldSizeInfo
	{
		public int WorldSizeMin;

		public int WorldSizeMax;

		public int TargetCount;
	}

	public struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public bool dungeonEntrance;

		public Vector3 dungeonEntrancePos;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;

		public float minDistanceDungeonEntrance;

		public float maxDistanceDungeonEntrance;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public AnimationCurve TargetCountWorldSizeMultiplier = AnimationCurve.Constant(1000f, 6000f, 1f);

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	[Tooltip("Enable to only spawn these monuments when running as a nexus")]
	public bool NexusOnly;

	public const int GroupCandidates = 8;

	public const int IndividualCandidates = 8;

	public const int Attempts = 10000;

	private const int MaxDepth = 100000;

	public override void Process(uint seed)
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0453: Unknown result type (might be due to invalid IL or missing references)
		//IL_0455: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_040a: Unknown result type (might be due to invalid IL or missing references)
		//IL_040f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0414: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0422: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_042d: Unknown result type (might be due to invalid IL or missing references)
		//IL_042f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0431: Unknown result type (might be due to invalid IL or missing references)
		//IL_0436: Unknown result type (might be due to invalid IL or missing references)
		//IL_043b: Unknown result type (might be due to invalid IL or missing references)
		//IL_043f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_046b: Unknown result type (might be due to invalid IL or missing references)
		//IL_046d: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_044d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_047d: Unknown result type (might be due to invalid IL or missing references)
		//IL_047f: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_048f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0491: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_05f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_05fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0603: Unknown result type (might be due to invalid IL or missing references)
		//IL_0605: Unknown result type (might be due to invalid IL or missing references)
		//IL_057a: Unknown result type (might be due to invalid IL or missing references)
		//IL_057c: Unknown result type (might be due to invalid IL or missing references)
		//IL_057e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0587: Unknown result type (might be due to invalid IL or missing references)
		//IL_058c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0591: Unknown result type (might be due to invalid IL or missing references)
		//IL_0596: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		//IL_061f: Unknown result type (might be due to invalid IL or missing references)
		if (NexusOnly && !World.Nexus)
		{
			return;
		}
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			PathFinder pathFinder = null;
			List<PathFinder.Point> endList = null;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!text.Contains("underwater_lab") || World.Config.UnderwaterLabs)
				{
					Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(text, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
					array3.Shuffle(ref seed);
					list.AddRange(array3);
				}
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			Vector3 position = TerrainMeta.Position;
			Vector3 size = TerrainMeta.Size;
			float x = position.x;
			float z = position.z;
			float num = position.x + size.x;
			float num2 = position.z + size.z;
			int num3 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num4 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			int num5 = Mathf.RoundToInt((float)TargetCount * TargetCountWorldSizeMultiplier.Evaluate((float)World.Size));
			Vector3 pos = default(Vector3);
			for (int j = 0; j < 8; j++)
			{
				num3 = 0;
				list2.Clear();
				Prefab<MonumentInfo>[] array5 = array4;
				foreach (Prefab<MonumentInfo> prefab in array5)
				{
					MonumentInfo component = prefab.Component;
					if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component.DungeonEntrance;
					int num6 = (int)((!Object.op_Implicit((Object)(object)prefab.Parameters)) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
					int num7 = 100000 * num6 * num6 * num6 * num6;
					int num8 = 0;
					int num9 = 0;
					SpawnInfo item = default(SpawnInfo);
					for (int k = 0; k < 10000; k++)
					{
						float num10 = SeedRandom.Range(ref seed, x, num);
						float num11 = SeedRandom.Range(ref seed, z, num2);
						float normX = TerrainMeta.NormalizeX(num10);
						float normZ = TerrainMeta.NormalizeZ(num11);
						float num12 = SeedRandom.Value(ref seed);
						float factor = Filter.GetFactor(normX, normZ);
						if (factor * factor < num12)
						{
							continue;
						}
						float height = heightMap.GetHeight(normX, normZ);
						((Vector3)(ref pos))..ctor(num10, height, num11);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						Vector3 val = pos;
						prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab, pos, rot, scale, val);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType || (Object.op_Implicit((Object)(object)dungeonEntrance) && distanceInfo.minDistanceDungeonEntrance < dungeonEntrance.MinDistance))
						{
							continue;
						}
						int num13 = num7;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num13 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num13 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num13 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num13 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (num13 <= num9 || !prefab.ApplyTerrainFilters(pos, rot, scale) || !prefab.ApplyTerrainAnchors(ref pos, rot, scale, Filter) || !component.CheckPlacement(pos, rot, scale))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val2 = pos + rot * Vector3.Scale(scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val3 = dungeonEntrance.SnapPosition(val2);
							pos += val3 - val2;
							if (!dungeonEntrance.IsValidSpawnPosition(val3))
							{
								continue;
							}
							val = val3;
						}
						if (!prefab.ApplyTerrainChecks(pos, rot, scale, Filter) || !prefab.ApplyWaterChecks(pos, rot, scale) || !prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale) || prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							continue;
						}
						bool flag = false;
						TerrainPathConnect[] componentsInChildren = prefab.Object.GetComponentsInChildren<TerrainPathConnect>(true);
						foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
						{
							if (terrainPathConnect.Type == InfrastructureType.Boat)
							{
								if (pathFinder == null)
								{
									int[,] array6 = TerrainPath.CreateBoatCostmap(4f);
									int length = array6.GetLength(0);
									pathFinder = new PathFinder(array6);
									endList = new List<PathFinder.Point>
									{
										new PathFinder.Point(0, 0),
										new PathFinder.Point(0, length / 2),
										new PathFinder.Point(0, length - 1),
										new PathFinder.Point(length / 2, 0),
										new PathFinder.Point(length / 2, length - 1),
										new PathFinder.Point(length - 1, 0),
										new PathFinder.Point(length - 1, length / 2),
										new PathFinder.Point(length - 1, length - 1)
									};
								}
								PathFinder.Point point = PathFinder.GetPoint(pos + rot * Vector3.Scale(scale, ((Component)terrainPathConnect).transform.localPosition), pathFinder.GetResolution(0));
								if (pathFinder.FindPathUndirected(new List<PathFinder.Point> { point }, endList, 100000) == null)
								{
									flag = true;
									break;
								}
							}
						}
						if (!flag)
						{
							SpawnInfo spawnInfo = default(SpawnInfo);
							spawnInfo.prefab = prefab;
							spawnInfo.position = pos;
							spawnInfo.rotation = rot;
							spawnInfo.scale = scale;
							if (Object.op_Implicit((Object)(object)dungeonEntrance))
							{
								spawnInfo.dungeonEntrance = true;
								spawnInfo.dungeonEntrancePos = val;
							}
							num9 = num13;
							item = spawnInfo;
							num8++;
							if (num8 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num9 > 0)
					{
						list2.Add(item);
						num3 += num9;
					}
					if (num5 > 0 && list2.Count >= num5)
					{
						break;
					}
				}
				if (num3 > num4)
				{
					num4 = num3;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item2 in list3)
			{
				World.AddPrefab("Monument", item2.prefab, item2.position, item2.rotation, item2.scale);
			}
		}
	}

	public DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale, Vector3 dungeonPos)
	{
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceDungeonEntrance = float.MaxValue;
		result.maxDistanceDungeonEntrance = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num = ((OBB)(ref val2)).SqrDistance(val);
				if (spawn.prefab.Folder == prefab.Folder)
				{
					if (num < result.minDistanceSameType)
					{
						result.minDistanceSameType = num;
					}
					if (num > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num;
					}
				}
				else
				{
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			foreach (SpawnInfo spawn2 in spawns)
			{
				if (spawn2.dungeonEntrance)
				{
					Vector3 val3 = spawn2.dungeonEntrancePos - dungeonPos;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < result.minDistanceDungeonEntrance)
					{
						result.minDistanceDungeonEntrance = sqrMagnitude;
					}
					if (sqrMagnitude > result.maxDistanceDungeonEntrance)
					{
						result.maxDistanceDungeonEntrance = sqrMagnitude;
					}
				}
			}
		}
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				float num2 = monument.SqrDistance(val);
				if (num2 < result.minDistanceDifferentType)
				{
					result.minDistanceDifferentType = num2;
				}
				if (num2 > result.maxDistanceDifferentType)
				{
					result.maxDistanceDifferentType = num2;
				}
			}
			foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
			{
				float num3 = dungeonGridEntrance.SqrDistance(dungeonPos);
				if (num3 < result.minDistanceDungeonEntrance)
				{
					result.minDistanceDungeonEntrance = num3;
				}
				if (num3 > result.maxDistanceDungeonEntrance)
				{
					result.maxDistanceDungeonEntrance = num3;
				}
			}
		}
		if (result.minDistanceSameType != float.MaxValue)
		{
			result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
		}
		if (result.maxDistanceSameType != float.MinValue)
		{
			result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
		}
		if (result.minDistanceDifferentType != float.MaxValue)
		{
			result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
		}
		if (result.maxDistanceDifferentType != float.MinValue)
		{
			result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
		}
		if (result.minDistanceDungeonEntrance != float.MaxValue)
		{
			result.minDistanceDungeonEntrance = Mathf.Sqrt(result.minDistanceDungeonEntrance);
		}
		if (result.maxDistanceDungeonEntrance != float.MinValue)
		{
			result.maxDistanceDungeonEntrance = Mathf.Sqrt(result.maxDistanceDungeonEntrance);
		}
		return result;
	}
}


public struct WorldSizeInfo
{
	public int WorldSizeMin;

	public int WorldSizeMax;

	public int TargetCount;
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public bool dungeonEntrance;

	public Vector3 dungeonEntrancePos;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;

	public float minDistanceDungeonEntrance;

	public float maxDistanceDungeonEntrance;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsOffshore : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public int MinDistanceFromTerrain = 100;

	public int MaxDistanceFromTerrain = 500;

	public int DistanceBetweenMonuments = 500;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	private const int Candidates = 10;

	private const int Attempts = 10000;

	public override void Process(uint seed)
	{
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_029d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_030d: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_033a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0343: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			TerrainHeightMap heightMap = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(array2[i], (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
				array3.Shuffle(ref seed);
				list.AddRange(array3);
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			Vector3 position = TerrainMeta.Position;
			Vector3 size = TerrainMeta.Size;
			float num = position.x - (float)MaxDistanceFromTerrain;
			float num2 = position.x - (float)MinDistanceFromTerrain;
			float num3 = position.x + size.x + (float)MinDistanceFromTerrain;
			float num4 = position.x + size.x + (float)MaxDistanceFromTerrain;
			float num5 = position.z - (float)MaxDistanceFromTerrain;
			float num6 = position.z - (float)MinDistanceFromTerrain;
			float num7 = position.z + size.z + (float)MinDistanceFromTerrain;
			float num8 = position.z + size.z + (float)MaxDistanceFromTerrain;
			int num9 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num10 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			Vector3 pos = default(Vector3);
			for (int j = 0; j < 10; j++)
			{
				num9 = 0;
				list2.Clear();
				Prefab<MonumentInfo>[] array5 = array4;
				foreach (Prefab<MonumentInfo> prefab in array5)
				{
					int num11 = (int)((!Object.op_Implicit((Object)(object)prefab.Parameters)) ? PrefabPriority.Low : (prefab.Parameters.Priority + 1));
					int num12 = num11 * num11 * num11 * num11;
					for (int k = 0; k < 10000; k++)
					{
						float num13 = 0f;
						float num14 = 0f;
						switch (seed % 4)
						{
						case 0u:
							num13 = SeedRandom.Range(ref seed, num, num2);
							num14 = SeedRandom.Range(ref seed, num5, num8);
							break;
						case 1u:
							num13 = SeedRandom.Range(ref seed, num3, num4);
							num14 = SeedRandom.Range(ref seed, num5, num8);
							break;
						case 2u:
							num13 = SeedRandom.Range(ref seed, num, num4);
							num14 = SeedRandom.Range(ref seed, num5, num6);
							break;
						case 3u:
							num13 = SeedRandom.Range(ref seed, num, num4);
							num14 = SeedRandom.Range(ref seed, num7, num8);
							break;
						}
						float normX = TerrainMeta.NormalizeX(num13);
						float normZ = TerrainMeta.NormalizeZ(num14);
						float height = heightMap.GetHeight(normX, normZ);
						((Vector3)(ref pos))..ctor(num13, height, num14);
						Quaternion rot = prefab.Object.transform.localRotation;
						Vector3 scale = prefab.Object.transform.localScale;
						if (!CheckRadius(list2, pos, DistanceBetweenMonuments))
						{
							prefab.ApplyDecorComponents(ref pos, ref rot, ref scale);
							if ((!Object.op_Implicit((Object)(object)prefab.Component) || prefab.Component.CheckPlacement(pos, rot, scale)) && prefab.ApplyEnvironmentVolumeChecks(pos, rot, scale) && !prefab.CheckEnvironmentVolumes(pos, rot, scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
							{
								SpawnInfo item = default(SpawnInfo);
								item.prefab = prefab;
								item.position = pos;
								item.rotation = rot;
								item.scale = scale;
								list2.Add(item);
								num9 += num12;
								break;
							}
						}
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num9 > num10)
				{
					num10 = num9;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item2 in list3)
			{
				World.AddPrefab("Monument", item2.prefab, item2.position, item2.rotation, item2.scale);
			}
		}
	}

	public bool CheckRadius(List<SpawnInfo> spawns, Vector3 pos, float radius)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = radius * radius;
		foreach (SpawnInfo spawn in spawns)
		{
			Vector3 val = spawn.position - pos;
			if (((Vector3)(ref val)).sqrMagnitude < num)
			{
				return true;
			}
		}
		return false;
	}
}


using UnityEngine;

private struct SpawnInfo
{
	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsRailside : ProceduralComponent
{
	private struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;
	}

	private class SpawnInfoGroup
	{
		public bool processed;

		public Prefab<MonumentInfo> prefab;

		public List<SpawnInfo> candidates;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	public int PositionOffset = 100;

	public int TangentInterval = 100;

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	private const int GroupCandidates = 8;

	private const int IndividualCandidates = 8;

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_0228: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_082f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0836: Unknown result type (might be due to invalid IL or missing references)
		//IL_083d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0518: Unknown result type (might be due to invalid IL or missing references)
		//IL_051f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0526: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0614: Unknown result type (might be due to invalid IL or missing references)
		//IL_061b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0622: Unknown result type (might be due to invalid IL or missing references)
		//IL_0641: Unknown result type (might be due to invalid IL or missing references)
		//IL_0648: Unknown result type (might be due to invalid IL or missing references)
		//IL_064f: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0316: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0342: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_034b: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0352: Unknown result type (might be due to invalid IL or missing references)
		//IL_0354: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0363: Unknown result type (might be due to invalid IL or missing references)
		//IL_0368: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_066a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0671: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0705: Unknown result type (might be due to invalid IL or missing references)
		//IL_070c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0691: Unknown result type (might be due to invalid IL or missing references)
		//IL_0698: Unknown result type (might be due to invalid IL or missing references)
		//IL_069f: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_06db: Unknown result type (might be due to invalid IL or missing references)
		//IL_06dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0722: Unknown result type (might be due to invalid IL or missing references)
		//IL_0729: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0740: Unknown result type (might be due to invalid IL or missing references)
		//IL_0747: Unknown result type (might be due to invalid IL or missing references)
		//IL_074e: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0765: Unknown result type (might be due to invalid IL or missing references)
		//IL_076c: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			_ = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			for (int i = 0; i < array2.Length; i++)
			{
				Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(array2[i], (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
				array3.Shuffle(ref seed);
				list.AddRange(array3);
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			SpawnInfoGroup[] array5 = new SpawnInfoGroup[array4.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				Prefab<MonumentInfo> prefab = array4[j];
				SpawnInfoGroup spawnInfoGroup = null;
				for (int k = 0; k < j; k++)
				{
					SpawnInfoGroup spawnInfoGroup2 = array5[k];
					Prefab<MonumentInfo> prefab2 = spawnInfoGroup2.prefab;
					if (prefab == prefab2)
					{
						spawnInfoGroup = spawnInfoGroup2;
						break;
					}
				}
				if (spawnInfoGroup == null)
				{
					spawnInfoGroup = new SpawnInfoGroup();
					spawnInfoGroup.prefab = array4[j];
					spawnInfoGroup.candidates = new List<SpawnInfo>();
				}
				array5[j] = spawnInfoGroup;
			}
			SpawnInfoGroup[] array6 = array5;
			foreach (SpawnInfoGroup spawnInfoGroup3 in array6)
			{
				if (spawnInfoGroup3.processed)
				{
					continue;
				}
				Prefab<MonumentInfo> prefab3 = spawnInfoGroup3.prefab;
				MonumentInfo component = prefab3.Component;
				if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
				{
					continue;
				}
				int num = 0;
				Vector3 val = Vector3.zero;
				Vector3 val2 = Vector3.zero;
				Vector3 val3 = Vector3.zero;
				TerrainPathConnect[] componentsInChildren = prefab3.Object.GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Rail)
					{
						switch (num)
						{
						case 0:
							val2 = ((Component)terrainPathConnect).transform.position;
							break;
						case 1:
							val3 = ((Component)terrainPathConnect).transform.position;
							break;
						}
						val += ((Component)terrainPathConnect).transform.position;
						num++;
					}
				}
				Vector3 val4 = val3 - val2;
				Vector3 normalized = ((Vector3)(ref val4)).normalized;
				val4 = rot90 * normalized;
				Vector3 normalized2 = ((Vector3)(ref val4)).normalized;
				if (num > 1)
				{
					val /= (float)num;
				}
				foreach (PathList rail in TerrainMeta.Path.Rails)
				{
					PathInterpolator path = rail.Path;
					float num2 = TangentInterval / 2;
					float num3 = 5f;
					float num4 = 5f;
					float num5 = path.StartOffset + num4;
					float num6 = path.Length - path.EndOffset - num4;
					for (float num7 = num5; num7 <= num6; num7 += num3)
					{
						Vector3 val5 = (rail.Spline ? path.GetPointCubicHermite(num7) : path.GetPoint(num7));
						val4 = path.GetPoint(num7 + num2) - path.GetPoint(num7 - num2);
						Vector3 normalized3 = ((Vector3)(ref val4)).normalized;
						for (int m = Mathf.RoundToInt((float)PositionOffset); m <= Mathf.CeilToInt((float)PositionOffset * 1.5f); m += 25)
						{
							for (int n = -1; n <= 1; n += 2)
							{
								Quaternion val6 = Quaternion.LookRotation((float)n * Vector3Ex.XZ3D(normalized3));
								Vector3 val7 = val5;
								Quaternion val8 = val6;
								Vector3 localScale = prefab3.Object.transform.localScale;
								val8 *= Quaternion.LookRotation(normalized);
								val7 -= val8 * (val + (float)m * normalized2);
								if (!(GetDistanceToAboveGroundRail(val7) < (float)PositionOffset * 0.5f))
								{
									SpawnInfo item = default(SpawnInfo);
									item.prefab = prefab3;
									item.position = val7;
									item.rotation = val8;
									item.scale = localScale;
									spawnInfoGroup3.candidates.Add(item);
								}
							}
						}
					}
				}
				spawnInfoGroup3.processed = true;
			}
			int num8 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num9 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			for (int num10 = 0; num10 < 8; num10++)
			{
				num8 = 0;
				list2.Clear();
				array5.Shuffle(ref seed);
				array6 = array5;
				foreach (SpawnInfoGroup spawnInfoGroup4 in array6)
				{
					Prefab<MonumentInfo> prefab4 = spawnInfoGroup4.prefab;
					MonumentInfo component2 = prefab4.Component;
					if ((Object)(object)component2 == (Object)null || World.Size < component2.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component2.DungeonEntrance;
					int num11 = (int)((!Object.op_Implicit((Object)(object)prefab4.Parameters)) ? PrefabPriority.Low : (prefab4.Parameters.Priority + 1));
					int num12 = 100000 * num11 * num11 * num11 * num11;
					int num13 = 0;
					int num14 = 0;
					SpawnInfo item2 = default(SpawnInfo);
					ListEx.Shuffle<SpawnInfo>(spawnInfoGroup4.candidates, ref seed);
					for (int num15 = 0; num15 < spawnInfoGroup4.candidates.Count; num15++)
					{
						SpawnInfo spawnInfo = spawnInfoGroup4.candidates[num15];
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab4, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType)
						{
							continue;
						}
						int num16 = num12;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num16 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num16 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num16 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num16 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (!component2.CheckPlacement(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale))
						{
							num16 /= 2;
						}
						if (num16 <= num14 || !prefab4.ApplyTerrainFilters(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) || !prefab4.ApplyTerrainAnchors(ref spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val9 = spawnInfo.position + spawnInfo.rotation * Vector3.Scale(spawnInfo.scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val10 = dungeonEntrance.SnapPosition(val9);
							ref Vector3 position = ref spawnInfo.position;
							position += val10 - val9;
							if (!dungeonEntrance.IsValidSpawnPosition(val10))
							{
								continue;
							}
						}
						if (prefab4.ApplyTerrainChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) && prefab4.ApplyWaterChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && prefab4.ApplyEnvironmentVolumeChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && !prefab4.CheckEnvironmentVolumes(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							num14 = num16;
							item2 = spawnInfo;
							num13++;
							if (num13 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num14 > 0)
					{
						list2.Add(item2);
						num8 += num14;
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num8 > num9)
				{
					num9 = num8;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item3 in list3)
			{
				World.AddPrefab("Monument", item3.prefab, item3.position, item3.rotation, item3.scale);
			}
		}
	}

	private DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (!prefab.Component.HasDungeonLink || (!monument.HasDungeonLink && monument.WantsDungeonLink))
				{
					float num = monument.SqrDistance(val);
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			if (result.minDistanceDifferentType != float.MaxValue)
			{
				result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
			}
			if (result.maxDistanceDifferentType != float.MinValue)
			{
				result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
			}
		}
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num2 = ((OBB)(ref val2)).SqrDistance(val);
				if (num2 < result.minDistanceSameType)
				{
					result.minDistanceSameType = num2;
				}
				if (num2 > result.maxDistanceSameType)
				{
					result.maxDistanceSameType = num2;
				}
			}
			if (prefab.Component.HasDungeonLink)
			{
				foreach (MonumentInfo monument2 in TerrainMeta.Path.Monuments)
				{
					if (monument2.HasDungeonLink || !monument2.WantsDungeonLink)
					{
						float num3 = monument2.SqrDistance(val);
						if (num3 < result.minDistanceSameType)
						{
							result.minDistanceSameType = num3;
						}
						if (num3 > result.maxDistanceSameType)
						{
							result.maxDistanceSameType = num3;
						}
					}
				}
				foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
				{
					float num4 = dungeonGridEntrance.SqrDistance(monumentPos);
					if (num4 < result.minDistanceSameType)
					{
						result.minDistanceSameType = num4;
					}
					if (num4 > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num4;
					}
				}
			}
			if (result.minDistanceSameType != float.MaxValue)
			{
				result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
			}
			if (result.maxDistanceSameType != float.MinValue)
			{
				result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
			}
		}
		return result;
	}

	private float GetDistanceToAboveGroundRail(Vector3 pos)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			foreach (PathList rail in TerrainMeta.Path.Rails)
			{
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					num = Mathf.Min(num, Vector3Ex.Distance2D(val, pos));
				}
			}
		}
		return num;
	}
}


using UnityEngine;

private struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;
}


using System.Collections.Generic;

private class SpawnInfoGroup
{
	public bool processed;

	public Prefab<MonumentInfo> prefab;

	public List<SpawnInfo> candidates;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.Serialization;

public class PlaceMonumentsRoadside : ProceduralComponent
{
	public struct SpawnInfo
	{
		public Prefab<MonumentInfo> prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public PathInterpolator path;

		public int pathStartIndex;

		public int pathEndIndex;
	}

	public class SpawnInfoGroup
	{
		public bool processed;

		public Prefab<MonumentInfo> prefab;

		public List<SpawnInfo> candidates;
	}

	private struct DistanceInfo
	{
		public float minDistanceSameType;

		public float maxDistanceSameType;

		public float minDistanceDifferentType;

		public float maxDistanceDifferentType;
	}

	public enum DistanceMode
	{
		Any,
		Min,
		Max
	}

	public enum RoadMode
	{
		SideRoadOrRingRoad,
		SideRoad,
		RingRoad,
		SideRoadOrDesireTrail,
		DesireTrail
	}

	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public int TargetCount;

	[FormerlySerializedAs("MinDistance")]
	public int MinDistanceSameType = 500;

	public int MinDistanceDifferentType;

	[FormerlySerializedAs("MinSize")]
	public int MinWorldSize;

	[Tooltip("Distance to monuments of the same type")]
	public DistanceMode DistanceSameType = DistanceMode.Max;

	[Tooltip("Distance to monuments of a different type")]
	public DistanceMode DistanceDifferentType;

	public RoadMode RoadType;

	public const int GroupCandidates = 8;

	public const int IndividualCandidates = 8;

	public static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	public override void Process(uint seed)
	{
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0219: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_037c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0390: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0400: Unknown result type (might be due to invalid IL or missing references)
		//IL_0402: Unknown result type (might be due to invalid IL or missing references)
		//IL_0407: Unknown result type (might be due to invalid IL or missing references)
		//IL_040c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0421: Unknown result type (might be due to invalid IL or missing references)
		//IL_0423: Unknown result type (might be due to invalid IL or missing references)
		//IL_042a: Unknown result type (might be due to invalid IL or missing references)
		//IL_042c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0433: Unknown result type (might be due to invalid IL or missing references)
		//IL_0435: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0783: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0791: Unknown result type (might be due to invalid IL or missing references)
		//IL_0716: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0724: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0735: Unknown result type (might be due to invalid IL or missing references)
		//IL_073a: Unknown result type (might be due to invalid IL or missing references)
		//IL_073f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0744: Unknown result type (might be due to invalid IL or missing references)
		//IL_0748: Unknown result type (might be due to invalid IL or missing references)
		//IL_074a: Unknown result type (might be due to invalid IL or missing references)
		//IL_074f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0759: Unknown result type (might be due to invalid IL or missing references)
		//IL_075e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_0762: Unknown result type (might be due to invalid IL or missing references)
		//IL_0767: Unknown result type (might be due to invalid IL or missing references)
		//IL_076c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0773: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_07d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_07f1: Unknown result type (might be due to invalid IL or missing references)
		string[] array = (from folder in ResourceFolder.Split(',')
			select "assets/bundled/prefabs/autospawn/" + folder + "/").ToArray();
		if (World.Networked)
		{
			World.Spawn("Monument", array);
		}
		else
		{
			if (World.Size < MinWorldSize)
			{
				return;
			}
			_ = TerrainMeta.HeightMap;
			List<Prefab<MonumentInfo>> list = new List<Prefab<MonumentInfo>>();
			string[] array2 = array;
			foreach (string text in array2)
			{
				if (!text.Contains("tunnel-entrance") || World.Config.BelowGroundRails)
				{
					Prefab<MonumentInfo>[] array3 = Prefab.Load<MonumentInfo>(text, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
					array3.Shuffle(ref seed);
					list.AddRange(array3);
				}
			}
			Prefab<MonumentInfo>[] array4 = list.ToArray();
			if (array4 == null || array4.Length == 0)
			{
				return;
			}
			array4.BubbleSort();
			SpawnInfoGroup[] array5 = new SpawnInfoGroup[array4.Length];
			for (int j = 0; j < array4.Length; j++)
			{
				Prefab<MonumentInfo> prefab = array4[j];
				SpawnInfoGroup spawnInfoGroup = null;
				for (int k = 0; k < j; k++)
				{
					SpawnInfoGroup spawnInfoGroup2 = array5[k];
					Prefab<MonumentInfo> prefab2 = spawnInfoGroup2.prefab;
					if (prefab == prefab2)
					{
						spawnInfoGroup = spawnInfoGroup2;
						break;
					}
				}
				if (spawnInfoGroup == null)
				{
					spawnInfoGroup = new SpawnInfoGroup();
					spawnInfoGroup.prefab = array4[j];
					spawnInfoGroup.candidates = new List<SpawnInfo>();
				}
				array5[j] = spawnInfoGroup;
			}
			SpawnInfoGroup[] array6 = array5;
			foreach (SpawnInfoGroup spawnInfoGroup3 in array6)
			{
				if (spawnInfoGroup3.processed)
				{
					continue;
				}
				Prefab<MonumentInfo> prefab3 = spawnInfoGroup3.prefab;
				MonumentInfo component = prefab3.Component;
				if ((Object)(object)component == (Object)null || World.Size < component.MinWorldSize)
				{
					continue;
				}
				int num = 0;
				Vector3 val = Vector3.zero;
				Vector3 val2 = Vector3.zero;
				_ = Vector3.zero;
				float num2 = 0f;
				TerrainPathConnect[] componentsInChildren = prefab3.Object.GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type == InfrastructureType.Road)
					{
						Vector3 val3 = Vector3Ex.XZ3D(((Component)terrainPathConnect).transform.position);
						val += val3;
						num2 += ((Vector3)(ref val3)).magnitude;
						if (num == 0)
						{
							val2 += val3;
						}
						if (num == 1)
						{
							val2 -= val3;
						}
						num++;
					}
				}
				val2 = ((Vector3)(ref val2)).normalized;
				_ = rot90 * val2;
				if (num > 1)
				{
					val /= (float)num;
					num2 /= (float)num;
				}
				foreach (PathList road in TerrainMeta.Path.Roads)
				{
					bool flag = false;
					switch (RoadType)
					{
					case RoadMode.SideRoadOrRingRoad:
						flag = road.Hierarchy == 0 || road.Hierarchy == 1;
						break;
					case RoadMode.SideRoad:
						flag = road.Hierarchy == 1;
						break;
					case RoadMode.RingRoad:
						flag = road.Hierarchy == 0;
						break;
					case RoadMode.SideRoadOrDesireTrail:
						flag = road.Hierarchy == 1 || road.Hierarchy == 2;
						break;
					case RoadMode.DesireTrail:
						flag = road.Hierarchy == 2;
						break;
					}
					if (!flag)
					{
						continue;
					}
					PathInterpolator path = road.Path;
					float num3 = 5f;
					float num4 = 5f;
					float num5 = path.StartOffset + num4 + num2;
					float num6 = path.Length - path.EndOffset - num4 - num2;
					for (float num7 = num5; num7 <= num6; num7 += num3)
					{
						float distance = num7 - num2;
						float distance2 = num7 + num2;
						int prevIndex = path.GetPrevIndex(distance);
						int nextIndex = path.GetNextIndex(distance2);
						Vector3 point = path.GetPoint(prevIndex);
						Vector3 point2 = path.GetPoint(nextIndex);
						Vector3 val4 = (point + point2) * 0.5f;
						Vector3 val5 = point2 - point;
						Vector3 normalized = ((Vector3)(ref val5)).normalized;
						for (int m = -1; m <= 1; m += 2)
						{
							Quaternion val6 = Quaternion.LookRotation((float)m * Vector3Ex.XZ3D(normalized));
							Vector3 val7 = val4;
							Quaternion val8 = val6;
							Vector3 localScale = prefab3.Object.transform.localScale;
							val8 *= Quaternion.LookRotation(val2);
							val7 -= val8 * val;
							SpawnInfo item = default(SpawnInfo);
							item.prefab = prefab3;
							item.position = val7;
							item.rotation = val8;
							item.scale = localScale;
							item.path = path;
							item.pathStartIndex = prevIndex;
							item.pathEndIndex = nextIndex;
							spawnInfoGroup3.candidates.Add(item);
						}
					}
				}
				spawnInfoGroup3.processed = true;
			}
			int num8 = 0;
			List<SpawnInfo> list2 = new List<SpawnInfo>();
			int num9 = 0;
			List<SpawnInfo> list3 = new List<SpawnInfo>();
			for (int n = 0; n < 8; n++)
			{
				num8 = 0;
				list2.Clear();
				array5.Shuffle(ref seed);
				array6 = array5;
				foreach (SpawnInfoGroup spawnInfoGroup4 in array6)
				{
					Prefab<MonumentInfo> prefab4 = spawnInfoGroup4.prefab;
					MonumentInfo component2 = prefab4.Component;
					if ((Object)(object)component2 == (Object)null || World.Size < component2.MinWorldSize)
					{
						continue;
					}
					DungeonGridInfo dungeonEntrance = component2.DungeonEntrance;
					int num10 = (int)((!Object.op_Implicit((Object)(object)prefab4.Parameters)) ? PrefabPriority.Low : (prefab4.Parameters.Priority + 1));
					int num11 = 100000 * num10 * num10 * num10 * num10;
					int num12 = 0;
					int num13 = 0;
					SpawnInfo item2 = default(SpawnInfo);
					ListEx.Shuffle<SpawnInfo>(spawnInfoGroup4.candidates, ref seed);
					for (int num14 = 0; num14 < spawnInfoGroup4.candidates.Count; num14++)
					{
						SpawnInfo spawnInfo = spawnInfoGroup4.candidates[num14];
						DistanceInfo distanceInfo = GetDistanceInfo(list2, prefab4, spawnInfo.position, spawnInfo.rotation, spawnInfo.scale);
						if (distanceInfo.minDistanceSameType < (float)MinDistanceSameType || distanceInfo.minDistanceDifferentType < (float)MinDistanceDifferentType)
						{
							continue;
						}
						int num15 = num11;
						if (distanceInfo.minDistanceSameType != float.MaxValue)
						{
							if (DistanceSameType == DistanceMode.Min)
							{
								num15 -= Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
							else if (DistanceSameType == DistanceMode.Max)
							{
								num15 += Mathf.RoundToInt(distanceInfo.minDistanceSameType * distanceInfo.minDistanceSameType * 2f);
							}
						}
						if (distanceInfo.minDistanceDifferentType != float.MaxValue)
						{
							if (DistanceDifferentType == DistanceMode.Min)
							{
								num15 -= Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
							else if (DistanceDifferentType == DistanceMode.Max)
							{
								num15 += Mathf.RoundToInt(distanceInfo.minDistanceDifferentType * distanceInfo.minDistanceDifferentType);
							}
						}
						if (num15 <= num13 || !prefab4.ApplyTerrainFilters(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) || !prefab4.ApplyTerrainAnchors(ref spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) || !component2.CheckPlacement(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale))
						{
							continue;
						}
						if (Object.op_Implicit((Object)(object)dungeonEntrance))
						{
							Vector3 val9 = spawnInfo.position + spawnInfo.rotation * Vector3.Scale(spawnInfo.scale, ((Component)dungeonEntrance).transform.position);
							Vector3 val10 = dungeonEntrance.SnapPosition(val9);
							ref Vector3 position = ref spawnInfo.position;
							position += val10 - val9;
							if (!dungeonEntrance.IsValidSpawnPosition(val10))
							{
								continue;
							}
						}
						if (prefab4.ApplyTerrainChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, Filter) && prefab4.ApplyWaterChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && prefab4.ApplyEnvironmentVolumeChecks(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale) && !prefab4.CheckEnvironmentVolumes(spawnInfo.position, spawnInfo.rotation, spawnInfo.scale, EnvironmentType.Underground | EnvironmentType.TrainTunnels))
						{
							num13 = num15;
							item2 = spawnInfo;
							num12++;
							if (num12 >= 8 || DistanceDifferentType == DistanceMode.Any)
							{
								break;
							}
						}
					}
					if (num13 > 0)
					{
						list2.Add(item2);
						num8 += num13;
					}
					if (TargetCount > 0 && list2.Count >= TargetCount)
					{
						break;
					}
				}
				if (num8 > num9)
				{
					num9 = num8;
					GenericsUtil.Swap<List<SpawnInfo>>(ref list2, ref list3);
				}
			}
			foreach (SpawnInfo item3 in list3)
			{
				World.AddPrefab("Monument", item3.prefab, item3.position, item3.rotation, item3.scale);
			}
			HashSet<PathInterpolator> hashSet = new HashSet<PathInterpolator>();
			foreach (SpawnInfo item4 in list3)
			{
				item4.path.Straighten(item4.pathStartIndex, item4.pathEndIndex);
				hashSet.Add(item4.path);
			}
			foreach (PathInterpolator item5 in hashSet)
			{
				item5.RecalculateLength();
			}
		}
	}

	private DistanceInfo GetDistanceInfo(List<SpawnInfo> spawns, Prefab<MonumentInfo> prefab, Vector3 monumentPos, Quaternion monumentRot, Vector3 monumentScale)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		DistanceInfo result = default(DistanceInfo);
		result.minDistanceDifferentType = float.MaxValue;
		result.maxDistanceDifferentType = float.MinValue;
		result.minDistanceSameType = float.MaxValue;
		result.maxDistanceSameType = float.MinValue;
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(monumentPos, monumentScale, monumentRot, prefab.Component.Bounds);
		if ((Object)(object)TerrainMeta.Path != (Object)null)
		{
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (!prefab.Component.HasDungeonLink || (!monument.HasDungeonLink && monument.WantsDungeonLink))
				{
					float num = monument.SqrDistance(val);
					if (num < result.minDistanceDifferentType)
					{
						result.minDistanceDifferentType = num;
					}
					if (num > result.maxDistanceDifferentType)
					{
						result.maxDistanceDifferentType = num;
					}
				}
			}
			if (result.minDistanceDifferentType != float.MaxValue)
			{
				result.minDistanceDifferentType = Mathf.Sqrt(result.minDistanceDifferentType);
			}
			if (result.maxDistanceDifferentType != float.MinValue)
			{
				result.maxDistanceDifferentType = Mathf.Sqrt(result.maxDistanceDifferentType);
			}
		}
		if (spawns != null)
		{
			foreach (SpawnInfo spawn in spawns)
			{
				OBB val2 = new OBB(spawn.position, spawn.scale, spawn.rotation, spawn.prefab.Component.Bounds);
				float num2 = ((OBB)(ref val2)).SqrDistance(val);
				if (num2 < result.minDistanceSameType)
				{
					result.minDistanceSameType = num2;
				}
				if (num2 > result.maxDistanceSameType)
				{
					result.maxDistanceSameType = num2;
				}
			}
			if (prefab.Component.HasDungeonLink)
			{
				foreach (MonumentInfo monument2 in TerrainMeta.Path.Monuments)
				{
					if (monument2.HasDungeonLink || !monument2.WantsDungeonLink)
					{
						float num3 = monument2.SqrDistance(val);
						if (num3 < result.minDistanceSameType)
						{
							result.minDistanceSameType = num3;
						}
						if (num3 > result.maxDistanceSameType)
						{
							result.maxDistanceSameType = num3;
						}
					}
				}
				foreach (DungeonGridInfo dungeonGridEntrance in TerrainMeta.Path.DungeonGridEntrances)
				{
					float num4 = dungeonGridEntrance.SqrDistance(monumentPos);
					if (num4 < result.minDistanceSameType)
					{
						result.minDistanceSameType = num4;
					}
					if (num4 > result.maxDistanceSameType)
					{
						result.maxDistanceSameType = num4;
					}
				}
			}
			if (result.minDistanceSameType != float.MaxValue)
			{
				result.minDistanceSameType = Mathf.Sqrt(result.minDistanceSameType);
			}
			if (result.maxDistanceSameType != float.MinValue)
			{
				result.maxDistanceSameType = Mathf.Sqrt(result.maxDistanceSameType);
			}
		}
		return result;
	}
}


using UnityEngine;

public struct SpawnInfo
{
	public Prefab<MonumentInfo> prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public PathInterpolator path;

	public int pathStartIndex;

	public int pathEndIndex;
}


using System.Collections.Generic;

public class SpawnInfoGroup
{
	public bool processed;

	public Prefab<MonumentInfo> prefab;

	public List<SpawnInfo> candidates;
}


private struct DistanceInfo
{
	public float minDistanceSameType;

	public float maxDistanceSameType;

	public float minDistanceDifferentType;

	public float maxDistanceDifferentType;
}


public enum DistanceMode
{
	Any,
	Min,
	Max
}


public enum RoadMode
{
	SideRoadOrRingRoad,
	SideRoad,
	RingRoad,
	SideRoadOrDesireTrail,
	DesireTrail
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlacePowerlineObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	public PathList.SideObject[] Side;

	[FormerlySerializedAs("PowerlineObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> powerlines = TerrainMeta.Path.Powerlines;
		if (World.Networked)
		{
			foreach (PathList item in powerlines)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in powerlines)
		{
			PathList.BasicObject[] start = Start;
			foreach (PathList.BasicObject obj in start)
			{
				item2.TrimStart(obj);
			}
			start = End;
			foreach (PathList.BasicObject obj2 in start)
			{
				item2.TrimEnd(obj2);
			}
			start = Start;
			foreach (PathList.BasicObject obj3 in start)
			{
				item2.SpawnStart(ref seed, obj3);
			}
			start = End;
			foreach (PathList.BasicObject obj4 in start)
			{
				item2.SpawnEnd(ref seed, obj4);
			}
			PathList.PathObject[] path = Path;
			foreach (PathList.PathObject obj5 in path)
			{
				item2.SpawnAlong(ref seed, obj5);
			}
			PathList.SideObject[] side = Side;
			foreach (PathList.SideObject obj6 in side)
			{
				item2.SpawnSide(ref seed, obj6);
			}
			item2.ResetTrims();
		}
	}
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlaceRiverObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	[FormerlySerializedAs("RiversideObjects")]
	public PathList.SideObject[] Side;

	[FormerlySerializedAs("RiverObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> rivers = TerrainMeta.Path.Rivers;
		if (World.Networked)
		{
			foreach (PathList item in rivers)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in rivers)
		{
			PathList.BasicObject[] start = Start;
			foreach (PathList.BasicObject obj in start)
			{
				item2.TrimStart(obj);
			}
			start = End;
			foreach (PathList.BasicObject obj2 in start)
			{
				item2.TrimEnd(obj2);
			}
			start = Start;
			foreach (PathList.BasicObject obj3 in start)
			{
				item2.SpawnStart(ref seed, obj3);
			}
			PathList.PathObject[] path = Path;
			foreach (PathList.PathObject obj4 in path)
			{
				item2.SpawnAlong(ref seed, obj4);
			}
			PathList.SideObject[] side = Side;
			foreach (PathList.SideObject obj5 in side)
			{
				item2.SpawnSide(ref seed, obj5);
			}
			start = End;
			foreach (PathList.BasicObject obj6 in start)
			{
				item2.SpawnEnd(ref seed, obj6);
			}
			item2.ResetTrims();
		}
	}
}


using System.Collections.Generic;
using UnityEngine.Serialization;

public class PlaceRoadObjects : ProceduralComponent
{
	public PathList.BasicObject[] Start;

	public PathList.BasicObject[] End;

	[FormerlySerializedAs("RoadsideObjects")]
	public PathList.SideObject[] Side;

	[FormerlySerializedAs("RoadObjects")]
	public PathList.PathObject[] Path;

	public override void Process(uint seed)
	{
		List<PathList> roads = TerrainMeta.Path.Roads;
		if (World.Networked)
		{
			foreach (PathList item in roads)
			{
				World.Spawn(item.Name, "assets/bundled/prefabs/autospawn/");
			}
			return;
		}
		foreach (PathList item2 in roads)
		{
			if (item2.Hierarchy < 2)
			{
				PathList.BasicObject[] start = Start;
				foreach (PathList.BasicObject obj in start)
				{
					item2.TrimStart(obj);
				}
				start = End;
				foreach (PathList.BasicObject obj2 in start)
				{
					item2.TrimEnd(obj2);
				}
				start = Start;
				foreach (PathList.BasicObject obj3 in start)
				{
					item2.SpawnStart(ref seed, obj3);
				}
				start = End;
				foreach (PathList.BasicObject obj4 in start)
				{
					item2.SpawnEnd(ref seed, obj4);
				}
				PathList.PathObject[] path = Path;
				foreach (PathList.PathObject obj5 in path)
				{
					item2.SpawnAlong(ref seed, obj5);
				}
				PathList.SideObject[] side = Side;
				foreach (PathList.SideObject obj6 in side)
				{
					item2.SpawnSide(ref seed, obj6);
				}
				item2.ResetTrims();
			}
		}
	}
}


using System.Collections.Generic;

public class ProcessMonumentNodes : ProceduralComponent
{
	public override void Process(uint seed)
	{
		List<MonumentNode> monumentNodes = SingletonComponent<WorldSetup>.Instance.MonumentNodes;
		if (!World.Cached)
		{
			for (int i = 0; i < monumentNodes.Count; i++)
			{
				monumentNodes[i].Process(ref seed);
			}
		}
		monumentNodes.Clear();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ProcessProceduralObjects : ProceduralComponent
{
	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		List<ProceduralObject> proceduralObjects = SingletonComponent<WorldSetup>.Instance.ProceduralObjects;
		if (!World.Cached)
		{
			for (int i = 0; i < proceduralObjects.Count; i++)
			{
				ProceduralObject proceduralObject = proceduralObjects[i];
				if (Object.op_Implicit((Object)(object)proceduralObject))
				{
					proceduralObject.Process();
				}
			}
		}
		proceduralObjects.Clear();
	}
}


public class ResetPlacementMap : ProceduralComponent
{
	public override void Process(uint seed)
	{
		TerrainMeta.PlacementMap.Reset();
	}
}


using UnityEngine;

public abstract class ProceduralObject : MonoBehaviour
{
	protected void Awake()
	{
		if (!((Object)(object)SingletonComponent<WorldSetup>.Instance == (Object)null))
		{
			if (SingletonComponent<WorldSetup>.Instance.ProceduralObjects == null)
			{
				Debug.LogError((object)"WorldSetup.Instance.ProceduralObjects is null.", (Object)(object)this);
			}
			else
			{
				SingletonComponent<WorldSetup>.Instance.ProceduralObjects.Add(this);
			}
		}
	}

	public abstract void Process();
}


using UnityEngine;

public class AddToAlphaMap : ProceduralObject
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public override void Process()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		OBB val = default(OBB);
		((OBB)(ref val))..ctor(((Component)this).transform, bounds);
		Vector3 point = ((OBB)(ref val)).GetPoint(-1f, 0f, -1f);
		Vector3 point2 = ((OBB)(ref val)).GetPoint(1f, 0f, -1f);
		Vector3 point3 = ((OBB)(ref val)).GetPoint(-1f, 0f, 1f);
		Vector3 point4 = ((OBB)(ref val)).GetPoint(1f, 0f, 1f);
		TerrainMeta.AlphaMap.ForEachParallel(point, point2, point3, point4, delegate(int x, int z)
		{
			TerrainMeta.AlphaMap.SetAlpha(x, z, 0f);
		});
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class AddToHeightMap : ProceduralObject
{
	public bool DestroyGameObject;

	public void Apply()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		Collider component = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component.bounds;
		int num = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.x));
		int num2 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.x));
		int num3 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.z));
		int num4 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.z));
		Vector3 val = default(Vector3);
		Ray val2 = default(Ray);
		RaycastHit val3 = default(RaycastHit);
		for (int i = num3; i <= num4; i++)
		{
			float normZ = TerrainMeta.HeightMap.Coordinate(i);
			for (int j = num; j <= num2; j++)
			{
				float normX = TerrainMeta.HeightMap.Coordinate(j);
				((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), ((Bounds)(ref bounds)).max.y, TerrainMeta.DenormalizeZ(normZ));
				((Ray)(ref val2))..ctor(val, Vector3.down);
				if (component.Raycast(val2, ref val3, ((Bounds)(ref bounds)).size.y))
				{
					float num5 = TerrainMeta.NormalizeY(((RaycastHit)(ref val3)).point.y);
					float height = TerrainMeta.HeightMap.GetHeight01(j, i);
					if (num5 > height)
					{
						TerrainMeta.HeightMap.SetHeight(j, i, num5);
					}
				}
			}
		}
	}

	public override void Process()
	{
		Apply();
		if (DestroyGameObject)
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
		else
		{
			GameManager.Destroy((Component)(object)this);
		}
	}
}


using UnityEngine;

public class AddToWaterMap : ProceduralObject
{
	public bool automaticallyAddTerrainTopology;

	public override void Process()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		WaterBody component = ((Component)this).GetComponent<WaterBody>();
		Collider component2 = ((Component)this).GetComponent<Collider>();
		Bounds bounds = component2.bounds;
		int mask = (((Object)(object)component != (Object)null) ? component.GetTopologyMask() : 0);
		float num = TerrainMeta.NormalizeY(((Bounds)(ref bounds)).max.y);
		int num2 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.x));
		int num3 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.x));
		int num4 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeX(((Bounds)(ref bounds)).min.z));
		int num5 = TerrainMeta.WaterMap.Index(TerrainMeta.NormalizeZ(((Bounds)(ref bounds)).max.z));
		bool flag = component2 is BoxCollider && ((Component)this).transform.rotation == Quaternion.identity;
		Vector3 val = default(Vector3);
		Ray val2 = default(Ray);
		RaycastHit val3 = default(RaycastHit);
		for (int i = num4; i <= num5; i++)
		{
			float normZ = TerrainMeta.WaterMap.Coordinate(i);
			for (int j = num2; j <= num3; j++)
			{
				float normX = TerrainMeta.WaterMap.Coordinate(j);
				((Vector3)(ref val))..ctor(TerrainMeta.DenormalizeX(normX), ((Bounds)(ref bounds)).max.y + 1f, TerrainMeta.DenormalizeZ(normZ));
				if (!flag)
				{
					((Ray)(ref val2))..ctor(val, Vector3.down);
					if (!component2.Raycast(val2, ref val3, ((Bounds)(ref bounds)).size.y + 1f + 1f))
					{
						continue;
					}
					num = TerrainMeta.NormalizeY(((RaycastHit)(ref val3)).point.y);
				}
				float height = TerrainMeta.HeightMap.GetHeight01(normX, normZ);
				if (num < height - TerrainMeta.OneOverSize.z)
				{
					continue;
				}
				if ((Object)(object)component != (Object)null)
				{
					if (automaticallyAddTerrainTopology)
					{
						TerrainMeta.TopologyMap.AddTopology(normX, normZ, mask);
					}
					if (component.Type == WaterBodyType.Lake && !TerrainMeta.TopologyMap.GetTopology(normX, normZ, 196608))
					{
						continue;
					}
				}
				if (!(TerrainMeta.WaterMap.GetHeight01(j, i) >= num))
				{
					TerrainMeta.WaterMap.SetHeight(j, i, num);
				}
			}
		}
		GameManager.Destroy((Component)(object)this);
	}
}


using Oxide.Core;
using UnityEngine;

public class TerrainGenerator : SingletonComponent<TerrainGenerator>
{
	public TerrainConfig config;

	private const float HeightMapRes = 1f;

	private const float SplatMapRes = 0.5f;

	private const float BaseMapRes = 0.01f;

	public static int GetHeightMapRes()
	{
		return Mathf.Min(4096, Mathf.ClosestPowerOfTwo((int)((float)World.Size * 1f))) + 1;
	}

	public static int GetSplatMapRes()
	{
		return Mathf.Min(2048, Mathf.NextPowerOfTwo((int)((float)World.Size * 0.5f)));
	}

	public static int GetBaseMapRes()
	{
		return Mathf.Min(2048, Mathf.NextPowerOfTwo((int)((float)World.Size * 0.01f)));
	}

	public GameObject CreateTerrain()
	{
		return CreateTerrain(GetHeightMapRes(), GetSplatMapRes());
	}

	public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Expected O, but got Unknown
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		Interface.CallHook("OnTerrainCreate", (object)this);
		Terrain component = Terrain.CreateTerrainGameObject(new TerrainData
		{
			baseMapResolution = GetBaseMapRes(),
			heightmapResolution = heightmapResolution,
			alphamapResolution = alphamapResolution,
			size = new Vector3((float)World.Size, 1000f, (float)World.Size)
		}).GetComponent<Terrain>();
		((Component)component).transform.position = ((Component)this).transform.position + new Vector3((float)(0L - (long)World.Size) * 0.5f, 0f, (float)(0L - (long)World.Size) * 0.5f);
		component.drawInstanced = false;
		component.castShadows = config.CastShadows;
		component.materialType = (MaterialType)3;
		component.materialTemplate = config.Material;
		((Component)component).gameObject.tag = ((Component)this).gameObject.tag;
		((Component)component).gameObject.layer = ((Component)this).gameObject.layer;
		((Collider)((Component)component).gameObject.GetComponent<TerrainCollider>()).sharedMaterial = config.GenericMaterial;
		TerrainMeta terrainMeta = ((Component)component).gameObject.AddComponent<TerrainMeta>();
		((Component)component).gameObject.AddComponent<TerrainPhysics>();
		((Component)component).gameObject.AddComponent<TerrainColors>();
		((Component)component).gameObject.AddComponent<TerrainCollision>();
		((Component)component).gameObject.AddComponent<TerrainBiomeMap>();
		((Component)component).gameObject.AddComponent<TerrainAlphaMap>();
		((Component)component).gameObject.AddComponent<TerrainHeightMap>();
		((Component)component).gameObject.AddComponent<TerrainSplatMap>();
		((Component)component).gameObject.AddComponent<TerrainTopologyMap>();
		((Component)component).gameObject.AddComponent<TerrainWaterMap>();
		((Component)component).gameObject.AddComponent<TerrainPlacementMap>();
		((Component)component).gameObject.AddComponent<TerrainPath>();
		((Component)component).gameObject.AddComponent<TerrainTexturing>();
		((Component)component).gameObject.AddComponent<TerrainWaterFlowMap>();
		terrainMeta.terrain = component;
		terrainMeta.config = config;
		Object.DestroyImmediate((Object)(object)((Component)this).gameObject);
		return ((Component)component).gameObject;
	}
}


