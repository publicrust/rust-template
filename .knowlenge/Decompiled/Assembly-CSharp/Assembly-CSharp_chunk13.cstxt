using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/CookItem")]
public class MissionObjective_CookItem : MissionObjective
{
	[ItemSelector]
	[Tooltip("The cooked result that this objective is looking for (eg cooked chicken, not raw)")]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool checkExistingInventory;

	private bool HasPings
	{
		get
		{
			if (pingEntitiesOnTutorialIsland != null)
			{
				return pingEntitiesOnTutorialIsland.Length != 0;
			}
			return false;
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		if (HasPings)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
				BaseEntityRef[] array = pingEntitiesOnTutorialIsland;
				foreach (BaseEntityRef baseEntityRef in array)
				{
					list.Clear();
					currentTutorialIsland.GetBuildTargets(list, baseEntityRef.Get().prefabID);
					if (list.Count > 0)
					{
						List<BaseOven> list2 = Pool.Get<List<BaseOven>>();
						Vis.Entities(((Component)list[0]).transform.position, 0.25f, list2, 153092352, (QueryTriggerInteraction)2);
						if (list2.Count > 0)
						{
							playerFor.RegisterPingedEntity(list2[0], pingType);
						}
						Pool.FreeUnmanaged<BaseOven>(ref list2);
						break;
					}
				}
				Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
			}
		}
		if (checkExistingInventory)
		{
			int amount = playerFor.inventory.GetAmount(targetItem);
			if (amount > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.COOK, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItem.itemid
				}, amount);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.COOK || IsCompleted(index, instance) || !CanProgress(index, instance) || targetItem.itemid != payload.IntIdentifier)
		{
			return;
		}
		instance.objectiveStatuses[index].progressCurrent += (int)amount;
		if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
		{
			CompleteObjective(index, instance, playerFor);
			if (HasPings)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, pingType);
			}
		}
		playerFor.MissionDirty();
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Craft")]
public class MissionObjective_Craft : MissionObjective
{
	[ItemSelector]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public bool checkExistingInventory;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CRAFT_ITEM || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		foreach (ItemDefinition itemDefinition in array)
		{
			ItemDefinition itemDefinition2 = ItemManager.FindItemDefinition(payload.IntIdentifier);
			bool flag = (Object)(object)itemDefinition2 != (Object)null && (Object)(object)itemDefinition2.isRedirectOf != (Object)null && itemDefinition2.isRedirectOf.itemid == itemDefinition.itemid;
			if (itemDefinition.itemid == payload.IntIdentifier || flag)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (checkExistingInventory)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			if (num > 0)
			{
				ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CRAFT_ITEM, new BaseMission.MissionEventPayload
				{
					IntIdentifier = targetItems[0].itemid
				}, num);
			}
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Deploy")]
public class MissionObjective_DeployItem : MissionObjective
{
	public BaseEntity[] PossibleOptions = new BaseEntity[0];

	public ItemDefinition[] PossibleItems = new ItemDefinition[0];

	public int RequiredAmount = 1;

	public bool PingTutorialTargets;

	private const BasePlayer.PingType PingType = BasePlayer.PingType.Build;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.DEPLOY && Matches(payload))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (PingTutorialTargets)
			{
				UpdatePings(playerFor);
			}
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	private bool Matches(BaseMission.MissionEventPayload payload)
	{
		BaseEntity[] possibleOptions = PossibleOptions;
		for (int i = 0; i < possibleOptions.Length; i++)
		{
			if (possibleOptions[i].prefabID == payload.UintIdentifier)
			{
				return true;
			}
		}
		ItemDefinition itemDefinition = null;
		ItemDefinition[] possibleItems = PossibleItems;
		foreach (ItemDefinition itemDefinition2 in possibleItems)
		{
			if (itemDefinition2.itemid == payload.IntIdentifier)
			{
				return true;
			}
			if ((Object)(object)itemDefinition == (Object)null)
			{
				itemDefinition = ItemManager.FindItemDefinition(payload.IntIdentifier);
			}
			if ((Object)(object)itemDefinition != (Object)null && (Object)(object)itemDefinition.isRedirectOf == (Object)(object)itemDefinition2)
			{
				return true;
			}
		}
		return false;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (PingTutorialTargets)
		{
			UpdatePings(playerFor);
		}
	}

	private void UpdatePings(BasePlayer playerFor)
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		List<TutorialBuildTarget> list = Pool.Get<List<TutorialBuildTarget>>();
		BaseEntity[] possibleOptions = PossibleOptions;
		foreach (BaseEntity baseEntity in possibleOptions)
		{
			currentTutorialIsland.GetBuildTargets(list, baseEntity.prefabID);
		}
		foreach (TutorialBuildTarget item in list)
		{
			item.UpdateActive(playerFor);
			if (((Component)item).gameObject.activeSelf)
			{
				playerFor.AddPingAtLocation(BasePlayer.PingType.Build, ((Component)item).transform.position, 86400f, currentTutorialIsland.net.ID);
			}
			else
			{
				playerFor.RemovePingAtLocation(BasePlayer.PingType.Build, ((Component)item).transform.position, 0.5f, currentTutorialIsland.net.ID);
			}
		}
		Pool.FreeUnmanaged<TutorialBuildTarget>(ref list);
	}
}


using UnityEngine;

public class MissionObjective_EnterTrigger : MissionObjective
{
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		instance.missionLocation = instance.GetMissionPoint(positionName, playerFor);
		playerFor.MissionDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, instance.missionLocation, 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!ShouldThink(index, instance) || type != BaseMission.MissionEventType.ENTER_TRIGGER || ((Object)(object)requiredMountable != (Object)null && (!playerFor.isMounted || playerFor.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		CompleteObjective(index, instance, playerFor);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.RemovePingAtLocation(pingType, instance.missionLocation, float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Equip Clothing")]
public class MissionObjective_EquipClothing : MissionObjective
{
	public ItemDefinition[] RequiredItems = new ItemDefinition[0];

	public bool CheckExistingClothingOnStart = true;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		if (CheckExistingClothingOnStart)
		{
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.CLOTHINGCHANGED, default(BaseMission.MissionEventPayload), 0f);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (IsCompleted(index, instance) || !CanProgress(index, instance) || type != BaseMission.MissionEventType.CLOTHINGCHANGED)
		{
			return;
		}
		ItemDefinition[] requiredItems = RequiredItems;
		foreach (ItemDefinition searchFor in requiredItems)
		{
			if (!playerFor.inventory.containerWear.HasItem(searchFor))
			{
				return;
			}
		}
		CompleteObjective(index, instance, playerFor);
		playerFor.MissionDirty();
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Fill Tutorial TC")]
public class MissionObjective_FillTutorialToolCupboard : MissionObjective
{
	public int RequiredUpkeepHours = 24;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredUpkeepHours;
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance))
		{
			return;
		}
		BuildingPrivlidge buildingPrivilege = assignee.GetBuildingPrivilege();
		if (!((Object)(object)buildingPrivilege != (Object)null))
		{
			return;
		}
		int num = Mathf.RoundToInt(buildingPrivilege.GetProtectedMinutes() / 60f);
		if (num != Mathf.RoundToInt(instance.objectiveStatuses[index].progressCurrent))
		{
			instance.objectiveStatuses[index].progressCurrent = num;
			if (num >= RequiredUpkeepHours)
			{
				CompleteObjective(index, instance, assignee);
			}
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/FreeCrate")]
public class MissionObjective_FreeCrate : MissionObjective
{
	public int targetAmount;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetAmount;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.FREE_CRATE && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += (int)amount;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)targetAmount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Harvest")]
public class MissionObjective_Harvest : MissionObjective
{
	[ItemSelector]
	public ItemDefinition[] targetItems;

	public int targetItemAmount;

	public ItemDefinition[] pingResourceDispensers;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public bool countExisting;

	public override void PostServerLoad(BasePlayer player, BaseMission.MissionInstance.ObjectiveStatus status)
	{
		base.PostServerLoad(player, status);
		if (status.started && !status.completed)
		{
			InitialiseResourcePings(player);
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		InitialiseResourcePings(playerFor);
		if (countExisting && targetItems.Length != 0)
		{
			int num = 0;
			ItemDefinition[] array = targetItems;
			foreach (ItemDefinition definition in array)
			{
				num += playerFor.inventory.GetAmount(definition);
			}
			ProcessMissionEvent(playerFor, instance, index, BaseMission.MissionEventType.HARVEST, new BaseMission.MissionEventPayload
			{
				IntIdentifier = targetItems[0].itemid
			}, num);
		}
	}

	private void InitialiseResourcePings(BasePlayer forPlayer)
	{
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				forPlayer.EnableResourcePings(forItem, pingType);
			}
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HARVEST || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		ItemDefinition[] array = targetItems;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i].itemid == payload.IntIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)targetItemAmount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (pingResourceDispensers != null)
		{
			ItemDefinition[] array = pingResourceDispensers;
			foreach (ItemDefinition forItem in array)
			{
				playerFor.DisableResourcePings(forItem, pingType);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HaveItem")]
public class MissionObjective_HaveItem : MissionObjective
{
	[ItemSelector]
	public ItemDefinition targetItem;

	public int targetItemAmount;

	public bool canBeReset = true;

	public BaseEntityRef[] pingEntitiesOnTutorialIsland;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetItemAmount;
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || (Object)(object)targetItem == (Object)null)
		{
			return;
		}
		int amount = assignee.inventory.GetAmount(targetItem.itemid);
		bool completed = instance.objectiveStatuses[index].completed;
		bool flag = amount >= targetItemAmount;
		if (!canBeReset && completed)
		{
			return;
		}
		if (completed != flag)
		{
			if (flag)
			{
				CompleteObjective(index, instance, assignee);
			}
			else
			{
				ResetObjective(index, instance, assignee);
			}
		}
		if (amount != (int)instance.objectiveStatuses[index].progressCurrent)
		{
			instance.objectiveStatuses[index].progressCurrent = amount;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Heal")]
public class MissionObjective_Heal : MissionObjective
{
	[Range(0f, 1f)]
	public float RequiredHealthNormalised = 0.5f;

	public BaseEntityRef RequireHealSource;

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (!IsCompleted(index, instance) && CanProgress(index, instance) && type == BaseMission.MissionEventType.HEAL && (RequireHealSource == null || RequireHealSource.Get().prefabID == payload.UintIdentifier) && playerFor.healthFraction >= RequiredHealthNormalised)
		{
			CompleteObjective(index, instance, playerFor);
			playerFor.MissionDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtEntityType")]
public class MissionObjective_HurtEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (!baseCombatEntity.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == baseCombatEntity.prefabID)
			{
				instance.objectiveStatuses[index].progressCurrent += amount;
				if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/HurtMissionEntity")]
public class MissionObjective_HurtMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public float targetDamage = 1f;

	public bool shouldUpdateMissionLocation = true;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = targetDamage;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.HURT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = missionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseCombatEntity> entityRef = default(EntityRef<BaseCombatEntity>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseCombatEntity> entityRef2 = entityRef;
		BaseCombatEntity baseCombatEntity = entityRef2.Get(serverside: true);
		if (baseCombatEntity.IsValid() && baseCombatEntity.EqualNetID((BaseNetworkable)entity))
		{
			instance.objectiveStatuses[index].progressCurrent += amount;
			if (instance.objectiveStatuses[index].progressCurrent >= targetDamage)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)missionEntity).transform.position;
			if (position != instance.missionLocation)
			{
				instance.missionLocation = position;
				assignee.MissionDirty();
			}
		}
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Ignite Oven")]
public class MissionObjective_IgniteOven : MissionObjective
{
	public BaseEntityRef TargetOven;

	public bool PingTarget;

	public BasePlayer.PingType PingType = BasePlayer.PingType.GoTo;

	private Func<BaseCombatEntity, bool> searchFilter;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => e.IsAlive() && e.prefabID == TargetOven.resourceID;
		}
		if (PingTarget && TryFindNearby(((Component)forPlayer).transform.position, searchFilter, out var entity, 200f))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			forPlayer.RegisterPingedEntity(entity, PingType);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.STARTOVEN || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		if (TargetOven.resourceID == payload.UintIdentifier)
		{
			CompleteObjective(index, instance, playerFor);
			if (PingTarget)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
		playerFor.MissionDirty();
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Kill")]
public class MissionObjective_KillEntity : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToKill;

	public bool shouldUpdateMissionLocation;

	public bool pingTargets;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseCombatEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = numToKill;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.KILL_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		uint[] array = targetPrefabIDs;
		for (int i = 0; i < array.Length; i++)
		{
			if (array[i] == payload.UintIdentifier)
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToKill)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		EnsureInitialized();
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseCombatEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue && e.IsAlive();
		}
		if (IsCompleted(index, instance))
		{
			return;
		}
		assignee.DeregisterPingedEntitiesOfType(BasePlayer.PingType.Hostile);
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity, pingTargets ? 200f : 20f))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
			if (pingTargets)
			{
				assignee.RegisterPingedEntity(entity, BasePlayer.PingType.Hostile);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Metal Detector")]
public class MissionObjective_MetalDetectorFind : MissionObjective
{
	public int RequiredFinds = 3;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredFinds;
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.METAL_DETECTOR_FIND && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= instance.objectiveStatuses[index].progressTarget)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
		}
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountEntityType")]
public class MissionObjective_MountEntityType : MissionObjective
{
	public BaseEntityRef[] targetEntities;

	public int numToMount = 1;

	public bool shouldUpdateMissionLocation = true;

	private bool isInitalized;

	private uint[] targetPrefabIDs;

	private Func<BaseEntity, bool> searchFilter;

	private void EnsureInitialized()
	{
		if (!isInitalized)
		{
			isInitalized = true;
			targetPrefabIDs = (from e in targetEntities
				where e.isValid
				select e.Get().prefabID).ToArray();
		}
	}

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		if (numToMount > 1)
		{
			instance.objectiveStatuses[index].progressTarget = numToMount;
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		EnsureInitialized();
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (!baseMountable.IsValid())
		{
			return;
		}
		uint[] array = targetPrefabIDs;
		foreach (uint num in array)
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (num == baseMountable.prefabID || (!((Object)(object)baseVehicle == (Object)null) && num == baseVehicle.prefabID))
			{
				instance.objectiveStatuses[index].progressCurrent += (int)amount;
				if (instance.objectiveStatuses[index].progressCurrent >= (float)numToMount)
				{
					CompleteObjective(index, instance, playerFor);
				}
				playerFor.MissionDirty();
				break;
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!shouldUpdateMissionLocation || !IsStarted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		if (searchFilter == null)
		{
			searchFilter = (BaseEntity e) => List.TryFindWith<uint, uint>((IReadOnlyCollection<uint>)(object)targetPrefabIDs, (Func<uint, uint>)((uint id) => id), e.prefabID, (IEqualityComparer<uint>)null).HasValue;
		}
		if (TryFindNearby(((Component)assignee).transform.position, searchFilter, out var entity))
		{
			instance.missionLocation = ((Component)entity).transform.position;
			assignee.MissionDirty();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/MountMissionEntity")]
public class MissionObjective_MountMissionEntity : MissionObjective
{
	public string targetIdentifier;

	public bool shouldUpdateMissionLocation = true;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.GetMissionEntity(targetIdentifier, playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.MOUNT_ENTITY || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, playerFor);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		BaseEntity entity = missionEntity.GetEntity();
		if (!entity.IsValid())
		{
			FailObjective(index, instance, playerFor);
			return;
		}
		EntityRef<BaseMountable> entityRef = default(EntityRef<BaseMountable>);
		entityRef.uid = payload.NetworkIdentifier;
		EntityRef<BaseMountable> entityRef2 = entityRef;
		BaseMountable baseMountable = entityRef2.Get(serverside: true);
		if (baseMountable.IsValid())
		{
			BaseVehicle baseVehicle = baseMountable.VehicleParent();
			if (baseMountable.EqualNetID((BaseNetworkable)entity) || ((Object)(object)baseVehicle != (Object)null && baseVehicle.EqualNetID((BaseNetworkable)entity)))
			{
				CompleteObjective(index, instance, playerFor);
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!IsStarted(index, instance) || IsCompleted(index, instance))
		{
			return;
		}
		ref RealTimeSince sinceLastThink = ref instance.objectiveStatuses[index].sinceLastThink;
		if (RealTimeSince.op_Implicit(sinceLastThink) < 1f)
		{
			return;
		}
		sinceLastThink = RealTimeSince.op_Implicit(0f);
		MissionEntity missionEntity = instance.GetMissionEntity(targetIdentifier, assignee);
		if ((Object)(object)missionEntity == (Object)null)
		{
			FailObjective(index, instance, assignee);
		}
		else if (shouldUpdateMissionLocation)
		{
			Vector3 position = ((Component)missionEntity).transform.position;
			if (position != instance.missionLocation)
			{
				instance.missionLocation = position;
				assignee.MissionDirty();
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Move")]
public class MissionObjective_Move : MissionObjective
{
	[BaseMission.PositionGenerator.PositionPoint]
	public string positionName = "default";

	public float distForCompletion = 3f;

	public bool use2D;

	public BaseMountable requiredMountable;

	public bool shouldPing;

	public BasePlayer.PingType pingType = BasePlayer.PingType.GoTo;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		instance.missionLocation = instance.GetMissionPoint(positionName, playerFor);
		playerFor.MissionDirty();
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				playerFor.AddPingAtLocation(pingType, instance.missionLocation, 86400f, currentTutorialIsland.net.ID);
			}
		}
	}

	public override void Think(int index, BaseMission.MissionInstance instance, BasePlayer assignee, float delta)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		base.Think(index, instance, assignee, delta);
		if (!ShouldThink(index, instance) || ((Object)(object)requiredMountable != (Object)null && (!assignee.isMounted || assignee.GetMounted().prefabID != requiredMountable.prefabID)))
		{
			return;
		}
		Vector3 missionPoint = instance.GetMissionPoint(positionName, assignee);
		if (!((use2D ? Vector3Ex.Distance2D(missionPoint, ((Component)assignee).transform.position) : Vector3.Distance(missionPoint, ((Component)assignee).transform.position)) <= distForCompletion))
		{
			return;
		}
		CompleteObjective(index, instance, assignee);
		if (shouldPing)
		{
			TutorialIsland currentTutorialIsland = assignee.GetCurrentTutorialIsland();
			if ((Object)(object)currentTutorialIsland != (Object)null)
			{
				assignee.RemovePingAtLocation(pingType, instance.missionLocation, float.MaxValue, currentTutorialIsland.net.ID);
			}
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Open Tutorial Storage")]
public class MissionObjective_OpenTutorialStorageContainer : MissionObjective
{
	public ItemAmount[] Items;

	public BaseEntity TargetEntity;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			currentTutorialIsland.TutorialContainer.LoadStorage(Items);
		}
		playerFor.RegisterPingedEntity(currentTutorialIsland.TutorialContainer, BasePlayer.PingType.Loot);
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	private void DeregisterPing(BasePlayer playerFor)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		TutorialIsland currentTutorialIsland = playerFor.GetCurrentTutorialIsland();
		if ((Object)(object)currentTutorialIsland != (Object)null && (Object)(object)currentTutorialIsland.TutorialContainer != (Object)null)
		{
			playerFor.DeregisterPingedEntity(currentTutorialIsland.TutorialContainer.net.ID, BasePlayer.PingType.Loot);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		DeregisterPing(playerFor);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.OPEN_STORAGE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.UintIdentifier == TargetEntity.prefabID)
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/PlayerInput")]
public class MissionObjective_PlayerInput : MissionObjective
{
	public BUTTON requiredButton;

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveStarted(playerFor, index, instance);
		instance.EnablePlayerInput();
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		instance.DisablePlayerInput();
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.PLAYER_TICK && !IsCompleted(index, instance) && CanProgress(index, instance) && playerFor.serverInput.IsDown(requiredButton))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Respawn")]
public class MissionObjective_Respawn : MissionObjective
{
	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.RESPAWN && !IsCompleted(index, instance) && CanProgress(index, instance))
		{
			CompleteObjective(index, instance, playerFor);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Retrieve Items from corpse")]
public class MissionObjective_RetrieveItemsFromCorpse : MissionObjective
{
	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ObjectiveStarted(playerFor, index, instance);
		if (playerFor.ServerCurrentDeathNote == null)
		{
			return;
		}
		List<PlayerCorpse> list = Pool.Get<List<PlayerCorpse>>();
		Vis.Entities(playerFor.ServerCurrentDeathNote.worldPosition, 3f, list, 512, (QueryTriggerInteraction)2);
		foreach (PlayerCorpse item in list)
		{
			if ((Object)(object)item != (Object)null && item.isServer)
			{
				playerFor.RegisterPingedEntity(item, BasePlayer.PingType.Loot);
				break;
			}
		}
		Pool.FreeUnmanaged<PlayerCorpse>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.OPEN_STORAGE || IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseNetworkable baseNetworkable = BaseNetworkable.serverEntities.Find(payload.NetworkIdentifier);
		if ((Object)(object)baseNetworkable != (Object)null)
		{
			bool flag = baseNetworkable is PlayerCorpse playerCorpse && playerCorpse.playerSteamID == (ulong)playerFor.userID;
			if (!flag && baseNetworkable is DroppedItemContainer droppedItemContainer && droppedItemContainer.playerSteamID == (ulong)playerFor.userID)
			{
				flag = true;
			}
			if (flag)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, BasePlayer.PingType.Loot);
				CompleteObjective(index, instance, playerFor);
			}
		}
	}
}


using ConVar;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/SpeakWith")]
public class MissionObjective_SpeakWith : MissionObjective
{
	public ItemAmount[] requiredReturnItems = new ItemAmount[0];

	public bool destroyReturnItems;

	public bool showPing;

	public bool checkSpaceForRewards;

	public static Phrase NoSpaceInInventoryPhrase = new Phrase("no_space_mission_reward", "No space for rewards in inventory, please clear some space");

	public override void ObjectiveStarted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = instance.ProviderEntity();
		if (Object.op_Implicit((Object)(object)baseEntity) && !showPing)
		{
			instance.missionLocation = ((Component)baseEntity).transform.position;
			playerFor.MissionDirty();
		}
		base.ObjectiveStarted(playerFor, index, instance);
		if ((Object)(object)baseEntity != (Object)null && showPing)
		{
			playerFor.RegisterPingedEntity(baseEntity, BasePlayer.PingType.GoTo);
		}
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type != BaseMission.MissionEventType.CONVERSATION)
		{
			return;
		}
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"Speak info: IsCompleted:{IsCompleted(index, instance)} CanProgress:{CanProgress(index, instance)}");
		}
		if (IsCompleted(index, instance) || !CanProgress(index, instance))
		{
			return;
		}
		BaseEntity baseEntity = instance.ProviderEntity();
		if (Debugging.printMissionSpeakInfo)
		{
			Debug.Log((object)$"Looking for Provider: {instance.providerID.Value}/{baseEntity} Supplied NPC:{payload.NetworkIdentifier}");
		}
		if (!Object.op_Implicit((Object)(object)baseEntity))
		{
			return;
		}
		IMissionProvider component = ((Component)baseEntity).GetComponent<IMissionProvider>();
		if (component == null || !(component.ProviderID() == payload.NetworkIdentifier) || amount != 1f)
		{
			return;
		}
		bool flag = true;
		if (component.ProviderID() == payload.NetworkIdentifier && amount == 1f)
		{
			ItemAmount[] array = requiredReturnItems;
			foreach (ItemAmount itemAmount in array)
			{
				if ((float)playerFor.inventory.GetAmount(itemAmount.itemDef.itemid) < itemAmount.amount)
				{
					flag = false;
					break;
				}
			}
			if (flag && destroyReturnItems)
			{
				if (!CheckRewardsSpace())
				{
					return;
				}
				array = requiredReturnItems;
				foreach (ItemAmount itemAmount2 in array)
				{
					playerFor.inventory.Take(null, itemAmount2.itemDef.itemid, (int)itemAmount2.amount);
				}
			}
		}
		if (CheckRewardsSpace() && (requiredReturnItems == null || requiredReturnItems.Length == 0 || flag))
		{
			CompleteObjective(index, instance, playerFor);
		}
		bool CheckRewardsSpace()
		{
			if (checkSpaceForRewards && !playerFor.inventory.HasEmptySlots(instance.GetTotalRequiredRewardItemSlots()))
			{
				playerFor.ShowToast(GameTip.Styles.Red_Normal, NoSpaceInInventoryPhrase, false);
				return false;
			}
			return true;
		}
	}

	public override void ObjectiveCompleted(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveCompleted(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}

	private static void DeregisterPing(BasePlayer playerFor, BaseMission.MissionInstance instance)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = instance.ProviderEntity();
		if ((Object)(object)baseEntity != (Object)null)
		{
			playerFor.DeregisterPingedEntity(baseEntity.net.ID, BasePlayer.PingType.GoTo);
		}
	}

	public override void ObjectiveFailed(BasePlayer playerFor, int index, BaseMission.MissionInstance instance)
	{
		base.ObjectiveFailed(playerFor, index, instance);
		if (showPing)
		{
			DeregisterPing(playerFor, instance);
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/OBJECTIVES/Upgrade Building Block")]
public class MissionObjective_UpgradeBuildingBlock : MissionObjective
{
	public bool ShouldPingBlocksLessThanTargetGrade;

	public BasePlayer.PingType PingType;

	public BuildingGrade.Enum TargetGrade;

	public int RequiredCount = 6;

	public override void MissionStarted(int index, BaseMission.MissionInstance instance, BasePlayer forPlayer)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		base.MissionStarted(index, instance, forPlayer);
		instance.objectiveStatuses[index].progressCurrent = 0f;
		instance.objectiveStatuses[index].progressTarget = RequiredCount;
		if (!ShouldPingBlocksLessThanTargetGrade)
		{
			return;
		}
		TutorialIsland currentTutorialIsland = forPlayer.GetCurrentTutorialIsland();
		if (!((Object)(object)currentTutorialIsland != (Object)null))
		{
			return;
		}
		Vector3 worldPosOfBuildTarget = currentTutorialIsland.GetWorldPosOfBuildTarget(0);
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(worldPosOfBuildTarget, 32f, list, 2097152, (QueryTriggerInteraction)2);
		if (list.Count != RequiredCount)
		{
			Debug.LogWarning((object)("Non matching building block count, check RequiredCount on " + ((Object)this).name));
		}
		foreach (BuildingBlock item in list)
		{
			forPlayer.RegisterPingedEntity(item, PingType);
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
	}

	public override void ProcessMissionEvent(BasePlayer playerFor, BaseMission.MissionInstance instance, int index, BaseMission.MissionEventType type, BaseMission.MissionEventPayload payload, float amount)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		base.ProcessMissionEvent(playerFor, instance, index, type, payload, amount);
		if (type == BaseMission.MissionEventType.UPGRADE_BUILDING_GRADE && !IsCompleted(index, instance) && CanProgress(index, instance) && payload.IntIdentifier >= (int)TargetGrade)
		{
			instance.objectiveStatuses[index].progressCurrent += 1f;
			if (instance.objectiveStatuses[index].progressCurrent >= (float)RequiredCount)
			{
				CompleteObjective(index, instance, playerFor);
			}
			playerFor.MissionDirty();
			if (ShouldPingBlocksLessThanTargetGrade)
			{
				playerFor.DeregisterPingedEntity(payload.NetworkIdentifier, PingType);
			}
		}
	}
}


using UnityEngine;

public class PVPMissionManager : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using UnityEngine;

public class TriggerMission : TriggerBase
{
	private BasePlayer cachedPlayer;

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		if ((Object)(object)ent.ToPlayer() != (Object)null)
		{
			cachedPlayer = ent.ToPlayer();
			((FacepunchBehaviour)this).Invoke((Action)DelayedEntityCallback, 0f);
		}
	}

	private void DelayedEntityCallback()
	{
		if ((Object)(object)cachedPlayer != (Object)null)
		{
			cachedPlayer.ProcessMissionEvent(BaseMission.MissionEventType.ENTER_TRIGGER, 0, 0f);
		}
		cachedPlayer = null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Missions/WorldPositionGenerator")]
public class WorldPositionGenerator : ScriptableObject
{
	public SpawnFilter Filter = new SpawnFilter();

	public float FilterCutoff;

	public bool aboveWater;

	public float MaxSlopeRadius;

	public float MaxSlopeDegrees = 90f;

	public float CheckSphereRadius;

	public LayerMask CheckSphereMask;

	private Vector3 _origin;

	private Vector3 _area;

	private ByteQuadtree _quadtree;

	public bool TrySample(Vector3 origin, float minDist, float maxDist, out Vector3 position, List<Vector3> blocked = null)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0191: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		if (_quadtree == null)
		{
			PrecalculatePositions();
		}
		Rect inclusion = new Rect(origin.x - maxDist, origin.z - maxDist, maxDist * 2f, maxDist * 2f);
		Rect exclusion = new Rect(origin.x - minDist, origin.z - minDist, minDist * 2f, minDist * 2f);
		List<Rect> blockedRects = Pool.Get<List<Rect>>();
		if (blocked != null)
		{
			float num = 10f;
			Rect item = default(Rect);
			foreach (Vector3 item2 in blocked)
			{
				((Rect)(ref item))..ctor(item2.x - num, item2.z - num, num * 2f, num * 2f);
				blockedRects.Add(item);
			}
		}
		List<ByteQuadtree.Element> candidates = Pool.Get<List<ByteQuadtree.Element>>();
		candidates.Add(_quadtree.Root);
		for (int i = 0; i < candidates.Count; i++)
		{
			ByteQuadtree.Element element2 = candidates[i];
			if (!element2.IsLeaf)
			{
				ListEx.RemoveUnordered<ByteQuadtree.Element>(candidates, i--);
				EvaluateCandidate(element2.Child1);
				EvaluateCandidate(element2.Child2);
				EvaluateCandidate(element2.Child3);
				EvaluateCandidate(element2.Child4);
			}
		}
		if (candidates.Count == 0)
		{
			position = origin;
			Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
			Pool.FreeUnmanaged<Rect>(ref blockedRects);
			return false;
		}
		Vector3 val2;
		if (CheckSphereRadius <= float.Epsilon)
		{
			ByteQuadtree.Element random = ListEx.GetRandom<ByteQuadtree.Element>(candidates);
			Rect val = GetElementRect(random);
			val2 = Vector3Ex.XZ3D(((Rect)(ref val)).min + ((Rect)(ref val)).size * new Vector2(Random.value, Random.value));
		}
		else
		{
			Vector3 val4;
			while (true)
			{
				if (candidates.Count == 0)
				{
					position = Vector3.zero;
					return false;
				}
				int index = Random.Range(0, candidates.Count);
				ByteQuadtree.Element element3 = candidates[index];
				Rect val3 = GetElementRect(element3);
				val4 = Vector3Ex.XZ3D(((Rect)(ref val3)).center);
				val4.y = TerrainMeta.HeightMap.GetHeight(val4);
				if (!Physics.CheckSphere(val4, CheckSphereRadius, ((LayerMask)(ref CheckSphereMask)).value))
				{
					break;
				}
				candidates.RemoveAt(index);
			}
			val2 = val4;
		}
		position = Vector3Ex.WithY(val2, aboveWater ? WaterLevel.GetWaterOrTerrainSurface(val2, waves: false, volumes: false) : TerrainMeta.HeightMap.GetHeight(val2));
		Pool.FreeUnmanaged<ByteQuadtree.Element>(ref candidates);
		Pool.FreeUnmanaged<Rect>(ref blockedRects);
		return true;
		void EvaluateCandidate(ByteQuadtree.Element child)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_006a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0074: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (child.Value != 0)
			{
				Rect val5 = GetElementRect(child);
				if (((Rect)(ref val5)).Overlaps(inclusion) && (!((Rect)(ref exclusion)).Contains(((Rect)(ref val5)).min) || !((Rect)(ref exclusion)).Contains(((Rect)(ref val5)).max)))
				{
					if (blockedRects.Count > 0)
					{
						foreach (Rect item3 in blockedRects)
						{
							Rect current2 = item3;
							if (((Rect)(ref current2)).Contains(((Rect)(ref val5)).min) && ((Rect)(ref current2)).Contains(((Rect)(ref val5)).max))
							{
								return;
							}
						}
					}
					candidates.Add(child);
				}
			}
		}
		Rect GetElementRect(ByteQuadtree.Element element)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			int num2 = 1 << element.Depth;
			float num3 = 1f / (float)num2;
			Vector2 val6 = element.Coords * num3;
			return new Rect(_origin.x + val6.x * _area.x, _origin.z + val6.y * _area.z, _area.x * num3, _area.z * num3);
		}
	}

	public void PrecalculatePositions()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		int res = Mathf.NextPowerOfTwo((int)((float)World.Size * 0.25f));
		byte[] map = new byte[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				float normX = ((float)i + 0.5f) / (float)res;
				float normZ = ((float)z + 0.5f) / (float)res;
				float factor = Filter.GetFactor(normX, normZ);
				if (factor > 0f && MaxSlopeRadius > 0f)
				{
					TerrainMeta.HeightMap.ForEach(normX, normZ, MaxSlopeRadius / (float)res, delegate(int slopeX, int slopeZ)
					{
						if (TerrainMeta.HeightMap.GetSlope(slopeX, slopeZ) > MaxSlopeDegrees)
						{
							factor = 0f;
						}
					});
				}
				map[z * res + i] = (byte)((factor >= FilterCutoff) ? (255f * factor) : 0f);
			}
		});
		_origin = TerrainMeta.Position;
		_area = TerrainMeta.Size;
		_quadtree = new ByteQuadtree();
		_quadtree.UpdateValues(map);
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CargoShipContainer : BaseEntity
{
	public GameObject[] DressingVariants;

	public const Flags Descending = Flags.Reserved1;

	public const Flags Targeted = Flags.Reserved2;

	private int dressingVariant;

	public override float MaxVelocity()
	{
		return 1f;
	}

	public override void PreInitShared()
	{
		base.PreInitShared();
		AssignVariant();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		UpdateDressingVariant();
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		UpdateDressingVariant();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.cargoShipContainer = Pool.Get<CargoShipContainer>();
		info.msg.cargoShipContainer.dressingVariant = dressingVariant;
	}

	private void AssignVariant()
	{
		dressingVariant = Random.Range(0, DressingVariants.Length);
	}

	public void ToggleHurtCollider(bool state)
	{
		SetFlag(Flags.Reserved1, state);
	}

	public void SetTargeted(bool state)
	{
		SetFlag(Flags.Reserved2, state);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.cargoShipContainer != null)
		{
			dressingVariant = info.msg.cargoShipContainer.dressingVariant;
		}
		UpdateDressingVariant();
	}

	private void UpdateDressingVariant()
	{
		for (int i = 0; i < DressingVariants.Length; i++)
		{
			DressingVariants[i].SetActive(dressingVariant == i);
		}
	}
}


public class CargoShipContainerSounds : FacepunchBehaviour, IClientComponent
{
	public SoundDefinition liftDef;

	public SoundDefinition dropDef;
}


using UnityEngine;

public class HarborBridgeSounds : MonoBehaviour, IClientComponent
{
	public HarborProximityEntity bridge;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;
}


using UnityEngine;

public class HarborCrane : HarborProximityEntity
{
	public Transform CraneGrab;

	public Transform ArmRoot;

	public Transform ArmSupportLower;

	public Transform ArmSupportUpper;

	public TransformLineRenderer[] LineRenderers;

	protected void UpdateArmSupports(Vector3 fwd)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)ArmSupportUpper == (Object)null) && !((Object)(object)ArmSupportLower == (Object)null))
		{
			Vector3 val = ArmSupportUpper.position - ArmSupportLower.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			ArmSupportLower.rotation = Quaternion.LookRotation(fwd, normalized);
			ArmSupportUpper.rotation = Quaternion.LookRotation(fwd, normalized);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneContainerPickup : HarborCrane
{
	public struct ContainerStack
	{
		public Transform RootPoint;

		public int MaxStackSize;

		public int CurrentStackSize { get; set; }
	}

	private struct QueuedMove
	{
		public EntityRef<CargoShipContainer> TargetEntity;

		public Vector3 TargetWorldPosition;

		public Quaternion TargetWorldRotation;

		public bool HasTarget;
	}

	private enum PickupState
	{
		RotateToFace,
		Lift,
		RotateToTarget,
		Drop,
		Reset
	}

	public Transform ServerTowerGrab;

	public float LockTime = 5f;

	public float MaxMoveDistance = 32f;

	public float PickedUpObjectRotationSpeed = 30f;

	private List<ContainerStack> Stacks;

	public GameObjectRef ContainerPrefab;

	private const float ContainerSize = 3f;

	public int MaxContainerStackSize = 3;

	public bool DebugContainerSpawns;

	public bool DebugContainerDestinations;

	private Vector3 grabOffset = new Vector3(0f, 19f, 0f);

	public static ListHashSet<HarborCraneContainerPickup> AllCranes = new ListHashSet<HarborCraneContainerPickup>();

	private Vector3 startForward;

	private List<QueuedMove> movesToMake = new List<QueuedMove>();

	private QueuedMove? moveInProcess;

	private EntityRef<CargoShip> toParent;

	private float moveDelay;

	private PickupState currentPickupState;

	private float lockOnTime;

	private float maxTargetHeight;

	public override void ServerInit()
	{
		base.ServerInit();
		AllCranes.Add(this);
		List<HarborCraneContainerSpawnPoint> list = Pool.Get<List<HarborCraneContainerSpawnPoint>>();
		FindNearbyContainerSpawns(list);
		Stacks = new List<ContainerStack>();
		foreach (HarborCraneContainerSpawnPoint item in list)
		{
			Stacks.Add(new ContainerStack
			{
				RootPoint = ((Component)item).transform,
				MaxStackSize = item.MaxStackSize
			});
		}
		Pool.FreeUnmanaged<HarborCraneContainerSpawnPoint>(ref list);
		UpdateArm();
		SendNetworkUpdate();
	}

	public override void PostMapEntitySpawn()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.PostMapEntitySpawn();
		startForward = ((Component)this).transform.forward;
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		AllCranes.Remove(this);
	}

	private void FindNearbyContainerSpawns(List<HarborCraneContainerSpawnPoint> foundPoints)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		Vis.Components<HarborCraneContainerSpawnPoint>(((Component)this).transform.position, MaxMoveDistance, foundPoints, 1218652417, (QueryTriggerInteraction)2);
	}

	private void ReplenishContainers(int totalContainers)
	{
		for (int i = 0; i < Stacks.Count; i++)
		{
			ContainerStack value = Stacks[i];
			value.CurrentStackSize = 0;
			Stacks[i] = value;
		}
		maxTargetHeight = 0f;
		int count = Stacks.Count;
		if (count == 0)
		{
			return;
		}
		int num = Random.Range(0, count);
		int num2 = 0;
		while (totalContainers > 0 && num2 < 50)
		{
			num2++;
			num++;
			if (num >= count)
			{
				num = 0;
			}
			ContainerStack containerStack = Stacks[num];
			if (SpawnContainerOnStack(containerStack))
			{
				containerStack.CurrentStackSize++;
				totalContainers--;
				Stacks[num] = containerStack;
			}
		}
		movesToMake.Reverse();
		bool SpawnContainerOnStack(ContainerStack stack)
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_00af: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_011a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			if (stack.CurrentStackSize >= MaxContainerStackSize || stack.CurrentStackSize >= stack.MaxStackSize)
			{
				return false;
			}
			if (CargoShip.docking_debug)
			{
				Debug.Log((object)$"Spawning container on stack {stack.RootPoint.position}");
			}
			Vector3 position = stack.RootPoint.position;
			position.y += (float)stack.CurrentStackSize * 3f;
			List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
			Vis.Entities(new OBB(position, stack.RootPoint.rotation, new Bounds(new Vector3(0f, 1.5f, 0f), new Vector3(4.5f, 1.5f, 1.5f) * 0.8f)), list, 1218685185, (QueryTriggerInteraction)2);
			bool num3 = list.Count == 0;
			if (!num3 && CargoShip.docking_debug)
			{
				Debug.Log((object)("Container spawn blocked by " + ((Object)((Component)list[0]).gameObject).name), (Object)(object)list[0]);
			}
			Pool.FreeUnmanaged<BaseEntity>(ref list);
			if (!num3)
			{
				return false;
			}
			CargoShipContainer cargoShipContainer = GameManager.server.CreateEntity(ContainerPrefab.resourcePath, position, stack.RootPoint.rotation) as CargoShipContainer;
			cargoShipContainer.Spawn();
			QueuedMove item = default(QueuedMove);
			item.TargetEntity.Set(cargoShipContainer);
			item.HasTarget = false;
			movesToMake.Add(item);
			return true;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = ServerTowerGrab.localPosition.z;
		info.msg.harborCrane.height = ServerTowerGrab.localPosition.y;
		info.msg.harborCrane.time = GetNetworkTime();
		info.msg.harborCrane.maxMoveHeight = maxTargetHeight;
		info.msg.harborCrane.toParent = toParent.uid;
		info.msg.harborCrane.startForward = startForward;
		info.msg.harborCrane.moveDelay = moveDelay;
		if (moveInProcess.HasValue)
		{
			info.msg.harborCrane.currentMove = Pool.Get<QueuedMove>();
			CreateMove(moveInProcess.Value, info.msg.harborCrane.currentMove);
		}
		if (movesToMake.Count > 0)
		{
			info.msg.harborCrane.queuedMoves = Pool.Get<List<QueuedMove>>();
			foreach (QueuedMove item in movesToMake)
			{
				QueuedMove val = Pool.Get<QueuedMove>();
				CreateMove(item, val);
				info.msg.harborCrane.queuedMoves.Add(val);
			}
		}
		info.msg.harborCrane.currentPickupState = (int)currentPickupState;
	}

	private QueuedMove CreateMove(QueuedMove from)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		QueuedMove result = default(QueuedMove);
		result.TargetEntity = new EntityRef<CargoShipContainer>(from.targetEntity);
		result.TargetWorldPosition = from.targetWorldPosition;
		result.TargetWorldRotation = new Quaternion(from.targetWorldRotation.x, from.targetWorldRotation.y, from.targetWorldRotation.z, from.targetWorldRotation.w);
		result.HasTarget = from.hasTarget;
		return result;
	}

	private void CreateMove(QueuedMove move, QueuedMove target)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		target.hasTarget = move.HasTarget;
		target.targetEntity = move.TargetEntity.uid;
		target.targetWorldPosition = move.TargetWorldPosition;
		target.targetWorldRotation = new Vector4(move.TargetWorldRotation.x, move.TargetWorldRotation.y, move.TargetWorldRotation.z, move.TargetWorldRotation.w);
	}

	private void CountdownDelay()
	{
		moveDelay -= Time.deltaTime;
		if (moveDelay <= 0f)
		{
			moveDelay = 0f;
			((FacepunchBehaviour)this).CancelInvoke((Action)CountdownDelay);
			CheckMoveQueue();
		}
	}

	private void CheckMoveQueue()
	{
		if (moveDelay > 0f && movesToMake.Count > 0 && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		else if (movesToMake.Count > 0 && !IsBusy() && movesToMake[0].HasTarget)
		{
			moveInProcess = movesToMake[0];
			movesToMake.RemoveAt(0);
			currentPickupState = PickupState.RotateToFace;
			lockOnTime = 0f;
			SetFlag(Flags.Busy, b: true);
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
	}

	private void ProcessCraneMovement()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_022e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_0237: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0285: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0348: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0358: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0364: Unknown result type (might be due to invalid IL or missing references)
		//IL_0366: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0371: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0386: Unknown result type (might be due to invalid IL or missing references)
		//IL_03fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0401: Unknown result type (might be due to invalid IL or missing references)
		//IL_0406: Unknown result type (might be due to invalid IL or missing references)
		//IL_040b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0419: Unknown result type (might be due to invalid IL or missing references)
		//IL_041e: Unknown result type (might be due to invalid IL or missing references)
		//IL_042b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_043e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0440: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0467: Unknown result type (might be due to invalid IL or missing references)
		//IL_0469: Unknown result type (might be due to invalid IL or missing references)
		//IL_0476: Unknown result type (might be due to invalid IL or missing references)
		//IL_047b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0483: Unknown result type (might be due to invalid IL or missing references)
		//IL_0496: Unknown result type (might be due to invalid IL or missing references)
		//IL_049c: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_030a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0302: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0584: Unknown result type (might be due to invalid IL or missing references)
		//IL_058a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0594: Unknown result type (might be due to invalid IL or missing references)
		//IL_0599: Unknown result type (might be due to invalid IL or missing references)
		//IL_059e: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_05a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_05b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_05c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_05ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_0618: Unknown result type (might be due to invalid IL or missing references)
		//IL_061d: Unknown result type (might be due to invalid IL or missing references)
		if (!moveInProcess.HasValue)
		{
			return;
		}
		QueuedMove value = moveInProcess.Value;
		CargoShipContainer cargoShipContainer = value.TargetEntity.Get(serverside: true);
		if ((Object)(object)cargoShipContainer == (Object)null)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		float num = Mathf.Max(15.585f, Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight));
		float num2 = num;
		Vector3 val = ((Component)cargoShipContainer).transform.position;
		Vector3 val2 = Vector3Ex.WithY(val, position.y) - position;
		float num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
		Vector3 localPosition = ServerTowerGrab.localPosition;
		bool flag = false;
		float num4 = 0f;
		switch (currentPickupState)
		{
		case PickupState.RotateToFace:
			cargoShipContainer.SetTargeted(state: true);
			if (!(num3 < 2f))
			{
				break;
			}
			num2 = ((Component)this).transform.InverseTransformPoint(new Vector3(0f, ((Component)cargoShipContainer).transform.position.y + ((Bounds)(ref cargoShipContainer.bounds)).max.y, 0f)).y;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Lift;
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Lift:
			flag = true;
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				currentPickupState = PickupState.RotateToTarget;
			}
			break;
		case PickupState.RotateToTarget:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (num3 < 0.1f)
			{
				currentPickupState = PickupState.Drop;
			}
			break;
		case PickupState.Drop:
			flag = true;
			val = value.TargetWorldPosition;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num2 = ((Component)this).transform.InverseTransformPoint(value.TargetWorldPosition).y + ((Bounds)(ref cargoShipContainer.bounds)).size.y;
			((Component)cargoShipContainer).transform.rotation = Quaternion.RotateTowards(((Component)cargoShipContainer).transform.rotation, value.TargetWorldRotation, PickedUpObjectRotationSpeed * Time.deltaTime);
			if (Mathf.Abs(num2 - localPosition.y) < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > LockTime)
				{
					currentPickupState = PickupState.Reset;
					((Component)cargoShipContainer).transform.SetPositionAndRotation(value.TargetWorldPosition, (PickedUpObjectRotationSpeed > 0f) ? value.TargetWorldRotation : ((Component)cargoShipContainer).transform.rotation);
					cargoShipContainer.SetParent(toParent.Get(serverside: true), worldPositionStays: true);
					cargoShipContainer.SetTargeted(state: false);
					lockOnTime = 0f;
				}
			}
			break;
		case PickupState.Reset:
			num2 = num;
			val = ((Component)this).transform.position + startForward * 26f;
			val2 = Vector3Ex.WithY(val, position.y) - position;
			num3 = Vector3.Angle(((Component)this).transform.forward, ((Vector3)(ref val2)).normalized);
			if (num3 < 0.1f)
			{
				lockOnTime += Time.deltaTime;
				if (lockOnTime > 5f)
				{
					lockOnTime = 0f;
					SetFlag(Flags.Busy, b: false);
					((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
					CheckMoveQueue();
				}
			}
			break;
		}
		cargoShipContainer.ToggleHurtCollider(currentPickupState == PickupState.Drop);
		Quaternion val3 = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		((Component)this).transform.rotation = Quaternion.RotateTowards(((Component)this).transform.rotation, val3, 5f * Time.deltaTime);
		float num5 = ((num4 > 0f) ? num4 : Vector3.Distance(Vector3Ex.WithY(val, position.y), position));
		Vector3 val4 = default(Vector3);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		localPosition = Vector3.MoveTowards(localPosition, val4, Time.deltaTime * 2f);
		ServerTowerGrab.localPosition = localPosition;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		if (flag)
		{
			((Component)cargoShipContainer).transform.position = ServerTowerGrab.position - Vector3.up * ((Bounds)(ref cargoShipContainer.bounds)).size.y;
		}
		UpdateArm();
		SendNetworkUpdate();
		CargoShip cargoShip = toParent.Get(serverside: true);
		if (!((Object)(object)cargoShip != (Object)null) || cargoShip.HasFlag(Flags.Reserved1))
		{
			return;
		}
		foreach (QueuedMove item in movesToMake)
		{
			item.TargetEntity.Get(serverside: true).Kill();
		}
		if ((Object)(object)cargoShipContainer != (Object)null && currentPickupState != PickupState.Reset)
		{
			cargoShipContainer.Kill();
		}
		val = ((Component)this).transform.position + startForward * 26f;
		val2 = Vector3Ex.WithY(val, position.y) - position;
		num2 = num;
		num5 = Vector3.Distance(Vector3Ex.WithY(val, position.y), position);
		((Vector3)(ref val4))..ctor(0f, num2, num5);
		((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
		ServerTowerGrab.localPosition = val4;
		CraneGrab.position = ServerTowerGrab.position + grabOffset;
		UpdateArm();
		SendNetworkUpdate();
		SetFlag(Flags.Busy, b: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ProcessCraneMovement);
	}

	public void ReplenishContainers()
	{
		ReplenishContainers(Random.Range(2, 4));
	}

	public void AssignDestination(List<Transform> destinations, CargoShip targetShip, float delay)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (startForward == Vector3.zero)
		{
			startForward = ((Component)targetShip).transform.forward;
		}
		toParent.Set(targetShip);
		int num = 0;
		int num2 = 0;
		for (int i = 0; i < movesToMake.Count; i++)
		{
			QueuedMove value = movesToMake[i];
			Transform val = destinations[num];
			value.TargetWorldRotation = val.rotation;
			value.TargetWorldPosition = val.position + Vector3.up * ((float)num2 * 3f);
			maxTargetHeight = Mathf.Max(value.TargetWorldPosition.y, maxTargetHeight);
			value.HasTarget = true;
			movesToMake[i] = value;
			num++;
			if (num >= destinations.Count)
			{
				num = 0;
				num2++;
			}
		}
		moveDelay = delay;
		CheckMoveQueue();
	}

	public bool IsDestinationValidForCrane(CargoShipContainerDestination destination)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = Vector3Ex.WithY(((Component)destination).transform.position, position.y);
		Vector3 val2 = position;
		return Vector3.Distance(val, val2) < MaxMoveDistance - 2f;
	}

	public override void Load(LoadInfo info)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (!base.isServer)
		{
			return;
		}
		startForward = info.msg.harborCrane.startForward;
		ServerTowerGrab.localPosition = new Vector3(0f, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		toParent.uid = info.msg.harborCrane.toParent;
		moveDelay = info.msg.harborCrane.moveDelay;
		if (moveDelay > 0f && !((FacepunchBehaviour)this).IsInvoking((Action)CountdownDelay))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)CountdownDelay, 0f, 0f);
		}
		if (info.msg.harborCrane.currentMove != null)
		{
			moveInProcess = CreateMove(info.msg.harborCrane.currentMove);
		}
		movesToMake.Clear();
		if (info.msg.harborCrane.queuedMoves != null)
		{
			foreach (QueuedMove queuedMove in info.msg.harborCrane.queuedMoves)
			{
				movesToMake.Add(CreateMove(queuedMove));
			}
			Pool.Free<QueuedMove>(ref info.msg.harborCrane.queuedMoves, false);
		}
		currentPickupState = (PickupState)info.msg.harborCrane.currentPickupState;
		if (IsBusy() && !((FacepunchBehaviour)this).IsInvoking((Action)ProcessCraneMovement))
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessCraneMovement, 0f, 0f);
		}
		maxTargetHeight = info.msg.harborCrane.maxMoveHeight;
	}

	private void UpdateArm()
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ArmRoot != (Object)null && (Object)(object)CraneGrab != (Object)null)
		{
			Vector3 position = ((Component)this).transform.position;
			Vector3 position2 = CraneGrab.position;
			float num = Vector3.Distance(position, Vector3Ex.WithY(position2, position.y));
			if (num < MaxMoveDistance + 2f)
			{
				float num2 = Mathf.Acos(num / (MaxMoveDistance + 3f));
				ArmRoot.localEulerAngles = new Vector3(0f - num2 * 57.29578f, 90f, 0f);
			}
		}
		UpdateArmSupports(((Component)this).transform.right);
	}
}


using UnityEngine;

public struct ContainerStack
{
	public Transform RootPoint;

	public int MaxStackSize;

	public int CurrentStackSize { get; set; }
}


using UnityEngine;

private struct QueuedMove
{
	public EntityRef<CargoShipContainer> TargetEntity;

	public Vector3 TargetWorldPosition;

	public Quaternion TargetWorldRotation;

	public bool HasTarget;
}


private enum PickupState
{
	RotateToFace,
	Lift,
	RotateToTarget,
	Drop,
	Reset
}


using UnityEngine;

public class HarborCraneContainerSpawnPoint : MonoBehaviour
{
	public int MaxStackSize = 1;
}


using UnityEngine;

public class HarborCraneSounds : MonoBehaviour, IClientComponent
{
	public HarborCrane crane;

	public SoundDefinition rootRotationLoopDef;

	public SoundDefinition rootRotationStartDef;

	public SoundDefinition rootRotationStopDef;

	public SoundDefinition armRotationLoopDef;

	public SoundDefinition armRotationStartDef;

	public SoundDefinition armRotationStopDef;

	public Transform grabSoundPosition;

	public SoundDefinition grabMoveLoopDef;

	public SoundDefinition grabMoveStartDef;

	public SoundDefinition grabMoveStopDef;
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HarborCraneStatic : HarborCrane
{
	public float StartingDepth;

	public float StartingHeight;

	public float StartingAngle;

	public Transform HangingLadder;

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		SetArmPos(StartingAngle, StartingHeight, StartingDepth);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.harborCrane = Pool.Get<HarborCrane>();
		info.msg.harborCrane.depth = CraneGrab.localPosition.x;
		info.msg.harborCrane.height = CraneGrab.localPosition.y;
		info.msg.harborCrane.yaw = ArmRoot.localEulerAngles.z;
	}

	private void SetArmPos(float angle, float height, float depth)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		ArmRoot.localEulerAngles = new Vector3(0f, 0f, angle);
		CraneGrab.localPosition = new Vector3(depth, height, 0f);
		HangingLadder.rotation = Quaternion.LookRotation(((Component)this).transform.right, Vector3.up);
		UpdateArmSupports(((Component)this).transform.forward);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.harborCrane != null)
		{
			SetArmPos(info.msg.harborCrane.yaw, info.msg.harborCrane.height, info.msg.harborCrane.depth);
		}
	}
}


using System;
using UnityEngine;

public class HarborProximityEntity : BaseEntity
{
	public bool SupportChildDeployables;

	public const Flags IsMoving = Flags.Reserved1;

	private static ListHashSet<HarborProximityEntity> harborEntities = new ListHashSet<HarborProximityEntity>();

	public override void ServerInit()
	{
		base.ServerInit();
		harborEntities.Add(this);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		harborEntities.Remove(this);
	}

	public static HarborProximityEntity GetEntity(Vector3 worldPos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Enumerator<HarborProximityEntity> enumerator = harborEntities.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				HarborProximityEntity current = enumerator.Current;
				if (Vector3.Distance(Vector3Ex.WithY(((Component)current).transform.position, worldPos.y), worldPos) < 3f)
				{
					return current;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return null;
	}

	public void NotifyStart()
	{
		SetFlag(Flags.Reserved1, b: true);
	}

	public void NotifyEnd()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public override bool SupportsChildDeployables()
	{
		return SupportChildDeployables;
	}
}


using System;
using UnityEngine;

public class HarborProximityManager : MonoBehaviour, IServerComponent
{
	[Serializable]
	public class MoveToMake
	{
		public Transform EntityReferencePoint;

		public Transform MinimumPoint;

		public Transform MaximumPoint;

		public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

		public bool UseToggleMode;

		public float ToggleSpeed = 1f;

		private float toggleState;

		private BaseEntity cachedEntity;

		private bool isMoving;

		public void Apply(float normalisedTime)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_009e: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)cachedEntity == (Object)null)
			{
				cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
			}
			if ((Object)(object)cachedEntity == (Object)null)
			{
				return;
			}
			EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
			if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
			{
				if (!isMoving)
				{
					isMoving = true;
					if (cachedEntity is HarborProximityEntity harborProximityEntity)
					{
						harborProximityEntity.NotifyStart();
					}
				}
				((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
			}
			else if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity2)
				{
					harborProximityEntity2.NotifyEnd();
				}
			}
		}

		public void OnDockingEnded()
		{
			if (isMoving)
			{
				isMoving = false;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyEnd();
				}
			}
		}

		public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_007e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			//IL_0089: Unknown result type (might be due to invalid IL or missing references)
			float num = Animation.Evaluate(normalisedTime);
			if (UseToggleMode)
			{
				if (Application.isPlaying)
				{
					toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
				}
				else
				{
					toggleState = num;
				}
				num = toggleState;
			}
			rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
			posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
		}
	}

	public MoveToMake[] Moves;

	public bool DebugCargo;

	[Range(0f, 1f)]
	public float DebugVisPoint;

	private float localNormalisedState;

	public void StartMovement()
	{
		localNormalisedState = 0f;
		Apply(0f);
	}

	public void UpdateNormalisedState(float f)
	{
		localNormalisedState = Mathf.Max(localNormalisedState, f);
		localNormalisedState = f;
		Apply(localNormalisedState);
	}

	public void EndMovement()
	{
		Apply(0f);
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].OnDockingEnded();
		}
	}

	private void Apply(float f)
	{
		MoveToMake[] moves = Moves;
		for (int i = 0; i < moves.Length; i++)
		{
			moves[i].Apply(f);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class MoveToMake
{
	public Transform EntityReferencePoint;

	public Transform MinimumPoint;

	public Transform MaximumPoint;

	public AnimationCurve Animation = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public bool UseToggleMode;

	public float ToggleSpeed = 1f;

	private float toggleState;

	private BaseEntity cachedEntity;

	private bool isMoving;

	public void Apply(float normalisedTime)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)cachedEntity == (Object)null)
		{
			cachedEntity = HarborProximityEntity.GetEntity(EntityReferencePoint.position);
		}
		if ((Object)(object)cachedEntity == (Object)null)
		{
			return;
		}
		EvaluatePositionRotation(normalisedTime, out var rotToApply, out var posToApply);
		if (((Component)cachedEntity).transform.position != posToApply || ((Component)cachedEntity).transform.rotation != rotToApply)
		{
			if (!isMoving)
			{
				isMoving = true;
				if (cachedEntity is HarborProximityEntity harborProximityEntity)
				{
					harborProximityEntity.NotifyStart();
				}
			}
			((Component)cachedEntity).transform.SetPositionAndRotation(posToApply, rotToApply);
		}
		else if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity2)
			{
				harborProximityEntity2.NotifyEnd();
			}
		}
	}

	public void OnDockingEnded()
	{
		if (isMoving)
		{
			isMoving = false;
			if (cachedEntity is HarborProximityEntity harborProximityEntity)
			{
				harborProximityEntity.NotifyEnd();
			}
		}
	}

	public void EvaluatePositionRotation(float normalisedTime, out Quaternion rotToApply, out Vector3 posToApply)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		float num = Animation.Evaluate(normalisedTime);
		if (UseToggleMode)
		{
			if (Application.isPlaying)
			{
				toggleState = Mathf.MoveTowards(toggleState, num, Time.deltaTime * ToggleSpeed);
			}
			else
			{
				toggleState = num;
			}
			num = toggleState;
		}
		rotToApply = Quaternion.Lerp(MinimumPoint.rotation, MaximumPoint.rotation, num);
		posToApply = Vector3.Lerp(MinimumPoint.position, MaximumPoint.position, num);
	}
}


using UnityEngine;

public class MovementSounds : MonoBehaviour
{
	public SoundDefinition waterMovementDef;

	public float waterMovementFadeInSpeed = 1f;

	public float waterMovementFadeOutSpeed = 1f;

	public SoundDefinition enterWaterSmall;

	public SoundDefinition enterWaterMedium;

	public SoundDefinition enterWaterLarge;

	private Sound waterMovement;

	private SoundModulation.Modulator waterGainMod;

	public bool inWater;

	public float waterLevel;

	public bool mute;
}


using UnityEngine;

public class MoveOverTime : MonoBehaviour
{
	[Range(-10f, 10f)]
	public float speed = 1f;

	public Vector3 position;

	public Vector3 rotation;

	public Vector3 scale;

	private void Update()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		Quaternion val = ((Component)this).transform.rotation;
		transform.rotation = Quaternion.Euler(((Quaternion)(ref val)).eulerAngles + rotation * speed * Time.deltaTime);
		Transform transform2 = ((Component)this).transform;
		transform2.localScale += scale * speed * Time.deltaTime;
		Transform transform3 = ((Component)this).transform;
		transform3.localPosition += position * speed * Time.deltaTime;
	}
}


using System;
using Network;

public abstract class NetworkCryptography : INetworkCryptography
{
	private byte[] buffer = new byte[8388608];

	public unsafe ArraySegment<byte> EncryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		EncryptionHandler(connection, src, ref dst);
		return dst;
	}

	public unsafe ArraySegment<byte> DecryptCopy(Connection connection, ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(buffer, data.Offset, buffer.Length - data.Offset);
		if (data.Offset > 0)
		{
			fixed (byte* array2 = dst.Array)
			{
				fixed (byte* array = data.Array)
				{
					Buffer.MemoryCopy(array, array2, dst.Array.Length, data.Offset);
				}
			}
		}
		DecryptionHandler(connection, src, ref dst);
		return dst;
	}

	public void Encrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		EncryptionHandler(connection, src, ref dst);
		data = dst;
	}

	public void Decrypt(Connection connection, ref ArraySegment<byte> data)
	{
		ArraySegment<byte> src = new ArraySegment<byte>(data.Array, data.Offset, data.Count);
		ArraySegment<byte> dst = new ArraySegment<byte>(data.Array, data.Offset, data.Array.Length - data.Offset);
		DecryptionHandler(connection, src, ref dst);
		data = dst;
	}

	protected abstract void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);

	protected abstract void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst);
}


using System;
using Network;

public class NetworkCryptographyServer : NetworkCryptography
{
	protected override void EncryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Encrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2597u, src, ref dst);
		}
	}

	protected override void DecryptionHandler(Connection connection, ArraySegment<byte> src, ref ArraySegment<byte> dst)
	{
		if (connection.encryptionLevel > 1)
		{
			EACServer.Decrypt(connection, src, ref dst);
		}
		else
		{
			Craptography.XOR(2597u, src, ref dst);
		}
	}
}


using System;
using ConVar;
using Network;
using Network.Visibility;
using Oxide.Core;
using Rust;
using UnityEngine;
using UnityEngine.Serialization;

public class NetworkVisibilityGrid : MonoBehaviour, Provider
{
	public const int overworldLayer = 0;

	public const int cavesLayer = 1;

	public const int tunnelsLayer = 2;

	public const int tutorialsLayer = 3;

	public const int dynamicDungeonsFirstLayer = 10;

	public int startID = 1024;

	public int gridSize = 100;

	public int cellCount = 32;

	[FormerlySerializedAs("visibilityRadius")]
	public int visibilityRadiusFar = 2;

	public int visibilityRadiusNear = 1;

	public float switchTolerance = 20f;

	public static float cavesThreshold = -5f;

	public static float tunnelsThreshold = -50f;

	public float dynamicDungeonsThreshold = 1000f;

	public float dynamicDungeonsInterval = 100f;

	private float halfGridSize;

	private float cellSize;

	private float halfCellSize;

	private int numIDsPerLayer;

	public static void ResetUndergroundThresholds()
	{
		cavesThreshold = -5f;
		tunnelsThreshold = -50f;
	}

	public static void RegisterEnvironmentVolume(EnvironmentVolume volume)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if ((volume.NetworkType & NetworkGroupType.Canyon) == NetworkGroupType.Canyon)
		{
			tunnelsThreshold = Mathf.Min(tunnelsThreshold, ((Component)volume).transform.position.y + volume.Center.y - volume.Size.y * 0.5f);
		}
	}

	private void Awake()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Expected O, but got Unknown
		Debug.Assert(Net.sv != null, "Network.Net.sv is NULL when creating Visibility Grid");
		Debug.Assert(Net.sv.visibility == null, "Network.Net.sv.visibility is being set multiple times");
		Net.sv.visibility = new Manager((Provider)(object)this);
	}

	private void OnEnable()
	{
		halfGridSize = (float)gridSize / 2f;
		cellSize = (float)gridSize / (float)cellCount;
		halfCellSize = cellSize / 2f;
		numIDsPerLayer = cellCount * cellCount;
	}

	private void OnDisable()
	{
		if (!Application.isQuitting && Net.sv != null && Net.sv.visibility != null)
		{
			Net.sv.visibility.Dispose();
			Net.sv.visibility = null;
		}
	}

	private void OnDrawGizmosSelected()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.blue;
		Vector3 position = ((Component)this).transform.position;
		for (int i = 0; i <= cellCount; i++)
		{
			float num = 0f - halfGridSize + (float)i * cellSize - halfCellSize;
			Gizmos.DrawLine(new Vector3(halfGridSize, position.y, num), new Vector3(0f - halfGridSize, position.y, num));
			Gizmos.DrawLine(new Vector3(num, position.y, halfGridSize), new Vector3(num, position.y, 0f - halfGridSize));
		}
	}

	private int PositionToGrid(float value)
	{
		return Mathf.Clamp(Mathf.RoundToInt((value + halfGridSize) / cellSize), 0, cellCount - 1);
	}

	private float GridToPosition(int value)
	{
		return (float)value * cellSize - halfGridSize;
	}

	private int PositionToLayer(float x, float y, float z)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (y < tunnelsThreshold)
		{
			return 2;
		}
		if (y < cavesThreshold)
		{
			return 1;
		}
		if (y >= dynamicDungeonsThreshold)
		{
			return 10 + Mathf.FloorToInt((y - dynamicDungeonsThreshold) / dynamicDungeonsInterval);
		}
		if (TerrainMeta.IsPointWithinTutorialBounds(new Vector3(x, 0f, z)))
		{
			return 3;
		}
		return 0;
	}

	private uint CoordToID(int x, int y, int layer)
	{
		return (uint)(layer * numIDsPerLayer + (x * cellCount + y) + startID);
	}

	private uint GetID(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		int num = PositionToGrid(vPos.x);
		int num2 = PositionToGrid(vPos.z);
		int num3 = PositionToLayer(vPos.x, vPos.y, vPos.z);
		if (num3 == 3)
		{
			Enumerator<TutorialIsland.IslandBounds> enumerator = TutorialIsland.BoundsListServer.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					TutorialIsland.IslandBounds current = enumerator.Current;
					if (current.Contains(vPos))
					{
						return current.Id;
					}
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		uint num4 = CoordToID(num, num2, num3);
		if (num4 < startID)
		{
			Debug.LogError((object)$"NetworkVisibilityGrid.GetID - group is below range {num} {num2} {num3} {num4} {cellCount}");
		}
		return num4;
	}

	private (int x, int y, int layer) DeconstructGroupId(int groupId)
	{
		groupId -= startID;
		int result;
		int item = Math.DivRem(groupId, numIDsPerLayer, out result);
		int result2;
		return (x: Math.DivRem(result, cellCount, out result2), y: result2, layer: item);
	}

	private Bounds GetBounds(uint uid)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		var (value, value2, num) = DeconstructGroupId((int)uid);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(GridToPosition(value) - halfCellSize, 0f, GridToPosition(value2) - halfCellSize);
		Vector3 max = default(Vector3);
		((Vector3)(ref max))..ctor(val.x + cellSize, 0f, val.z + cellSize);
		if (num == 0 || num == 3)
		{
			val.y = cavesThreshold;
			max.y = dynamicDungeonsThreshold;
		}
		else if (num == 1)
		{
			val.y = tunnelsThreshold;
			max.y = cavesThreshold - float.Epsilon;
		}
		else if (num == 2)
		{
			val.y = -10000f;
			max.y = tunnelsThreshold - float.Epsilon;
		}
		else if (num >= 10)
		{
			int num2 = num - 10;
			val.y = dynamicDungeonsThreshold + (float)num2 * dynamicDungeonsInterval + float.Epsilon;
			max.y = val.y + dynamicDungeonsInterval;
		}
		else
		{
			Debug.LogError((object)$"Cannot get bounds for unknown layer {num}!", (Object)(object)this);
		}
		Bounds result = default(Bounds);
		((Bounds)(ref result)).min = val;
		((Bounds)(ref result)).max = max;
		return result;
	}

	public void OnGroupAdded(Group group)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		if (!group.restricted)
		{
			group.bounds = GetBounds(group.ID);
		}
	}

	public bool IsInside(Group group, Vector3 vPos)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false || group.ID == 0 || ((Bounds)(ref group.bounds)).Contains(vPos);
		if (!group.restricted)
		{
			flag = flag || ((Bounds)(ref group.bounds)).SqrDistance(vPos) < switchTolerance;
		}
		return flag;
	}

	public Group GetGroup(Vector3 vPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		uint iD = GetID(vPos);
		if (iD == 0)
		{
			return null;
		}
		Group val = Net.sv.visibility.Get(iD);
		if (Net.network_group_debug && !IsInside(val, vPos))
		{
			float num = ((Bounds)(ref val.bounds)).SqrDistance(vPos);
			string[] obj = new string[6]
			{
				"Group is inside is all fucked ",
				iD.ToString(),
				"/",
				num.ToString(),
				"/",
				null
			};
			Vector3 val2 = vPos;
			obj[5] = ((object)(Vector3)(ref val2)/*cast due to .constrained prefix*/).ToString();
			Debug.Log((object)string.Concat(obj));
		}
		return val;
	}

	public void GetVisibleFromFar(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusFarOverride = Net.visibilityRadiusFarOverride;
		int radius = ((visibilityRadiusFarOverride > 0) ? visibilityRadiusFarOverride : visibilityRadiusFar);
		GetVisibleFrom(group, groups, radius);
	}

	public void GetVisibleFromNear(Group group, ListHashSet<Group> groups)
	{
		int visibilityRadiusNearOverride = Net.visibilityRadiusNearOverride;
		int radius = ((visibilityRadiusNearOverride > 0) ? visibilityRadiusNearOverride : visibilityRadiusNear);
		GetVisibleFrom(group, groups, radius);
	}

	private void GetVisibleFrom(Group group, ListHashSet<Group> groups, int radius)
	{
		if (Interface.CallHook("OnNetworkSubscriptionsGather", (object)this, (object)group, (object)groups, (object)radius) != null)
		{
			return;
		}
		ListHashSet<Group> groups2 = groups;
		groups2.Add(Net.sv.visibility.Get(0u));
		if (group.restricted)
		{
			groups2.Add(group);
			return;
		}
		int iD = (int)group.ID;
		if (iD < startID)
		{
			return;
		}
		var (num, num2, groupLayer2) = DeconstructGroupId(iD);
		AddLayers(num, num2, groupLayer2);
		for (int i = 1; i <= radius; i++)
		{
			AddLayers(num - i, num2, groupLayer2);
			AddLayers(num + i, num2, groupLayer2);
			AddLayers(num, num2 - i, groupLayer2);
			AddLayers(num, num2 + i, groupLayer2);
			for (int j = 1; j < i; j++)
			{
				AddLayers(num - i, num2 - j, groupLayer2);
				AddLayers(num - i, num2 + j, groupLayer2);
				AddLayers(num + i, num2 - j, groupLayer2);
				AddLayers(num + i, num2 + j, groupLayer2);
				AddLayers(num - j, num2 - i, groupLayer2);
				AddLayers(num + j, num2 - i, groupLayer2);
				AddLayers(num - j, num2 + i, groupLayer2);
				AddLayers(num + j, num2 + i, groupLayer2);
			}
			AddLayers(num - i, num2 - i, groupLayer2);
			AddLayers(num - i, num2 + i, groupLayer2);
			AddLayers(num + i, num2 - i, groupLayer2);
			AddLayers(num + i, num2 + i, groupLayer2);
		}
		void Add(int groupX, int groupY, int groupLayer)
		{
			groups2.Add(Net.sv.visibility.Get(CoordToID(groupX, groupY, groupLayer)));
		}
		void AddLayers(int groupX, int groupY, int groupLayer)
		{
			Add(groupX, groupY, groupLayer);
			if (groupLayer == 0)
			{
				Add(groupX, groupY, 1);
			}
			if (groupLayer == 1)
			{
				Add(groupX, groupY, 2);
				Add(groupX, groupY, 0);
			}
			if (groupLayer == 2)
			{
				Add(groupX, groupY, 1);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using ConVar;
using Facepunch;
using Network;
using Network.Visibility;
using ServerOcclusionJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public static class ServerOcclusion
{
	public readonly struct Grid : IEquatable<Grid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 16f;

		public const float HalfResolution = 8f;

		public Grid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 16f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
		}

		public override string ToString()
		{
			return $"(x: {x}, y: {y}, z: {z})";
		}

		public bool Equals(Grid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
		}

		public int GetIndex()
		{
			return GetGridIndex(x, y, z);
		}
	}

	public readonly struct SubGrid : IEquatable<SubGrid>
	{
		public readonly int x;

		public readonly int y;

		public readonly int z;

		public const float Resolution = 2f;

		public const float HalfResolution = 1f;

		public SubGrid(int x, int y, int z)
		{
			this.x = x;
			this.y = y;
			this.z = z;
		}

		public SubGrid(int3 p)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			x = p.x;
			y = p.y;
			z = p.z;
		}

		public int GetOffset(float axis)
		{
			return Mathf.RoundToInt(axis / 2f / 2f);
		}

		public Vector3 GetCenterPoint()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
		}

		public override string ToString()
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
		}

		public bool Equals(SubGrid other)
		{
			if (x == other.x && y == other.y)
			{
				return z == other.z;
			}
			return false;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(x, y, z);
		}

		public bool IsBlocked()
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			bool flag = false;
			for (int i = 0; i < GridOffsets.Length; i++)
			{
				Vector3 pos = GetCenterPoint() + GridOffsets[i];
				flag = false;
				if (OcclusionIncludeRocks)
				{
					flag = AntiHack.IsInsideMesh(pos);
				}
				if (!flag && !AntiHack.TestInsideTerrain(pos))
				{
					return false;
				}
			}
			if (flag)
			{
				return ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
			}
			return true;
		}

		public int GetIndex()
		{
			return GetSubGridIndex(x, y, z);
		}

		public int GetDistance(SubGrid other)
		{
			return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
		}
	}

	public static int MaxY = 200;

	public static int ChunkCountX;

	public static int ChunkCountY;

	public static int ChunkCountZ;

	public static int SubChunkCountX;

	public static int SubChunkCountY;

	public static int SubChunkCountZ;

	public static float AxisX;

	public static float AxisY;

	public static float AxisZ;

	public static LimitDictionary<(int, int), bool> OcclusionCache = new LimitDictionary<(int, int), bool>(32768);

	public static NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public static NativeReference<bool> ReturnHolder;

	public const int OcclusionChunkSize = 16;

	public const int OcclusionChunkResolution = 8;

	public static Dictionary<Group, ListHashSet<BaseNetworkable>> Occludees = new Dictionary<Group, ListHashSet<BaseNetworkable>>();

	public static readonly Vector3[] GridOffsets = (Vector3[])(object)new Vector3[2]
	{
		new Vector3(0f, 0f, 0f),
		new Vector3(0f, 1f, 0f)
	};

	public static readonly (int, int, int)[] neighbours = new(int, int, int)[6]
	{
		(1, 0, 0),
		(-1, 0, 0),
		(0, 1, 0),
		(0, -1, 0),
		(0, 0, 1),
		(0, 0, -1)
	};

	public static bool OcclusionEnabled { get; set; } = true;

	public static bool OcclusionIncludeRocks { get; set; } = true;

	public static float OcclusionPollRate => 2f;

	public static int MinOcclusionDistance => 25;

	public static string SubGridFilePath
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder + "/" + World.MapFileName.Replace(".map", "") + "_occlusion.dat";
		}
	}

	public static int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCountX * ChunkCountY + y * ChunkCountZ + x;
	}

	public static int GetSubGridIndex(int x, int y, int z)
	{
		return z * SubChunkCountX * SubChunkCountY + y * SubChunkCountX + x;
	}

	public static int GetGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 16f + axis / 16f);
	}

	public static Grid GetGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int grid = GetGrid(position.x, AxisX);
		int grid2 = GetGrid(position.y, AxisY);
		int grid3 = GetGrid(position.z, AxisZ);
		if (IsValidGrid(grid, grid2, grid3))
		{
			return new Grid(grid, grid2, grid3);
		}
		return default(Grid);
	}

	public static int GetSubGrid(float position, float axis)
	{
		return Mathf.RoundToInt(position / 2f + axis / 2f);
	}

	public static SubGrid GetSubGrid(Vector3 position)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		int subGrid = GetSubGrid(position.x, AxisX);
		int subGrid2 = GetSubGrid(position.y, AxisY);
		int subGrid3 = GetSubGrid(position.z, AxisZ);
		if (IsValidSubGrid(subGrid, subGrid2, subGrid3))
		{
			return new SubGrid(subGrid, subGrid2, subGrid3);
		}
		return default(SubGrid);
	}

	public static bool IsBlocked(int x, int y, int z)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		int result;
		int x2 = Math.DivRem(x, 8, out result);
		int result2;
		int y2 = Math.DivRem(y, 8, out result2);
		int result3;
		int z2 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(x2, y2, z2);
		NativeBitArray val = (NativeBitArray)(IsValidGrid(x2, y2, z2) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int num = result3 * 8 * 8 + result2 * 8 + result;
		if (((NativeBitArray)(ref val)).IsCreated)
		{
			return ((NativeBitArray)(ref val)).IsSet(num);
		}
		return false;
	}

	public static bool IsBlocked(SubGrid sub)
	{
		return IsBlocked(sub.x, sub.y, sub.z);
	}

	public static bool IsValidGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= ChunkCountX || y >= ChunkCountY || z >= ChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidSubGrid(int x, int y, int z)
	{
		if (x < 0 || y < 0 || z < 0)
		{
			return false;
		}
		if (x >= SubChunkCountX || y >= SubChunkCountY || z >= SubChunkCountZ)
		{
			return false;
		}
		return true;
	}

	public static void CalculatePathBetweenGrids(SubGrid grid1, SubGrid grid2, out bool pathBlocked)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		pathBlocked = false;
		NativeReference<bool> returnHolder = ReturnHolder;
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob = default(CalculatePathBetweenGridsJob);
		calculatePathBetweenGridsJob.From = grid1;
		calculatePathBetweenGridsJob.To = grid2;
		calculatePathBetweenGridsJob.PathBlocked = returnHolder;
		calculatePathBetweenGridsJob.Grid = new GridDefinition
		{
			OcclusionSubGridBlocked = OcclusionSubGridBlocked.AsReadOnly(),
			ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ),
			SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ)
		};
		calculatePathBetweenGridsJob.BlockedGridThreshold = ConVar.AntiHack.server_occlusion_blocked_grid_threshold;
		calculatePathBetweenGridsJob.NeighbourThreshold = ConVar.AntiHack.server_occlusion_neighbour_threshold;
		calculatePathBetweenGridsJob.UseNeighbourThresholds = ConVar.AntiHack.server_occlusion_use_neighbour_thresholds;
		CalculatePathBetweenGridsJob calculatePathBetweenGridsJob2 = calculatePathBetweenGridsJob;
		IJobExtensions.RunByRef<CalculatePathBetweenGridsJob>(ref calculatePathBetweenGridsJob2);
		pathBlocked = returnHolder.Value;
	}

	public static JobHandle CalculatePathsBetweenGridsJob(ReadOnly<(SubGrid from, SubGrid to)> paths, NativeArray<bool> pathsBlocked)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		CalculatePathsBetweenGridsJob calculatePathsBetweenGridsJob = default(CalculatePathsBetweenGridsJob);
		calculatePathsBetweenGridsJob.Paths = paths;
		calculatePathsBetweenGridsJob.PathsBlocked = pathsBlocked;
		calculatePathsBetweenGridsJob.Grid = new GridDefinition
		{
			OcclusionSubGridBlocked = OcclusionSubGridBlocked.AsReadOnly(),
			ChunkCount = new int3(ChunkCountX, ChunkCountY, ChunkCountZ),
			SubChunkCount = new int3(SubChunkCountX, SubChunkCountY, SubChunkCountZ)
		};
		calculatePathsBetweenGridsJob.BlockedGridThreshold = ConVar.AntiHack.server_occlusion_blocked_grid_threshold;
		calculatePathsBetweenGridsJob.NeighbourThreshold = ConVar.AntiHack.server_occlusion_neighbour_threshold;
		calculatePathsBetweenGridsJob.UseNeighbourThresholds = ConVar.AntiHack.server_occlusion_use_neighbour_thresholds;
		CalculatePathsBetweenGridsJob calculatePathsBetweenGridsJob2 = calculatePathsBetweenGridsJob;
		return IJobParallelForBatchExtensions.ScheduleBatchByRef<CalculatePathsBetweenGridsJob>(ref calculatePathsBetweenGridsJob2, paths.Length, 64, default(JobHandle));
	}

	public static void SetupGrid()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		Stopwatch stopwatch = new Stopwatch();
		stopwatch.Start();
		Vector3 size = TerrainMeta.Size;
		ChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 16f), 1);
		ChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 16f), 1);
		ChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 16f), 1);
		SubChunkCountX = Mathf.Max(Mathf.CeilToInt(size.x / 2f), 1);
		SubChunkCountY = Mathf.Max(Mathf.CeilToInt((float)MaxY / 2f), 1);
		SubChunkCountZ = Mathf.Max(Mathf.CeilToInt(size.z / 2f), 1);
		AxisX = TerrainMeta.Size.x / 2f;
		AxisY = MaxY / 2;
		AxisZ = TerrainMeta.Size.z / 2f;
		bool server_occlusion_save_grid = ConVar.AntiHack.server_occlusion_save_grid;
		if (!server_occlusion_save_grid || !ReadGridFromFile(SubGridFilePath))
		{
			OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(ChunkCountX * ChunkCountY * ChunkCountZ, (Allocator)4, (NativeArrayOptions)1);
			ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
			Debug.Log((object)$"Preparing Occlusion Grid ({SubChunkCountX}, {SubChunkCountY}, {SubChunkCountZ})");
			for (int i = 0; i < ChunkCountX; i++)
			{
				for (int j = 0; j < ChunkCountY; j++)
				{
					for (int k = 0; k < ChunkCountZ; k++)
					{
						Grid cell2 = new Grid(i, j, k);
						if (cell2.IsBlocked())
						{
							PopulateSubGrid(cell2);
						}
					}
				}
			}
			if (server_occlusion_save_grid)
			{
				WriteGridToFile(ChunkCountX * ChunkCountY * ChunkCountZ, OcclusionSubGridBlocked);
			}
			Debug.Log((object)$"Initialized {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		}
		else
		{
			Debug.Log((object)$"Loaded {SubChunkCountX * SubChunkCountY * SubChunkCountZ} occlusion sub-chunks from file - took {stopwatch.Elapsed.TotalMilliseconds / 1000.0} seconds");
		}
		foreach (BasePlayer allPlayer in BasePlayer.allPlayerList)
		{
			if (OcclusionEnabled && allPlayer.SupportsServerOcclusion())
			{
				allPlayer.SubGrid = GetSubGrid(allPlayer.GetOcclusionOffset());
				ListHashSet<Group> val = Pool.Get<ListHashSet<Group>>();
				Net.sv.visibility.GetVisibleFromFar(allPlayer.net.group, val);
				allPlayer.GroupAddOccludee(allPlayer.net.group);
				for (int l = 0; l < val.Count; l++)
				{
					allPlayer.GroupAddOccludee(val[l]);
				}
				Pool.FreeUnmanaged<Group>(ref val);
			}
		}
		static void PopulateSubGrid(Grid cell)
		{
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0063: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0059: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			int num = cell.x * 8;
			int num2 = cell.y * 8;
			int num3 = cell.z * 8;
			int index = cell.GetIndex();
			NativeBitArray val2 = OcclusionSubGridBlocked[index];
			NativeBitArray val3;
			if (!((NativeBitArray)(ref val2)).IsCreated)
			{
				((NativeBitArray)(ref val2))..ctor(512, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				OcclusionSubGridBlocked[index] = val2;
				val3 = val2;
			}
			else
			{
				val3 = OcclusionSubGridBlocked[index];
			}
			NativeBitArray val4 = val3;
			for (int m = 0; m < 8; m++)
			{
				for (int n = 0; n < 8; n++)
				{
					for (int num4 = 0; num4 < 8; num4++)
					{
						int num5 = num4 * 8 * 8 + n * 8 + m;
						((NativeBitArray)(ref val4)).Set(num5, new SubGrid(num + m, num2 + n, num3 + num4).IsBlocked());
					}
				}
			}
		}
	}

	public static void Dispose()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if (OcclusionSubGridBlocked.IsCreated)
		{
			for (int i = 0; i < OcclusionSubGridBlocked.Length; i++)
			{
				NativeBitArray val = OcclusionSubGridBlocked[i];
				if (((NativeBitArray)(ref val)).IsCreated)
				{
					((NativeBitArray)(ref val)).Dispose();
				}
			}
			OcclusionSubGridBlocked.Dispose();
		}
		if (ReturnHolder.IsCreated)
		{
			ReturnHolder.Dispose();
		}
	}

	private static void WriteGridToFile(int length, NativeArray<NativeBitArray> data)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			using BinaryWriter binaryWriter = new BinaryWriter(File.Open(SubGridFilePath, FileMode.Create));
			binaryWriter.Write(length);
			binaryWriter.Write(OcclusionIncludeRocks);
			Enumerator<NativeBitArray> enumerator = data.GetEnumerator();
			try
			{
				while (enumerator.MoveNext())
				{
					NativeBitArray current = enumerator.Current;
					if (!((NativeBitArray)(ref current)).IsCreated)
					{
						binaryWriter.Write(0);
						continue;
					}
					binaryWriter.Write(((NativeBitArray)(ref current)).Length);
					byte[] array = new byte[(((NativeBitArray)(ref current)).Length + 7) / 8];
					((NativeBitArray)(ref current)).AsNativeArray<byte>().CopyTo(array);
					binaryWriter.Write(array);
				}
			}
			finally
			{
				((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public static bool ReadGridFromFile(string path)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		try
		{
			if (!File.Exists(path))
			{
				return false;
			}
			using (BinaryReader binaryReader = new BinaryReader(File.Open(path, FileMode.Open)))
			{
				int num = binaryReader.ReadInt32();
				if (binaryReader.ReadBoolean() != OcclusionIncludeRocks)
				{
					Debug.LogWarning((object)"Grid file and occlusion parameters don't match, rebuilding grid");
					binaryReader.Close();
					File.Delete(path);
					return false;
				}
				OcclusionSubGridBlocked = new NativeArray<NativeBitArray>(num, (Allocator)4, (NativeArrayOptions)1);
				ReturnHolder = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
				for (int i = 0; i < num; i++)
				{
					int num2 = binaryReader.ReadInt32();
					if (num2 != 0)
					{
						byte[] array = binaryReader.ReadBytes((num2 + 7) / 8);
						OcclusionSubGridBlocked[i] = new NativeBitArray(num2, AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
						NativeBitArray val = OcclusionSubGridBlocked[i];
						((NativeBitArray)(ref val)).AsNativeArray<byte>().CopyFrom(array);
					}
				}
			}
			return true;
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
			return false;
		}
	}

	[ServerVar(Help = "Tests occlusion visibility between two positions")]
	public static string serverocclusiondebug(Arg arg)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		Vector3 vector = arg.GetVector3(0, default(Vector3));
		Vector3 vector2 = arg.GetVector3(1, default(Vector3));
		SubGrid subGrid = GetSubGrid(vector);
		SubGrid subGrid2 = GetSubGrid(vector2);
		if (subGrid.Equals(default(SubGrid)) || subGrid2.Equals(default(SubGrid)))
		{
			return $"Invalid grid(s), positions provided: {vector} - {vector2}";
		}
		CalculatePathBetweenGrids(subGrid, subGrid2, out var pathBlocked);
		return $"Grid 1: {subGrid}, Grid 2: {subGrid2}\nPath blocked: {pathBlocked}";
	}

	public static bool GetCachedVisibility(SubGrid from, SubGrid to, out bool isVisible)
	{
		int num = from.GetIndex();
		int num2 = to.GetIndex();
		if (num > num2)
		{
			int num3 = num2;
			int num4 = num;
			num = num3;
			num2 = num4;
		}
		return ((Dictionary<(int, int), bool>)(object)OcclusionCache).TryGetValue((num, num2), out isVisible);
	}

	public static void CacheVisibility(SubGrid from, SubGrid to, bool isVisible)
	{
		int num = from.GetIndex();
		int num2 = to.GetIndex();
		if (num > num2)
		{
			int num3 = num2;
			int num4 = num;
			num = num3;
			num2 = num4;
		}
		OcclusionCache.TryAdd((num, num2), isVisible);
	}
}


using System;
using UnityEngine;

public readonly struct Grid : IEquatable<Grid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 16f;

	public const float HalfResolution = 8f;

	public Grid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 16f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 16f, (float)(y - GetOffset(MaxY)) * 16f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 16f);
	}

	public override string ToString()
	{
		return $"(x: {x}, y: {y}, z: {z})";
	}

	public bool Equals(Grid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckBounds(new Bounds(GetCenterPoint(), new Vector3(16f, 16f, 16f)), 8388608, (QueryTriggerInteraction)0);
	}

	public int GetIndex()
	{
		return GetGridIndex(x, y, z);
	}
}


using System;
using Unity.Mathematics;
using UnityEngine;

public readonly struct SubGrid : IEquatable<SubGrid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 2f;

	public const float HalfResolution = 1f;

	public SubGrid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public SubGrid(int3 p)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		x = p.x;
		y = p.y;
		z = p.z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 2f);
	}

	public Vector3 GetCenterPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
	}

	public override string ToString()
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
	}

	public bool Equals(SubGrid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		for (int i = 0; i < GridOffsets.Length; i++)
		{
			Vector3 pos = GetCenterPoint() + GridOffsets[i];
			flag = false;
			if (OcclusionIncludeRocks)
			{
				flag = AntiHack.IsInsideMesh(pos);
			}
			if (!flag && !AntiHack.TestInsideTerrain(pos))
			{
				return false;
			}
		}
		if (flag)
		{
			return ((Component)((RaycastHit)(ref AntiHack.isInsideRayHit)).collider).gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
		}
		return true;
	}

	public int GetIndex()
	{
		return GetSubGridIndex(x, y, z);
	}

	public int GetDistance(SubGrid other)
	{
		return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
	}
}


using System;

[AttributeUsage(AttributeTargets.Property)]
public class SyncAttribute : Attribute
{
	public bool Pack { get; set; } = true;

	public bool Autosave { get; set; }

	public bool RequireChange { get; set; } = true;

	public bool InvalidateCache { get; set; } = true;
}


using UnityEngine;

public class DisableIfDlssNotSupported : MonoBehaviour
{
	private void OnEnable()
	{
		((Component)this).gameObject.SetActive(false);
	}
}


using UnityEngine;

public class NVidiaReflex : MonoBehaviour
{
}


using System;
using UnityEngine;

[Serializable]
public class PIDController
{
	[SerializeField]
	public float p;

	[SerializeField]
	public float i;

	[SerializeField]
	public float d;

	private float oldError;

	private float integralSum;

	public float Update(float dt, float current, float target)
	{
		float num = target - current;
		float num2 = p * num;
		float num3 = (num - oldError) / dt;
		oldError = num;
		float num4 = d * num3;
		integralSum += num * dt;
		float num5 = i * integralSum;
		return num2 + num5 + num4;
	}
}


public enum BlurType
{
	StandardGauss,
	SgxGauss
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlurTypeParameter : ParameterOverride<BlurType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class FixedIntParameter : ParameterOverride<int>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(BlurOptimizedRenderer), PostProcessEvent.AfterStack, "Custom/BlurOptimized", true)]
public class BlurOptimized : PostProcessEffectSettings
{
	[Range(0f, 2f)]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};

	public BlurTypeParameter blurType = new BlurTypeParameter
	{
		value = BlurType.StandardGauss
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class BlurOptimizedRenderer : PostProcessEffectRenderer<BlurOptimized>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private Shader blurShader;

	public override void Init()
	{
		base.Init();
		blurShader = Shader.Find("Hidden/PostProcessing/BlurOptimized");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("BlurOptimized");
		int value = base.settings.downsample.value;
		float value2 = base.settings.fadeToBlurDistance.value;
		float value3 = base.settings.blurSize.value;
		int value4 = base.settings.blurIterations.value;
		BlurType value5 = base.settings.blurType.value;
		float num = 1f / (1f * (float)(1 << value));
		float num2 = 1f / Mathf.Clamp(value2, 0.001f, 10000f);
		PropertySheet propertySheet = context.propertySheets.Get(blurShader);
		propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num, (0f - value3) * num, num2, 0f));
		int num3 = context.width >> value;
		int num4 = context.height >> value;
		int num5 = Shader.PropertyToID("_BlurRT1");
		int num6 = Shader.PropertyToID("_BlurRT2");
		command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
		command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
		int num7 = ((value5 != 0) ? 2 : 0);
		for (int i = 0; i < value4; i++)
		{
			float num8 = (float)i * 1f;
			propertySheet.properties.SetVector("_Parameter", new Vector4(value3 * num + num8, (0f - value3) * num - num8, num2, 0f));
			command.GetTemporaryRT(num6, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			command.GetTemporaryRT(num5, num3, num4, 0, (FilterMode)1, context.sourceFormat);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 2 + num7, clear: false, null);
			command.ReleaseTemporaryRT(num6);
		}
		if (value2 <= 0f)
		{
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, clear: false, null);
		}
		else
		{
			command.SetGlobalTexture("_Source", context.source);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), context.destination, propertySheet, 5, clear: false, null);
		}
		command.ReleaseTemporaryRT(num5);
		command.EndSample("BlurOptimized");
	}
}


using UnityEngine;

[CreateAssetMenu]
public class CustomPostEffectsResources : ScriptableObject
{
	public Shader[] shaders;
}


public enum DOFBlurSampleCount
{
	Low,
	Medium,
	High,
	VeryHigh
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public class DOFBlurSampleCountParameter : ParameterOverride<DOFBlurSampleCount>
{
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DepthOfFieldEffectRenderer), "Unity/Depth of Field (Custom)", false)]
public class DepthOfFieldEffect : PostProcessEffectSettings
{
	public FloatParameter focalLength = new FloatParameter
	{
		value = 10f
	};

	public FloatParameter focalSize = new FloatParameter
	{
		value = 0.05f
	};

	public FloatParameter aperture = new FloatParameter
	{
		value = 11.5f
	};

	[Range(0f, 3f)]
	public FloatParameter anamorphicSqueeze = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter anamorphicBarrel = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter maxBlurSize = new FloatParameter
	{
		value = 2f
	};

	public BoolParameter highResolution = new BoolParameter
	{
		value = true
	};

	public DOFBlurSampleCountParameter blurSampleCount = new DOFBlurSampleCountParameter
	{
		value = DOFBlurSampleCount.Low
	};

	public Transform focalTransform;
}


using ConVar;
using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DepthOfFieldEffectRenderer : PostProcessEffectRenderer<DepthOfFieldEffect>
{
	private float focalDistance01 = 10f;

	private float internalBlurWidth = 1f;

	private Shader dofShader;

	public override void Init()
	{
		dofShader = Shader.Find("Hidden/PostProcessing/DepthOfFieldEffect");
	}

	private float FocalDistance01(Camera cam, float worldDist)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		return cam.WorldToViewportPoint((worldDist - cam.nearClipPlane) * ((Component)cam).transform.forward + ((Component)cam).transform.position).z / (cam.farClipPlane - cam.nearClipPlane);
	}

	private void WriteCoc(PostProcessRenderContext context, PropertySheet sheet)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		RenderTargetIdentifier source = context.source;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		float num = 1f;
		int num2 = context.width / 2;
		int num3 = context.height / 2;
		int num4 = Shader.PropertyToID("DOFtemp1");
		int num5 = Shader.PropertyToID("DOFtemp2");
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num5), sheet, 1, clear: false, null);
		float num6 = internalBlurWidth * num;
		sheet.properties.SetVector("_Offsets", new Vector4(0f, num6, 0f, num6));
		command.GetTemporaryRT(num4, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num5);
		sheet.properties.SetVector("_Offsets", new Vector4(num6, 0f, 0f, num6));
		command.GetTemporaryRT(num5, num2, num3, 0, (FilterMode)1, sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), sheet, 0, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.SetGlobalTexture("_FgOverlap", RenderTargetIdentifier.op_Implicit(num5));
		command.BlitFullscreenTriangle(source, source, sheet, 3, (RenderBufferLoadAction)0, null);
		command.ReleaseTemporaryRT(num5);
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0287: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(dofShader);
		CommandBuffer command = context.command;
		int width = context.width;
		int height = context.height;
		RenderTextureFormat sourceFormat = context.sourceFormat;
		bool value = base.settings.highResolution.value;
		DOFBlurSampleCountParameter blurSampleCount = base.settings.blurSampleCount;
		float value2 = base.settings.focalSize.value;
		float value3 = base.settings.focalLength.value;
		float value4 = base.settings.aperture.value;
		float value5 = base.settings.maxBlurSize.value;
		int num = Shader.PropertyToID("DOFrtLow");
		int num2 = Shader.PropertyToID("DOFrtLow2");
		value4 = Mathf.Clamp(value4, 1f, 32f);
		value5 = Mathf.Clamp(value5, 0.1f, 32f * ((float)context.height / 1080f));
		value2 = Mathf.Clamp(value2, 0f, 2f);
		internalBlurWidth = Mathf.Max(value5, 0f);
		focalDistance01 = FocalDistance01(context.camera, value3);
		propertySheet.properties.SetVector("_CurveParams", new Vector4(1f, value2, value4 / 10f, focalDistance01));
		propertySheet.properties.SetVector("_DistortionParams", new Vector4((float)base.settings.anamorphicSqueeze, (float)base.settings.anamorphicBarrel * 2f, 0f, 0f));
		if (value)
		{
			internalBlurWidth *= 2f;
		}
		WriteCoc(context, propertySheet);
		if (Graphics.dof_debug)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 5, clear: false, null);
			return;
		}
		command.GetTemporaryRT(num, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		command.GetTemporaryRT(num2, width >> 1, height >> 1, 0, (FilterMode)1, sourceFormat);
		int pass = 2;
		if ((float)base.settings.anamorphicSqueeze > 0f || (float)base.settings.anamorphicBarrel > 0f)
		{
			command.EnableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		else
		{
			command.DisableShaderKeyword("ANAMORPHIC_BOKEH");
		}
		propertySheet.properties.SetVector("_Offsets", new Vector4(0f, internalBlurWidth, 0.025f, internalBlurWidth));
		propertySheet.properties.SetInt("_BlurCountMode", (int)blurSampleCount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, pass, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.ReleaseTemporaryRT(num2);
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(DoubleVisionRenderer), PostProcessEvent.AfterStack, "Custom/DoubleVision", true)]
public class DoubleVision : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public Vector2Parameter displace = new Vector2Parameter
	{
		value = Vector2.zero
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class DoubleVisionRenderer : PostProcessEffectRenderer<DoubleVision>
{
	private int displaceProperty = Shader.PropertyToID("_displace");

	private int amountProperty = Shader.PropertyToID("_amount");

	private Shader doubleVisionShader;

	public override void Init()
	{
		base.Init();
		doubleVisionShader = Shader.Find("Hidden/PostProcessing/DoubleVision");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("DoubleVision");
		PropertySheet propertySheet = context.propertySheets.Get(doubleVisionShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(displaceProperty, Vector4.op_Implicit(base.settings.displace.value));
		propertySheet.properties.SetFloat(amountProperty, base.settings.amount.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("DoubleVision");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FlashbangEffectRenderer), PostProcessEvent.AfterStack, "Custom/FlashbangEffect", false)]
public class FlashbangEffect : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter burnIntensity = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter whiteoutIntensity = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FlashbangEffectRenderer : PostProcessEffectRenderer<FlashbangEffect>
{
	public static bool needsCapture;

	private Shader flashbangEffectShader;

	private RenderTexture screenRT;

	public override void Init()
	{
		base.Init();
		flashbangEffectShader = Shader.Find("Hidden/PostProcessing/FlashbangEffect");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		if (!Application.isPlaying)
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		CommandBuffer command = context.command;
		CheckCreateRenderTexture(ref screenRT, "Flashbang", context.width, context.height, context.sourceFormat);
		command.BeginSample("FlashbangEffect");
		if (needsCapture)
		{
			command.CopyTexture(context.source, RenderTargetIdentifier.op_Implicit((Texture)(object)screenRT));
			needsCapture = false;
		}
		PropertySheet propertySheet = context.propertySheets.Get(flashbangEffectShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat("_BurnIntensity", base.settings.burnIntensity.value);
		propertySheet.properties.SetFloat("_WhiteoutIntensity", base.settings.whiteoutIntensity.value);
		if (Object.op_Implicit((Object)(object)screenRT))
		{
			propertySheet.properties.SetTexture("_BurnOverlay", (Texture)(object)screenRT);
		}
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("FlashbangEffect");
	}

	public override void Release()
	{
		base.Release();
		SafeDestroyRenderTexture(ref screenRT);
	}

	private static void CheckCreateRenderTexture(ref RenderTexture rt, string name, int width, int height, RenderTextureFormat format)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Expected O, but got Unknown
		if ((Object)(object)rt == (Object)null || ((Texture)rt).width != width || ((Texture)rt).height != height)
		{
			SafeDestroyRenderTexture(ref rt);
			rt = new RenderTexture(width, height, 0, format)
			{
				hideFlags = (HideFlags)52
			};
			((Object)rt).name = name;
			((Texture)rt).wrapMode = (TextureWrapMode)1;
			rt.Create();
		}
	}

	private static void SafeDestroyRenderTexture(ref RenderTexture rt)
	{
		if ((Object)(object)rt != (Object)null)
		{
			rt.Release();
			Object.DestroyImmediate((Object)(object)rt);
			rt = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(FrostRenderer), PostProcessEvent.AfterStack, "Custom/Frost", true)]
public class Frost : PostProcessEffectSettings
{
	[Range(0f, 16f)]
	public FloatParameter scale = new FloatParameter
	{
		value = 0f
	};

	public BoolParameter enableVignette = new BoolParameter
	{
		value = true
	};

	[Range(0f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class FrostRenderer : PostProcessEffectRenderer<Frost>
{
	private int scaleProperty = Shader.PropertyToID("_scale");

	private int sharpnessProperty = Shader.PropertyToID("_sharpness");

	private int darknessProperty = Shader.PropertyToID("_darkness");

	private Shader frostShader;

	public override void Init()
	{
		base.Init();
		frostShader = Shader.Find("Hidden/PostProcessing/Frost");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Frost");
		PropertySheet propertySheet = context.propertySheets.Get(frostShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		propertySheet.properties.SetFloat(sharpnessProperty, base.settings.sharpness.value * 0.01f);
		propertySheet.properties.SetFloat(darknessProperty, base.settings.darkness.value * 0.02f);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, base.settings.enableVignette.value ? 1 : 0, clear: false, null);
		command.EndSample("Frost");
	}
}


public enum BlendModeType
{
	Screen,
	Add
}


public enum ResolutionType
{
	Low,
	Normal,
	High
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class BlendModeTypeParameter : ParameterOverride<BlendModeType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class ResolutionTypeParameter : ParameterOverride<ResolutionType>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GodRaysRenderer), PostProcessEvent.BeforeStack, "Custom/GodRays", true)]
public class GodRays : PostProcessEffectSettings
{
	public BoolParameter UseDepth = new BoolParameter
	{
		value = true
	};

	public BlendModeTypeParameter BlendMode = new BlendModeTypeParameter
	{
		value = BlendModeType.Screen
	};

	public FloatParameter Intensity = new FloatParameter
	{
		value = 0f
	};

	public ResolutionTypeParameter Resolution = new ResolutionTypeParameter
	{
		value = ResolutionType.High
	};

	public IntParameter BlurIterations = new IntParameter
	{
		value = 2
	};

	public FloatParameter BlurRadius = new FloatParameter
	{
		value = 2f
	};

	public FloatParameter MaxRadius = new FloatParameter
	{
		value = 0.5f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GodRaysRenderer : PostProcessEffectRenderer<GodRays>
{
	private const int PASS_SCREEN = 0;

	private const int PASS_ADD = 1;

	public Shader GodRayShader;

	public Shader ScreenClearShader;

	public Shader SkyMaskShader;

	public override void Init()
	{
		if (!Object.op_Implicit((Object)(object)GodRayShader))
		{
			GodRayShader = Shader.Find("Hidden/PostProcessing/GodRays");
		}
		if (!Object.op_Implicit((Object)(object)ScreenClearShader))
		{
			ScreenClearShader = Shader.Find("Hidden/PostProcessing/ScreenClear");
		}
		if (!Object.op_Implicit((Object)(object)SkyMaskShader))
		{
			SkyMaskShader = Shader.Find("Hidden/PostProcessing/SkyMask");
		}
	}

	private void DrawBorder(PostProcessRenderContext context, RenderTargetIdentifier buffer1)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		PropertySheet propertySheet = context.propertySheets.Get(ScreenClearShader);
		Rect value = default(Rect);
		((Rect)(ref value))..ctor(0f, (float)(context.height - 1), (float)context.width, 1f);
		Rect value2 = default(Rect);
		((Rect)(ref value2))..ctor(0f, 0f, (float)context.width, 1f);
		Rect value3 = default(Rect);
		((Rect)(ref value3))..ctor(0f, 0f, 1f, (float)context.height);
		Rect value4 = default(Rect);
		((Rect)(ref value4))..ctor((float)(context.width - 1), 0f, 1f, (float)context.height);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value2);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value3);
		context.command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), buffer1, propertySheet, 0, clear: false, value4);
	}

	private int GetSkyMask(PostProcessRenderContext context, ResolutionType resolution, Vector3 lightPos, int blurIterations, float blurRadius, float maxRadius)
	{
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Invalid comparison between Unknown and I4
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		Camera camera = context.camera;
		PropertySheet propertySheet = context.propertySheets.Get(SkyMaskShader);
		command.BeginSample("GodRays");
		int num;
		int num2;
		int num3;
		switch (resolution)
		{
		case ResolutionType.High:
			num = context.screenWidth;
			num2 = context.screenHeight;
			num3 = 0;
			break;
		case ResolutionType.Normal:
			num = context.screenWidth / 2;
			num2 = context.screenHeight / 2;
			num3 = 0;
			break;
		default:
			num = context.screenWidth / 4;
			num2 = context.screenHeight / 4;
			num3 = 0;
			break;
		}
		int num4 = Shader.PropertyToID("buffer1");
		int num5 = Shader.PropertyToID("buffer2");
		command.GetTemporaryRT(num4, num, num2, num3);
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(1f, 1f, 0f, 0f) * blurRadius);
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		if ((camera.depthTextureMode & 1) != 0)
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(num4), propertySheet, 2, clear: false, null);
		}
		if ((int)camera.stereoActiveEye == 2)
		{
			DrawBorder(context, RenderTargetIdentifier.op_Implicit(num4));
		}
		float num6 = blurRadius * 0.0013020834f;
		propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		propertySheet.properties.SetVector("_LightPosition", new Vector4(lightPos.x, lightPos.y, lightPos.z, maxRadius));
		for (int i = 0; i < blurIterations; i++)
		{
			command.GetTemporaryRT(num5, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num4);
			num6 = blurRadius * (((float)i * 2f + 1f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
			command.GetTemporaryRT(num4, num, num2, num3);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 0, clear: false, null);
			command.ReleaseTemporaryRT(num5);
			num6 = blurRadius * (((float)i * 2f + 2f) * 6f) / 768f;
			propertySheet.properties.SetVector("_BlurRadius4", new Vector4(num6, num6, 0f, 0f));
		}
		command.EndSample("GodRays");
		return num4;
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		TOD_Sky instance = TOD_Sky.Instance;
		if (!((Object)(object)instance == (Object)null))
		{
			Vector3 val = camera.WorldToViewportPoint(instance.Components.LightTransform.position);
			CommandBuffer command = context.command;
			PropertySheet propertySheet = context.propertySheets.Get(GodRayShader);
			int skyMask = GetSkyMask(context, base.settings.Resolution.value, val, base.settings.BlurIterations.value, base.settings.BlurRadius.value, base.settings.MaxRadius.value);
			Color val2 = Color.black;
			if ((double)val.z >= 0.0)
			{
				val2 = ((!instance.IsDay) ? (base.settings.Intensity.value * instance.MoonVisibility * instance.MoonRayColor) : (base.settings.Intensity.value * instance.SunVisibility * instance.SunRayColor));
			}
			propertySheet.properties.SetColor("_LightColor", val2);
			command.SetGlobalTexture("_SkyMask", RenderTargetIdentifier.op_Implicit(skyMask));
			if (base.settings.BlendMode.value == BlendModeType.Screen)
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
			}
			else
			{
				context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(skyMask);
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(GreyScaleRenderer), PostProcessEvent.AfterStack, "Custom/GreyScale", true)]
public class GreyScale : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter redLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter greenLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter blueLuminance = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 1f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[ColorUsage(false, true)]
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class GreyScaleRenderer : PostProcessEffectRenderer<GreyScale>
{
	private int dataProperty = Shader.PropertyToID("_data");

	private int colorProperty = Shader.PropertyToID("_color");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/GreyScale");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("GreyScale");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetVector(dataProperty, new Vector4(base.settings.redLuminance.value, base.settings.greenLuminance.value, base.settings.blueLuminance.value, base.settings.amount.value));
		propertySheet.properties.SetColor(colorProperty, base.settings.color.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("GreyScale");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(LensDirtinessRenderer), PostProcessEvent.AfterStack, "Custom/LensDirtiness", true)]
public class LensDirtinessEffect : PostProcessEffectSettings
{
	public TextureParameter dirtinessTexture = new TextureParameter();

	public BoolParameter sceneTintsBloom = new BoolParameter
	{
		value = false
	};

	public FloatParameter gain = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter threshold = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter bloomSize = new FloatParameter
	{
		value = 5f
	};

	public FloatParameter dirtiness = new FloatParameter
	{
		value = 1f
	};

	public ColorParameter bloomColor = new ColorParameter
	{
		value = Color.white
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class LensDirtinessRenderer : PostProcessEffectRenderer<LensDirtinessEffect>
{
	private enum Pass
	{
		Threshold,
		Kawase,
		Compose
	}

	private int dataProperty = Shader.PropertyToID("_data");

	private Shader lensDirtinessShader;

	public override void Init()
	{
		base.Init();
		lensDirtinessShader = Shader.Find("Hidden/PostProcessing/LensDirtiness");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_021a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0221: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_030f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_0373: Unknown result type (might be due to invalid IL or missing references)
		//IL_037a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0396: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0410: Unknown result type (might be due to invalid IL or missing references)
		//IL_0412: Unknown result type (might be due to invalid IL or missing references)
		float value = base.settings.bloomSize.value;
		float value2 = base.settings.gain.value;
		float value3 = base.settings.threshold.value;
		float value4 = base.settings.dirtiness.value;
		Color value5 = base.settings.bloomColor.value;
		Texture value6 = base.settings.dirtinessTexture.value;
		bool value7 = base.settings.sceneTintsBloom.value;
		CommandBuffer command = context.command;
		command.BeginSample("LensDirtinessEffect");
		if (value7)
		{
			command.EnableShaderKeyword("_SCENE_TINTS_BLOOM");
		}
		PropertySheet propertySheet = context.propertySheets.Get(lensDirtinessShader);
		RenderTargetIdentifier source = context.source;
		RenderTargetIdentifier destination = context.destination;
		int width = context.width;
		int height = context.height;
		int num = Shader.PropertyToID("_RTT_BloomThreshold");
		int num2 = Shader.PropertyToID("_RTT_1");
		int num3 = Shader.PropertyToID("_RTT_2");
		int num4 = Shader.PropertyToID("_RTT_3");
		int num5 = Shader.PropertyToID("_RTT_4");
		int num6 = Shader.PropertyToID("_RTT_Bloom_1");
		int num7 = Shader.PropertyToID("_RTT_Bloom_2");
		propertySheet.properties.SetFloat("_Gain", value2);
		propertySheet.properties.SetFloat("_Threshold", value3);
		command.GetTemporaryRT(num, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(source, RenderTargetIdentifier.op_Implicit(num), propertySheet, 0, clear: false, null);
		propertySheet.properties.SetVector("_Offset", new Vector4(1f / (float)width, 1f / (float)height, 0f, 0f) * 2f);
		command.GetTemporaryRT(num2, width / 2, height / 2, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num), RenderTargetIdentifier.op_Implicit(num2), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num);
		command.GetTemporaryRT(num3, width / 4, height / 4, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num2), RenderTargetIdentifier.op_Implicit(num3), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num2);
		command.GetTemporaryRT(num4, width / 8, height / 8, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num3), RenderTargetIdentifier.op_Implicit(num4), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num3);
		command.GetTemporaryRT(num5, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num4), RenderTargetIdentifier.op_Implicit(num5), propertySheet, 1, clear: false, null);
		command.ReleaseTemporaryRT(num4);
		command.GetTemporaryRT(num6, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.GetTemporaryRT(num7, width / 16, height / 16, 0, (FilterMode)1, context.sourceFormat);
		command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num5), RenderTargetIdentifier.op_Implicit(num6), clear: false, null);
		command.ReleaseTemporaryRT(num5);
		for (int i = 1; i <= 8; i++)
		{
			float num8 = value * (float)i / (float)width;
			float num9 = value * (float)i / (float)height;
			propertySheet.properties.SetVector("_Offset", new Vector4(num8, num9, 0f, 0f));
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num6), RenderTargetIdentifier.op_Implicit(num7), propertySheet, 1, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(num7), RenderTargetIdentifier.op_Implicit(num6), propertySheet, 1, clear: false, null);
		}
		command.SetGlobalTexture("_Bloom", RenderTargetIdentifier.op_Implicit(num7));
		propertySheet.properties.SetFloat("_Dirtiness", value4);
		propertySheet.properties.SetColor("_BloomColor", value5);
		propertySheet.properties.SetTexture("_DirtinessTexture", value6);
		command.BlitFullscreenTriangle(source, destination, propertySheet, 2, clear: false, null);
		command.ReleaseTemporaryRT(num6);
		command.ReleaseTemporaryRT(num7);
		command.EndSample("LensDirtinessEffect");
	}
}


private enum Pass
{
	Threshold,
	Kawase,
	Compose
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(NightLightEffectRenderer), PostProcessEvent.BeforeStack, "Custom/NightLight", true)]
public class NightLightEffect : PostProcessEffectSettings
{
	[Range(0f, 25f)]
	public FloatParameter distance = new FloatParameter
	{
		value = 5f
	};

	[Range(0f, 1f)]
	public FloatParameter fadeFraction = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter brightness = new FloatParameter
	{
		value = 0.1f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class NightLightEffectRenderer : PostProcessEffectRenderer<NightLightEffect>
{
	private int distanceProperty = Shader.PropertyToID("_distance");

	private int fadeFractionProperty = Shader.PropertyToID("_fadefraction");

	private int brightnessProperty = Shader.PropertyToID("_brightness");

	private Shader nightlightShader;

	public override void Init()
	{
		base.Init();
		nightlightShader = Shader.Find("Hidden/PostProcessing/NightLightShader");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("NightLight");
		PropertySheet propertySheet = context.propertySheets.Get(nightlightShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(distanceProperty, base.settings.distance.value);
		propertySheet.properties.SetFloat(fadeFractionProperty, base.settings.fadeFraction.value);
		propertySheet.properties.SetFloat(brightnessProperty, base.settings.brightness.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("NightLight");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(PhotoFilterRenderer), PostProcessEvent.AfterStack, "Custom/PhotoFilter", true)]
public class PhotoFilter : PostProcessEffectSettings
{
	public ColorParameter color = new ColorParameter
	{
		value = Color.white
	};

	[Range(0f, 1f)]
	public FloatParameter density = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class PhotoFilterRenderer : PostProcessEffectRenderer<PhotoFilter>
{
	private int rgbProperty = Shader.PropertyToID("_rgb");

	private int densityProperty = Shader.PropertyToID("_density");

	private Shader greyScaleShader;

	public override void Init()
	{
		base.Init();
		greyScaleShader = Shader.Find("Hidden/PostProcessing/PhotoFilter");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("PhotoFilter");
		PropertySheet propertySheet = context.propertySheets.Get(greyScaleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetColor(rgbProperty, base.settings.color.value);
		propertySheet.properties.SetFloat(densityProperty, base.settings.density.value);
		command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("PhotoFilter");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RadialBlurRenderer), PostProcessEvent.AfterStack, "Custom/RadialBlur", true)]
public class RadialBlur : PostProcessEffectSettings
{
	[Header("Radial Controls")]
	public Vector2Parameter center = new Vector2Parameter
	{
		value = new Vector2(0.5f, 0.5f)
	};

	[Range(0.1f, 2f)]
	public FloatParameter start = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 2f)]
	public FloatParameter amount = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 3f)]
	[Header("Blur Quality")]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 1
	};

	[Range(1f, 4f)]
	public FixedIntParameter iterations = new FixedIntParameter
	{
		value = 2
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class RadialBlurRenderer : PostProcessEffectRenderer<RadialBlur>
{
	private Shader shader;

	private int rt1ID = Shader.PropertyToID("_BlurRT1");

	private int rt2ID = Shader.PropertyToID("_BlurRT2");

	private int paramsID = Shader.PropertyToID("_Params");

	public override void Init()
	{
		base.Init();
		shader = Shader.Find("Hidden/PostProcessing/RadialBlur");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("RadialBlur");
		if (Mathf.Approximately((float)base.settings.start, 1f) && Mathf.Approximately((float)base.settings.amount, 0f))
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		else
		{
			PropertySheet propertySheet = context.propertySheets.Get(shader);
			propertySheet.properties.SetVector(paramsID, new Vector4(base.settings.center.value.x, base.settings.center.value.y, (float)base.settings.start, (float)base.settings.amount));
			int num = context.width >> (int)base.settings.downsample;
			int num2 = context.height >> (int)base.settings.downsample;
			int num3 = (int)base.settings.iterations / 2;
			int num4 = (int)base.settings.iterations % 2;
			command.GetTemporaryRT(rt1ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.GetTemporaryRT(rt2ID, num, num2, 0, (FilterMode)1, context.sourceFormat, (RenderTextureReadWrite)0);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 0, clear: false, null);
			if ((int)base.settings.iterations > 1)
			{
				for (int i = 0; i < num3; i++)
				{
					command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), RenderTargetIdentifier.op_Implicit(rt2ID), propertySheet, 1, clear: false, null);
					if (i == num3 - 1 && num4 == 0)
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), context.destination, propertySheet, 1, clear: false, null);
					}
					else
					{
						command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt2ID), RenderTargetIdentifier.op_Implicit(rt1ID), propertySheet, 1, clear: false, null);
					}
				}
			}
			if (num4 > 0)
			{
				command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(rt1ID), context.destination, propertySheet, 1, clear: false, null);
			}
			command.ReleaseTemporaryRT(rt1ID);
			command.ReleaseTemporaryRT(rt2ID);
		}
		command.EndSample("RadialBlur");
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(RustTemporalAntialiasingRenderer), PostProcessEvent.BeforeStack, "Custom/RustTemporalAntialiasing", false)]
public sealed class RustTemporalAntialiasing : PostProcessEffectSettings
{
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class Jitter
{
	private readonly Vector2[] haltonSequence = (Vector2[])(object)new Vector2[16]
	{
		new Vector2(0.5f, 0.333333f),
		new Vector2(0.25f, 0.666667f),
		new Vector2(0.75f, 0.111111f),
		new Vector2(0.125f, 0.444444f),
		new Vector2(0.625f, 0.777778f),
		new Vector2(0.375f, 0.222222f),
		new Vector2(0.875f, 0.555556f),
		new Vector2(0.0625f, 0.888889f),
		new Vector2(0.5625f, 0.037037f),
		new Vector2(0.3125f, 0.37037f),
		new Vector2(0.8125f, 0.703704f),
		new Vector2(0.1875f, 0.148148f),
		new Vector2(0.6875f, 0.481481f),
		new Vector2(0.4375f, 0.814815f),
		new Vector2(0.9375f, 0.259259f),
		new Vector2(1f / 32f, 0.592593f)
	};

	public int SampleIndex { get; private set; }

	public int SampleCount { get; private set; } = 8;

	public Vector2 Offset { get; private set; } = Vector2.zero;

	public Vector2 TexelOffset { get; private set; } = Vector2.zero;

	public Jitter()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		SampleCount = haltonSequence.Length;
	}

	private Matrix4x4 GetJitteredProjectionMatrix(Camera camera)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		Offset = haltonSequence[++SampleIndex % 8] - new Vector2(0.5f, 0.5f);
		TexelOffset = new Vector2(Offset.x / (float)camera.pixelWidth, Offset.y / (float)camera.pixelHeight);
		return RuntimeUtilities.GetJitteredPerspectiveProjectionMatrix(camera, Offset);
	}

	public void ConfigureCameraJitter(PostProcessRenderContext context)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		Camera camera = context.camera;
		camera.nonJitteredProjectionMatrix = camera.projectionMatrix;
		camera.projectionMatrix = GetJitteredProjectionMatrix(camera);
		camera.useJitteredProjectionMatrixForTransparentRendering = true;
	}
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public sealed class RustTemporalAntialiasingRenderer : PostProcessEffectRenderer<RustTemporalAntialiasing>
{
	private const string BUFFER_NAME = "RustTemporalAntiAliasing";

	private static readonly int historyTextureId = Shader.PropertyToID("_HistoryTex");

	private static readonly int jitterTexelOffsetId = Shader.PropertyToID("_JitterTexelOffset");

	public readonly Jitter JitterSettings = new Jitter();

	private RenderTexture[] historyTextures = (RenderTexture[])(object)new RenderTexture[2];

	private readonly RenderTargetIdentifier[] multipleRenderTargets = (RenderTargetIdentifier[])(object)new RenderTargetIdentifier[2];

	private int pingPongValue;

	private Shader postProcessShader;

	public static RustTemporalAntialiasingRenderer Instance { get; private set; }

	public override void Init()
	{
		if (Instance == null)
		{
			Instance = this;
		}
		postProcessShader = Shader.Find("Hidden/PostProcessing/RustTemporalAntialiasing");
		if ((Object)(object)postProcessShader == (Object)null)
		{
			Debug.LogError((object)"Failed to initialize RustTemporalAntialiasing as the shader couldn't be found!");
		}
	}

	private bool IsValid()
	{
		return (Object)(object)postProcessShader != (Object)null;
	}

	private RenderTexture ConvertTextureToMatchCamera(RenderTexture texture, PostProcessRenderContext context)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Expected O, but got Unknown
		if ((Object)(object)texture == (Object)null || ((Texture)texture).width != context.width || ((Texture)texture).height != context.height)
		{
			if (texture != null)
			{
				texture.Release();
			}
			texture = new RenderTexture(context.width, context.height, 0, context.sourceFormat);
		}
		return texture;
	}

	private void RecreateRenderTexturesIfNeeded(PostProcessRenderContext context)
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			historyTextures[i] = ConvertTextureToMatchCamera(historyTextures[i], context);
		}
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!IsValid())
		{
			context.command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
			return;
		}
		Camera camera = context.camera;
		camera.depthTextureMode = (DepthTextureMode)(camera.depthTextureMode | 5);
		JitterSettings.ConfigureCameraJitter(context);
		RecreateRenderTexturesIfNeeded(context);
		PropertySheet propertySheet = context.propertySheets.Get(postProcessShader);
		CommandBuffer command = context.command;
		RenderTexture val = historyTextures[pingPongValue++ % 2];
		RenderTexture val2 = historyTextures[pingPongValue++ % 2];
		pingPongValue++;
		multipleRenderTargets[0] = context.destination;
		multipleRenderTargets[1] = RenderTargetIdentifier.op_Implicit((Texture)(object)val);
		command.BeginSample("RustTemporalAntiAliasing");
		command.SetGlobalVector(jitterTexelOffsetId, Vector4.op_Implicit(JitterSettings.TexelOffset));
		command.SetGlobalTexture(historyTextureId, RenderTargetIdentifier.op_Implicit((Texture)(object)val2));
		command.BlitFullscreenTriangle(context.source, multipleRenderTargets, RenderTargetIdentifier.op_Implicit((BuiltinRenderTextureType)0), propertySheet, 0, clear: false, null);
		command.EndSample("RustTemporalAntiAliasing");
	}

	public override void Release()
	{
		for (int i = 0; i < historyTextures.Length; i++)
		{
			RenderTexture obj = historyTextures[i];
			if (obj != null)
			{
				obj.Release();
			}
			historyTextures[i] = null;
		}
	}
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class RustTemporalAntialiasingOverlay : MonoBehaviour
{
	public PostProcessVolume postProcessVolume;
}


public enum OverlayBlendMode
{
	Additive,
	ScreenBlend,
	Multiply,
	Overlay,
	AlphaBlend,
	AdditiveNonLit,
	AlpbaBlendConst
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
public sealed class OverlayBlendModeParameter : ParameterOverride<OverlayBlendMode>
{
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(ScreenOverlayRenderer), PostProcessEvent.AfterStack, "Custom/ScreenOverlay", true)]
public class ScreenOverlay : PostProcessEffectSettings
{
	public OverlayBlendModeParameter blendMode = new OverlayBlendModeParameter
	{
		value = OverlayBlendMode.Multiply
	};

	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	public TextureParameter texture = new TextureParameter
	{
		value = null
	};

	public TextureParameter normals = new TextureParameter
	{
		value = null
	};

	public BoolParameter respectUseLightingConvar = new BoolParameter
	{
		value = false
	};
}


using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

public class ScreenOverlayRenderer : PostProcessEffectRenderer<ScreenOverlay>
{
	private Shader overlayShader;

	public override void Init()
	{
		base.Init();
		overlayShader = Shader.Find("Hidden/PostProcessing/ScreenOverlay");
	}

	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(SharpenAndVignetteRenderer), PostProcessEvent.AfterStack, "Custom/SharpenAndVignette", true)]
public class SharpenAndVignette : PostProcessEffectSettings
{
	[Header("Sharpen")]
	public BoolParameter applySharpen = new BoolParameter
	{
		value = true
	};

	[Range(0f, 5f)]
	public FloatParameter strength = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter clamp = new FloatParameter
	{
		value = 1f
	};

	[Header("Vignette")]
	public BoolParameter applyVignette = new BoolParameter
	{
		value = true
	};

	[Range(-100f, 100f)]
	public FloatParameter sharpness = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 100f)]
	public FloatParameter darkness = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class SharpenAndVignetteRenderer : PostProcessEffectRenderer<SharpenAndVignette>
{
	private Shader sharpenAndVigenetteShader;

	public override void Init()
	{
		base.Init();
		sharpenAndVigenetteShader = Shader.Find("Hidden/PostProcessing/SharpenAndVignette");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("SharpenAndVignette");
		PropertySheet propertySheet = context.propertySheets.Get(sharpenAndVigenetteShader);
		propertySheet.properties.Clear();
		bool value = base.settings.applySharpen.value;
		bool value2 = base.settings.applyVignette.value;
		if (value)
		{
			propertySheet.properties.SetFloat("_px", 1f / (float)Screen.width);
			propertySheet.properties.SetFloat("_py", 1f / (float)Screen.height);
			propertySheet.properties.SetFloat("_strength", base.settings.strength.value);
			propertySheet.properties.SetFloat("_clamp", base.settings.clamp.value);
		}
		if (value2)
		{
			propertySheet.properties.SetFloat("_sharpness", base.settings.sharpness.value * 0.01f);
			propertySheet.properties.SetFloat("_darkness", base.settings.darkness.value * 0.02f);
		}
		if (value && !value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		else if (value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 1, clear: false, null);
		}
		else if (!value && value2)
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 2, clear: false, null);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		}
		command.EndSample("SharpenAndVignette");
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(UnderWaterEffectRenderer), PostProcessEvent.AfterStack, "Custom/UnderWaterEffect", false)]
public class UnderwaterPostEffect : PostProcessEffectSettings
{
	[Header("Wiggle")]
	public BoolParameter wiggle = new BoolParameter();

	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};

	[Header("Water Line")]
	public ColorParameter waterLineColor = new ColorParameter();

	[Range(1f, 4f)]
	public FixedIntParameter waterLineBlurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter waterLineBlurSize = new FloatParameter
	{
		value = 0f
	};

	[Range(0f, 2f)]
	[Header("Blur")]
	public FixedIntParameter downsample = new FixedIntParameter
	{
		value = 0
	};

	[Range(1f, 4f)]
	public FixedIntParameter blurIterations = new FixedIntParameter
	{
		value = 1
	};

	[Range(0f, 10f)]
	public FloatParameter blurSize = new FloatParameter
	{
		value = 0f
	};

	public FloatParameter fadeToBlurDistance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine.Rendering.PostProcessing;

public class UnderWaterEffectRenderer : PostProcessEffectRenderer<UnderwaterPostEffect>
{
	public override void Render(PostProcessRenderContext context)
	{
	}
}


using System;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(WiggleRenderer), PostProcessEvent.AfterStack, "Custom/Wiggle", true)]
public class Wiggle : PostProcessEffectSettings
{
	public FloatParameter speed = new FloatParameter
	{
		value = 1f
	};

	public FloatParameter scale = new FloatParameter
	{
		value = 12f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class WiggleRenderer : PostProcessEffectRenderer<Wiggle>
{
	private int timerProperty = Shader.PropertyToID("_timer");

	private int scaleProperty = Shader.PropertyToID("_scale");

	private Shader wiggleShader;

	private float timer;

	public override void Init()
	{
		base.Init();
		wiggleShader = Shader.Find("Hidden/PostProcessing/Wiggle");
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("Wiggle");
		timer += base.settings.speed.value * Time.deltaTime;
		PropertySheet propertySheet = context.propertySheets.Get(wiggleShader);
		propertySheet.properties.Clear();
		propertySheet.properties.SetFloat(timerProperty, timer);
		propertySheet.properties.SetFloat(scaleProperty, base.settings.scale.value);
		context.command.BlitFullscreenTriangle(context.source, context.destination, propertySheet, 0, clear: false, null);
		command.EndSample("Wiggle");
	}
}


using UnityEngine;

public class PostProcessVolumeLOD : MonoBehaviour, ILOD, IClientComponent
{
	public float distance;
}


using System;

public class BoundsCheck : PrefabAttribute
{
	public enum BlockType
	{
		Tree
	}

	public BlockType IsType;

	protected override Type GetIndexedType()
	{
		return typeof(BoundsCheck);
	}
}


public enum BlockType
{
	Tree
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class BoundsCheckEx
{
	public static bool ApplyBoundsChecks(this BaseEntity entity, BoundsCheck[] bounds, Vector3 pos, Quaternion rot, Vector3 scale, LayerMask rejectOnLayer)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (bounds.Length == 0 && LayerMask.op_Implicit(rejectOnLayer) == 0)
		{
			return true;
		}
		OBB obb = new OBB(pos + rot * Vector3.Scale(((Bounds)(ref entity.bounds)).center, scale), Vector3.Scale(((Bounds)(ref entity.bounds)).extents, scale), rot);
		List<Collider> list = Pool.Get<List<Collider>>();
		GamePhysics.OverlapOBB(obb, list, 0x40000 | LayerMask.op_Implicit(rejectOnLayer), (QueryTriggerInteraction)2);
		SpawnableBoundsBlocker spawnableBoundsBlocker = default(SpawnableBoundsBlocker);
		foreach (Collider item in list)
		{
			if (!item.isTrigger && (((Component)item).gameObject.layer & LayerMask.op_Implicit(rejectOnLayer)) != 0)
			{
				Pool.FreeUnmanaged<Collider>(ref list);
				return false;
			}
			if (!((Component)item).TryGetComponent<SpawnableBoundsBlocker>(ref spawnableBoundsBlocker))
			{
				continue;
			}
			foreach (BoundsCheck boundsCheck in bounds)
			{
				if (spawnableBoundsBlocker.BlockType == boundsCheck.IsType)
				{
					Pool.FreeUnmanaged<Collider>(ref list);
					return false;
				}
			}
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class SpawnableBoundsBlocker : MonoBehaviour
{
	public BoundsCheck.BlockType BlockType;

	public BoxCollider BoxCollider;

	[Button("Clear Trees")]
	public void ClearTrees()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		List<TreeEntity> list = Pool.Get<List<TreeEntity>>();
		if ((Object)(object)BoxCollider != (Object)null)
		{
			GamePhysics.OverlapOBB<TreeEntity>(new OBB(((Component)this).transform.TransformPoint(BoxCollider.center), BoxCollider.size + Vector3.one, ((Component)this).transform.rotation), list, 1073741824, (QueryTriggerInteraction)2);
		}
		foreach (TreeEntity item in list)
		{
			BoundsCheck boundsCheck = PrefabAttribute.server.Find<BoundsCheck>(item.prefabID);
			if (boundsCheck != null && boundsCheck.IsType == BlockType)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<TreeEntity>(ref list);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ByteMap
{
	[SerializeField]
	private int size;

	[SerializeField]
	private int bytes;

	[SerializeField]
	private byte[] values;

	public int Size => size;

	public uint this[int x, int y]
	{
		get
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				return values[num];
			case 2:
			{
				byte num7 = values[num];
				uint num3 = values[num + 1];
				return (uint)(num7 << 8) | num3;
			}
			case 3:
			{
				byte num6 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				return (uint)(num6 << 16) | (num3 << 8) | num4;
			}
			default:
			{
				byte num2 = values[num];
				uint num3 = values[num + 1];
				uint num4 = values[num + 2];
				uint num5 = values[num + 3];
				return (uint)(num2 << 24) | (num3 << 16) | (num4 << 8) | num5;
			}
			}
		}
		set
		{
			int num = y * bytes * size + x * bytes;
			switch (bytes)
			{
			case 1:
				values[num] = (byte)(value & 0xFF);
				break;
			case 2:
				values[num] = (byte)((value >> 8) & 0xFF);
				values[num + 1] = (byte)(value & 0xFF);
				break;
			case 3:
				values[num] = (byte)((value >> 16) & 0xFF);
				values[num + 1] = (byte)((value >> 8) & 0xFF);
				values[num + 2] = (byte)(value & 0xFF);
				break;
			default:
				values[num] = (byte)((value >> 24) & 0xFF);
				values[num + 1] = (byte)((value >> 16) & 0xFF);
				values[num + 2] = (byte)((value >> 8) & 0xFF);
				values[num + 3] = (byte)(value & 0xFF);
				break;
			}
		}
	}

	public ByteMap(int size, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		values = new byte[bytes * size * size];
	}

	public ByteMap(int size, byte[] values, int bytes = 1)
	{
		this.size = size;
		this.bytes = bytes;
		this.values = values;
	}
}


using System;
using UnityEngine;

[Serializable]
public sealed class ByteQuadtree
{
	public struct Element
	{
		private ByteQuadtree source;

		private int x;

		private int y;

		private int level;

		public bool IsLeaf => level == 0;

		public bool IsRoot => level == source.levels - 1;

		public int ByteMap => level;

		public uint Value => source.values[level][x, y];

		public Vector2 Coords => new Vector2((float)x, (float)y);

		public int Depth => source.levels - level - 1;

		public Element Parent
		{
			get
			{
				if (IsRoot)
				{
					throw new Exception("Element is the root and therefore has no parent.");
				}
				return new Element(source, x / 2, y / 2, level + 1);
			}
		}

		public Element Child1
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2, level - 1);
			}
		}

		public Element Child2
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2, level - 1);
			}
		}

		public Element Child3
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2, y * 2 + 1, level - 1);
			}
		}

		public Element Child4
		{
			get
			{
				if (IsLeaf)
				{
					throw new Exception("Element is a leaf and therefore has no children.");
				}
				return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
			}
		}

		public Element MaxChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				if (value >= value2 && value >= value3 && value >= value4)
				{
					return child;
				}
				if (value2 >= value3 && value2 >= value4)
				{
					return child2;
				}
				if (value3 >= value4)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element RandChild
		{
			get
			{
				Element child = Child1;
				Element child2 = Child2;
				Element child3 = Child3;
				Element child4 = Child4;
				uint value = child.Value;
				uint value2 = child2.Value;
				uint value3 = child3.Value;
				uint value4 = child4.Value;
				float num = value + value2 + value3 + value4;
				float value5 = Random.value;
				if ((float)value / num >= value5)
				{
					return child;
				}
				if ((float)(value + value2) / num >= value5)
				{
					return child2;
				}
				if ((float)(value + value2 + value3) / num >= value5)
				{
					return child3;
				}
				return child4;
			}
		}

		public Element(ByteQuadtree source, int x, int y, int level)
		{
			this.source = source;
			this.x = x;
			this.y = y;
			this.level = level;
		}
	}

	[SerializeField]
	private int size;

	[SerializeField]
	private int levels;

	[SerializeField]
	private ByteMap[] values;

	public int Size => size;

	public Element Root => new Element(this, 0, 0, levels - 1);

	public void UpdateValues(byte[] baseValues)
	{
		size = Mathf.RoundToInt(Mathf.Sqrt((float)baseValues.Length));
		levels = Mathf.RoundToInt(Mathf.Max(Mathf.Log((float)size, 2f), 0f)) + 1;
		values = new ByteMap[levels];
		values[0] = new ByteMap(size, baseValues);
		for (int i = 1; i < levels; i++)
		{
			ByteMap byteMap = values[i - 1];
			ByteMap byteMap2 = (values[i] = CreateLevel(i));
			for (int j = 0; j < byteMap2.Size; j++)
			{
				for (int k = 0; k < byteMap2.Size; k++)
				{
					byteMap2[k, j] = byteMap[2 * k, 2 * j] + byteMap[2 * k + 1, 2 * j] + byteMap[2 * k, 2 * j + 1] + byteMap[2 * k + 1, 2 * j + 1];
				}
			}
		}
	}

	private ByteMap CreateLevel(int level)
	{
		int num = 1 << levels - level - 1;
		int bytes = 1 + (level + 3) / 4;
		return new ByteMap(num, bytes);
	}
}


using System;
using UnityEngine;

public struct Element
{
	private ByteQuadtree source;

	private int x;

	private int y;

	private int level;

	public bool IsLeaf => level == 0;

	public bool IsRoot => level == source.levels - 1;

	public int ByteMap => level;

	public uint Value => source.values[level][x, y];

	public Vector2 Coords => new Vector2((float)x, (float)y);

	public int Depth => source.levels - level - 1;

	public Element Parent
	{
		get
		{
			if (IsRoot)
			{
				throw new Exception("Element is the root and therefore has no parent.");
			}
			return new Element(source, x / 2, y / 2, level + 1);
		}
	}

	public Element Child1
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2, level - 1);
		}
	}

	public Element Child2
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2, level - 1);
		}
	}

	public Element Child3
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2, y * 2 + 1, level - 1);
		}
	}

	public Element Child4
	{
		get
		{
			if (IsLeaf)
			{
				throw new Exception("Element is a leaf and therefore has no children.");
			}
			return new Element(source, x * 2 + 1, y * 2 + 1, level - 1);
		}
	}

	public Element MaxChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			if (value >= value2 && value >= value3 && value >= value4)
			{
				return child;
			}
			if (value2 >= value3 && value2 >= value4)
			{
				return child2;
			}
			if (value3 >= value4)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element RandChild
	{
		get
		{
			Element child = Child1;
			Element child2 = Child2;
			Element child3 = Child3;
			Element child4 = Child4;
			uint value = child.Value;
			uint value2 = child2.Value;
			uint value3 = child3.Value;
			uint value4 = child4.Value;
			float num = value + value2 + value3 + value4;
			float value5 = Random.value;
			if ((float)value / num >= value5)
			{
				return child;
			}
			if ((float)(value + value2) / num >= value5)
			{
				return child2;
			}
			if ((float)(value + value2 + value3) / num >= value5)
			{
				return child3;
			}
			return child4;
		}
	}

	public Element(ByteQuadtree source, int x, int y, int level)
	{
		this.source = source;
		this.x = x;
		this.y = y;
		this.level = level;
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;

public static class ImageProcessing
{
	private static byte[] signaturePNG = new byte[8] { 137, 80, 78, 71, 13, 10, 26, 10 };

	private static byte[] signatureIHDR = new byte[8] { 0, 0, 0, 13, 73, 72, 68, 82 };

	public static void GaussianBlur2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] array = data;
		float[] array2 = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			for (int j = 0; j < len1; j++)
			{
				int num = Mathf.Max(0, j - 1);
				int num2 = Mathf.Min(len1 - 1, j + 1);
				for (int k = 0; k < len2; k++)
				{
					int num3 = Mathf.Max(0, k - 1);
					int num4 = Mathf.Min(len2 - 1, k + 1);
					float num5 = array[j * len2 + k] * 4f + array[j * len2 + num3] + array[j * len2 + num4] + array[num * len2 + k] + array[num2 * len2 + k];
					array2[j * len2 + k] = num5 * 0.125f;
				}
			}
			GenericsUtil.Swap<float[]>(ref array, ref array2);
		}
		if (array != data)
		{
			Buffer.BlockCopy(array, 0, data, 0, data.Length * 4);
		}
	}

	public static void GaussianBlur2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] * 4f + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.125f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					float num5 = src[x * len2 + j] + src[x * len2 + num3] + src[x * len2 + num4] + src[num * len2 + j] + src[num2 * len2 + j];
					dst[x * len2 + j] = num5 * 0.2f;
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Average2D(float[] data, int len1, int len2, int len3, int iterations = 1)
	{
		float[] src = data;
		float[] dst = new float[len1 * len2 * len3];
		for (int i = 0; i < iterations; i++)
		{
			Parallel.For(0, len1, (Action<int>)delegate(int x)
			{
				int num = Mathf.Max(0, x - 1);
				int num2 = Mathf.Min(len1 - 1, x + 1);
				for (int j = 0; j < len2; j++)
				{
					int num3 = Mathf.Max(0, j - 1);
					int num4 = Mathf.Min(len2 - 1, j + 1);
					for (int k = 0; k < len3; k++)
					{
						float num5 = src[(x * len2 + j) * len3 + k] + src[(x * len2 + num3) * len3 + k] + src[(x * len2 + num4) * len3 + k] + src[(num * len2 + j) * len3 + k] + src[(num2 * len2 + j) * len3 + k];
						dst[(x * len2 + j) * len3 + k] = num5 * 0.2f;
					}
				}
			});
			GenericsUtil.Swap<float[]>(ref src, ref dst);
		}
		if (src != data)
		{
			Buffer.BlockCopy(src, 0, data, 0, data.Length * 4);
		}
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, float[] dst, int dstlen1, int dstlen2)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2)
		{
			return;
		}
		Parallel.For(0, srclen1, (Action<int>)delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				float num5 = src[x * srclen2 + i] * 6f;
				float num6 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num3];
				dst[2 * x * dstlen2 + 2 * i] = num6 * 0.125f;
				float num7 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num3];
				dst[(2 * x + 1) * dstlen2 + 2 * i] = num7 * 0.125f;
				float num8 = num5 + src[num * srclen2 + i] + src[x * srclen2 + num4];
				dst[2 * x * dstlen2 + (2 * i + 1)] = num8 * 0.125f;
				float num9 = num5 + src[num2 * srclen2 + i] + src[x * srclen2 + num4];
				dst[(2 * x + 1) * dstlen2 + (2 * i + 1)] = num9 * 0.125f;
			}
		});
	}

	public static void Upsample2D(float[] src, int srclen1, int srclen2, int srclen3, float[] dst, int dstlen1, int dstlen2, int dstlen3)
	{
		if (2 * srclen1 != dstlen1 || 2 * srclen2 != dstlen2 || srclen3 != dstlen3)
		{
			return;
		}
		Parallel.For(0, srclen1, (Action<int>)delegate(int x)
		{
			int num = Mathf.Max(0, x - 1);
			int num2 = Mathf.Min(srclen1 - 1, x + 1);
			for (int i = 0; i < srclen2; i++)
			{
				int num3 = Mathf.Max(0, i - 1);
				int num4 = Mathf.Min(srclen2 - 1, i + 1);
				for (int j = 0; j < srclen3; j++)
				{
					float num5 = src[(x * srclen2 + i) * srclen3 + j] * 6f;
					float num6 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[(2 * x * dstlen2 + 2 * i) * dstlen3 + j] = num6 * 0.125f;
					float num7 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num3) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + 2 * i) * dstlen3 + j] = num7 * 0.125f;
					float num8 = num5 + src[(num * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[(2 * x * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num8 * 0.125f;
					float num9 = num5 + src[(num2 * srclen2 + i) * srclen3 + j] + src[(x * srclen2 + num4) * srclen3 + j];
					dst[((2 * x + 1) * dstlen2 + (2 * i + 1)) * dstlen3 + j] = num9 * 0.125f;
				}
			}
		});
	}

	public static void Dilate2D(NativeArray<int> src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Parallel.For(0, len1, (Action<int>)delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, (Action<int>)delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void Dilate2D(int[] src, int len1, int len2, int srcmask, int radius, Action<int, int> action)
	{
		Parallel.For(0, len1, (Action<int>)delegate(int x)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val = new MaxQueue(radius * 2 + 1);
			for (int i = 0; i < radius; i++)
			{
				val.Push(src[x * len2 + i] & srcmask);
			}
			for (int j = 0; j < len2; j++)
			{
				if (j > radius)
				{
					val.Pop();
				}
				if (j < len2 - radius)
				{
					val.Push(src[x * len2 + j + radius] & srcmask);
				}
				if (val.Max != 0)
				{
					action(x, j);
				}
			}
		});
		Parallel.For(0, len2, (Action<int>)delegate(int y)
		{
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Expected O, but got Unknown
			MaxQueue val2 = new MaxQueue(radius * 2 + 1);
			for (int k = 0; k < radius; k++)
			{
				val2.Push(src[k * len2 + y] & srcmask);
			}
			for (int l = 0; l < len1; l++)
			{
				if (l > radius)
				{
					val2.Pop();
				}
				if (l < len1 - radius)
				{
					val2.Push(src[(l + radius) * len2 + y] & srcmask);
				}
				if (val2.Max != 0)
				{
					action(l, y);
				}
			}
		});
	}

	public static void FloodFill2D(int x, int y, int[] data, int len1, int len2, int mask_any, int mask_not, Func<int, int> action)
	{
		Stack<KeyValuePair<int, int>> stack = new Stack<KeyValuePair<int, int>>();
		stack.Push(new KeyValuePair<int, int>(x, y));
		while (stack.Count > 0)
		{
			KeyValuePair<int, int> keyValuePair = stack.Pop();
			x = keyValuePair.Key;
			y = keyValuePair.Value;
			int num;
			for (num = y; num >= 0; num--)
			{
				int num2 = data[x * len2 + num];
				if ((num2 & mask_any) == 0 || (num2 & mask_not) != 0)
				{
					break;
				}
			}
			num++;
			bool flag;
			bool flag2 = (flag = false);
			for (; num < len2; num++)
			{
				int num3 = data[x * len2 + num];
				if ((num3 & mask_any) == 0 || (num3 & mask_not) != 0)
				{
					break;
				}
				data[x * len2 + num] = action(num3);
				if (x > 0)
				{
					int num4 = data[(x - 1) * len2 + num];
					bool flag3 = (num4 & mask_any) != 0 && (num4 & mask_not) == 0;
					if (!flag2 && flag3)
					{
						stack.Push(new KeyValuePair<int, int>(x - 1, num));
						flag2 = true;
					}
					else if (flag2 && !flag3)
					{
						flag2 = false;
					}
				}
				if (x < len1 - 1)
				{
					int num5 = data[(x + 1) * len2 + num];
					bool flag4 = (num5 & mask_any) != 0 && (num5 & mask_not) == 0;
					if (!flag && flag4)
					{
						stack.Push(new KeyValuePair<int, int>(x + 1, num));
						flag = true;
					}
					else if (flag && !flag4)
					{
						flag = false;
					}
				}
			}
		}
	}

	public static bool IsValidPNG(byte[] data, int maxSizeSquare)
	{
		return IsValidPNG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidPNG(byte[] data, int maxWidth, int maxHeight)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		if (data == null || data.Length < 29)
		{
			return false;
		}
		if (data.Length > 29 + maxWidth * maxHeight * 4)
		{
			return false;
		}
		for (int i = 0; i < signaturePNG.Length; i++)
		{
			if (data[i] != signaturePNG[i])
			{
				return false;
			}
		}
		for (int j = 0; j < signatureIHDR.Length; j++)
		{
			if (data[8 + j] != signatureIHDR[j])
			{
				return false;
			}
		}
		Union32 val = default(Union32);
		val.b4 = data[16];
		val.b3 = data[17];
		val.b2 = data[18];
		val.b1 = data[19];
		if (val.i < 1 || val.i > maxWidth)
		{
			return false;
		}
		Union32 val2 = default(Union32);
		val2.b4 = data[20];
		val2.b3 = data[21];
		val2.b2 = data[22];
		val2.b1 = data[23];
		if (val2.i < 1 || val2.i > maxHeight)
		{
			return false;
		}
		byte b = data[24];
		if (b != 8 && b != 16)
		{
			return false;
		}
		byte b2 = data[25];
		if (b2 != 2 && b2 != 6)
		{
			return false;
		}
		if (data[26] != 0)
		{
			return false;
		}
		if (data[27] != 0)
		{
			return false;
		}
		if (data[28] != 0)
		{
			return false;
		}
		return true;
	}

	public static bool IsValidJPG(byte[] data, int maxSizeSquare)
	{
		return IsValidJPG(data, maxSizeSquare, maxSizeSquare);
	}

	public static bool IsValidJPG(byte[] data, int maxWidth, int maxHeight)
	{
		if (data.Length < 30)
		{
			return false;
		}
		if (data.Length > 30 + maxWidth * maxHeight)
		{
			return false;
		}
		try
		{
			if (data[0] != byte.MaxValue || data[1] != 216)
			{
				return false;
			}
			if (data[2] != byte.MaxValue || data[3] != 224)
			{
				return false;
			}
			if (data[6] != 74 || data[7] != 70 || data[8] != 73 || data[9] != 70 || data[10] != 0)
			{
				return false;
			}
			if (data[13] != 0)
			{
				return false;
			}
			if (data[14] != data[16] || data[15] != data[17])
			{
				return false;
			}
			int num = 4;
			int num2 = (data[num] << 8) | data[num + 1];
			while (num < data.Length)
			{
				num += num2;
				if (num >= data.Length)
				{
					return false;
				}
				if (data[num] != byte.MaxValue)
				{
					return false;
				}
				if (data[num + 1] == 192 || data[num + 1] == 193 || data[num + 1] == 194)
				{
					int num3 = (data[num + 5] << 8) | data[num + 6];
					return ((data[num + 7] << 8) | data[num + 8]) <= maxWidth && num3 <= maxHeight;
				}
				num += 2;
				num2 = (data[num] << 8) | data[num + 1];
			}
			return false;
		}
		catch
		{
			return false;
		}
	}

	public static bool IsClear(Color32[] data)
	{
		for (int i = 0; i < data.Length; i++)
		{
			if (data[i].a > 5)
			{
				return false;
			}
		}
		return true;
	}
}


public static class ManagedNoise
{
	private static readonly int[] hash = new int[512]
	{
		151, 160, 137, 91, 90, 15, 131, 13, 201, 95,
		96, 53, 194, 233, 7, 225, 140, 36, 103, 30,
		69, 142, 8, 99, 37, 240, 21, 10, 23, 190,
		6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
		94, 252, 219, 203, 117, 35, 11, 32, 57, 177,
		33, 88, 237, 149, 56, 87, 174, 20, 125, 136,
		171, 168, 68, 175, 74, 165, 71, 134, 139, 48,
		27, 166, 77, 146, 158, 231, 83, 111, 229, 122,
		60, 211, 133, 230, 220, 105, 92, 41, 55, 46,
		245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
		1, 216, 80, 73, 209, 76, 132, 187, 208, 89,
		18, 169, 200, 196, 135, 130, 116, 188, 159, 86,
		164, 100, 109, 198, 173, 186, 3, 64, 52, 217,
		226, 250, 124, 123, 5, 202, 38, 147, 118, 126,
		255, 82, 85, 212, 207, 206, 59, 227, 47, 16,
		58, 17, 182, 189, 28, 42, 223, 183, 170, 213,
		119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
		101, 155, 167, 43, 172, 9, 129, 22, 39, 253,
		19, 98, 108, 110, 79, 113, 224, 232, 178, 185,
		112, 104, 218, 246, 97, 228, 251, 34, 242, 193,
		238, 210, 144, 12, 191, 179, 162, 241, 81, 51,
		145, 235, 249, 14, 239, 107, 49, 192, 214, 31,
		181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
		50, 45, 127, 4, 150, 254, 138, 236, 205, 93,
		222, 114, 67, 29, 24, 72, 243, 141, 128, 195,
		78, 66, 215, 61, 156, 180, 151, 160, 137, 91,
		90, 15, 131, 13, 201, 95, 96, 53, 194, 233,
		7, 225, 140, 36, 103, 30, 69, 142, 8, 99,
		37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
		234, 75, 0, 26, 197, 62, 94, 252, 219, 203,
		117, 35, 11, 32, 57, 177, 33, 88, 237, 149,
		56, 87, 174, 20, 125, 136, 171, 168, 68, 175,
		74, 165, 71, 134, 139, 48, 27, 166, 77, 146,
		158, 231, 83, 111, 229, 122, 60, 211, 133, 230,
		220, 105, 92, 41, 55, 46, 245, 40, 244, 102,
		143, 54, 65, 25, 63, 161, 1, 216, 80, 73,
		209, 76, 132, 187, 208, 89, 18, 169, 200, 196,
		135, 130, 116, 188, 159, 86, 164, 100, 109, 198,
		173, 186, 3, 64, 52, 217, 226, 250, 124, 123,
		5, 202, 38, 147, 118, 126, 255, 82, 85, 212,
		207, 206, 59, 227, 47, 16, 58, 17, 182, 189,
		28, 42, 223, 183, 170, 213, 119, 248, 152, 2,
		44, 154, 163, 70, 221, 153, 101, 155, 167, 43,
		172, 9, 129, 22, 39, 253, 19, 98, 108, 110,
		79, 113, 224, 232, 178, 185, 112, 104, 218, 246,
		97, 228, 251, 34, 242, 193, 238, 210, 144, 12,
		191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
		239, 107, 49, 192, 214, 31, 181, 199, 106, 157,
		184, 84, 204, 176, 115, 121, 50, 45, 127, 4,
		150, 254, 138, 236, 205, 93, 222, 114, 67, 29,
		24, 72, 243, 141, 128, 195, 78, 66, 215, 61,
		156, 180
	};

	private const int hashMask = 255;

	private const double sqrt2 = 1.4142135623730951;

	private const double rsqrt2 = 0.7071067811865476;

	private const double squaresToTriangles = 0.2113248654051871;

	private const double trianglesToSquares = 0.36602540378443865;

	private const double simplexScale1D = 2.4074074074074074;

	private const double simplexScale2D = 32.99077398303956;

	private const double gradientScale2D = 4.0;

	private static double[] gradients1D = new double[2] { 1.0, -1.0 };

	private const int gradientsMask1D = 1;

	private static double[] gradients2Dx = new double[8] { 1.0, -1.0, 0.0, 0.0, 0.7071067811865476, -0.7071067811865476, 0.7071067811865476, -0.7071067811865476 };

	private static double[] gradients2Dy = new double[8] { 0.0, 0.0, 1.0, -1.0, 0.7071067811865476, 0.7071067811865476, -0.7071067811865476, -0.7071067811865476 };

	private const int gradientsMask2D = 7;

	public static double Simplex1D(double x)
	{
		double num = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8] * num4;
			num += num9 * num7;
		}
		int num10 = num3 + 1;
		double num11 = x - (double)num10;
		double num12 = 1.0 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[num10 & 0xFF] & 1;
			double num16 = gradients1D[num15] * num11;
			num += num16 * num14;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex1D(double x, out double dx)
	{
		double num = 0.0;
		dx = 0.0;
		int num2;
		int num3 = (num2 = Floor(x));
		double num4 = x - (double)num2;
		double num5 = 1.0 - num4 * num4;
		if (num5 > 0.0)
		{
			double num6 = num5 * num5;
			double num7 = num5 * num6;
			int num8 = hash[num2 & 0xFF] & 1;
			double num9 = gradients1D[num8];
			double num10 = num9 * num4;
			double num11 = num10 * 6.0 * num6;
			dx += num9 * num7 - num11 * num4;
			num += num10 * num7;
		}
		int num12 = num3 + 1;
		double num13 = x - (double)num12;
		double num14 = 1.0 - num13 * num13;
		if (num14 > 0.0)
		{
			double num15 = num14 * num14;
			double num16 = num14 * num15;
			int num17 = hash[num12 & 0xFF] & 1;
			double num18 = gradients1D[num17];
			double num19 = num18 * num13;
			double num20 = num19 * 6.0 * num15;
			dx += num18 * num16 - num20 * num13;
			num += num19 * num16;
		}
		return num * 2.4074074074074074;
	}

	public static double Simplex2D(double x, double y)
	{
		double num = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			num += num18 * num14;
		}
		int num19 = num5 + 1;
		int num20 = num6 + 1;
		double num21 = (double)(num19 + num20) * 0.2113248654051871;
		double num22 = x - (double)num19 + num21;
		double num23 = y - (double)num20 + num21;
		double num24 = 0.5 - num22 * num22 - num23 * num23;
		if (num24 > 0.0)
		{
			double num25 = num24 * num24;
			double num26 = num24 * num25;
			int num27 = hash[(hash[num19 & 0xFF] + num20) & 0xFF] & 7;
			double num28 = gradients2Dx[num27];
			double num29 = gradients2Dy[num27];
			double num30 = num28 * num22 + num29 * num23;
			num += num30 * num26;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num31 = num5 + 1;
			int num32 = num6;
			double num33 = (double)(num31 + num32) * 0.2113248654051871;
			double num34 = x - (double)num31 + num33;
			double num35 = y - (double)num32 + num33;
			double num36 = 0.5 - num34 * num34 - num35 * num35;
			if (num36 > 0.0)
			{
				double num37 = num36 * num36;
				double num38 = num36 * num37;
				int num39 = hash[(hash[num31 & 0xFF] + num32) & 0xFF] & 7;
				double num40 = gradients2Dx[num39];
				double num41 = gradients2Dy[num39];
				double num42 = num40 * num34 + num41 * num35;
				num += num42 * num38;
			}
		}
		else
		{
			int num43 = num5;
			int num44 = num6 + 1;
			double num45 = (double)(num43 + num44) * 0.2113248654051871;
			double num46 = x - (double)num43 + num45;
			double num47 = y - (double)num44 + num45;
			double num48 = 0.5 - num46 * num46 - num47 * num47;
			if (num48 > 0.0)
			{
				double num49 = num48 * num48;
				double num50 = num48 * num49;
				int num51 = hash[(hash[num43 & 0xFF] + num44) & 0xFF] & 7;
				double num52 = gradients2Dx[num51];
				double num53 = gradients2Dy[num51];
				double num54 = num52 * num46 + num53 * num47;
				num += num54 * num50;
			}
		}
		return num * 32.99077398303956;
	}

	public static double Simplex2D(double x, double y, out double dx, out double dy)
	{
		double num = 0.0;
		dx = 0.0;
		dy = 0.0;
		double num2 = (x + y) * 0.36602540378443865;
		double num3 = x + num2;
		double num4 = y + num2;
		int num5 = Floor(num3);
		int num6 = Floor(num4);
		int num7 = num5;
		int num8 = num6;
		double num9 = (double)(num7 + num8) * 0.2113248654051871;
		double num10 = x - (double)num7 + num9;
		double num11 = y - (double)num8 + num9;
		double num12 = 0.5 - num10 * num10 - num11 * num11;
		if (num12 > 0.0)
		{
			double num13 = num12 * num12;
			double num14 = num12 * num13;
			int num15 = hash[(hash[num7 & 0xFF] + num8) & 0xFF] & 7;
			double num16 = gradients2Dx[num15];
			double num17 = gradients2Dy[num15];
			double num18 = num16 * num10 + num17 * num11;
			double num19 = num18 * 6.0 * num13;
			dx += num16 * num14 - num19 * num10;
			dy += num17 * num14 - num19 * num11;
			num += num18 * num14;
		}
		int num20 = num5 + 1;
		int num21 = num6 + 1;
		double num22 = (double)(num20 + num21) * 0.2113248654051871;
		double num23 = x - (double)num20 + num22;
		double num24 = y - (double)num21 + num22;
		double num25 = 0.5 - num23 * num23 - num24 * num24;
		if (num25 > 0.0)
		{
			double num26 = num25 * num25;
			double num27 = num25 * num26;
			int num28 = hash[(hash[num20 & 0xFF] + num21) & 0xFF] & 7;
			double num29 = gradients2Dx[num28];
			double num30 = gradients2Dy[num28];
			double num31 = num29 * num23 + num30 * num24;
			double num32 = num31 * 6.0 * num26;
			dx += num29 * num27 - num32 * num23;
			dy += num30 * num27 - num32 * num24;
			num += num31 * num27;
		}
		if (num3 - (double)num5 >= num4 - (double)num6)
		{
			int num33 = num5 + 1;
			int num34 = num6;
			double num35 = (double)(num33 + num34) * 0.2113248654051871;
			double num36 = x - (double)num33 + num35;
			double num37 = y - (double)num34 + num35;
			double num38 = 0.5 - num36 * num36 - num37 * num37;
			if (num38 > 0.0)
			{
				double num39 = num38 * num38;
				double num40 = num38 * num39;
				int num41 = hash[(hash[num33 & 0xFF] + num34) & 0xFF] & 7;
				double num42 = gradients2Dx[num41];
				double num43 = gradients2Dy[num41];
				double num44 = num42 * num36 + num43 * num37;
				double num45 = num44 * 6.0 * num39;
				dx += num42 * num40 - num45 * num36;
				dy += num43 * num40 - num45 * num37;
				num += num44 * num40;
			}
		}
		else
		{
			int num46 = num5;
			int num47 = num6 + 1;
			double num48 = (double)(num46 + num47) * 0.2113248654051871;
			double num49 = x - (double)num46 + num48;
			double num50 = y - (double)num47 + num48;
			double num51 = 0.5 - num49 * num49 - num50 * num50;
			if (num51 > 0.0)
			{
				double num52 = num51 * num51;
				double num53 = num51 * num52;
				int num54 = hash[(hash[num46 & 0xFF] + num47) & 0xFF] & 7;
				double num55 = gradients2Dx[num54];
				double num56 = gradients2Dy[num54];
				double num57 = num55 * num49 + num56 * num50;
				double num58 = num57 * 6.0 * num52;
				dx += num55 * num53 - num58 * num49;
				dy += num56 * num53 - num58 * num50;
				num += num57 * num53;
			}
		}
		dx *= 4.0;
		dy *= 4.0;
		return num * 32.99077398303956;
	}

	public static double Turbulence(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * num4;
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Billow(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * Abs(x2);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Ridge(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double x2 = Simplex2D(x * num2, y * num2);
			num += num3 * (1.0 - Abs(x2));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double Sharp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		for (int i = 0; i < octaves; i++)
		{
			double num4 = Simplex2D(x * num2, y * num2);
			num += num3 * (num4 * num4);
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * num6 / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double BillowIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * Abs(x2) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double RidgeIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double x2 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (1.0 - Abs(x2)) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double SharpIQ(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D(x * num2, y * num2, out dx, out dy);
			num4 += dx;
			num5 += dy;
			num += num3 * (num6 * num6) / (1.0 + (num4 * num4 + num5 * num5));
			num2 *= lacunarity;
			num3 *= gain;
		}
		return num * amplitude;
	}

	public static double TurbulenceWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * num6;
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double BillowWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * Abs(num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double RidgeWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (1.0 - Abs(num6));
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double SharpWarp(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num6 = Simplex2D((x + warp * num4) * num2, (y + warp * num5) * num2, out dx, out dy);
			num += num3 * (num6 * num6);
			num4 += num3 * dx * (0.0 - num6);
			num5 += num3 * dy * (0.0 - num6);
			num2 *= lacunarity;
			num3 *= gain * Saturate(num);
		}
		return num * amplitude;
	}

	public static double Jordan(double x, double y, int octaves, double frequency, double amplitude, double lacunarity, double gain, double warp, double damp, double damp_scale)
	{
		x *= frequency;
		y *= frequency;
		double num = 0.0;
		double num2 = 1.0;
		double num3 = 1.0;
		double num4 = 0.0;
		double num5 = 0.0;
		double num6 = 0.0;
		double num7 = 0.0;
		double num8 = num2 * gain;
		for (int i = 0; i < octaves; i++)
		{
			double dx;
			double dy;
			double num9 = Simplex2D(x * num3 + num4, y * num3 + num5, out dx, out dy);
			double num10 = num9 * num9;
			double num11 = dx * num9;
			double num12 = dy * num9;
			num += num8 * num10;
			num4 += warp * num11;
			num5 += warp * num12;
			num6 += damp * num11;
			num7 += damp * num12;
			num3 *= lacunarity;
			num2 *= gain;
			num8 = num2 * (1.0 - damp_scale / (1.0 + (num6 * num6 + num7 * num7)));
		}
		return num * amplitude;
	}

	private static int Floor(double x)
	{
		if (!(x >= 0.0))
		{
			return (int)x - 1;
		}
		return (int)x;
	}

	private static double Abs(double x)
	{
		if (!(x >= 0.0))
		{
			return 0.0 - x;
		}
		return x;
	}

	private static double Saturate(double x)
	{
		if (!(x > 1.0))
		{
			if (!(x < 0.0))
			{
				return x;
			}
			return 0.0;
		}
		return 1.0;
	}
}


using System.Runtime.InteropServices;
using System.Security;

[SuppressUnmanagedCodeSecurity]
public static class NativeNoise
{
	[DllImport("RustNative", EntryPoint = "snoise1_32")]
	public static extern float Simplex1D(float x);

	[DllImport("RustNative", EntryPoint = "sdnoise1_32")]
	public static extern float Simplex1D(float x, out float dx);

	[DllImport("RustNative", EntryPoint = "snoise2_32")]
	public static extern float Simplex2D(float x, float y);

	[DllImport("RustNative", EntryPoint = "sdnoise2_32")]
	public static extern float Simplex2D(float x, float y, out float dx, out float dy);

	[DllImport("RustNative", EntryPoint = "turbulence_32")]
	public static extern float Turbulence(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_32")]
	public static extern float Billow(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_32")]
	public static extern float Ridge(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_32")]
	public static extern float Sharp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_iq_32")]
	public static extern float TurbulenceIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "billow_iq_32")]
	public static extern float BillowIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "ridge_iq_32")]
	public static extern float RidgeIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "sharp_iq_32")]
	public static extern float SharpIQ(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain);

	[DllImport("RustNative", EntryPoint = "turbulence_warp_32")]
	public static extern float TurbulenceWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "billow_warp_32")]
	public static extern float BillowWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "ridge_warp_32")]
	public static extern float RidgeWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "sharp_warp_32")]
	public static extern float SharpWarp(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp);

	[DllImport("RustNative", EntryPoint = "jordan_32")]
	public static extern float Jordan(float x, float y, int octaves, float frequency, float amplitude, float lacunarity, float gain, float warp, float damp, float damp_scale);
}


public static class Noise
{
	public const float MIN = -1000000f;

	public const float MAX = 1000000f;

	public static float SimplexSigned(float x)
	{
		return NativeNoise.Simplex1D(x);
	}

	public static float SimplexSigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y);
	}

	public static float SimplexUnsigned(float x)
	{
		return NativeNoise.Simplex1D(x) * 0.5f + 1f;
	}

	public static float SimplexUnsigned(float x, float y)
	{
		return NativeNoise.Simplex2D(x, y) * 0.5f + 1f;
	}

	public static float Turbulence(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Turbulence(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Billow(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Billow(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Ridge(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Ridge(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float Sharp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.Sharp(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.TurbulenceIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float BillowIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.BillowIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float RidgeIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.RidgeIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float SharpIQ(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f)
	{
		return NativeNoise.SharpIQ(x, y, octaves, frequency, amplitude, lacunarity, gain);
	}

	public static float TurbulenceWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.TurbulenceWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float BillowWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.BillowWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float RidgeWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.RidgeWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float SharpWarp(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 0.25f)
	{
		return NativeNoise.SharpWarp(x, y, octaves, frequency, amplitude, lacunarity, gain, warp);
	}

	public static float Jordan(float x, float y, int octaves = 1, float frequency = 1f, float amplitude = 1f, float lacunarity = 2f, float gain = 0.5f, float warp = 1f, float damp = 1f, float damp_scale = 1f)
	{
		return NativeNoise.Jordan(x, y, octaves, frequency, amplitude, lacunarity, gain, warp, damp, damp_scale);
	}
}


using System;

[Serializable]
public struct NoiseParameters
{
	public int Octaves;

	public float Frequency;

	public float Amplitude;

	public float Offset;

	public NoiseParameters(int octaves, float frequency, float amplitude, float offset)
	{
		Octaves = octaves;
		Frequency = frequency;
		Amplitude = amplitude;
		Offset = offset;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PathList
{
	public enum Side
	{
		Both,
		Left,
		Right,
		Any
	}

	public enum Placement
	{
		Center,
		Side
	}

	public enum Alignment
	{
		None,
		Neighbor,
		Forward,
		Inward
	}

	[Serializable]
	public class BasicObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Placement Placement;

		public bool AlignToNormal = true;

		public bool HeightToTerrain = true;

		public float Offset;
	}

	[Serializable]
	public class SideObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Side Side;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 25f;

		public float Offset = 2f;
	}

	[Serializable]
	public class PathObject
	{
		public string Folder;

		public SpawnFilter Filter;

		public Alignment Alignment;

		public float Density = 1f;

		public float Distance = 5f;

		public float Dithering = 5f;
	}

	[Serializable]
	public class BridgeObject
	{
		public string Folder;

		public float Distance = 10f;
	}

	public class MeshObject
	{
		public Vector3 Position;

		public Mesh[] Meshes;

		public MeshObject(Vector3 meshPivot, MeshData[] meshData)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Expected O, but got Unknown
			//IL_0031: Expected O, but got Unknown
			Position = meshPivot;
			Meshes = (Mesh[])(object)new Mesh[meshData.Length];
			for (int i = 0; i < Meshes.Length; i++)
			{
				MeshData obj = meshData[i];
				Mesh[] meshes = Meshes;
				int num = i;
				Mesh val = new Mesh();
				Mesh val2 = val;
				meshes[num] = val;
				Mesh mesh = val2;
				obj.Apply(mesh);
			}
		}
	}

	private struct WeldVertex : IEquatable<WeldVertex>
	{
		private const float EPSILON = 0.001f;

		private const float INV_EPSILON = 999.99994f;

		public float x;

		public float y;

		public float z;

		public float alwaysUnderwater;

		public float topSurface;

		public override bool Equals(object other)
		{
			if (other is WeldVertex)
			{
				return Equals((WeldVertex)other);
			}
			return false;
		}

		public bool Equals(WeldVertex other)
		{
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
			{
				return topSurface == other.topSurface;
			}
			return false;
		}

		public override int GetHashCode()
		{
			int value = Mathf.RoundToInt(x * 999.99994f);
			int value2 = Mathf.RoundToInt(y * 999.99994f);
			int value3 = Mathf.RoundToInt(z * 999.99994f);
			return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
		}
	}

	private static Quaternion rot90 = Quaternion.Euler(0f, 90f, 0f);

	private static Quaternion rot180 = Quaternion.Euler(0f, 180f, 0f);

	private static Quaternion rot270 = Quaternion.Euler(0f, 270f, 0f);

	public const float EndWidthScale = 3f;

	public const float EndScaleDistance = 100f;

	public const float LengthWidthScale = 8f;

	public const float LengthDepthScale = 3f;

	public const float LengthScaleDistance = 1000f;

	public string Name;

	public PathInterpolator Path;

	public bool Spline;

	public bool Start;

	public bool End;

	public float Width;

	public float InnerPadding;

	public float OuterPadding;

	public float InnerFade;

	public float OuterFade;

	public float RandomScale;

	public float MeshOffset;

	public float TerrainOffset;

	public int Topology;

	public int Splat;

	public int Hierarchy;

	public PathFinder.Node ProcgenStartNode;

	public PathFinder.Node ProcgenEndNode;

	public const float StepSize = 1f;

	private static float[] placements = new float[3] { 0f, -1f, 1f };

	public PathList(string name, Vector3[] points)
	{
		Name = name;
		Path = new PathInterpolator(points);
	}

	private void SpawnObjectsNeighborAligned(ref uint seed, Prefab[] prefabs, List<Vector3> positions, SpawnFilter filter = null)
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Count < 2)
		{
			return;
		}
		List<Prefab> list = Pool.Get<List<Prefab>>();
		for (int i = 0; i < positions.Count; i++)
		{
			int index = Mathf.Max(i - 1, 0);
			int index2 = Mathf.Min(i + 1, positions.Count - 1);
			Vector3 position = positions[i];
			Quaternion rotation = Quaternion.LookRotation(Vector3Ex.XZ3D(positions[index2] - positions[index]));
			SpawnObject(ref seed, prefabs, position, rotation, list, out var spawned, positions.Count, i, filter);
			if (spawned != null)
			{
				list.Add(spawned);
			}
		}
		Pool.FreeUnmanaged<Prefab>(ref list);
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Prefab random = prefabs.GetRandom(ref seed);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = random.Object.transform.localScale;
		random.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!random.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, random, pos, rot, scale);
		return true;
	}

	private bool SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 position, Quaternion rotation, List<Prefab> previousSpawns, out Prefab spawned, int pathLength, int index, SpawnFilter filter = null)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		spawned = null;
		Prefab replacement = prefabs.GetRandom(ref seed);
		replacement.ApplySequenceReplacement(previousSpawns, ref replacement, prefabs, pathLength, index, position);
		Vector3 pos = position;
		Quaternion rot = rotation;
		Vector3 scale = replacement.Object.transform.localScale;
		replacement.ApplyDecorComponents(ref pos, ref rot, ref scale);
		if (!replacement.ApplyTerrainAnchors(ref pos, rot, scale, filter))
		{
			return false;
		}
		World.AddPrefab(Name, replacement, pos, rot, scale);
		spawned = replacement;
		return true;
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 position, Quaternion rotation, SpawnFilter filter = null)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		foreach (Prefab obj in prefabs)
		{
			Vector3 pos = position;
			Vector3 localScale = obj.Object.transform.localScale;
			if (!obj.ApplyTerrainAnchors(ref pos, rotation, localScale, filter))
			{
				return false;
			}
		}
		return true;
	}

	private void SpawnObject(ref uint seed, Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (SpawnObject(ref seed, prefabs, val3, rotation, filter))
				{
					break;
				}
			}
		}
	}

	private bool CheckObjects(Prefab[] prefabs, Vector3 pos, Vector3 dir, BasicObject obj)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!obj.AlignToNormal)
		{
			Vector3 val = Vector3Ex.XZ3D(dir);
			dir = ((Vector3)(ref val)).normalized;
		}
		SpawnFilter filter = obj.Filter;
		Vector3 val2 = (Width * 0.5f + obj.Offset) * (rot90 * dir);
		for (int i = 0; i < placements.Length; i++)
		{
			if ((obj.Placement == Placement.Center && i != 0) || (obj.Placement == Placement.Side && i == 0))
			{
				continue;
			}
			Vector3 val3 = pos + placements[i] * val2;
			if (obj.HeightToTerrain)
			{
				val3.y = TerrainMeta.HeightMap.GetHeight(val3);
			}
			if (filter.Test(val3))
			{
				Quaternion rotation = ((i == 2) ? Quaternion.LookRotation(rot180 * dir) : Quaternion.LookRotation(dir));
				if (CheckObjects(prefabs, val3, rotation, filter))
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SpawnSide(ref uint seed, SideObject obj)
	{
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_025c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_0266: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Side side = obj.Side;
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float num = Width * 0.5f + obj.Offset;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		float[] array2 = new float[2]
		{
			0f - num,
			num
		};
		int num2 = 0;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num3 = distance * 0.25f;
		float num4 = distance * 0.5f;
		float num5 = Path.StartOffset + num4;
		float num6 = Path.Length - Path.EndOffset - num4;
		for (float num7 = num5; num7 <= num6; num7 += num3)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num7) : Path.GetPoint(num7));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num7);
			Vector3 val4 = rot90 * tangent;
			for (int i = 0; i < array2.Length; i++)
			{
				int num8 = (num2 + i) % array2.Length;
				if ((side == Side.Left && num8 != 0) || (side == Side.Right && num8 != 1))
				{
					continue;
				}
				float num9 = array2[num8];
				Vector3 val5 = val2;
				val5.x += val4.x * num9;
				val5.z += val4.z * num9;
				float normX = TerrainMeta.NormalizeX(val5.x);
				float normZ = TerrainMeta.NormalizeZ(val5.z);
				if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
				{
					continue;
				}
				if (density >= SeedRandom.Value(ref seed))
				{
					val5.y = heightMap.GetHeight(normX, normZ);
					if (obj.Alignment == Alignment.None)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(Vector3.zero), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Forward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9), filter))
						{
							continue;
						}
					}
					else if (obj.Alignment == Alignment.Inward)
					{
						if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent * num9) * rot270, filter))
						{
							continue;
						}
					}
					else
					{
						list.Add(val5);
					}
				}
				num2 = num8;
				val = val2;
				if (side == Side.Any)
				{
					break;
				}
			}
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnAlong(ref uint seed, PathObject obj)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		SpawnFilter filter = obj.Filter;
		float density = obj.Density;
		float distance = obj.Distance;
		float dithering = obj.Dithering;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val = Path.GetStartPoint();
		List<Vector3> list = new List<Vector3>();
		float num = distance * 0.25f;
		float num2 = distance * 0.5f;
		float num3 = Path.StartOffset + num2;
		float num4 = Path.Length - Path.EndOffset - num2;
		for (float num5 = num3; num5 <= num4; num5 += num)
		{
			Vector3 val2 = (Spline ? Path.GetPointCubicHermite(num5) : Path.GetPoint(num5));
			Vector3 val3 = val2 - val;
			if (((Vector3)(ref val3)).magnitude < distance)
			{
				continue;
			}
			Vector3 tangent = Path.GetTangent(num5);
			Vector3 val4 = rot90 * tangent;
			Vector3 val5 = val2;
			val5.x += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			val5.z += SeedRandom.Range(ref seed, 0f - dithering, dithering);
			float normX = TerrainMeta.NormalizeX(val5.x);
			float normZ = TerrainMeta.NormalizeZ(val5.z);
			if (filter.GetFactor(normX, normZ) < SeedRandom.Value(ref seed))
			{
				continue;
			}
			if (density >= SeedRandom.Value(ref seed))
			{
				val5.y = heightMap.GetHeight(normX, normZ);
				if (obj.Alignment == Alignment.None)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.identity, filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Forward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(tangent), filter))
					{
						continue;
					}
				}
				else if (obj.Alignment == Alignment.Inward)
				{
					if (!SpawnObject(ref seed, array, val5, Quaternion.LookRotation(val4), filter))
					{
						continue;
					}
				}
				else
				{
					list.Add(val5);
				}
			}
			val = val2;
		}
		if (list.Count > 0)
		{
			SpawnObjectsNeighborAligned(ref seed, array, list, filter);
		}
	}

	public void SpawnBridge(ref uint seed, BridgeObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		if (string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 val = Path.GetEndPoint() - startPoint;
		float magnitude = ((Vector3)(ref val)).magnitude;
		Vector3 val2 = val / magnitude;
		float num = magnitude / obj.Distance;
		int num2 = Mathf.RoundToInt(num);
		float num3 = 0.5f * (num - (float)num2);
		Vector3 val3 = obj.Distance * val2;
		Vector3 val4 = startPoint + (0.5f + num3) * val3;
		Quaternion rotation = Quaternion.LookRotation(val2);
		for (int i = 0; i < num2; i++)
		{
			float num4 = WaterLevel.GetWaterOrTerrainSurface(val4, waves: false, volumes: false) - 1f;
			if (val4.y > num4)
			{
				SpawnObject(ref seed, array, val4, rotation);
			}
			val4 += val3;
		}
	}

	public void SpawnStart(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (Start && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 startPoint = Path.GetStartPoint();
			Vector3 startTangent = Path.GetStartTangent();
			SpawnObject(ref seed, array, startPoint, startTangent, obj);
		}
	}

	public void SpawnEnd(ref uint seed, BasicObject obj)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		if (End && !string.IsNullOrEmpty(obj.Folder))
		{
			Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
			if (array == null || array.Length == 0)
			{
				Debug.LogError((object)("Empty decor folder: " + obj.Folder));
				return;
			}
			Vector3 endPoint = Path.GetEndPoint();
			Vector3 dir = -Path.GetEndTangent();
			SpawnObject(ref seed, array, endPoint, dir, obj);
		}
	}

	public void TrimStart(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!Start || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MinIndex + i];
			Vector3 dir = tangents[Path.MinIndex + i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MinIndex += i;
				break;
			}
		}
	}

	public void TrimEnd(BasicObject obj)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!End || string.IsNullOrEmpty(obj.Folder))
		{
			return;
		}
		Prefab[] array = Prefab.Load("assets/bundled/prefabs/autospawn/" + obj.Folder);
		if (array == null || array.Length == 0)
		{
			Debug.LogError((object)("Empty decor folder: " + obj.Folder));
			return;
		}
		Vector3[] points = Path.Points;
		Vector3[] tangents = Path.Tangents;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 pos = points[Path.MaxIndex - i];
			Vector3 dir = -tangents[Path.MaxIndex - i];
			if (CheckObjects(array, pos, dir, obj))
			{
				Path.MaxIndex -= i;
				break;
			}
		}
	}

	public void TrimTopology(int topology)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] points = Path.Points;
		int num = points.Length / 4;
		for (int i = 0; i < num; i++)
		{
			Vector3 worldPos = points[Path.MinIndex + i];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos, topology))
			{
				Path.MinIndex += i;
				break;
			}
		}
		for (int j = 0; j < num; j++)
		{
			Vector3 worldPos2 = points[Path.MaxIndex - j];
			if (!TerrainMeta.TopologyMap.GetTopology(worldPos2, topology))
			{
				Path.MaxIndex -= j;
				break;
			}
		}
	}

	public void ResetTrims()
	{
		Path.MinIndex = Path.DefaultMinIndex;
		Path.MaxIndex = Path.DefaultMaxIndex;
	}

	public void AdjustTerrainHeight(float intensity = 1f, float fade = 1f, bool scaleWidthWithLength = false)
	{
		AdjustTerrainHeight((float xn, float zn) => intensity, (float xn, float zn) => fade, scaleWidthWithLength);
	}

	public void AdjustTerrainHeight(Func<float, float, float> intensity, Func<float, float, float> fade, bool scaleWidthWithLength = false)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_032c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		//IL_035d: Unknown result type (might be due to invalid IL or missing references)
		//IL_035f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0361: Unknown result type (might be due to invalid IL or missing references)
		//IL_0375: Unknown result type (might be due to invalid IL or missing references)
		//IL_0377: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_037b: Unknown result type (might be due to invalid IL or missing references)
		//IL_037d: Unknown result type (might be due to invalid IL or missing references)
		//IL_037f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0394: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_039b: Unknown result type (might be due to invalid IL or missing references)
		//IL_039d: Unknown result type (might be due to invalid IL or missing references)
		//IL_039f: Unknown result type (might be due to invalid IL or missing references)
		//IL_03aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_03af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0270: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0282: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		TerrainHeightMap heightmap = TerrainMeta.HeightMap;
		_ = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float outerFade = OuterFade;
		float innerFade = InnerFade;
		float terrainOffset = TerrainOffset;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 val3 = startPoint;
		Line prev_line = new Line(startPoint, startPoint + startTangent * num);
		Vector3 val4 = startPoint - val2 * (num2 + outerPadding + outerFade);
		Vector3 val5 = startPoint + val2 * (num2 + outerPadding + outerFade);
		Vector3 val6 = val3;
		Vector3 val7 = startTangent;
		Line cur_line = prev_line;
		Vector3 val8 = val4;
		Vector3 val9 = val5;
		float num3 = Path.Length + num;
		for (float d = 0f; d < num3; d += num)
		{
			Vector3 val10 = (Spline ? Path.GetPointCubicHermite(d + num) : Path.GetPoint(d + num));
			Vector3 tangent = Path.GetTangent(d + num);
			Line next_line = new Line(val10, val10 + tangent * num);
			float opacity = 1f;
			float radius = GetRadius(d, Path.Length, num2, randomScale, scaleWidthWithLength);
			float depth = GetDepth(d, Path.Length, terrainOffset, randomScale, scaleWidthWithLength);
			float offset01 = depth * TerrainMeta.OneOverSize.y;
			if (!Path.Circular)
			{
				float num4 = Vector3Ex.Magnitude2D(startPoint - val6);
				float num5 = Vector3Ex.Magnitude2D(endPoint - val6);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num4, num5));
			}
			val = Vector3Ex.XZ3D(val7);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			val8 = val6 - val2 * (radius + outerPadding + outerFade);
			val9 = val6 + val2 * (radius + outerPadding + outerFade);
			float yn = TerrainMeta.NormalizeY((val6.y + val3.y) * 0.5f);
			heightmap.ForEach(val4, val5, val8, val9, delegate(int x, int z)
			{
				//IL_002c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0031: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0048: Unknown result type (might be due to invalid IL or missing references)
				//IL_0054: Unknown result type (might be due to invalid IL or missing references)
				//IL_0055: Unknown result type (might be due to invalid IL or missing references)
				//IL_005a: Unknown result type (might be due to invalid IL or missing references)
				//IL_0062: Unknown result type (might be due to invalid IL or missing references)
				//IL_0063: Unknown result type (might be due to invalid IL or missing references)
				//IL_0068: Unknown result type (might be due to invalid IL or missing references)
				//IL_006a: Unknown result type (might be due to invalid IL or missing references)
				//IL_006b: Unknown result type (might be due to invalid IL or missing references)
				//IL_006c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0078: Unknown result type (might be due to invalid IL or missing references)
				//IL_0079: Unknown result type (might be due to invalid IL or missing references)
				//IL_007b: Unknown result type (might be due to invalid IL or missing references)
				//IL_0087: Unknown result type (might be due to invalid IL or missing references)
				//IL_0088: Unknown result type (might be due to invalid IL or missing references)
				//IL_008a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009a: Unknown result type (might be due to invalid IL or missing references)
				//IL_009c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
				//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_01af: Unknown result type (might be due to invalid IL or missing references)
				float num6 = heightmap.Coordinate(x);
				float num7 = heightmap.Coordinate(z);
				Vector3 val11 = TerrainMeta.Denormalize(new Vector3(num6, yn, num7));
				Vector3 val12 = ((Line)(ref prev_line)).ClosestPoint2D(val11);
				Vector3 val13 = ((Line)(ref cur_line)).ClosestPoint2D(val11);
				Vector3 val14 = ((Line)(ref next_line)).ClosestPoint2D(val11);
				float num8 = Vector3Ex.Magnitude2D(val11 - val12);
				float num9 = Vector3Ex.Magnitude2D(val11 - val13);
				float num10 = Vector3Ex.Magnitude2D(val11 - val14);
				float num11 = num9;
				Vector3 val15 = val13;
				if (!(num9 <= num8) || !(num9 <= num10))
				{
					if (num8 <= num10)
					{
						num11 = num8;
						val15 = val12;
					}
					else
					{
						num11 = num10;
						val15 = val14;
					}
				}
				float num12 = Mathf.InverseLerp(radius + outerPadding + outerFade * fade(num6, num7), radius + outerPadding, num11);
				float num13 = intensity(num6, num7) * opacity * num12;
				if (num13 > 0f)
				{
					float num14 = (scaleWidthWithLength ? Mathf.Lerp(0.3f, 1f, d / 1000f) : 1f);
					float num15 = Mathf.InverseLerp(radius - innerPadding * num14, radius - innerPadding * num14 - innerFade * num14, num11);
					float num16 = TerrainMeta.NormalizeY(val15.y);
					float num17 = Mathf.SmoothStep(0f, offset01, num15);
					heightmap.SetHeight(x, z, num16 + num17, num13);
				}
			});
			val3 = val6;
			val4 = val8;
			val5 = val9;
			prev_line = cur_line;
			val6 = val10;
			val7 = tangent;
			cur_line = next_line;
		}
	}

	public void AdjustTerrainTexture(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Splat == 0)
		{
			return;
		}
		TerrainSplatMap splatmap = TerrainMeta.SplatMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			splatmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = splatmap.Coordinate(x);
				float num8 = splatmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				float num10 = Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9);
				splatmap.SetSplat(x, z, Splat, num10 * opacity);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainWaterFlow(bool scaleWidthWithLength = false)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		TerrainWaterFlowMap flowMap = TerrainMeta.WaterFlowMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 dir = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(dir);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			dir = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(dir);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			flowMap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_0023: Unknown result type (might be due to invalid IL or missing references)
				float normX = flowMap.Coordinate(x);
				float normZ = flowMap.Coordinate(z);
				flowMap.SetFlowDirection(normX, normZ, dir);
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustTerrainTopology(bool scaleWidthWithLength = false)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		if (Topology == 0)
		{
			return;
		}
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		float num = 1f;
		float randomScale = RandomScale;
		float outerPadding = OuterPadding;
		float innerPadding = InnerPadding;
		float num2 = Width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Vector3 endPoint = Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * (num2 + outerPadding);
		Vector3 v2 = startPoint + val2 * (num2 + outerPadding);
		float num3 = Path.Length + num;
		for (float num4 = 0f; num4 < num3; num4 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num4) : Path.GetPoint(num4));
			float opacity = 1f;
			float radius = GetRadius(num4, Path.Length, num2, randomScale, scaleWidthWithLength);
			if (!Path.Circular)
			{
				float num5 = Vector3Ex.Magnitude2D(startPoint - val3);
				float num6 = Vector3Ex.Magnitude2D(endPoint - val3);
				opacity = Mathf.InverseLerp(0f, num2, Mathf.Min(num5, num6));
			}
			startTangent = Path.GetTangent(num4);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * (radius + outerPadding);
			Vector3 val5 = val3 + val2 * (radius + outerPadding);
			float yn = TerrainMeta.NormalizeY(val3.y);
			topomap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num7 = topomap.Coordinate(x);
				float num8 = topomap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num7, yn, num8));
				Vector3 val7 = ray.ClosestPoint(val6);
				float num9 = Vector3Ex.Magnitude2D(val6 - val7);
				if (Mathf.InverseLerp(radius + outerPadding, radius - innerPadding, num9) * opacity > 0.3f)
				{
					topomap.AddTopology(x, z, Topology);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public void AdjustPlacementMap(float width)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		TerrainPlacementMap placementmap = TerrainMeta.PlacementMap;
		float num = 1f;
		float radius = width * 0.5f;
		Vector3 startPoint = Path.GetStartPoint();
		Path.GetEndPoint();
		Vector3 startTangent = Path.GetStartTangent();
		Vector3 val = Vector3Ex.XZ3D(startTangent);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = rot90 * normalized;
		Vector3 v = startPoint - val2 * radius;
		Vector3 v2 = startPoint + val2 * radius;
		float num2 = Path.Length + num;
		for (float num3 = 0f; num3 < num2; num3 += num)
		{
			Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num3) : Path.GetPoint(num3));
			startTangent = Path.GetTangent(num3);
			val = Vector3Ex.XZ3D(startTangent);
			normalized = ((Vector3)(ref val)).normalized;
			val2 = rot90 * normalized;
			Ray ray = new Ray(val3, startTangent);
			Vector3 val4 = val3 - val2 * radius;
			Vector3 val5 = val3 + val2 * radius;
			float yn = TerrainMeta.NormalizeY(val3.y);
			placementmap.ForEach(v, v2, val4, val5, delegate(int x, int z)
			{
				//IL_002a: Unknown result type (might be due to invalid IL or missing references)
				//IL_002f: Unknown result type (might be due to invalid IL or missing references)
				//IL_0034: Unknown result type (might be due to invalid IL or missing references)
				//IL_0036: Unknown result type (might be due to invalid IL or missing references)
				//IL_003b: Unknown result type (might be due to invalid IL or missing references)
				//IL_003c: Unknown result type (might be due to invalid IL or missing references)
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0042: Unknown result type (might be due to invalid IL or missing references)
				//IL_0043: Unknown result type (might be due to invalid IL or missing references)
				//IL_0044: Unknown result type (might be due to invalid IL or missing references)
				float num4 = placementmap.Coordinate(x);
				float num5 = placementmap.Coordinate(z);
				Vector3 val6 = TerrainMeta.Denormalize(new Vector3(num4, yn, num5));
				Vector3 val7 = ray.ClosestPoint(val6);
				if (Vector3Ex.Magnitude2D(val6 - val7) <= radius)
				{
					placementmap.SetBlocked(x, z);
				}
			});
			v = val4;
			v2 = val5;
		}
	}

	public List<MeshObject> CreateMesh(Mesh[] meshes, float normalSmoothing, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, bool scaleWidthWithLength = false, bool topAligned = false, int roundVertices = 0)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_024d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0256: Unknown result type (might be due to invalid IL or missing references)
		//IL_025b: Unknown result type (might be due to invalid IL or missing references)
		//IL_025d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0262: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_026d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0272: Unknown result type (might be due to invalid IL or missing references)
		//IL_0274: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029a: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02df: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0301: Unknown result type (might be due to invalid IL or missing references)
		//IL_0303: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_030c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0338: Unknown result type (might be due to invalid IL or missing references)
		//IL_0353: Unknown result type (might be due to invalid IL or missing references)
		//IL_0355: Unknown result type (might be due to invalid IL or missing references)
		//IL_0357: Unknown result type (might be due to invalid IL or missing references)
		//IL_035c: Unknown result type (might be due to invalid IL or missing references)
		//IL_035e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0360: Unknown result type (might be due to invalid IL or missing references)
		//IL_0362: Unknown result type (might be due to invalid IL or missing references)
		//IL_0367: Unknown result type (might be due to invalid IL or missing references)
		//IL_036b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0372: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0385: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_0389: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0392: Unknown result type (might be due to invalid IL or missing references)
		//IL_0399: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_041b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0429: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0445: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ff: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		MeshData[] array2 = new MeshData[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
			array2[i] = new MeshData();
		}
		MeshData[] array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].AllocMinimal();
		}
		Bounds bounds = meshes[^1].bounds;
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		List<MeshObject> list = new List<MeshObject>();
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		_ = array[0].vertices.Length;
		_ = array[0].triangles.Length;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		Vector3 val12 = default(Vector3);
		for (int k = 0; k < num2; k += num3)
		{
			float distance = (float)k * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int l = 0; l < num3 && k + l < num2; l++)
			{
				float num5 = (float)(k + l) * num4;
				for (int m = 0; m < meshes.Length; m++)
				{
					MeshCache.Data data = array[m];
					MeshData meshData = array2[m];
					int count = meshData.vertices.Count;
					for (int n = 0; n < data.vertices.Length; n++)
					{
						Vector2 item = data.uv[n];
						Vector3 val2 = data.vertices[n];
						Vector3 val3 = data.normals[n];
						Vector4 val4 = data.tangents[n];
						float num6 = (val2.x - min.x) / size.x;
						float num7 = val2.y - min.y;
						if (topAligned)
						{
							num7 -= size.y;
						}
						float num8 = (val2.z - min.z) / size.z;
						float num9 = num5 + num8 * num4;
						Vector3 val5 = (Spline ? Path.GetPointCubicHermite(num9) : Path.GetPoint(num9));
						Vector3 tangent = Path.GetTangent(num9);
						Vector3 val6 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val6)).normalized;
						Vector3 val7 = rot90 * normalized;
						Vector3 val8 = Vector3.Cross(tangent, val7);
						Quaternion val9 = Quaternion.LookRotation(normalized, val8);
						float radius = GetRadius(num9, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val10 = val5 - val7 * radius;
						Vector3 val11 = val5 + val7 * radius;
						if (snapToTerrain)
						{
							val10.y = heightMap.GetHeight(val10);
							val11.y = heightMap.GetHeight(val11);
						}
						val10 += val8 * meshOffset;
						val11 += val8 * meshOffset;
						val2 = Vector3.Lerp(val10, val11, num6);
						if ((snapStartToTerrain && num9 < 0.1f) || (snapEndToTerrain && num9 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num7;
						}
						val2 -= val;
						val3 = val9 * val3;
						((Vector3)(ref val12))..ctor(val4.x, val4.y, val4.z);
						val12 = val9 * val12;
						((Vector4)(ref val4)).Set(val12.x, val12.y, val12.z, val4.w);
						if (normalSmoothing > 0f)
						{
							val3 = Vector3.Slerp(val3, Vector3.up, normalSmoothing);
						}
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData.vertices.Add(val2);
						meshData.normals.Add(val3);
						meshData.tangents.Add(val4);
						meshData.uv.Add(item);
					}
					for (int num10 = 0; num10 < data.triangles.Length; num10++)
					{
						int num11 = data.triangles[num10];
						meshData.triangles.Add(count + num11);
					}
				}
			}
			list.Add(new MeshObject(val, array2));
			array3 = array2;
			for (int j = 0; j < array3.Length; j++)
			{
				array3[j].Clear();
			}
		}
		array3 = array2;
		for (int j = 0; j < array3.Length; j++)
		{
			array3[j].Free();
		}
		return list;
	}

	public List<MeshObject> CreateMeshRiverInterior(Mesh[] meshes, bool snapToTerrain, bool snapStartToTerrain, bool snapEndToTerrain, Bounds bounds, bool scaleWidthWithLength = false, int roundVertices = 0)
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0493: Unknown result type (might be due to invalid IL or missing references)
		//IL_0498: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0571: Unknown result type (might be due to invalid IL or missing references)
		//IL_0536: Unknown result type (might be due to invalid IL or missing references)
		//IL_0543: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_028a: Unknown result type (might be due to invalid IL or missing references)
		//IL_028f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0290: Unknown result type (might be due to invalid IL or missing references)
		//IL_0295: Unknown result type (might be due to invalid IL or missing references)
		//IL_0299: Unknown result type (might be due to invalid IL or missing references)
		//IL_029e: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02db: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0315: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_0325: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_0329: Unknown result type (might be due to invalid IL or missing references)
		//IL_032d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		//IL_0337: Unknown result type (might be due to invalid IL or missing references)
		//IL_0339: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		//IL_033f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_038a: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		//IL_038e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		MeshCache.Data[] array = new MeshCache.Data[meshes.Length];
		for (int i = 0; i < meshes.Length; i++)
		{
			array[i] = MeshCache.Get(meshes[i]);
		}
		MeshData meshData = new MeshData();
		meshData.vertices = Pool.Get<List<Vector3>>();
		meshData.triangles = Pool.Get<List<int>>();
		meshData.uv = Pool.Get<List<Vector2>>();
		MeshData meshData2 = new MeshData();
		meshData2.vertices = Pool.Get<List<Vector3>>();
		meshData2.triangles = Pool.Get<List<int>>();
		meshData2.uv = Pool.Get<List<Vector2>>();
		Dictionary<WeldVertex, int> dictionary = new Dictionary<WeldVertex, int>();
		Vector3 min = ((Bounds)(ref bounds)).min;
		Vector3 size = ((Bounds)(ref bounds)).size;
		float num = Width / ((Bounds)(ref bounds)).size.x;
		int num2 = (int)(Path.Length / (num * ((Bounds)(ref bounds)).size.z));
		int num3 = 5;
		float num4 = Path.Length / (float)num2;
		float randomScale = RandomScale;
		float meshOffset = MeshOffset;
		float baseRadius = Width * 0.5f;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		List<MeshObject> list = new List<MeshObject>();
		for (int j = 0; j < num2; j += num3)
		{
			float distance = (float)j * num4 + 0.5f * (float)num3 * num4;
			Vector3 val = (Spline ? Path.GetPointCubicHermite(distance) : Path.GetPoint(distance));
			for (int k = 0; k < num3 && j + k < num2; k++)
			{
				float num5 = (float)(j + k) * num4;
				bool flag = j == 0;
				bool flag2 = k == 0;
				bool flag3 = j == num2 - 1;
				bool flag4 = k == num3 - 1 || j + k == num2 - 1;
				int num6 = (flag2 ? 4 : 3);
				for (int l = 0; l < num6; l++)
				{
					int num7 = l;
					MeshCache.Data data = array[num7];
					MeshData meshData3 = meshData;
					int count = meshData3.vertices.Count;
					float num8 = ((num7 == 2 && !(flag4 && flag3)) ? 1f : ((!(num7 == 3 && flag2) || flag) ? 0f : 1f));
					float num9 = ((num7 == 0) ? 1f : 0f);
					for (int m = 0; m < data.vertices.Length; m++)
					{
						Vector3 val2 = data.vertices[m];
						float num10 = (val2.x - min.x) / size.x;
						float num11 = val2.y - min.y;
						float num12 = (val2.z - min.z) / size.z;
						float num13 = num5 + num12 * num4;
						Vector3 val3 = (Spline ? Path.GetPointCubicHermite(num13) : Path.GetPoint(num13));
						Vector3 tangent = Path.GetTangent(num13);
						Vector3 val4 = Vector3Ex.XZ3D(tangent);
						Vector3 normalized = ((Vector3)(ref val4)).normalized;
						Vector3 val5 = rot90 * normalized;
						Vector3 val6 = Vector3.Cross(tangent, val5);
						float radius = GetRadius(num13, Path.Length, baseRadius, randomScale, scaleWidthWithLength);
						Vector3 val7 = val3 - val5 * radius;
						Vector3 val8 = val3 + val5 * radius;
						if (snapToTerrain)
						{
							val7.y = heightMap.GetHeight(val7);
							val8.y = heightMap.GetHeight(val8);
						}
						val7 += val6 * meshOffset;
						val8 += val6 * meshOffset;
						val2 = Vector3.Lerp(val7, val8, num10);
						if ((snapStartToTerrain && num13 < 0.1f) || (snapEndToTerrain && num13 > Path.Length - 0.1f))
						{
							val2.y = heightMap.GetHeight(val2);
						}
						else
						{
							val2.y += num11;
						}
						val2 -= val;
						if (roundVertices > 0)
						{
							val2.x = (float)Math.Round(val2.x, roundVertices);
							val2.y = (float)Math.Round(val2.y, roundVertices);
							val2.z = (float)Math.Round(val2.z, roundVertices);
						}
						meshData3.vertices.Add(val2);
						meshData3.uv.Add(new Vector2(num8, num9));
					}
					for (int n = 0; n < data.triangles.Length; n++)
					{
						int num14 = data.triangles[n];
						meshData3.triangles.Add(count + num14);
					}
				}
			}
			for (int num15 = 0; num15 < meshData.triangles.Count; num15++)
			{
				int index = meshData.triangles[num15];
				Vector3 val9 = meshData.vertices[index];
				Vector2 item = meshData.uv[index];
				WeldVertex key = default(WeldVertex);
				key.x = val9.x;
				key.y = val9.y;
				key.z = val9.z;
				key.alwaysUnderwater = meshData.uv[index].x;
				key.topSurface = meshData.uv[index].y;
				if (!dictionary.TryGetValue(key, out var value))
				{
					value = meshData2.vertices.Count;
					dictionary.Add(key, value);
					meshData2.vertices.Add(val9);
					meshData2.uv.Add(item);
				}
				meshData2.triangles.Add(value);
			}
			list.Add(new MeshObject(val, new MeshData[1] { meshData2 }));
			meshData.Clear();
			meshData2.Clear();
			dictionary.Clear();
		}
		meshData.Free();
		meshData2.Free();
		return list;
	}

	public static float GetRadius(float distance, float length, float baseRadius, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = Mathf.Sqrt(Mathf.Max(0f, length - distance) / 100f);
			float num2 = ((length > 0f) ? Mathf.Lerp(3f, 1f, num) : 1f);
			float num3 = distance / 1000f;
			float num4 = Mathf.Lerp(1f, 8f, num3);
			baseRadius = baseRadius * num4 * num2;
		}
		return Mathf.Lerp(baseRadius, baseRadius * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}

	public static float GetDepth(float distance, float length, float baseDepth, float randomScale, bool scaleWidthWithLength)
	{
		if (scaleWidthWithLength)
		{
			float num = distance / 1000f;
			float num2 = Mathf.Lerp(1f, 3f, num);
			baseDepth *= num2;
		}
		return Mathf.Lerp(baseDepth, baseDepth * randomScale, Noise.SimplexUnsigned(distance * 0.005f));
	}
}


public enum Side
{
	Both,
	Left,
	Right,
	Any
}


public enum Placement
{
	Center,
	Side
}


public enum Alignment
{
	None,
	Neighbor,
	Forward,
	Inward
}


using System;

[Serializable]
public class BasicObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Placement Placement;

	public bool AlignToNormal = true;

	public bool HeightToTerrain = true;

	public float Offset;
}


using System;

[Serializable]
public class SideObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Side Side;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 25f;

	public float Offset = 2f;
}


using System;

[Serializable]
public class PathObject
{
	public string Folder;

	public SpawnFilter Filter;

	public Alignment Alignment;

	public float Density = 1f;

	public float Distance = 5f;

	public float Dithering = 5f;
}


using System;

[Serializable]
public class BridgeObject
{
	public string Folder;

	public float Distance = 10f;
}


using UnityEngine;

public class MeshObject
{
	public Vector3 Position;

	public Mesh[] Meshes;

	public MeshObject(Vector3 meshPivot, MeshData[] meshData)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Expected O, but got Unknown
		//IL_0031: Expected O, but got Unknown
		Position = meshPivot;
		Meshes = (Mesh[])(object)new Mesh[meshData.Length];
		for (int i = 0; i < Meshes.Length; i++)
		{
			MeshData obj = meshData[i];
			Mesh[] meshes = Meshes;
			int num = i;
			Mesh val = new Mesh();
			Mesh val2 = val;
			meshes[num] = val;
			Mesh mesh = val2;
			obj.Apply(mesh);
		}
	}
}


using System;
using UnityEngine;

private struct WeldVertex : IEquatable<WeldVertex>
{
	private const float EPSILON = 0.001f;

	private const float INV_EPSILON = 999.99994f;

	public float x;

	public float y;

	public float z;

	public float alwaysUnderwater;

	public float topSurface;

	public override bool Equals(object other)
	{
		if (other is WeldVertex)
		{
			return Equals((WeldVertex)other);
		}
		return false;
	}

	public bool Equals(WeldVertex other)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (Vector3.Distance(new Vector3(x, y, z), new Vector3(other.x, other.y, other.z)) < 0.001f && alwaysUnderwater == other.alwaysUnderwater)
		{
			return topSurface == other.topSurface;
		}
		return false;
	}

	public override int GetHashCode()
	{
		int value = Mathf.RoundToInt(x * 999.99994f);
		int value2 = Mathf.RoundToInt(y * 999.99994f);
		int value3 = Mathf.RoundToInt(z * 999.99994f);
		return HashCode.Combine(value, value2, value3, alwaysUnderwater, topSurface);
	}
}


using System;
using UnityEngine;

[Serializable]
public class SpawnFilter
{
	[InspectorFlags]
	public Enum SplatType = (Enum)(-1);

	[InspectorFlags]
	public Enum BiomeType = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAny = (Enum)(-1);

	[InspectorFlags]
	public Enum TopologyAll;

	[InspectorFlags]
	public Enum TopologyNot;

	public bool Test(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetFactor(worldPos) > 0.5f;
	}

	public bool Test(float normX, float normZ)
	{
		return GetFactor(normX, normZ) > 0.5f;
	}

	public float GetFactor(Vector3 worldPos, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFactor(normX, normZ, checkPlacementMap, checkTopologyRadius);
	}

	public float GetFactor(float normX, float normZ, bool checkPlacementMap = true, float checkTopologyRadius = 0f)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected I4, but got Unknown
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Expected I4, but got Unknown
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Expected I4, but got Unknown
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Expected I4, but got Unknown
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Expected I4, but got Unknown
		if ((Object)(object)TerrainMeta.TopologyMap == (Object)null)
		{
			return 0f;
		}
		if (checkPlacementMap && (Object)(object)TerrainMeta.PlacementMap != (Object)null && TerrainMeta.PlacementMap.GetBlocked(normX, normZ))
		{
			return 0f;
		}
		int num = (int)SplatType;
		int num2 = (int)BiomeType;
		int num3 = (int)TopologyAny;
		int num4 = (int)TopologyAll;
		int num5 = (int)TopologyNot;
		if (num3 == 0)
		{
			Debug.LogError((object)"Empty topology filter is invalid.");
		}
		else if (num3 != -1 || num4 != 0 || num5 != 0)
		{
			int num6 = ((checkTopologyRadius > 0f) ? TerrainMeta.TopologyMap.GetTopology(normX, normZ, checkTopologyRadius) : TerrainMeta.TopologyMap.GetTopology(normX, normZ));
			if (num3 != -1 && (num6 & num3) == 0)
			{
				return 0f;
			}
			if (num5 != 0 && (num6 & num5) != 0)
			{
				return 0f;
			}
			if (num4 != 0 && (num6 & num4) != num4)
			{
				return 0f;
			}
		}
		switch (num2)
		{
		case 0:
			Debug.LogError((object)"Empty biome filter is invalid.");
			break;
		default:
			if ((TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ) & num2) == 0)
			{
				return 0f;
			}
			break;
		case -1:
			break;
		}
		switch (num)
		{
		case 0:
			Debug.LogError((object)"Empty splat filter is invalid.");
			break;
		default:
			return TerrainMeta.SplatMap.GetSplat(normX, normZ, num);
		case -1:
			break;
		}
		return 1f;
	}
}


public enum SpawnFilterMode
{
	PivotPoint = 1,
	TerrainAnchorPoints = 2,
	TerrainCheckPoints = 4
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

[CreateAssetMenu(menuName = "Rust/Terrain Config")]
public class TerrainConfig : ScriptableObject
{
	[Serializable]
	public class SplatOverlay
	{
		public Color Color = new Color(1f, 1f, 1f, 0f);

		[Range(0f, 1f)]
		public float Smoothness;

		[Range(0f, 1f)]
		public float NormalIntensity = 1f;

		[Range(0f, 8f)]
		public float BlendFactor = 0.5f;

		[Range(0.01f, 32f)]
		public float BlendFalloff = 0.5f;
	}

	[Serializable]
	public class SplatType
	{
		public string Name = "";

		[FormerlySerializedAs("WarmColor")]
		public Color AridColor = Color.white;

		public SplatOverlay AridOverlay = new SplatOverlay();

		[FormerlySerializedAs("Color")]
		public Color TemperateColor = Color.white;

		public SplatOverlay TemperateOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color TundraColor = Color.white;

		public SplatOverlay TundraOverlay = new SplatOverlay();

		[FormerlySerializedAs("ColdColor")]
		public Color ArcticColor = Color.white;

		public SplatOverlay ArcticOverlay = new SplatOverlay();

		public Color JungleColor = Color.white;

		public SplatOverlay JungleOverlay = new SplatOverlay();

		public PhysicMaterial Material;

		public float SplatTiling = 5f;

		[Range(0f, 1f)]
		public float UVMIXMult = 0.15f;

		public float UVMIXStart;

		public float UVMIXDist = 100f;
	}

	public enum GroundType
	{
		None,
		HardSurface,
		Grass,
		Sand,
		Snow,
		Dirt,
		Gravel
	}

	public bool CastShadows = true;

	public LayerMask GroundMask = LayerMask.op_Implicit(0);

	public LayerMask WaterMask = LayerMask.op_Implicit(0);

	public PhysicMaterial GenericMaterial;

	public PhysicMaterial WaterMaterial;

	public Material Material;

	public Material MarginMaterial;

	public Texture[] AlbedoArrays = (Texture[])(object)new Texture[3];

	public Texture[] NormalArrays = (Texture[])(object)new Texture[3];

	public float HeightMapErrorMin = 5f;

	public float HeightMapErrorMax = 100f;

	public float BaseMapDistanceMin = 100f;

	public float BaseMapDistanceMax = 500f;

	public float ShaderLodMin = 100f;

	public float ShaderLodMax = 600f;

	public SplatType[] Splats = new SplatType[8];

	private string snowMatName;

	private string grassMatName;

	private string sandMatName;

	private List<string> dirtMatNames;

	private List<string> stoneyMatNames;

	private int snowMatID;

	private int grassMatID;

	private int sandMatID;

	private List<int> dirtMatIds;

	private List<int> stoneyMatIds;

	public Texture AlbedoArray => AlbedoArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public Texture NormalArray => NormalArrays[Mathf.Clamp(QualitySettings.globalTextureMipmapLimit, 0, 2)];

	public PhysicMaterial[] GetPhysicMaterials()
	{
		PhysicMaterial[] array = (PhysicMaterial[])(object)new PhysicMaterial[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].Material;
		}
		return array;
	}

	public Color[] GetAridColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].AridColor;
		}
		return array;
	}

	public void GetAridOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay aridOverlay = Splats[i].AridOverlay;
			color[i] = ((Color)(ref aridOverlay.Color)).linear;
			param[i] = new Vector4(aridOverlay.Smoothness, aridOverlay.NormalIntensity, aridOverlay.BlendFactor, aridOverlay.BlendFalloff);
		}
	}

	public Color[] GetTemperateColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TemperateColor;
		}
		return array;
	}

	public void GetTemperateOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay temperateOverlay = Splats[i].TemperateOverlay;
			color[i] = ((Color)(ref temperateOverlay.Color)).linear;
			param[i] = new Vector4(temperateOverlay.Smoothness, temperateOverlay.NormalIntensity, temperateOverlay.BlendFactor, temperateOverlay.BlendFalloff);
		}
	}

	public Color[] GetTundraColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].TundraColor;
		}
		return array;
	}

	public void GetTundraOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay tundraOverlay = Splats[i].TundraOverlay;
			color[i] = ((Color)(ref tundraOverlay.Color)).linear;
			param[i] = new Vector4(tundraOverlay.Smoothness, tundraOverlay.NormalIntensity, tundraOverlay.BlendFactor, tundraOverlay.BlendFalloff);
		}
	}

	public Color[] GetArcticColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].ArcticColor;
		}
		return array;
	}

	public void GetArcticOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay arcticOverlay = Splats[i].ArcticOverlay;
			color[i] = ((Color)(ref arcticOverlay.Color)).linear;
			param[i] = new Vector4(arcticOverlay.Smoothness, arcticOverlay.NormalIntensity, arcticOverlay.BlendFactor, arcticOverlay.BlendFalloff);
		}
	}

	public Color[] GetJungleColors()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		Color[] array = (Color[])(object)new Color[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].JungleColor;
		}
		return array;
	}

	public void GetJungleOverlayConstants(out Color[] color, out Vector4[] param)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		color = (Color[])(object)new Color[Splats.Length];
		param = (Vector4[])(object)new Vector4[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			SplatOverlay jungleOverlay = Splats[i].JungleOverlay;
			color[i] = ((Color)(ref jungleOverlay.Color)).linear;
			param[i] = new Vector4(jungleOverlay.Smoothness, jungleOverlay.NormalIntensity, jungleOverlay.BlendFactor, jungleOverlay.BlendFalloff);
		}
	}

	public float[] GetSplatTiling()
	{
		float[] array = new float[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = Splats[i].SplatTiling;
		}
		return array;
	}

	public float GetMaxSplatTiling()
	{
		float num = float.MinValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling > num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public float GetMinSplatTiling()
	{
		float num = float.MaxValue;
		for (int i = 0; i < Splats.Length; i++)
		{
			if (Splats[i].SplatTiling < num)
			{
				num = Splats[i].SplatTiling;
			}
		}
		return num;
	}

	public Vector3[] GetPackedUVMIX()
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[Splats.Length];
		for (int i = 0; i < Splats.Length; i++)
		{
			array[i] = new Vector3(Splats[i].UVMIXMult, Splats[i].UVMIXStart, Splats[i].UVMIXDist);
		}
		return array;
	}

	[Obsolete("Use GetCurrentGroundTypeNoAlloc instead")]
	public GroundType GetCurrentGroundType(bool isGrounded, RaycastHit hit)
	{
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundType", 0);
		try
		{
			if (string.IsNullOrEmpty(grassMatName))
			{
				dirtMatNames = new List<string>();
				stoneyMatNames = new List<string>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					string text = obj.Name.ToLower();
					string name = ((Object)obj.Material).name;
					switch (text)
					{
					case "grass":
						grassMatName = name;
						break;
					case "snow":
						snowMatName = name;
						break;
					case "sand":
						sandMatName = name;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatNames.Add(name);
						break;
					case "stones":
					case "gravel":
						stoneyMatNames.Add(name);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			string name2 = ((Object)materialAt).name;
			if (name2 == grassMatName)
			{
				return GroundType.Grass;
			}
			if (name2 == sandMatName)
			{
				return GroundType.Sand;
			}
			if (name2 == snowMatName)
			{
				return GroundType.Snow;
			}
			for (int j = 0; j < dirtMatNames.Count; j++)
			{
				if (dirtMatNames[j] == name2)
				{
					return GroundType.Dirt;
				}
			}
			for (int k = 0; k < stoneyMatNames.Count; k++)
			{
				if (stoneyMatNames[k] == name2)
				{
					return GroundType.Gravel;
				}
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public GroundType GetCurrentGroundTypeNoAlloc(bool isGrounded, RaycastHit hit)
	{
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainConfig.GetCurrentGroundTypeNoAlloc", 0);
		try
		{
			if (grassMatID == 0)
			{
				dirtMatIds = new List<int>();
				stoneyMatIds = new List<int>();
				SplatType[] splats = Splats;
				foreach (SplatType obj in splats)
				{
					int instanceID = ((Object)obj.Material).GetInstanceID();
					switch (obj.Name.ToLower())
					{
					case "grass":
						grassMatID = instanceID;
						break;
					case "snow":
						snowMatID = instanceID;
						break;
					case "sand":
						sandMatID = instanceID;
						break;
					case "dirt":
					case "forest":
					case "tundra":
						dirtMatIds.Add(instanceID);
						break;
					case "stones":
					case "gravel":
						stoneyMatIds.Add(instanceID);
						break;
					}
				}
			}
			if (!isGrounded)
			{
				return GroundType.None;
			}
			if ((Object)(object)((RaycastHit)(ref hit)).collider == (Object)null)
			{
				return GroundType.HardSurface;
			}
			PhysicMaterial materialAt = ((RaycastHit)(ref hit)).collider.GetMaterialAt(((RaycastHit)(ref hit)).point);
			if ((Object)(object)materialAt == (Object)null)
			{
				return GroundType.HardSurface;
			}
			int instanceID2 = ((Object)materialAt).GetInstanceID();
			if (instanceID2 == grassMatID)
			{
				return GroundType.Grass;
			}
			if (instanceID2 == sandMatID)
			{
				return GroundType.Sand;
			}
			if (instanceID2 == snowMatID)
			{
				return GroundType.Snow;
			}
			if (dirtMatIds.Contains(instanceID2))
			{
				return GroundType.Dirt;
			}
			if (stoneyMatIds.Contains(instanceID2))
			{
				return GroundType.Gravel;
			}
			return GroundType.HardSurface;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class SplatOverlay
{
	public Color Color = new Color(1f, 1f, 1f, 0f);

	[Range(0f, 1f)]
	public float Smoothness;

	[Range(0f, 1f)]
	public float NormalIntensity = 1f;

	[Range(0f, 8f)]
	public float BlendFactor = 0.5f;

	[Range(0.01f, 32f)]
	public float BlendFalloff = 0.5f;
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

[Serializable]
public class SplatType
{
	public string Name = "";

	[FormerlySerializedAs("WarmColor")]
	public Color AridColor = Color.white;

	public SplatOverlay AridOverlay = new SplatOverlay();

	[FormerlySerializedAs("Color")]
	public Color TemperateColor = Color.white;

	public SplatOverlay TemperateOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color TundraColor = Color.white;

	public SplatOverlay TundraOverlay = new SplatOverlay();

	[FormerlySerializedAs("ColdColor")]
	public Color ArcticColor = Color.white;

	public SplatOverlay ArcticOverlay = new SplatOverlay();

	public Color JungleColor = Color.white;

	public SplatOverlay JungleOverlay = new SplatOverlay();

	public PhysicMaterial Material;

	public float SplatTiling = 5f;

	[Range(0f, 1f)]
	public float UVMIXMult = 0.15f;

	public float UVMIXStart;

	public float UVMIXDist = 100f;
}


public enum GroundType
{
	None,
	HardSurface,
	Grass,
	Sand,
	Snow,
	Dirt,
	Gravel
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.AI;

public class AsyncTerrainNavMeshBake : CustomYieldInstruction
{
	private List<int> indices;

	private List<Vector3> vertices;

	private List<Vector3> normals;

	private List<int> triangles;

	private Vector3 pivot;

	private int width;

	private int height;

	private bool normal;

	private bool alpha;

	private Action worker;

	public override bool keepWaiting => worker != null;

	public bool isDone => worker == null;

	public Mesh mesh
	{
		get
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0006: Expected O, but got Unknown
			Mesh val = new Mesh();
			if (vertices != null)
			{
				val.SetVertices(vertices);
				Pool.FreeUnmanaged<Vector3>(ref vertices);
			}
			if (normals != null)
			{
				val.SetNormals(normals);
				Pool.FreeUnmanaged<Vector3>(ref normals);
			}
			if (triangles != null)
			{
				val.SetTriangles(triangles, 0);
				Pool.FreeUnmanaged<int>(ref triangles);
			}
			if (indices != null)
			{
				Pool.FreeUnmanaged<int>(ref indices);
			}
			return val;
		}
	}

	public NavMeshBuildSource CreateNavMeshBuildSource()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = default(NavMeshBuildSource);
		((NavMeshBuildSource)(ref result)).transform = Matrix4x4.TRS(pivot, Quaternion.identity, Vector3.one);
		((NavMeshBuildSource)(ref result)).shape = (NavMeshBuildSourceShape)0;
		((NavMeshBuildSource)(ref result)).sourceObject = (Object)(object)mesh;
		return result;
	}

	public NavMeshBuildSource CreateNavMeshBuildSource(int area)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		NavMeshBuildSource result = CreateNavMeshBuildSource();
		((NavMeshBuildSource)(ref result)).area = area;
		return result;
	}

	public AsyncTerrainNavMeshBake(Vector3 pivot, int width, int height, bool normal, bool alpha)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		this.pivot = pivot;
		this.width = width;
		this.height = height;
		this.normal = normal;
		this.alpha = alpha;
		indices = Pool.Get<List<int>>();
		vertices = Pool.Get<List<Vector3>>();
		normals = (normal ? Pool.Get<List<Vector3>>() : null);
		triangles = Pool.Get<List<int>>();
		Invoke();
	}

	private void DoWork()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor((float)(width / 2), 0f, (float)(height / 2));
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(pivot.x - val.x, 0f, pivot.z - val.z);
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainAlphaMap alphaMap = TerrainMeta.AlphaMap;
		int num = 0;
		for (int i = 0; i <= height; i++)
		{
			int num2 = 0;
			while (num2 <= width)
			{
				Vector3 worldPos = new Vector3((float)num2, 0f, (float)i) + val2;
				Vector3 item = new Vector3((float)num2, 0f, (float)i) - val;
				float num3 = heightMap.GetHeight(worldPos);
				if (num3 < -1f)
				{
					indices.Add(-1);
				}
				else if (alpha && alphaMap.GetAlpha(worldPos) < 0.1f)
				{
					indices.Add(-1);
				}
				else
				{
					if (normal)
					{
						Vector3 item2 = heightMap.GetNormal(worldPos);
						normals.Add(item2);
					}
					worldPos.y = (item.y = num3 - pivot.y);
					indices.Add(vertices.Count);
					vertices.Add(item);
				}
				num2++;
				num++;
			}
		}
		int num4 = 0;
		int num5 = 0;
		while (num5 < height)
		{
			int num6 = 0;
			while (num6 < width)
			{
				int num7 = indices[num4];
				int num8 = indices[num4 + width + 1];
				int num9 = indices[num4 + 1];
				int num10 = indices[num4 + 1];
				int num11 = indices[num4 + width + 1];
				int num12 = indices[num4 + width + 2];
				if (num7 != -1 && num8 != -1 && num9 != -1)
				{
					triangles.Add(num7);
					triangles.Add(num8);
					triangles.Add(num9);
				}
				if (num10 != -1 && num11 != -1 && num12 != -1)
				{
					triangles.Add(num10);
					triangles.Add(num11);
					triangles.Add(num12);
				}
				num6++;
				num4++;
			}
			num5++;
			num4++;
		}
	}

	private void Invoke()
	{
		worker = DoWork;
		worker.BeginInvoke(Callback, null);
	}

	private void Callback(IAsyncResult result)
	{
		worker.EndInvoke(result);
		worker = null;
	}
}


using UnityEngine;

public struct TextureData
{
	public int width;

	public int height;

	public Color32[] colors;

	public TextureData(Texture2D tex)
	{
		if ((Object)(object)tex != (Object)null)
		{
			width = ((Texture)tex).width;
			height = ((Texture)tex).height;
			colors = tex.GetPixels32();
		}
		else
		{
			width = 0;
			height = 0;
			colors = null;
		}
	}

	public Color32 GetColor(int x, int y)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return colors[y * width + x];
	}

	public int GetShort(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeShort(GetColor(x, y));
	}

	public int GetInt(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeInt(GetColor(x, y));
	}

	public float GetFloat(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeFloat(GetColor(x, y));
	}

	public float GetHalf(int x, int y)
	{
		return BitUtility.Short2Float(GetShort(x, y));
	}

	public Vector4 GetVector(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeVector(GetColor(x, y));
	}

	public Vector3 GetNormal(int x, int y)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return BitUtility.DecodeNormal(Color32.op_Implicit(GetColor(x, y)));
	}

	public Color32 GetInterpolatedColor(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Color val = Color32.op_Implicit(GetColor(num3, num4));
		Color val2 = Color32.op_Implicit(GetColor(x2, num4));
		Color val3 = Color32.op_Implicit(GetColor(num3, y2));
		Color val4 = Color32.op_Implicit(GetColor(x2, y2));
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Color val5 = Color.Lerp(val, val2, num5);
		Color val6 = Color.Lerp(val3, val4, num5);
		return Color32.op_Implicit(Color.Lerp(val5, val6, num6));
	}

	public int GetInterpolatedInt(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetInt(x2, y2);
	}

	public int GetInterpolatedShort(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int x2 = Mathf.Clamp(Mathf.RoundToInt(num), 1, width - 2);
		int y2 = Mathf.Clamp(Mathf.RoundToInt(num2), 1, height - 2);
		return GetShort(x2, y2);
	}

	public float GetInterpolatedFloat(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float @float = GetFloat(num3, num4);
		float float2 = GetFloat(x2, num4);
		float float3 = GetFloat(num3, y2);
		float float4 = GetFloat(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(@float, float2, num5);
		float num8 = Mathf.Lerp(float3, float4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public float GetInterpolatedHalf(float x, float y)
	{
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		float half = GetHalf(num3, num4);
		float half2 = GetHalf(x2, num4);
		float half3 = GetHalf(num3, y2);
		float half4 = GetHalf(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		float num7 = Mathf.Lerp(half, half2, num5);
		float num8 = Mathf.Lerp(half3, half4, num5);
		return Mathf.Lerp(num7, num8, num6);
	}

	public Vector4 GetInterpolatedVector(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector4 vector = GetVector(num3, num4);
		Vector4 vector2 = GetVector(x2, num4);
		Vector4 vector3 = GetVector(num3, y2);
		Vector4 vector4 = GetVector(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector4 val = Vector4.Lerp(vector, vector2, num5);
		Vector4 val2 = Vector4.Lerp(vector3, vector4, num5);
		return Vector4.Lerp(val, val2, num6);
	}

	public Vector3 GetInterpolatedNormal(float x, float y)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		float num = x * (float)(width - 1);
		float num2 = y * (float)(height - 1);
		int num3 = Mathf.Clamp((int)num, 1, width - 2);
		int num4 = Mathf.Clamp((int)num2, 1, height - 2);
		int x2 = Mathf.Min(num3 + 1, width - 2);
		int y2 = Mathf.Min(num4 + 1, height - 2);
		Vector3 normal = GetNormal(num3, num4);
		Vector3 normal2 = GetNormal(x2, num4);
		Vector3 normal3 = GetNormal(num3, y2);
		Vector3 normal4 = GetNormal(x2, y2);
		float num5 = num - (float)num3;
		float num6 = num2 - (float)num4;
		Vector3 val = Vector3.Lerp(normal, normal2, num5);
		Vector3 val2 = Vector3.Lerp(normal3, normal4, num5);
		return Vector3.Lerp(val, val2, num6);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text.RegularExpressions;
using System.Threading;
using ConVar;
using Development.Attributes;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

[ResetStaticFields]
public static class World
{
	public struct SpawnTiming
	{
		public string category;

		public Prefab prefab;

		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public TimeSpan time;
	}

	private static uint _size;

	public static readonly Dictionary<string, HashSet<GameObject>> SpawnedPrefabs = new Dictionary<string, HashSet<GameObject>>(StringComparer.OrdinalIgnoreCase);

	private static Stopwatch spawnTimer = new Stopwatch();

	private static List<SpawnTiming> spawnTimings = new List<SpawnTiming>();

	public static uint Seed { get; set; }

	public static uint Salt { get; set; }

	public static uint Size
	{
		get
		{
			return _size;
		}
		set
		{
			_size = value;
		}
	}

	public static string Checksum { get; set; }

	public static long Timestamp { get; set; }

	public static string Url { get; set; }

	public static bool Procedural { get; set; }

	public static bool Cached { get; set; }

	public static bool Networked { get; set; }

	public static bool Receiving { get; set; }

	public static bool Transfer { get; set; }

	public static bool Nexus => NexusServer.Started;

	public static bool LoadedFromSave { get; set; }

	public static int SpawnIndex { get; set; }

	public static WorldSerialization Serialization { get; set; }

	public static WorldConfig Config { get; set; }

	public static string Name
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalName;
			}
			if (CanLoadFromUrl())
			{
				return Path.GetFileNameWithoutExtension(WWW.UnEscapeURL(Url));
			}
			return Application.loadedLevelName;
		}
	}

	public static string MapFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalMapFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + ".map";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 271 + ".map";
		}
	}

	public static string MapFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	public static string SaveFileName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			if (MapUploader.IsUploaded)
			{
				return MapUploader.OriginalSaveFileName;
			}
			if (CanLoadFromUrl())
			{
				return Name + "." + 271 + ".sav";
			}
			return Name.Replace(" ", "").ToLower() + "." + Size + "." + Seed + "." + 271 + ".sav";
		}
	}

	public static string SaveFolderName
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		get
		{
			return Server.rootFolder;
		}
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static string GetServerBrowserMapName()
	{
		if (MapUploader.IsUploaded)
		{
			return Name;
		}
		if (!CanLoadFromUrl())
		{
			return Name;
		}
		if (Name.StartsWith("proceduralmap."))
		{
			return "Procedural Map";
		}
		return "Custom Map";
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromUrl()
	{
		return !string.IsNullOrEmpty(Url);
	}

	[MethodImpl(MethodImplOptions.NoInlining)]
	public static bool CanLoadFromDisk()
	{
		return File.Exists(MapFolderName + "/" + MapFileName);
	}

	public static void CleanupOldFiles()
	{
		if (!Directory.Exists(MapFolderName))
		{
			return;
		}
		Regex regex1 = new Regex("proceduralmap\\.[0-9]+\\.[0-9]+\\.[0-9]+(_occlusion)*\\.(map|dat)");
		Regex regex2 = new Regex("\\.[0-9]+\\.[0-9]+\\." + 271 + "+(_occlusion)*\\.(map|dat)");
		foreach (string item in new string[2] { "*.map", "*.dat" }.SelectMany((string ext) => from path in Directory.GetFiles(MapFolderName, ext)
			where regex1.IsMatch(path) && !regex2.IsMatch(path)
			select path))
		{
			try
			{
				File.Delete(item);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)ex.Message);
			}
		}
	}

	public static void InitSeed(int seed)
	{
		InitSeed((uint)seed);
	}

	public static void InitSeed(uint seed)
	{
		if (seed == 0)
		{
			seed = MurmurHashEx.MurmurHashUnsigned(SeedIdentifier()) % int.MaxValue;
		}
		if (seed == 0)
		{
			seed = 123456u;
		}
		Seed = seed;
		Server.seed = (int)seed;
	}

	private static string SeedIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_" + 271 + "_" + Server.identity;
	}

	public static void InitSalt(int salt)
	{
		InitSalt((uint)salt);
	}

	public static void InitSalt(uint salt)
	{
		if (salt == 0)
		{
			salt = MurmurHashEx.MurmurHashUnsigned(SaltIdentifier()) % int.MaxValue;
		}
		if (salt == 0)
		{
			salt = 654321u;
		}
		Salt = salt;
		Server.salt = (int)salt;
	}

	private static string SaltIdentifier()
	{
		return SystemInfo.deviceUniqueIdentifier + "_salt";
	}

	public static void InitSize(int size)
	{
		InitSize((uint)size);
	}

	public static void InitSize(uint size)
	{
		if (size == 0)
		{
			size = 4500u;
		}
		if (size < 1000)
		{
			size = 1000u;
		}
		if (size > 6000)
		{
			size = 6000u;
		}
		Size = size;
		Server.worldsize = (int)size;
	}

	public static byte[] GetMap(string name)
	{
		return Serialization.GetMap(name)?.data;
	}

	public static int GetCachedHeightMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("height").Length / 2)));
	}

	public static int GetCachedSplatMapResolution()
	{
		return Mathf.RoundToInt(Mathf.Sqrt((float)(GetMap("splat").Length / 8)));
	}

	public static void AddMap(string name, byte[] data)
	{
		Serialization.AddMap(name, data);
	}

	public static void AddPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		Serialization.AddPrefab(category, prefab.ID, position, rotation, scale);
		if (!Cached)
		{
			rotation = Quaternion.Euler(((Quaternion)(ref rotation)).eulerAngles);
			SpawnPrefab(category, prefab, position, rotation, scale);
		}
	}

	public static PathData PathListToPathData(PathList src)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Expected O, but got Unknown
		return new PathData
		{
			name = src.Name,
			spline = src.Spline,
			start = src.Start,
			end = src.End,
			width = src.Width,
			innerPadding = src.InnerPadding,
			outerPadding = src.OuterPadding,
			innerFade = src.InnerFade,
			outerFade = src.OuterFade,
			randomScale = src.RandomScale,
			meshOffset = src.MeshOffset,
			terrainOffset = src.TerrainOffset,
			splat = src.Splat,
			topology = src.Topology,
			hierarchy = src.Hierarchy,
			nodes = VectorArrayToList(src.Path.Points)
		};
	}

	public static PathList PathDataToPathList(PathData src)
	{
		PathList pathList = new PathList(src.name, VectorListToArray(src.nodes));
		pathList.Spline = src.spline;
		pathList.Start = src.start;
		pathList.End = src.end;
		pathList.Width = src.width;
		pathList.InnerPadding = src.innerPadding;
		pathList.OuterPadding = src.outerPadding;
		pathList.InnerFade = src.innerFade;
		pathList.OuterFade = src.outerFade;
		pathList.RandomScale = src.randomScale;
		pathList.MeshOffset = src.meshOffset;
		pathList.TerrainOffset = src.terrainOffset;
		pathList.Splat = src.splat;
		pathList.Topology = src.topology;
		pathList.Hierarchy = src.hierarchy;
		pathList.Path.RecalculateTangents();
		return pathList;
	}

	public static Vector3[] VectorListToArray(List<VectorData> src)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[src.Count];
		for (int i = 0; i < array.Length; i++)
		{
			VectorData val = src[i];
			Vector3 val2 = default(Vector3);
			val2.x = val.x;
			val2.y = val.y;
			val2.z = val.z;
			array[i] = val2;
		}
		return array;
	}

	public static List<VectorData> VectorArrayToList(Vector3[] src)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		List<VectorData> list = new List<VectorData>(src.Length);
		foreach (Vector3 val in src)
		{
			VectorData item = default(VectorData);
			item.x = val.x;
			item.y = val.y;
			item.z = val.z;
			list.Add(item);
		}
		return list;
	}

	public static IEnumerable<PathList> GetPaths(string name)
	{
		return from p in Serialization.GetPaths(name)
			select PathDataToPathList(p);
	}

	public static void AddPaths(IEnumerable<PathList> paths)
	{
		foreach (PathList path in paths)
		{
			AddPath(path);
		}
	}

	public static void AddPath(PathList path)
	{
		Serialization.AddPath(PathListToPathData(path));
	}

	public static IEnumerator Spawn(float deltaTime, Action<string> statusFunction = null, CancellationToken ct = default(CancellationToken))
	{
		FileSystemBackend backend = FileSystem.Backend;
		AssetBundleBackend assetBundleBackend = (AssetBundleBackend)(object)((backend is AssetBundleBackend) ? backend : null);
		if (assetBundleBackend != null)
		{
			HashSet<string> hashSet = Serialization.world.prefabs.Select((PrefabData p) => StringPool.Get(p.id)).ToHashSet<string>(StringComparer.OrdinalIgnoreCase);
			List<string> requiredAssetScenes = assetBundleBackend.GetRequiredAssetScenesForPrefabs((IEnumerable<string>)hashSet);
			IEnumerator loading = assetBundleBackend.LoadAssetScenes(requiredAssetScenes);
			bool wantsCancel = false;
			float lastProgress = 0f;
			while (loading.MoveNext())
			{
				if (!wantsCancel && ct.IsCancellationRequested)
				{
					wantsCancel = true;
					Debug.LogWarning((object)"Cancel was requested but must wait for asset scenes to finish loading");
				}
				float assetSceneProgress = assetBundleBackend.GetAssetSceneProgress(requiredAssetScenes);
				if (!Mathf.Approximately(assetSceneProgress, lastProgress))
				{
					lastProgress = assetSceneProgress;
					Status(statusFunction, $"Loading World Prefabs {assetSceneProgress * 100f:0.0}%");
				}
				yield return loading.Current;
			}
		}
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			if (ct.IsCancellationRequested)
			{
				break;
			}
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == Serialization.world.prefabs.Count - 1)
			{
				Status(statusFunction, "Spawning World ({0}/{1})", i + 1, Serialization.world.prefabs.Count);
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn()
	{
		for (int i = 0; i < Serialization.world.prefabs.Count; i++)
		{
			SpawnPrefabData(Serialization.world.prefabs[i]);
		}
	}

	public static void Spawn(string category, string folder = null)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (string.IsNullOrEmpty(folder) || text.StartsWith(folder))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	public static void Spawn(string category, string[] folders)
	{
		for (int i = SpawnIndex; i < Serialization.world.prefabs.Count; i++)
		{
			PrefabData val = Serialization.world.prefabs[i];
			if (!(val.category != category))
			{
				string text = StringPool.Get(val.id);
				if (folders == null || StringEx.StartsWithAny(text, folders))
				{
					SpawnPrefabData(val);
					SpawnIndex++;
					continue;
				}
				break;
			}
			break;
		}
	}

	private static void SpawnPrefabData(PrefabData prefab)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		StringPool.Get(prefab.id);
		uint id = prefab.id;
		SpawnPrefab(prefab.category, Prefab.Load(id), VectorData.op_Implicit(prefab.position), VectorData.op_Implicit(prefab.rotation), VectorData.op_Implicit(prefab.scale));
	}

	private static void SpawnPrefab(string category, Prefab prefab, Vector3 position, Quaternion rotation, Vector3 scale)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (prefab != null && Object.op_Implicit((Object)(object)prefab.Object))
		{
			spawnTimer.Restart();
			if (!Cached)
			{
				prefab.ApplyTerrainPlacements(position, rotation, scale);
				prefab.ApplyTerrainModifiers(position, rotation, scale);
			}
			GameObject val = prefab.Spawn(position, rotation, scale);
			TrackSpawnedPrefab(category, val);
			Interface.CallHook("OnWorldPrefabSpawned", (object)val, (object)category);
			spawnTimer.Stop();
			spawnTimings.Add(new SpawnTiming
			{
				category = category,
				prefab = prefab,
				position = position,
				rotation = rotation,
				scale = scale,
				time = spawnTimer.Elapsed
			});
		}
	}

	public static void TrackSpawnedPrefab(string category, GameObject instance)
	{
		if (!string.IsNullOrEmpty(category) && !((Object)(object)instance == (Object)null))
		{
			if (!SpawnedPrefabs.TryGetValue(category, out var value))
			{
				value = new HashSet<GameObject>();
				SpawnedPrefabs[category] = value;
			}
			value.Add(instance);
		}
	}

	private static void Status(Action<string> statusFunction, string status, object obj1)
	{
		statusFunction?.Invoke(string.Format(status, obj1));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2));
	}

	private static void Status(Action<string> statusFunction, string status, object obj1, object obj2, object obj3)
	{
		statusFunction?.Invoke(string.Format(status, obj1, obj2, obj3));
	}

	private static void Status(Action<string> statusFunction, string status, params object[] objs)
	{
		statusFunction?.Invoke(string.Format(status, objs));
	}

	public static IEnumerable<SpawnTiming> GetSpawnTimings()
	{
		return spawnTimings;
	}

	public static void ResetTiming()
	{
		spawnTimings.Clear();
	}
}


using System;
using UnityEngine;

public struct SpawnTiming
{
	public string category;

	public Prefab prefab;

	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public TimeSpan time;
}


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using ConVar;
using Newtonsoft.Json;
using UnityEngine;

[JsonModel]
public class WorldConfig
{
	public string JsonString = string.Empty;

	public float PercentageTier0 = 0.3f;

	public float PercentageTier1 = 0.3f;

	public float PercentageTier2 = 0.4f;

	public float PercentageBiomeArid = 0.4f;

	public float PercentageBiomeTemperate = 0.15f;

	public float PercentageBiomeTundra = 0.15f;

	public float PercentageBiomeArctic = 0.3f;

	public float PercentageBiomeJungle = 0.5f;

	public bool MainRoads = true;

	public bool SideRoads = true;

	public bool Trails = true;

	public bool Rivers = true;

	public bool Powerlines = true;

	public bool AboveGroundRails = true;

	public bool BelowGroundRails = true;

	public bool UnderwaterLabs = true;

	public List<string> PrefabBlacklist = new List<string>();

	public List<string> PrefabWhitelist = new List<string>();

	public bool IsPrefabAllowed(string name)
	{
		if (PrefabBlacklist.Count > 0)
		{
			foreach (string item in PrefabBlacklist)
			{
				if (name.Contains(item))
				{
					return false;
				}
			}
		}
		if (PrefabWhitelist.Count > 0)
		{
			foreach (string item2 in PrefabWhitelist)
			{
				if (name.Contains(item2))
				{
					return true;
				}
			}
			return false;
		}
		return true;
	}

	public void LoadFromJsonFile(string fileName)
	{
		try
		{
			LoadFromJsonString(File.ReadAllText(fileName));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromJsonString(string data)
	{
		try
		{
			LoadFromWorldConfig(JsonConvert.DeserializeObject<WorldConfig>(JsonString = data));
		}
		catch (Exception ex)
		{
			Debug.LogError((object)ex.Message);
		}
	}

	public void LoadFromWorldConfig(WorldConfig data)
	{
		float num = data.PercentageTier0 + data.PercentageTier1 + data.PercentageTier2;
		if (num > 0f)
		{
			PercentageTier0 = data.PercentageTier0 / num;
			PercentageTier1 = data.PercentageTier1 / num;
			PercentageTier2 = data.PercentageTier2 / num;
		}
		else
		{
			PercentageTier0 = 0f;
			PercentageTier1 = 1f;
			PercentageTier2 = 0f;
		}
		float num2 = data.PercentageBiomeArid + data.PercentageBiomeTemperate + data.PercentageBiomeTundra + data.PercentageBiomeArctic;
		if (num2 > 0f)
		{
			PercentageBiomeArid = data.PercentageBiomeArid / num2;
			PercentageBiomeTemperate = data.PercentageBiomeTemperate / num2;
			PercentageBiomeTundra = data.PercentageBiomeTundra / num2;
			PercentageBiomeArctic = data.PercentageBiomeArctic / num2;
		}
		else
		{
			PercentageBiomeArid = 0f;
			PercentageBiomeTemperate = 1f;
			PercentageBiomeTundra = 0f;
			PercentageBiomeArctic = 0f;
		}
		MainRoads = data.MainRoads;
		SideRoads = data.SideRoads;
		Trails = data.Trails;
		Rivers = data.Rivers;
		Powerlines = data.Powerlines;
		AboveGroundRails = data.AboveGroundRails;
		BelowGroundRails = data.BelowGroundRails;
		UnderwaterLabs = data.UnderwaterLabs;
		PrefabBlacklist.Clear();
		if (data.PrefabBlacklist != null && data.PrefabBlacklist.Count > 0)
		{
			PrefabBlacklist.AddRange(data.PrefabBlacklist);
		}
		PrefabWhitelist.Clear();
		if (data.PrefabWhitelist != null && data.PrefabWhitelist.Count > 0)
		{
			PrefabWhitelist.AddRange(data.PrefabWhitelist);
		}
	}

	public void LoadScriptableConfigs()
	{
		ScriptableWorldConfig[] array = Resources.LoadAll<ScriptableWorldConfig>("");
		bool flag = false;
		ScriptableWorldConfig[] array2 = array;
		foreach (ScriptableWorldConfig scriptableWorldConfig in array2)
		{
			if (scriptableWorldConfig.GameModes != null && scriptableWorldConfig.GameModes.Contains(Server.gamemode))
			{
				MergeScriptableConfig(scriptableWorldConfig);
				flag = true;
			}
		}
		if (flag)
		{
			JsonString = JsonConvert.SerializeObject((object)this);
		}
	}

	private void MergeScriptableConfig(ScriptableWorldConfig config)
	{
		UnderwaterLabs &= config.UnderwaterLabs;
		BelowGroundRails &= config.UndergroundTrains;
		if (PrefabBlacklist == null)
		{
			PrefabBlacklist = new List<string>();
		}
		if (config.BlacklistedPrefabs != null)
		{
			PrefabBlacklist.AddRange(config.BlacklistedPrefabs);
		}
	}
}


using System;
using UnityEngine;

public abstract class DecorComponent : PrefabAttribute
{
	internal bool isRoot;

	public abstract void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale);

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.AttributeSetup(rootObj, name, serverside, clientside, bundling);
		isRoot = (Object)(object)rootObj == (Object)(object)((Component)this).gameObject;
	}

	protected override Type GetIndexedType()
	{
		return typeof(DecorComponent);
	}
}


using UnityEngine;

public static class DecorComponentEx
{
	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components, ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		foreach (DecorComponent decorComponent in components)
		{
			if (!decorComponent.isRoot)
			{
				break;
			}
			decorComponent.Apply(ref pos, ref rot, ref scale);
		}
	}

	public static void ApplyDecorComponents(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.position = pos;
		transform.rotation = rot;
		transform.localScale = scale;
	}

	public static void ApplyDecorComponentsScaleOnly(this Transform transform, DecorComponent[] components)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		Quaternion rot = transform.rotation;
		Vector3 scale = transform.localScale;
		transform.ApplyDecorComponents(components, ref pos, ref rot, ref scale);
		transform.localScale = scale;
	}
}


using UnityEngine;

public class DecorAlign : DecorComponent
{
	public float NormalAlignment = 1f;

	public float GradientAlignment = 1f;

	public Vector3 SlopeOffset = Vector3.zero;

	public Vector3 SlopeScale = Vector3.one;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normal = TerrainMeta.HeightMap.GetNormal(pos);
		Vector3 val = ((normal == Vector3.up) ? Vector3.forward : Vector3.Cross(normal, Vector3.up));
		Vector3 val2 = Vector3.Cross(normal, val);
		if (SlopeOffset != Vector3.zero || SlopeScale != Vector3.one)
		{
			float slope = TerrainMeta.HeightMap.GetSlope01(pos);
			if (SlopeOffset != Vector3.zero)
			{
				Vector3 val3 = SlopeOffset * slope;
				pos += val3.x * val;
				pos += val3.y * normal;
				pos -= val3.z * val2;
			}
			if (SlopeScale != Vector3.one)
			{
				Vector3 val4 = Vector3.Lerp(Vector3.one, Vector3.one + Quaternion.Inverse(rot) * (SlopeScale - Vector3.one), slope);
				scale.x *= val4.x;
				scale.y *= val4.y;
				scale.z *= val4.z;
			}
		}
		Vector3 up = Vector3.Lerp(rot * Vector3.up, normal, NormalAlignment);
		Vector3 forward = Vector3.Lerp(rot * Vector3.forward, val2, GradientAlignment);
		rot = QuaternionEx.LookRotationForcedUp(forward, up);
	}
}


using UnityEngine;

public class DecorFlip : DecorComponent
{
	public enum AxisType
	{
		X,
		Y,
		Z
	}

	public AxisType FlipAxis = AxisType.Y;

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 4;
		if (!(SeedRandom.Value(ref num) > 0.5f))
		{
			switch (FlipAxis)
			{
			case AxisType.X:
			case AxisType.Z:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.up) * rot;
				break;
			case AxisType.Y:
				rot = Quaternion.AngleAxis(180f, rot * Vector3.forward) * rot;
				break;
			}
		}
	}
}


public enum AxisType
{
	X,
	Y,
	Z
}


using UnityEngine;

public class DecorOffset : DecorComponent
{
	public Vector3 MinOffset = new Vector3(0f, 0f, 0f);

	public Vector3 MaxOffset = new Vector3(0f, 0f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 1;
		pos.x += scale.x * SeedRandom.Range(ref num, MinOffset.x, MaxOffset.x);
		pos.y += scale.y * SeedRandom.Range(ref num, MinOffset.y, MaxOffset.y);
		pos.z += scale.z * SeedRandom.Range(ref num, MinOffset.z, MaxOffset.z);
	}
}


using UnityEngine;

public class DecorRotate : DecorComponent
{
	public Vector3 MinRotation = new Vector3(0f, -180f, 0f);

	public Vector3 MaxRotation = new Vector3(0f, 180f, 0f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 2;
		float num2 = SeedRandom.Range(ref num, MinRotation.x, MaxRotation.x);
		float num3 = SeedRandom.Range(ref num, MinRotation.y, MaxRotation.y);
		float num4 = SeedRandom.Range(ref num, MinRotation.z, MaxRotation.z);
		rot = Quaternion.Euler(num2, num3, num4) * rot;
	}
}


using UnityEngine;

public class DecorScale : DecorComponent
{
	public Vector3 MinScale = new Vector3(1f, 1f, 1f);

	public Vector3 MaxScale = new Vector3(2f, 2f, 2f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(pos, World.Seed) + 3;
		float num2 = SeedRandom.Value(ref num);
		scale.x *= Mathf.Lerp(MinScale.x, MaxScale.x, num2);
		scale.y *= Mathf.Lerp(MinScale.y, MaxScale.y, num2);
		scale.z *= Mathf.Lerp(MinScale.z, MaxScale.z, num2);
	}
}


using System;
using UnityEngine;

public class DecorSocketFemale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketFemale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(1f, 0.5f, 0.5f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using System;
using UnityEngine;

public class DecorSocketMale : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(DecorSocketMale);
	}

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 1f, 1f);
		Gizmos.DrawSphere(((Component)this).transform.position, 1f);
	}
}


using UnityEngine;

public class DecorSwim : DecorComponent
{
	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		pos.y = WaterLevel.GetWaterSurface(pos, waves: false, volumes: false);
		if (pos.y <= TerrainMeta.Position.y + 1f)
		{
			pos.y = 0f;
		}
	}
}


using UnityEngine;

public class DecorTransform : DecorComponent
{
	public Vector3 Position = new Vector3(0f, 0f, 0f);

	public Vector3 Rotation = new Vector3(0f, 0f, 0f);

	public Vector3 Scale = new Vector3(1f, 1f, 1f);

	public override void Apply(ref Vector3 pos, ref Quaternion rot, ref Vector3 scale)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		pos += rot * Vector3.Scale(scale, Position);
		rot = Quaternion.Euler(Rotation) * rot;
		scale = Vector3.Scale(scale, Scale);
	}
}


public class DecorPatch
{
}


using Development.Attributes;
using UnityEngine;

[ResetStaticFields]
public class DecorSpawn : MonoBehaviour, IClientComponent
{
	public SpawnFilter Filter;

	public string ResourceFolder = string.Empty;

	public uint Seed;

	public float ObjectCutoff = 0.2f;

	public float ObjectTapering = 0.2f;

	public int ObjectsPerPatch = 10;

	public float ClusterRadius = 2f;

	public int ClusterSizeMin = 1;

	public int ClusterSizeMax = 10;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public bool LOD = true;
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseInfo : LandmarkInfo
{
	public List<GameObject> Links = new List<GameObject>();

	public List<DungeonBaseFloor> Floors = new List<DungeonBaseFloor>();

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public void Add(DungeonBaseLink link)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		Links.Add(((Component)link).gameObject);
		if (link.Type == DungeonBaseLinkType.End)
		{
			return;
		}
		DungeonBaseFloor dungeonBaseFloor = null;
		float num = float.MaxValue;
		for (int i = 0; i < Floors.Count; i++)
		{
			DungeonBaseFloor dungeonBaseFloor2 = Floors[i];
			float num2 = dungeonBaseFloor2.Distance(((Component)link).transform.position);
			if (!(num2 >= 1f) && !(num2 >= num))
			{
				dungeonBaseFloor = dungeonBaseFloor2;
				num = num2;
			}
		}
		if (dungeonBaseFloor == null)
		{
			dungeonBaseFloor = new DungeonBaseFloor();
			dungeonBaseFloor.Links.Add(link);
			Floors.Add(dungeonBaseFloor);
			Floors.Sort((DungeonBaseFloor l, DungeonBaseFloor r) => l.SignedDistance(((Component)this).transform.position).CompareTo(r.SignedDistance(((Component)this).transform.position)));
		}
		else
		{
			dungeonBaseFloor.Links.Add(link);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseEntrances.Add(this);
		}
	}

	protected void Start()
	{
		World.TrackSpawnedPrefab("DungeonBase", ((Component)this).gameObject);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class DungeonBaseFloor
{
	public List<DungeonBaseLink> Links = new List<DungeonBaseLink>();

	public float Distance(Vector3 position)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return Mathf.Abs(((Component)Links[0]).transform.position.y - position.y);
	}

	public float SignedDistance(Vector3 position)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)Links[0]).transform.position.y - position.y;
	}
}


using UnityEngine;

[RequireComponent(typeof(DungeonBaseLink))]
public class DungeonBaseLandmarkInfo : LandmarkInfo
{
	private DungeonBaseLink baseLink;

	private MapLayer? layer;

	public override MapLayer MapLayer
	{
		get
		{
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			if (layer.HasValue)
			{
				return layer.Value;
			}
			DungeonBaseInfo dungeonBaseInfo = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonBaseEntrances, ((Component)baseLink).transform.position);
			if ((Object)(object)dungeonBaseInfo == (Object)null)
			{
				Debug.LogWarning((object)"Couldn't determine which underwater lab a DungeonBaseLandmarkInfo belongs to", (Object)(object)this);
				shouldDisplayOnMap = false;
				layer = MapLayer.Overworld;
				return layer.Value;
			}
			int num = -1;
			for (int i = 0; i < dungeonBaseInfo.Floors.Count; i++)
			{
				if (dungeonBaseInfo.Floors[i].Links.Contains(baseLink))
				{
					num = i;
				}
			}
			if (num >= 0)
			{
				layer = (MapLayer)(1 + num);
			}
			else
			{
				Debug.LogWarning((object)"Couldn't determine the floor of a DungeonBaseLandmarkInfo", (Object)(object)this);
				shouldDisplayOnMap = false;
				layer = MapLayer.Overworld;
			}
			return layer.Value;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		baseLink = ((Component)this).GetComponent<DungeonBaseLink>();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonBaseLink : MonoBehaviour
{
	public DungeonBaseLinkType Type;

	public int Cost = 1;

	public int MaxFloor = -1;

	public int MaxCountLocal = -1;

	public int MaxCountGlobal = -1;

	[Tooltip("If set to a positive number, all segments with the same MaxCountIdentifier are counted towards MaxCountLocal and MaxCountGlobal")]
	public int MaxCountIdentifier = -1;

	public DungeonBaseInfo Dungeon;

	public RendererLOD[] MapRendererLods = new RendererLOD[0];

	private List<DungeonBaseSocket> sockets;

	private List<DungeonVolume> volumes;

	internal List<DungeonBaseSocket> Sockets
	{
		get
		{
			if (sockets == null)
			{
				sockets = new List<DungeonBaseSocket>();
				((Component)this).GetComponentsInChildren<DungeonBaseSocket>(true, sockets);
			}
			return sockets;
		}
	}

	internal List<DungeonVolume> Volumes
	{
		get
		{
			if (volumes == null)
			{
				volumes = new List<DungeonVolume>();
				((Component)this).GetComponentsInChildren<DungeonVolume>(true, volumes);
			}
			return volumes;
		}
	}

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonBaseLinks.Add(this);
		}
	}

	internal void Initialize()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)TerrainMeta.Path == (Object)null))
		{
			Dungeon = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonBaseEntrances, ((Component)this).transform.position);
			if (!((Object)(object)Dungeon == (Object)null))
			{
				Dungeon.Add(this);
			}
		}
	}
}


public enum DungeonBaseLinkType
{
	Room,
	Corridor,
	End
}


using UnityEngine;

public class DungeonBaseSocket : MonoBehaviour
{
	public DungeonBaseSocketType Type;

	public bool Male = true;

	public bool Female = true;
}


public enum DungeonBaseSocketType
{
	Horizontal,
	Vertical,
	Pillar
}


using UnityEngine;

public class DungeonBaseTransition : MonoBehaviour
{
	public DungeonBaseSocketType Type;

	public DungeonBaseLinkType Neighbour1;

	public DungeonBaseLinkType Neighbour2;
}


using UnityEngine;

public class DungeonConditionalModel : MonoBehaviour
{
	public MapLayer Layer;

	private void Start()
	{
		foreach (Transform child in ((Component)this).transform.GetChildren())
		{
			((Component)child).gameObject.SetActive(!World.Config.BelowGroundRails);
		}
	}
}


using UnityEngine;

public class DungeonGridCell : MonoBehaviour
{
	public DungeonGridConnectionType North;

	public DungeonGridConnectionType South;

	public DungeonGridConnectionType West;

	public DungeonGridConnectionType East;

	public DungeonGridConnectionVariant NorthVariant;

	public DungeonGridConnectionVariant SouthVariant;

	public DungeonGridConnectionVariant WestVariant;

	public DungeonGridConnectionVariant EastVariant;

	public GameObjectRef[] AvoidNeighbours;

	public RendererLOD[] MapRendererLods;

	public bool Replaceable;

	public bool ShouldAvoid(uint id)
	{
		GameObjectRef[] avoidNeighbours = AvoidNeighbours;
		for (int i = 0; i < avoidNeighbours.Length; i++)
		{
			if (avoidNeighbours[i].resourceID == id)
			{
				return true;
			}
		}
		return false;
	}

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonGridCells.Add(this);
		}
	}
}


public enum DungeonGridConnectionType
{
	None,
	TrainTunnel
}


public enum DungeonGridConnectionVariant
{
	A,
	B
}


public struct DungeonGridConnectionHash
{
	public bool North;

	public bool South;

	public bool West;

	public bool East;

	public int Value => (North ? 1 : 0) | (South ? 2 : 0) | (West ? 4 : 0) | (East ? 8 : 0);
}


using System.Collections.Generic;
using UnityEngine;

public class DungeonGridInfo : LandmarkInfo
{
	[Header("DungeonGridInfo")]
	public int CellSize = 216;

	public float LinkHeight = 1.5f;

	public float LinkRadius = 3f;

	internal List<GameObject> Links = new List<GameObject>();

	public float MinDistance => (float)CellSize * 2.5f;

	public float Distance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).magnitude;
	}

	public float SqrDistance(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - position;
		return ((Vector3)(ref val)).sqrMagnitude;
	}

	public bool IsValidSpawnPosition(Vector3 position)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		OBB bounds = ((Component)this).GetComponentInChildren<DungeonVolume>().GetBounds(position, Quaternion.identity);
		Vector3 val = WorldSpaceGrid.ClosestGridCell(bounds.position, TerrainMeta.Size.x, (float)CellSize, (RoundingMode)1);
		Vector3 val2 = bounds.position - val;
		if (!(Mathf.Abs(val2.x) > 3f))
		{
			return Mathf.Abs(val2.z) > 3f;
		}
		return true;
	}

	public Vector3 SnapPosition(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		pos.x = (float)Mathf.RoundToInt(pos.x / LinkRadius) * LinkRadius;
		pos.y = (float)Mathf.CeilToInt(pos.y / LinkHeight) * LinkHeight;
		pos.z = (float)Mathf.RoundToInt(pos.z / LinkRadius) * LinkRadius;
		return pos;
	}

	protected override void Awake()
	{
		base.Awake();
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.DungeonGridEntrances.Add(this);
		}
	}

	protected void Start()
	{
		World.TrackSpawnedPrefab("Dungeon", ((Component)this).gameObject);
	}
}


using UnityEngine;

public class DungeonGridLink : MonoBehaviour
{
	public Transform UpSocket;

	public Transform DownSocket;

	public DungeonGridLinkType UpType;

	public DungeonGridLinkType DownType;

	public int Priority;

	public int Rotation;

	protected void Start()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)TerrainMeta.Path == (Object)null))
		{
			DungeonGridInfo dungeonGridInfo = TerrainMeta.Path.FindClosest(TerrainMeta.Path.DungeonGridEntrances, ((Component)this).transform.position);
			if (!((Object)(object)dungeonGridInfo == (Object)null))
			{
				dungeonGridInfo.Links.Add(((Component)this).gameObject);
			}
		}
	}
}


public enum DungeonGridLinkType
{
	Default,
	Elevator,
	Transition
}


using UnityEngine;

public class DungeonVolume : MonoBehaviour
{
	public Bounds bounds = new Bounds(Vector3.zero, Vector3.one);

	public OBB GetBounds(Vector3 position, Quaternion rotation)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (((Component)this).transform.localRotation * ((Bounds)(ref bounds)).center + ((Component)this).transform.localPosition);
		return new OBB(position, ((Bounds)(ref bounds)).size, rotation * ((Component)this).transform.localRotation);
	}

	public OBB GetBounds(Vector3 position, Quaternion rotation, Vector3 extrude)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		position += rotation * (((Component)this).transform.localRotation * ((Bounds)(ref bounds)).center + ((Component)this).transform.localPosition);
		return new OBB(position, ((Bounds)(ref bounds)).size + extrude, rotation * ((Component)this).transform.localRotation);
	}
}


using System;
using UnityEngine;

public class EnvironmentVolumeCheck : PrefabAttribute
{
	[InspectorFlags]
	public EnvironmentType Type = EnvironmentType.Underground | EnvironmentType.TrainTunnels;

	public Vector3 Center = Vector3.zero;

	public Vector3 Size = Vector3.one;

	protected void OnDrawGizmosSelected()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.matrix = ((Component)this).transform.localToWorldMatrix;
		Gizmos.color = new Color(0f, 0f, 0.5f, 1f);
		Gizmos.DrawWireCube(Center, Size);
	}

	public bool Check(OBB obb)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return !EnvironmentManager.Check(obb, Type);
	}

	protected override Type GetIndexedType()
	{
		return typeof(EnvironmentVolumeCheck);
	}
}


using UnityEngine;

public static class EnvironmentVolumeCheckEx
{
	public static bool ApplyEnvironmentVolumeChecks(this Transform transform, EnvironmentVolumeCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		OBB obb = default(OBB);
		foreach (EnvironmentVolumeCheck environmentVolumeCheck in anchors)
		{
			Vector3 val = environmentVolumeCheck.worldPosition + environmentVolumeCheck.worldRotation * environmentVolumeCheck.Center;
			Vector3 val2 = rot * Vector3.Scale(val, scale);
			((OBB)(ref obb))..ctor(pos + val2, Vector3.Scale(environmentVolumeCheck.Size, scale), rot);
			if (!environmentVolumeCheck.Check(obb))
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using UnityEngine;

public class BiomeVisuals : MonoBehaviour
{
	[Serializable]
	public class EnvironmentVolumeOverride
	{
		public EnvironmentType Environment;

		public Enum Biome;
	}

	public GameObject Arid;

	public GameObject Temperate;

	public GameObject Tundra;

	public GameObject Arctic;

	public bool OverrideBiome;

	public Enum ToOverride;

	[Horizontal(2, -1)]
	public EnvironmentVolumeOverride[] EnvironmentVolumeOverrides;

	private bool _supportsPooling;

	private GameObject _defaultSelection;

	protected void Awake()
	{
		_supportsPooling = ((Component)this).gameObject.SupportsPoolingInParent();
		if (Object.op_Implicit((Object)(object)Arid) && Arid.activeSelf)
		{
			_defaultSelection = Arid;
		}
		else if (Object.op_Implicit((Object)(object)Temperate) && Temperate.activeSelf)
		{
			_defaultSelection = Temperate;
		}
		else if (Object.op_Implicit((Object)(object)Tundra) && Tundra.activeSelf)
		{
			_defaultSelection = Tundra;
		}
		else if (Object.op_Implicit((Object)(object)Arctic) && Arctic.activeSelf)
		{
			_defaultSelection = Arctic;
		}
	}

	protected void OnEnable()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Expected I4, but got Unknown
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Expected I4, but got Unknown
		int num = (((Object)(object)TerrainMeta.BiomeMap != (Object)null) ? TerrainMeta.BiomeMap.GetBiomeMaxType(((Component)this).transform.position) : 2);
		if (OverrideBiome)
		{
			num = (int)ToOverride;
		}
		else if (EnvironmentVolumeOverrides.Length != 0)
		{
			EnvironmentType environmentType = EnvironmentManager.Get(((Component)this).transform.position);
			EnvironmentVolumeOverride[] environmentVolumeOverrides = EnvironmentVolumeOverrides;
			foreach (EnvironmentVolumeOverride environmentVolumeOverride in environmentVolumeOverrides)
			{
				if ((environmentType & environmentVolumeOverride.Environment) != 0)
				{
					num = (int)environmentVolumeOverride.Biome;
					break;
				}
			}
		}
		switch (num)
		{
		case 1:
			SetChoice(Arid);
			break;
		case 2:
			SetChoice(Temperate);
			break;
		case 4:
			SetChoice(Tundra);
			break;
		case 8:
			SetChoice(Arctic);
			break;
		default:
			SetChoice(_defaultSelection);
			break;
		}
	}

	private void SetChoice(GameObject selection)
	{
		bool flag = !_supportsPooling;
		ApplyChoice(selection, Arid, flag);
		ApplyChoice(selection, Temperate, flag);
		ApplyChoice(selection, Tundra, flag);
		ApplyChoice(selection, Arctic, flag);
		if ((Object)(object)selection != (Object)null)
		{
			selection.SetActive(true);
		}
		if (flag)
		{
			GameManager.Destroy((Component)(object)this);
		}
	}

	private void ApplyChoice(GameObject selection, GameObject target, bool shouldDestroy)
	{
		if ((Object)(object)target != (Object)null && (Object)(object)target != (Object)(object)selection)
		{
			if (shouldDestroy)
			{
				GameManager.Destroy(target);
			}
			else
			{
				target.SetActive(false);
			}
		}
	}
}


using System;

[Serializable]
public class EnvironmentVolumeOverride
{
	public EnvironmentType Environment;

	public Enum Biome;
}


using UnityEngine;

public class RandomDestroy : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref num) > Probability)
		{
			GameManager.Destroy((Component)(object)this);
		}
		else
		{
			GameManager.Destroy(((Component)this).gameObject);
		}
	}
}


using UnityEngine;

public class RandomDynamicObject : MonoBehaviour, IClientComponent, ILOD
{
	public uint Seed;

	public float Distance = 100f;

	public float Probability = 0.5f;

	public GameObject[] Candidates;
}


using UnityEngine;

public class RandomDynamicPrefab : MonoBehaviour, IClientComponent, ILOD
{
	public uint Seed;

	public float Distance = 100f;

	public float Probability = 0.5f;

	public string ResourceFolder = string.Empty;
}


using UnityEngine;

public class RandomStaticObject : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	public GameObject[] Candidates;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint num = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref num) > Probability)
		{
			for (int i = 0; i < Candidates.Length; i++)
			{
				GameManager.Destroy(Candidates[i]);
			}
			GameManager.Destroy((Component)(object)this);
			return;
		}
		int num2 = SeedRandom.Range(num, 0, ((Component)this).transform.childCount);
		for (int j = 0; j < Candidates.Length; j++)
		{
			GameObject val = Candidates[j];
			if (j == num2)
			{
				val.SetActive(true);
			}
			else
			{
				GameManager.Destroy(val);
			}
		}
		GameManager.Destroy((Component)(object)this);
	}
}


using UnityEngine;

public class RandomStaticPrefab : MonoBehaviour
{
	public uint Seed;

	public float Probability = 0.5f;

	public string ResourceFolder = string.Empty;

	protected void Start()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		uint seed = SeedEx.Seed(((Component)this).transform.position, World.Seed + Seed);
		if (SeedRandom.Value(ref seed) > Probability)
		{
			GameManager.Destroy((Component)(object)this);
			return;
		}
		Prefab.LoadRandom("assets/bundled/prefabs/autospawn/" + ResourceFolder, ref seed).Spawn(((Component)this).transform);
		GameManager.Destroy((Component)(object)this);
	}
}


public class ParticlePatch
{
}


using UnityEngine;

public class ParticleSpawn : SingletonComponent<ParticleSpawn>, IClientComponent
{
	public GameObjectRef[] Prefabs;

	public int PatchCount = 8;

	public int PatchSize = 100;

	public Vector3 Origin { get; private set; }
}


using UnityEngine;

public class PowerlineNode : MonoBehaviour
{
	public GameObjectRef WirePrefab;

	public float MaxDistance = 50f;

	protected void Awake()
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			TerrainMeta.Path.AddWire(this);
		}
	}
}


using UnityEngine;

public class RemoveChildObjectsAlongPath : MonoBehaviour, IEditorComponent
{
	public Transform Node1;

	public Transform Node2;

	public float Distance;
}


using System.Collections.Generic;
using UnityEngine;

public class TerrainPathChildObjects : MonoBehaviour
{
	public bool Spline = true;

	public float Width;

	public float Offset;

	public float Fade;

	[InspectorFlags]
	public Enum Splat = (Enum)1;

	[InspectorFlags]
	public Enum Topology = (Enum)2048;

	public InfrastructureType Type;

	protected void Awake()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Expected O, but got Unknown
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Expected I4, but got Unknown
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Expected I4, but got Unknown
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Expected I4, but got Unknown
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Expected I4, but got Unknown
		if (!World.Cached && !World.Networked)
		{
			List<Vector3> list = new List<Vector3>();
			foreach (Transform item in ((Component)this).transform)
			{
				Transform val = item;
				list.Add(val.position);
			}
			if (list.Count >= 2)
			{
				switch (Type)
				{
				case InfrastructureType.Road:
				{
					PathList pathList2 = new PathList("Road " + TerrainMeta.Path.Roads.Count, list.ToArray());
					pathList2.Width = Width;
					pathList2.InnerFade = Fade * 0.5f;
					pathList2.OuterFade = Fade * 0.5f;
					pathList2.MeshOffset = Offset * 0.3f;
					pathList2.TerrainOffset = Offset;
					pathList2.Topology = (int)Topology;
					pathList2.Splat = (int)Splat;
					pathList2.Spline = Spline;
					pathList2.Path.RecalculateTangents();
					TerrainMeta.Path.Roads.Add(pathList2);
					break;
				}
				case InfrastructureType.Power:
				{
					PathList pathList = new PathList("Powerline " + TerrainMeta.Path.Powerlines.Count, list.ToArray());
					pathList.Width = Width;
					pathList.InnerFade = Fade * 0.5f;
					pathList.OuterFade = Fade * 0.5f;
					pathList.MeshOffset = Offset * 0.3f;
					pathList.TerrainOffset = Offset;
					pathList.Topology = (int)Topology;
					pathList.Splat = (int)Splat;
					pathList.Spline = Spline;
					pathList.Path.RecalculateTangents();
					TerrainMeta.Path.Powerlines.Add(pathList);
					break;
				}
				}
			}
		}
		GameManager.Destroy(((Component)this).gameObject);
	}

	protected void OnDrawGizmos()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		Vector3 a = Vector3.zero;
		foreach (Transform item in ((Component)this).transform)
		{
			Vector3 position = item.position;
			if (flag)
			{
				Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
				GizmosUtil.DrawWirePath(a, position, 0.5f * Width);
			}
			a = position;
			flag = true;
		}
	}
}


using UnityEngine;

public class TerrainPathConnect : MonoBehaviour
{
	public InfrastructureType Type;

	public PathFinder.Point GetPathFinderPoint(int res)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return PathFinder.GetPoint(((Component)this).transform.position, res);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathSequence : PrefabAttribute
{
	protected override Type GetIndexedType()
	{
		return typeof(PathSequence);
	}

	public virtual void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
	}
}


using System.Collections.Generic;
using UnityEngine;

public class PathSequencePowerline : PathSequence
{
	public enum SequenceRule
	{
		PowerlinePlatform,
		Powerline
	}

	public SequenceRule Rule;

	private const int RegularPowerlineSpacing = 2;

	public override void ApplySequenceReplacement(List<Prefab> sequence, ref Prefab replacement, Prefab[] possibleReplacements, int pathLength, int pathIndex, Vector3 position)
	{
		bool flag = false;
		if (Rule == SequenceRule.Powerline)
		{
			if (pathLength >= 3)
			{
				flag = sequence.Count == 0 || pathIndex == pathLength - 1;
				if (!flag)
				{
					flag = GetIndexCountToRule(sequence, SequenceRule.PowerlinePlatform) >= 2;
				}
			}
		}
		else if (Rule == SequenceRule.PowerlinePlatform)
		{
			flag = pathLength < 3;
			if (!flag)
			{
				int indexCountToRule = GetIndexCountToRule(sequence, SequenceRule.PowerlinePlatform);
				flag = indexCountToRule < 2 && indexCountToRule != sequence.Count && pathIndex < pathLength - 1;
			}
		}
		if (flag)
		{
			Prefab prefabOfType = GetPrefabOfType(possibleReplacements, (Rule == SequenceRule.PowerlinePlatform) ? SequenceRule.Powerline : SequenceRule.PowerlinePlatform);
			if (prefabOfType != null)
			{
				replacement = prefabOfType;
			}
		}
	}

	private Prefab GetPrefabOfType(Prefab[] options, SequenceRule ruleToFind)
	{
		for (int i = 0; i < options.Length; i++)
		{
			PathSequencePowerline pathSequencePowerline = options[i].Attribute.Find<PathSequence>(options[i].ID) as PathSequencePowerline;
			if (pathSequencePowerline == null || pathSequencePowerline.Rule == ruleToFind)
			{
				return options[i];
			}
		}
		return null;
	}

	private int GetIndexCountToRule(List<Prefab> sequence, SequenceRule rule)
	{
		int num = 0;
		for (int num2 = sequence.Count - 1; num2 >= 0; num2--)
		{
			PathSequencePowerline pathSequencePowerline = sequence[num2].Attribute.Find<PathSequence>(sequence[num2].ID) as PathSequencePowerline;
			if (pathSequencePowerline != null)
			{
				if (pathSequencePowerline.Rule == rule)
				{
					break;
				}
				num++;
			}
		}
		return num;
	}
}


public enum SequenceRule
{
	PowerlinePlatform,
	Powerline
}


using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Procedural/Mega Wire")]
public class PowerLineWire : MonoBehaviour
{
	public List<Transform> poles = new List<Transform>();

	public List<PowerLineWireConnectionDef> connections = new List<PowerLineWireConnectionDef>();

	public List<PowerLineWireSpan> spans = new List<PowerLineWireSpan>();

	public void Copy(PowerLineWire from, PowerLineWireConnectionHelper helper)
	{
		connections.Clear();
		if (Object.op_Implicit((Object)(object)helper))
		{
			for (int i = 0; i < helper.connections.Count; i++)
			{
				connections.Add(new PowerLineWireConnectionDef(helper.connections[i]));
			}
		}
		else
		{
			for (int j = 0; j < from.connections.Count; j++)
			{
				connections.Add(new PowerLineWireConnectionDef(from.connections[j]));
			}
		}
	}

	public static PowerLineWire Create(PowerLineWire wire, List<GameObject> objs, GameObjectRef wirePrefab, string name, PowerLineWire copyfrom, float wiresize, float str)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Expected O, but got Unknown
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		if (objs != null && objs.Count > 1)
		{
			GameObject val = null;
			if ((Object)(object)wire == (Object)null)
			{
				val = new GameObject();
				((Object)val).name = name;
				wire = val.AddComponent<PowerLineWire>();
			}
			else
			{
				val = ((Component)wire).gameObject;
			}
			wire.poles.Clear();
			wire.spans.Clear();
			wire.connections.Clear();
			wire.poles.Add(objs[0].transform);
			for (int i = 0; i < objs.Count - 1; i++)
			{
				GameObject val2 = new GameObject
				{
					name = name + " Span Mesh " + i
				};
				val2.transform.parent = val.transform;
				PowerLineWireSpan powerLineWireSpan = val2.AddComponent<PowerLineWireSpan>();
				powerLineWireSpan.wirePrefab = wirePrefab;
				powerLineWireSpan.start = objs[i].transform;
				powerLineWireSpan.end = objs[i + 1].transform;
				wire.spans.Add(powerLineWireSpan);
				wire.poles.Add(objs[i + 1].transform);
			}
			PowerLineWireConnectionHelper component = objs[0].GetComponent<PowerLineWireConnectionHelper>();
			if (Object.op_Implicit((Object)(object)copyfrom))
			{
				wire.Copy(copyfrom, component);
			}
			else if (Object.op_Implicit((Object)(object)component))
			{
				wire.Copy(wire, component);
			}
			else
			{
				PowerLineWireConnectionDef item = new PowerLineWireConnectionDef();
				wire.connections.Add(item);
			}
			if (wiresize != 1f)
			{
				for (int j = 0; j < wire.connections.Count; j++)
				{
					wire.connections[j].radius *= wiresize;
				}
			}
			wire.Init();
		}
		return wire;
	}

	public void Init()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < spans.Count; i++)
		{
			PowerLineWireSpan powerLineWireSpan = spans[i];
			powerLineWireSpan.connections.Clear();
			for (int j = 0; j < connections.Count; j++)
			{
				PowerLineWireConnection powerLineWireConnection = new PowerLineWireConnection
				{
					start = powerLineWireSpan.start,
					end = powerLineWireSpan.end,
					inOffset = connections[j].inOffset,
					outOffset = connections[j].outOffset,
					radius = connections[j].radius
				};
				PowerLineWireConnectionHelper component = ((Component)powerLineWireSpan.start).GetComponent<PowerLineWireConnectionHelper>();
				PowerLineWireConnectionHelper component2 = ((Component)powerLineWireSpan.end).GetComponent<PowerLineWireConnectionHelper>();
				powerLineWireConnection.inOffset = component2.connections[j].inOffset;
				powerLineWireConnection.outOffset = component.connections[j].outOffset;
				if (!component.connections[j].hidden && !component2.connections[j].hidden)
				{
					powerLineWireSpan.connections.Add(powerLineWireConnection);
				}
			}
			powerLineWireSpan.Init(this);
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class PowerLineWireConnectionDef
{
	public Vector3 inOffset = Vector3.zero;

	public Vector3 outOffset = Vector3.zero;

	public float radius = 0.01f;

	public bool hidden;

	public PowerLineWireConnectionDef()
	{
	}//IL_0001: Unknown result type (might be due to invalid IL or missing references)
	//IL_0006: Unknown result type (might be due to invalid IL or missing references)
	//IL_000c: Unknown result type (might be due to invalid IL or missing references)
	//IL_0011: Unknown result type (might be due to invalid IL or missing references)


	public PowerLineWireConnectionDef(PowerLineWireConnectionDef src)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		inOffset = src.inOffset;
		outOffset = src.outOffset;
		radius = src.radius;
	}
}


using System;
using UnityEngine;

[Serializable]
public class PowerLineWireConnection
{
	public Vector3 inOffset = Vector3.zero;

	public Vector3 outOffset = Vector3.zero;

	public float radius = 0.01f;

	public Transform start;

	public Transform end;
}


using System.Collections.Generic;
using UnityEngine;

[AddComponentMenu("Mega Wire/Connection Helper")]
public class PowerLineWireConnectionHelper : MonoBehaviour
{
	public List<PowerLineWireConnectionDef> connections = new List<PowerLineWireConnectionDef>();

	public bool showgizmo;
}


using System.Collections.Generic;
using UnityEngine;

public class PowerLineWireSpan : MonoBehaviour
{
	public GameObjectRef wirePrefab;

	public Transform start;

	public Transform end;

	public float WireLength;

	public List<PowerLineWireConnection> connections = new List<PowerLineWireConnection>();

	public void Init(PowerLineWire wire)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)start) && Object.op_Implicit((Object)(object)end))
		{
			WireLength = Vector3.Distance(start.position, end.position);
			for (int i = 0; i < connections.Count; i++)
			{
				Vector3 val = start.TransformPoint(connections[i].outOffset);
				Vector3 val2 = end.TransformPoint(connections[i].inOffset);
				Vector3 val3 = val - val2;
				WireLength = ((Vector3)(ref val3)).magnitude;
				GameObject obj = wirePrefab.Instantiate(((Component)this).transform);
				((Object)obj).name = "WIRE";
				obj.transform.position = Vector3.Lerp(val, val2, 0.5f);
				obj.transform.LookAt(val2);
				obj.transform.localScale = new Vector3(1f, 1f, Vector3.Distance(val, val2));
				obj.SetActive(true);
			}
		}
	}
}


using UnityEngine;

public class ApplyTerrainAnchors : MonoBehaviour
{
	protected void Awake()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		TerrainAnchor[] anchors = null;
		if (component.isServer)
		{
			anchors = PrefabAttribute.server.FindAll<TerrainAnchor>(component.prefabID);
		}
		((Component)this).transform.ApplyTerrainAnchors(anchors);
		GameManager.Destroy((Component)(object)this);
	}
}


using System;
using UnityEngine;

public class TerrainAnchor : PrefabAttribute
{
	public float Extents = 1f;

	public float Offset;

	public float Radius;

	public float SlopeScale;

	public void Apply(out float height, out float min, out float max, Vector3 pos, Vector3 scale, Quaternion rotation)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		float num = 1f + SlopeScale * Mathf.InverseLerp(0f, 90f, Vector3.Angle(Vector3.up, rotation * Vector3.up));
		float num2 = Extents * scale.y * num;
		float num3 = Offset * scale.y * num;
		height = TerrainMeta.HeightMap.GetHeight(pos);
		min = height - num3 - num2;
		max = height - num3 + num2;
		if (!(Radius > 0f))
		{
			return;
		}
		int num4 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(pos.x - Radius));
		int num5 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeX(pos.x + Radius));
		int num6 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(pos.z - Radius));
		int num7 = TerrainMeta.HeightMap.Index(TerrainMeta.NormalizeZ(pos.z + Radius));
		for (int i = num6; i <= num7; i++)
		{
			if (max < min)
			{
				break;
			}
			for (int j = num4; j <= num5; j++)
			{
				if (max < min)
				{
					break;
				}
				float height2 = TerrainMeta.HeightMap.GetHeight(j, i);
				min = Mathf.Max(min, height2 - num3 - num2);
				max = Mathf.Min(max, height2 - num3 + num2);
			}
		}
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainAnchor);
	}
}


public enum TerrainAnchorMode
{
	MinimizeError,
	MinimizeMovement,
	MaximizeHeight
}


using UnityEngine;

public static class TerrainAnchorEx
{
	public static bool ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors, ref Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return transform.ApplyTerrainAnchors(anchors, ref pos, rot, scale, TerrainAnchorMode.MinimizeError, filter);
	}

	public static bool ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors, ref Vector3 pos, Quaternion rot, Vector3 scale, TerrainAnchorMode mode, SpawnFilter filter = null)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		float num = 0f;
		float num2 = float.MinValue;
		float num3 = float.MaxValue;
		foreach (TerrainAnchor terrainAnchor in anchors)
		{
			Vector3 val = Vector3.Scale(terrainAnchor.worldPosition, scale);
			val = rot * val;
			Vector3 val2 = pos + val;
			if (filter != null && filter.GetFactor(val2) == 0f)
			{
				return false;
			}
			terrainAnchor.Apply(out var height, out var min, out var max, val2, scale, rot);
			num += height - val.y;
			num2 = Mathf.Max(num2, min - val.y);
			num3 = Mathf.Min(num3, max - val.y);
			if (num3 < num2)
			{
				return false;
			}
		}
		if (num3 > 1f && num2 < 1f)
		{
			num2 = 1f;
		}
		switch (mode)
		{
		case TerrainAnchorMode.MinimizeError:
			pos.y = Mathf.Clamp(num / (float)anchors.Length, num2, num3);
			break;
		case TerrainAnchorMode.MinimizeMovement:
			pos.y = Mathf.Clamp(pos.y, num2, num3);
			break;
		default:
			pos.y = num3;
			break;
		}
		return true;
	}

	public static void ApplyTerrainAnchors(this Transform transform, TerrainAnchor[] anchors)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pos = transform.position;
		transform.ApplyTerrainAnchors(anchors, ref pos, transform.rotation, transform.lossyScale);
		transform.position = pos;
	}
}


using UnityEngine;

public class TerrainAnchorGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementPadding;

	public float PlacementFade = 16f;

	public float PlacementDistance = 8f;

	public float AnchorExtentsMin = 8f;

	public float AnchorExtentsMax = 16f;

	public float AnchorOffsetMin;

	public float AnchorOffsetMax;
}


using System;
using UnityEngine;

public class TerrainCheck : PrefabAttribute
{
	public bool Rotate = true;

	public float Extents = 1f;

	public bool Check(Vector3 pos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float extents = Extents;
		float height = TerrainMeta.HeightMap.GetHeight(pos);
		float num = pos.y - extents;
		float num2 = pos.y + extents;
		if (num > height)
		{
			return false;
		}
		if (num2 < height)
		{
			return false;
		}
		return true;
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainCheck);
	}
}


using UnityEngine;

public static class TerrainCheckEx
{
	public static bool ApplyTerrainChecks(this Transform transform, TerrainCheck[] anchors, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter filter = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (anchors.Length == 0)
		{
			return true;
		}
		foreach (TerrainCheck terrainCheck in anchors)
		{
			Vector3 val = Vector3.Scale(terrainCheck.worldPosition, scale);
			if (terrainCheck.Rotate)
			{
				val = rot * val;
			}
			Vector3 val2 = pos + val;
			if (filter != null && filter.GetFactor(val2) == 0f)
			{
				return false;
			}
			if (!terrainCheck.Check(val2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class TerrainCheckGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementPadding;

	public float PlacementFade = 16f;

	public float PlacementDistance = 8f;

	public float CheckExtentsMin = 8f;

	public float CheckExtentsMax = 16f;

	public bool CheckRotate = true;
}


using UnityEngine;

public class TerrainCheckGeneratorVolumes : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius;

	public float PlacementOffset;

	protected void OnDrawGizmosSelected()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = new Color(0.5f, 0.5f, 0.5f, 1f);
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, PlacementRadius);
	}
}


using System;

public interface ICoarseQueryGridProvider : IDisposable
{
	CoarseQueryGrid GetQueryGrid();
}


using System;
using CoarseQueryGridJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[GenerateTestsForBurstCompatibility]
public struct CoarseQueryGrid : IDisposable
{
	public struct RefCountedSpatialArray : IDisposable
	{
		private NativeArray<byte> _array;

		public NativeArray<byte> RawArray => _array;

		public int Length => _array.Length;

		public static RefCountedSpatialArray Init(int length)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			RefCountedSpatialArray result = default(RefCountedSpatialArray);
			result._array = new NativeArray<byte>(length, (Allocator)4, (NativeArrayOptions)1);
			return result;
		}

		public void Add(int index)
		{
			Debug.Assert(_array[index] != byte.MaxValue);
			ref NativeArray<byte> array = ref _array;
			byte b = array[index];
			array[index] = (byte)(b + 1);
		}

		public void Remove(int index)
		{
			Debug.Assert(_array[index] != 0);
			ref NativeArray<byte> array = ref _array;
			byte b = array[index];
			array[index] = (byte)(b - 1);
		}

		public bool Get(int index)
		{
			return _array[index] > 0;
		}

		public void Dispose()
		{
			_array.Dispose();
		}
	}

	private const float StaticBoundsInflation = 0.1f;

	private readonly int _cellXZDimensionCount;

	private readonly Vector2 _gridCentre;

	private readonly float _yCutoff;

	private readonly int _cellSize;

	private readonly int _cellClampLimit;

	private NativeReference<bool> _result;

	private bool _hasDisposed;

	private NativeList<Bounds> _dynamicBounds;

	private RefCountedSpatialArray _upperStaticSpatialArray;

	private RefCountedSpatialArray _lowerStaticSpatialArray;

	public CoarseQueryGrid(int cellSize, int maxWorldSizeXZ, float yCutoff)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		_cellSize = cellSize;
		_cellXZDimensionCount = (int)((float)(maxWorldSizeXZ / cellSize) + 0.5f);
		_gridCentre = new Vector2((float)maxWorldSizeXZ * 0.5f, (float)maxWorldSizeXZ * 0.5f);
		_yCutoff = yCutoff;
		_hasDisposed = false;
		_result = new NativeReference<bool>(AllocatorHandle.op_Implicit((Allocator)4), (NativeArrayOptions)1);
		_upperStaticSpatialArray = RefCountedSpatialArray.Init(_cellXZDimensionCount * _cellXZDimensionCount);
		_lowerStaticSpatialArray = RefCountedSpatialArray.Init(_cellXZDimensionCount * _cellXZDimensionCount);
		_dynamicBounds = new NativeList<Bounds>(AllocatorHandle.op_Implicit((Allocator)4));
		_cellClampLimit = _upperStaticSpatialArray.Length - 1;
	}

	private bool TouchesUpperSpatial(Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref bounds)).max.y >= _yCutoff;
	}

	private bool TouchesUpperSpatial(Vector3 pos, float r)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return pos.y + r >= _yCutoff;
	}

	private bool TouchesLowerSpatial(Bounds bounds)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return ((Bounds)(ref bounds)).min.y <= _yCutoff;
	}

	private bool TouchesLowerSpatial(Vector3 pos, float r)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		return pos.y - r <= _yCutoff;
	}

	public void PrepareForDynamicPopulate(int dynamicCount)
	{
		if (!_hasDisposed)
		{
			_dynamicBounds.Clear();
			if (_dynamicBounds.Capacity < dynamicCount)
			{
				_dynamicBounds.SetCapacity(dynamicCount);
			}
		}
	}

	private bool CheckStateAdd()
	{
		if (_hasDisposed)
		{
			Debug.LogError((object)"Adding bounds to disposed CoarseQueryGrid");
		}
		return _hasDisposed;
	}

	public void AddDynamic(Bounds bounds)
	{
		if (!CheckStateAdd())
		{
			_dynamicBounds.Add(ref bounds);
		}
	}

	public void AddStatic(Bounds bounds)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckStateAdd())
		{
			((Bounds)(ref bounds)).Expand(0.1f);
			Vector2i min = WorldPosToStaticGrid(((Bounds)(ref bounds)).min);
			Vector2i max = WorldPosToStaticGrid(((Bounds)(ref bounds)).max);
			if (TouchesUpperSpatial(bounds))
			{
				AddStatic(min, max, _upperStaticSpatialArray);
			}
			if (TouchesLowerSpatial(bounds))
			{
				AddStatic(min, max, _lowerStaticSpatialArray);
			}
		}
	}

	private void AddStatic(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				spatial.Add(index);
			}
		}
	}

	public void RemoveStatic(Bounds bounds)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (!_hasDisposed)
		{
			((Bounds)(ref bounds)).Expand(0.1f);
			Vector2i min = WorldPosToStaticGrid(((Bounds)(ref bounds)).min);
			Vector2i max = WorldPosToStaticGrid(((Bounds)(ref bounds)).max);
			if (TouchesUpperSpatial(bounds))
			{
				RemoveStatic(min, max, _upperStaticSpatialArray);
			}
			if (TouchesLowerSpatial(bounds))
			{
				RemoveStatic(min, max, _lowerStaticSpatialArray);
			}
		}
	}

	private void RemoveStatic(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				spatial.Remove(index);
			}
		}
	}

	public bool CheckJob(Bounds checkBounds)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		CheckBoundsJob checkBoundsJob = default(CheckBoundsJob);
		checkBoundsJob.Grid = this;
		checkBoundsJob.CheckBounds = checkBounds;
		checkBoundsJob.Result = _result;
		CheckBoundsJob checkBoundsJob2 = checkBoundsJob;
		IJobExtensions.RunByRef<CheckBoundsJob>(ref checkBoundsJob2);
		return _result.Value;
	}

	public bool Check(Bounds checkBounds)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector2i min = WorldPosToStaticGrid(((Bounds)(ref checkBounds)).min);
		Vector2i max = WorldPosToStaticGrid(((Bounds)(ref checkBounds)).max);
		if (TouchesUpperSpatial(checkBounds) && Check(min, max, _upperStaticSpatialArray))
		{
			return true;
		}
		if (TouchesLowerSpatial(checkBounds) && Check(min, max, _lowerStaticSpatialArray))
		{
			return true;
		}
		Enumerator<Bounds> enumerator = _dynamicBounds.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Bounds current = enumerator.Current;
				if (((Bounds)(ref current)).Intersects(checkBounds))
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	private bool Check(Vector2i min, Vector2i max, RefCountedSpatialArray spatial)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		for (int i = min.x; i <= max.x; i++)
		{
			for (int j = min.y; j <= max.y; j++)
			{
				int index = GridToStaticIndex(new Vector2i(i, j));
				if (spatial.Get(index))
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool CheckJob(Vector3 worldPosition, float radius)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		CheckPosRadJob checkPosRadJob = default(CheckPosRadJob);
		checkPosRadJob.Grid = this;
		checkPosRadJob.CheckPos = worldPosition;
		checkPosRadJob.CheckRad = radius;
		checkPosRadJob.Result = _result;
		CheckPosRadJob checkPosRadJob2 = checkPosRadJob;
		IJobExtensions.RunByRef<CheckPosRadJob>(ref checkPosRadJob2);
		return _result.Value;
	}

	public JobHandle CheckJob(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckPosRadBatchJob checkPosRadBatchJob = default(CheckPosRadBatchJob);
		checkPosRadBatchJob.Grid = this;
		checkPosRadBatchJob.Pos = worldPositions;
		checkPosRadBatchJob.Radii = radii;
		checkPosRadBatchJob.OverlapIndices = overlapIndices;
		CheckPosRadBatchJob checkPosRadBatchJob2 = checkPosRadBatchJob;
		return IJobExtensions.ScheduleByRef<CheckPosRadBatchJob>(ref checkPosRadBatchJob2, default(JobHandle));
	}

	public JobHandle CheckJobIndirect(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckPosRadBatchJobIndirect checkPosRadBatchJobIndirect = default(CheckPosRadBatchJobIndirect);
		checkPosRadBatchJobIndirect.Grid = this;
		checkPosRadBatchJobIndirect.Pos = worldPositions;
		checkPosRadBatchJobIndirect.Radii = radii;
		checkPosRadBatchJobIndirect.OverlapIndices = overlapIndices;
		checkPosRadBatchJobIndirect.Indices = indices;
		CheckPosRadBatchJobIndirect checkPosRadBatchJobIndirect2 = checkPosRadBatchJobIndirect;
		return IJobExtensions.ScheduleByRef<CheckPosRadBatchJobIndirect>(ref checkPosRadBatchJobIndirect2, default(JobHandle));
	}

	public bool Check(Vector3 worldPosition, float radius)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector2i min = WorldPosToStaticGrid(worldPosition - Vector3.one * radius);
		Vector2i max = WorldPosToStaticGrid(worldPosition + Vector3.one * radius);
		if (TouchesUpperSpatial(worldPosition, radius) && Check(min, max, _upperStaticSpatialArray))
		{
			return true;
		}
		if (TouchesLowerSpatial(worldPosition, radius) && Check(min, max, _lowerStaticSpatialArray))
		{
			return true;
		}
		float num = radius * radius;
		Enumerator<Bounds> enumerator = _dynamicBounds.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Bounds current = enumerator.Current;
				if (Vector3.SqrMagnitude(((Bounds)(ref current)).ClosestPoint(worldPosition) - worldPosition) <= num)
				{
					return true;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		return false;
	}

	public bool CheckJob(Vector3 start, Vector3 end, float radius)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector3 val = Vector3.one * radius;
		Vector3 val2 = Vector3.Min(start, end) - val;
		Vector3 val3 = Vector3.Max(start, end) + val;
		Bounds checkBounds = default(Bounds);
		((Bounds)(ref checkBounds))..ctor((val3 + val2) * 0.5f, val3 - val2);
		return CheckJob(checkBounds);
	}

	public JobHandle CheckJobIndirect(ReadOnly<Vector3> starts, ReadOnly<Vector3> ends, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> overlapIndices)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			throw new Exception("CoarseQueryGrid already disposed!");
		}
		CheckBoundsJobIndirect checkBoundsJobIndirect = default(CheckBoundsJobIndirect);
		checkBoundsJobIndirect.Grid = this;
		checkBoundsJobIndirect.Starts = starts;
		checkBoundsJobIndirect.Ends = ends;
		checkBoundsJobIndirect.Radii = radii;
		checkBoundsJobIndirect.OverlapIndices = overlapIndices;
		checkBoundsJobIndirect.Indices = indices;
		CheckBoundsJobIndirect checkBoundsJobIndirect2 = checkBoundsJobIndirect;
		return IJobExtensions.ScheduleByRef<CheckBoundsJobIndirect>(ref checkBoundsJobIndirect2, default(JobHandle));
	}

	public bool Check(Vector3 start, Vector3 end, float radius)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		if (_hasDisposed)
		{
			return true;
		}
		Vector3 val = Vector3.one * radius;
		Vector3 val2 = Vector3.Min(start, end) - val;
		Vector3 val3 = Vector3.Max(start, end) + val;
		Bounds checkBounds = default(Bounds);
		((Bounds)(ref checkBounds))..ctor((val3 + val2) * 0.5f, val3 - val2);
		return Check(checkBounds);
	}

	private Vector2i WorldPosToStaticGrid(Vector3 worldPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)((worldPosition.x + _gridCentre.x) / (float)_cellSize), (int)((worldPosition.z + _gridCentre.y) / (float)_cellSize));
	}

	private int GridToStaticIndex(Vector2i gridPosition)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return math.clamp(gridPosition.x + gridPosition.y * _cellXZDimensionCount, 0, _cellClampLimit);
	}

	public void Dispose()
	{
		_hasDisposed = true;
		_result.Dispose();
		_dynamicBounds.Dispose();
		_upperStaticSpatialArray.Dispose();
		_lowerStaticSpatialArray.Dispose();
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public struct RefCountedSpatialArray : IDisposable
{
	private NativeArray<byte> _array;

	public NativeArray<byte> RawArray => _array;

	public int Length => _array.Length;

	public static RefCountedSpatialArray Init(int length)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		RefCountedSpatialArray result = default(RefCountedSpatialArray);
		result._array = new NativeArray<byte>(length, (Allocator)4, (NativeArrayOptions)1);
		return result;
	}

	public void Add(int index)
	{
		Debug.Assert(_array[index] != byte.MaxValue);
		ref NativeArray<byte> array = ref _array;
		byte b = array[index];
		array[index] = (byte)(b + 1);
	}

	public void Remove(int index)
	{
		Debug.Assert(_array[index] != 0);
		ref NativeArray<byte> array = ref _array;
		byte b = array[index];
		array[index] = (byte)(b - 1);
	}

	public bool Get(int index)
	{
		return _array[index] > 0;
	}

	public void Dispose()
	{
		_array.Dispose();
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Terrain Atlas Set")]
public class TerrainAtlasSet : ScriptableObject
{
	public enum SourceType
	{
		ALBEDO,
		NORMAL,
		PACKED,
		COUNT
	}

	[Serializable]
	public class SourceMapSet
	{
		public Texture2D[] maps;

		internal void CheckReset()
		{
			if (maps == null)
			{
				maps = (Texture2D[])(object)new Texture2D[8];
			}
			else if (maps.Length != 8)
			{
				Array.Resize(ref maps, 8);
			}
		}
	}

	public const int SplatCount = 8;

	public const int SplatSize = 2048;

	public const int MaxSplatSize = 2047;

	public const int SplatPadding = 256;

	public const int AtlasSize = 8192;

	public const int RegionSize = 2560;

	public const int SplatsPerLine = 3;

	public const int SourceTypeCount = 3;

	public const int AtlasMipCount = 10;

	public static string[] sourceTypeNames = new string[3] { "Albedo", "Normal", "Packed" };

	public static string[] sourceTypeNamesExt = new string[3] { "Albedo (rgb)", "Normal (rgb)", "Metal[ignored]_Height_AO_Gloss (rgba)" };

	public static string[] sourceTypePostfix = new string[3] { "_albedo", "_normal", "_metal_hm_ao_gloss" };

	public string[] splatNames;

	public bool[] albedoHighpass;

	public string[] albedoPaths;

	public Color[] defaultValues;

	public SourceMapSet[] sourceMaps;

	public bool highQualityCompression = true;

	public bool generateTextureAtlases = true;

	public bool generateTextureArrays;

	public string splatSearchPrefix = "terrain_";

	public string splatSearchFolder = "Assets/Content/Nature/Terrain";

	public string albedoAtlasSavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_albedo_atlas";

	public string normalAtlasSavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_normal_atlas";

	public string albedoArraySavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_albedo_array";

	public string normalArraySavePath = "Assets/Content/Nature/Terrain/Atlas/terrain_normal_array";

	public void CheckReset()
	{
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		if (splatNames == null)
		{
			splatNames = new string[8] { "Dirt", "Snow", "Sand", "Rock", "Grass", "Forest", "Stones", "Gravel" };
		}
		else if (splatNames.Length != 8)
		{
			Array.Resize(ref splatNames, 8);
		}
		if (albedoHighpass == null)
		{
			albedoHighpass = new bool[8];
		}
		else if (albedoHighpass.Length != 8)
		{
			Array.Resize(ref albedoHighpass, 8);
		}
		if (albedoPaths == null)
		{
			albedoPaths = new string[8];
		}
		else if (albedoPaths.Length != 8)
		{
			Array.Resize(ref albedoPaths, 8);
		}
		if (defaultValues == null)
		{
			defaultValues = (Color[])(object)new Color[3]
			{
				new Color(1f, 1f, 1f, 0.5f),
				new Color(0.5f, 0.5f, 1f, 0f),
				new Color(0f, 0f, 1f, 0.5f)
			};
		}
		else if (defaultValues.Length != 3)
		{
			Array.Resize(ref defaultValues, 3);
		}
		if (sourceMaps == null)
		{
			sourceMaps = new SourceMapSet[3];
		}
		else if (sourceMaps.Length != 3)
		{
			Array.Resize(ref sourceMaps, 3);
		}
		for (int i = 0; i < 3; i++)
		{
			sourceMaps[i] = ((sourceMaps[i] != null) ? sourceMaps[i] : new SourceMapSet());
			sourceMaps[i].CheckReset();
		}
	}
}


public enum SourceType
{
	ALBEDO,
	NORMAL,
	PACKED,
	COUNT
}


using System;
using UnityEngine;

[Serializable]
public class SourceMapSet
{
	public Texture2D[] maps;

	internal void CheckReset()
	{
		if (maps == null)
		{
			maps = (Texture2D[])(object)new Texture2D[8];
		}
		else if (maps.Length != 8)
		{
			Array.Resize(ref maps, 8);
		}
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UtilityJobs;

public class TerrainCollision : TerrainExtension
{
	public TerrainIgnoreGrid TerrainIgnoreGrid;

	public ListDictionary<Collider, List<Collider>> ignoredColliders;

	public TerrainCollider terrainCollider;

	public const float IgnoreRadius = 0.01f;

	public override void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		terrainCollider = ((Component)terrain).GetComponent<TerrainCollider>();
		TerrainIgnoreGrid = new TerrainIgnoreGrid();
	}

	private void OnDestroy()
	{
		TerrainIgnoreGrid.Dispose();
	}

	public void Clear()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)terrainCollider))
		{
			return;
		}
		Enumerator<Collider> enumerator = ignoredColliders.Keys.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				Physics.IgnoreCollision(enumerator.Current, (Collider)(object)terrainCollider, false);
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if (Object.op_Implicit((Object)(object)terrainCollider) && Object.op_Implicit((Object)(object)collider))
		{
			Physics.IgnoreCollision(collider, (Collider)(object)terrainCollider, false);
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			if (TerrainIgnoreGrid != null && !TerrainIgnoreGrid.Check(pos, radius))
			{
				return false;
			}
			return GamePhysics.CheckSphere<TerrainCollisionTrigger>(pos, radius, 262144, (QueryTriggerInteraction)2);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetIgnore(ReadOnly<Vector3> positions, ReadOnly<float> radii, NativeArray<bool> results)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			FillJob<bool> fillJob = default(FillJob<bool>);
			fillJob.Values = results;
			fillJob.Value = false;
			FillJob<bool> fillJob2 = fillJob;
			IJobExtensions.RunByRef<FillJob<bool>>(ref fillJob2);
			NativeList<int> val2 = new NativeList<int>(positions.Length, AllocatorHandle.op_Implicit((Allocator)3));
			JobHandle val3;
			if (TerrainIgnoreGrid != null)
			{
				val3 = TerrainIgnoreGrid.Check(positions, radii, val2);
			}
			else
			{
				GenerateAscSeqListJob generateAscSeqListJob = default(GenerateAscSeqListJob);
				generateAscSeqListJob.Values = val2;
				generateAscSeqListJob.Start = 0;
				generateAscSeqListJob.Step = 1;
				generateAscSeqListJob.Count = positions.Length;
				val3 = IJobExtensions.Schedule<GenerateAscSeqListJob>(generateAscSeqListJob, default(JobHandle));
			}
			((JobHandle)(ref val3)).Complete();
			if (!val2.IsEmpty)
			{
				NativeArray<Vector3> results2 = default(NativeArray<Vector3>);
				results2..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<Vector3> gatherJob = default(GatherJob<Vector3>);
				gatherJob.Results = results2;
				gatherJob.Source = positions;
				gatherJob.Indices = val2.AsReadOnly();
				GatherJob<Vector3> gatherJob2 = gatherJob;
				IJobExtensions.RunByRef<GatherJob<Vector3>>(ref gatherJob2);
				NativeArray<float> results3 = default(NativeArray<float>);
				results3..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				GatherJob<float> gatherJob3 = default(GatherJob<float>);
				gatherJob3.Results = results3;
				gatherJob3.Source = radii;
				gatherJob3.Indices = val2.AsReadOnly();
				GatherJob<float> gatherJob4 = gatherJob3;
				IJobExtensions.RunByRef<GatherJob<float>>(ref gatherJob4);
				NativeArray<int> values = default(NativeArray<int>);
				values..ctor(val2.Length, (Allocator)3, (NativeArrayOptions)0);
				FillJob<int> fillJob3 = default(FillJob<int>);
				fillJob3.Values = values;
				fillJob3.Value = 262144;
				FillJob<int> fillJob4 = fillJob3;
				IJobExtensions.RunByRef<FillJob<int>>(ref fillJob4);
				new QueryParameters(262144, false, (QueryTriggerInteraction)2, false);
				GamePhysics.CheckSpheres<TerrainCollisionTrigger>(results2.AsReadOnly(), results3.AsReadOnly(), values.AsReadOnly(), NativeArray<bool>.op_Implicit(ref results), (QueryTriggerInteraction)2, 16, GamePhysics.MasksToValidate.None);
				Span<bool> values2 = NativeArray<bool>.op_Implicit(ref results);
				ReadOnly<int> val4 = val2.AsReadOnly();
				CollectionUtil.ScatterOutInplace(values2, ReadOnly<int>.op_Implicit(ref val4), defValue: false);
				values.Dispose();
				results3.Dispose();
				results2.Dispose();
			}
			val2.Dispose();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(RaycastHit hit)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainCollision.GetIgnore", 0);
		try
		{
			if (!(((RaycastHit)(ref hit)).collider is TerrainCollider))
			{
				return false;
			}
			if (!TerrainIgnoreGrid.Check(((RaycastHit)(ref hit)).point))
			{
				return false;
			}
			return ((RaycastHit)(ref hit)).collider is TerrainCollider && GetIgnore(((RaycastHit)(ref hit)).point);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool GetIgnore(Collider collider)
	{
		if (!Object.op_Implicit((Object)(object)terrainCollider) || !Object.op_Implicit((Object)(object)collider))
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (!Object.op_Implicit((Object)(object)terrainCollider) || !Object.op_Implicit((Object)(object)collider))
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> list = new List<Collider> { trigger };
				Physics.IgnoreCollision(collider, (Collider)(object)terrainCollider, true);
				ignoredColliders.Add(collider, list);
			}
			return;
		}
		List<Collider> list2 = ignoredColliders[collider];
		if (ignore)
		{
			if (!list2.Contains(trigger))
			{
				list2.Add(trigger);
			}
		}
		else if (list2.Contains(trigger))
		{
			list2.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if ((Object)(object)key == (Object)null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				Physics.IgnoreCollision(key, (Collider)(object)terrainCollider, false);
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}


using UnityEngine;

public class TerrainCollisionProxy : MonoBehaviour, IServerComponent
{
	public WheelCollider[] colliders;
}


using Rust;
using UnityEngine;

public class TerrainCollisionTrigger : EnvironmentVolumeTrigger
{
	protected override void OnVolumeTriggerUpdate()
	{
		TerrainMeta.Collision.TerrainIgnoreGrid.AddTrigger(this);
	}

	private void OnDisable()
	{
		if (!Application.isUnloadingWorld)
		{
			TerrainMeta.Collision.TerrainIgnoreGrid.RemoveTrigger(this);
		}
	}

	protected void OnTriggerEnter(Collider other)
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !other.isTrigger)
		{
			UpdateCollider(other, state: true);
		}
	}

	protected void OnTriggerExit(Collider other)
	{
		if (Object.op_Implicit((Object)(object)TerrainMeta.Collision) && !other.isTrigger)
		{
			UpdateCollider(other, state: false);
		}
	}

	private void UpdateCollider(Collider other, bool state)
	{
		TerrainMeta.Collision.SetIgnore(other, base.volume.trigger, state);
		TerrainCollisionProxy component = ((Component)other).GetComponent<TerrainCollisionProxy>();
		if (Object.op_Implicit((Object)(object)component))
		{
			for (int i = 0; i < component.colliders.Length; i++)
			{
				TerrainMeta.Collision.SetIgnore((Collider)(object)component.colliders[i], base.volume.trigger, state);
			}
		}
	}
}


using UnityEngine;

public class TerrainColors : TerrainExtension
{
	private TerrainSplatMap splatMap;

	private TerrainBiomeMap biomeMap;

	public override void Setup()
	{
		splatMap = ((Component)terrain).GetComponent<TerrainSplatMap>();
		biomeMap = ((Component)terrain).GetComponent<TerrainBiomeMap>();
	}

	public Color GetColor(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetColor(normX, normZ, mask);
	}

	public Color GetColor(float normX, float normZ, int mask = -1)
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		float biome = biomeMap.GetBiome(normX, normZ, 1);
		float biome2 = biomeMap.GetBiome(normX, normZ, 2);
		float biome3 = biomeMap.GetBiome(normX, normZ, 4);
		float biome4 = biomeMap.GetBiome(normX, normZ, 8);
		int num = TerrainSplat.TypeToIndex(splatMap.GetSplatMaxType(normX, normZ, mask));
		TerrainConfig.SplatType splatType = config.Splats[num];
		return biome * splatType.AridColor + biome2 * splatType.TemperateColor + biome3 * splatType.TundraColor + biome4 * splatType.ArcticColor;
	}
}


using System;
using Facepunch.Extend;
using UnityEngine;

[RequireComponent(typeof(TerrainMeta))]
public abstract class TerrainExtension : MonoBehaviour
{
	[NonSerialized]
	public bool isInitialized;

	internal Terrain terrain;

	internal TerrainConfig config;

	public void Init(Terrain terrain, TerrainConfig config)
	{
		this.terrain = terrain;
		this.config = config;
	}

	public virtual void Setup()
	{
	}

	public virtual void PostSetup()
	{
	}

	public void LogSize(object obj, ulong size)
	{
		Debug.Log((object)(obj.GetType()?.ToString() + " allocated: " + NumberExtensions.FormatBytes<ulong>(size, false)));
	}
}


using System;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainIgnoreGrid : ICoarseQueryGridProvider, IDisposable
{
	private CoarseQueryGrid _queryGrid;

	private const int CellSize = 8;

	public TerrainIgnoreGrid()
	{
		_queryGrid = new CoarseQueryGrid(8, (int)(World.Size + 1000), -5f);
	}

	public CoarseQueryGrid GetQueryGrid()
	{
		return _queryGrid;
	}

	public void AddTrigger(TerrainCollisionTrigger trigger)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.AddStatic(trigger.volume.trigger.bounds);
	}

	public void RemoveTrigger(TerrainCollisionTrigger trigger)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		_queryGrid.RemoveStatic(trigger.volume.trigger.bounds);
	}

	public bool Check(Vector3 pos, float radius)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerrainIgnoreGrid.Check(pos,rad)", 0);
		try
		{
			return _queryGrid.CheckJob(pos, radius);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public JobHandle Check(ReadOnly<Vector3> starts, ReadOnly<float> radii, NativeList<int> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return _queryGrid.CheckJob(starts, radii, results);
	}

	public JobHandle CheckIndirect(ReadOnly<Vector3> pos, ReadOnly<float> radii, ReadOnly<int> indices, NativeList<int> results)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return _queryGrid.CheckJobIndirect(pos, radii, indices, results);
	}

	public bool Check(Vector3 pos)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("TerraingIgnoreGrid.Check(pos)", 0);
		try
		{
			return _queryGrid.CheckJob(pos, 0f);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Dispose()
	{
		_queryGrid.Dispose();
	}
}


using System;
using UnityEngine;
using UnityEngine.Serialization;

public class TerrainAlphaMap : TerrainMap<byte>
{
	[FormerlySerializedAs("ColorTexture")]
	public Texture2D AlphaTexture;

	private bool _generatedAlphaTexture;

	public override void Setup()
	{
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				dst[i * res + j] = byte.MaxValue;
			}
		}
		if (!((Object)(object)AlphaTexture != (Object)null))
		{
			return;
		}
		if (((Texture)AlphaTexture).width == ((Texture)AlphaTexture).height && ((Texture)AlphaTexture).width == res)
		{
			Color32[] pixels = AlphaTexture.GetPixels32();
			int k = 0;
			int num = 0;
			for (; k < res; k++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					dst[k * res + num2] = pixels[num].a;
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid alpha texture: " + ((Object)AlphaTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedAlphaTexture && (Object)(object)AlphaTexture != (Object)null)
		{
			Object.Destroy((Object)(object)AlphaTexture);
			AlphaTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		AlphaTexture = new Texture2D(res, res, (TextureFormat)1, false, true);
		((Object)AlphaTexture).name = "AlphaTexture";
		((Texture)AlphaTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				byte b = src[z * res + i];
				col[z * res + i] = new Color32(b, b, b, b);
			}
		});
		AlphaTexture.SetPixels32(col);
		_generatedAlphaTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		AlphaTexture.Apply(true, false);
		AlphaTexture.Compress(false);
		AlphaTexture.Apply(false, true);
	}

	public float GetAlpha(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetAlpha(normX, normZ);
	}

	public float GetAlpha(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetAlpha(num4, num5), GetAlpha(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetAlpha(num4, z), GetAlpha(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetAlpha(int x, int z)
	{
		return BitUtility.Byte2Float((int)src[z * res + x]);
	}

	public void SetAlpha(Vector3 worldPos, float a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a);
	}

	public void SetAlpha(float normX, float normZ, float a)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetAlpha(x, z, a);
	}

	public void SetAlpha(int x, int z, float a)
	{
		dst[z * res + x] = BitUtility.Float2Byte(a);
	}

	public void SetAlpha(int x, int z, float a, float opacity)
	{
		SetAlpha(x, z, Mathf.Lerp(GetAlpha(x, z), a, opacity));
	}

	public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a, opacity, radius, fade);
	}

	public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			lerp *= opacity;
			if (lerp > 0f)
			{
				SetAlpha(x, z, a, lerp);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainBiomeMap : TerrainMap<byte>
{
	public Texture2D BiomeTexture;

	private bool _generatedBiomeTexture;

	internal int num;

	public override void Setup()
	{
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		this.num = 5;
		InitArrays(this.num * res * res);
		if (!((Object)(object)BiomeTexture != (Object)null))
		{
			return;
		}
		if (((Texture)BiomeTexture).width == ((Texture)BiomeTexture).height && ((Texture)BiomeTexture).width == res)
		{
			Color32[] pixels = BiomeTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					ref NativeArray<byte> reference = ref dst;
					_ = res;
					reference[(0 + i) * res + num2] = val.r;
					dst[(res + i) * res + num2] = val.g;
					dst[(2 * res + i) * res + num2] = val.b;
					dst[(3 * res + i) * res + num2] = val.a;
					dst[(4 * res + i) * res + num2] = (byte)(255 - val.r - val.g - val.b - val.a);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid biome texture: " + ((Object)BiomeTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedBiomeTexture && (Object)(object)BiomeTexture != (Object)null)
		{
			Object.Destroy((Object)(object)BiomeTexture);
			BiomeTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		BiomeTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)BiomeTexture).name = "BiomeTexture";
		((Texture)BiomeTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				ref NativeArray<byte> reference = ref src;
				_ = res;
				byte b = reference[(0 + z) * res + i];
				byte b2 = src[(res + z) * res + i];
				byte b3 = src[(2 * res + z) * res + i];
				byte b4 = src[(3 * res + z) * res + i];
				col[z * res + i] = new Color32(b, b2, b3, b4);
			}
		});
		BiomeTexture.SetPixels32(col);
		_generatedBiomeTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		BiomeTexture.Apply(true, false);
		BiomeTexture.Compress(false);
		BiomeTexture.Apply(false, true);
	}

	public float GetBiomeMax(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMax(normX, normZ, mask);
	}

	public float GetBiomeMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMax(x, z, mask);
	}

	public float GetBiomeMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return (int)b;
	}

	public int GetBiomeMaxIndex(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiomeMaxIndex(normX, normZ, mask);
	}

	public int GetBiomeMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiomeMaxIndex(x, z, mask);
	}

	public int GetBiomeMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetBiomeMaxType(Vector3 worldPos, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(worldPos, mask));
	}

	public int GetBiomeMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(normX, normZ, mask));
	}

	public int GetBiomeMaxType(int x, int z, int mask = -1)
	{
		return TerrainBiome.IndexToType(GetBiomeMaxIndex(x, z, mask));
	}

	public float GetBiome(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBiome(normX, normZ, mask);
	}

	public float GetBiome(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBiome(x, z, mask);
	}

	public float GetBiome(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(TerrainBiome.TypeToIndex(mask) * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			if ((TerrainBiome.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	public void SetBiome(Vector3 worldPos, int id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id);
	}

	public void SetBiome(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id);
	}

	public void SetBiome(int x, int z, int id)
	{
		int num = TerrainBiome.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = byte.MaxValue;
			}
			else
			{
				dst[(i * res + z) * res + x] = 0;
			}
		}
	}

	public void SetBiome(Vector3 worldPos, int id, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBiome(normX, normZ, id, v);
	}

	public void SetBiome(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBiome(x, z, id, v);
	}

	public void SetBiome(int x, int z, int id, float v)
	{
		SetBiome(x, z, id, GetBiome(x, z, id), v);
	}

	public void SetBiomeRaw(int x, int z, float biome0, float biome1, float biome2, float biome3, float biome4, float opacity)
	{
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(biome0 + biome1 + biome2 + biome3 + biome4);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				ref NativeArray<byte> reference = ref dst;
				_ = res;
				reference[(0 + z) * res + x] = BitUtility.Float2Byte(biome0);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(biome1);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(biome2);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(biome3);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(biome4);
			}
			else
			{
				ref NativeArray<byte> reference2 = ref dst;
				_ = res;
				int num3 = (0 + z) * res + x;
				ref NativeArray<byte> reference3 = ref src;
				_ = res;
				reference2[num3] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)reference3[(0 + z) * res + x]) * num2 + biome0 * opacity);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(res + z) * res + x]) * num2 + biome1 * opacity);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(2 * res + z) * res + x]) * num2 + biome2 * opacity);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(3 * res + z) * res + x]) * num2 + biome3 * opacity);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(4 * res + z) * res + x]) * num2 + biome4 * opacity);
			}
		}
	}

	private void SetBiome(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainBiome.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(new_val);
			}
			else
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(num2 * BitUtility.Byte2Float((int)dst[(i * res + z) * res + x]));
			}
		}
	}
}


using System;
using UnityEngine;

public class TerrainBlendMap : TerrainMap<byte>
{
	public Texture2D BlendTexture;

	public override void Setup()
	{
		if ((Object)(object)BlendTexture != (Object)null)
		{
			if (((Texture)BlendTexture).width == ((Texture)BlendTexture).height)
			{
				res = ((Texture)BlendTexture).width;
				InitArrays(res * res);
				Color32[] pixels = BlendTexture.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						dst[i * res + num2] = pixels[num].a;
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError((object)("Invalid alpha texture: " + ((Object)BlendTexture).name));
			}
			return;
		}
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		for (int j = 0; j < res; j++)
		{
			for (int k = 0; k < res; k++)
			{
				dst[j * res + k] = 0;
			}
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		BlendTexture = new Texture2D(res, res, (TextureFormat)1, true, true);
		((Object)BlendTexture).name = "BlendTexture";
		((Texture)BlendTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				byte b = src[z * res + i];
				col[z * res + i] = new Color32(b, b, b, b);
			}
		});
		BlendTexture.SetPixels32(col);
	}

	public void ApplyTextures()
	{
		BlendTexture.Apply(true, false);
		BlendTexture.Compress(false);
		BlendTexture.Apply(false, true);
	}

	public float GetAlpha(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetAlpha(normX, normZ);
	}

	public float GetAlpha(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetAlpha(num4, num5), GetAlpha(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetAlpha(num4, z), GetAlpha(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetAlpha(int x, int z)
	{
		return BitUtility.Byte2Float((int)src[z * res + x]);
	}

	public void SetAlpha(Vector3 worldPos, float a)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a);
	}

	public void SetAlpha(float normX, float normZ, float a)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetAlpha(x, z, a);
	}

	public void SetAlpha(int x, int z, float a)
	{
		dst[z * res + x] = BitUtility.Float2Byte(a);
	}

	public void SetAlpha(int x, int z, float a, float opacity)
	{
		SetAlpha(x, z, Mathf.Lerp(GetAlpha(x, z), a, opacity));
	}

	public void SetAlpha(Vector3 worldPos, float a, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetAlpha(normX, normZ, a, opacity, radius, fade);
	}

	public void SetAlpha(float normX, float normZ, float a, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			lerp *= opacity;
			if (lerp > 0f)
			{
				SetAlpha(x, z, a, lerp);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainDistanceMap : TerrainMap<byte>
{
	public Texture2D DistanceTexture;

	public override void Setup()
	{
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(4 * res * res);
		if (!((Object)(object)DistanceTexture != (Object)null))
		{
			return;
		}
		if (((Texture)DistanceTexture).width == ((Texture)DistanceTexture).height && ((Texture)DistanceTexture).width == res)
		{
			Color32[] pixels = DistanceTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					SetDistance(num2, i, BitUtility.DecodeVector2i(pixels[num]));
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid distance texture: " + ((Object)DistanceTexture).name), (Object)(object)DistanceTexture);
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		DistanceTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)DistanceTexture).name = "DistanceTexture";
		((Texture)DistanceTexture).wrapMode = (TextureWrapMode)1;
		Color32[] cols = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				cols[z * res + i] = BitUtility.EncodeVector2i(GetDistance(i, z));
			}
		});
		DistanceTexture.SetPixels32(cols);
	}

	public void ApplyTextures()
	{
		DistanceTexture.Apply(true, true);
	}

	public Vector2i GetDistance(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetDistance(normX, normZ);
	}

	public Vector2i GetDistance(float normX, float normZ)
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x = Mathf.Clamp(Mathf.RoundToInt(normX * (float)num), 0, num);
		int z = Mathf.Clamp(Mathf.RoundToInt(normZ * (float)num), 0, num);
		return GetDistance(x, z);
	}

	public Vector2i GetDistance(int x, int z)
	{
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<byte> reference = ref src;
		_ = res;
		byte b = reference[(0 + z) * res + x];
		byte b2 = src[(res + z) * res + x];
		byte b3 = src[(2 * res + z) * res + x];
		byte b4 = src[(3 * res + z) * res + x];
		if (b == byte.MaxValue && b2 == byte.MaxValue && b3 == byte.MaxValue && b4 == byte.MaxValue)
		{
			return new Vector2i(256, 256);
		}
		return new Vector2i(b - b2, b3 - b4);
	}

	public void SetDistance(int x, int z, Vector2i v)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		ref NativeArray<byte> reference = ref dst;
		_ = res;
		reference[(0 + z) * res + x] = (byte)Mathf.Clamp(v.x, 0, 255);
		dst[(res + z) * res + x] = (byte)Mathf.Clamp(-v.x, 0, 255);
		dst[(2 * res + z) * res + x] = (byte)Mathf.Clamp(v.y, 0, 255);
		dst[(3 * res + z) * res + x] = (byte)Mathf.Clamp(-v.y, 0, 255);
	}
}


using System;
using TerrainHeightMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainHeightMap : TerrainMap<short>
{
	public struct HeightMapQueryStructure
	{
		public ReadOnly<short> Data;

		public int Res;

		public Vector3 TerrainPosition;

		public Vector3 TerrainSize;

		public Vector3 TerrainOneOverSize;

		public float GetHeightFast(Vector2 uv)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			int num = Res - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? Res : 0);
			int num10 = num5 * Res + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = (float)Data[num10] * 3.051944E-05f;
			float num15 = (float)Data[num11] * 3.051944E-05f;
			float num16 = (float)Data[num12] * 3.051944E-05f;
			float num17 = (float)Data[num13] * 3.051944E-05f;
			float num18 = (num15 - num14) * num6 + num14;
			float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
			return TerrainPosition.y + num19 * TerrainSize.y;
		}
	}

	public Texture2D HeightTexture;

	public Texture2D NormalTexture;

	public float normY;

	private bool _generatedHeightTexture;

	private bool _generatedNormalTexture;

	public override void Setup()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
		if (!((Object)(object)HeightTexture != (Object)null))
		{
			return;
		}
		if (((Texture)HeightTexture).width == ((Texture)HeightTexture).height && ((Texture)HeightTexture).width == res)
		{
			Color32[] pixels = HeightTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					dst[i * res + num2] = BitUtility.DecodeShort(val);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid height texture: " + ((Object)HeightTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedHeightTexture && (Object)(object)HeightTexture != (Object)null)
		{
			Object.Destroy((Object)(object)HeightTexture);
			HeightTexture = null;
		}
		if (_generatedNormalTexture && (Object)(object)NormalTexture != (Object)null)
		{
			Object.Destroy((Object)(object)NormalTexture);
			NormalTexture = null;
		}
	}

	public void ApplyToTerrain()
	{
		float[,] heights = terrain.terrainData.GetHeights(0, 0, res, res);
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				heights[z, i] = GetHeight01(i, z);
			}
		});
		terrain.terrainData.SetHeights(0, 0, heights);
		TerrainCollider component = ((Component)terrain).GetComponent<TerrainCollider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			((Collider)component).enabled = false;
			((Collider)component).enabled = true;
		}
	}

	public void GenerateTextures(bool heightTexture = true, bool normalTexture = true)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Expected O, but got Unknown
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Expected O, but got Unknown
		if (heightTexture)
		{
			Color32[] heights = (Color32[])(object)new Color32[res * res];
			Parallel.For(0, res, (Action<int>)delegate(int z)
			{
				//IL_0038: Unknown result type (might be due to invalid IL or missing references)
				//IL_003d: Unknown result type (might be due to invalid IL or missing references)
				for (int i = 0; i < res; i++)
				{
					heights[z * res + i] = BitUtility.EncodeShort(src[z * res + i]);
				}
			});
			HeightTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
			((Object)HeightTexture).name = "HeightTexture";
			((Texture)HeightTexture).wrapMode = (TextureWrapMode)1;
			HeightTexture.SetPixels32(heights);
			HeightTexture.ignoreMipmapLimit = true;
			_generatedHeightTexture = Application.isPlaying;
		}
		if (!normalTexture)
		{
			return;
		}
		int normalres = (res - 1) / 2;
		Color32[] normals = (Color32[])(object)new Color32[normalres * normalres];
		Parallel.For(0, normalres, (Action<int>)delegate(int z)
		{
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_0054: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0061: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			float normZ = ((float)z + 0.5f) / (float)normalres;
			for (int j = 0; j < normalres; j++)
			{
				float normX = ((float)j + 0.5f) / (float)normalres;
				Vector3 normal = GetNormal(normX, normZ);
				float num = Vector3.Angle(Vector3.up, normal);
				float num2 = Mathf.InverseLerp(50f, 70f, num);
				normal = Vector3.Slerp(normal, Vector3.up, num2);
				normals[z * normalres + j] = Color32.op_Implicit(BitUtility.EncodeNormal(normal));
			}
		});
		NormalTexture = new Texture2D(normalres, normalres, (TextureFormat)4, false, true);
		((Object)NormalTexture).name = "NormalTexture";
		((Texture)NormalTexture).wrapMode = (TextureWrapMode)1;
		NormalTexture.SetPixels32(normals);
		_generatedNormalTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		HeightTexture.Apply(true, false);
		NormalTexture.Apply(true, false);
		NormalTexture.Compress(false);
		HeightTexture.Apply(false, true);
		NormalTexture.Apply(false, true);
	}

	public float GetHeight(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(worldPos) * TerrainMeta.Size.y;
	}

	public void GetHeights(NativeArray<Vector3> worldPos, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsJob getHeightsJob = default(GetHeightsJob);
		getHeightsJob.Heights = results;
		getHeightsJob.Pos = worldPos;
		getHeightsJob.Data = src;
		getHeightsJob.Res = res;
		getHeightsJob.TerrainPos = TerrainMeta.Position;
		getHeightsJob.TerrainScale = TerrainMeta.Size.y;
		getHeightsJob.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
		GetHeightsJob getHeightsJob2 = getHeightsJob;
		IJobExtensions.RunByRef<GetHeightsJob>(ref getHeightsJob2);
	}

	public void GetHeightsIndirect(ReadOnly<Vector3> worldPos, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsJobIndirect getHeightsJobIndirect = default(GetHeightsJobIndirect);
		getHeightsJobIndirect.Heights = results;
		getHeightsJobIndirect.Pos = worldPos;
		getHeightsJobIndirect.Data = src.AsReadOnly();
		getHeightsJobIndirect.Res = res;
		getHeightsJobIndirect.TerrainPos = TerrainMeta.Position;
		getHeightsJobIndirect.TerrainScale = TerrainMeta.Size.y;
		getHeightsJobIndirect.TerrainOneOverSize = Vector3Ex.XZ2D(TerrainMeta.OneOverSize);
		getHeightsJobIndirect.Indices = indices;
		GetHeightsJobIndirect getHeightsJobIndirect2 = getHeightsJobIndirect;
		IJobExtensions.RunByRef<GetHeightsJobIndirect>(ref getHeightsJobIndirect2);
	}

	public float GetHeight(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public HeightMapQueryStructure GetQueryStructure()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		HeightMapQueryStructure result = default(HeightMapQueryStructure);
		result.Data = src.AsReadOnly();
		result.Res = res;
		result.TerrainPosition = TerrainMeta.Position;
		result.TerrainSize = TerrainMeta.Size;
		result.TerrainOneOverSize = TerrainMeta.OneOverSize;
		return result;
	}

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainMeta.Position.y + num19 * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public void GetHeightsFastIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		GetHeightsFastJobIndirect getHeightsFastJobIndirect = default(GetHeightsFastJobIndirect);
		getHeightsFastJobIndirect.Heights = results;
		getHeightsFastJobIndirect.UVs = uvs;
		getHeightsFastJobIndirect.Indices = indices;
		getHeightsFastJobIndirect.Data = src.AsReadOnly();
		getHeightsFastJobIndirect.Res = res;
		getHeightsFastJobIndirect.TerrainPos = TerrainMeta.Position.y;
		getHeightsFastJobIndirect.TerrainScale = TerrainMeta.Size.y;
		GetHeightsFastJobIndirect getHeightsFastJobIndirect2 = getHeightsFastJobIndirect;
		IJobExtensions.RunByRef<GetHeightsFastJobIndirect>(ref getHeightsFastJobIndirect2);
	}

	public float GetHeight01(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetHeight01(normX, normZ);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float height = GetHeight01(num4, num5);
		float height2 = GetHeight01(x, num5);
		float height3 = GetHeight01(num4, z);
		float height4 = GetHeight01(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		float num8 = Mathf.Lerp(height, height2, num6);
		float num9 = Mathf.Lerp(height3, height4, num6);
		return Mathf.Lerp(num8, num9, num7);
	}

	public float GetTriangulatedHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		float height = GetHeight01(num4, num5);
		float height2 = GetHeight01(x, z);
		if (num6 > num7)
		{
			float height3 = GetHeight01(x, num5);
			return height + (height3 - height) * num6 + (height2 - height3) * num7;
		}
		float height4 = GetHeight01(num4, z);
		return height + (height2 - height4) * num6 + (height4 - height) * num7;
	}

	public float GetHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	private float GetSrcHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	private float GetDstHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)dst[z * res + x]);
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		Vector3 normal = GetNormal(num4, num5);
		Vector3 normal2 = GetNormal(x, num5);
		Vector3 normal3 = GetNormal(num4, z);
		Vector3 normal4 = GetNormal(x, z);
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		Vector3 val = Vector3.Slerp(normal, normal2, num6);
		Vector3 val2 = Vector3.Slerp(normal3, normal4, num6);
		Vector3 val3 = Vector3.Slerp(val, val2, num7);
		return ((Vector3)(ref val3)).normalized;
	}

	public Vector3 GetNormal(int x, int z)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = (GetHeight01(x3, z2) - GetHeight01(x2, z2)) * 0.5f;
		float num3 = (GetHeight01(x2, z3) - GetHeight01(x2, z2)) * 0.5f;
		Vector3 val = new Vector3(0f - num2, normY, 0f - num3);
		return ((Vector3)(ref val)).normalized;
	}

	private Vector3 GetNormalSobel(int x, int z)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(TerrainMeta.Size.x / (float)num, TerrainMeta.Size.y, TerrainMeta.Size.z / (float)num);
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = GetHeight01(x2, z2) * -1f;
		num2 += GetHeight01(x2, z) * -2f;
		num2 += GetHeight01(x2, z3) * -1f;
		num2 += GetHeight01(x3, z2) * 1f;
		num2 += GetHeight01(x3, z) * 2f;
		num2 += GetHeight01(x3, z3) * 1f;
		num2 *= val.y;
		num2 /= val.x;
		float num3 = GetHeight01(x2, z2) * -1f;
		num3 += GetHeight01(x, z2) * -2f;
		num3 += GetHeight01(x3, z2) * -1f;
		num3 += GetHeight01(x2, z3) * 1f;
		num3 += GetHeight01(x, z3) * 2f;
		num3 += GetHeight01(x3, z3) * 1f;
		num3 *= val.y;
		num3 /= val.z;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(0f - num2, 8f, 0f - num3);
		return ((Vector3)(ref val2)).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z * res + x] = BitUtility.Float2Short(height);
	}

	public void SetHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height, opacity);
	}

	public void SetHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height, opacity);
	}

	public void SetHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity);
		SetHeight(x, z, height2);
	}

	public void AddHeight(Vector3 worldPos, float delta)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddHeight(normX, normZ, delta);
	}

	public void AddHeight(float normX, float normZ, float delta)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddHeight(x, z, delta);
	}

	public void AddHeight(int x, int z, float delta)
	{
		float height = Mathf.Clamp01(GetDstHeight01(x, z) + delta);
		SetHeight(x, z, height);
	}

	public void LowerHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		LowerHeight(normX, normZ, height, opacity);
	}

	public void LowerHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		LowerHeight(x, z, height, opacity);
	}

	public void LowerHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.Min(GetDstHeight01(x, z), Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity));
		SetHeight(x, z, height2);
	}

	public void RaiseHeight(Vector3 worldPos, float height, float opacity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RaiseHeight(normX, normZ, height, opacity);
	}

	public void RaiseHeight(float normX, float normZ, float height, float opacity)
	{
		int x = Index(normX);
		int z = Index(normZ);
		RaiseHeight(x, z, height, opacity);
	}

	public void RaiseHeight(int x, int z, float height, float opacity)
	{
		float height2 = Mathf.Max(GetDstHeight01(x, z), Mathf.SmoothStep(GetSrcHeight01(x, z), height, opacity));
		SetHeight(x, z, height2);
	}

	public void SetHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		SetHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void SetHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				SetHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void LowerHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		LowerHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void LowerHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				LowerHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void RaiseHeight(Vector3 worldPos, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		float height = TerrainMeta.NormalizeY(worldPos.y);
		RaiseHeight(normX, normZ, height, opacity, radius, fade);
	}

	public void RaiseHeight(float normX, float normZ, float height, float opacity, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				RaiseHeight(x, z, height, lerp * opacity);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddHeight(Vector3 worldPos, float delta, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddHeight(normX, normZ, delta, radius, fade);
	}

	public void AddHeight(float normX, float normZ, float delta, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				AddHeight(x, z, lerp * delta);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using Unity.Collections;
using UnityEngine;

public struct HeightMapQueryStructure
{
	public ReadOnly<short> Data;

	public int Res;

	public Vector3 TerrainPosition;

	public Vector3 TerrainSize;

	public Vector3 TerrainOneOverSize;

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		int num = Res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? Res : 0);
		int num10 = num5 * Res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)Data[num10] * 3.051944E-05f;
		float num15 = (float)Data[num11] * 3.051944E-05f;
		float num16 = (float)Data[num12] * 3.051944E-05f;
		float num17 = (float)Data[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainPosition.y + num19 * TerrainSize.y;
	}
}


using System;
using UnityEngine;

public abstract class TerrainMap : TerrainExtension
{
	internal int res;

	public void ApplyFilter(float normX, float normZ, float radius, float fade, Action<int, int, float> action)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		float num2 = TerrainMeta.OneOverSize.x * fade;
		float num3 = (float)res * (num - num2);
		float num4 = (float)res * num;
		float num5 = normX * (float)res;
		float num6 = normZ * (float)res;
		int num7 = Index(normX - num);
		int num8 = Index(normX + num);
		int num9 = Index(normZ - num);
		int num10 = Index(normZ + num);
		Vector2 val;
		if (num3 != num4)
		{
			for (int i = num9; i <= num10; i++)
			{
				for (int j = num7; j <= num8; j++)
				{
					val = new Vector2((float)j + 0.5f - num5, (float)i + 0.5f - num6);
					float magnitude = ((Vector2)(ref val)).magnitude;
					float arg = Mathf.InverseLerp(num4, num3, magnitude);
					action(j, i, arg);
				}
			}
			return;
		}
		for (int k = num9; k <= num10; k++)
		{
			for (int l = num7; l <= num8; l++)
			{
				val = new Vector2((float)l + 0.5f - num5, (float)k + 0.5f - num6);
				float arg2 = ((((Vector2)(ref val)).magnitude < num4) ? 1 : 0);
				action(l, k, arg2);
			}
		}
	}

	public void ForEach(Vector3 worldPos, float radius, Action<int, int> action)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(TerrainMeta.NormalizeX(worldPos.x - radius));
		int num2 = Index(TerrainMeta.NormalizeX(worldPos.x + radius));
		int num3 = Index(TerrainMeta.NormalizeZ(worldPos.z - radius));
		int num4 = Index(TerrainMeta.NormalizeZ(worldPos.z + radius));
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num; j <= num2; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEach(float normX, float normZ, float normRadius, Action<int, int> action)
	{
		int num = Index(normX - normRadius);
		int num2 = Index(normX + normRadius);
		int num3 = Index(normZ - normRadius);
		int num4 = Index(normZ + normRadius);
		for (int i = num3; i <= num4; i++)
		{
			for (int j = num; j <= num2; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v3 = default(Vector2i);
		((Vector2i)(ref v3))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		ForEachParallel(v3, v4, v5, action);
	}

	public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathx.Min(v0.x, v1.x, v2.x);
		int num2 = Mathx.Max(v0.x, v1.x, v2.x);
		int num3 = Mathx.Min(v0.y, v1.y, v2.y);
		int num4 = Mathx.Max(v0.y, v1.y, v2.y);
		Vector2i base_min = new Vector2i(num, num3);
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num2, num4);
		Vector2i base_count = val - base_min + Vector2i.one;
		Parallel.Call((Action<int, int>)delegate(int thread_id, int thread_count)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			Vector2i min = base_min + base_count * thread_id / thread_count;
			Vector2i max = base_min + base_count * (thread_id + 1) / thread_count - Vector2i.one;
			ForEachInternal(v0, v1, v2, action, min, max);
		});
	}

	public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v3 = default(Vector2i);
		((Vector2i)(ref v3))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		ForEach(v3, v4, v5, action);
	}

	public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		Vector2i min = default(Vector2i);
		((Vector2i)(ref min))..ctor(int.MinValue, int.MinValue);
		Vector2i max = default(Vector2i);
		((Vector2i)(ref max))..ctor(int.MaxValue, int.MaxValue);
		ForEachInternal(v0, v1, v2, action, min, max);
	}

	private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Action<int, int> action, Vector2i min, Vector2i max)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.Max(min.x, Mathx.Min(v0.x, v1.x, v2.x));
		int num2 = Mathf.Min(max.x, Mathx.Max(v0.x, v1.x, v2.x));
		int num3 = Mathf.Max(min.y, Mathx.Min(v0.y, v1.y, v2.y));
		int num4 = Mathf.Min(max.y, Mathx.Max(v0.y, v1.y, v2.y));
		int num5 = v0.y - v1.y;
		int num6 = v1.x - v0.x;
		int num7 = v1.y - v2.y;
		int num8 = v2.x - v1.x;
		int num9 = v2.y - v0.y;
		int num10 = v0.x - v2.x;
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num, num3);
		int num11 = (v2.x - v1.x) * (val.y - v1.y) - (v2.y - v1.y) * (val.x - v1.x);
		int num12 = (v0.x - v2.x) * (val.y - v2.y) - (v0.y - v2.y) * (val.x - v2.x);
		int num13 = (v1.x - v0.x) * (val.y - v0.y) - (v1.y - v0.y) * (val.x - v0.x);
		val.y = num3;
		while (val.y <= num4)
		{
			int num14 = num11;
			int num15 = num12;
			int num16 = num13;
			val.x = num;
			while (val.x <= num2)
			{
				if ((num14 | num15 | num16) >= 0)
				{
					action(val.x, val.y);
				}
				num14 += num7;
				num15 += num9;
				num16 += num5;
				val.x++;
			}
			num11 += num8;
			num12 += num10;
			num13 += num6;
			val.y++;
		}
	}

	public void ForEachParallel(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v6 = default(Vector2i);
		((Vector2i)(ref v6))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		Vector2i v7 = default(Vector2i);
		((Vector2i)(ref v7))..ctor(Index(TerrainMeta.NormalizeX(v3.x)), Index(TerrainMeta.NormalizeZ(v3.z)));
		ForEachParallel(v4, v5, v6, v7, action);
	}

	public void ForEachParallel(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathx.Min(v0.x, v1.x, v2.x, v3.x);
		int num2 = Mathx.Max(v0.x, v1.x, v2.x, v3.x);
		int num3 = Mathx.Min(v0.y, v1.y, v2.y, v3.y);
		int num4 = Mathx.Max(v0.y, v1.y, v2.y, v3.y);
		Vector2i base_min = new Vector2i(num, num3);
		Vector2i val = new Vector2i(num2, num4) - base_min + Vector2i.one;
		Vector2i size_x = new Vector2i(val.x, 0);
		Vector2i size_y = new Vector2i(0, val.y);
		Parallel.Call((Action<int, int>)delegate(int thread_id, int thread_count)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_002d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			Vector2i min = base_min + size_y * thread_id / thread_count;
			Vector2i max = base_min + size_y * (thread_id + 1) / thread_count + size_x - Vector2i.one;
			ForEachInternal(v0, v1, v2, v3, action, min, max);
		});
	}

	public void ForEach(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 v3, Action<int, int> action)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		Vector2i v4 = default(Vector2i);
		((Vector2i)(ref v4))..ctor(Index(TerrainMeta.NormalizeX(v0.x)), Index(TerrainMeta.NormalizeZ(v0.z)));
		Vector2i v5 = default(Vector2i);
		((Vector2i)(ref v5))..ctor(Index(TerrainMeta.NormalizeX(v1.x)), Index(TerrainMeta.NormalizeZ(v1.z)));
		Vector2i v6 = default(Vector2i);
		((Vector2i)(ref v6))..ctor(Index(TerrainMeta.NormalizeX(v2.x)), Index(TerrainMeta.NormalizeZ(v2.z)));
		Vector2i v7 = default(Vector2i);
		((Vector2i)(ref v7))..ctor(Index(TerrainMeta.NormalizeX(v3.x)), Index(TerrainMeta.NormalizeZ(v3.z)));
		ForEach(v4, v5, v6, v7, action);
	}

	public void ForEach(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		Vector2i min = default(Vector2i);
		((Vector2i)(ref min))..ctor(int.MinValue, int.MinValue);
		Vector2i max = default(Vector2i);
		((Vector2i)(ref max))..ctor(int.MaxValue, int.MaxValue);
		ForEachInternal(v0, v1, v2, v3, action, min, max);
	}

	private void ForEachInternal(Vector2i v0, Vector2i v1, Vector2i v2, Vector2i v3, Action<int, int> action, Vector2i min, Vector2i max)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0196: Unknown result type (might be due to invalid IL or missing references)
		//IL_019d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_021e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0240: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0296: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0365: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0323: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.Max(min.x, Mathx.Min(v0.x, v1.x, v2.x, v3.x));
		int num2 = Mathf.Min(max.x, Mathx.Max(v0.x, v1.x, v2.x, v3.x));
		int num3 = Mathf.Max(min.y, Mathx.Min(v0.y, v1.y, v2.y, v3.y));
		int num4 = Mathf.Min(max.y, Mathx.Max(v0.y, v1.y, v2.y, v3.y));
		int num5 = v0.y - v1.y;
		int num6 = v1.x - v0.x;
		int num7 = v1.y - v2.y;
		int num8 = v2.x - v1.x;
		int num9 = v2.y - v0.y;
		int num10 = v0.x - v2.x;
		int num11 = v3.y - v2.y;
		int num12 = v2.x - v3.x;
		int num13 = v2.y - v1.y;
		int num14 = v1.x - v2.x;
		int num15 = v1.y - v3.y;
		int num16 = v3.x - v1.x;
		Vector2i val = default(Vector2i);
		((Vector2i)(ref val))..ctor(num, num3);
		int num17 = (v2.x - v1.x) * (val.y - v1.y) - (v2.y - v1.y) * (val.x - v1.x);
		int num18 = (v0.x - v2.x) * (val.y - v2.y) - (v0.y - v2.y) * (val.x - v2.x);
		int num19 = (v1.x - v0.x) * (val.y - v0.y) - (v1.y - v0.y) * (val.x - v0.x);
		int num20 = (v1.x - v2.x) * (val.y - v2.y) - (v1.y - v2.y) * (val.x - v2.x);
		int num21 = (v3.x - v1.x) * (val.y - v1.y) - (v3.y - v1.y) * (val.x - v1.x);
		int num22 = (v2.x - v3.x) * (val.y - v3.y) - (v2.y - v3.y) * (val.x - v3.x);
		val.y = num3;
		while (val.y <= num4)
		{
			int num23 = num17;
			int num24 = num18;
			int num25 = num19;
			int num26 = num20;
			int num27 = num21;
			int num28 = num22;
			val.x = num;
			while (val.x <= num2)
			{
				if ((num23 | num24 | num25) >= 0 || (num26 | num27 | num28) >= 0)
				{
					action(val.x, val.y);
				}
				num23 += num7;
				num24 += num9;
				num25 += num5;
				num26 += num13;
				num27 += num15;
				num28 += num11;
				val.x++;
			}
			num17 += num8;
			num18 += num10;
			num19 += num6;
			num20 += num14;
			num21 += num16;
			num22 += num12;
			val.y++;
		}
	}

	public void ForEach(int x_min, int x_max, int z_min, int z_max, Action<int, int> action)
	{
		for (int i = z_min; i <= z_max; i++)
		{
			for (int j = x_min; j <= x_max; j++)
			{
				action(j, i);
			}
		}
	}

	public void ForEach(Action<int, int> action)
	{
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				action(j, i);
			}
		}
	}

	public int Index(float normalized)
	{
		int num = (int)(normalized * (float)res);
		if (num >= 0)
		{
			if (num <= res - 1)
			{
				return num;
			}
			return res - 1;
		}
		return 0;
	}

	public float Coordinate(int index)
	{
		return ((float)index + 0.5f) / (float)res;
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public abstract class TerrainMap<T> : TerrainMap, IDisposable where T : unmanaged
{
	internal NativeArray<T> src;

	internal NativeArray<T> dst;

	public void InitArrays(int size)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		src = (dst = new NativeArray<T>(size, (Allocator)4, (NativeArrayOptions)1));
	}

	public void Push()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		if (!(src != dst))
		{
			Debug.Assert(src == dst);
			dst = new NativeArray<T>(src, (Allocator)4);
		}
	}

	public void Pop()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (!(src == dst))
		{
			Debug.Assert(src.IsCreated);
			Debug.Assert(dst.IsCreated);
			src.CopyFrom(dst);
			Debug.Assert(src != dst);
			dst.Dispose();
			dst = src;
		}
	}

	public IEnumerable<T> ToEnumerable()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerable<T>)(object)src;
	}

	public int BytesPerElement()
	{
		return UnsafeUtility.SizeOf<T>();
	}

	public long GetMemoryUsage()
	{
		return (long)BytesPerElement() * (long)src.Length;
	}

	public byte[] ToByteArray()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return src.Reinterpret<byte>(UnsafeUtility.SizeOf<T>()).ToArray();
	}

	public void FromByteArray(byte[] dat)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if (dat == null)
		{
			throw new ArgumentNullException("dat");
		}
		if (!dst.IsCreated)
		{
			throw new InvalidOperationException("Destination NativeArray is not created");
		}
		int num = UnsafeUtility.SizeOf<T>();
		NativeSlice<byte> val = default(NativeSlice<byte>);
		val..ctor(dst.Reinterpret<byte>(num), 0, dat.Length);
		val.CopyFrom(dat);
	}

	public void OnDestroy()
	{
		Dispose();
	}

	public virtual void Dispose()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (src != dst)
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
			if (dst.IsCreated)
			{
				dst.Dispose();
			}
		}
		else if (src.IsCreated)
		{
			src.Dispose();
		}
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainPlacementMap : TerrainMap<bool>
{
	private bool isEnabled;

	public override void Setup()
	{
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		Enable();
	}

	public override void PostSetup()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		res = 0;
		if (src == dst)
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
		}
		else
		{
			if (src.IsCreated)
			{
				src.Dispose();
			}
			if (dst.IsCreated)
			{
				dst.Dispose();
			}
		}
		src = default(NativeArray<bool>);
		dst = default(NativeArray<bool>);
		Disable();
	}

	public void Enable()
	{
		isEnabled = true;
	}

	public void Disable()
	{
		isEnabled = false;
	}

	public void Reset()
	{
		for (int i = 0; i < res; i++)
		{
			for (int j = 0; j < res; j++)
			{
				dst[i * res + j] = false;
			}
		}
	}

	public bool GetBlocked(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBlocked(normX, normZ);
	}

	public bool GetBlocked(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetBlocked(x, z);
	}

	public bool GetBlocked(int x, int z)
	{
		if (!isEnabled || res <= 0)
		{
			return false;
		}
		return src[z * res + x];
	}

	public void SetBlocked(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBlocked(normX, normZ);
	}

	public void SetBlocked(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetBlocked(x, z);
	}

	public void SetBlocked(int x, int z)
	{
		dst[z * res + x] = true;
	}

	public bool GetBlocked(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetBlocked(normX, normZ, radius);
	}

	public bool GetBlocked(float normX, float normZ, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		int num2 = Index(normX - num);
		int num3 = Index(normX + num);
		int num4 = Index(normZ - num);
		int num5 = Index(normZ + num);
		for (int i = num4; i <= num5; i++)
		{
			for (int j = num2; j <= num3; j++)
			{
				if (src[i * res + j])
				{
					return true;
				}
			}
		}
		return false;
	}

	public void SetBlocked(Vector3 worldPos, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetBlocked(normX, normZ, radius, fade);
	}

	public void SetBlocked(float normX, float normZ, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				dst[z * res + x] = true;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class TerrainSplatMap : TerrainMap<byte>
{
	public Texture2D SplatTexture0;

	public Texture2D SplatTexture1;

	private bool _generatedSplatTexture0;

	private bool _generatedSplatTexture1;

	internal int num;

	public override void Setup()
	{
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0243: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d3: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		this.num = config.Splats.Length;
		InitArrays(this.num * res * res);
		if ((Object)(object)SplatTexture0 != (Object)null)
		{
			if (((Texture)SplatTexture0).width == ((Texture)SplatTexture0).height && ((Texture)SplatTexture0).width == res)
			{
				Color32[] pixels = SplatTexture0.GetPixels32();
				int i = 0;
				int num = 0;
				for (; i < res; i++)
				{
					int num2 = 0;
					while (num2 < res)
					{
						Color32 val = pixels[num];
						if (this.num > 0)
						{
							ref NativeArray<byte> reference = ref dst;
							_ = res;
							reference[(0 + i) * res + num2] = val.r;
						}
						if (this.num > 1)
						{
							dst[(res + i) * res + num2] = val.g;
						}
						if (this.num > 2)
						{
							dst[(2 * res + i) * res + num2] = val.b;
						}
						if (this.num > 3)
						{
							dst[(3 * res + i) * res + num2] = val.a;
						}
						num2++;
						num++;
					}
				}
			}
			else
			{
				Debug.LogError((object)("Invalid splat texture: " + ((Object)SplatTexture0).name), (Object)(object)SplatTexture0);
			}
		}
		if (!((Object)(object)SplatTexture1 != (Object)null))
		{
			return;
		}
		if (((Texture)SplatTexture1).width == ((Texture)SplatTexture1).height && ((Texture)SplatTexture1).width == res && this.num > 5)
		{
			Color32[] pixels2 = SplatTexture1.GetPixels32();
			int j = 0;
			int num3 = 0;
			for (; j < res; j++)
			{
				int num4 = 0;
				while (num4 < res)
				{
					Color32 val2 = pixels2[num3];
					if (this.num > 4)
					{
						dst[(4 * res + j) * res + num4] = val2.r;
					}
					if (this.num > 5)
					{
						dst[(5 * res + j) * res + num4] = val2.g;
					}
					if (this.num > 6)
					{
						dst[(6 * res + j) * res + num4] = val2.b;
					}
					if (this.num > 7)
					{
						dst[(7 * res + j) * res + num4] = val2.a;
					}
					num4++;
					num3++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid splat texture: " + ((Object)SplatTexture1).name), (Object)(object)SplatTexture1);
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedSplatTexture0 && (Object)(object)SplatTexture0 != (Object)null)
		{
			Object.Destroy((Object)(object)SplatTexture0);
			SplatTexture0 = null;
		}
		if (_generatedSplatTexture1 && (Object)(object)SplatTexture1 != (Object)null)
		{
			Object.Destroy((Object)(object)SplatTexture1);
			SplatTexture1 = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Expected O, but got Unknown
		SplatTexture0 = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)SplatTexture0).name = "SplatTexture0";
		((Texture)SplatTexture0).wrapMode = (TextureWrapMode)1;
		Color32[] cols = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_011c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0121: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				int num;
				if (this.num <= 0)
				{
					num = 0;
				}
				else
				{
					ref NativeArray<byte> reference = ref src;
					_ = res;
					num = reference[(0 + z) * res + i];
				}
				byte b = (byte)num;
				byte b2 = (byte)((this.num > 1) ? src[(res + z) * res + i] : 0);
				byte b3 = (byte)((this.num > 2) ? src[(2 * res + z) * res + i] : 0);
				byte b4 = (byte)((this.num > 3) ? src[(3 * res + z) * res + i] : 0);
				cols[z * res + i] = new Color32(b, b2, b3, b4);
			}
		});
		SplatTexture0.SetPixels32(cols);
		_generatedSplatTexture0 = Application.isPlaying;
		SplatTexture1 = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)SplatTexture1).name = "SplatTexture1";
		((Texture)SplatTexture1).wrapMode = (TextureWrapMode)1;
		Color32[] cols2 = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_011e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0123: Unknown result type (might be due to invalid IL or missing references)
			for (int j = 0; j < res; j++)
			{
				byte b5 = (byte)((num > 4) ? src[(4 * res + z) * res + j] : 0);
				byte b6 = (byte)((num > 5) ? src[(5 * res + z) * res + j] : 0);
				byte b7 = (byte)((num > 6) ? src[(6 * res + z) * res + j] : 0);
				byte b8 = (byte)((num > 7) ? src[(7 * res + z) * res + j] : 0);
				cols2[z * res + j] = new Color32(b5, b6, b7, b8);
			}
		});
		SplatTexture1.SetPixels32(cols2);
		_generatedSplatTexture1 = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		SplatTexture0.Apply(true, true);
		SplatTexture1.Apply(true, true);
	}

	public float GetSplatMax(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplatMax(normX, normZ, mask);
	}

	public float GetSplatMax(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetSplatMax(x, z, mask);
	}

	public float GetSplatMax(int x, int z, int mask = -1)
	{
		byte b = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
				}
			}
		}
		return BitUtility.Byte2Float((int)b);
	}

	public int GetSplatMaxIndex(Vector3 worldPos, int mask = -1)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplatMaxIndex(normX, normZ, mask);
	}

	public int GetSplatMaxIndex(float normX, float normZ, int mask = -1)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetSplatMaxIndex(x, z, mask);
	}

	public int GetSplatMaxIndex(int x, int z, int mask = -1)
	{
		byte b = 0;
		int result = 0;
		for (int i = 0; i < num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				byte b2 = src[(i * res + z) * res + x];
				if (b2 >= b)
				{
					b = b2;
					result = i;
				}
			}
		}
		return result;
	}

	public int GetSplatMaxType(Vector3 worldPos, int mask = -1)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return TerrainSplat.IndexToType(GetSplatMaxIndex(worldPos, mask));
	}

	public int GetSplatMaxType(float normX, float normZ, int mask = -1)
	{
		return TerrainSplat.IndexToType(GetSplatMaxIndex(normX, normZ, mask));
	}

	public int GetSplatMaxType(int x, int z, int mask = -1)
	{
		return TerrainSplat.IndexToType(GetSplatMaxIndex(x, z, mask));
	}

	public float GetSplat(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetSplat(normX, normZ, mask);
	}

	public float GetSplat(float normX, float normZ, int mask)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetSplat(num4, num5, mask), GetSplat(x, num5, mask), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetSplat(num4, z, mask), GetSplat(x, z, mask), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetSplat(int x, int z, int mask)
	{
		if (Mathf.IsPowerOfTwo(mask))
		{
			return BitUtility.Byte2Float((int)src[(TerrainSplat.TypeToIndex(mask) * res + z) * res + x]);
		}
		int num = 0;
		for (int i = 0; i < this.num; i++)
		{
			if ((TerrainSplat.IndexToType(i) & mask) != 0)
			{
				num += src[(i * res + z) * res + x];
			}
		}
		return Mathf.Clamp01(BitUtility.Byte2Float(num));
	}

	public void SetSplat(Vector3 worldPos, int id)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id);
	}

	public void SetSplat(float normX, float normZ, int id)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetSplat(x, z, id);
	}

	public void SetSplat(int x, int z, int id)
	{
		int num = TerrainSplat.TypeToIndex(id);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = byte.MaxValue;
			}
			else
			{
				dst[(i * res + z) * res + x] = 0;
			}
		}
	}

	public void SetSplat(Vector3 worldPos, int id, float v)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id, v);
	}

	public void SetSplat(float normX, float normZ, int id, float v)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetSplat(x, z, id, v);
	}

	public void SetSplat(int x, int z, int id, float v)
	{
		SetSplat(x, z, id, GetSplat(x, z, id), v);
	}

	public void SetSplatRaw(int x, int z, Vector4 v1, Vector4 v2, float opacity)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_024e: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0437: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		if (opacity == 0f)
		{
			return;
		}
		float num = Mathf.Clamp01(v1.x + v1.y + v1.z + v1.w + v2.x + v2.y + v2.z + v2.w);
		if (num != 0f)
		{
			float num2 = 1f - opacity * num;
			if (num2 == 0f && opacity == 1f)
			{
				ref NativeArray<byte> reference = ref dst;
				_ = res;
				reference[(0 + z) * res + x] = BitUtility.Float2Byte(v1.x);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(v1.y);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(v1.z);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(v1.w);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(v2.x);
				dst[(5 * res + z) * res + x] = BitUtility.Float2Byte(v2.y);
				dst[(6 * res + z) * res + x] = BitUtility.Float2Byte(v2.z);
				dst[(7 * res + z) * res + x] = BitUtility.Float2Byte(v2.w);
			}
			else
			{
				ref NativeArray<byte> reference2 = ref dst;
				_ = res;
				int num3 = (0 + z) * res + x;
				ref NativeArray<byte> reference3 = ref src;
				_ = res;
				reference2[num3] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)reference3[(0 + z) * res + x]) * num2 + v1.x * opacity);
				dst[(res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(res + z) * res + x]) * num2 + v1.y * opacity);
				dst[(2 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(2 * res + z) * res + x]) * num2 + v1.z * opacity);
				dst[(3 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(3 * res + z) * res + x]) * num2 + v1.w * opacity);
				dst[(4 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(4 * res + z) * res + x]) * num2 + v2.x * opacity);
				dst[(5 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(5 * res + z) * res + x]) * num2 + v2.y * opacity);
				dst[(6 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(6 * res + z) * res + x]) * num2 + v2.z * opacity);
				dst[(7 * res + z) * res + x] = BitUtility.Float2Byte(BitUtility.Byte2Float((int)src[(7 * res + z) * res + x]) * num2 + v2.w * opacity);
			}
		}
	}

	public void AddSplat(Vector3 worldPos, int id, float d)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddSplat(normX, normZ, id, d);
	}

	public void AddSplat(float normX, float normZ, int id, float d)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddSplat(x, z, id, d);
	}

	public void AddSplat(int x, int z, int id, float d)
	{
		float splat = GetSplat(x, z, id);
		SetSplat(x, z, id, splat, Mathf.Clamp01(splat + d));
	}

	public void SetSplat(Vector3 worldPos, int id, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetSplat(normX, normZ, id, opacity, radius, fade);
	}

	public void SetSplat(float normX, float normZ, int id, float opacity, float radius, float fade = 0f)
	{
		int idx = TerrainSplat.TypeToIndex(id);
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				float num = BitUtility.Byte2Float((int)dst[(idx * res + z) * res + x]);
				float new_val = Mathf.Lerp(num, 1f, lerp * opacity);
				SetSplat(x, z, id, num, new_val);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddSplat(Vector3 worldPos, int id, float delta, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddSplat(normX, normZ, id, delta, radius, fade);
	}

	public void AddSplat(float normX, float normZ, int id, float delta, float radius, float fade = 0f)
	{
		int idx = TerrainSplat.TypeToIndex(id);
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				float num = BitUtility.Byte2Float((int)dst[(idx * res + z) * res + x]);
				float new_val = Mathf.Clamp01(num + lerp * delta);
				SetSplat(x, z, id, num, new_val);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void RemoveSplat(Vector3 worldPos, int id, float opacity, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RemoveSplat(normX, normZ, id, opacity, radius, fade);
	}

	public void RemoveSplat(float normX, float normZ, int id, float opacity, float radius, float fade = 0f)
	{
		int a_idx = TerrainSplat.TypeToIndex(id);
		int b_idx = 0;
		switch (TerrainMeta.BiomeMap.GetBiomeMaxType(normX, normZ))
		{
		case 1:
			b_idx = TerrainSplat.TypeToIndex(4);
			break;
		case 2:
			b_idx = TerrainSplat.TypeToIndex(16);
			break;
		case 4:
			b_idx = TerrainSplat.TypeToIndex(16);
			break;
		case 8:
			b_idx = TerrainSplat.TypeToIndex(2);
			break;
		}
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if (lerp > 0f)
			{
				int num = (a_idx * res + z) * res + x;
				int num2 = (b_idx * res + z) * res + x;
				float num3 = BitUtility.Byte2Float((int)dst[num]);
				float num4 = BitUtility.Byte2Float((int)dst[num2]);
				float num5 = lerp * opacity * num3;
				float num6 = Mathf.Clamp01(num3 - num5);
				float num7 = Mathf.Clamp01(num4 + num5);
				dst[num] = BitUtility.Float2Byte(num6);
				dst[num2] = BitUtility.Float2Byte(num7);
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	private void SetSplat(int x, int z, int id, float old_val, float new_val)
	{
		int num = TerrainSplat.TypeToIndex(id);
		if (old_val >= 1f)
		{
			return;
		}
		float num2 = (1f - new_val) / (1f - old_val);
		for (int i = 0; i < this.num; i++)
		{
			if (i == num)
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(new_val);
			}
			else
			{
				dst[(i * res + z) * res + x] = BitUtility.Float2Byte(num2 * BitUtility.Byte2Float((int)dst[(i * res + z) * res + x]));
			}
		}
	}
}


using System;
using System.Threading;
using TerrainTopologyMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;

public class TerrainTopologyMap : TerrainMap<int>
{
	public Texture2D TopologyTexture;

	private bool _generatedTopologyTexture;

	private ThreadLocal<NativeReference<int>> topoNative = new ThreadLocal<NativeReference<int>>(() => new NativeReference<int>(0, AllocatorHandle.op_Implicit((Allocator)4)), trackAllValues: true);

	public override void Setup()
	{
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.alphamapResolution;
		InitArrays(res * res);
		if (!((Object)(object)TopologyTexture != (Object)null))
		{
			return;
		}
		if (((Texture)TopologyTexture).width == ((Texture)TopologyTexture).height && ((Texture)TopologyTexture).width == res)
		{
			Color32[] pixels = TopologyTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					dst[i * res + num2] = BitUtility.DecodeInt(pixels[num]);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid topology texture: " + ((Object)TopologyTexture).name));
		}
	}

	public void GenerateTextures()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Expected O, but got Unknown
		TopologyTexture = new Texture2D(res, res, (TextureFormat)4, false, true);
		((Object)TopologyTexture).name = "TopologyTexture";
		((Texture)TopologyTexture).wrapMode = (TextureWrapMode)1;
		Color32[] col = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				col[z * res + i] = BitUtility.EncodeInt(src[z * res + i]);
			}
		});
		TopologyTexture.SetPixels32(col);
		_generatedTopologyTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		TopologyTexture.Apply(false, true);
	}

	public bool GetTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ, mask);
	}

	public bool GetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z, mask);
	}

	public bool GetTopology(int x, int z, int mask)
	{
		return (src[z * res + x] & mask) != 0;
	}

	public int GetTopology(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ);
	}

	public int GetTopology(float normX, float normZ)
	{
		int x = Index(normX);
		int z = Index(normZ);
		return GetTopology(x, z);
	}

	public int GetTopologyFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int num2 = (int)(uv.x * (float)res);
		int num3 = (int)(uv.y * (float)res);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		return src[num3 * res + num2];
	}

	public int GetTopology(int x, int z)
	{
		return src[z * res + x];
	}

	public void GetTopologies(NativeArray<Vector3> worldPos, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByPosJob getTopologyByPosJob = default(GetTopologyByPosJob);
		getTopologyByPosJob.Topologies = results;
		getTopologyByPosJob.Pos = worldPos;
		getTopologyByPosJob.Data = src;
		getTopologyByPosJob.Res = res;
		getTopologyByPosJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		getTopologyByPosJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		GetTopologyByPosJob getTopologyByPosJob2 = getTopologyByPosJob;
		IJobExtensions.RunByRef<GetTopologyByPosJob>(ref getTopologyByPosJob2);
	}

	public void GetTopologies(NativeArray<Vector2> uvs, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByUVJob getTopologyByUVJob = default(GetTopologyByUVJob);
		getTopologyByUVJob.Topologies = results;
		getTopologyByUVJob.UV = uvs;
		getTopologyByUVJob.Data = src;
		getTopologyByUVJob.Res = res;
		GetTopologyByUVJob getTopologyByUVJob2 = getTopologyByUVJob;
		IJobExtensions.RunByRef<GetTopologyByUVJob>(ref getTopologyByUVJob2);
	}

	public void GetTopologies(NativeArray<Vector2i> indices, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByIndexJob getTopologyByIndexJob = default(GetTopologyByIndexJob);
		getTopologyByIndexJob.Topologies = results;
		getTopologyByIndexJob.Indices = indices;
		getTopologyByIndexJob.Data = src;
		getTopologyByIndexJob.Res = res;
		GetTopologyByIndexJob getTopologyByIndexJob2 = getTopologyByIndexJob;
		IJobExtensions.RunByRef<GetTopologyByIndexJob>(ref getTopologyByIndexJob2);
	}

	public void GetTopologiesIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyByUVJobIndirect getTopologyByUVJobIndirect = default(GetTopologyByUVJobIndirect);
		getTopologyByUVJobIndirect.Topologies = results;
		getTopologyByUVJobIndirect.UV = uvs;
		getTopologyByUVJobIndirect.Indices = indices;
		getTopologyByUVJobIndirect.Data = src.AsReadOnly();
		getTopologyByUVJobIndirect.Res = res;
		GetTopologyByUVJobIndirect getTopologyByUVJobIndirect2 = getTopologyByUVJobIndirect;
		IJobExtensions.RunByRef<GetTopologyByUVJobIndirect>(ref getTopologyByUVJobIndirect2);
	}

	public void GetTopologiesIndirect(ReadOnly<Vector3> worldPositions, ReadOnly<float> radii, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyRadiusJobIndirect getTopologyRadiusJobIndirect = default(GetTopologyRadiusJobIndirect);
		getTopologyRadiusJobIndirect.WorldX = TerrainMeta.Position.x;
		getTopologyRadiusJobIndirect.WorldZ = TerrainMeta.Position.z;
		getTopologyRadiusJobIndirect.OneOverSizeX = TerrainMeta.OneOverSize.x;
		getTopologyRadiusJobIndirect.OneOverSizeZ = TerrainMeta.OneOverSize.z;
		getTopologyRadiusJobIndirect.Src = src.AsReadOnly();
		getTopologyRadiusJobIndirect.Res = res;
		getTopologyRadiusJobIndirect.WorldPositions = worldPositions;
		getTopologyRadiusJobIndirect.Radii = radii;
		getTopologyRadiusJobIndirect.Topologies = results;
		GetTopologyRadiusJobIndirect jobData = getTopologyRadiusJobIndirect;
		int length = worldPositions.Length;
		JobHandle dependsOn = default(JobHandle);
		dependsOn = ParallelJobEx.ScheduleParallelByRef<GetTopologyRadiusJobIndirect>(ref jobData, length, dependsOn);
		((JobHandle)(ref dependsOn)).Complete();
	}

	public void GetTopologiesIndirect(ReadOnly<Vector2> normalizedCoords, ReadOnly<float> radii, NativeArray<int> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		GetTopologyRadiusNormalizedJobIndirect getTopologyRadiusNormalizedJobIndirect = default(GetTopologyRadiusNormalizedJobIndirect);
		getTopologyRadiusNormalizedJobIndirect.OneOverSizeX = TerrainMeta.OneOverSize.x;
		getTopologyRadiusNormalizedJobIndirect.Src = src.AsReadOnly();
		getTopologyRadiusNormalizedJobIndirect.Res = res;
		getTopologyRadiusNormalizedJobIndirect.WorldNXZ = normalizedCoords;
		getTopologyRadiusNormalizedJobIndirect.Radii = radii;
		getTopologyRadiusNormalizedJobIndirect.Topologies = results;
		GetTopologyRadiusNormalizedJobIndirect jobData = getTopologyRadiusNormalizedJobIndirect;
		int length = normalizedCoords.Length;
		JobHandle dependsOn = default(JobHandle);
		dependsOn = ParallelJobEx.ScheduleParallelByRef<GetTopologyRadiusNormalizedJobIndirect>(ref jobData, length, dependsOn);
		((JobHandle)(ref dependsOn)).Complete();
	}

	public void SetTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetTopology(normX, normZ, mask);
	}

	public void SetTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetTopology(x, z, mask);
	}

	public void SetTopology(int x, int z, int mask)
	{
		dst[z * res + x] = mask;
	}

	public void AddTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddTopology(normX, normZ, mask);
	}

	public void AddTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		AddTopology(x, z, mask);
	}

	public void AddTopology(int x, int z, int mask)
	{
		ref NativeArray<int> reference = ref dst;
		int num = z * res + x;
		reference[num] |= mask;
	}

	public void RemoveTopology(Vector3 worldPos, int mask)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		RemoveTopology(normX, normZ, mask);
	}

	public void RemoveTopology(float normX, float normZ, int mask)
	{
		int x = Index(normX);
		int z = Index(normZ);
		RemoveTopology(x, z, mask);
	}

	public void RemoveTopology(int x, int z, int mask)
	{
		ref NativeArray<int> reference = ref dst;
		int num = z * res + x;
		reference[num] &= ~mask;
	}

	public int GetTopology(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopology(normX, normZ, radius);
	}

	public int GetTopologyJob(Vector3 worldPos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetTopologyJob(normX, normZ, radius);
	}

	public int GetTopologyJob(float normX, float normZ, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.OneOverSize.x * radius;
		int x_mid = Index(normX);
		int z_mid = Index(normZ);
		int x_min = Index(normX - num);
		int x_max = Index(normX + num);
		int z_min = Index(normZ - num);
		int z_max = Index(normZ + num);
		NativeReference<int> value = topoNative.Value;
		GetTopologyRadiusJob getTopologyRadiusJob = default(GetTopologyRadiusJob);
		getTopologyRadiusJob.Res = res;
		getTopologyRadiusJob.Src = src.AsReadOnly();
		getTopologyRadiusJob.Topo = value;
		getTopologyRadiusJob.radius = radius;
		getTopologyRadiusJob.x_mid = x_mid;
		getTopologyRadiusJob.z_mid = z_mid;
		getTopologyRadiusJob.x_min = x_min;
		getTopologyRadiusJob.x_max = x_max;
		getTopologyRadiusJob.z_min = z_min;
		getTopologyRadiusJob.z_max = z_max;
		GetTopologyRadiusJob getTopologyRadiusJob2 = getTopologyRadiusJob;
		IJobExtensions.RunByRef<GetTopologyRadiusJob>(ref getTopologyRadiusJob2);
		return value.Value;
	}

	public int GetTopology(float normX, float normZ, float radius)
	{
		return GetTopologyJob(normX, normZ, radius);
	}

	public void SetTopology(Vector3 worldPos, int mask, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetTopology(normX, normZ, mask, radius, fade);
	}

	public void SetTopology(float normX, float normZ, int mask, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				dst[z * res + x] = mask;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public void AddTopology(Vector3 worldPos, int mask, float radius, float fade = 0f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		AddTopology(normX, normZ, mask, radius, fade);
	}

	public void AddTopology(float normX, float normZ, int mask, float radius, float fade = 0f)
	{
		Action<int, int, float> action = delegate(int x, int z, float lerp)
		{
			if ((double)lerp > 0.5)
			{
				ref NativeArray<int> reference = ref dst;
				int num = z * res + x;
				reference[num] |= mask;
			}
		};
		ApplyFilter(normX, normZ, radius, fade, action);
	}

	public override void Dispose()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		base.Dispose();
		if (_generatedTopologyTexture && (Object)(object)TopologyTexture != (Object)null)
		{
			Object.Destroy((Object)(object)TopologyTexture);
			TopologyTexture = null;
		}
		foreach (NativeReference<int> value in topoNative.Values)
		{
			if (value.IsCreated)
			{
				value.Dispose();
			}
		}
	}
}


using System;
using Facepunch;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainWaterFlowMap : TerrainMap<byte>
{
	private const float TwoPi = MathF.PI * 2f;

	public override void Setup()
	{
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
	}

	public override void PostSetup()
	{
		TimeWarning val = TimeWarning.New("TerrainWaterFlowMap.PostSetup", 0);
		try
		{
			WriteWaterFlowFromShoreVectors();
			WriteWaterFlowFromRivers();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void WriteWaterFlowFromShoreVectors()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<Vector2> normalizedCoords = new NativeArray<Vector2>(res * res, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<float> radii = new NativeArray<float>(res * res, (Allocator)3, (NativeArrayOptions)1);
		NativeArray<int> topologies = new NativeArray<int>(res * res, (Allocator)3, (NativeArrayOptions)1);
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			float num = Coordinate(z);
			for (int i = 0; i < res; i++)
			{
				float num2 = Coordinate(i);
				normalizedCoords[z * res + i] = new Vector2(num2, num);
				radii[z * res + i] = 16f;
			}
		});
		TerrainMeta.TopologyMap.GetTopologiesIndirect(normalizedCoords.AsReadOnly(), radii.AsReadOnly(), topologies);
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			float num3 = Coordinate(z);
			Vector3 flow = default(Vector3);
			for (int j = 0; j < res; j++)
			{
				float num4 = Coordinate(j);
				int num5 = topologies[z * res + j];
				Vector4 rawShoreVector = TerrainTexturing.Instance.GetRawShoreVector(new Vector2(num4, num3));
				((Vector3)(ref flow))..ctor(rawShoreVector.x, 0f, rawShoreVector.y);
				if ((num5 & 0x14080) != 0)
				{
					SetFlowDirection(num4, num3, flow);
				}
			}
		});
		normalizedCoords.Dispose(default(JobHandle));
		radii.Dispose(default(JobHandle));
		topologies.Dispose(default(JobHandle));
	}

	private void WriteWaterFlowFromRivers()
	{
		foreach (PathList river in TerrainMeta.Path.Rivers)
		{
			river.AdjustTerrainWaterFlow(scaleWidthWithLength: true);
		}
	}

	public Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetFlowDirection(normX, normZ);
	}

	public Vector3 GetFlowDirection(Vector2 worldPos2D)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos2D.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos2D.y);
		return GetFlowDirection(normX, normZ);
	}

	public Vector3 GetFlowDirection(float normX, float normZ)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(normX);
		int num2 = Index(normZ);
		float num3 = ByteToAngle(src[num2 * res + num]);
		return new Vector3(Mathf.Sin(num3), 0f, Mathf.Cos(num3));
	}

	public void SetFlowDirection(Vector3 worldPos, Vector3 flow)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetFlowDirection(normX, normZ, flow);
	}

	public void SetFlowDirection(float normX, float normZ, Vector3 flow)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		int num = Index(normX);
		int num2 = Index(normZ);
		Vector3 val = Vector3Extensions.XZ(flow, 0f);
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		byte b = AngleToByte(Mathf.Atan2(normalized.x, normalized.z));
		src[num2 * res + num] = b;
	}

	private static float ByteToAngle(byte b)
	{
		return (float)(int)b / 255f * (MathF.PI * 2f) - MathF.PI;
	}

	private static byte AngleToByte(float a)
	{
		a = Mathf.Clamp(a, -MathF.PI, MathF.PI);
		return (byte)Mathf.RoundToInt((a + MathF.PI) / (MathF.PI * 2f) * 255f);
	}
}


using System;
using TerrainWaterMapJobs;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class TerrainWaterMap : TerrainMap<short>
{
	public Texture2D WaterTexture;

	private bool _generatedWaterTexture;

	private float normY;

	public override void Setup()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		res = terrain.terrainData.heightmapResolution;
		InitArrays(res * res);
		normY = TerrainMeta.Size.x / TerrainMeta.Size.y / (float)res;
		if (!((Object)(object)WaterTexture != (Object)null))
		{
			return;
		}
		if (((Texture)WaterTexture).width == ((Texture)WaterTexture).height && ((Texture)WaterTexture).width == res)
		{
			Color32[] pixels = WaterTexture.GetPixels32();
			int i = 0;
			int num = 0;
			for (; i < res; i++)
			{
				int num2 = 0;
				while (num2 < res)
				{
					Color32 val = pixels[num];
					dst[i * res + num2] = BitUtility.DecodeShort(val);
					num2++;
					num++;
				}
			}
		}
		else
		{
			Debug.LogError((object)("Invalid water texture: " + ((Object)WaterTexture).name));
		}
	}

	public override void Dispose()
	{
		base.Dispose();
		if (_generatedWaterTexture && (Object)(object)WaterTexture != (Object)null)
		{
			Object.Destroy((Object)(object)WaterTexture);
			WaterTexture = null;
		}
	}

	public void GenerateTextures()
	{
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Expected O, but got Unknown
		Color32[] heights = (Color32[])(object)new Color32[res * res];
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			for (int i = 0; i < res; i++)
			{
				heights[z * res + i] = BitUtility.EncodeShort(src[z * res + i]);
			}
		});
		WaterTexture = new Texture2D(res, res, (TextureFormat)4, true, true);
		((Object)WaterTexture).name = "WaterTexture";
		((Texture)WaterTexture).wrapMode = (TextureWrapMode)1;
		WaterTexture.SetPixels32(heights);
		_generatedWaterTexture = Application.isPlaying;
	}

	public void ApplyTextures()
	{
		WaterTexture.Apply(true, true);
	}

	public float GetHeight(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(worldPos) * TerrainMeta.Size.y;
	}

	public float GetHeight(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(normX, normZ) * TerrainMeta.Size.y;
	}

	public float GetHeightFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? res : 0);
		int num10 = num5 * res + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = (float)src[num10] * 3.051944E-05f;
		float num15 = (float)src[num11] * 3.051944E-05f;
		float num16 = (float)src[num12] * 3.051944E-05f;
		float num17 = (float)src[num13] * 3.051944E-05f;
		float num18 = (num15 - num14) * num6 + num14;
		float num19 = ((num17 - num16) * num6 + num16 - num18) * num7 + num18;
		return TerrainMeta.Position.y + num19 * TerrainMeta.Size.y;
	}

	public float GetHeight(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return TerrainMeta.Position.y + GetHeight01(x, z) * TerrainMeta.Size.y;
	}

	public void GetHeights(NativeArray<Vector3> worldPos, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByPosJob getHeightByPosJob = default(GetHeightByPosJob);
		getHeightByPosJob.Heights = results;
		getHeightByPosJob.Pos = worldPos;
		getHeightByPosJob.Data = src;
		getHeightByPosJob.Res = res;
		getHeightByPosJob.Offset = TerrainMeta.Position.y;
		getHeightByPosJob.Scale = TerrainMeta.Size.y;
		getHeightByPosJob.DataOrigin = new Vector2(TerrainMeta.Position.x, TerrainMeta.Position.z);
		getHeightByPosJob.DataScale = new Vector2(TerrainMeta.OneOverSize.x, TerrainMeta.OneOverSize.z);
		GetHeightByPosJob getHeightByPosJob2 = getHeightByPosJob;
		IJobExtensions.RunByRef<GetHeightByPosJob>(ref getHeightByPosJob2);
	}

	public void GetHeights(NativeArray<Vector2> uvs, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJob getHeightByUVJob = default(GetHeightByUVJob);
		getHeightByUVJob.Heights = results;
		getHeightByUVJob.UV = uvs;
		getHeightByUVJob.Data = src;
		getHeightByUVJob.Res = res;
		getHeightByUVJob.Offset = TerrainMeta.Position.y;
		getHeightByUVJob.Scale = TerrainMeta.Size.y;
		GetHeightByUVJob getHeightByUVJob2 = getHeightByUVJob;
		IJobExtensions.RunByRef<GetHeightByUVJob>(ref getHeightByUVJob2);
	}

	public void GetHeightsIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByUVJobIndirect getHeightByUVJobIndirect = default(GetHeightByUVJobIndirect);
		getHeightByUVJobIndirect.Heights = results;
		getHeightByUVJobIndirect.UV = uvs;
		getHeightByUVJobIndirect.Indices = indices;
		getHeightByUVJobIndirect.Data = src.AsReadOnly();
		getHeightByUVJobIndirect.Res = res;
		getHeightByUVJobIndirect.Offset = TerrainMeta.Position.y;
		getHeightByUVJobIndirect.Scale = TerrainMeta.Size.y;
		GetHeightByUVJobIndirect getHeightByUVJobIndirect2 = getHeightByUVJobIndirect;
		IJobExtensions.RunByRef<GetHeightByUVJobIndirect>(ref getHeightByUVJobIndirect2);
	}

	public void GetHeights(NativeArray<Vector2i> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		GetHeightByIndexJob getHeightByIndexJob = default(GetHeightByIndexJob);
		getHeightByIndexJob.Heights = results;
		getHeightByIndexJob.Indices = indices;
		getHeightByIndexJob.Data = src;
		getHeightByIndexJob.Res = res;
		getHeightByIndexJob.Offset = TerrainMeta.Position.y;
		getHeightByIndexJob.Scale = TerrainMeta.Size.y;
		GetHeightByIndexJob getHeightByIndexJob2 = getHeightByIndexJob;
		IJobExtensions.RunByRef<GetHeightByIndexJob>(ref getHeightByIndexJob2);
	}

	public float GetHeight01(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetHeight01(normX, normZ);
	}

	public float GetHeight01(float normX, float normZ)
	{
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = Mathf.Lerp(GetHeight01(num4, num5), GetHeight01(x, num5), num2 - (float)num4);
		float num7 = Mathf.Lerp(GetHeight01(num4, z), GetHeight01(x, z), num2 - (float)num4);
		return Mathf.Lerp(num6, num7, num3 - (float)num5);
	}

	public float GetHeight01(int x, int z)
	{
		return BitUtility.Short2Float((int)src[z * res + x]);
	}

	public Vector3 GetNormal(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		return GetNormal(normX, normZ);
	}

	public Vector3 GetNormal(float normX, float normZ)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		float num2 = normX * (float)num;
		float num3 = normZ * (float)num;
		int num4 = Mathf.Clamp((int)num2, 0, num);
		int num5 = Mathf.Clamp((int)num3, 0, num);
		int x = Mathf.Min(num4 + 1, num);
		int z = Mathf.Min(num5 + 1, num);
		float num6 = GetHeight01(x, num5) - GetHeight01(num4, num5);
		float num7 = GetHeight01(num4, z) - GetHeight01(num4, num5);
		Vector3 val = new Vector3(0f - num6, normY, 0f - num7);
		return ((Vector3)(ref val)).normalized;
	}

	public Vector3 GetNormalFast(Vector2 uv)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int num2 = (int)(uv.x * (float)num);
		int num3 = (int)(uv.y * (float)num);
		num2 = ((num2 >= 0) ? num2 : 0);
		num3 = ((num3 >= 0) ? num3 : 0);
		num2 = ((num2 <= num) ? num2 : num);
		num3 = ((num3 <= num) ? num3 : num);
		int num4 = ((num2 < num) ? 1 : 0);
		int num5 = ((num3 < num) ? res : 0);
		int num6 = num3 * res + num2;
		int num7 = num6 + num4;
		int num8 = num6 + num5;
		short num9 = src[num6];
		short num10 = src[num7];
		short num11 = src[num8];
		float num12 = (float)(num10 - num9) * 3.051944E-05f;
		float num13 = (float)(num11 - num9) * 3.051944E-05f;
		return new Vector3(0f - num12, normY, 0f - num13);
	}

	public Vector3 GetNormal(int x, int z)
	{
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		int num = res - 1;
		int x2 = Mathf.Clamp(x - 1, 0, num);
		int z2 = Mathf.Clamp(z - 1, 0, num);
		int x3 = Mathf.Clamp(x + 1, 0, num);
		int z3 = Mathf.Clamp(z + 1, 0, num);
		float num2 = (GetHeight01(x3, z2) - GetHeight01(x2, z2)) * 0.5f;
		float num3 = (GetHeight01(x2, z3) - GetHeight01(x2, z2)) * 0.5f;
		Vector3 val = new Vector3(0f - num2, normY, 0f - num3);
		return ((Vector3)(ref val)).normalized;
	}

	public float GetSlope(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(worldPos));
	}

	public float GetSlope(float normX, float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(normX, normZ));
	}

	public float GetSlope(int x, int z)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Angle(Vector3.up, GetNormal(x, z));
	}

	public float GetSlope01(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GetSlope(worldPos) * (1f / 90f);
	}

	public float GetSlope01(float normX, float normZ)
	{
		return GetSlope(normX, normZ) * (1f / 90f);
	}

	public float GetSlope01(int x, int z)
	{
		return GetSlope(x, z) * (1f / 90f);
	}

	public float GetDepth(Vector3 worldPos)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return GetHeight(worldPos) - TerrainMeta.HeightMap.GetHeight(worldPos);
	}

	public float GetDepth(float normX, float normZ)
	{
		return GetHeight(normX, normZ) - TerrainMeta.HeightMap.GetHeight(normX, normZ);
	}

	public void SetHeight(Vector3 worldPos, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float normX = TerrainMeta.NormalizeX(worldPos.x);
		float normZ = TerrainMeta.NormalizeZ(worldPos.z);
		SetHeight(normX, normZ, height);
	}

	public void SetHeight(float normX, float normZ, float height)
	{
		int x = Index(normX);
		int z = Index(normZ);
		SetHeight(x, z, height);
	}

	public void SetHeight(int x, int z, float height)
	{
		dst[z * res + x] = BitUtility.Float2Short(height);
	}
}


using UnityEngine;

public class TerrainMargin
{
	private static MaterialPropertyBlock materialPropertyBlock;

	public static void Create()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		Material marginMaterial = TerrainMeta.Config.MarginMaterial;
		Vector3 center = TerrainMeta.Center;
		Vector3 size = TerrainMeta.Size;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(size.x, 0f, 0f);
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(0f, 0f, size.z);
		center.y = TerrainMeta.HeightMap.GetHeight(0, 0);
		Create(center - val2, size, marginMaterial);
		Create(center - val2 - val, size, marginMaterial);
		Create(center - val2 + val, size, marginMaterial);
		Create(center - val, size, marginMaterial);
		Create(center + val, size, marginMaterial);
		Create(center + val2, size, marginMaterial);
		Create(center + val2 - val, size, marginMaterial);
		Create(center + val2 + val, size, marginMaterial);
	}

	private static void Create(Vector3 position, Vector3 size, Material material)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		GameObject obj = GameObject.CreatePrimitive((PrimitiveType)4);
		((Object)obj).name = "TerrainMargin";
		obj.layer = 16;
		obj.transform.position = position;
		obj.transform.localScale = size * 0.1f;
		Object.Destroy((Object)(object)obj.GetComponent<MeshRenderer>());
		Object.Destroy((Object)(object)obj.GetComponent<MeshFilter>());
	}
}


using Oxide.Core;
using UnityEngine;

[ExecuteInEditMode]
public class TerrainMeta : MonoBehaviour
{
	public enum PaintMode
	{
		None,
		Splats,
		Biomes,
		Alpha,
		Blend,
		Field,
		Cliff,
		Summit,
		Beachside,
		Beach,
		Forest,
		Forestside,
		Ocean,
		Oceanside,
		Decor,
		Monument,
		Road,
		Roadside,
		Swamp,
		River,
		Riverside,
		Lake,
		Lakeside,
		Offshore,
		Rail,
		Railside,
		Building,
		Cliffside,
		Mountain,
		Clutter,
		Alt,
		Tier0,
		Tier1,
		Tier2,
		Mainland,
		Hilltop
	}

	public Terrain terrain;

	public TerrainConfig config;

	public PaintMode paint;

	[HideInInspector]
	public PaintMode currentPaintMode;

	public static TerrainConfig Config { get; private set; }

	public static Terrain Terrain { get; private set; }

	public static Transform Transform { get; private set; }

	public static Vector3 Position { get; private set; }

	public static Vector3 Size { get; private set; }

	public static Vector3 Center => Position + Size * 0.5f;

	public static Vector3 Max => Position + Size;

	public static Vector3 OneOverSize { get; private set; }

	public static Vector3 HighestPoint { get; set; }

	public static Vector3 LowestPoint { get; set; }

	public static float LootAxisAngle { get; private set; }

	public static float BiomeAxisAngle { get; private set; }

	public static TerrainData Data { get; private set; }

	public static TerrainCollider Collider { get; private set; }

	public static TerrainCollision Collision { get; private set; }

	public static TerrainPhysics Physics { get; private set; }

	public static TerrainColors Colors { get; private set; }

	public static TerrainQuality Quality { get; private set; }

	public static TerrainPath Path { get; private set; }

	public static TerrainBiomeMap BiomeMap { get; private set; }

	public static TerrainAlphaMap AlphaMap { get; private set; }

	public static TerrainBlendMap BlendMap { get; private set; }

	public static TerrainHeightMap HeightMap { get; private set; }

	public static TerrainSplatMap SplatMap { get; private set; }

	public static TerrainTopologyMap TopologyMap { get; private set; }

	public static TerrainWaterMap WaterMap { get; private set; }

	public static TerrainWaterFlowMap WaterFlowMap { get; private set; }

	public static TerrainDistanceMap DistanceMap { get; private set; }

	public static TerrainPlacementMap PlacementMap { get; private set; }

	public static TerrainTexturing Texturing { get; private set; }

	public static bool OutOfBounds(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x)
		{
			return true;
		}
		if (worldPos.z < Position.z)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfMargin(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x - Size.x)
		{
			return true;
		}
		if (worldPos.z < Position.z - Size.z)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x + Size.x)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z + Size.z)
		{
			return true;
		}
		return false;
	}

	public static bool OutOfMarginPlusTutorialBounds(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		if (worldPos.x < Position.x - Size.x - TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.z < Position.z - Size.z - TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.x > Position.x + Size.x + Size.x + TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		if (worldPos.z > Position.z + Size.z + Size.z + TutorialIsland.TutorialBoundsSize)
		{
			return true;
		}
		return false;
	}

	public static float InnerDistToEdge2D(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		float num = Position.x - Size.x;
		float num2 = Position.x + Size.x + Size.x;
		float num3 = Position.z - Size.z;
		float num4 = Position.z + Size.z + Size.z;
		float num5 = Mathf.Abs(worldPos.x - num);
		float num6 = Mathf.Abs(worldPos.x - num2);
		float num7 = Mathf.Abs(worldPos.z - num3);
		float num8 = Mathf.Abs(worldPos.z - num4);
		return Mathf.Min(num5, Mathf.Min(num6, Mathf.Min(num7, num8)));
	}

	public static bool IsPointWithinTutorialBounds(Vector3 worldPos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		float tutorialBoundsSize = TutorialIsland.TutorialBoundsSize;
		float maximumPointTutorial = ValidBounds.GetMaximumPointTutorial();
		float num = 0f - maximumPointTutorial + tutorialBoundsSize;
		float num2 = maximumPointTutorial - tutorialBoundsSize;
		float num3 = 0f - maximumPointTutorial + tutorialBoundsSize;
		float num4 = maximumPointTutorial - tutorialBoundsSize;
		if (!(worldPos.x < num) && !(worldPos.x > num2) && !(worldPos.z < num3))
		{
			return worldPos.z > num4;
		}
		return true;
	}

	public static bool RandomWaterPointInAnnulus(Vector3 centre, float minRadius, float maxRadius, out Vector3 randomPoint)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 100; i++)
		{
			Vector3 val = Vector2.op_Implicit(Random.insideUnitCircle);
			float num = Random.Range(minRadius, maxRadius);
			Vector3 val2 = centre + new Vector3(val.x, 0f, val.y) * num;
			float height = HeightMap.GetHeight(val2);
			float height2 = WaterMap.GetHeight(val2);
			if (height <= height2)
			{
				randomPoint = val2;
				return true;
			}
		}
		randomPoint = Vector3.zero;
		return false;
	}

	public static Vector3 RandomPointOffshore()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		float num = Random.Range(-1f, 1f);
		float num2 = Random.Range(0f, 100f);
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(Mathf.Min(Size.x, 4000f) - 100f, 0f, Mathf.Min(Size.z, 4000f) - 100f);
		if (num2 < 25f)
		{
			return Center + new Vector3(0f - val.x, 0f, num * val.z);
		}
		if (num2 < 50f)
		{
			return Center + new Vector3(val.x, 0f, num * val.z);
		}
		if (num2 < 75f)
		{
			return Center + new Vector3(num * val.x, 0f, 0f - val.z);
		}
		return Center + new Vector3(num * val.x, 0f, val.z);
	}

	public static Vector3 RandomPoint(bool excludeWater = true)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = default(Vector3);
		while (((Vector3)(ref val)).Equals(default(Vector3)) || (excludeWater && WaterLevel.Test(val, waves: true, volumes: true)))
		{
			float num = Random.Range(0f, Terrain.terrainData.size.x);
			float num2 = Random.Range(0f, Terrain.terrainData.size.z);
			float height = HeightMap.GetHeight(new Vector3(num, 0f, num2));
			((Vector3)(ref val))..ctor(num, height, num2);
		}
		return val;
	}

	public static Vector3 Normalize(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = (worldPos.x - Position.x) * OneOverSize.x;
		float num2 = (worldPos.y - Position.y) * OneOverSize.y;
		float num3 = (worldPos.z - Position.z) * OneOverSize.z;
		return new Vector3(num, num2, num3);
	}

	public static float NormalizeX(float x)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (x - Position.x) * OneOverSize.x;
	}

	public static float NormalizeY(float y)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (y - Position.y) * OneOverSize.y;
	}

	public static float NormalizeZ(float z)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return (z - Position.z) * OneOverSize.z;
	}

	public static Vector3 Denormalize(Vector3 normPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		float num = Position.x + normPos.x * Size.x;
		float num2 = Position.y + normPos.y * Size.y;
		float num3 = Position.z + normPos.z * Size.z;
		return new Vector3(num, num2, num3);
	}

	public static float DenormalizeX(float normX)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.x + normX * Size.x;
	}

	public static float DenormalizeY(float normY)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.y + normY * Size.y;
	}

	public static float DenormalizeZ(float normZ)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return Position.z + normZ * Size.z;
	}

	protected void Awake()
	{
		if (Application.isPlaying)
		{
			Shader.DisableKeyword("TERRAIN_PAINTING");
		}
	}

	public void Init(Terrain terrainOverride = null, TerrainConfig configOverride = null)
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)terrainOverride != (Object)null)
		{
			terrain = terrainOverride;
		}
		if ((Object)(object)configOverride != (Object)null)
		{
			config = configOverride;
		}
		Terrain = terrain;
		Config = config;
		Transform = ((Component)terrain).transform;
		Data = terrain.terrainData;
		Size = terrain.terrainData.size;
		OneOverSize = Vector3Ex.Inverse(Size);
		Position = terrain.GetPosition();
		Collider = ((Component)terrain).GetComponent<TerrainCollider>();
		Collision = ((Component)terrain).GetComponent<TerrainCollision>();
		Physics = ((Component)terrain).GetComponent<TerrainPhysics>();
		Colors = ((Component)terrain).GetComponent<TerrainColors>();
		Quality = ((Component)terrain).GetComponent<TerrainQuality>();
		Path = ((Component)terrain).GetComponent<TerrainPath>();
		BiomeMap = ((Component)terrain).GetComponent<TerrainBiomeMap>();
		AlphaMap = ((Component)terrain).GetComponent<TerrainAlphaMap>();
		BlendMap = ((Component)terrain).GetComponent<TerrainBlendMap>();
		HeightMap = ((Component)terrain).GetComponent<TerrainHeightMap>();
		SplatMap = ((Component)terrain).GetComponent<TerrainSplatMap>();
		TopologyMap = ((Component)terrain).GetComponent<TerrainTopologyMap>();
		WaterMap = ((Component)terrain).GetComponent<TerrainWaterMap>();
		WaterFlowMap = ((Component)terrain).GetComponent<TerrainWaterFlowMap>();
		DistanceMap = ((Component)terrain).GetComponent<TerrainDistanceMap>();
		PlacementMap = ((Component)terrain).GetComponent<TerrainPlacementMap>();
		Texturing = ((Component)terrain).GetComponent<TerrainTexturing>();
		terrain.drawInstanced = false;
		HighestPoint = new Vector3(Position.x, Position.y + Size.y, Position.z);
		LowestPoint = new Vector3(Position.x, Position.y, Position.z);
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].Init(terrain, config);
		}
		uint seed = World.Seed;
		int num = SeedRandom.Range(ref seed, 0, 4) * 90;
		int num2 = SeedRandom.Range(ref seed, -45, 46);
		int num3 = SeedRandom.Sign(ref seed);
		LootAxisAngle = num;
		BiomeAxisAngle = num + num2 + num3 * 90;
	}

	public static void InitNoTerrain(bool createPath = false)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Size = new Vector3(4096f, 4096f, 4096f);
		OneOverSize = Vector3Ex.Inverse(Size);
		Position = -0.5f * Size;
	}

	public void SetupComponents()
	{
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		foreach (TerrainExtension obj in components)
		{
			obj.Setup();
			obj.isInitialized = true;
		}
	}

	public void PostSetupComponents()
	{
		TerrainExtension[] components = ((Component)this).GetComponents<TerrainExtension>();
		for (int i = 0; i < components.Length; i++)
		{
			components[i].PostSetup();
		}
		Interface.CallHook("OnTerrainInitialized");
	}

	public void BindShaderProperties()
	{
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0284: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_031f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0324: Unknown result type (might be due to invalid IL or missing references)
		//IL_036f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_03bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_048d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0492: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_04b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ba: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)config))
		{
			Shader.SetGlobalTexture("Terrain_AlbedoArray", config.AlbedoArray);
			Shader.SetGlobalTexture("Terrain_NormalArray", config.NormalArray);
			Shader.SetGlobalVector("Terrain_TexelSize", Vector4.op_Implicit(new Vector2(1f / config.GetMinSplatTiling(), 1f / config.GetMinSplatTiling())));
			Shader.SetGlobalVector("Terrain_TexelSize0", new Vector4(1f / config.Splats[0].SplatTiling, 1f / config.Splats[1].SplatTiling, 1f / config.Splats[2].SplatTiling, 1f / config.Splats[3].SplatTiling));
			Shader.SetGlobalVector("Terrain_TexelSize1", new Vector4(1f / config.Splats[4].SplatTiling, 1f / config.Splats[5].SplatTiling, 1f / config.Splats[6].SplatTiling, 1f / config.Splats[7].SplatTiling));
			Shader.SetGlobalVector("Splat0_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[0].UVMIXMult, config.Splats[0].UVMIXStart, 1f / config.Splats[0].UVMIXDist)));
			Shader.SetGlobalVector("Splat1_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[1].UVMIXMult, config.Splats[1].UVMIXStart, 1f / config.Splats[1].UVMIXDist)));
			Shader.SetGlobalVector("Splat2_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[2].UVMIXMult, config.Splats[2].UVMIXStart, 1f / config.Splats[2].UVMIXDist)));
			Shader.SetGlobalVector("Splat3_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[3].UVMIXMult, config.Splats[3].UVMIXStart, 1f / config.Splats[3].UVMIXDist)));
			Shader.SetGlobalVector("Splat4_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[4].UVMIXMult, config.Splats[4].UVMIXStart, 1f / config.Splats[4].UVMIXDist)));
			Shader.SetGlobalVector("Splat5_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[5].UVMIXMult, config.Splats[5].UVMIXStart, 1f / config.Splats[5].UVMIXDist)));
			Shader.SetGlobalVector("Splat6_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[6].UVMIXMult, config.Splats[6].UVMIXStart, 1f / config.Splats[6].UVMIXDist)));
			Shader.SetGlobalVector("Splat7_UVMIX", Vector4.op_Implicit(new Vector3(config.Splats[7].UVMIXMult, config.Splats[7].UVMIXStart, 1f / config.Splats[7].UVMIXDist)));
		}
		if (Object.op_Implicit((Object)(object)HeightMap))
		{
			Shader.SetGlobalTexture("Terrain_Normal", (Texture)(object)HeightMap.NormalTexture);
		}
		if (Object.op_Implicit((Object)(object)AlphaMap))
		{
			Shader.SetGlobalTexture("Terrain_Alpha", (Texture)(object)AlphaMap.AlphaTexture);
		}
		if (Object.op_Implicit((Object)(object)BiomeMap))
		{
			Shader.SetGlobalTexture("Terrain_Biome", (Texture)(object)BiomeMap.BiomeTexture);
		}
		if (Object.op_Implicit((Object)(object)SplatMap))
		{
			Shader.SetGlobalTexture("Terrain_Control0", (Texture)(object)SplatMap.SplatTexture0);
			Shader.SetGlobalTexture("Terrain_Control1", (Texture)(object)SplatMap.SplatTexture1);
		}
		Object.op_Implicit((Object)(object)WaterMap);
		Object.op_Implicit((Object)(object)DistanceMap);
		if (!Object.op_Implicit((Object)(object)terrain))
		{
			return;
		}
		Shader.SetGlobalVector("Terrain_Position", Vector4.op_Implicit(Position));
		Shader.SetGlobalVector("Terrain_Size", Vector4.op_Implicit(Size));
		Shader.SetGlobalVector("Terrain_RcpSize", Vector4.op_Implicit(OneOverSize));
		if (Object.op_Implicit((Object)(object)terrain.materialTemplate))
		{
			if (terrain.materialTemplate.IsKeywordEnabled("_TERRAIN_BLEND_LINEAR"))
			{
				terrain.materialTemplate.DisableKeyword("_TERRAIN_BLEND_LINEAR");
			}
			if (terrain.materialTemplate.IsKeywordEnabled("_TERRAIN_VERTEX_NORMALS"))
			{
				terrain.materialTemplate.DisableKeyword("_TERRAIN_VERTEX_NORMALS");
			}
		}
	}
}


public enum PaintMode
{
	None,
	Splats,
	Biomes,
	Alpha,
	Blend,
	Field,
	Cliff,
	Summit,
	Beachside,
	Beach,
	Forest,
	Forestside,
	Ocean,
	Oceanside,
	Decor,
	Monument,
	Road,
	Roadside,
	Swamp,
	River,
	Riverside,
	Lake,
	Lakeside,
	Offshore,
	Rail,
	Railside,
	Building,
	Cliffside,
	Mountain,
	Clutter,
	Alt,
	Tier0,
	Tier1,
	Tier2,
	Mainland,
	Hilltop
}


using UnityEngine;

[ExecuteInEditMode]
public class TerrainPaint : MonoBehaviour
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TerrainPath : TerrainExtension
{
	public List<PathList> Roads = new List<PathList>();

	public List<PathList> MainRoads = new List<PathList>();

	public List<PathList> SideRoads = new List<PathList>();

	public List<PathList> TrailRoads = new List<PathList>();

	public List<PathList> Rails = new List<PathList>();

	public List<PathList> Rivers = new List<PathList>();

	public List<PathList> Powerlines = new List<PathList>();

	public List<LandmarkInfo> Landmarks = new List<LandmarkInfo>();

	public List<MonumentInfo> Monuments = new List<MonumentInfo>();

	public List<RiverInfo> RiverObjs = new List<RiverInfo>();

	public List<LakeInfo> LakeObjs = new List<LakeInfo>();

	public List<DungeonGridInfo> DungeonGridEntrances = new List<DungeonGridInfo>();

	public List<DungeonGridCell> DungeonGridCells = new List<DungeonGridCell>();

	public List<DungeonBaseInfo> DungeonBaseEntrances = new List<DungeonBaseInfo>();

	public List<DungeonBaseLink> DungeonBaseLinks = new List<DungeonBaseLink>();

	public List<Vector3> OceanPatrolClose = new List<Vector3>();

	public List<Vector3> OceanPatrolFar = new List<Vector3>();

	public Dictionary<string, List<PowerlineNode>> wires = new Dictionary<string, List<PowerlineNode>>();

	public override void PostSetup()
	{
		foreach (PathList road in Roads)
		{
			road.ProcgenStartNode = null;
			road.ProcgenEndNode = null;
		}
		foreach (PathList rail in Rails)
		{
			rail.ProcgenStartNode = null;
			rail.ProcgenEndNode = null;
		}
		foreach (PathList river in Rivers)
		{
			river.ProcgenStartNode = null;
			river.ProcgenEndNode = null;
		}
		foreach (PathList powerline in Powerlines)
		{
			powerline.ProcgenStartNode = null;
			powerline.ProcgenEndNode = null;
		}
	}

	public void Clear()
	{
		Roads.Clear();
		Rails.Clear();
		Rivers.Clear();
		Powerlines.Clear();
	}

	public T FindClosest<T>(List<T> list, Vector3 pos) where T : MonoBehaviour
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		T result = default(T);
		float num = float.MaxValue;
		foreach (T item in list)
		{
			float num2 = Vector3Ex.Distance2D(((Component)(object)item).transform.position, pos);
			if (!(num2 >= num))
			{
				result = item;
				num = num2;
			}
		}
		return result;
	}

	public static int[,] CreatePowerlineCostmap(ref uint seed)
	{
		float radius = 5f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int num2 = 10683780;
				int num3 = 1628160;
				int num4 = 514;
				if ((topology & num2) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num3) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 2500;
				}
				else if ((topology & num4) != 0)
				{
					array[j, i] = 1000;
				}
				else
				{
					array[j, i] = 1 + (int)(slope * slope * 10f);
				}
			}
		}
		return array;
	}

	public static int[,] CreateRoadCostmap(ref uint seed, bool trail = false)
	{
		float radius = 5f;
		float radius2 = 15f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				int num2 = SeedRandom.Range(ref seed, 100, 200);
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int topology2 = topologyMap.GetTopology(normX, normZ, radius2);
				int num3 = 196996;
				int num4 = 10487296;
				int num5 = 2;
				int num6 = 49152;
				if (slope > 20f || (topology & num3) != 0 || (topology2 & num4) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num6) != 0)
				{
					array[j, i] = (trail ? int.MaxValue : 5000);
				}
				else if ((topology & num5) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 5000;
				}
				else
				{
					array[j, i] = 1 + (int)(slope * slope * 10f) + num2;
				}
			}
		}
		return array;
	}

	public static int[,] CreateRailCostmap(ref uint seed)
	{
		float radius = 5f;
		float radius2 = 25f;
		int num = (int)((float)World.Size / 7.5f);
		TerrainPlacementMap placementMap = TerrainMeta.PlacementMap;
		TerrainHeightMap heightMap = TerrainMeta.HeightMap;
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				float slope = heightMap.GetSlope(normX, normZ);
				int topology = topologyMap.GetTopology(normX, normZ, radius);
				int topology2 = topologyMap.GetTopology(normX, normZ, radius2);
				int num2 = 196996;
				int num3 = 10487296;
				int num4 = 2;
				int num5 = 49152;
				if (slope > 30f || (topology & num2) != 0 || (topology2 & num3) != 0)
				{
					array[j, i] = int.MaxValue;
				}
				else if ((topology & num5) != 0)
				{
					array[j, i] = 5000;
				}
				else if (slope > 20f || (topology & num4) != 0 || placementMap.GetBlocked(normX, normZ, radius))
				{
					array[j, i] = 5000;
				}
				else if (slope > 10f)
				{
					array[j, i] = 1500;
				}
				else
				{
					array[j, i] = 1000;
				}
			}
		}
		return array;
	}

	public static int[,] CreateBoatCostmap(float depth)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		int num = (int)((float)World.Size / 7.5f);
		int[,] array = new int[num, num];
		for (int i = 0; i < num; i++)
		{
			float normZ = ((float)i + 0.5f) / (float)num;
			for (int j = 0; j < num; j++)
			{
				float normX = ((float)j + 0.5f) / (float)num;
				if (WaterLevel.GetOverallWaterDepth(new Vector3(TerrainMeta.DenormalizeX(normX), 0f, TerrainMeta.DenormalizeZ(normZ)), waves: false, volumes: false) < depth)
				{
					array[j, i] = int.MaxValue;
				}
				else
				{
					array[j, i] = 1;
				}
			}
		}
		return array;
	}

	public void AddWire(PowerlineNode node)
	{
		string name = ((Object)((Component)node).transform.root).name;
		if (!wires.ContainsKey(name))
		{
			wires.Add(name, new List<PowerlineNode>());
		}
		wires[name].Add(node);
	}

	public void CreateWires()
	{
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		List<GameObject> list = new List<GameObject>();
		int num = 0;
		GameObjectRef gameObjectRef = null;
		foreach (KeyValuePair<string, List<PowerlineNode>> wire2 in wires)
		{
			KeyValuePair<string, List<PowerlineNode>> wire = wire2;
			GameObject rootGO = null;
			foreach (PowerlineNode item in wire.Value)
			{
				PowerLineWireConnectionHelper component = ((Component)item).GetComponent<PowerLineWireConnectionHelper>();
				if (!Object.op_Implicit((Object)(object)component))
				{
					continue;
				}
				if (list.Count == 0)
				{
					gameObjectRef = item.WirePrefab;
					num = component.connections.Count;
				}
				else
				{
					GameObject val = list[list.Count - 1];
					if (!(item.WirePrefab.guid != gameObjectRef?.guid) && component.connections.Count == num)
					{
						Vector3 val2 = val.transform.position - ((Component)item).transform.position;
						if (!(((Vector3)(ref val2)).sqrMagnitude > item.MaxDistance * item.MaxDistance))
						{
							goto IL_010f;
						}
					}
					CreateWire(list, gameObjectRef);
					list.Clear();
				}
				goto IL_010f;
				IL_010f:
				list.Add(((Component)item).gameObject);
			}
			CreateWire(list, gameObjectRef);
			list.Clear();
			void CreateWire(List<GameObject> objects, GameObjectRef wirePrefab)
			{
				//IL_0057: Unknown result type (might be due to invalid IL or missing references)
				//IL_0061: Expected O, but got Unknown
				if (objects.Count >= 3 && wirePrefab != null && wirePrefab.isValid)
				{
					PowerLineWire powerLineWire = PowerLineWire.Create(null, objects, wirePrefab, "Powerline Wires", null, 1f, 0.1f);
					if (Object.op_Implicit((Object)(object)powerLineWire))
					{
						((Behaviour)powerLineWire).enabled = false;
						if ((Object)(object)rootGO == (Object)null)
						{
							rootGO = new GameObject(wire.Key);
						}
						((Component)powerLineWire).transform.SetParent(rootGO.transform, true);
					}
				}
			}
		}
	}

	public MonumentInfo FindMonumentWithBoundsOverlap(Vector3 position, MonumentType[] types = null)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in Monuments)
		{
			if ((Object)(object)monument != (Object)null && (types == null || Array.IndexOf(types, monument.Type) != -1) && monument.IsInBounds(position))
			{
				return monument;
			}
		}
		return null;
	}

	public void AddRoad(List<PathList> newRoadList, bool addToMaster = true)
	{
		foreach (PathList newRoad in newRoadList)
		{
			AddRoad(newRoad, addToMaster);
		}
	}

	public void AddRoad(PathList newRoad, bool addToMaster = true)
	{
		switch (newRoad?.Hierarchy)
		{
		case 0:
			MainRoads.Add(newRoad);
			break;
		case 1:
			SideRoads.Add(newRoad);
			break;
		case 2:
			TrailRoads.Add(newRoad);
			break;
		default:
			MainRoads.Add(newRoad);
			break;
		}
		if (addToMaster && newRoad != null)
		{
			Roads.Add(newRoad);
		}
	}
}


public enum InfrastructureType
{
	Road,
	Power,
	Trail,
	Tunnel,
	UnderwaterLab,
	Boat,
	Rail
}


using UnityEngine;

public class TerrainPhysics : TerrainExtension
{
	private TerrainSplatMap splat;

	private PhysicMaterial[] materials;

	public override void Setup()
	{
		splat = ((Component)terrain).GetComponent<TerrainSplatMap>();
		materials = config.GetPhysicMaterials();
	}

	public PhysicMaterial GetMaterial(Vector3 worldPos)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)splat == (Object)null || materials.Length == 0)
		{
			return null;
		}
		return materials[splat.GetSplatMaxIndex(worldPos)];
	}
}


public class TerrainQuality : TerrainExtension
{
}


using System;
using Rust;
using TerrainTexturingJobs;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[ExecuteInEditMode]
public class TerrainTexturing : TerrainExtension
{
	public struct ShoreVectorQueryStructure
	{
		public ReadOnly<float> ShoreDistances;

		public float ShoreDistanceScale;

		public int ShoreMapSize;

		public float GetCoarseDistanceToShore(Vector2 uv)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			int shoreMapSize = ShoreMapSize;
			int num = shoreMapSize - 1;
			float num2 = uv.x * (float)num;
			float num3 = uv.y * (float)num;
			int num4 = (int)num2;
			int num5 = (int)num3;
			float num6 = num2 - (float)num4;
			float num7 = num3 - (float)num5;
			num4 = ((num4 >= 0) ? num4 : 0);
			num5 = ((num5 >= 0) ? num5 : 0);
			num4 = ((num4 <= num) ? num4 : num);
			num5 = ((num5 <= num) ? num5 : num);
			int num8 = ((num2 < (float)num) ? 1 : 0);
			int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
			int num10 = num5 * shoreMapSize + num4;
			int num11 = num10 + num8;
			int num12 = num10 + num9;
			int num13 = num12 + num8;
			float num14 = ShoreDistances[num10];
			float num15 = ShoreDistances[num11];
			float num16 = ShoreDistances[num12];
			float num17 = ShoreDistances[num13];
			float num18 = (num15 - num14) * num6 + num14;
			return (((num17 - num16) * num6 + num16 - num18) * num7 + num18) * ShoreDistanceScale;
		}
	}

	public bool debugFoliageDisplacement;

	private bool initialized;

	private static TerrainTexturing instance;

	private int afCached;

	private int globalTextureMipmapLimitCached;

	private int anisotropicFilteringCached;

	private bool streamingMipmapsActiveCached;

	private bool billboardsFaceCameraPositionCached;

	private const int ShoreVectorDownscale = 1;

	private const int ShoreVectorBlurPasses = 1;

	private float terrainSize;

	private int shoreMapSize;

	private float shoreDistanceScale;

	private NativeArray<float> shoreDistances;

	private NativeArray<float4> shoreVectors;

	public static TerrainTexturing Instance => instance;

	public bool TexturesInitialized => initialized;

	public int ShoreMapSize => shoreMapSize;

	public ReadOnlySpan<float4> ShoreMap => NativeArray<float4>.op_Implicit(ref shoreVectors);

	private void ReleaseBasePyramid()
	{
	}

	private void UpdateBasePyramid()
	{
	}

	private void InitializeCoarseHeightSlope()
	{
	}

	private void ReleaseCoarseHeightSlope()
	{
	}

	private void UpdateCoarseHeightSlope()
	{
	}

	private void CheckInstance()
	{
		instance = (((Object)(object)instance != (Object)null) ? instance : this);
	}

	private void Awake()
	{
		CheckInstance();
	}

	public override void Setup()
	{
		CheckInstance();
		InitializeShoreVector();
	}

	public override void PostSetup()
	{
		TerrainMeta component = ((Component)this).GetComponent<TerrainMeta>();
		if ((Object)(object)component == (Object)null || (Object)(object)component.config == (Object)null)
		{
			Debug.LogError((object)"[TerrainTexturing] Missing TerrainMeta or TerrainConfig not assigned.");
			return;
		}
		Shutdown();
		InitializeCoarseHeightSlope();
		GenerateShoreVector();
		InitializeWaterHeight();
		initialized = true;
	}

	private void Shutdown()
	{
		ReleaseBasePyramid();
		ReleaseCoarseHeightSlope();
		ReleaseShoreVector();
		ReleaseWaterHeight();
		initialized = false;
	}

	public void OnEnable()
	{
		CheckInstance();
	}

	private void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Shutdown();
		}
	}

	private void Update()
	{
		if (initialized)
		{
			UpdateBasePyramid();
			UpdateCoarseHeightSlope();
			UpdateWaterHeight();
		}
	}

	private void InitializeShoreVector()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.ClosestPowerOfTwo(terrain.terrainData.heightmapResolution) >> 1;
		int num2 = num * num;
		terrainSize = Mathf.Max(terrain.terrainData.size.x, terrain.terrainData.size.z);
		shoreMapSize = num;
		shoreDistanceScale = terrainSize / (float)shoreMapSize;
		shoreDistances = new NativeArray<float>(num * num, (Allocator)4, (NativeArrayOptions)0);
		shoreVectors = new NativeArray<float4>(num * num, (Allocator)4, (NativeArrayOptions)0);
		for (int i = 0; i < num2; i++)
		{
			shoreDistances[i] = 10000f;
			shoreVectors[i] = new float4(1f, 1f, 1f, 0f);
		}
	}

	private void GenerateShoreVector()
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GenerateShoreVector", 500);
		try
		{
			GenerateShoreVector(out var distances, out var vectors);
			if (!shoreDistances.IsCreated)
			{
				shoreDistances = new NativeArray<float>(distances, (Allocator)4);
			}
			else
			{
				shoreDistances.CopyFrom(distances);
			}
			if (!shoreVectors.IsCreated)
			{
				shoreVectors = new NativeArray<float4>(vectors.Length, (Allocator)4, (NativeArrayOptions)0);
			}
			for (int i = 0; i < vectors.Length; i++)
			{
				shoreVectors[i] = float4.op_Implicit(vectors[i]);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void OnDestroy()
	{
		ReleaseShoreVector();
	}

	private void ReleaseShoreVector()
	{
		NativeArrayEx.SafeDispose(ref shoreDistances);
		shoreVectors.SafeDispose<float4>();
	}

	private void GenerateShoreVector(out float[] distances, out Vector4[] vectors)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0264: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0300: Unknown result type (might be due to invalid IL or missing references)
		//IL_0306: Unknown result type (might be due to invalid IL or missing references)
		//IL_0308: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_0208: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GenerateShoreVector", 0);
		try
		{
			float upscaleCoords = terrainSize / (float)shoreMapSize;
			Vector3 terrainPosition = terrain.GetPosition();
			byte[] image = new byte[shoreMapSize * shoreMapSize];
			distances = new float[shoreMapSize * shoreMapSize];
			vectors = (Vector4[])(object)new Vector4[shoreMapSize * shoreMapSize];
			TimeWarning val2 = TimeWarning.New("WaterDepth", 0);
			try
			{
				int i = 0;
				int num = 0;
				for (; i < shoreMapSize; i++)
				{
					int num2 = 0;
					while (num2 < shoreMapSize)
					{
						float num3 = ((float)num2 + 0.5f) * upscaleCoords;
						float num4 = ((float)i + 0.5f) * upscaleCoords;
						bool flag = WaterLevel.GetOverallWaterDepth(new Vector3(terrainPosition.x, 0f, terrainPosition.z) + new Vector3(num3, 0f, num4), waves: false, volumes: false) <= 0f;
						image[num] = (byte)(flag ? 255u : 0u);
						distances[num] = (flag ? 256 : 0);
						num2++;
						num++;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("DistanceField.XXX", 0);
			try
			{
				DistanceField.Generate(in shoreMapSize, (byte)127, in image, ref distances);
				DistanceField.ApplyGaussianBlur(shoreMapSize, distances);
				DistanceField.GenerateVectors(in shoreMapSize, in distances, ref vectors);
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			val2 = TimeWarning.New("Parallel.For", 0);
			try
			{
				if (!((Object)(object)TerrainMeta.TopologyMap != (Object)null) || !TerrainMeta.TopologyMap.isInitialized || !((Object)(object)TerrainMeta.HeightMap != (Object)null) || !TerrainMeta.HeightMap.isInitialized)
				{
					for (int j = 0; j < vectors.Length; j++)
					{
						Vector4 val3 = vectors[j];
						val3.w = -1f;
						vectors[j] = val3;
					}
					return;
				}
				NativeArray<Vector3> positions = new NativeArray<Vector3>(shoreMapSize * ShoreMapSize, (Allocator)3, (NativeArrayOptions)1);
				NativeArray<float> radii = new NativeArray<float>(shoreMapSize * shoreMapSize, (Allocator)3, (NativeArrayOptions)1);
				NativeArray<int> topologies = new NativeArray<int>(shoreMapSize * shoreMapSize, (Allocator)3, (NativeArrayOptions)1);
				Parallel.For(0, shoreMapSize, (Action<int>)delegate(int z)
				{
					//IL_0042: Unknown result type (might be due to invalid IL or missing references)
					//IL_004e: Unknown result type (might be due to invalid IL or missing references)
					//IL_0053: Unknown result type (might be due to invalid IL or missing references)
					//IL_0058: Unknown result type (might be due to invalid IL or missing references)
					//IL_005e: Unknown result type (might be due to invalid IL or missing references)
					//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
					float num5 = ((float)z + 0.5f) * upscaleCoords;
					for (int k = 0; k < shoreMapSize; k++)
					{
						float num6 = ((float)k + 0.5f) * upscaleCoords;
						Vector3 val4 = new Vector3(terrainPosition.x, 0f, terrainPosition.z) + new Vector3(num6, 0f, num5);
						float height = TerrainMeta.HeightMap.GetHeight(val4);
						float num7 = Mathf.InverseLerp(4f, 0f, height);
						float num8 = Mathf.Lerp(16f, 32f, num7);
						positions[z * shoreMapSize + k] = val4;
						radii[z * shoreMapSize + k] = num8;
					}
				});
				TerrainMeta.TopologyMap.GetTopologiesIndirect(positions.AsReadOnly(), radii.AsReadOnly(), topologies);
				Vector4[] captureVec = vectors;
				Parallel.For(0, shoreMapSize, (Action<int>)delegate(int z)
				{
					//IL_001c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0021: Unknown result type (might be due to invalid IL or missing references)
					//IL_0095: Unknown result type (might be due to invalid IL or missing references)
					//IL_0096: Unknown result type (might be due to invalid IL or missing references)
					for (int l = 0; l < shoreMapSize; l++)
					{
						Vector4 val5 = captureVec[z * shoreMapSize + l];
						int num9 = topologies[z * shoreMapSize + l];
						if ((num9 & 0x180) != 0)
						{
							val5.w = 1f;
						}
						else if ((num9 & 0x32000) != 0)
						{
							val5.w = 2f;
						}
						else if ((num9 & 0xC000) != 0)
						{
							val5.w = 3f;
						}
						captureVec[z * shoreMapSize + l] = val5;
					}
				});
				positions.Dispose(default(JobHandle));
				radii.Dispose(default(JobHandle));
				topologies.Dispose(default(JobHandle));
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetCoarseDistanceToShore(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - TerrainMeta.Position.x) * TerrainMeta.OneOverSize.x;
		uv.y = (pos.z - TerrainMeta.Position.z) * TerrainMeta.OneOverSize.z;
		return GetCoarseDistanceToShore(uv);
	}

	public ShoreVectorQueryStructure GetShoreVectorQueryStructure()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		ShoreVectorQueryStructure result = default(ShoreVectorQueryStructure);
		result.ShoreDistances = shoreDistances.AsReadOnly();
		result.ShoreDistanceScale = shoreDistanceScale;
		result.ShoreMapSize = shoreMapSize;
		return result;
	}

	public float GetCoarseDistanceToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		int num = shoreMapSize;
		int num2 = num - 1;
		float num3 = uv.x * (float)num2;
		float num4 = uv.y * (float)num2;
		int num5 = (int)num3;
		int num6 = (int)num4;
		float num7 = num3 - (float)num5;
		float num8 = num4 - (float)num6;
		num5 = ((num5 >= 0) ? num5 : 0);
		num6 = ((num6 >= 0) ? num6 : 0);
		num5 = ((num5 <= num2) ? num5 : num2);
		num6 = ((num6 <= num2) ? num6 : num2);
		int num9 = ((num3 < (float)num2) ? 1 : 0);
		int num10 = ((num4 < (float)num2) ? num : 0);
		int num11 = num6 * num + num5;
		int num12 = num11 + num9;
		int num13 = num11 + num10;
		int num14 = num13 + num9;
		float num15 = shoreDistances[num11];
		float num16 = shoreDistances[num12];
		float num17 = shoreDistances[num13];
		float num18 = shoreDistances[num14];
		float num19 = (num16 - num15) * num7 + num15;
		return (((num18 - num17) * num7 + num17 - num19) * num8 + num19) * shoreDistanceScale;
	}

	public void GetCoarseDistancesToShoreIndirect(ReadOnly<Vector2> uvs, ReadOnly<int> indices, NativeArray<float> results)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		GetCoarseDistsToShoreJobIndirect getCoarseDistsToShoreJobIndirect = default(GetCoarseDistsToShoreJobIndirect);
		getCoarseDistsToShoreJobIndirect.Dists = results;
		getCoarseDistsToShoreJobIndirect.UVs = uvs;
		getCoarseDistsToShoreJobIndirect.Indices = indices;
		getCoarseDistsToShoreJobIndirect.Data = shoreDistances.AsReadOnly();
		getCoarseDistsToShoreJobIndirect.ShoreMapSize = shoreMapSize;
		getCoarseDistsToShoreJobIndirect.ShoreDistanceScale = shoreDistanceScale;
		GetCoarseDistsToShoreJobIndirect getCoarseDistsToShoreJobIndirect2 = getCoarseDistsToShoreJobIndirect;
		IJobExtensions.RunByRef<GetCoarseDistsToShoreJobIndirect>(ref getCoarseDistsToShoreJobIndirect2);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - TerrainMeta.Position.x) * TerrainMeta.OneOverSize.x;
		uv.y = (pos.z - TerrainMeta.Position.z) * TerrainMeta.OneOverSize.z;
		return GetCoarseVectorToShore(uv);
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0165: Unknown result type (might be due to invalid IL or missing references)
		//IL_0174: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		int num = shoreMapSize;
		int num2 = num - 1;
		float num3 = uv.x * (float)num2;
		float num4 = uv.y * (float)num2;
		int num5 = (int)num3;
		int num6 = (int)num4;
		float num7 = num3 - (float)num5;
		float num8 = num4 - (float)num6;
		num5 = ((num5 >= 0) ? num5 : 0);
		num6 = ((num6 >= 0) ? num6 : 0);
		num5 = ((num5 <= num2) ? num5 : num2);
		num6 = ((num6 <= num2) ? num6 : num2);
		int num9 = ((num3 < (float)num2) ? 1 : 0);
		int num10 = ((num4 < (float)num2) ? num : 0);
		int num11 = num6 * num + num5;
		int num12 = num11 + num9;
		int num13 = num11 + num10;
		int num14 = num13 + num9;
		float4 val = shoreVectors[num11];
		float3 xyz = ((float4)(ref val)).xyz;
		val = shoreVectors[num12];
		float3 xyz2 = ((float4)(ref val)).xyz;
		val = shoreVectors[num13];
		float3 xyz3 = ((float4)(ref val)).xyz;
		val = shoreVectors[num14];
		float3 xyz4 = ((float4)(ref val)).xyz;
		Vector3 val2 = default(Vector3);
		val2.x = (xyz2.x - xyz.x) * num7 + xyz.x;
		val2.y = (xyz2.y - xyz.y) * num7 + xyz.y;
		val2.z = (xyz2.z - xyz.z) * num7 + xyz.z;
		Vector3 val3 = default(Vector3);
		val3.x = (xyz4.x - xyz3.x) * num7 + xyz3.x;
		val3.y = (xyz4.y - xyz3.y) * num7 + xyz3.y;
		val3.z = (xyz4.z - xyz3.z) * num7 + xyz3.z;
		float num15 = (val3.x - val2.x) * num8 + val2.x;
		float num16 = (val3.y - val2.y) * num8 + val2.y;
		return new ValueTuple<Vector3, float>(item2: ((val3.z - val2.z) * num8 + val2.z) * shoreDistanceScale, item1: new Vector3(num15, 0f, num16));
	}

	public (Vector3 shoreDir, float shoreDist) GetCoarseVectorToShore(float normX, float normY)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		return this.GetCoarseVectorToShore(new Vector2(normX, normY));
	}

	public Vector4 GetRawShoreVector(Vector3 pos)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		Vector2 uv = default(Vector2);
		uv.x = (pos.x - TerrainMeta.Position.x) * TerrainMeta.OneOverSize.x;
		uv.y = (pos.z - TerrainMeta.Position.z) * TerrainMeta.OneOverSize.z;
		return GetRawShoreVector(uv);
	}

	public Vector4 GetRawShoreVector(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		int num = shoreMapSize;
		int num2 = num - 1;
		float num3 = uv.x * (float)num2;
		float num4 = uv.y * (float)num2;
		int num5 = (int)num3;
		int num6 = (int)num4;
		num5 = ((num5 >= 0) ? num5 : 0);
		num6 = ((num6 >= 0) ? num6 : 0);
		num5 = ((num5 <= num2) ? num5 : num2);
		num6 = ((num6 <= num2) ? num6 : num2);
		return float4.op_Implicit(shoreVectors[num6 * num + num5]);
	}

	private void InitializeWaterHeight()
	{
	}

	private void ReleaseWaterHeight()
	{
	}

	private void UpdateWaterHeight()
	{
	}
}


using Unity.Collections;
using UnityEngine;

public struct ShoreVectorQueryStructure
{
	public ReadOnly<float> ShoreDistances;

	public float ShoreDistanceScale;

	public int ShoreMapSize;

	public float GetCoarseDistanceToShore(Vector2 uv)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		int shoreMapSize = ShoreMapSize;
		int num = shoreMapSize - 1;
		float num2 = uv.x * (float)num;
		float num3 = uv.y * (float)num;
		int num4 = (int)num2;
		int num5 = (int)num3;
		float num6 = num2 - (float)num4;
		float num7 = num3 - (float)num5;
		num4 = ((num4 >= 0) ? num4 : 0);
		num5 = ((num5 >= 0) ? num5 : 0);
		num4 = ((num4 <= num) ? num4 : num);
		num5 = ((num5 <= num) ? num5 : num);
		int num8 = ((num2 < (float)num) ? 1 : 0);
		int num9 = ((num3 < (float)num) ? shoreMapSize : 0);
		int num10 = num5 * shoreMapSize + num4;
		int num11 = num10 + num8;
		int num12 = num10 + num9;
		int num13 = num12 + num8;
		float num14 = ShoreDistances[num10];
		float num15 = ShoreDistances[num11];
		float num16 = ShoreDistances[num12];
		float num17 = ShoreDistances[num13];
		float num18 = (num15 - num14) * num6 + num14;
		return (((num17 - num16) * num6 + num16 - num18) * num7 + num18) * ShoreDistanceScale;
	}
}


internal enum TextureCacheState
{
	Initializing,
	Uncached,
	CachedRaw,
	CachedCompressed
}


using UnityEngine;

public class TerrainTreeBatch : MonoBehaviour
{
}


using UnityEngine;

public class TreeMesh : MonoBehaviour
{
}


using System;
using UnityEngine;

public class TerrainFilter : PrefabAttribute
{
	public SpawnFilter Filter;

	public bool CheckPlacementMap = true;

	public bool CheckTerrainBounds;

	public float CheckTopologyRadius;

	public bool Check(Vector3 pos)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		if (CheckTerrainBounds && TerrainMeta.OutOfBounds(pos))
		{
			return false;
		}
		return Filter.GetFactor(pos, CheckPlacementMap, CheckTopologyRadius) > 0f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(TerrainFilter);
	}
}


using UnityEngine;

public static class TerrainFilterEx
{
	public static bool ApplyTerrainFilters(this Transform transform, TerrainFilter[] filters, Vector3 pos, Quaternion rot, Vector3 scale, SpawnFilter globalFilter = null)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if (filters.Length == 0)
		{
			return true;
		}
		foreach (TerrainFilter terrainFilter in filters)
		{
			Vector3 val = Vector3.Scale(terrainFilter.worldPosition, scale);
			val = rot * val;
			Vector3 val2 = pos + val;
			if (globalFilter != null && globalFilter.GetFactor(val2) == 0f)
			{
				return false;
			}
			if (!terrainFilter.Check(val2))
			{
				return false;
			}
		}
		return true;
	}
}


using UnityEngine;

public class TerrainFilterGenerator : MonoBehaviour, IEditorComponent
{
	public float PlacementRadius = 32f;

	public float PlacementDistance = 8f;

	public SpawnFilter Filter;

	public bool CheckPlacementMap = true;
}


using UnityEngine;

public class CollateTrainTracks : ProceduralComponent
{
	private const float MAX_NODE_DIST = 0.1f;

	private const float MAX_NODE_DIST_SQR = 0.010000001f;

	private const float MAX_NODE_ANGLE = 10f;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018c: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_028d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		TrainTrackSpline[] array = Object.FindObjectsOfType<TrainTrackSpline>();
		TrainTrackSpline[] array2;
		for (int num = array.Length - 1; num >= 0; num--)
		{
			TrainTrackSpline ourSpline = array[num];
			if (ourSpline.dataIndex < 0 && ourSpline.points.Length > 3)
			{
				int nodeIndex;
				for (nodeIndex = ourSpline.points.Length - 2; nodeIndex >= 1; nodeIndex--)
				{
					Vector3 ourPos2 = ourSpline.points[nodeIndex];
					Vector3 ourTangent2 = ourSpline.tangents[nodeIndex];
					array2 = array;
					foreach (TrainTrackSpline trainTrackSpline in array2)
					{
						if (!((Object)(object)ourSpline == (Object)(object)trainTrackSpline))
						{
							Vector3 startPointWorld = trainTrackSpline.GetStartPointWorld();
							Vector3 endPointWorld = trainTrackSpline.GetEndPointWorld();
							Vector3 startTangentWorld = trainTrackSpline.GetStartTangentWorld();
							Vector3 endTangentWorld = trainTrackSpline.GetEndTangentWorld();
							if (!CompareNodes(startPointWorld, startTangentWorld) && !CompareNodes(endPointWorld, endTangentWorld) && !CompareNodes(startPointWorld, -startTangentWorld))
							{
								CompareNodes(endPointWorld, -endTangentWorld);
							}
						}
					}
					bool CompareNodes(Vector3 theirPos, Vector3 theirTangent)
					{
						//IL_0002: Unknown result type (might be due to invalid IL or missing references)
						//IL_0007: Unknown result type (might be due to invalid IL or missing references)
						//IL_000a: Unknown result type (might be due to invalid IL or missing references)
						//IL_000f: Unknown result type (might be due to invalid IL or missing references)
						//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
						//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
						//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
						//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
						//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
						//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
						//IL_0113: Unknown result type (might be due to invalid IL or missing references)
						//IL_0118: Unknown result type (might be due to invalid IL or missing references)
						if (NodesConnect(ourPos2, theirPos, ourTangent2, theirTangent))
						{
							TrainTrackSpline trainTrackSpline2 = ((Component)ourSpline).gameObject.AddComponent<TrainTrackSpline>();
							Vector3[] array4 = (Vector3[])(object)new Vector3[ourSpline.points.Length - nodeIndex];
							Vector3[] array5 = (Vector3[])(object)new Vector3[ourSpline.points.Length - nodeIndex];
							Vector3[] array6 = (Vector3[])(object)new Vector3[nodeIndex + 1];
							Vector3[] array7 = (Vector3[])(object)new Vector3[nodeIndex + 1];
							for (int num2 = ourSpline.points.Length - 1; num2 >= 0; num2--)
							{
								if (num2 >= nodeIndex)
								{
									array4[num2 - nodeIndex] = ourSpline.points[num2];
									array5[num2 - nodeIndex] = ourSpline.tangents[num2];
								}
								if (num2 <= nodeIndex)
								{
									array6[num2] = ourSpline.points[num2];
									array7[num2] = ourSpline.tangents[num2];
								}
							}
							ourSpline.SetAll(array6, array7, ourSpline);
							trainTrackSpline2.SetAll(array4, array5, ourSpline);
							nodeIndex--;
							return true;
						}
						return false;
					}
				}
			}
		}
		array = Object.FindObjectsOfType<TrainTrackSpline>();
		array2 = array;
		foreach (TrainTrackSpline ourSpline2 in array2)
		{
			Vector3 ourStartPos = ourSpline2.GetStartPointWorld();
			Vector3 ourEndPos = ourSpline2.GetEndPointWorld();
			Vector3 ourStartTangent = ourSpline2.GetStartTangentWorld();
			Vector3 ourEndTangent = ourSpline2.GetEndTangentWorld();
			if (NodesConnect(ourStartPos, ourEndPos, ourStartTangent, ourEndTangent))
			{
				ourSpline2.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Next, TrainTrackSpline.TrackOrientation.Same);
				ourSpline2.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Prev, TrainTrackSpline.TrackOrientation.Same);
				continue;
			}
			TrainTrackSpline[] array3 = array;
			foreach (TrainTrackSpline otherSpline in array3)
			{
				Vector3 theirStartPos;
				Vector3 theirEndPos;
				Vector3 theirStartTangent;
				Vector3 theirEndTangent;
				if (!((Object)(object)ourSpline2 == (Object)(object)otherSpline))
				{
					theirStartPos = otherSpline.GetStartPointWorld();
					theirEndPos = otherSpline.GetEndPointWorld();
					theirStartTangent = otherSpline.GetStartTangentWorld();
					theirEndTangent = otherSpline.GetEndTangentWorld();
					if (!CompareNodes(ourStart: false, theirStart: true) && !CompareNodes(ourStart: false, theirStart: false) && !CompareNodes(ourStart: true, theirStart: true))
					{
						CompareNodes(ourStart: true, theirStart: false);
					}
				}
				bool CompareNodes(bool ourStart, bool theirStart)
				{
					//IL_000c: Unknown result type (might be due to invalid IL or missing references)
					//IL_0004: Unknown result type (might be due to invalid IL or missing references)
					//IL_001d: Unknown result type (might be due to invalid IL or missing references)
					//IL_0015: Unknown result type (might be due to invalid IL or missing references)
					//IL_0022: Unknown result type (might be due to invalid IL or missing references)
					//IL_0031: Unknown result type (might be due to invalid IL or missing references)
					//IL_0028: Unknown result type (might be due to invalid IL or missing references)
					//IL_0036: Unknown result type (might be due to invalid IL or missing references)
					//IL_0045: Unknown result type (might be due to invalid IL or missing references)
					//IL_003c: Unknown result type (might be due to invalid IL or missing references)
					//IL_004a: Unknown result type (might be due to invalid IL or missing references)
					//IL_005b: Unknown result type (might be due to invalid IL or missing references)
					//IL_005c: Unknown result type (might be due to invalid IL or missing references)
					//IL_005d: Unknown result type (might be due to invalid IL or missing references)
					//IL_004f: Unknown result type (might be due to invalid IL or missing references)
					//IL_0055: Unknown result type (might be due to invalid IL or missing references)
					//IL_005a: Unknown result type (might be due to invalid IL or missing references)
					Vector3 ourPos3 = (ourStart ? ourStartPos : ourEndPos);
					Vector3 ourTangent3 = (ourStart ? ourStartTangent : ourEndTangent);
					Vector3 theirPos2 = (theirStart ? theirStartPos : theirEndPos);
					Vector3 val = (theirStart ? theirStartTangent : theirEndTangent);
					if (ourStart == theirStart)
					{
						val *= -1f;
					}
					if (NodesConnect(ourPos3, theirPos2, ourTangent3, val))
					{
						if (ourStart)
						{
							ourSpline2.AddTrackConnection(otherSpline, TrainTrackSpline.TrackPosition.Prev, theirStart ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						else
						{
							ourSpline2.AddTrackConnection(otherSpline, TrainTrackSpline.TrackPosition.Next, (!theirStart) ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						if (theirStart)
						{
							otherSpline.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Prev, ourStart ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						else
						{
							otherSpline.AddTrackConnection(ourSpline2, TrainTrackSpline.TrackPosition.Next, (!ourStart) ? TrainTrackSpline.TrackOrientation.Reverse : TrainTrackSpline.TrackOrientation.Same);
						}
						return true;
					}
					return false;
				}
			}
		}
		static bool NodesConnect(Vector3 ourPos, Vector3 theirPos, Vector3 ourTangent, Vector3 theirTangent)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			if (Vector3.SqrMagnitude(ourPos - theirPos) < 0.010000001f)
			{
				return Vector3.Angle(ourTangent, theirTangent) < 10f;
			}
			return false;
		}
	}
}


using UnityEngine;

public class MonumentNode : MonoBehaviour
{
	public string ResourceFolder = string.Empty;

	protected void Awake()
	{
		if (!((Object)(object)SingletonComponent<WorldSetup>.Instance == (Object)null))
		{
			if (SingletonComponent<WorldSetup>.Instance.MonumentNodes == null)
			{
				Debug.LogError((object)"WorldSetup.Instance.MonumentNodes is null.", (Object)(object)this);
			}
			else
			{
				SingletonComponent<WorldSetup>.Instance.MonumentNodes.Add(this);
			}
		}
	}

	public void Process(ref uint seed)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (World.Networked)
		{
			World.Spawn("Monument", "assets/bundled/prefabs/autospawn/" + ResourceFolder + "/");
			return;
		}
		Prefab<MonumentInfo>[] array = Prefab.Load<MonumentInfo>("assets/bundled/prefabs/autospawn/" + ResourceFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: true);
		if (array != null && array.Length != 0)
		{
			Prefab<MonumentInfo> random = array.GetRandom(ref seed);
			float height = TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position);
			Vector3 pos = default(Vector3);
			((Vector3)(ref pos))..ctor(((Component)this).transform.position.x, height, ((Component)this).transform.position.z);
			Quaternion rot = random.Object.transform.localRotation;
			Vector3 scale = random.Object.transform.localScale;
			random.ApplyDecorComponents(ref pos, ref rot, ref scale);
			World.AddPrefab("Monument", random, pos, rot, scale);
		}
	}
}


using UnityEngine;

public abstract class ProceduralComponent : MonoBehaviour
{
	public enum Realm
	{
		Client = 1,
		Server
	}

	[InspectorFlags]
	public Realm Mode = (Realm)(-1);

	public string Description = "Procedural Component";

	public virtual bool RunOnCache => false;

	public bool ShouldRun()
	{
		if (World.Cached && !RunOnCache)
		{
			return false;
		}
		if ((Mode & Realm.Server) != 0)
		{
			return true;
		}
		return false;
	}

	public abstract void Process(uint seed);
}


public enum Realm
{
	Client = 1,
	Server
}


using System.Runtime.InteropServices;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class GenerateBiome : ProceduralComponent
{
	[DllImport("RustNative", EntryPoint = "generate_biome")]
	public unsafe static extern void Native_GenerateBiome(byte* nativeArrayPtr, int res, Vector3 pos, Vector3 size, uint seed, float lootAngle, float lootTier0, float lootTier1, float lootTier2, float biomeAngle, float biomeArid, float biomeTemperate, float biomeTundra, float biomeArctic, float biomeJungle, short* heightmap, int heightres);

	public unsafe override void Process(uint seed)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		byte* unsafePtr = (byte*)NativeArrayUnsafeUtility.GetUnsafePtr<byte>(TerrainMeta.BiomeMap.dst);
		int res = TerrainMeta.BiomeMap.res;
		Vector3 position = TerrainMeta.Position;
		Vector3 size = TerrainMeta.Size;
		float lootAxisAngle = TerrainMeta.LootAxisAngle;
		float biomeAxisAngle = TerrainMeta.BiomeAxisAngle;
		short* unsafePtr2 = (short*)NativeArrayUnsafeUtility.GetUnsafePtr<short>(TerrainMeta.HeightMap.src);
		int res2 = TerrainMeta.HeightMap.res;
		Native_GenerateBiome(unsafePtr, res, position, size, seed, lootAxisAngle, World.Config.PercentageTier0, World.Config.PercentageTier1, World.Config.PercentageTier2, biomeAxisAngle, World.Config.PercentageBiomeArid, World.Config.PercentageBiomeTemperate, World.Config.PercentageBiomeTundra, World.Config.PercentageBiomeArctic, World.Config.PercentageBiomeJungle, unsafePtr2, res2);
	}
}


using System;
using UnityEngine;

public class GenerateCliffSplat : ProceduralComponent
{
	private const int filter = 8389632;

	public static void Process(int x, int z)
	{
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		float normZ = splatMap.Coordinate(z);
		float normX = splatMap.Coordinate(x);
		if ((TerrainMeta.TopologyMap.GetTopology(normX, normZ) & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			if (slope > 30f)
			{
				splatMap.SetSplat(x, z, 8, Mathf.InverseLerp(30f, 50f, slope));
			}
		}
	}

	public override void Process(uint seed)
	{
		TerrainSplatMap splatMap = TerrainMeta.SplatMap;
		int splatres = splatMap.res;
		Parallel.For(0, splatres, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < splatres; i++)
			{
				Process(i, z);
			}
		});
	}
}


using System;
using Unity.Collections;
using UnityEngine;

public class GenerateCliffTopology : ProceduralComponent
{
	public bool KeepExisting = true;

	private const float slopeCutoff = 30f;

	private const float splatCutoff = 0.4f;

	private const int filter = 8389632;

	public static void Process(int x, int z)
	{
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		float normZ = topologyMap.Coordinate(z);
		float normX = topologyMap.Coordinate(x);
		if ((topologyMap.GetTopology(x, z) & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			float splat = TerrainMeta.SplatMap.GetSplat(normX, normZ, 8);
			if (slope > 30f || splat > 0.4f)
			{
				topologyMap.AddTopology(x, z, 2);
			}
			else
			{
				topologyMap.RemoveTopology(x, z, 2);
			}
		}
	}

	private static void Process(int x, int z, bool keepExisting)
	{
		TerrainTopologyMap topologyMap = TerrainMeta.TopologyMap;
		float normZ = topologyMap.Coordinate(z);
		float normX = topologyMap.Coordinate(x);
		int topology = topologyMap.GetTopology(x, z);
		if (!World.Procedural || (topology & 0x800400) == 0)
		{
			float slope = TerrainMeta.HeightMap.GetSlope(normX, normZ);
			float splat = TerrainMeta.SplatMap.GetSplat(normX, normZ, 8);
			if (slope > 30f || splat > 0.4f)
			{
				topologyMap.AddTopology(x, z, 2);
			}
			else if (!keepExisting)
			{
				topologyMap.RemoveTopology(x, z, 2);
			}
		}
	}

	public override void Process(uint seed)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<int> map = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		Parallel.For(0, res, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < res; i++)
			{
				Process(i, z, KeepExisting);
			}
		});
		ImageProcessing.Dilate2D(map, res, res, 4194306, 1, delegate(int x, int y)
		{
			if ((map[x * res + y] & 2) == 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x400000;
			}
		});
	}
}


using Unity.Collections;

public class GenerateClutterTopology : ProceduralComponent
{
	public override void Process(uint seed)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<int> map = TerrainMeta.TopologyMap.dst;
		int res = TerrainMeta.TopologyMap.res;
		ImageProcessing.Dilate2D(map, res, res, 16777728, 3, delegate(int x, int y)
		{
			if ((map[x * res + y] & 0x200) == 0)
			{
				ref NativeArray<int> reference = ref map;
				int num = x * res + y;
				reference[num] |= 0x1000000;
			}
		});
	}
}


using System;
using UnityEngine;

public class GenerateDecorTopology : ProceduralComponent
{
	public bool KeepExisting = true;

	public override void Process(uint seed)
	{
		TerrainTopologyMap topomap = TerrainMeta.TopologyMap;
		int topores = topomap.res;
		Parallel.For(0, topores, (Action<int>)delegate(int z)
		{
			for (int i = 0; i < topores; i++)
			{
				if (topomap.GetTopology(i, z, 4194306))
				{
					topomap.AddTopology(i, z, 512);
				}
				else if (!KeepExisting)
				{
					topomap.RemoveTopology(i, z, 512);
				}
			}
		});
	}
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateDungeonBase : ProceduralComponent
{
	private class DungeonSegment
	{
		public Vector3 position;

		public Quaternion rotation;

		public Prefab prefab;

		public DungeonBaseLink link;

		public int score;

		public int cost;

		public int floor;
	}

	public string EntranceFolder = string.Empty;

	public string LinkFolder = string.Empty;

	public string EndFolder = string.Empty;

	public string TransitionFolder = string.Empty;

	public InfrastructureType ConnectionType = InfrastructureType.UnderwaterLab;

	private static Vector3 VolumeExtrudePositive = Vector3.one * 0.01f;

	private static Vector3 VolumeExtrudeNegative = Vector3.one * -0.01f;

	private const int MaxCount = int.MaxValue;

	private const int MaxDepth = 3;

	private const int MaxFloor = 2;

	private List<DungeonSegment> segmentsTotal = new List<DungeonSegment>();

	private Quaternion[] horizontalRotations = (Quaternion[])(object)new Quaternion[1] { Quaternion.Euler(0f, 0f, 0f) };

	private Quaternion[] pillarRotations = (Quaternion[])(object)new Quaternion[4]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 270f, 0f)
	};

	private Quaternion[] verticalRotations = (Quaternion[])(object)new Quaternion[8]
	{
		Quaternion.Euler(0f, 0f, 0f),
		Quaternion.Euler(0f, 45f, 0f),
		Quaternion.Euler(0f, 90f, 0f),
		Quaternion.Euler(0f, 135f, 0f),
		Quaternion.Euler(0f, 180f, 0f),
		Quaternion.Euler(0f, 225f, 0f),
		Quaternion.Euler(0f, 270f, 0f),
		Quaternion.Euler(0f, 315f, 0f)
	};

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0380: Unknown result type (might be due to invalid IL or missing references)
		//IL_0387: Unknown result type (might be due to invalid IL or missing references)
		//IL_038c: Unknown result type (might be due to invalid IL or missing references)
		if (World.Cached)
		{
			return;
		}
		if (World.Networked)
		{
			World.Spawn("DungeonBase");
		}
		else
		{
			if (ConnectionType == InfrastructureType.UnderwaterLab && !World.Config.UnderwaterLabs)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + EntranceFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array == null)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array2 = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + LinkFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array2 == null)
			{
				return;
			}
			Prefab<DungeonBaseLink>[] array3 = Prefab.Load<DungeonBaseLink>("assets/bundled/prefabs/autospawn/" + EndFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array3 == null)
			{
				return;
			}
			Prefab<DungeonBaseTransition>[] array4 = Prefab.Load<DungeonBaseTransition>("assets/bundled/prefabs/autospawn/" + TransitionFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array4 == null)
			{
				return;
			}
			foreach (DungeonBaseInfo item in Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.DungeonBaseEntrances : null)
			{
				TerrainPathConnect[] componentsInChildren = ((Component)item).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect obj in componentsInChildren)
				{
					if (obj.Type != ConnectionType)
					{
						continue;
					}
					uint seed2 = seed++;
					List<DungeonSegment> list = new List<DungeonSegment>();
					DungeonSegment segmentStart = new DungeonSegment();
					int num = 0;
					segmentStart.position = ((Component)item).transform.position;
					segmentStart.rotation = ((Component)item).transform.rotation;
					segmentStart.link = ((Component)item).GetComponentInChildren<DungeonBaseLink>();
					segmentStart.cost = 0;
					segmentStart.floor = 0;
					for (int j = 0; j < 25; j++)
					{
						List<DungeonSegment> list2 = new List<DungeonSegment>();
						list2.Add(segmentStart);
						PlaceSegments(ref seed2, int.MaxValue, 3, 2, attachToFemale: true, attachToMale: false, list2, array2);
						int num2 = list2.Count((DungeonSegment x) => x.link.MaxCountLocal != -1);
						if (num2 > num || (num2 == num && list2.Count > list.Count))
						{
							list = list2;
							num = num2;
						}
					}
					if (list.Count > 5)
					{
						list = list.OrderByDescending((DungeonSegment x) => Vector3Ex.SqrMagnitude2D(x.position - segmentStart.position)).ToList();
						PlaceSegments(ref seed2, 1, 4, 2, attachToFemale: true, attachToMale: false, list, array);
					}
					if (list.Count > 25)
					{
						DungeonSegment segmentEnd = list[list.Count - 1];
						list = list.OrderByDescending((DungeonSegment x) => Mathf.Min(Vector3Ex.SqrMagnitude2D(x.position - segmentStart.position), Vector3Ex.SqrMagnitude2D(x.position - segmentEnd.position))).ToList();
						PlaceSegments(ref seed2, 1, 5, 2, attachToFemale: true, attachToMale: false, list, array);
					}
					bool flag = true;
					while (flag)
					{
						flag = false;
						for (int k = 0; k < list.Count; k++)
						{
							DungeonSegment dungeonSegment = list[k];
							if (dungeonSegment.link.Cost <= 0 && !IsFullyOccupied(list, dungeonSegment))
							{
								list.RemoveAt(k--);
								flag = true;
							}
						}
					}
					PlaceSegments(ref seed2, int.MaxValue, int.MaxValue, 3, attachToFemale: true, attachToMale: true, list, array3);
					PlaceTransitions(ref seed2, list, array4);
					segmentsTotal.AddRange(list);
				}
			}
			foreach (DungeonSegment item2 in segmentsTotal)
			{
				if (item2.prefab != null)
				{
					World.AddPrefab("DungeonBase", item2.prefab, item2.position, item2.rotation, Vector3.one);
				}
			}
		}
	}

	private Quaternion[] GetRotationList(DungeonBaseSocketType type)
	{
		return type switch
		{
			DungeonBaseSocketType.Horizontal => horizontalRotations, 
			DungeonBaseSocketType.Vertical => verticalRotations, 
			DungeonBaseSocketType.Pillar => pillarRotations, 
			_ => null, 
		};
	}

	private int GetSocketFloor(DungeonBaseSocketType type)
	{
		if (type != DungeonBaseSocketType.Vertical)
		{
			return 0;
		}
		return 1;
	}

	private bool IsFullyOccupied(List<DungeonSegment> segments, DungeonSegment segment)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return SocketMatches(segments, segment.link, segment.position, segment.rotation) == segment.link.Sockets.Count;
	}

	private bool NeighbourMatches(List<DungeonSegment> segments, DungeonBaseTransition transition, Vector3 transitionPos, Quaternion transitionRot)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		bool flag = false;
		bool flag2 = false;
		foreach (DungeonSegment segment in segments)
		{
			Vector3 val;
			if ((Object)(object)segment.link == (Object)null)
			{
				val = segment.position - transitionPos;
				if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
				{
					flag = false;
					flag2 = false;
				}
				continue;
			}
			foreach (DungeonBaseSocket socket in segment.link.Sockets)
			{
				val = segment.position + segment.rotation * ((Component)socket).transform.localPosition - transitionPos;
				if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
				{
					if (!flag && segment.link.Type == transition.Neighbour1)
					{
						flag = true;
					}
					else if (!flag2 && segment.link.Type == transition.Neighbour2)
					{
						flag2 = true;
					}
				}
			}
		}
		return flag && flag2;
	}

	private int SocketMatches(List<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		foreach (DungeonSegment segment in segments)
		{
			foreach (DungeonBaseSocket socket in segment.link.Sockets)
			{
				Vector3 val = segment.position + segment.rotation * ((Component)socket).transform.localPosition;
				foreach (DungeonBaseSocket socket2 in link.Sockets)
				{
					if (!((Object)(object)socket == (Object)(object)socket2))
					{
						Vector3 val2 = linkPos + linkRot * ((Component)socket2).transform.localPosition;
						Vector3 val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							num++;
						}
					}
				}
			}
		}
		return num;
	}

	private bool IsOccupied(List<DungeonSegment> segments, DungeonBaseSocket socket, Vector3 socketPos, Quaternion socketRot)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		foreach (DungeonSegment segment in segments)
		{
			foreach (DungeonBaseSocket socket2 in segment.link.Sockets)
			{
				if (!((Object)(object)socket2 == (Object)(object)socket))
				{
					Vector3 val = segment.position + segment.rotation * ((Component)socket2).transform.localPosition - socketPos;
					if (((Vector3)(ref val)).sqrMagnitude < 0.01f)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private int CountLocal(List<DungeonSegment> segments, DungeonBaseLink link)
	{
		int num = 0;
		if ((Object)(object)link == (Object)null)
		{
			return num;
		}
		foreach (DungeonSegment segment in segments)
		{
			if (!((Object)(object)segment.link == (Object)null))
			{
				if ((Object)(object)segment.link == (Object)(object)link)
				{
					num++;
				}
				else if (segment.link.MaxCountIdentifier >= 0 && segment.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		return num;
	}

	private int CountGlobal(List<DungeonSegment> segments, DungeonBaseLink link)
	{
		int num = 0;
		if ((Object)(object)link == (Object)null)
		{
			return num;
		}
		foreach (DungeonSegment segment in segments)
		{
			if (!((Object)(object)segment.link == (Object)null))
			{
				if ((Object)(object)segment.link == (Object)(object)link)
				{
					num++;
				}
				else if (segment.link.MaxCountIdentifier >= 0 && segment.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		foreach (DungeonSegment item in segmentsTotal)
		{
			if (!((Object)(object)item.link == (Object)null))
			{
				if ((Object)(object)item.link == (Object)(object)link)
				{
					num++;
				}
				else if (item.link.MaxCountIdentifier >= 0 && item.link.MaxCountIdentifier == link.MaxCountIdentifier)
				{
					num++;
				}
			}
		}
		return num;
	}

	private bool IsBlocked(List<DungeonSegment> segments, DungeonBaseLink link, Vector3 linkPos, Quaternion linkRot)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_0207: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0211: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0233: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0247: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0250: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0132: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_027f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0286: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val3;
		foreach (DungeonVolume volume in link.Volumes)
		{
			OBB bounds = volume.GetBounds(linkPos, linkRot, VolumeExtrudeNegative);
			OBB bounds2 = volume.GetBounds(linkPos, linkRot, VolumeExtrudePositive);
			foreach (DungeonSegment segment in segments)
			{
				foreach (DungeonVolume volume2 in segment.link.Volumes)
				{
					OBB bounds3 = volume2.GetBounds(segment.position, segment.rotation, VolumeExtrudeNegative);
					if (((OBB)(ref bounds)).Intersects(bounds3))
					{
						return true;
					}
				}
				foreach (DungeonBaseSocket socket in segment.link.Sockets)
				{
					Vector3 val = segment.position + segment.rotation * ((Component)socket).transform.localPosition;
					if (!((OBB)(ref bounds2)).Contains(val))
					{
						continue;
					}
					bool flag = false;
					foreach (DungeonBaseSocket socket2 in link.Sockets)
					{
						Vector3 val2 = linkPos + linkRot * ((Component)socket2).transform.localPosition;
						val3 = val - val2;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							flag = true;
							break;
						}
					}
					if (!flag)
					{
						return true;
					}
				}
			}
		}
		foreach (DungeonSegment segment2 in segments)
		{
			foreach (DungeonVolume volume3 in segment2.link.Volumes)
			{
				OBB bounds4 = volume3.GetBounds(segment2.position, segment2.rotation, VolumeExtrudePositive);
				foreach (DungeonBaseSocket socket3 in link.Sockets)
				{
					Vector3 val4 = linkPos + linkRot * ((Component)socket3).transform.localPosition;
					if (!((OBB)(ref bounds4)).Contains(val4))
					{
						continue;
					}
					bool flag2 = false;
					foreach (DungeonBaseSocket socket4 in segment2.link.Sockets)
					{
						val3 = segment2.position + segment2.rotation * ((Component)socket4).transform.localPosition - val4;
						if (((Vector3)(ref val3)).sqrMagnitude < 0.01f)
						{
							flag2 = true;
							break;
						}
					}
					if (!flag2)
					{
						return true;
					}
				}
			}
		}
		return false;
	}

	private void PlaceSegments(ref uint seed, int count, int budget, int floors, bool attachToFemale, bool attachToMale, List<DungeonSegment> segments, Prefab<DungeonBaseLink>[] prefabs)
	{
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_017c: Unknown result type (might be due to invalid IL or missing references)
		//IL_017e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < segments.Count; i++)
		{
			DungeonSegment dungeonSegment = segments[i];
			if (dungeonSegment.cost >= budget)
			{
				continue;
			}
			int num2 = SeedRandom.Range(ref seed, 0, dungeonSegment.link.Sockets.Count);
			for (int j = 0; j < dungeonSegment.link.Sockets.Count; j++)
			{
				DungeonBaseSocket dungeonBaseSocket = dungeonSegment.link.Sockets[(j + num2) % dungeonSegment.link.Sockets.Count];
				if (!(dungeonBaseSocket.Female && attachToFemale) && !(dungeonBaseSocket.Male && attachToMale))
				{
					continue;
				}
				Vector3 val = dungeonSegment.position + dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localPosition;
				Quaternion val2 = dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localRotation;
				if (IsOccupied(segments, dungeonBaseSocket, val, val2))
				{
					continue;
				}
				prefabs.Shuffle(ref seed);
				DungeonSegment dungeonSegment2 = null;
				Quaternion[] rotationList = GetRotationList(dungeonBaseSocket.Type);
				foreach (Prefab<DungeonBaseLink> prefab in prefabs)
				{
					DungeonBaseLink component = prefab.Component;
					if (component.MaxCountLocal == 0 || component.MaxCountGlobal == 0 || (component.MaxFloor >= 0 && dungeonSegment.floor > component.MaxFloor))
					{
						continue;
					}
					int num3 = dungeonSegment.cost + component.Cost;
					if (num3 > budget)
					{
						continue;
					}
					int num4 = dungeonSegment.floor + GetSocketFloor(dungeonBaseSocket.Type);
					if (num4 > floors)
					{
						continue;
					}
					DungeonBaseSocket linkSocket = null;
					Vector3 linkPos = Vector3.zero;
					Quaternion linkRot = Quaternion.identity;
					int linkScore = 0;
					if (Place(ref seed, segments, dungeonBaseSocket, val, val2, prefab, rotationList, out linkSocket, out linkPos, out linkRot, out linkScore) && (component.MaxCountLocal <= 0 || CountLocal(segments, component) < component.MaxCountLocal) && (component.MaxCountGlobal <= 0 || CountGlobal(segments, component) < component.MaxCountGlobal))
					{
						DungeonSegment dungeonSegment3 = new DungeonSegment();
						dungeonSegment3.position = linkPos;
						dungeonSegment3.rotation = linkRot;
						dungeonSegment3.prefab = prefab;
						dungeonSegment3.link = component;
						dungeonSegment3.score = linkScore;
						dungeonSegment3.cost = num3;
						dungeonSegment3.floor = num4;
						if (dungeonSegment2 == null || dungeonSegment2.score < dungeonSegment3.score)
						{
							dungeonSegment2 = dungeonSegment3;
						}
					}
				}
				if (dungeonSegment2 != null)
				{
					segments.Add(dungeonSegment2);
					num++;
					if (num >= count)
					{
						return;
					}
				}
			}
		}
	}

	private void PlaceTransitions(ref uint seed, List<DungeonSegment> segments, Prefab<DungeonBaseTransition>[] prefabs)
	{
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		int count = segments.Count;
		for (int i = 0; i < count; i++)
		{
			DungeonSegment dungeonSegment = segments[i];
			int num = SeedRandom.Range(ref seed, 0, dungeonSegment.link.Sockets.Count);
			for (int j = 0; j < dungeonSegment.link.Sockets.Count; j++)
			{
				DungeonBaseSocket dungeonBaseSocket = dungeonSegment.link.Sockets[(j + num) % dungeonSegment.link.Sockets.Count];
				Vector3 val = dungeonSegment.position + dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localPosition;
				Quaternion val2 = dungeonSegment.rotation * ((Component)dungeonBaseSocket).transform.localRotation;
				prefabs.Shuffle(ref seed);
				foreach (Prefab<DungeonBaseTransition> prefab in prefabs)
				{
					if (dungeonBaseSocket.Type == prefab.Component.Type && NeighbourMatches(segments, prefab.Component, val, val2))
					{
						DungeonSegment dungeonSegment2 = new DungeonSegment();
						dungeonSegment2.position = val;
						dungeonSegment2.rotation = val2;
						dungeonSegment2.prefab = prefab;
						dungeonSegment2.link = null;
						dungeonSegment2.score = 0;
						dungeonSegment2.cost = 0;
						dungeonSegment2.floor = 0;
						segments.Add(dungeonSegment2);
						break;
					}
				}
			}
		}
	}

	private bool Place(ref uint seed, List<DungeonSegment> segments, DungeonBaseSocket targetSocket, Vector3 targetPos, Quaternion targetRot, Prefab<DungeonBaseLink> prefab, Quaternion[] rotations, out DungeonBaseSocket linkSocket, out Vector3 linkPos, out Quaternion linkRot, out int linkScore)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016a: Unknown result type (might be due to invalid IL or missing references)
		linkSocket = null;
		linkPos = Vector3.one;
		linkRot = Quaternion.identity;
		linkScore = 0;
		DungeonBaseLink component = prefab.Component;
		int num = SeedRandom.Range(ref seed, 0, component.Sockets.Count);
		for (int i = 0; i < component.Sockets.Count; i++)
		{
			DungeonBaseSocket dungeonBaseSocket = component.Sockets[(i + num) % component.Sockets.Count];
			if (dungeonBaseSocket.Type != targetSocket.Type || ((!dungeonBaseSocket.Male || !targetSocket.Female) && (!dungeonBaseSocket.Female || !targetSocket.Male)))
			{
				continue;
			}
			rotations.Shuffle(ref seed);
			foreach (Quaternion val in rotations)
			{
				Quaternion val2 = Quaternion.FromToRotation(-((Component)dungeonBaseSocket).transform.forward, targetRot * Vector3.forward);
				if (dungeonBaseSocket.Type != DungeonBaseSocketType.Vertical)
				{
					val2 = QuaternionEx.LookRotationForcedUp(val2 * Vector3.forward, Vector3.up);
				}
				Quaternion val3 = val * val2;
				Vector3 val4 = targetPos - val3 * ((Component)dungeonBaseSocket).transform.localPosition;
				if (!IsBlocked(segments, component, val4, val3))
				{
					int num2 = SocketMatches(segments, component, val4, val3);
					if (num2 > linkScore && prefab.CheckEnvironmentVolumesOutsideTerrain(val4, val3, Vector3.one, EnvironmentType.UnderwaterLab, (EnvironmentType)0, 1f))
					{
						linkSocket = dungeonBaseSocket;
						linkPos = val4;
						linkRot = val3;
						linkScore = num2;
					}
				}
			}
		}
		return linkScore > 0;
	}

	public static void SetupAI()
	{
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Expected O, but got Unknown
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0189: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)TerrainMeta.Path == (Object)null || TerrainMeta.Path.DungeonBaseEntrances == null)
		{
			return;
		}
		foreach (DungeonBaseInfo dungeonBaseEntrance in TerrainMeta.Path.DungeonBaseEntrances)
		{
			if ((Object)(object)dungeonBaseEntrance == (Object)null)
			{
				continue;
			}
			List<AIInformationZone> list = new List<AIInformationZone>();
			int num = 0;
			AIInformationZone componentInChildren = ((Component)dungeonBaseEntrance).GetComponentInChildren<AIInformationZone>();
			if ((Object)(object)componentInChildren != (Object)null)
			{
				list.Add(componentInChildren);
				num++;
			}
			foreach (GameObject link in ((Component)dungeonBaseEntrance).GetComponent<DungeonBaseInfo>().Links)
			{
				AIInformationZone componentInChildren2 = link.GetComponentInChildren<AIInformationZone>();
				if (!((Object)(object)componentInChildren2 == (Object)null))
				{
					list.Add(componentInChildren2);
					num++;
				}
			}
			GameObject val = new GameObject("AIZ");
			val.transform.position = ((Component)dungeonBaseEntrance).gameObject.transform.position;
			AIInformationZone aIInformationZone = AIInformationZone.Merge(list, val);
			aIInformationZone.ShouldSleepAI = true;
			val.transform.SetParent(((Component)dungeonBaseEntrance).gameObject.transform);
			GameObject val2 = new GameObject("WakeTrigger");
			val2.transform.position = val.transform.position + ((Bounds)(ref aIInformationZone.bounds)).center;
			val2.transform.localScale = ((Bounds)(ref aIInformationZone.bounds)).extents + new Vector3(100f, 100f, 100f);
			((Collider)val2.AddComponent<BoxCollider>()).isTrigger = true;
			val2.layer = LayerMask.NameToLayer("Trigger");
			val2.transform.SetParent(((Component)dungeonBaseEntrance).gameObject.transform);
			TriggerWakeAIZ triggerWakeAIZ = val2.AddComponent<TriggerWakeAIZ>();
			triggerWakeAIZ.InterestLayers = LayerMask.op_Implicit(LayerMask.GetMask(new string[1] { "Player (Server)" }));
			triggerWakeAIZ.Init(aIInformationZone);
		}
	}
}


using UnityEngine;

private class DungeonSegment
{
	public Vector3 position;

	public Quaternion rotation;

	public Prefab prefab;

	public DungeonBaseLink link;

	public int score;

	public int cost;

	public int floor;
}


using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class GenerateDungeonGrid : ProceduralComponent
{
	private class PathNode
	{
		public MonumentInfo monument;

		public PathFinder.Node node;
	}

	private class PathSegment
	{
		public PathFinder.Node start;

		public PathFinder.Node end;
	}

	private class PathLink
	{
		public PathLinkSide downwards;

		public PathLinkSide upwards;
	}

	private class PathLinkSide
	{
		public PathLinkSegment origin;

		public List<PathLinkSegment> segments;

		public PathLinkSegment prevSegment
		{
			get
			{
				if (segments.Count <= 0)
				{
					return origin;
				}
				return segments[segments.Count - 1];
			}
		}
	}

	private class PathLinkSegment
	{
		public Vector3 position;

		public Quaternion rotation;

		public Vector3 scale;

		public Prefab<DungeonGridLink> prefab;

		public DungeonGridLink link;

		public Transform downSocket => link.DownSocket;

		public Transform upSocket => link.UpSocket;

		public DungeonGridLinkType downType => link.DownType;

		public DungeonGridLinkType upType => link.UpType;
	}

	private struct PrefabReplacement
	{
		public Vector2i gridPosition;

		public Vector3 worldPosition;

		public int distance;

		public Prefab<DungeonGridCell> prefab;
	}

	public string TunnelFolder = string.Empty;

	public string StationFolder = string.Empty;

	public string UpwardsFolder = string.Empty;

	public string TransitionFolder = string.Empty;

	public string LinkFolder = string.Empty;

	public InfrastructureType ConnectionType = InfrastructureType.Tunnel;

	public int CellSize = 216;

	public float LinkHeight = 1.5f;

	public float LinkRadius = 3f;

	public float LinkTransition = 9f;

	private const int MaxDepth = 100000;

	public override bool RunOnCache => true;

	public override void Process(uint seed)
	{
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0263: Unknown result type (might be due to invalid IL or missing references)
		//IL_0268: Unknown result type (might be due to invalid IL or missing references)
		//IL_026c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_08b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_08bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_08c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_08ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0291: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_107f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1084: Unknown result type (might be due to invalid IL or missing references)
		//IL_1086: Unknown result type (might be due to invalid IL or missing references)
		//IL_108b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0320: Unknown result type (might be due to invalid IL or missing references)
		//IL_108d: Unknown result type (might be due to invalid IL or missing references)
		//IL_108f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0330: Unknown result type (might be due to invalid IL or missing references)
		//IL_0340: Unknown result type (might be due to invalid IL or missing references)
		//IL_0347: Unknown result type (might be due to invalid IL or missing references)
		//IL_1116: Unknown result type (might be due to invalid IL or missing references)
		//IL_1118: Unknown result type (might be due to invalid IL or missing references)
		//IL_10b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_10c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_10d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_10db: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_10e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1141: Unknown result type (might be due to invalid IL or missing references)
		//IL_1146: Unknown result type (might be due to invalid IL or missing references)
		//IL_1148: Unknown result type (might be due to invalid IL or missing references)
		//IL_114d: Unknown result type (might be due to invalid IL or missing references)
		//IL_118e: Unknown result type (might be due to invalid IL or missing references)
		//IL_119f: Unknown result type (might be due to invalid IL or missing references)
		//IL_11b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_11c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_11cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_11d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_11da: Unknown result type (might be due to invalid IL or missing references)
		//IL_11e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_11f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_120f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1220: Unknown result type (might be due to invalid IL or missing references)
		//IL_1225: Unknown result type (might be due to invalid IL or missing references)
		//IL_122a: Unknown result type (might be due to invalid IL or missing references)
		//IL_122f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1234: Unknown result type (might be due to invalid IL or missing references)
		//IL_1236: Unknown result type (might be due to invalid IL or missing references)
		//IL_123b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1254: Unknown result type (might be due to invalid IL or missing references)
		//IL_1259: Unknown result type (might be due to invalid IL or missing references)
		//IL_126f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1274: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_1287: Unknown result type (might be due to invalid IL or missing references)
		//IL_128c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03da: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f1e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f25: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f2c: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_12bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_12c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_12cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_12d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_12e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_12ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_12f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1300: Unknown result type (might be due to invalid IL or missing references)
		//IL_1305: Unknown result type (might be due to invalid IL or missing references)
		//IL_130a: Unknown result type (might be due to invalid IL or missing references)
		//IL_130f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1314: Unknown result type (might be due to invalid IL or missing references)
		//IL_1318: Unknown result type (might be due to invalid IL or missing references)
		//IL_1324: Unknown result type (might be due to invalid IL or missing references)
		//IL_1329: Unknown result type (might be due to invalid IL or missing references)
		//IL_132e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1820: Unknown result type (might be due to invalid IL or missing references)
		//IL_1822: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f7b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f82: Unknown result type (might be due to invalid IL or missing references)
		//IL_1f89: Unknown result type (might be due to invalid IL or missing references)
		//IL_229f: Unknown result type (might be due to invalid IL or missing references)
		//IL_22a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_22a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_22af: Unknown result type (might be due to invalid IL or missing references)
		//IL_22b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_22b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_22b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_22bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0558: Unknown result type (might be due to invalid IL or missing references)
		//IL_055f: Unknown result type (might be due to invalid IL or missing references)
		//IL_056f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0576: Unknown result type (might be due to invalid IL or missing references)
		//IL_1837: Unknown result type (might be due to invalid IL or missing references)
		//IL_1839: Unknown result type (might be due to invalid IL or missing references)
		//IL_1840: Unknown result type (might be due to invalid IL or missing references)
		//IL_1842: Unknown result type (might be due to invalid IL or missing references)
		//IL_1849: Unknown result type (might be due to invalid IL or missing references)
		//IL_184e: Unknown result type (might be due to invalid IL or missing references)
		//IL_187d: Unknown result type (might be due to invalid IL or missing references)
		//IL_187f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1881: Unknown result type (might be due to invalid IL or missing references)
		//IL_1886: Unknown result type (might be due to invalid IL or missing references)
		//IL_2026: Unknown result type (might be due to invalid IL or missing references)
		//IL_2028: Unknown result type (might be due to invalid IL or missing references)
		//IL_202d: Unknown result type (might be due to invalid IL or missing references)
		//IL_202f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2034: Unknown result type (might be due to invalid IL or missing references)
		//IL_05de: Unknown result type (might be due to invalid IL or missing references)
		//IL_05e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_13b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1890: Unknown result type (might be due to invalid IL or missing references)
		//IL_0609: Unknown result type (might be due to invalid IL or missing references)
		//IL_0612: Unknown result type (might be due to invalid IL or missing references)
		//IL_138d: Unknown result type (might be due to invalid IL or missing references)
		//IL_13c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_18b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_18c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_18cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_18de: Unknown result type (might be due to invalid IL or missing references)
		//IL_18e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_18ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_18f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_18fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_1902: Unknown result type (might be due to invalid IL or missing references)
		//IL_1907: Unknown result type (might be due to invalid IL or missing references)
		//IL_190c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1910: Unknown result type (might be due to invalid IL or missing references)
		//IL_191c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1921: Unknown result type (might be due to invalid IL or missing references)
		//IL_1926: Unknown result type (might be due to invalid IL or missing references)
		//IL_189e: Unknown result type (might be due to invalid IL or missing references)
		//IL_049e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_04a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_04aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_04af: Unknown result type (might be due to invalid IL or missing references)
		//IL_04bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_04c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_04d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_0634: Unknown result type (might be due to invalid IL or missing references)
		//IL_063b: Unknown result type (might be due to invalid IL or missing references)
		//IL_139e: Unknown result type (might be due to invalid IL or missing references)
		//IL_04eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_04f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_04fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_050a: Unknown result type (might be due to invalid IL or missing references)
		//IL_050f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0514: Unknown result type (might be due to invalid IL or missing references)
		//IL_051d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0522: Unknown result type (might be due to invalid IL or missing references)
		//IL_0524: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_06bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_06c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_06da: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_06e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_06eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_06ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_06f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_071d: Unknown result type (might be due to invalid IL or missing references)
		//IL_071f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0730: Unknown result type (might be due to invalid IL or missing references)
		//IL_0732: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_0748: Unknown result type (might be due to invalid IL or missing references)
		//IL_074d: Unknown result type (might be due to invalid IL or missing references)
		//IL_079f: Unknown result type (might be due to invalid IL or missing references)
		//IL_07a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_07ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_07cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_065f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0666: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_13f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_13fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_13ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1404: Unknown result type (might be due to invalid IL or missing references)
		//IL_1406: Unknown result type (might be due to invalid IL or missing references)
		//IL_140f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1414: Unknown result type (might be due to invalid IL or missing references)
		//IL_1419: Unknown result type (might be due to invalid IL or missing references)
		//IL_142b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1437: Unknown result type (might be due to invalid IL or missing references)
		//IL_143c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1441: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e18: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e1a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1489: Unknown result type (might be due to invalid IL or missing references)
		//IL_148b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1494: Unknown result type (might be due to invalid IL or missing references)
		//IL_1499: Unknown result type (might be due to invalid IL or missing references)
		//IL_149e: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_14a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_14ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_14bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_14cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_14d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_14da: Unknown result type (might be due to invalid IL or missing references)
		//IL_14df: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_14f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_14fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1500: Unknown result type (might be due to invalid IL or missing references)
		//IL_1502: Unknown result type (might be due to invalid IL or missing references)
		//IL_1507: Unknown result type (might be due to invalid IL or missing references)
		//IL_151b: Unknown result type (might be due to invalid IL or missing references)
		//IL_151d: Unknown result type (might be due to invalid IL or missing references)
		//IL_144d: Unknown result type (might be due to invalid IL or missing references)
		//IL_144f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e31: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e38: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e41: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e46: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e75: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e77: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e79: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e7e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1463: Unknown result type (might be due to invalid IL or missing references)
		//IL_1465: Unknown result type (might be due to invalid IL or missing references)
		//IL_1467: Unknown result type (might be due to invalid IL or missing references)
		//IL_146c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1471: Unknown result type (might be due to invalid IL or missing references)
		//IL_1473: Unknown result type (might be due to invalid IL or missing references)
		//IL_1475: Unknown result type (might be due to invalid IL or missing references)
		//IL_1477: Unknown result type (might be due to invalid IL or missing references)
		//IL_147c: Unknown result type (might be due to invalid IL or missing references)
		//IL_147e: Unknown result type (might be due to invalid IL or missing references)
		//IL_1480: Unknown result type (might be due to invalid IL or missing references)
		//IL_1482: Unknown result type (might be due to invalid IL or missing references)
		//IL_1487: Unknown result type (might be due to invalid IL or missing references)
		//IL_19a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_20bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_20c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1564: Unknown result type (might be due to invalid IL or missing references)
		//IL_1570: Unknown result type (might be due to invalid IL or missing references)
		//IL_1985: Unknown result type (might be due to invalid IL or missing references)
		//IL_19ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_20da: Unknown result type (might be due to invalid IL or missing references)
		//IL_20dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_20e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1587: Unknown result type (might be due to invalid IL or missing references)
		//IL_1996: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_20f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_20fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_15b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_15bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_159a: Unknown result type (might be due to invalid IL or missing references)
		//IL_15a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_19e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_19ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_19f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_19f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_19fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_19fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a07: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a0c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a11: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a23: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a2f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a34: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a39: Unknown result type (might be due to invalid IL or missing references)
		//IL_23e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_23e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_23fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2403: Unknown result type (might be due to invalid IL or missing references)
		//IL_2408: Unknown result type (might be due to invalid IL or missing references)
		//IL_2411: Unknown result type (might be due to invalid IL or missing references)
		//IL_2413: Unknown result type (might be due to invalid IL or missing references)
		//IL_2415: Unknown result type (might be due to invalid IL or missing references)
		//IL_241a: Unknown result type (might be due to invalid IL or missing references)
		//IL_241f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2118: Unknown result type (might be due to invalid IL or missing references)
		//IL_211a: Unknown result type (might be due to invalid IL or missing references)
		//IL_15d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a81: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a83: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a8c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a91: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a96: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a9b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a9d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aa6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ab7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1abc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac5: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ac7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1acc: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ace: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad2: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ad7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aeb: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aed: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aef: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af4: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1af8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1afa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1aff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b13: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b15: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a45: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a47: Unknown result type (might be due to invalid IL or missing references)
		//IL_24fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_2500: Unknown result type (might be due to invalid IL or missing references)
		//IL_2516: Unknown result type (might be due to invalid IL or missing references)
		//IL_251b: Unknown result type (might be due to invalid IL or missing references)
		//IL_2520: Unknown result type (might be due to invalid IL or missing references)
		//IL_2529: Unknown result type (might be due to invalid IL or missing references)
		//IL_252b: Unknown result type (might be due to invalid IL or missing references)
		//IL_252d: Unknown result type (might be due to invalid IL or missing references)
		//IL_2532: Unknown result type (might be due to invalid IL or missing references)
		//IL_2537: Unknown result type (might be due to invalid IL or missing references)
		//IL_213a: Unknown result type (might be due to invalid IL or missing references)
		//IL_2125: Unknown result type (might be due to invalid IL or missing references)
		//IL_212e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2133: Unknown result type (might be due to invalid IL or missing references)
		//IL_2138: Unknown result type (might be due to invalid IL or missing references)
		//IL_1602: Unknown result type (might be due to invalid IL or missing references)
		//IL_160e: Unknown result type (might be due to invalid IL or missing references)
		//IL_15e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_15f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a5f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a64: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a69: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a6b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a6d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a6f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a74: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a76: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a78: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a7a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1a7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_2149: Unknown result type (might be due to invalid IL or missing references)
		//IL_1625: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b5c: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b68: Unknown result type (might be due to invalid IL or missing references)
		//IL_2165: Unknown result type (might be due to invalid IL or missing references)
		//IL_2167: Unknown result type (might be due to invalid IL or missing references)
		//IL_216e: Unknown result type (might be due to invalid IL or missing references)
		//IL_2170: Unknown result type (might be due to invalid IL or missing references)
		//IL_1638: Unknown result type (might be due to invalid IL or missing references)
		//IL_163f: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b7f: Unknown result type (might be due to invalid IL or missing references)
		//IL_16f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_1658: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bab: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bb7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b92: Unknown result type (might be due to invalid IL or missing references)
		//IL_1b99: Unknown result type (might be due to invalid IL or missing references)
		//IL_16fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_1669: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bce: Unknown result type (might be due to invalid IL or missing references)
		//IL_1bfa: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c06: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1be8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1742: Unknown result type (might be due to invalid IL or missing references)
		//IL_1713: Unknown result type (might be due to invalid IL or missing references)
		//IL_1680: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c1d: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1801: Unknown result type (might be due to invalid IL or missing references)
		//IL_1807: Unknown result type (might be due to invalid IL or missing references)
		//IL_1809: Unknown result type (might be due to invalid IL or missing references)
		//IL_180b: Unknown result type (might be due to invalid IL or missing references)
		//IL_180d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1795: Unknown result type (might be due to invalid IL or missing references)
		//IL_1765: Unknown result type (might be due to invalid IL or missing references)
		//IL_16b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1693: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c30: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c37: Unknown result type (might be due to invalid IL or missing references)
		//IL_17b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_16c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1ce8: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c50: Unknown result type (might be due to invalid IL or missing references)
		//IL_17eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_17ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cf6: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c61: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d3a: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d0b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c78: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df7: Unknown result type (might be due to invalid IL or missing references)
		//IL_1df9: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dff: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e01: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e03: Unknown result type (might be due to invalid IL or missing references)
		//IL_1e05: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d8d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1d5d: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cae: Unknown result type (might be due to invalid IL or missing references)
		//IL_1c8b: Unknown result type (might be due to invalid IL or missing references)
		//IL_1dad: Unknown result type (might be due to invalid IL or missing references)
		//IL_1cc1: Unknown result type (might be due to invalid IL or missing references)
		//IL_1de3: Unknown result type (might be due to invalid IL or missing references)
		//IL_1de5: Unknown result type (might be due to invalid IL or missing references)
		if (World.Cached)
		{
			return;
		}
		if (World.Networked)
		{
			World.Spawn("Dungeon");
		}
		else
		{
			if (ConnectionType == InfrastructureType.Tunnel && !World.Config.BelowGroundRails)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + TunnelFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array == null || array.Length == 0)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array2 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + StationFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array2 == null || array2.Length == 0)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array3 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + UpwardsFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array3 == null)
			{
				return;
			}
			Prefab<DungeonGridCell>[] array4 = Prefab.Load<DungeonGridCell>("assets/bundled/prefabs/autospawn/" + TransitionFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array4 == null)
			{
				return;
			}
			Prefab<DungeonGridLink>[] array5 = Prefab.Load<DungeonGridLink>("assets/bundled/prefabs/autospawn/" + LinkFolder, (GameManager)null, (PrefabAttribute.Library)null, useProbabilities: true, useWorldConfig: false);
			if (array5 == null)
			{
				return;
			}
			array5 = array5.OrderByDescending((Prefab<DungeonGridLink> x) => x.Component.Priority).ToArray();
			List<DungeonGridInfo> list = (Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.DungeonGridEntrances : null);
			WorldSpaceGrid<Prefab<DungeonGridCell>> val = new WorldSpaceGrid<Prefab<DungeonGridCell>>(TerrainMeta.Size.x, (float)CellSize, (RoundingMode)1);
			int[,] array6 = new int[val.CellCount, val.CellCount];
			DungeonGridConnectionHash[,] hashmap = new DungeonGridConnectionHash[val.CellCount, val.CellCount];
			PathFinder pathFinder = new PathFinder(array6, diagonals: false);
			int cellCount = val.CellCount;
			int num = 0;
			int num2 = val.CellCount - 1;
			for (int i = 0; i < cellCount; i++)
			{
				for (int j = 0; j < cellCount; j++)
				{
					array6[j, i] = 1;
				}
			}
			List<PathSegment> list2 = new List<PathSegment>();
			List<PathLink> list3 = new List<PathLink>();
			List<PathNode> list4 = new List<PathNode>();
			List<PathNode> unconnectedNodeList = new List<PathNode>();
			List<PathNode> secondaryNodeList = new List<PathNode>();
			List<PathFinder.Point> list5 = new List<PathFinder.Point>();
			List<PathFinder.Point> list6 = new List<PathFinder.Point>();
			List<PathFinder.Point> list7 = new List<PathFinder.Point>();
			foreach (DungeonGridInfo item3 in list)
			{
				DungeonGridInfo entrance = item3;
				TerrainPathConnect[] componentsInChildren = ((Component)entrance).GetComponentsInChildren<TerrainPathConnect>(true);
				foreach (TerrainPathConnect terrainPathConnect in componentsInChildren)
				{
					if (terrainPathConnect.Type != ConnectionType)
					{
						continue;
					}
					Vector2i val2 = val.WorldToGridCoords(((Component)terrainPathConnect).transform.position);
					if (array6[val2.x, val2.y] == int.MaxValue)
					{
						continue;
					}
					PathFinder.Node stationNode = pathFinder.FindClosestWalkable(new PathFinder.Point(val2.x, val2.y), 1);
					if (stationNode == null)
					{
						continue;
					}
					Prefab<DungeonGridCell> prefab2 = ((val2.x > num) ? val[val2.x - 1, val2.y] : null);
					Prefab<DungeonGridCell> prefab3 = ((val2.x < num2) ? val[val2.x + 1, val2.y] : null);
					Prefab<DungeonGridCell> prefab4 = ((val2.y > num) ? val[val2.x, val2.y - 1] : null);
					Prefab<DungeonGridCell> obj = ((val2.y < num2) ? val[val2.x, val2.y + 1] : null);
					DungeonGridConnectionType dungeonGridConnectionType = prefab2?.Component.East ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType2 = prefab3?.Component.West ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType3 = prefab4?.Component.North ?? DungeonGridConnectionType.None;
					DungeonGridConnectionType dungeonGridConnectionType4 = obj?.Component.South ?? DungeonGridConnectionType.None;
					bool flag = prefab2 != null || val2.x <= num;
					bool flag2 = prefab3 != null || val2.x >= num2;
					bool flag3 = prefab4 != null || val2.y <= num;
					bool flag4 = obj != null || val2.y >= num2;
					Prefab<DungeonGridCell> prefab5 = null;
					float num3 = float.MaxValue;
					array2.Shuffle(ref seed);
					Prefab<DungeonGridCell>[] array7 = array2;
					foreach (Prefab<DungeonGridCell> prefab6 in array7)
					{
						if ((flag && prefab6.Component.West != dungeonGridConnectionType) || (flag2 && prefab6.Component.East != dungeonGridConnectionType2) || (flag3 && prefab6.Component.South != dungeonGridConnectionType3) || (flag4 && prefab6.Component.North != dungeonGridConnectionType4))
						{
							continue;
						}
						DungeonVolume componentInChildren = prefab6.Object.GetComponentInChildren<DungeonVolume>();
						DungeonVolume componentInChildren2 = ((Component)entrance).GetComponentInChildren<DungeonVolume>();
						OBB bounds = componentInChildren.GetBounds(val.GridToWorldCoords(val2), Quaternion.identity);
						OBB bounds2 = componentInChildren2.GetBounds(((Component)entrance).transform.position, Quaternion.identity);
						if (!((OBB)(ref bounds)).Intersects2D(bounds2))
						{
							DungeonGridLink componentInChildren3 = prefab6.Object.GetComponentInChildren<DungeonGridLink>();
							Vector3 val3 = val.GridToWorldCoords(new Vector2i(val2.x, val2.y)) + componentInChildren3.UpSocket.localPosition;
							float num4 = Vector3Ex.Magnitude2D(((Component)terrainPathConnect).transform.position - val3);
							if (!(num3 < num4))
							{
								prefab5 = prefab6;
								num3 = num4;
							}
						}
					}
					bool isStartPoint;
					if (prefab5 != null)
					{
						val[val2.x, val2.y] = prefab5;
						array6[val2.x, val2.y] = int.MaxValue;
						isStartPoint = secondaryNodeList.Count == 0;
						secondaryNodeList.RemoveAll((PathNode x) => x.node.point == stationNode.point);
						unconnectedNodeList.RemoveAll((PathNode x) => x.node.point == stationNode.point);
						if (prefab5.Component.West != 0)
						{
							AddNode(val2.x - 1, val2.y);
						}
						if (prefab5.Component.East != 0)
						{
							AddNode(val2.x + 1, val2.y);
						}
						if (prefab5.Component.South != 0)
						{
							AddNode(val2.x, val2.y - 1);
						}
						if (prefab5.Component.North != 0)
						{
							AddNode(val2.x, val2.y + 1);
						}
						PathLink pathLink = new PathLink();
						DungeonGridLink componentInChildren4 = ((Component)entrance).gameObject.GetComponentInChildren<DungeonGridLink>();
						Vector3 position = ((Component)entrance).transform.position;
						Quaternion rotation = ((Component)entrance).transform.rotation;
						Vector3 eulerAngles = ((Quaternion)(ref rotation)).eulerAngles;
						DungeonGridLink componentInChildren5 = prefab5.Object.GetComponentInChildren<DungeonGridLink>();
						Vector3 position2 = val.GridToWorldCoords(new Vector2i(val2.x, val2.y));
						Vector3 zero = Vector3.zero;
						pathLink.downwards = new PathLinkSide();
						pathLink.downwards.origin = new PathLinkSegment();
						pathLink.downwards.origin.position = position;
						pathLink.downwards.origin.rotation = Quaternion.Euler(eulerAngles);
						pathLink.downwards.origin.scale = Vector3.one;
						pathLink.downwards.origin.link = componentInChildren4;
						pathLink.downwards.segments = new List<PathLinkSegment>();
						pathLink.upwards = new PathLinkSide();
						pathLink.upwards.origin = new PathLinkSegment();
						pathLink.upwards.origin.position = position2;
						pathLink.upwards.origin.rotation = Quaternion.Euler(zero);
						pathLink.upwards.origin.scale = Vector3.one;
						pathLink.upwards.origin.link = componentInChildren5;
						pathLink.upwards.segments = new List<PathLinkSegment>();
						list3.Add(pathLink);
					}
					void AddNode(int x, int y)
					{
						//IL_0059: Unknown result type (might be due to invalid IL or missing references)
						PathFinder.Node node8 = pathFinder.FindClosestWalkable(new PathFinder.Point(x, y), 1);
						if (node8 != null)
						{
							PathNode item2 = new PathNode
							{
								monument = (Object.op_Implicit((Object)(object)TerrainMeta.Path) ? TerrainMeta.Path.FindClosest(TerrainMeta.Path.Monuments, ((Component)entrance).transform.position) : ((Component)((Component)entrance).transform).GetComponentInParent<MonumentInfo>()),
								node = node8
							};
							if (isStartPoint)
							{
								secondaryNodeList.Add(item2);
							}
							else
							{
								unconnectedNodeList.Add(item2);
							}
							DungeonGridConnectionHash dungeonGridConnectionHash4 = hashmap[node8.point.x, node8.point.y];
							DungeonGridConnectionHash dungeonGridConnectionHash5 = hashmap[stationNode.point.x, stationNode.point.y];
							if (node8.point.x > stationNode.point.x)
							{
								dungeonGridConnectionHash4.West = true;
								dungeonGridConnectionHash5.East = true;
							}
							if (node8.point.x < stationNode.point.x)
							{
								dungeonGridConnectionHash4.East = true;
								dungeonGridConnectionHash5.West = true;
							}
							if (node8.point.y > stationNode.point.y)
							{
								dungeonGridConnectionHash4.South = true;
								dungeonGridConnectionHash5.North = true;
							}
							if (node8.point.y < stationNode.point.y)
							{
								dungeonGridConnectionHash4.North = true;
								dungeonGridConnectionHash5.South = true;
							}
							hashmap[node8.point.x, node8.point.y] = dungeonGridConnectionHash4;
							hashmap[stationNode.point.x, stationNode.point.y] = dungeonGridConnectionHash5;
						}
					}
				}
			}
			while (unconnectedNodeList.Count != 0 || secondaryNodeList.Count != 0)
			{
				if (unconnectedNodeList.Count == 0)
				{
					PathNode node = secondaryNodeList[0];
					unconnectedNodeList.AddRange(secondaryNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node.monument));
					secondaryNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node.monument);
					Vector2i val4 = val.WorldToGridCoords(((Component)node.monument).transform.position);
					pathFinder.PushPoint = new PathFinder.Point(val4.x, val4.y);
					pathFinder.PushRadius = (pathFinder.PushDistance = 2);
					pathFinder.PushMultiplier = 16;
				}
				list7.Clear();
				list7.AddRange(unconnectedNodeList.Select((PathNode x) => x.node.point));
				list6.Clear();
				list6.AddRange(list4.Select((PathNode x) => x.node.point));
				list6.AddRange(secondaryNodeList.Select((PathNode x) => x.node.point));
				list6.AddRange(list5);
				PathFinder.Node node2 = pathFinder.FindPathUndirected(list6, list7, 100000);
				if (node2 == null)
				{
					PathNode node3 = unconnectedNodeList[0];
					secondaryNodeList.AddRange(unconnectedNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument));
					unconnectedNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node3.monument);
					secondaryNodeList.Remove(node3);
					list4.Add(node3);
					continue;
				}
				PathSegment segment = new PathSegment();
				for (PathFinder.Node node4 = node2; node4 != null; node4 = node4.next)
				{
					if (node4 == node2)
					{
						segment.start = node4;
					}
					if (node4.next == null)
					{
						segment.end = node4;
					}
				}
				list2.Add(segment);
				PathNode node5 = unconnectedNodeList.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				secondaryNodeList.AddRange(unconnectedNodeList.Where((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument));
				unconnectedNodeList.RemoveAll((PathNode x) => (Object)(object)x.monument == (Object)(object)node5.monument);
				secondaryNodeList.Remove(node5);
				list4.Add(node5);
				PathNode pathNode = secondaryNodeList.Find((PathNode x) => x.node.point == segment.start.point || x.node.point == segment.end.point);
				if (pathNode != null)
				{
					secondaryNodeList.Remove(pathNode);
					list4.Add(pathNode);
				}
				for (PathFinder.Node node6 = node2; node6 != null; node6 = node6.next)
				{
					if (node6 != node2 && node6.next != null)
					{
						list5.Add(node6.point);
					}
				}
			}
			foreach (PathSegment item4 in list2)
			{
				PathFinder.Node node7 = item4.start;
				while (node7 != null && node7.next != null)
				{
					DungeonGridConnectionHash dungeonGridConnectionHash = hashmap[node7.point.x, node7.point.y];
					DungeonGridConnectionHash dungeonGridConnectionHash2 = hashmap[node7.next.point.x, node7.next.point.y];
					if (node7.point.x > node7.next.point.x)
					{
						dungeonGridConnectionHash.West = true;
						dungeonGridConnectionHash2.East = true;
					}
					if (node7.point.x < node7.next.point.x)
					{
						dungeonGridConnectionHash.East = true;
						dungeonGridConnectionHash2.West = true;
					}
					if (node7.point.y > node7.next.point.y)
					{
						dungeonGridConnectionHash.South = true;
						dungeonGridConnectionHash2.North = true;
					}
					if (node7.point.y < node7.next.point.y)
					{
						dungeonGridConnectionHash.North = true;
						dungeonGridConnectionHash2.South = true;
					}
					hashmap[node7.point.x, node7.point.y] = dungeonGridConnectionHash;
					hashmap[node7.next.point.x, node7.next.point.y] = dungeonGridConnectionHash2;
					node7 = node7.next;
				}
			}
			for (int m = 0; m < val.CellCount; m++)
			{
				for (int n = 0; n < val.CellCount; n++)
				{
					if (array6[m, n] == int.MaxValue)
					{
						continue;
					}
					DungeonGridConnectionHash dungeonGridConnectionHash3 = hashmap[m, n];
					if (dungeonGridConnectionHash3.Value == 0)
					{
						continue;
					}
					array.Shuffle(ref seed);
					Prefab<DungeonGridCell>[] array7 = array;
					foreach (Prefab<DungeonGridCell> prefab7 in array7)
					{
						Prefab<DungeonGridCell> prefab8 = ((m > num) ? val[m - 1, n] : null);
						if (((prefab8 != null) ? ((prefab7.Component.West == prefab8.Component.East) ? 1 : 0) : (dungeonGridConnectionHash3.West ? ((int)prefab7.Component.West) : ((prefab7.Component.West == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab9 = ((m < num2) ? val[m + 1, n] : null);
						if (((prefab9 != null) ? ((prefab7.Component.East == prefab9.Component.West) ? 1 : 0) : (dungeonGridConnectionHash3.East ? ((int)prefab7.Component.East) : ((prefab7.Component.East == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab10 = ((n > num) ? val[m, n - 1] : null);
						if (((prefab10 != null) ? ((prefab7.Component.South == prefab10.Component.North) ? 1 : 0) : (dungeonGridConnectionHash3.South ? ((int)prefab7.Component.South) : ((prefab7.Component.South == DungeonGridConnectionType.None) ? 1 : 0))) == 0)
						{
							continue;
						}
						Prefab<DungeonGridCell> prefab11 = ((n < num2) ? val[m, n + 1] : null);
						if (((prefab11 != null) ? (prefab7.Component.North == prefab11.Component.South) : (dungeonGridConnectionHash3.North ? ((byte)prefab7.Component.North != 0) : (prefab7.Component.North == DungeonGridConnectionType.None))) && (prefab7.Component.West == DungeonGridConnectionType.None || prefab8 == null || !prefab7.Component.ShouldAvoid(prefab8.ID)) && (prefab7.Component.East == DungeonGridConnectionType.None || prefab9 == null || !prefab7.Component.ShouldAvoid(prefab9.ID)) && (prefab7.Component.South == DungeonGridConnectionType.None || prefab10 == null || !prefab7.Component.ShouldAvoid(prefab10.ID)) && (prefab7.Component.North == DungeonGridConnectionType.None || prefab11 == null || !prefab7.Component.ShouldAvoid(prefab11.ID)))
						{
							val[m, n] = prefab7;
							bool num5 = prefab8 == null || prefab7.Component.WestVariant == prefab8.Component.EastVariant;
							bool flag5 = prefab10 == null || prefab7.Component.SouthVariant == prefab10.Component.NorthVariant;
							if (num5 && flag5)
							{
								break;
							}
						}
					}
				}
			}
			Vector3 zero2 = Vector3.zero;
			Vector3 zero3 = Vector3.zero;
			Vector2i val5 = default(Vector2i);
			do
			{
				zero3 = zero2;
				for (int num6 = 0; num6 < val.CellCount; num6++)
				{
					for (int num7 = 0; num7 < val.CellCount; num7++)
					{
						Prefab<DungeonGridCell> prefab12 = val[num6, num7];
						if (prefab12 != null)
						{
							((Vector2i)(ref val5))..ctor(num6, num7);
							Vector3 val6 = val.GridToWorldCoords(val5);
							while (!IsValidPrefabPlacement(prefab12, zero2 + val6, Quaternion.identity, Vector3.one, EnvironmentType.Underground | EnvironmentType.Building))
							{
								zero2.y -= 3f;
							}
						}
					}
				}
			}
			while (zero2 != zero3);
			foreach (PathLink item5 in list3)
			{
				PathLinkSegment origin = item5.upwards.origin;
				origin.position += zero2;
			}
			foreach (PathLink item6 in list3)
			{
				Vector3 val7 = item6.upwards.origin.position + item6.upwards.origin.rotation * Vector3.Scale(item6.upwards.origin.upSocket.localPosition, item6.upwards.origin.scale);
				Vector3 val8 = item6.downwards.origin.position + item6.downwards.origin.rotation * Vector3.Scale(item6.downwards.origin.downSocket.localPosition, item6.downwards.origin.scale) - val7;
				Vector3[] array8 = (Vector3[])(object)new Vector3[2]
				{
					new Vector3(0f, 1f, 0f),
					new Vector3(1f, 1f, 1f)
				};
				foreach (Vector3 val9 in array8)
				{
					int num8 = 0;
					int num9 = 0;
					while (((Vector3)(ref val8)).magnitude > 1f && (num8 < 8 || num9 < 8))
					{
						bool flag6 = num8 > 2 && num9 > 2;
						bool flag7 = num8 > 4 && num9 > 4;
						Prefab<DungeonGridLink> prefab13 = null;
						Vector3 val10 = Vector3.zero;
						int num10 = int.MinValue;
						Vector3 position3 = Vector3.zero;
						Quaternion rotation2 = Quaternion.identity;
						PathLinkSegment prevSegment = item6.downwards.prevSegment;
						Vector3 val11 = prevSegment.position + prevSegment.rotation * Vector3.Scale(prevSegment.scale, prevSegment.downSocket.localPosition);
						Quaternion val12 = prevSegment.rotation * prevSegment.downSocket.localRotation;
						Prefab<DungeonGridLink>[] array9 = array5;
						foreach (Prefab<DungeonGridLink> prefab14 in array9)
						{
							float num11 = SeedRandom.Value(ref seed);
							DungeonGridLink component = prefab14.Component;
							if (prevSegment.downType != component.UpType)
							{
								continue;
							}
							switch (component.DownType)
							{
							case DungeonGridLinkType.Elevator:
								if (flag6 || val9.x != 0f || val9.z != 0f)
								{
									continue;
								}
								break;
							case DungeonGridLinkType.Transition:
								if (val9.x != 0f || val9.z != 0f)
								{
									continue;
								}
								break;
							}
							int num12 = ((!flag6) ? component.Priority : 0);
							if (num10 > num12)
							{
								continue;
							}
							Quaternion val13 = val12 * Quaternion.Inverse(component.UpSocket.localRotation);
							Quaternion val14 = val13 * component.DownSocket.localRotation;
							PathLinkSegment prevSegment2 = item6.upwards.prevSegment;
							Quaternion val15 = prevSegment2.rotation * prevSegment2.upSocket.localRotation;
							if (component.Rotation > 0)
							{
								if (Quaternion.Angle(val15, val14) > (float)component.Rotation)
								{
									continue;
								}
								Quaternion val16 = val15 * Quaternion.Inverse(val14);
								val13 *= val16;
								val14 *= val16;
							}
							Vector3 val17 = val11 - val13 * component.UpSocket.localPosition;
							Vector3 val18 = val13 * (component.DownSocket.localPosition - component.UpSocket.localPosition);
							Vector3 val19 = val8 + val10;
							Vector3 val20 = val8 + val18;
							float magnitude = ((Vector3)(ref val19)).magnitude;
							float magnitude2 = ((Vector3)(ref val20)).magnitude;
							Vector3 val21 = Vector3.Scale(val19, val9);
							Vector3 val22 = Vector3.Scale(val20, val9);
							float magnitude3 = ((Vector3)(ref val21)).magnitude;
							float magnitude4 = ((Vector3)(ref val22)).magnitude;
							if (val10 != Vector3.zero)
							{
								if (magnitude3 < magnitude4 || (magnitude3 == magnitude4 && magnitude < magnitude2) || (magnitude3 == magnitude4 && magnitude == magnitude2 && num11 < 0.5f))
								{
									continue;
								}
							}
							else if (magnitude3 <= magnitude4)
							{
								continue;
							}
							if (Mathf.Abs(val22.x) - Mathf.Abs(val21.x) > 0.01f || (Mathf.Abs(val22.x) > 0.01f && val19.x * val20.x < 0f) || Mathf.Abs(val22.y) - Mathf.Abs(val21.y) > 0.01f || (Mathf.Abs(val22.y) > 0.01f && val19.y * val20.y < 0f) || Mathf.Abs(val22.z) - Mathf.Abs(val21.z) > 0.01f || (Mathf.Abs(val22.z) > 0.01f && val19.z * val20.z < 0f) || (flag6 && val9.x == 0f && val9.z == 0f && component.DownType == DungeonGridLinkType.Default && ((Mathf.Abs(val20.x) > 0.01f && Mathf.Abs(val20.x) < LinkRadius * 2f - 0.1f) || (Mathf.Abs(val20.z) > 0.01f && Mathf.Abs(val20.z) < LinkRadius * 2f - 0.1f))))
							{
								continue;
							}
							num10 = num12;
							if (val9.x == 0f && val9.z == 0f)
							{
								if (!flag6 && Mathf.Abs(val20.y) < LinkTransition - 0.1f)
								{
									continue;
								}
							}
							else if ((!flag6 && magnitude4 > 0.01f && (Mathf.Abs(val20.x) < LinkRadius * 2f - 0.1f || Mathf.Abs(val20.z) < LinkRadius * 2f - 0.1f)) || (!flag7 && magnitude4 > 0.01f && (Mathf.Abs(val20.x) < LinkRadius * 1f - 0.1f || Mathf.Abs(val20.z) < LinkRadius * 1f - 0.1f)))
							{
								continue;
							}
							if (!flag6 || !(magnitude4 < 0.01f) || !(magnitude2 < 0.01f) || !(Quaternion.Angle(val15, val14) > 10f))
							{
								prefab13 = prefab14;
								val10 = val18;
								num10 = num12;
								position3 = val17;
								rotation2 = val13;
							}
						}
						if (val10 != Vector3.zero)
						{
							PathLinkSegment pathLinkSegment = new PathLinkSegment();
							pathLinkSegment.position = position3;
							pathLinkSegment.rotation = rotation2;
							pathLinkSegment.scale = Vector3.one;
							pathLinkSegment.prefab = prefab13;
							pathLinkSegment.link = prefab13.Component;
							item6.downwards.segments.Add(pathLinkSegment);
							val8 += val10;
						}
						else
						{
							num9++;
						}
						if (val9.x > 0f || val9.z > 0f)
						{
							Prefab<DungeonGridLink> prefab15 = null;
							Vector3 val23 = Vector3.zero;
							int num13 = int.MinValue;
							Vector3 position4 = Vector3.zero;
							Quaternion rotation3 = Quaternion.identity;
							PathLinkSegment prevSegment3 = item6.upwards.prevSegment;
							Vector3 val24 = prevSegment3.position + prevSegment3.rotation * Vector3.Scale(prevSegment3.scale, prevSegment3.upSocket.localPosition);
							Quaternion val25 = prevSegment3.rotation * prevSegment3.upSocket.localRotation;
							array9 = array5;
							foreach (Prefab<DungeonGridLink> prefab16 in array9)
							{
								float num14 = SeedRandom.Value(ref seed);
								DungeonGridLink component2 = prefab16.Component;
								if (prevSegment3.upType != component2.DownType)
								{
									continue;
								}
								switch (component2.DownType)
								{
								case DungeonGridLinkType.Elevator:
									if (flag6 || val9.x != 0f || val9.z != 0f)
									{
										continue;
									}
									break;
								case DungeonGridLinkType.Transition:
									if (val9.x != 0f || val9.z != 0f)
									{
										continue;
									}
									break;
								}
								int num15 = ((!flag6) ? component2.Priority : 0);
								if (num13 > num15)
								{
									continue;
								}
								Quaternion val26 = val25 * Quaternion.Inverse(component2.DownSocket.localRotation);
								Quaternion val27 = val26 * component2.UpSocket.localRotation;
								PathLinkSegment prevSegment4 = item6.downwards.prevSegment;
								Quaternion val28 = prevSegment4.rotation * prevSegment4.downSocket.localRotation;
								if (component2.Rotation > 0)
								{
									if (Quaternion.Angle(val28, val27) > (float)component2.Rotation)
									{
										continue;
									}
									Quaternion val29 = val28 * Quaternion.Inverse(val27);
									val26 *= val29;
									val27 *= val29;
								}
								Vector3 val30 = val24 - val26 * component2.DownSocket.localPosition;
								Vector3 val31 = val26 * (component2.UpSocket.localPosition - component2.DownSocket.localPosition);
								Vector3 val32 = val8 - val23;
								Vector3 val33 = val8 - val31;
								float magnitude5 = ((Vector3)(ref val32)).magnitude;
								float magnitude6 = ((Vector3)(ref val33)).magnitude;
								Vector3 val34 = Vector3.Scale(val32, val9);
								Vector3 val35 = Vector3.Scale(val33, val9);
								float magnitude7 = ((Vector3)(ref val34)).magnitude;
								float magnitude8 = ((Vector3)(ref val35)).magnitude;
								if (val23 != Vector3.zero)
								{
									if (magnitude7 < magnitude8 || (magnitude7 == magnitude8 && magnitude5 < magnitude6) || (magnitude7 == magnitude8 && magnitude5 == magnitude6 && num14 < 0.5f))
									{
										continue;
									}
								}
								else if (magnitude7 <= magnitude8)
								{
									continue;
								}
								if (Mathf.Abs(val35.x) - Mathf.Abs(val34.x) > 0.01f || (Mathf.Abs(val35.x) > 0.01f && val32.x * val33.x < 0f) || Mathf.Abs(val35.y) - Mathf.Abs(val34.y) > 0.01f || (Mathf.Abs(val35.y) > 0.01f && val32.y * val33.y < 0f) || Mathf.Abs(val35.z) - Mathf.Abs(val34.z) > 0.01f || (Mathf.Abs(val35.z) > 0.01f && val32.z * val33.z < 0f) || (flag6 && val9.x == 0f && val9.z == 0f && component2.UpType == DungeonGridLinkType.Default && ((Mathf.Abs(val33.x) > 0.01f && Mathf.Abs(val33.x) < LinkRadius * 2f - 0.1f) || (Mathf.Abs(val33.z) > 0.01f && Mathf.Abs(val33.z) < LinkRadius * 2f - 0.1f))))
								{
									continue;
								}
								num13 = num15;
								if (val9.x == 0f && val9.z == 0f)
								{
									if (!flag6 && Mathf.Abs(val33.y) < LinkTransition - 0.1f)
									{
										continue;
									}
								}
								else if ((!flag6 && magnitude8 > 0.01f && (Mathf.Abs(val33.x) < LinkRadius * 2f - 0.1f || Mathf.Abs(val33.z) < LinkRadius * 2f - 0.1f)) || (!flag7 && magnitude8 > 0.01f && (Mathf.Abs(val33.x) < LinkRadius * 1f - 0.1f || Mathf.Abs(val33.z) < LinkRadius * 1f - 0.1f)))
								{
									continue;
								}
								if (!flag6 || !(magnitude8 < 0.01f) || !(magnitude6 < 0.01f) || !(Quaternion.Angle(val28, val27) > 10f))
								{
									prefab15 = prefab16;
									val23 = val31;
									num13 = num15;
									position4 = val30;
									rotation3 = val26;
								}
							}
							if (val23 != Vector3.zero)
							{
								PathLinkSegment pathLinkSegment2 = new PathLinkSegment();
								pathLinkSegment2.position = position4;
								pathLinkSegment2.rotation = rotation3;
								pathLinkSegment2.scale = Vector3.one;
								pathLinkSegment2.prefab = prefab15;
								pathLinkSegment2.link = prefab15.Component;
								item6.upwards.segments.Add(pathLinkSegment2);
								val8 -= val23;
							}
							else
							{
								num8++;
							}
						}
						else
						{
							num8++;
						}
					}
				}
			}
			foreach (PathLink item7 in list3)
			{
				foreach (PathLinkSegment segment2 in item7.downwards.segments)
				{
					World.AddPrefab("Dungeon", segment2.prefab, segment2.position, segment2.rotation, segment2.scale);
				}
				foreach (PathLinkSegment segment3 in item7.upwards.segments)
				{
					World.AddPrefab("Dungeon", segment3.prefab, segment3.position, segment3.rotation, segment3.scale);
				}
			}
			if (TerrainMeta.Path.Rails.Count > 0)
			{
				List<PrefabReplacement> list8 = new List<PrefabReplacement>();
				Vector2i val36 = default(Vector2i);
				for (int num16 = 0; num16 < val.CellCount; num16++)
				{
					for (int num17 = 0; num17 < val.CellCount; num17++)
					{
						Prefab<DungeonGridCell> prefab17 = val[num16, num17];
						if (prefab17 == null || !prefab17.Component.Replaceable)
						{
							continue;
						}
						((Vector2i)(ref val36))..ctor(num16, num17);
						Vector3 val37 = val.GridToWorldCoords(val36) + zero2;
						Prefab<DungeonGridCell>[] array7 = array3;
						foreach (Prefab<DungeonGridCell> prefab18 in array7)
						{
							if (prefab17.Component.North != prefab18.Component.North || prefab17.Component.South != prefab18.Component.South || prefab17.Component.West != prefab18.Component.West || prefab17.Component.East != prefab18.Component.East || !IsValidPrefabPlacement(prefab18, val37, Quaternion.identity, Vector3.one, EnvironmentType.Underground) || !prefab18.ApplyTerrainChecks(val37, Quaternion.identity, Vector3.one) || !prefab18.ApplyTerrainFilters(val37, Quaternion.identity, Vector3.one))
							{
								continue;
							}
							MonumentInfo componentInChildren6 = prefab18.Object.GetComponentInChildren<MonumentInfo>();
							Vector3 val38 = val37;
							if (Object.op_Implicit((Object)(object)componentInChildren6))
							{
								val38 += ((Component)componentInChildren6).transform.position;
							}
							if (!(val38.y < 1f))
							{
								float distanceToAboveGroundRail = GetDistanceToAboveGroundRail(val38);
								if (!(distanceToAboveGroundRail < 200f))
								{
									PrefabReplacement item = default(PrefabReplacement);
									item.gridPosition = val36;
									item.worldPosition = val38;
									item.distance = Mathf.RoundToInt(distanceToAboveGroundRail);
									item.prefab = prefab18;
									list8.Add(item);
								}
							}
						}
					}
				}
				ListEx.Shuffle<PrefabReplacement>(list8, ref seed);
				list8.Sort((PrefabReplacement a, PrefabReplacement b) => a.distance.CompareTo(b.distance));
				int num18 = 2;
				while (num18 > 0 && list8.Count > 0)
				{
					num18--;
					PrefabReplacement replacement = list8[0];
					val[replacement.gridPosition.x, replacement.gridPosition.y] = replacement.prefab;
					list8.RemoveAll(delegate(PrefabReplacement a)
					{
						//IL_0001: Unknown result type (might be due to invalid IL or missing references)
						//IL_000c: Unknown result type (might be due to invalid IL or missing references)
						//IL_0011: Unknown result type (might be due to invalid IL or missing references)
						//IL_0016: Unknown result type (might be due to invalid IL or missing references)
						Vector3 val39 = a.worldPosition - replacement.worldPosition;
						return ((Vector3)(ref val39)).magnitude < 1500f;
					});
				}
			}
			Vector2i val40 = default(Vector2i);
			for (int num19 = 0; num19 < val.CellCount; num19++)
			{
				for (int num20 = 0; num20 < val.CellCount; num20++)
				{
					Prefab<DungeonGridCell> prefab19 = val[num19, num20];
					if (prefab19 != null)
					{
						((Vector2i)(ref val40))..ctor(num19, num20);
						Vector3 val41 = val.GridToWorldCoords(val40);
						World.AddPrefab("Dungeon", prefab19, zero2 + val41, Quaternion.identity, Vector3.one);
					}
				}
			}
			Vector2i val42 = default(Vector2i);
			Vector2i val44 = default(Vector2i);
			for (int num21 = 0; num21 < val.CellCount - 1; num21++)
			{
				for (int num22 = 0; num22 < val.CellCount - 1; num22++)
				{
					Prefab<DungeonGridCell> prefab20 = val[num21, num22];
					Prefab<DungeonGridCell> prefab21 = val[num21 + 1, num22];
					Prefab<DungeonGridCell> prefab22 = val[num21, num22 + 1];
					Prefab<DungeonGridCell>[] array7;
					if (prefab20 != null && prefab21 != null && prefab20.Component.EastVariant != prefab21.Component.WestVariant)
					{
						array4.Shuffle(ref seed);
						array7 = array4;
						foreach (Prefab<DungeonGridCell> prefab23 in array7)
						{
							if (prefab23.Component.West == prefab20.Component.East && prefab23.Component.East == prefab21.Component.West && prefab23.Component.WestVariant == prefab20.Component.EastVariant && prefab23.Component.EastVariant == prefab21.Component.WestVariant)
							{
								((Vector2i)(ref val42))..ctor(num21, num22);
								Vector3 val43 = val.GridToWorldCoords(val42) + new Vector3(val.CellSizeHalf, 0f, 0f);
								World.AddPrefab("Dungeon", prefab23, zero2 + val43, Quaternion.identity, Vector3.one);
								break;
							}
						}
					}
					if (prefab20 == null || prefab22 == null || prefab20.Component.NorthVariant == prefab22.Component.SouthVariant)
					{
						continue;
					}
					array4.Shuffle(ref seed);
					array7 = array4;
					foreach (Prefab<DungeonGridCell> prefab24 in array7)
					{
						if (prefab24.Component.South == prefab20.Component.North && prefab24.Component.North == prefab22.Component.South && prefab24.Component.SouthVariant == prefab20.Component.NorthVariant && prefab24.Component.NorthVariant == prefab22.Component.SouthVariant)
						{
							((Vector2i)(ref val44))..ctor(num21, num22);
							Vector3 val45 = val.GridToWorldCoords(val44) + new Vector3(0f, 0f, val.CellSizeHalf);
							World.AddPrefab("Dungeon", prefab24, zero2 + val45, Quaternion.identity, Vector3.one);
							break;
						}
					}
				}
			}
		}
		bool IsValidPrefabPlacement(Prefab<DungeonGridCell> prefab, Vector3 pos, Quaternion rot, Vector3 scale, EnvironmentType type)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_000a: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0066: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_007d: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val46 = Vector3.up * 9f;
			Vector3 val47 = Vector3.up * (LinkTransition + 1f);
			if (!prefab.CheckEnvironmentVolumesBelowAltitude(pos + val46, rot, scale, EnvironmentType.Underground, EnvironmentType.Entrance) && !prefab.CheckEnvironmentVolumesInsideTerrain(pos + val46, rot, scale, EnvironmentType.TrainTunnels, EnvironmentType.Entrance))
			{
				return false;
			}
			if (prefab.CheckEnvironmentVolumes(pos + val47, rot, scale, type))
			{
				return false;
			}
			if (prefab.CheckEnvironmentVolumes(pos, rot, scale, type))
			{
				return false;
			}
			return true;
		}
	}

	private float GetDistanceToAboveGroundRail(Vector3 pos)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		if (Object.op_Implicit((Object)(object)TerrainMeta.Path))
		{
			foreach (PathList rail in TerrainMeta.Path.Rails)
			{
				Vector3[] points = rail.Path.Points;
				foreach (Vector3 val in points)
				{
					num = Mathf.Min(num, Vector3Ex.Distance2D(val, pos));
				}
			}
		}
		return num;
	}
}


private class PathNode
{
	public MonumentInfo monument;

	public PathFinder.Node node;
}


private class PathSegment
{
	public PathFinder.Node start;

	public PathFinder.Node end;
}


private class PathLink
{
	public PathLinkSide downwards;

	public PathLinkSide upwards;
}


using System.Collections.Generic;

private class PathLinkSide
{
	public PathLinkSegment origin;

	public List<PathLinkSegment> segments;

	public PathLinkSegment prevSegment
	{
		get
		{
			if (segments.Count <= 0)
			{
				return origin;
			}
			return segments[segments.Count - 1];
		}
	}
}


using UnityEngine;

private class PathLinkSegment
{
	public Vector3 position;

	public Quaternion rotation;

	public Vector3 scale;

	public Prefab<DungeonGridLink> prefab;

	public DungeonGridLink link;

	public Transform downSocket => link.DownSocket;

	public Transform upSocket => link.UpSocket;

	public DungeonGridLinkType downType => link.DownType;

	public DungeonGridLinkType upType => link.UpType;
}


using UnityEngine;

private struct PrefabReplacement
{
	public Vector2i gridPosition;

	public Vector3 worldPosition;

	public int distance;

	public Prefab<DungeonGridCell> prefab;
}


